<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter - AI Terakoya</title>

    <style>
        :root {
            --color-primary: #2c3e50;
            --color-primary-dark: #1a252f;
            --color-accent: #7b2cbf;
            --color-accent-light: #9d4edd;
            --color-text: #2d3748;
            --color-text-light: #4a5568;
            --color-bg: #ffffff;
            --color-bg-alt: #f7fafc;
            --color-border: #e2e8f0;
            --color-code-bg: #f8f9fa;
            --color-link: #3182ce;
            --color-link-hover: #2c5aa0;

            --spacing-xs: 0.5rem;
            --spacing-sm: 1rem;
            --spacing-md: 1.5rem;
            --spacing-lg: 2rem;
            --spacing-xl: 3rem;

            --font-body: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            --font-mono: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;

            --border-radius: 8px;
            --box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-body);
            line-height: 1.7;
            color: var(--color-text);
            background-color: var(--color-bg);
            font-size: 16px;
        }

        header {
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            color: white;
            padding: var(--spacing-xl) var(--spacing-md);
            margin-bottom: var(--spacing-xl);
            box-shadow: var(--box-shadow);
        }

        .header-content {
            max-width: 900px;
            margin: 0 auto;
        }

        h1 {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: var(--spacing-sm);
            line-height: 1.2;
        }

        .subtitle {
            font-size: 1.1rem;
            opacity: 0.95;
            font-weight: 400;
            margin-bottom: var(--spacing-md);
        }

        .meta {
            display: flex;
            flex-wrap: wrap;
            gap: var(--spacing-md);
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .meta-item {
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 0 var(--spacing-md) var(--spacing-xl);
        }

        h2 {
            font-size: 1.75rem;
            color: var(--color-primary);
            margin-top: var(--spacing-xl);
            margin-bottom: var(--spacing-md);
            padding-bottom: var(--spacing-xs);
            border-bottom: 3px solid var(--color-accent);
        }

        h3 {
            font-size: 1.4rem;
            color: var(--color-primary);
            margin-top: var(--spacing-lg);
            margin-bottom: var(--spacing-sm);
        }

        h4 {
            font-size: 1.1rem;
            color: var(--color-primary-dark);
            margin-top: var(--spacing-md);
            margin-bottom: var(--spacing-sm);
        }

        p {
            margin-bottom: var(--spacing-md);
            color: var(--color-text);
        }

        a {
            color: var(--color-link);
            text-decoration: none;
            transition: color 0.2s;
        }

        a:hover {
            color: var(--color-link-hover);
            text-decoration: underline;
        }

        ul, ol {
            margin-left: var(--spacing-lg);
            margin-bottom: var(--spacing-md);
        }

        li {
            margin-bottom: var(--spacing-xs);
            color: var(--color-text);
        }

        pre {
            background-color: var(--color-code-bg);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            overflow-x: auto;
            margin-bottom: var(--spacing-md);
            font-family: var(--font-mono);
            font-size: 0.9rem;
            line-height: 1.5;
        }

        code {
            font-family: var(--font-mono);
            font-size: 0.9em;
            background-color: var(--color-code-bg);
            padding: 0.2em 0.4em;
            border-radius: 3px;
        }

        pre code {
            background-color: transparent;
            padding: 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: var(--spacing-md);
            font-size: 0.95rem;
        }

        th, td {
            border: 1px solid var(--color-border);
            padding: var(--spacing-sm);
            text-align: left;
        }

        th {
            background-color: var(--color-bg-alt);
            font-weight: 600;
            color: var(--color-primary);
        }

        blockquote {
            border-left: 4px solid var(--color-accent);
            padding-left: var(--spacing-md);
            margin: var(--spacing-md) 0;
            color: var(--color-text-light);
            font-style: italic;
            background-color: var(--color-bg-alt);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        .mermaid {
            text-align: center;
            margin: var(--spacing-lg) 0;
            background-color: var(--color-bg-alt);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        details {
            background-color: var(--color-bg-alt);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            margin-bottom: var(--spacing-md);
        }

        summary {
            cursor: pointer;
            font-weight: 600;
            color: var(--color-primary);
            user-select: none;
            padding: var(--spacing-xs);
            margin: calc(-1 * var(--spacing-md));
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        summary:hover {
            background-color: rgba(123, 44, 191, 0.1);
        }

        details[open] summary {
            margin-bottom: var(--spacing-md);
            border-bottom: 1px solid var(--color-border);
        }

        .learning-objectives {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            padding: var(--spacing-lg);
            border-radius: var(--border-radius);
            border-left: 4px solid var(--color-accent);
            margin-bottom: var(--spacing-xl);
        }

        .learning-objectives h2 {
            margin-top: 0;
            border-bottom: none;
        }

        .navigation {
            display: flex;
            justify-content: space-between;
            gap: var(--spacing-md);
            margin: var(--spacing-xl) 0;
            padding-top: var(--spacing-lg);
            border-top: 2px solid var(--color-border);
        }

        .nav-button {
            flex: 1;
            padding: var(--spacing-md);
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            color: white;
            border-radius: var(--border-radius);
            text-align: center;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: var(--box-shadow);
        }

        .nav-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            text-decoration: none;
        }

        footer {
            margin-top: var(--spacing-xl);
            padding: var(--spacing-lg) var(--spacing-md);
            background-color: var(--color-bg-alt);
            border-top: 1px solid var(--color-border);
            text-align: center;
            font-size: 0.9rem;
            color: var(--color-text-light);
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.5rem;
            }

            h2 {
                font-size: 1.4rem;
            }

            h3 {
                font-size: 1.2rem;
            }

            .meta {
                font-size: 0.85rem;
            }

            .navigation {
                flex-direction: column;
            }

            table {
                font-size: 0.85rem;
            }

            th, td {
                padding: var(--spacing-xs);
            }
        }
    </style>

    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <script>
        mermaid.initialize({ startOnLoad: true, theme: 'default', securityLevel: 'strict' });
    </script>

    <!-- MathJax for LaTeX equation rendering -->
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\(', '\)']],
                displayMath: [['$$', '$$'], ['\[', '\]']],
                processEscapes: true,
                processEnvironments: true
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
                ignoreHtmlClass: 'mermaid'
            }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" id="MathJax-script" async></script>
</head>
<body>
    <header>
        <div class="header-content">
            <h1>Chapter</h1>
            <p class="subtitle"></p>
            <div class="meta">
                <span class="meta-item">üìñ Ë™≠‰∫ÜÊôÇÈñì: 20-25ÂàÜ</span>
                <span class="meta-item">üìä Èõ£ÊòìÂ∫¶: ÂàùÁ¥ö</span>
                <span class="meta-item">üíª „Ç≥„Éº„Éâ‰æã: 0ÂÄã</span>
                <span class="meta-item">üìù ÊºîÁøíÂïèÈ°å: 0Âïè</span>
            </div>
        </div>
    </header>

    <main class="container">
<h1>Á¨¨3Á´†: „ÇØ„É≠„Éº„Ç∫„Éâ„É´„Éº„ÉóÊúÄÈÅ©Âåñ</h1>
<p><strong>Â≠¶ÁøíÊôÇÈñì: 25-30ÂàÜ</strong></p>
<hr />
<h2>Â∞éÂÖ•</h2>
<p>ÂÆüÈ®ìËá™ÂãïÂåñ„ÅÆÁúü„ÅÆ‰æ°ÂÄ§„ÅØ„ÄÅÂçò„Å™„Çã„Çπ„É´„Éº„Éó„ÉÉ„ÉàÂêë‰∏ä„Å´„Å®„Å©„Åæ„Çä„Åæ„Åõ„Çì„ÄÇ„Éô„Ç§„Ç∫ÊúÄÈÅ©Âåñ„ÇÑ„Ç¢„ÇØ„ÉÜ„Ç£„Éñ„É©„Éº„Éã„É≥„Ç∞„Å®Áµ±Âêà„Åô„Çã„Åì„Å®„Åß„ÄÅ<strong>‰∫∫Èñì„ÅÆ‰ªãÂÖ•„Å™„Åó„Å´Ëá™ÂæãÁöÑ„Å´ÊúÄÈÅ©„Å™ÊùêÊñô„ÇíÊé¢Á¥¢„Åô„Çã„Ç∑„Çπ„ÉÜ„É†</strong>„ÇíÊßãÁØâ„Åß„Åç„Åæ„Åô„ÄÇ</p>
<p>Êú¨Á´†„Åß„ÅØ„ÄÅÂÆüÈ®ì‚ÜíÊ∏¨ÂÆö‚ÜíËß£Êûê‚Üí‰∫àÊ∏¨‚ÜíÊ¨°ÂÆüÈ®ìÊèêÊ°à„Å®„ÅÑ„ÅÜ<strong>„ÇØ„É≠„Éº„Ç∫„Éâ„É´„Éº„ÉóÔºàClosed-LoopÔºâ</strong>„ÇíËá™ÂãïÂåñ„Åô„ÇãÊäÄË°ì„ÇíÂ≠¶„Å≥„Åæ„Åô„ÄÇÈáèÂ≠ê„Éâ„ÉÉ„Éà„ÅÆÁô∫ÂÖâÊ≥¢Èï∑ÊúÄÈÅ©Âåñ„ÄÅËß¶Â™í„ÅÆÊ¥ªÊÄßÊúÄÂ§ßÂåñ„Å™„Å©„ÄÅÂÆüÈöõ„ÅÆÊùêÊñôÊé¢Á¥¢ÂïèÈ°å„Å´ÈÅ©Áî®„Åß„Åç„ÇãPythonÂÆüË£Ö„ÇíÁøíÂæó„Åó„Åæ„Åô„ÄÇ</p>
<hr />
<h2>Â≠¶ÁøíÁõÆÊ®ô</h2>
<p>Êú¨Á´†„ÇíÂ≠¶Áøí„Åô„Çã„Åì„Å®„Åß„ÄÅ‰ª•‰∏ã„ÇíÁøíÂæó„Åß„Åç„Åæ„ÅôÔºö</p>
<ol>
<li><strong>„ÇØ„É≠„Éº„Ç∫„Éâ„É´„Éº„Éó„ÅÆÊ¶ÇÂøµ</strong>: ÂÆüÈ®ì„Å®Ê©üÊ¢∞Â≠¶Áøí„ÅÆÁµ±Âêà„Ç¢„Éº„Ç≠„ÉÜ„ÇØ„ÉÅ„É£</li>
<li><strong>„Éô„Ç§„Ç∫ÊúÄÈÅ©Âåñ„Å®„ÅÆÁµ±Âêà</strong>: „Ç¨„Ç¶„ÇπÈÅéÁ®ã„Å´„Çà„ÇãÊ¨°ÂÆüÈ®ìÂÄôË£ú„ÅÆËá™ÂãïÊèêÊ°à</li>
<li><strong>„Ç¢„ÇØ„ÉÜ„Ç£„Éñ„É©„Éº„Éã„É≥„Ç∞</strong>: ÂäπÁéáÁöÑ„Å™„Éá„Éº„ÇøÂèéÈõÜÊà¶Áï•</li>
<li><strong>PythonÂÆüË£Ö</strong>: scikit-optimize„ÄÅBoTorch„Çí‰Ωø„Å£„ÅüÂÆüË∑µÁöÑ„Ç≥„Éº„Éâ</li>
<li><strong>„Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥Áí∞Â¢É</strong>: PyBullet„Å´„Çà„Çã‰ªÆÊÉ≥„É≠„Éú„ÉÉ„ÉàÂÆüÈ®ì</li>
<li><strong>ÂÆü„Éá„Éº„Çø„Åß„ÅÆ„Éá„É¢</strong>: ÈáèÂ≠ê„Éâ„ÉÉ„ÉàÁô∫ÂÖâÊ≥¢Èï∑„ÅÆËá™ÂãïÊúÄÈÅ©Âåñ</li>
</ol>
<hr />
<h2>3.1 „ÇØ„É≠„Éº„Ç∫„Éâ„É´„Éº„ÉóÊúÄÈÅ©Âåñ„ÅÆÊ¶ÇÂøµ</h2>
<h3>3.1.1 ÂæìÊù•„ÅÆÊâãÂãïÊúÄÈÅ©Âåñ vs „ÇØ„É≠„Éº„Ç∫„Éâ„É´„Éº„Éó</h3>
<p><strong>ÂæìÊù•„ÅÆÊâãÂãïÊúÄÈÅ©Âåñ</strong>:
1. Á†îÁ©∂ËÄÖ„ÅåÁõ¥ÊÑü„ÅßÂÆüÈ®ìÊù°‰ª∂„ÇíÊ±∫ÂÆö
2. ÂÆüÈ®ì„ÇíÂÆüË°åÔºà1-2Êó•Ôºâ
3. „Éá„Éº„Çø„ÇíËß£Êûê
4. Ê¨°„ÅÆÂÆüÈ®ìÊù°‰ª∂„ÇíËÄÉÊ°àÔºà1-2Êó•Ôºâ
5. „Çπ„ÉÜ„ÉÉ„Éó1-4„ÇíÁπ∞„ÇäËøî„Åó</p>
<p><strong>ÂïèÈ°åÁÇπ</strong>:
- ‰∫∫Èñì„ÅÆË™çÁü•„Éê„Ç§„Ç¢„ÇπÔºàÂ±ÄÊâÄÊúÄÈÅ©„Å´Èô•„Çä„ÇÑ„Åô„ÅÑÔºâ
- Â§öÊ¨°ÂÖÉ„Éë„É©„É°„Éº„ÇøÁ©∫Èñì„ÅÆÊé¢Á¥¢„ÅåÂõ∞Èõ£
- ÂÆüÈ®ì„Å®Ëß£Êûê„ÅÆÈñì„Å´„Çø„Ç§„É†„É©„Ç∞
- Â§úÈñì„ÉªÈÄ±Êú´„ÅØÂÆüÈ®ì„ÅåÊ≠¢„Åæ„Çã</p>
<p><strong>„ÇØ„É≠„Éº„Ç∫„Éâ„É´„Éº„ÉóÊúÄÈÅ©Âåñ</strong>:</p>
<div class="mermaid">
flowchart LR
    A[ÂÆüÈ®ìË®àÁîª\n„Éô„Ç§„Ç∫ÊúÄÈÅ©Âåñ] --> B[„É≠„Éú„ÉÉ„ÉàÂÆüÈ®ì\nËá™ÂãïÂêàÊàê]
    B --> C[Ê∏¨ÂÆö\n„Çª„É≥„Çµ„ÉºËá™ÂãïÂèñÂæó]
    C --> D[„Éá„Éº„ÇøËß£Êûê\nÁâπÊÄßË©ï‰æ°]
    D --> E[„É¢„Éá„É´Êõ¥Êñ∞\n„Ç¨„Ç¶„ÇπÈÅéÁ®ã]
    E --> A

    style A fill:#e1f5ff
    style B fill:#fff4e1
    style C fill:#ffe1e1
    style D fill:#f0e1ff
    style E fill:#e1ffe1
</div>

<p><strong>Âà©ÁÇπ</strong>:
- 24ÊôÇÈñì365Êó•Á®ºÂÉç
- Ë™çÁü•„Éê„Ç§„Ç¢„Çπ„Å™„ÅóÔºà„Éá„Éº„ÇøÈßÜÂãïÔºâ
- Â§öÊ¨°ÂÖÉÊé¢Á¥¢„Å´Âº∑„ÅÑ
- ÂÆüÈ®ì‚ÜíËß£Êûê‚ÜíÊ¨°ÂÆüÈ®ì„ÅåÊï∞ÂàÜ„ÅßÂÆåÁµê</p>
<hr />
<h3>3.1.2 „ÇØ„É≠„Éº„Ç∫„Éâ„É´„Éº„Éó„ÅÆÊï∞Â≠¶ÁöÑÂÆöÂºèÂåñ</h3>
<p>ÊúÄÈÅ©ÂåñÂïèÈ°å:
$$
\mathbf{x}^* = \arg\max_{\mathbf{x} \in \mathcal{X}} f(\mathbf{x})
$$</p>
<p>„Åì„Åì„Åß:
- $\mathbf{x}$: ÂÆüÈ®ìÊù°‰ª∂ÔºàÊ∏©Â∫¶„ÄÅÊôÇÈñì„ÄÅÁµÑÊàê„Å™„Å©Ôºâ
- $f(\mathbf{x})$: ÁõÆÁöÑÈñ¢Êï∞ÔºàËß¶Â™íÊ¥ªÊÄß„ÄÅÁô∫ÂÖâÊ≥¢Èï∑„Å™„Å©Ôºâ
- $\mathcal{X}$: Êé¢Á¥¢Á©∫ÈñìÔºàË®±ÂÆπ„Åï„Çå„ÇãÂÆüÈ®ìÊù°‰ª∂„ÅÆÁØÑÂõ≤Ôºâ</p>
<p><strong>Ë™≤È°å</strong>: $f(\mathbf{x})$„ÅØÊú™Áü•Èñ¢Êï∞„Åß„ÄÅÂÆüÈ®ì„Åß„Åó„ÅãË©ï‰æ°„Åß„Åç„Å™„ÅÑÔºàË®àÁÆó„Ç≥„Çπ„Éà„ÅåÈ´ò„ÅÑÔºâ</p>
<p><strong>Ëß£Ê±∫Á≠ñ</strong>: „Éô„Ç§„Ç∫ÊúÄÈÅ©Âåñ
1. <strong>„Çµ„É≠„Ç≤„Éº„Éà„É¢„Éá„É´</strong>: „Ç¨„Ç¶„ÇπÈÅéÁ®ã„Åß$f(\mathbf{x})$„ÇíËøë‰ºº
2. <strong>Áç≤ÂæóÈñ¢Êï∞</strong>: Ê¨°„Å´„Å©„Åì„ÇíÂÆüÈ®ì„Åô„Åπ„Åç„ÅãÊèêÊ°àÔºàÊé¢Á¥¢„Å®Ê¥ªÁî®„ÅÆ„Éê„É©„É≥„ÇπÔºâ
3. <strong>ÂèçÂæ©</strong>: ÂÆüÈ®ì‚Üí„É¢„Éá„É´Êõ¥Êñ∞‚ÜíÊ¨°ÂÄôË£úÊèêÊ°à„ÇíÁπ∞„ÇäËøî„Åó</p>
<hr />
<h2>3.2 „Éô„Ç§„Ç∫ÊúÄÈÅ©Âåñ„Å®„ÅÆÁµ±Âêà</h2>
<h3>3.2.1 „Ç¨„Ç¶„ÇπÈÅéÁ®ã„ÅÆÂü∫Á§é</h3>
<p>„Ç¨„Ç¶„ÇπÈÅéÁ®ãÔºàGaussian Process, GPÔºâ„ÅØ„ÄÅÈñ¢Êï∞Á©∫Èñì‰∏ä„ÅÆÁ¢∫ÁéáÂàÜÂ∏É„Åß„Åô„ÄÇ</p>
<p><strong>Êï∞Â≠¶ÁöÑÂÆöÁæ©</strong>:
$$
f(\mathbf{x}) \sim \mathcal{GP}(m(\mathbf{x}), k(\mathbf{x}, \mathbf{x}'))
$$</p>
<ul>
<li>$m(\mathbf{x})$: Âπ≥ÂùáÈñ¢Êï∞ÔºàÈÄöÂ∏∏„ÅØ0Ôºâ</li>
<li>$k(\mathbf{x}, \mathbf{x}')$: „Ç´„Éº„Éç„É´Èñ¢Êï∞Ôºà2ÁÇπ„ÅÆÈ°û‰ººÂ∫¶Ôºâ</li>
</ul>
<p><strong>‰∫àÊ∏¨</strong>:
Ë¶≥Ê∏¨„Éá„Éº„Çø $\mathcal{D} = {(\mathbf{x}_i, y_i)}_{i=1}^n$ „Åå‰∏é„Åà„Çâ„Çå„Åü„Å®„Åç„ÄÅÊñ∞„Åó„ÅÑÁÇπ $\mathbf{x}_*$ „Åß„ÅÆ‰∫àÊ∏¨:</p>
<p>$$
\begin{aligned}
\mu(\mathbf{x}_*) &amp;= \mathbf{k}_*^\top (\mathbf{K} + \sigma^2 \mathbf{I})^{-1} \mathbf{y} \
\sigma^2(\mathbf{x}_*) &amp;= k(\mathbf{x}_*, \mathbf{x}_*) - \mathbf{k}_*^\top (\mathbf{K} + \sigma^2 \mathbf{I})^{-1} \mathbf{k}_*
\end{aligned}
$$</p>
<ul>
<li>$\mu(\mathbf{x}_*)$: ‰∫àÊ∏¨Âπ≥ÂùáÔºàÊúüÂæÖÂÄ§Ôºâ</li>
<li>$\sigma^2(\mathbf{x}_*)$: ‰∫àÊ∏¨ÂàÜÊï£Ôºà‰∏çÁ¢∫ÂÆüÊÄßÔºâ</li>
<li>$\mathbf{K}$: „Ç´„Éº„Éç„É´Ë°åÂàó„ÄÅ$[\mathbf{K}]_{ij} = k(\mathbf{x}_i, \mathbf{x}_j)$</li>
</ul>
<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
from sklearn.gaussian_process import GaussianProcessRegressor
from sklearn.gaussian_process.kernels import RBF, ConstantKernel as C

# Áúü„ÅÆÈñ¢Êï∞ÔºàÊú™Áü•„Å®‰ªÆÂÆöÔºâ
def true_function(x):
    &quot;&quot;&quot;
    ÊúÄÈÅ©ÂåñÂØæË±°„ÅÆÁúü„ÅÆÈñ¢Êï∞Ôºà‰æã: Ëß¶Â™íÊ¥ªÊÄßÔºâ
    ÂÆüÈöõ„ÅÆÂÆüÈ®ì„Åß„ÅØÊú™Áü•„Åß„ÄÅÂÆüÈ®ì„Åß„ÅÆ„ÅøË©ï‰æ°ÂèØËÉΩ
    &quot;&quot;&quot;
    return np.sin(3*x) + 0.3*np.cos(10*x) + 0.5*x

# ÂàùÊúüÂÆüÈ®ì„Éá„Éº„ÇøÔºà3ÁÇπÔºâ
np.random.seed(42)
X_init = np.array([0.2, 0.5, 0.8]).reshape(-1, 1)
y_init = true_function(X_init).ravel() + np.random.normal(0, 0.05, 3)  # „Éé„Ç§„Ç∫

# „Ç¨„Ç¶„ÇπÈÅéÁ®ã„É¢„Éá„É´„ÅÆÊßãÁØâ
kernel = C(1.0, (1e-3, 1e3)) * RBF(length_scale=0.2, length_scale_bounds=(1e-2, 1e2))
gp = GaussianProcessRegressor(kernel=kernel, n_restarts_optimizer=10, alpha=0.05**2)

# „É¢„Éá„É´„ÅÆÂ≠¶Áøí
gp.fit(X_init, y_init)

# ‰∫àÊ∏¨ÔºàÊé¢Á¥¢Á©∫ÈñìÂÖ®‰ΩìÔºâ
X_pred = np.linspace(0, 1, 100).reshape(-1, 1)
y_pred, sigma = gp.predict(X_pred, return_std=True)

# ÂèØË¶ñÂåñ
plt.figure(figsize=(12, 6))

# Áúü„ÅÆÈñ¢Êï∞
plt.plot(X_pred, true_function(X_pred), 'k--', label='Áúü„ÅÆÈñ¢Êï∞ÔºàÊú™Áü•Ôºâ', linewidth=2)

# „Ç¨„Ç¶„ÇπÈÅéÁ®ã„ÅÆ‰∫àÊ∏¨
plt.plot(X_pred, y_pred, 'b-', label='GP‰∫àÊ∏¨ÔºàÂπ≥ÂùáÔºâ', linewidth=2)
plt.fill_between(X_pred.ravel(),
                 y_pred - 1.96*sigma,  # 95%‰ø°È†ºÂå∫Èñì
                 y_pred + 1.96*sigma,
                 alpha=0.2, color='blue', label='95%‰ø°È†ºÂå∫Èñì')

# Ë¶≥Ê∏¨ÁÇπ
plt.plot(X_init, y_init, 'ro', markersize=12, label='ÂàùÊúüË¶≥Ê∏¨ÁÇπ', zorder=10)

plt.xlabel('ÂÆüÈ®ìÊù°‰ª∂ x', fontsize=12)
plt.ylabel('ÁõÆÁöÑÈñ¢Êï∞ f(x)', fontsize=12)
plt.title('„Ç¨„Ç¶„ÇπÈÅéÁ®ã„Å´„Çà„ÇãÈñ¢Êï∞Ëøë‰ºº', fontsize=14, fontweight='bold')
plt.legend()
plt.grid(alpha=0.3)
plt.tight_layout()
plt.savefig('gaussian_process_approximation.png', dpi=300, bbox_inches='tight')
plt.show()

print(&quot;„Ç¨„Ç¶„ÇπÈÅéÁ®ã„ÅÆÂ≠¶ÁøíÂÆå‰∫Ü&quot;)
print(f&quot;ÊúÄÈÅ©Âåñ„Åï„Çå„Åü„Ç´„Éº„Éç„É´„Éë„É©„É°„Éº„Çø: {gp.kernel_}&quot;)
</code></pre>
<p><strong>„Ç≥„Éº„ÉâËß£Ë™¨</strong>:
1. <strong>„Ç´„Éº„Éç„É´Èñ¢Êï∞</strong>: RBFÔºàRadial Basis FunctionÔºâ„Ç´„Éº„Éç„É´„Çí‰ΩøÁî®
   - <code>length_scale</code>: Èñ¢Êï∞„ÅÆÊªë„Çâ„Åã„Åï„ÇíÂà∂Âæ°
2. <strong>„Éé„Ç§„Ç∫</strong>: <code>alpha</code> „Éë„É©„É°„Éº„Çø„ÅßÊ∏¨ÂÆö„Éé„Ç§„Ç∫„ÇíËÄÉÊÖÆ
3. <strong>‰∫àÊ∏¨</strong>: Âπ≥Âùá $\mu(\mathbf{x})$ „Å®Ê®ôÊ∫ñÂÅèÂ∑Æ $\sigma(\mathbf{x})$ „ÇíÂêåÊôÇ„Å´Ë®àÁÆó
4. <strong>‰ø°È†ºÂå∫Èñì</strong>: $\mu \pm 1.96\sigma$ „Åß95%‰ø°È†ºÂå∫Èñì</p>
<hr />
<h3>3.2.2 Áç≤ÂæóÈñ¢Êï∞ÔºàAcquisition FunctionÔºâ</h3>
<p>Ê¨°„Å´„Å©„Åì„ÇíÂÆüÈ®ì„Åô„Åπ„Åç„Åã„ÇíÊ±∫„ÇÅ„ÇãÈñ¢Êï∞„ÄÇ<strong>Êé¢Á¥¢ÔºàExplorationÔºâ</strong>„Å®<strong>Ê¥ªÁî®ÔºàExploitationÔºâ</strong>„ÅÆ„Éà„É¨„Éº„Éâ„Ç™„Éï„ÇíËá™ÂãïË™øÊï¥„Åó„Åæ„Åô„ÄÇ</p>
<p><strong>‰∏ª„Å™Áç≤ÂæóÈñ¢Êï∞</strong>:</p>
<ol>
<li>
<p><strong>Expected Improvement (EI)</strong>:
$$
\text{EI}(\mathbf{x}) = \mathbb{E}[\max(f(\mathbf{x}) - f^+, 0)]
$$
ÊúÄËâØË¶≥Ê∏¨ÂÄ§ $f^+$ „ÇíË∂Ö„Åà„ÇãÊúüÂæÖÊîπÂñÑÈáè</p>
</li>
<li>
<p><strong>Upper Confidence Bound (UCB)</strong>:
$$
\text{UCB}(\mathbf{x}) = \mu(\mathbf{x}) + \kappa \sigma(\mathbf{x})
$$
‰∫àÊ∏¨Âπ≥Âùá + ‰∏çÁ¢∫ÂÆüÊÄßÔºà$\kappa$„ÅßË™øÊï¥Ôºâ</p>
</li>
<li>
<p><strong>Probability of Improvement (PI)</strong>:
$$
\text{PI}(\mathbf{x}) = P(f(\mathbf{x}) &gt; f^+)
$$</p>
</li>
</ol>
<pre><code class="language-python">from scipy.stats import norm

def expected_improvement(X, gp, f_best, xi=0.01):
    &quot;&quot;&quot;
    Expected ImprovementÁç≤ÂæóÈñ¢Êï∞

    Args:
        X: ÂÄôË£úÁÇπ
        gp: „Ç¨„Ç¶„ÇπÈÅéÁ®ã„É¢„Éá„É´
        f_best: ÁèæÂú®„ÅÆÊúÄËâØÂÄ§
        xi: Exploitation-Exploration trade-offÔºàÂ∞è„Åï„ÅÑ„Åª„Å©Ê¥ªÁî®ÈáçË¶ñÔºâ

    Returns:
        EIÂÄ§
    &quot;&quot;&quot;
    mu, sigma = gp.predict(X, return_std=True)

    # sigma=0„ÅÆÂ†¥ÂêàÔºàÊó¢„Å´Ë¶≥Ê∏¨Ê∏à„ÅøÔºâ„ÇíÂõûÈÅø
    sigma = np.maximum(sigma, 1e-9)

    # EIË®àÁÆó
    z = (mu - f_best - xi) / sigma
    ei = (mu - f_best - xi) * norm.cdf(z) + sigma * norm.pdf(z)

    return ei

def upper_confidence_bound(X, gp, kappa=2.0):
    &quot;&quot;&quot;
    Upper Confidence BoundÁç≤ÂæóÈñ¢Êï∞

    Args:
        X: ÂÄôË£úÁÇπ
        gp: „Ç¨„Ç¶„ÇπÈÅéÁ®ã„É¢„Éá„É´
        kappa: ExplorationÈáçË¶ñÂ∫¶ÔºàÂ§ß„Åç„ÅÑ„Åª„Å©Êé¢Á¥¢ÈáçË¶ñÔºâ

    Returns:
        UCBÂÄ§
    &quot;&quot;&quot;
    mu, sigma = gp.predict(X, return_std=True)
    return mu + kappa * sigma


# Áç≤ÂæóÈñ¢Êï∞„ÅÆÂèØË¶ñÂåñ
X_pred = np.linspace(0, 1, 100).reshape(-1, 1)
y_pred, sigma = gp.predict(X_pred, return_std=True)

# ÁèæÂú®„ÅÆÊúÄËâØÂÄ§
f_best = y_init.max()

# Áç≤ÂæóÈñ¢Êï∞„ÅÆË®àÁÆó
ei_values = expected_improvement(X_pred, gp, f_best)
ucb_values = upper_confidence_bound(X_pred, gp, kappa=2.0)

# ÂèØË¶ñÂåñ
fig, (ax1, ax2, ax3) = plt.subplots(3, 1, figsize=(12, 12))

# (1) „Ç¨„Ç¶„ÇπÈÅéÁ®ã„ÅÆ‰∫àÊ∏¨
ax1.plot(X_pred, true_function(X_pred), 'k--', label='Áúü„ÅÆÈñ¢Êï∞', linewidth=2)
ax1.plot(X_pred, y_pred, 'b-', label='GP‰∫àÊ∏¨', linewidth=2)
ax1.fill_between(X_pred.ravel(), y_pred - 1.96*sigma, y_pred + 1.96*sigma,
                 alpha=0.2, color='blue')
ax1.plot(X_init, y_init, 'ro', markersize=12, label='Ë¶≥Ê∏¨ÁÇπ')
ax1.axhline(y=f_best, color='red', linestyle=':', label=f'ÁèæÂú®„ÅÆÊúÄËâØÂÄ§ ({f_best:.2f})')
ax1.set_ylabel('ÁõÆÁöÑÈñ¢Êï∞ f(x)', fontsize=12)
ax1.set_title('(1) „Ç¨„Ç¶„ÇπÈÅéÁ®ã„ÅÆ‰∫àÊ∏¨', fontsize=13, fontweight='bold')
ax1.legend()
ax1.grid(alpha=0.3)

# (2) Expected Improvement
next_x_ei = X_pred[np.argmax(ei_values)]
ax2.plot(X_pred, ei_values, 'g-', linewidth=2)
ax2.axvline(x=next_x_ei, color='red', linestyle='--', label=f'Ê¨°ÂÄôË£ú (x={next_x_ei[0]:.3f})')
ax2.fill_between(X_pred.ravel(), 0, ei_values.ravel(), alpha=0.3, color='green')
ax2.set_ylabel('EI(x)', fontsize=12)
ax2.set_title('(2) Expected ImprovementÁç≤ÂæóÈñ¢Êï∞', fontsize=13, fontweight='bold')
ax2.legend()
ax2.grid(alpha=0.3)

# (3) Upper Confidence Bound
next_x_ucb = X_pred[np.argmax(ucb_values)]
ax3.plot(X_pred, ucb_values, 'm-', linewidth=2, label='UCB')
ax3.plot(X_pred, y_pred, 'b--', linewidth=1, alpha=0.5, label='GPÂπ≥Âùá')
ax3.axvline(x=next_x_ucb, color='red', linestyle='--', label=f'Ê¨°ÂÄôË£ú (x={next_x_ucb[0]:.3f})')
ax3.set_xlabel('ÂÆüÈ®ìÊù°‰ª∂ x', fontsize=12)
ax3.set_ylabel('UCB(x)', fontsize=12)
ax3.set_title('(3) Upper Confidence BoundÁç≤ÂæóÈñ¢Êï∞', fontsize=13, fontweight='bold')
ax3.legend()
ax3.grid(alpha=0.3)

plt.tight_layout()
plt.savefig('acquisition_functions.png', dpi=300, bbox_inches='tight')
plt.show()

print(f&quot;EI„Å´„Çà„ÇãÊ¨°ÂÄôË£ú: x = {next_x_ei[0]:.3f}&quot;)
print(f&quot;UCB„Å´„Çà„ÇãÊ¨°ÂÄôË£ú: x = {next_x_ucb[0]:.3f}&quot;)
</code></pre>
<p><strong>Áç≤ÂæóÈñ¢Êï∞„ÅÆÁâπÂæ¥</strong>:
- <strong>EI</strong>: „Éê„É©„É≥„ÇπÂûã„ÄÅÊúÄ„ÇÇÂ∫É„Åè‰ΩøÁî®„Åï„Çå„Çã
- <strong>UCB</strong>: Êé¢Á¥¢ÈáçË¶ñ„ÄÅ$\kappa$„ÅßË™øÊï¥ÂèØËÉΩ
- <strong>PI</strong>: ‰øùÂÆàÁöÑ„ÄÅÊó¢Áü•È†òÂüü„ÅÆÊîπÂñÑ„ÇíÂÑ™ÂÖà</p>
<hr />
<h2>3.3 „ÇØ„É≠„Éº„Ç∫„Éâ„É´„Éº„Éó„ÅÆÂÆüË£Ö</h2>
<h3>3.3.1 scikit-optimize„Å´„Çà„ÇãÂÆüË£Ö</h3>
<pre><code class="language-python">from skopt import gp_minimize
from skopt.space import Real
from skopt.utils import use_named_args
from skopt.plots import plot_convergence, plot_objective

# ÊúÄÈÅ©ÂåñÂØæË±°„ÅÆÈñ¢Êï∞Ôºà„É≠„Éú„ÉÉ„ÉàÂÆüÈ®ì„ÅÆ„Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥Ôºâ
def robot_experiment(x):
    &quot;&quot;&quot;
    „É≠„Éú„ÉÉ„ÉàÂÆüÈ®ì„ÅÆ„Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥Èñ¢Êï∞

    Args:
        x: ÂÆüÈ®ìÊù°‰ª∂Ôºà‰æã: [Ê∏©Â∫¶, ÊôÇÈñì]Ôºâ

    Returns:
        -f(x): ÊúÄÂ∞èÂåñÂïèÈ°å„Å´Â§âÊèõÔºàscikit-optimize„ÅØÊúÄÂ∞èÂåñÔºâ
    &quot;&quot;&quot;
    # ÂÆüÈöõ„ÅÆÂÆüÈ®ì„Åß„ÅØ„ÄÅ„Åì„ÅÆÈÉ®ÂàÜ„Åå„É≠„Éú„ÉÉ„Éà„Å´„Çà„ÇãÂêàÊàê„ÉªÊ∏¨ÂÆö
    result = true_function(np.array([[x[0]]]))[0]

    # „Éé„Ç§„Ç∫ÔºàÂÆüÈ®ìË™§Â∑ÆÔºâ
    result += np.random.normal(0, 0.05)

    print(f&quot;ÂÆüÈ®ìÂÆüË°å: x={x[0]:.3f}, ÁµêÊûú={result:.3f}&quot;)

    # ÊúÄÂ§ßÂåñ‚ÜíÊúÄÂ∞èÂåñ„Å´Â§âÊèõÔºàscikit-optimize„ÅØÊúÄÂ∞èÂåñÔºâ
    return -result


# Êé¢Á¥¢Á©∫Èñì„ÅÆÂÆöÁæ©
space = [Real(0.0, 1.0, name='x')]

# „Éô„Ç§„Ç∫ÊúÄÈÅ©Âåñ„ÅÆÂÆüË°å
n_calls = 20  # ÂÆüÈ®ìÂõûÊï∞
result = gp_minimize(
    robot_experiment,  # ÁõÆÁöÑÈñ¢Êï∞Ôºà„É≠„Éú„ÉÉ„ÉàÂÆüÈ®ìÔºâ
    space,  # Êé¢Á¥¢Á©∫Èñì
    n_calls=n_calls,  # Á∑èÂÆüÈ®ìÂõûÊï∞
    n_initial_points=5,  # ÂàùÊúü„É©„É≥„ÉÄ„É†ÂÆüÈ®ìÊï∞
    acq_func='EI',  # Áç≤ÂæóÈñ¢Êï∞
    random_state=42
)

print(f&quot;\nÊúÄÈÅ©ÂåñÂÆå‰∫Ü!&quot;)
print(f&quot;ÊúÄÈÅ©Êù°‰ª∂: x = {result.x[0]:.3f}&quot;)
print(f&quot;ÊúÄÈÅ©ÂÄ§: f(x) = {-result.fun:.3f}&quot;)
print(f&quot;ÂÆüÈ®ìÂõûÊï∞: {n_calls}Âõû&quot;)

# ÂèéÊùü„Éó„É≠„ÉÉ„Éà
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 5))

# (1) ÂèéÊùüÂ±•Ê≠¥
plot_convergence(result, ax=ax1)
ax1.set_title('ÊúÄÈÅ©Âåñ„ÅÆÂèéÊùü', fontsize=14, fontweight='bold')

# (2) Êé¢Á¥¢„Åó„ÅüÁÇπ
X_evaluated = np.array([x[0] for x in result.x_iters])
y_evaluated = -np.array(result.func_vals)  # ÂÖÉ„ÅÆ„Çπ„Ç±„Éº„É´„Å´Êàª„Åô

X_plot = np.linspace(0, 1, 100)
y_true = true_function(X_plot.reshape(-1, 1)).ravel()

ax2.plot(X_plot, y_true, 'k--', label='Áúü„ÅÆÈñ¢Êï∞', linewidth=2)
ax2.plot(X_evaluated, y_evaluated, 'ro-', markersize=8, label='Ë©ï‰æ°ÁÇπ', alpha=0.6)
ax2.plot(result.x[0], -result.fun, 'g*', markersize=20, label='ÊúÄÈÅ©Ëß£')
ax2.set_xlabel('ÂÆüÈ®ìÊù°‰ª∂ x', fontsize=12)
ax2.set_ylabel('ÁõÆÁöÑÈñ¢Êï∞ f(x)', fontsize=12)
ax2.set_title('Êé¢Á¥¢ËªåË∑°', fontsize=14, fontweight='bold')
ax2.legend()
ax2.grid(alpha=0.3)

plt.tight_layout()
plt.savefig('bayesian_optimization_result.png', dpi=300, bbox_inches='tight')
plt.show()
</code></pre>
<hr />
<h3>3.3.2 ÂÆåÂÖ®„Å™„ÇØ„É≠„Éº„Ç∫„Éâ„É´„Éº„Éó„Ç∑„Çπ„ÉÜ„É†</h3>
<pre><code class="language-python">class ClosedLoopOptimization:
    &quot;&quot;&quot;
    „ÇØ„É≠„Éº„Ç∫„Éâ„É´„Éº„ÉóÊúÄÈÅ©Âåñ„Ç∑„Çπ„ÉÜ„É†
    ÂÆüÈ®ì ‚Üí Ê∏¨ÂÆö ‚Üí Ëß£Êûê ‚Üí ‰∫àÊ∏¨ ‚Üí Ê¨°ÂÆüÈ®ì
    &quot;&quot;&quot;

    def __init__(self, robot_controller, sensor_controller):
        &quot;&quot;&quot;
        Args:
            robot_controller: „É≠„Éú„ÉÉ„ÉàÂà∂Âæ°„Ç§„É≥„Çø„Éº„Éï„Çß„Éº„Çπ
            sensor_controller: „Çª„É≥„Çµ„ÉºÂà∂Âæ°„Ç§„É≥„Çø„Éº„Éï„Çß„Éº„Çπ
        &quot;&quot;&quot;
        self.robot = robot_controller
        self.sensor = sensor_controller
        self.data = []

    def run_experiment(self, conditions):
        &quot;&quot;&quot;
        1Âõû„ÅÆÂÆüÈ®ì„Çµ„Ç§„ÇØ„É´

        Args:
            conditions: ÂÆüÈ®ìÊù°‰ª∂ÔºàËæûÊõ∏Ôºâ

        Returns:
            measurement: Ê∏¨ÂÆöÂÄ§
        &quot;&quot;&quot;
        print(f&quot;\n--- ÂÆüÈ®ì {len(self.data)+1} ---&quot;)
        print(f&quot;Êù°‰ª∂: {conditions}&quot;)

        # (1) Ë©¶ÊñôË™øË£Ω
        print(&quot;  [1/4] „É≠„Éú„ÉÉ„Éà„Å´„Çà„ÇãË©¶ÊñôË™øË£Ω...&quot;)
        self.robot.prepare_sample(conditions)

        # (2) Ê∏¨ÂÆö
        print(&quot;  [2/4] „Çª„É≥„Çµ„Éº„Å´„Çà„ÇãÊ∏¨ÂÆö...&quot;)
        measurement = self.sensor.measure()

        # (3) „Éá„Éº„ÇøË®òÈå≤
        print(&quot;  [3/4] „Éá„Éº„ÇøË®òÈå≤...&quot;)
        self.data.append({'conditions': conditions, 'measurement': measurement})

        # (4) ÁµêÊûúË°®Á§∫
        print(f&quot;  [4/4] Ê∏¨ÂÆöÁµêÊûú: {measurement:.3f}&quot;)

        return measurement

    def optimize(self, n_iterations=10):
        &quot;&quot;&quot;
        „ÇØ„É≠„Éº„Ç∫„Éâ„É´„Éº„ÉóÊúÄÈÅ©Âåñ„ÅÆÂÆüË°å

        Args:
            n_iterations: ÊúÄÈÅ©ÂåñÂèçÂæ©ÂõûÊï∞
        &quot;&quot;&quot;
        from skopt import Optimizer

        # Êé¢Á¥¢Á©∫ÈñìÔºà‰æã: Ê∏©Â∫¶„Å®pHÔºâ
        space = [
            Real(50, 150, name='temperature'),  # Ê∏©Â∫¶Ôºà‚ÑÉÔºâ
            Real(4, 10, name='pH')  # pH
        ]

        optimizer = Optimizer(space, base_estimator='GP', acq_func='EI')

        print(&quot;=&quot; * 50)
        print(&quot;„ÇØ„É≠„Éº„Ç∫„Éâ„É´„Éº„ÉóÊúÄÈÅ©ÂåñÈñãÂßã&quot;)
        print(&quot;=&quot; * 50)

        for i in range(n_iterations):
            # Ê¨°„ÅÆÂÆüÈ®ìÊù°‰ª∂„ÇíÊèêÊ°à
            next_conditions = optimizer.ask()
            conditions_dict = {'temperature': next_conditions[0], 'pH': next_conditions[1]}

            # ÂÆüÈ®ìÂÆüË°å
            result = self.run_experiment(conditions_dict)

            # „Ç™„Éó„ÉÜ„Ç£„Éû„Ç§„Ç∂„Éº„Å´ÁµêÊûú„ÇíÈÄöÁü•
            optimizer.tell(next_conditions, -result)  # ÊúÄÂ§ßÂåñ‚ÜíÊúÄÂ∞èÂåñ

        # ÊúÄÈÅ©Êù°‰ª∂
        best_result = optimizer.get_result()
        print(&quot;\n&quot; + &quot;=&quot; * 50)
        print(&quot;ÊúÄÈÅ©ÂåñÂÆå‰∫Ü&quot;)
        print(&quot;=&quot; * 50)
        print(f&quot;ÊúÄÈÅ©Êù°‰ª∂: Ê∏©Â∫¶={best_result.x[0]:.1f}‚ÑÉ, pH={best_result.x[1]:.1f}&quot;)
        print(f&quot;ÊúÄÈÅ©ÂÄ§: {-best_result.fun:.3f}&quot;)

        return best_result


# „Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥Áî®„ÅÆ„Ç≥„É≥„Éà„É≠„Éº„É©„Éº
class RobotControllerSimulator:
    def prepare_sample(self, conditions):
        &quot;&quot;&quot;Ë©¶ÊñôË™øË£Ω„ÅÆ„Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥&quot;&quot;&quot;
        time.sleep(0.1)  # ÂÆüÈöõ„ÅØÊï∞ÂàÜ

class SensorControllerSimulator:
    def __init__(self):
        self.measurement_count = 0

    def measure(self):
        &quot;&quot;&quot;Ê∏¨ÂÆö„ÅÆ„Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥Ôºà2Â§âÊï∞Èñ¢Êï∞Ôºâ&quot;&quot;&quot;
        # ‰ªÆÊÉ≥ÁöÑ„Å™ÁõÆÁöÑÈñ¢Êï∞
        # ÊúÄÈÅ©ÂÄ§: temperature=100‚ÑÉ, pH=7
        temp = np.random.uniform(50, 150)
        ph = np.random.uniform(4, 10)
        result = -(temp - 100)**2 / 1000 - (ph - 7)**2 + 10
        result += np.random.normal(0, 0.2)  # „Éé„Ç§„Ç∫
        self.measurement_count += 1
        time.sleep(0.1)  # ÂÆüÈöõ„ÅØÊï∞ÂçÅÁßí„ÄúÊï∞ÂàÜ
        return result


# „ÇØ„É≠„Éº„Ç∫„Éâ„É´„Éº„Éó„ÅÆÂÆüË°å
robot = RobotControllerSimulator()
sensor = SensorControllerSimulator()
closed_loop = ClosedLoopOptimization(robot, sensor)

result = closed_loop.optimize(n_iterations=15)

# Êé¢Á¥¢„Åó„ÅüÁÇπ„ÅÆÂèØË¶ñÂåñÔºà2DÔºâ
import pandas as pd

df = pd.DataFrame([
    {'temperature': d['conditions']['temperature'],
     'pH': d['conditions']['pH'],
     'measurement': d['measurement']}
    for d in closed_loop.data
])

fig = plt.figure(figsize=(12, 5))

# Ê∏©Â∫¶ vs Ê∏¨ÂÆöÂÄ§
ax1 = fig.add_subplot(121)
ax1.scatter(df['temperature'], df['measurement'], c=range(len(df)), cmap='viridis', s=100, edgecolors='black')
ax1.set_xlabel('Ê∏©Â∫¶Ôºà‚ÑÉÔºâ', fontsize=12)
ax1.set_ylabel('Ê∏¨ÂÆöÂÄ§', fontsize=12)
ax1.set_title('Ê∏©Â∫¶„Å®Ê∏¨ÂÆöÂÄ§„ÅÆÈñ¢‰øÇ', fontsize=13, fontweight='bold')
ax1.grid(alpha=0.3)

# pH vs Ê∏¨ÂÆöÂÄ§
ax2 = fig.add_subplot(122)
scatter = ax2.scatter(df['pH'], df['measurement'], c=range(len(df)), cmap='viridis', s=100, edgecolors='black')
ax2.set_xlabel('pH', fontsize=12)
ax2.set_ylabel('Ê∏¨ÂÆöÂÄ§', fontsize=12)
ax2.set_title('pH„Å®Ê∏¨ÂÆöÂÄ§„ÅÆÈñ¢‰øÇ', fontsize=13, fontweight='bold')
ax2.grid(alpha=0.3)

# „Ç´„É©„Éº„Éê„ÉºÔºàÂÆüÈ®ìÈ†ÜÂ∫èÔºâ
cbar = plt.colorbar(scatter, ax=[ax1, ax2])
cbar.set_label('ÂÆüÈ®ìÈ†ÜÂ∫è', fontsize=11)

plt.tight_layout()
plt.savefig('closed_loop_exploration.png', dpi=300, bbox_inches='tight')
plt.show()
</code></pre>
<hr />
<h2>3.4 ÈáèÂ≠ê„Éâ„ÉÉ„ÉàÁô∫ÂÖâÊ≥¢Èï∑„ÅÆËá™ÂãïÊúÄÈÅ©Âåñ</h2>
<p>ÂÆüÈöõ„ÅÆÊùêÊñôÊé¢Á¥¢‰∫ã‰æãÔºöÈáèÂ≠ê„Éâ„ÉÉ„Éà„ÅÆÁô∫ÂÖâÊ≥¢Èï∑„ÇíËá™ÂãïÊúÄÈÅ©Âåñ„Åó„Åæ„Åô„ÄÇ</p>
<h3>3.4.1 ÂïèÈ°åË®≠ÂÆö</h3>
<p><strong>ÁõÆÊ®ô</strong>: CdSeSÈáèÂ≠ê„Éâ„ÉÉ„Éà„ÅÆÁô∫ÂÖâÊ≥¢Èï∑„Çí520nmÔºàÁ∑ëËâ≤Ôºâ„Å´ÊúÄÈÅ©Âåñ</p>
<p><strong>ÂÆüÈ®ì„Éë„É©„É°„Éº„Çø</strong>:
- Cd/SeÊØîÔºà0.5-2.0Ôºâ
- ÂèçÂøúÊ∏©Â∫¶Ôºà150-300‚ÑÉÔºâ
- ÂèçÂøúÊôÇÈñìÔºà5-60ÂàÜÔºâ</p>
<pre><code class="language-python">def quantum_dot_synthesis_simulator(cd_se_ratio, temperature, reaction_time):
    &quot;&quot;&quot;
    ÈáèÂ≠ê„Éâ„ÉÉ„ÉàÂêàÊàê„Å®Áô∫ÂÖâÊ≥¢Èï∑Ê∏¨ÂÆö„ÅÆ„Ç∑„Éü„É•„É¨„Éº„Çø„Éº

    Args:
        cd_se_ratio: Cd/SeÊØîÔºà0.5-2.0Ôºâ
        temperature: ÂèçÂøúÊ∏©Â∫¶Ôºà150-300‚ÑÉÔºâ
        reaction_time: ÂèçÂøúÊôÇÈñìÔºà5-60ÂàÜÔºâ

    Returns:
        emission_wavelength: Áô∫ÂÖâÊ≥¢Èï∑ÔºànmÔºâ
    &quot;&quot;&quot;
    # ÂÆüÈ®ìÂâá„Å´Âü∫„Å•„Åè„Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥„É¢„Éá„É´
    # ÂÆüÈöõ„ÅÆÂÆüÈ®ì„Åß„ÅØ„ÄÅ„Åì„ÅÆÈÉ®ÂàÜ„Åå„É≠„Éú„ÉÉ„ÉàÂêàÊàê + ËõçÂÖâÂàÜÂÖâÊ∏¨ÂÆö

    # Âü∫Êú¨Ê≥¢Èï∑ÔºàÁµÑÊàê‰æùÂ≠òÔºâ
    base_wavelength = 480 + 100 * (cd_se_ratio - 0.5) / 1.5

    # Ê∏©Â∫¶ÂäπÊûúÔºàÁ≤íÂæÑÂà∂Âæ°Ôºâ
    temp_effect = 0.2 * (temperature - 225)

    # ÊôÇÈñìÂäπÊûúÔºàÊàêÈï∑ÊôÇÈñìÔºâ
    time_effect = 0.3 * (reaction_time - 32.5)

    # Á∑èÂêàÁöÑ„Å™Áô∫ÂÖâÊ≥¢Èï∑
    emission_wavelength = base_wavelength + temp_effect + time_effect

    # „Éé„Ç§„Ç∫ÔºàÂÆüÈ®ìË™§Â∑ÆÔºâ
    emission_wavelength += np.random.normal(0, 3)

    return emission_wavelength


# „ÇØ„É≠„Éº„Ç∫„Éâ„É´„Éº„ÉóÊúÄÈÅ©Âåñ
from skopt import gp_minimize
from skopt.space import Real

# ÁõÆÊ®ôÊ≥¢Èï∑
target_wavelength = 520  # nmÔºàÁ∑ëËâ≤Ôºâ

def objective_function(params):
    &quot;&quot;&quot;
    ÁõÆÁöÑÈñ¢Êï∞: ÁõÆÊ®ôÊ≥¢Èï∑„Å®„ÅÆÂ∑Æ„ÇíÊúÄÂ∞èÂåñ

    Args:
        params: [cd_se_ratio, temperature, reaction_time]

    Returns:
        error: ÁõÆÊ®ô„Å®„ÅÆÂ∑ÆÔºàÊúÄÂ∞èÂåñÔºâ
    &quot;&quot;&quot;
    cd_se_ratio, temperature, reaction_time = params

    # ÈáèÂ≠ê„Éâ„ÉÉ„ÉàÂêàÊàêÔºà„Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥Ôºâ
    emission = quantum_dot_synthesis_simulator(cd_se_ratio, temperature, reaction_time)

    # Ë™§Â∑ÆÔºàÁõÆÊ®ôÊ≥¢Èï∑„Å®„ÅÆÂ∑Æ„ÅÆÁµ∂ÂØæÂÄ§Ôºâ
    error = abs(emission - target_wavelength)

    print(f&quot;Cd/Se={cd_se_ratio:.2f}, T={temperature:.0f}‚ÑÉ, t={reaction_time:.0f}min ‚Üí Œª={emission:.1f}nm (Ë™§Â∑Æ: {error:.1f}nm)&quot;)

    return error


# Êé¢Á¥¢Á©∫Èñì
space = [
    Real(0.5, 2.0, name='cd_se_ratio'),
    Real(150, 300, name='temperature'),
    Real(5, 60, name='reaction_time')
]

print(&quot;=&quot; * 70)
print(&quot;ÈáèÂ≠ê„Éâ„ÉÉ„ÉàÁô∫ÂÖâÊ≥¢Èï∑„ÅÆËá™ÂãïÊúÄÈÅ©Âåñ&quot;)
print(f&quot;ÁõÆÊ®ôÊ≥¢Èï∑: {target_wavelength}nmÔºàÁ∑ëËâ≤Ôºâ&quot;)
print(&quot;=&quot; * 70)

# „Éô„Ç§„Ç∫ÊúÄÈÅ©Âåñ„ÅÆÂÆüË°å
result = gp_minimize(
    objective_function,
    space,
    n_calls=30,  # 30Âõû„ÅÆÂÆüÈ®ì
    n_initial_points=10,  # ÂàùÊúü10Âõû„ÅØ„É©„É≥„ÉÄ„É†
    acq_func='EI',
    random_state=42
)

print(&quot;\n&quot; + &quot;=&quot; * 70)
print(&quot;ÊúÄÈÅ©ÂåñÂÆå‰∫Ü&quot;)
print(&quot;=&quot; * 70)
print(f&quot;ÊúÄÈÅ©Êù°‰ª∂:&quot;)
print(f&quot;  Cd/SeÊØî: {result.x[0]:.2f}&quot;)
print(f&quot;  Ê∏©Â∫¶: {result.x[1]:.0f}‚ÑÉ&quot;)
print(f&quot;  ÂèçÂøúÊôÇÈñì: {result.x[2]:.0f}ÂàÜ&quot;)

# ÊúÄÈÅ©Êù°‰ª∂„Åß„ÅÆÂÆüÊ∏¨ÂÄ§
optimized_wavelength = quantum_dot_synthesis_simulator(result.x[0], result.x[1], result.x[2])
print(f&quot;\nÊúÄÈÅ©Êù°‰ª∂„Åß„ÅÆÁô∫ÂÖâÊ≥¢Èï∑: {optimized_wavelength:.1f}nm&quot;)
print(f&quot;ÁõÆÊ®ô„Å®„ÅÆË™§Â∑Æ: {abs(optimized_wavelength - target_wavelength):.1f}nm&quot;)

# ÁµêÊûú„ÅÆÂèØË¶ñÂåñ
fig = plt.figure(figsize=(14, 10))

# (1) ÂèéÊùüÂ±•Ê≠¥
ax1 = fig.add_subplot(221)
errors = result.func_vals
ax1.plot(errors, 'o-', linewidth=2, markersize=8, color='steelblue')
ax1.axhline(y=5, color='red', linestyle='--', label='ÁõÆÊ®ôË™§Â∑Æ (&lt;5nm)')
ax1.set_xlabel('ÂÆüÈ®ìÂõûÊï∞', fontsize=12)
ax1.set_ylabel('Ë™§Â∑ÆÔºànmÔºâ', fontsize=12)
ax1.set_title('(1) ÊúÄÈÅ©Âåñ„ÅÆÂèéÊùü', fontsize=13, fontweight='bold')
ax1.legend()
ax1.grid(alpha=0.3)

# (2) Cd/SeÊØî vs Áô∫ÂÖâÊ≥¢Èï∑
ax2 = fig.add_subplot(222)
cd_se_ratios = [x[0] for x in result.x_iters]
wavelengths = [target_wavelength - e if i % 2 == 0 else target_wavelength + e
               for i, e in enumerate(errors)]  # Á∞°ÊòìÂÜçÊßãÊàê
ax2.scatter(cd_se_ratios, wavelengths, c=range(len(cd_se_ratios)), cmap='viridis',
            s=100, edgecolors='black')
ax2.axhline(y=target_wavelength, color='red', linestyle='--', label='ÁõÆÊ®ôÊ≥¢Èï∑')
ax2.set_xlabel('Cd/SeÊØî', fontsize=12)
ax2.set_ylabel('Áô∫ÂÖâÊ≥¢Èï∑ÔºànmÔºâ', fontsize=12)
ax2.set_title('(2) Cd/SeÊØî„Å®Áô∫ÂÖâÊ≥¢Èï∑', fontsize=13, fontweight='bold')
ax2.legend()
ax2.grid(alpha=0.3)

# (3) Ê∏©Â∫¶ vs Áô∫ÂÖâÊ≥¢Èï∑
ax3 = fig.add_subplot(223)
temperatures = [x[1] for x in result.x_iters]
ax3.scatter(temperatures, wavelengths, c=range(len(temperatures)), cmap='plasma',
            s=100, edgecolors='black')
ax3.axhline(y=target_wavelength, color='red', linestyle='--', label='ÁõÆÊ®ôÊ≥¢Èï∑')
ax3.set_xlabel('Ê∏©Â∫¶Ôºà‚ÑÉÔºâ', fontsize=12)
ax3.set_ylabel('Áô∫ÂÖâÊ≥¢Èï∑ÔºànmÔºâ', fontsize=12)
ax3.set_title('(3) Ê∏©Â∫¶„Å®Áô∫ÂÖâÊ≥¢Èï∑', fontsize=13, fontweight='bold')
ax3.legend()
ax3.grid(alpha=0.3)

# (4) ÂèçÂøúÊôÇÈñì vs Áô∫ÂÖâÊ≥¢Èï∑
ax4 = fig.add_subplot(224)
reaction_times = [x[2] for x in result.x_iters]
scatter = ax4.scatter(reaction_times, wavelengths, c=range(len(reaction_times)),
                      cmap='coolwarm', s=100, edgecolors='black')
ax4.axhline(y=target_wavelength, color='red', linestyle='--', label='ÁõÆÊ®ôÊ≥¢Èï∑')
ax4.set_xlabel('ÂèçÂøúÊôÇÈñìÔºàÂàÜÔºâ', fontsize=12)
ax4.set_ylabel('Áô∫ÂÖâÊ≥¢Èï∑ÔºànmÔºâ', fontsize=12)
ax4.set_title('(4) ÂèçÂøúÊôÇÈñì„Å®Áô∫ÂÖâÊ≥¢Èï∑', fontsize=13, fontweight='bold')
ax4.legend()
ax4.grid(alpha=0.3)

# „Ç´„É©„Éº„Éê„Éº
cbar = plt.colorbar(scatter, ax=[ax2, ax3, ax4])
cbar.set_label('ÂÆüÈ®ìÈ†ÜÂ∫è', fontsize=11)

plt.tight_layout()
plt.savefig('quantum_dot_optimization.png', dpi=300, bbox_inches='tight')
plt.show()
</code></pre>
<p><strong>ÁµêÊûú„ÅÆËß£Èáà</strong>:
- ÂàùÊúü10Âõû: „É©„É≥„ÉÄ„É†Êé¢Á¥¢„ÅßÂ∫ÉÁØÑÂõ≤„Çí„Çµ„É≥„Éó„É™„É≥„Ç∞
- 11ÂõûÁõÆ‰ª•Èôç: „Éô„Ç§„Ç∫ÊúÄÈÅ©Âåñ„ÅåÊúâÊúõÈ†òÂüü„Å´ÈõÜ‰∏≠
- 20-30ÂõûÁõÆ: ÁõÆÊ®ôÊ≥¢Èï∑¬±5nm‰ª•ÂÜÖ„Å´ÂèéÊùü</p>
<hr />
<h2>3.5 ÊºîÁøíÂïèÈ°å</h2>
<h3>ÊºîÁøí1: Áç≤ÂæóÈñ¢Êï∞„ÅÆÊØîËºÉÔºàÈõ£ÊòìÂ∫¶: MediumÔºâ</h3>
<p>EIÔºàExpected ImprovementÔºâ„Å®UCBÔºàUpper Confidence BoundÔºâ„ÅÆ2„Å§„ÅÆÁç≤ÂæóÈñ¢Êï∞„ÅßÂêå„ÅòÊúÄÈÅ©ÂåñÂïèÈ°å„ÇíËß£„Åç„ÄÅÊé¢Á¥¢ÊåôÂãï„ÅÆÈÅï„ÅÑ„ÇíÊØîËºÉ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
<details>
<summary>„Éí„É≥„Éà</summary>

`gp_minimize`„ÅÆ`acq_func`„Éë„É©„É°„Éº„Çø„Çí`'EI'`„Å®`'LCB'`ÔºàUCB„ÅÆÂèçËª¢Ôºâ„Å´Â§â„Åà„Å¶2ÂõûÂÆüË°å„Åó„ÄÅÂèéÊùüÈÄüÂ∫¶„Å®Êé¢Á¥¢„Åó„ÅüÁÇπ„ÅÆÂàÜÂ∏É„ÇíÊØîËºÉ„Åó„Åæ„Åô„ÄÇ

</details>

<details>
<summary>Ëß£Á≠î‰æã</summary>


<pre><code class="language-python"># EI„Å®UCB„ÅßÂêå„ÅòÂïèÈ°å„ÇíÊúÄÈÅ©Âåñ
results = {}

for acq_func in ['EI', 'LCB']:  # LCB = -UCBÔºàÊúÄÂ∞èÂåñÂïèÈ°å„Å™„ÅÆ„ÅßÔºâ
    print(f&quot;\nÁç≤ÂæóÈñ¢Êï∞: {acq_func}&quot;)
    result = gp_minimize(
        robot_experiment,
        space,
        n_calls=20,
        n_initial_points=5,
        acq_func=acq_func,
        random_state=42
    )
    results[acq_func] = result
    print(f&quot;ÊúÄÈÅ©ÂÄ§: {-result.fun:.3f}, ÊúÄÈÅ©Êù°‰ª∂: {result.x[0]:.3f}&quot;)

# ÊØîËºÉ„Éó„É≠„ÉÉ„Éà
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 5))

colors = {'EI': 'blue', 'LCB': 'red'}

# ÂèéÊùüÊØîËºÉ
for acq_func, result in results.items():
    ax1.plot(-np.array(result.func_vals), label=acq_func, color=colors[acq_func], linewidth=2)

ax1.set_xlabel('ÂÆüÈ®ìÂõûÊï∞', fontsize=12)
ax1.set_ylabel('ÁõÆÁöÑÈñ¢Êï∞ÂÄ§', fontsize=12)
ax1.set_title('Áç≤ÂæóÈñ¢Êï∞„Å´„Çà„ÇãÂèéÊùü„ÅÆÈÅï„ÅÑ', fontsize=14, fontweight='bold')
ax1.legend()
ax1.grid(alpha=0.3)

# Êé¢Á¥¢ÁÇπ„ÅÆÂàÜÂ∏É
X_true = np.linspace(0, 1, 100)
y_true = true_function(X_true.reshape(-1, 1)).ravel()

ax2.plot(X_true, y_true, 'k--', label='Áúü„ÅÆÈñ¢Êï∞', linewidth=2)

for acq_func, result in results.items():
    X_eval = np.array([x[0] for x in result.x_iters])
    y_eval = -np.array(result.func_vals)
    ax2.scatter(X_eval, y_eval, label=f'{acq_func}', s=80, alpha=0.6, color=colors[acq_func])

ax2.set_xlabel('ÂÆüÈ®ìÊù°‰ª∂ x', fontsize=12)
ax2.set_ylabel('ÁõÆÁöÑÈñ¢Êï∞ f(x)', fontsize=12)
ax2.set_title('Êé¢Á¥¢„Åó„ÅüÁÇπ„ÅÆÂàÜÂ∏É', fontsize=14, fontweight='bold')
ax2.legend()
ax2.grid(alpha=0.3)

plt.tight_layout()
plt.savefig('acquisition_function_comparison.png', dpi=300, bbox_inches='tight')
plt.show()

print(&quot;\nËÄÉÂØü:&quot;)
print(&quot;EI: „Éê„É©„É≥„ÇπÂûã„ÄÅÂ∫ÉÁØÑÂõ≤„ÇíÂäπÁéáÁöÑ„Å´Êé¢Á¥¢&quot;)
print(&quot;UCB: Êé¢Á¥¢ÈáçË¶ñ„ÄÅ‰∏çÁ¢∫ÂÆüÊÄß„ÅÆÈ´ò„ÅÑÈ†òÂüü„ÇíÁ©çÊ•µÁöÑ„Å´Ë™øÊüª&quot;)
</code></pre>


</details>

<hr />
<h3>ÊºîÁøí2: Âà∂Á¥Ñ‰ªò„ÅçÊúÄÈÅ©ÂåñÔºàÈõ£ÊòìÂ∫¶: HardÔºâ</h3>
<p>ÈáèÂ≠ê„Éâ„ÉÉ„ÉàÂêàÊàê„Åß„ÄÅ‰ª•‰∏ã„ÅÆÂà∂Á¥ÑÊù°‰ª∂„ÇíËøΩÂä†„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºö
- Ê∏©Â∫¶ ‚â§ 250‚ÑÉÔºàÂÆâÂÖ®ÊÄßÔºâ
- ÂèçÂøúÊôÇÈñì ‚â§ 30ÂàÜÔºà„Çπ„É´„Éº„Éó„ÉÉ„ÉàÔºâ</p>
<details>
<summary>„Éí„É≥„Éà</summary>

Êé¢Á¥¢Á©∫Èñì„ÅÆÂÆöÁæ©„ÇíÂ§âÊõ¥„Åô„Çã„Åã„ÄÅÁõÆÁöÑÈñ¢Êï∞ÂÜÖ„Åß„Éö„Éä„É´„ÉÜ„Ç£„ÇíËøΩÂä†„Åó„Åæ„Åô„ÄÇÂà∂Á¥ÑÈÅïÂèçÊôÇ„Å´Â§ß„Åç„Å™„Éö„Éä„É´„ÉÜ„Ç£Ôºà‰æã: +1000Ôºâ„ÇíÂä†„Åà„Åæ„Åô„ÄÇ

</details>

<details>
<summary>Ëß£Á≠î‰æã</summary>


<pre><code class="language-python">def constrained_objective(params):
    &quot;&quot;&quot;
    Âà∂Á¥Ñ‰ªò„ÅçÁõÆÁöÑÈñ¢Êï∞

    Args:
        params: [cd_se_ratio, temperature, reaction_time]

    Returns:
        error: Ë™§Â∑Æ + Âà∂Á¥ÑÈÅïÂèç„Éö„Éä„É´„ÉÜ„Ç£
    &quot;&quot;&quot;
    cd_se_ratio, temperature, reaction_time = params

    # Âü∫Êú¨ÁõÆÁöÑÈñ¢Êï∞
    emission = quantum_dot_synthesis_simulator(cd_se_ratio, temperature, reaction_time)
    error = abs(emission - target_wavelength)

    # Âà∂Á¥Ñ„ÉÅ„Çß„ÉÉ„ÇØ
    penalty = 0
    constraints_violated = []

    if temperature &gt; 250:
        penalty += 1000 * (temperature - 250)
        constraints_violated.append(f&quot;Ê∏©Â∫¶Âà∂Á¥ÑÈÅïÂèç({temperature:.0f}‚ÑÉ &gt; 250‚ÑÉ)&quot;)

    if reaction_time &gt; 30:
        penalty += 1000 * (reaction_time - 30)
        constraints_violated.append(f&quot;ÊôÇÈñìÂà∂Á¥ÑÈÅïÂèç({reaction_time:.0f}ÂàÜ &gt; 30ÂàÜ)&quot;)

    if constraints_violated:
        print(f&quot;  Âà∂Á¥ÑÈÅïÂèç: {', '.join(constraints_violated)} ‚Üí „Éö„Éä„É´„ÉÜ„Ç£={penalty:.0f}&quot;)
    else:
        print(f&quot;Cd/Se={cd_se_ratio:.2f}, T={temperature:.0f}‚ÑÉ, t={reaction_time:.0f}min ‚Üí Œª={emission:.1f}nm&quot;)

    return error + penalty


# Âà∂Á¥Ñ‰ªò„ÅçÊúÄÈÅ©Âåñ
space_constrained = [
    Real(0.5, 2.0, name='cd_se_ratio'),
    Real(150, 300, name='temperature'),  # Êé¢Á¥¢Á©∫Èñì„ÅØÂ§âÊõ¥„Åó„Å™„ÅÑ
    Real(5, 60, name='reaction_time')
]

print(&quot;Âà∂Á¥Ñ‰ªò„ÅçÊúÄÈÅ©Âåñ:&quot;)
print(&quot;  Ê∏©Â∫¶ ‚â§ 250‚ÑÉ&quot;)
print(&quot;  ÂèçÂøúÊôÇÈñì ‚â§ 30ÂàÜ\n&quot;)

result_constrained = gp_minimize(
    constrained_objective,
    space_constrained,
    n_calls=30,
    n_initial_points=10,
    acq_func='EI',
    random_state=42
)

print(f&quot;\nÊúÄÈÅ©Êù°‰ª∂:&quot;)
print(f&quot;  Cd/SeÊØî: {result_constrained.x[0]:.2f}&quot;)
print(f&quot;  Ê∏©Â∫¶: {result_constrained.x[1]:.0f}‚ÑÉ&quot;)
print(f&quot;  ÂèçÂøúÊôÇÈñì: {result_constrained.x[2]:.0f}ÂàÜ&quot;)

# Âà∂Á¥ÑÂÖÖË∂≥„ÅÆÁ¢∫Ë™ç
if result_constrained.x[1] &lt;= 250 and result_constrained.x[2] &lt;= 30:
    print(&quot;‚úÖ „Åô„Åπ„Å¶„ÅÆÂà∂Á¥Ñ„ÇíÊ∫Ä„Åü„Åó„Å¶„ÅÑ„Åæ„Åô&quot;)
else:
    print(&quot;‚ùå Âà∂Á¥ÑÈÅïÂèç„Åå„ÅÇ„Çä„Åæ„Åô&quot;)
</code></pre>


</details>

<hr />
<h3>ÊºîÁøí3: Â§öÁõÆÁöÑÊúÄÈÅ©ÂåñÔºàÈõ£ÊòìÂ∫¶: HardÔºâ</h3>
<p>ÈáèÂ≠ê„Éâ„ÉÉ„Éà„ÅÆÁô∫ÂÖâÊ≥¢Èï∑„Å®ÈáèÂ≠êÂèéÁéáÔºàÁô∫ÂÖâÂäπÁéáÔºâ„ÇíÂêåÊôÇ„Å´ÊúÄÈÅ©Âåñ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
<p><strong>ÁõÆÊ®ô</strong>:
- Áô∫ÂÖâÊ≥¢Èï∑: 520nm
- ÈáèÂ≠êÂèéÁéá: ÊúÄÂ§ßÂåñÔºà0-100%Ôºâ</p>
<details>
<summary>„Éí„É≥„Éà</summary>

ParetoÊúÄÈÅ©Ëß£„ÇíË¶ã„Å§„Åë„ÇãÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇÁ∞°ÊòìÁöÑ„Å´„ÅØ„ÄÅÈáç„Åø‰ªò„ÅçÂíå„ÇíÊúÄÂ∞èÂåñ„Åó„Åæ„ÅôÔºö
$$\text{objective} = w_1 \times |\lambda - 520| + w_2 \times (100 - QY)$$

</details>

<details>
<summary>Ëß£Á≠î‰æã</summary>


<pre><code class="language-python">def multi\_objective\_synthesis(cd\_se\_ratio, temperature, reaction\_time):
    &quot;&quot;&quot;
    ÈáèÂ≠ê„Éâ„ÉÉ„ÉàÂêàÊàêÔºàÁô∫ÂÖâÊ≥¢Èï∑ + ÈáèÂ≠êÂèéÁéáÔºâ

    Returns:
        emission\_wavelength, quantum\_yield
    &quot;&quot;&quot;
    # Áô∫ÂÖâÊ≥¢Èï∑
    emission = quantum\_dot\_synthesis\_simulator(cd\_se\_ratio, temperature, reaction\_time)

    # ÈáèÂ≠êÂèéÁéáÔºà‰ªÆÊÉ≥„É¢„Éá„É´Ôºâ
    # ‰ΩéÊ∏©„ÉªÁü≠ÊôÇÈñì„ÅßÈ´òQYÔºàË°®Èù¢Ê¨†Èô•„ÅåÂ∞ë„Å™„ÅÑÔºâ
    qy = 80 - 0.2 * (temperature - 200) - 0.5 * (reaction\_time - 15)
    qy = np.clip(qy + np.random.normal(0, 2), 0, 100)

    return emission, qy


def multi\_objective\_function(params, w1=1.0, w2=0.1):
    &quot;&quot;&quot;
    Â§öÁõÆÁöÑÈñ¢Êï∞ÔºàÈáç„Åø‰ªò„ÅçÂíåÔºâ

    Args:
        params: [cd\_se\_ratio, temperature, reaction\_time]
        w1: Ê≥¢Èï∑Ë™§Â∑Æ„ÅÆÈáç„Åø
        w2: ÈáèÂ≠êÂèéÁéá„ÅÆÈáç„Åø

    Returns:
        weighted\_error: Èáç„Åø‰ªò„ÅçË™§Â∑Æ
    &quot;&quot;&quot;
    cd\_se\_ratio, temperature, reaction\_time = params

    emission, qy = multi\_objective\_synthesis(cd\_se\_ratio, temperature, reaction\_time)

    # 2„Å§„ÅÆÁõÆÁöÑ
    wavelength\_error = abs(emission - 520)
    qy\_loss = 100 - qy  # ÊúÄÂ§ßÂåñ‚ÜíÊúÄÂ∞èÂåñ

    # Èáç„Åø‰ªò„ÅçÂíå
    weighted\_error = w1 * wavelength\_error + w2 * qy\_loss

    print(f&quot;T={temperature:.0f}‚ÑÉ, t={reaction\_time:.0f}min ‚Üí Œª={emission:.1f}nm, QY={qy:.1f}%&quot;)

    return weighted\_error


# Â§öÁõÆÁöÑÊúÄÈÅ©Âåñ
result\_multi = gp\_minimize(
    multi\_objective\_function,
    space,
    n\_calls=30,
    n\_initial\_points=10,
    acq\_func='EI',
    random\_state=42
)

print(f&quot;\nÊúÄÈÅ©Êù°‰ª∂:&quot;)
print(f&quot;  Cd/SeÊØî: {result\_multi.x[0]:.2f}&quot;)
print(f&quot;  Ê∏©Â∫¶: {result\_multi.x[1]:.0f}‚ÑÉ&quot;)
print(f&quot;  ÂèçÂøúÊôÇÈñì: {result\_multi.x[2]:.0f}ÂàÜ&quot;)

# ÊúÄÈÅ©Êù°‰ª∂„Åß„ÅÆÊÄßËÉΩÁ¢∫Ë™ç
opt\_emission, opt\_qy = multi\_objective\_synthesis(result\_multi.x[0], result\_multi.x[1], result\_multi.x[2])
print(f&quot;\nÊÄßËÉΩ:&quot;)
print(f&quot;  Áô∫ÂÖâÊ≥¢Èï∑: {opt\_emission:.1f}nmÔºàÁõÆÊ®ô520nm„ÄÅË™§Â∑Æ{abs(opt\_emission-520):.1f}nmÔºâ&quot;)
print(f&quot;  ÈáèÂ≠êÂèéÁéá: {opt\_qy:.1f}%&quot;)
</code></pre>


</details>

<hr />
<h2>Êú¨Á´†„ÅÆ„Åæ„Å®„ÇÅ</h2>
<p>Êú¨Á´†„Åß„ÅØ„ÄÅ„ÇØ„É≠„Éº„Ç∫„Éâ„É´„Éº„ÉóÊúÄÈÅ©Âåñ„ÅÆÁêÜË´ñ„Å®ÂÆüË£Ö„ÇíÂ≠¶„Å≥„Åæ„Åó„Åü„ÄÇ</p>
<h3>„Ç≠„Éº„Éù„Ç§„É≥„Éà</h3>
<ol>
<li>
<p><strong>„ÇØ„É≠„Éº„Ç∫„Éâ„É´„Éº„Éó„ÅÆÊ¶ÇÂøµ</strong>:
   - ÂÆüÈ®ì‚ÜíÊ∏¨ÂÆö‚ÜíËß£Êûê‚Üí‰∫àÊ∏¨‚ÜíÊ¨°ÂÆüÈ®ì„ÅÆËá™Âãï„Çµ„Ç§„ÇØ„É´
   - 24ÊôÇÈñì365Êó•Á®ºÂÉç„Å´„Çà„ÇãÂä†ÈÄü</p>
</li>
<li>
<p><strong>„Éô„Ç§„Ç∫ÊúÄÈÅ©Âåñ</strong>:
   - „Ç¨„Ç¶„ÇπÈÅéÁ®ã„Å´„Çà„ÇãÈñ¢Êï∞Ëøë‰ºº
   - Áç≤ÂæóÈñ¢Êï∞ÔºàEI„ÄÅUCBÔºâ„Å´„Çà„ÇãÊ¨°ÂÄôË£úÈÅ∏Êäû
   - Êé¢Á¥¢„Å®Ê¥ªÁî®„ÅÆ„Éê„É©„É≥„Çπ</p>
</li>
<li>
<p><strong>ÂÆüË£Ö</strong>:
   - scikit-optimize: Á∞°Âçò„Å™ÊúÄÈÅ©Âåñ
   - „Ç´„Çπ„Çø„É†„ÇØ„É≠„Éº„Ç∫„Éâ„É´„Éº„Éó„Ç∑„Çπ„ÉÜ„É†
   - „É≠„Éú„ÉÉ„Éà„Éª„Çª„É≥„Çµ„ÉºÁµ±Âêà</p>
</li>
<li>
<p><strong>ÂÆüÂøúÁî®</strong>:
   - ÈáèÂ≠ê„Éâ„ÉÉ„ÉàÁô∫ÂÖâÊ≥¢Èï∑ÊúÄÈÅ©Âåñ
   - 30Âõû„ÅÆÂÆüÈ®ì„ÅßÁõÆÊ®ôÈÅîÊàê
   - ÂæìÊù•„ÅÆË©¶Ë°åÈåØË™§ÔºàÊï∞ÈÄ±ÈñìÔºâ‚ÜíËá™ÂãïÂåñÔºà1Êó•Ôºâ</p>
</li>
<li>
<p><strong>È´òÂ∫¶„Å™ÊâãÊ≥ï</strong>:
   - Âà∂Á¥Ñ‰ªò„ÅçÊúÄÈÅ©Âåñ
   - Â§öÁõÆÁöÑÊúÄÈÅ©Âåñ</p>
</li>
</ol>
<h3>Ê¨°Á´†‰∫àÂëä</h3>
<p>Á¨¨4Á´†„Åß„ÅØ„ÄÅ„ÇØ„É©„Ç¶„Éâ„É©„ÉúÔºàEmerald Cloud LabÔºâ„Çí‰Ωø„Å£„ÅüÈÅ†ÈöîÂÆüÈ®ì„ÇíÂ≠¶„Å≥„Åæ„Åô„ÄÇË£ÖÁΩÆ„ÇíÊåÅ„Åü„Åö„Å´API„ÅßÂÆüÈ®ì„Çí‰æùÈ†º„Åó„ÄÅ„Éá„Éº„Çø„ÇíËá™ÂãïÂèñÂæó„Åô„ÇãÊúÄÂÖàÁ´Ø„ÅÆÂÆüÈ®ìÁí∞Â¢É„Çí‰ΩìÈ®ì„Åó„Åæ„Åô„ÄÇ</p>
<hr />
<h2>ÂèÇËÄÉÊñáÁåÆ</h2>
<ol>
<li>Shahriari, B. et al. (2016). "Taking the Human Out of the Loop: A Review of Bayesian Optimization." <em>Proceedings of the IEEE</em>, 104(1), 148-175.</li>
<li>Rasmussen, C. E., &amp; Williams, C. K. I. (2006). <em>Gaussian Processes for Machine Learning</em>. MIT Press.</li>
<li>MacLeod, B. P. et al. (2020). "Self-driving laboratory for accelerated discovery of thin-film materials." <em>Science Advances</em>, 6(20), eaaz8867.</li>
<li>H√§se, F. et al. (2018). "Next-Generation Experimentation with Self-Driving Laboratories." <em>Trends in Chemistry</em>, 1(3), 282-291.</li>
</ol>
<hr />
<p><strong>Ê¨°„ÅÆÁ´†„Å∏</strong>: <a href="chapter-4.html">Á¨¨4Á´†: „ÇØ„É©„Ç¶„Éâ„É©„Éú„Å®ÈÅ†ÈöîÂÆüÈ®ì</a></p>
<p><a href="index.html">ÁõÆÊ¨°„Å´Êàª„Çã</a></p><div class="navigation">
    <a href="chapter-2.html" class="nav-button">‚Üê Ââç„ÅÆÁ´†</a>
    <a href="index.html" class="nav-button">„Ç∑„É™„Éº„Ç∫ÁõÆÊ¨°„Å´Êàª„Çã</a>
    <a href="chapter-4.html" class="nav-button">Ê¨°„ÅÆÁ´† ‚Üí</a>
</div>
    </main>

    <footer>
        <p><strong>‰ΩúÊàêËÄÖ</strong>: AI Terakoya Content Team</p>
        <p><strong>Áõ£‰øÆ</strong>: Dr. Yusuke HashimotoÔºàÊù±ÂåóÂ§ßÂ≠¶Ôºâ</p>
        <p><strong>„Éê„Éº„Ç∏„Éß„É≥</strong>: 1.0 | <strong>‰ΩúÊàêÊó•</strong>: 2025-10-17</p>
        <p><strong>„É©„Ç§„Çª„É≥„Çπ</strong>: Creative Commons BY 4.0</p>
        <p>¬© 2025 AI Terakoya. All rights reserved.</p>
    </footer>
</body>
</html>
