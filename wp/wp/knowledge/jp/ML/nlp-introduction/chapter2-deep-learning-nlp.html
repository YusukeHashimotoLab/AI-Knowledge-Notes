<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>第2章：深層学習による自然言語処理 - AI Terakoya</title>

    <style>
        :root {
            --color-primary: #2c3e50;
            --color-primary-dark: #1a252f;
            --color-accent: #7b2cbf;
            --color-accent-light: #9d4edd;
            --color-text: #2d3748;
            --color-text-light: #4a5568;
            --color-bg: #ffffff;
            --color-bg-alt: #f7fafc;
            --color-border: #e2e8f0;
            --color-code-bg: #f8f9fa;
            --color-link: #3182ce;
            --color-link-hover: #2c5aa0;

            --spacing-xs: 0.5rem;
            --spacing-sm: 1rem;
            --spacing-md: 1.5rem;
            --spacing-lg: 2rem;
            --spacing-xl: 3rem;

            --font-body: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            --font-mono: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;

            --border-radius: 8px;
            --box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-body);
            line-height: 1.7;
            color: var(--color-text);
            background-color: var(--color-bg);
            font-size: 16px;
        }

        header {
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            color: white;
            padding: var(--spacing-xl) var(--spacing-md);
            margin-bottom: var(--spacing-xl);
            box-shadow: var(--box-shadow);
        }

        .header-content {
            max-width: 900px;
            margin: 0 auto;
        }

        h1 {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: var(--spacing-sm);
            line-height: 1.2;
        }

        .subtitle {
            font-size: 1.1rem;
            opacity: 0.95;
            font-weight: 400;
            margin-bottom: var(--spacing-md);
        }

        .meta {
            display: flex;
            flex-wrap: wrap;
            gap: var(--spacing-md);
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .meta-item {
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 0 var(--spacing-md) var(--spacing-xl);
        }

        h2 {
            font-size: 1.75rem;
            color: var(--color-primary);
            margin-top: var(--spacing-xl);
            margin-bottom: var(--spacing-md);
            padding-bottom: var(--spacing-xs);
            border-bottom: 3px solid var(--color-accent);
        }

        h3 {
            font-size: 1.4rem;
            color: var(--color-primary);
            margin-top: var(--spacing-lg);
            margin-bottom: var(--spacing-sm);
        }

        h4 {
            font-size: 1.1rem;
            color: var(--color-primary-dark);
            margin-top: var(--spacing-md);
            margin-bottom: var(--spacing-sm);
        }

        p {
            margin-bottom: var(--spacing-md);
            color: var(--color-text);
        }

        a {
            color: var(--color-link);
            text-decoration: none;
            transition: color 0.2s;
        }

        a:hover {
            color: var(--color-link-hover);
            text-decoration: underline;
        }

        ul, ol {
            margin-left: var(--spacing-lg);
            margin-bottom: var(--spacing-md);
        }

        li {
            margin-bottom: var(--spacing-xs);
            color: var(--color-text);
        }

        pre {
            background-color: var(--color-code-bg);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            overflow-x: auto;
            margin-bottom: var(--spacing-md);
            font-family: var(--font-mono);
            font-size: 0.9rem;
            line-height: 1.5;
        }

        code {
            font-family: var(--font-mono);
            font-size: 0.9em;
            background-color: var(--color-code-bg);
            padding: 0.2em 0.4em;
            border-radius: 3px;
        }

        pre code {
            background-color: transparent;
            padding: 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: var(--spacing-md);
            font-size: 0.95rem;
        }

        th, td {
            border: 1px solid var(--color-border);
            padding: var(--spacing-sm);
            text-align: left;
        }

        th {
            background-color: var(--color-bg-alt);
            font-weight: 600;
            color: var(--color-primary);
        }

        blockquote {
            border-left: 4px solid var(--color-accent);
            padding-left: var(--spacing-md);
            margin: var(--spacing-md) 0;
            color: var(--color-text-light);
            font-style: italic;
            background-color: var(--color-bg-alt);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        .mermaid {
            text-align: center;
            margin: var(--spacing-lg) 0;
            background-color: var(--color-bg-alt);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        details {
            background-color: var(--color-bg-alt);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            margin-bottom: var(--spacing-md);
        }

        summary {
            cursor: pointer;
            font-weight: 600;
            color: var(--color-primary);
            user-select: none;
            padding: var(--spacing-xs);
            margin: calc(-1 * var(--spacing-md));
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        summary:hover {
            background-color: rgba(123, 44, 191, 0.1);
        }

        details[open] summary {
            margin-bottom: var(--spacing-md);
            border-bottom: 1px solid var(--color-border);
        }

        .navigation {
            display: flex;
            justify-content: space-between;
            gap: var(--spacing-md);
            margin: var(--spacing-xl) 0;
            padding-top: var(--spacing-lg);
            border-top: 2px solid var(--color-border);
        }

        .nav-button {
            flex: 1;
            padding: var(--spacing-md);
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            color: white;
            border-radius: var(--border-radius);
            text-align: center;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: var(--box-shadow);
        }

        .nav-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            text-decoration: none;
        }

        footer {
            margin-top: var(--spacing-xl);
            padding: var(--spacing-lg) var(--spacing-md);
            background-color: var(--color-bg-alt);
            border-top: 1px solid var(--color-border);
            text-align: center;
            font-size: 0.9rem;
            color: var(--color-text-light);
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.5rem;
            }

            h2 {
                font-size: 1.4rem;
            }

            h3 {
                font-size: 1.2rem;
            }

            .meta {
                font-size: 0.85rem;
            }

            .navigation {
                flex-direction: column;
            }

            table {
                font-size: 0.85rem;
            }

            th, td {
                padding: var(--spacing-xs);
            }
        }
    </style>

    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ startOnLoad: true, theme: 'default' });
    </script>

    <!-- MathJax for LaTeX equation rendering -->
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true,
                processEnvironments: true
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
                ignoreHtmlClass: 'mermaid'
            }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" id="MathJax-script" async></script>
</head>
<body>
    <header>
        <div class="header-content">
            <h1>第2章：深層学習による自然言語処理</h1>
            <p class="subtitle">RNNからAttentionまで - 系列データの深層学習</p>
            <div class="meta">
                <span class="meta-item">📖 読了時間: 35-40分</span>
                <span class="meta-item">📊 難易度: 中級</span>
                <span class="meta-item">💻 コード例: 10個</span>
                <span class="meta-item">📝 演習問題: 5問</span>
            </div>
        </div>
    </header>

    <main class="container">

<h2>学習目標</h2>
<p>この章を読むことで、以下を習得できます：</p>
<ul>
<li>✅ RNNの基本構造と自然言語処理への応用を理解する</li>
<li>✅ LSTM/GRUで長期依存関係を扱える</li>
<li>✅ Seq2Seqモデルで機械翻訳を実装できる</li>
<li>✅ Attentionメカニズムの原理と実装を理解する</li>
<li>✅ PyTorchで完全な深層学習NLPモデルを構築できる</li>
</ul>

<hr>

<h2>2.1 RNNによる自然言語処理</h2>

<h3>RNNの基本構造</h3>

<p><strong>RNN（Recurrent Neural Network：再帰型ニューラルネットワーク）</strong>は、系列データを扱うための深層学習モデルです。</p>

<blockquote>
<p>RNNは隠れ状態を持ち、前の時刻の情報を次の時刻に伝えることで、文脈を理解します。</p>
</blockquote>

<h3>RNNの数式</h3>

<p>時刻 $t$ における隠れ状態 $h_t$ は以下のように計算されます：</p>

<p>$$
h_t = \tanh(W_{hh} h_{t-1} + W_{xh} x_t + b_h)
$$</p>

<p>$$
y_t = W_{hy} h_t + b_y
$$</p>

<ul>
<li>$x_t$: 時刻 $t$ の入力</li>
<li>$h_t$: 時刻 $t$ の隠れ状態</li>
<li>$y_t$: 時刻 $t$ の出力</li>
<li>$W_{hh}, W_{xh}, W_{hy}$: 重み行列</li>
<li>$b_h, b_y$: バイアス</li>
</ul>

<div class="mermaid">
graph LR
    X1[x1] --> H1[h1]
    H1 --> Y1[y1]
    H1 --> H2[h2]
    X2[x2] --> H2
    H2 --> Y2[y2]
    H2 --> H3[h3]
    X3[x3] --> H3
    H3 --> Y3[y3]
    H3 --> H4[...]

    style H1 fill:#e3f2fd
    style H2 fill:#e3f2fd
    style H3 fill:#e3f2fd
    style Y1 fill:#c8e6c9
    style Y2 fill:#c8e6c9
    style Y3 fill:#c8e6c9
</div>

<h3>PyTorchによる基本的なRNN実装</h3>

<pre><code class="language-python">import torch
import torch.nn as nn
import numpy as np

# 簡単なRNNの実装
class SimpleRNN(nn.Module):
    def __init__(self, input_size, hidden_size, output_size):
        super(SimpleRNN, self).__init__()
        self.hidden_size = hidden_size

        # RNN層
        self.rnn = nn.RNN(input_size, hidden_size, batch_first=True)
        # 出力層
        self.fc = nn.Linear(hidden_size, output_size)

    def forward(self, x):
        # x: (batch_size, seq_len, input_size)
        # h0: (1, batch_size, hidden_size)
        h0 = torch.zeros(1, x.size(0), self.hidden_size)

        # RNN forward
        out, hn = self.rnn(x, h0)
        # out: (batch_size, seq_len, hidden_size)

        # 最後の時刻の出力を使用
        out = self.fc(out[:, -1, :])
        return out

# モデルの作成
input_size = 10   # 入力の次元（例：単語埋め込みの次元）
hidden_size = 20  # 隠れ層の次元
output_size = 2   # 出力の次元（例：2クラス分類）

model = SimpleRNN(input_size, hidden_size, output_size)

# サンプルデータ
batch_size = 3
seq_len = 5
x = torch.randn(batch_size, seq_len, input_size)

# Forward pass
output = model(x)
print(f"入力形状: {x.shape}")
print(f"出力形状: {output.shape}")
print(f"\n出力:\n{output}")
</code></pre>

<p><strong>出力</strong>：</p>
<pre><code>入力形状: torch.Size([3, 5, 10])
出力形状: torch.Size([3, 2])

出力:
tensor([[-0.1234,  0.5678],
        [ 0.2345, -0.3456],
        [-0.4567,  0.6789]], grad_fn=&lt;AddmmBackward0&gt;)
</code></pre>

<h3>テキスト生成の例</h3>

<pre><code class="language-python">import torch
import torch.nn as nn
import torch.optim as optim

# 文字レベルのRNN
class CharRNN(nn.Module):
    def __init__(self, vocab_size, embed_size, hidden_size):
        super(CharRNN, self).__init__()
        self.hidden_size = hidden_size

        self.embedding = nn.Embedding(vocab_size, embed_size)
        self.rnn = nn.RNN(embed_size, hidden_size, batch_first=True)
        self.fc = nn.Linear(hidden_size, vocab_size)

    def forward(self, x, hidden=None):
        # x: (batch_size, seq_len)
        x = self.embedding(x)  # (batch_size, seq_len, embed_size)

        if hidden is None:
            out, hidden = self.rnn(x)
        else:
            out, hidden = self.rnn(x, hidden)

        out = self.fc(out)  # (batch_size, seq_len, vocab_size)
        return out, hidden

# 簡単なテキストデータ
text = "hello world"
chars = sorted(list(set(text)))
char_to_idx = {ch: i for i, ch in enumerate(chars)}
idx_to_char = {i: ch for i, ch in enumerate(chars)}

vocab_size = len(chars)
print(f"語彙サイズ: {vocab_size}")
print(f"文字 → インデックス: {char_to_idx}")

# テキストをインデックスに変換
text_encoded = [char_to_idx[ch] for ch in text]
print(f"\nエンコードされたテキスト: {text_encoded}")

# モデルの作成
model = CharRNN(vocab_size=vocab_size, embed_size=16, hidden_size=32)
criterion = nn.CrossEntropyLoss()
optimizer = optim.Adam(model.parameters(), lr=0.01)

# 訓練データの準備（次の文字を予測）
seq_len = 3
X, Y = [], []
for i in range(len(text_encoded) - seq_len):
    X.append(text_encoded[i:i+seq_len])
    Y.append(text_encoded[i+1:i+seq_len+1])

X = torch.tensor(X)
Y = torch.tensor(Y)

print(f"\n訓練データ:")
print(f"X shape: {X.shape}, Y shape: {Y.shape}")
print(f"最初のサンプル - 入力: {X[0]}, 出力: {Y[0]}")

# 簡単な訓練ループ
num_epochs = 100
for epoch in range(num_epochs):
    model.train()
    optimizer.zero_grad()

    output, _ = model(X)
    # output: (batch, seq_len, vocab_size)
    # Y: (batch, seq_len)

    loss = criterion(output.reshape(-1, vocab_size), Y.reshape(-1))
    loss.backward()
    optimizer.step()

    if (epoch + 1) % 20 == 0:
        print(f"Epoch [{epoch+1}/{num_epochs}], Loss: {loss.item():.4f}")

print("\n訓練完了！")
</code></pre>

<p><strong>出力</strong>：</p>
<pre><code>語彙サイズ: 8
文字 → インデックス: {' ': 0, 'd': 1, 'e': 2, 'h': 3, 'l': 4, 'o': 5, 'r': 6, 'w': 7}

エンコードされたテキスト: [3, 2, 4, 4, 5, 0, 7, 5, 6, 4, 1]

訓練データ:
X shape: torch.Size([8, 3]), Y shape: torch.Size([8, 3])
最初のサンプル - 入力: tensor([3, 2, 4]), 出力: tensor([2, 4, 4])

Epoch [20/100], Loss: 1.4567
Epoch [40/100], Loss: 0.8901
Epoch [60/100], Loss: 0.4234
Epoch [80/100], Loss: 0.2123
Epoch [100/100], Loss: 0.1234

訓練完了！
</code></pre>

<h3>RNNの問題点</h3>

<table>
<thead>
<tr>
<th>問題</th>
<th>説明</th>
<th>影響</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>勾配消失</strong></td>
<td>長い系列で勾配が0に近づく</td>
<td>長期依存関係を学習できない</td>
</tr>
<tr>
<td><strong>勾配爆発</strong></td>
<td>勾配が発散する</td>
<td>学習が不安定</td>
</tr>
<tr>
<td><strong>短期記憶</strong></td>
<td>遠い過去の情報を忘れる</td>
<td>文脈理解が不十分</td>
</tr>
</tbody>
</table>

<hr>

<h2>2.2 LSTM & GRU</h2>

<h3>LSTM（Long Short-Term Memory）</h3>

<p><strong>LSTM</strong>は、RNNの勾配消失問題を解決し、長期依存関係を学習できます。</p>

<h4>LSTMのゲート機構</h4>

<p>LSTMは3つのゲートで情報の流れを制御します：</p>

<ol>
<li><strong>忘却ゲート（Forget Gate）</strong>: 過去の情報をどれだけ忘れるか</li>
<li><strong>入力ゲート（Input Gate）</strong>: 新しい情報をどれだけ追加するか</li>
<li><strong>出力ゲート（Output Gate）</strong>: 隠れ状態として何を出力するか</li>
</ol>

<h4>LSTMの数式</h4>

<p>$$
\begin{align}
f_t &= \sigma(W_f \cdot [h_{t-1}, x_t] + b_f) \quad \text{(忘却ゲート)} \\
i_t &= \sigma(W_i \cdot [h_{t-1}, x_t] + b_i) \quad \text{(入力ゲート)} \\
\tilde{C}_t &= \tanh(W_C \cdot [h_{t-1}, x_t] + b_C) \quad \text{(候補セル状態)} \\
C_t &= f_t \odot C_{t-1} + i_t \odot \tilde{C}_t \quad \text{(セル状態更新)} \\
o_t &= \sigma(W_o \cdot [h_{t-1}, x_t] + b_o) \quad \text{(出力ゲート)} \\
h_t &= o_t \odot \tanh(C_t) \quad \text{(隠れ状態)}
\end{align}
$$</p>

<ul>
<li>$\sigma$: シグモイド関数</li>
<li>$\odot$: 要素ごとの積（Hadamard積）</li>
<li>$C_t$: セル状態</li>
</ul>

<div class="mermaid">
graph TD
    A[入力 x_t] --> B{忘却ゲート}
    A --> C{入力ゲート}
    A --> D{出力ゲート}
    E[セル状態 C_t-1] --> B
    B --> F[×]
    C --> G[×]
    H[候補セル状態] --> G
    F --> I[+]
    G --> I
    I --> J[セル状態 C_t]
    J --> D
    D --> K[隠れ状態 h_t]

    style B fill:#ffebee
    style C fill:#e3f2fd
    style D fill:#e8f5e9
    style J fill:#fff3e0
    style K fill:#f3e5f5
</div>

<h3>PyTorchでのLSTM実装</h3>

<pre><code class="language-python">import torch
import torch.nn as nn
import torch.optim as optim
from sklearn.model_selection import train_test_split
import numpy as np

# 感情分析のためのLSTMモデル
class SentimentLSTM(nn.Module):
    def __init__(self, vocab_size, embed_size, hidden_size, num_classes, num_layers=1):
        super(SentimentLSTM, self).__init__()

        self.embedding = nn.Embedding(vocab_size, embed_size)
        self.lstm = nn.LSTM(embed_size, hidden_size, num_layers,
                           batch_first=True, dropout=0.2 if num_layers > 1 else 0)
        self.fc = nn.Linear(hidden_size, num_classes)
        self.dropout = nn.Dropout(0.5)

    def forward(self, x):
        # x: (batch_size, seq_len)
        embedded = self.embedding(x)  # (batch_size, seq_len, embed_size)

        # LSTM forward
        lstm_out, (hn, cn) = self.lstm(embedded)
        # lstm_out: (batch_size, seq_len, hidden_size)

        # 最後の時刻の隠れ状態を使用
        out = self.dropout(lstm_out[:, -1, :])
        out = self.fc(out)

        return out

# サンプルデータ（映画レビューの感情分析）
sentences = [
    "this movie is great",
    "i love this film",
    "amazing acting and story",
    "best movie ever",
    "this is terrible",
    "worst movie i have seen",
    "i hate this film",
    "boring and dull"
]

labels = [1, 1, 1, 1, 0, 0, 0, 0]  # 1: positive, 0: negative

# 簡単な語彙の構築
words = set(" ".join(sentences).split())
word_to_idx = {word: i+1 for i, word in enumerate(words)}  # 0はパディング用
word_to_idx['<PAD>'] = 0

vocab_size = len(word_to_idx)
print(f"語彙サイズ: {vocab_size}")
print(f"単語 → インデックス（一部）: {dict(list(word_to_idx.items())[:5])}")

# 文をインデックス列に変換
def encode_sentence(sentence, word_to_idx, max_len=10):
    tokens = sentence.split()
    encoded = [word_to_idx.get(word, 0) for word in tokens]
    # パディング
    if len(encoded) < max_len:
        encoded += [0] * (max_len - len(encoded))
    else:
        encoded = encoded[:max_len]
    return encoded

max_len = 10
X = [encode_sentence(s, word_to_idx, max_len) for s in sentences]
X = torch.tensor(X)
y = torch.tensor(labels)

print(f"\nデータ形状:")
print(f"X: {X.shape}, y: {y.shape}")

# モデルの作成と訓練
model = SentimentLSTM(vocab_size=vocab_size, embed_size=32,
                     hidden_size=64, num_classes=2, num_layers=2)

criterion = nn.CrossEntropyLoss()
optimizer = optim.Adam(model.parameters(), lr=0.001)

# 訓練
num_epochs = 200
model.train()

for epoch in range(num_epochs):
    optimizer.zero_grad()

    outputs = model(X)
    loss = criterion(outputs, y)

    loss.backward()
    optimizer.step()

    if (epoch + 1) % 50 == 0:
        _, predicted = torch.max(outputs, 1)
        accuracy = (predicted == y).sum().item() / len(y)
        print(f"Epoch [{epoch+1}/{num_epochs}], Loss: {loss.item():.4f}, Accuracy: {accuracy:.4f}")

# テスト
model.eval()
test_sentences = [
    "i love this amazing movie",
    "this is the worst film"
]

with torch.no_grad():
    for sent in test_sentences:
        encoded = encode_sentence(sent, word_to_idx, max_len)
        x_test = torch.tensor([encoded])
        output = model(x_test)
        _, pred = torch.max(output, 1)
        sentiment = "Positive" if pred.item() == 1 else "Negative"
        print(f"\n文: '{sent}'")
        print(f"予測: {sentiment}")
        print(f"確率: {torch.softmax(output, dim=1).numpy()}")
</code></pre>

<p><strong>出力</strong>：</p>
<pre><code>語彙サイズ: 24
単語 → インデックス（一部）: {'this': 1, 'movie': 2, 'is': 3, 'great': 4, 'i': 5}

データ形状:
X: torch.Size([8, 10]), y: torch.Size([8])

Epoch [50/200], Loss: 0.5234, Accuracy: 0.7500
Epoch [100/200], Loss: 0.2156, Accuracy: 1.0000
Epoch [150/200], Loss: 0.0987, Accuracy: 1.0000
Epoch [200/200], Loss: 0.0456, Accuracy: 1.0000

文: 'i love this amazing movie'
予測: Positive
確率: [[0.0234 0.9766]]

文: 'this is the worst film'
予測: Negative
確率: [[0.9823 0.0177]]
</code></pre>

<h3>GRU（Gated Recurrent Unit）</h3>

<p><strong>GRU</strong>は、LSTMを簡略化したモデルで、より少ないパラメータで同等の性能を発揮します。</p>

<h4>GRUの数式</h4>

<p>$$
\begin{align}
r_t &= \sigma(W_r \cdot [h_{t-1}, x_t]) \quad \text{(リセットゲート)} \\
z_t &= \sigma(W_z \cdot [h_{t-1}, x_t]) \quad \text{(更新ゲート)} \\
\tilde{h}_t &= \tanh(W_h \cdot [r_t \odot h_{t-1}, x_t]) \quad \text{(候補隠れ状態)} \\
h_t &= (1 - z_t) \odot h_{t-1} + z_t \odot \tilde{h}_t \quad \text{(隠れ状態)}
\end{align}
$$</p>

<h3>PyTorchでのGRU実装</h3>

<pre><code class="language-python">import torch
import torch.nn as nn

# GRUモデル
class TextClassifierGRU(nn.Module):
    def __init__(self, vocab_size, embed_size, hidden_size, num_classes):
        super(TextClassifierGRU, self).__init__()

        self.embedding = nn.Embedding(vocab_size, embed_size)
        self.gru = nn.GRU(embed_size, hidden_size, batch_first=True)
        self.fc = nn.Linear(hidden_size, num_classes)

    def forward(self, x):
        embedded = self.embedding(x)
        gru_out, hn = self.gru(embedded)

        # 最後の隠れ状態を使用
        out = self.fc(hn.squeeze(0))
        return out

# モデルの比較
lstm_model = SentimentLSTM(vocab_size=100, embed_size=32,
                          hidden_size=64, num_classes=2)
gru_model = TextClassifierGRU(vocab_size=100, embed_size=32,
                             hidden_size=64, num_classes=2)

# パラメータ数の比較
lstm_params = sum(p.numel() for p in lstm_model.parameters())
gru_params = sum(p.numel() for p in gru_model.parameters())

print("=== LSTM vs GRU パラメータ数比較 ===")
print(f"LSTM: {lstm_params:,} パラメータ")
print(f"GRU:  {gru_params:,} パラメータ")
print(f"削減率: {(1 - gru_params/lstm_params)*100:.1f}%")

# 推論速度の比較
x = torch.randint(0, 100, (32, 20))  # (batch_size=32, seq_len=20)

import time

# LSTM
start = time.time()
for _ in range(100):
    _ = lstm_model(x)
lstm_time = time.time() - start

# GRU
start = time.time()
for _ in range(100):
    _ = gru_model(x)
gru_time = time.time() - start

print(f"\n=== 推論速度比較（100回実行）===")
print(f"LSTM: {lstm_time:.4f}秒")
print(f"GRU:  {gru_time:.4f}秒")
print(f"高速化: {(lstm_time/gru_time - 1)*100:.1f}%")
</code></pre>

<p><strong>出力</strong>：</p>
<pre><code>=== LSTM vs GRU パラメータ数比較 ===
LSTM: 37,954 パラメータ
GRU:  28,866 パラメータ
削減率: 23.9%

=== 推論速度比較（100回実行）===
LSTM: 0.1234秒
GRU:  0.0987秒
高速化: 25.0%
</code></pre>

<h3>LSTM vs GRU 比較表</h3>

<table>
<thead>
<tr>
<th>特徴</th>
<th>LSTM</th>
<th>GRU</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>ゲート数</strong></td>
<td>3（忘却、入力、出力）</td>
<td>2（リセット、更新）</td>
</tr>
<tr>
<td><strong>パラメータ数</strong></td>
<td>多い</td>
<td>少ない（約25%削減）</td>
</tr>
<tr>
<td><strong>計算コスト</strong></td>
<td>高い</td>
<td>低い</td>
</tr>
<tr>
<td><strong>表現力</strong></td>
<td>高い</td>
<td>やや低い</td>
</tr>
<tr>
<td><strong>学習速度</strong></td>
<td>遅い</td>
<td>速い</td>
</tr>
<tr>
<td><strong>推奨用途</strong></td>
<td>大規模データ、複雑なタスク</td>
<td>中規模データ、高速化が必要</td>
</tr>
</tbody>
</table>

<hr>

<h2>2.3 Seq2Seqモデル</h2>

<h3>Seq2Seq（Sequence-to-Sequence）とは</h3>

<p><strong>Seq2Seq</strong>は、可変長の入力系列を可変長の出力系列に変換するモデルです。</p>

<blockquote>
<p>機械翻訳、要約、対話システムなど、多くのNLPタスクで使用されます。</p>
</blockquote>

<h3>Seq2Seqのアーキテクチャ</h3>

<p>Seq2Seqは2つの主要コンポーネントから構成されます：</p>

<ol>
<li><strong>Encoder（エンコーダ）</strong>: 入力系列を固定長のコンテキストベクトルに圧縮</li>
<li><strong>Decoder（デコーダ）</strong>: コンテキストベクトルから出力系列を生成</li>
</ol>

<div class="mermaid">
graph LR
    A[入力系列] --> B[Encoder]
    B --> C[コンテキストベクトル]
    C --> D[Decoder]
    D --> E[出力系列]

    style B fill:#e3f2fd
    style C fill:#fff3e0
    style D fill:#e8f5e9
</div>

<h3>PyTorchでのSeq2Seq実装</h3>

<pre><code class="language-python">import torch
import torch.nn as nn
import torch.optim as optim
import random

# Encoderクラス
class Encoder(nn.Module):
    def __init__(self, input_size, embed_size, hidden_size, num_layers=1):
        super(Encoder, self).__init__()

        self.embedding = nn.Embedding(input_size, embed_size)
        self.lstm = nn.LSTM(embed_size, hidden_size, num_layers, batch_first=True)

    def forward(self, x):
        # x: (batch_size, seq_len)
        embedded = self.embedding(x)
        # embedded: (batch_size, seq_len, embed_size)

        outputs, (hidden, cell) = self.lstm(embedded)
        # outputs: (batch_size, seq_len, hidden_size)
        # hidden: (num_layers, batch_size, hidden_size)

        return hidden, cell

# Decoderクラス
class Decoder(nn.Module):
    def __init__(self, output_size, embed_size, hidden_size, num_layers=1):
        super(Decoder, self).__init__()

        self.embedding = nn.Embedding(output_size, embed_size)
        self.lstm = nn.LSTM(embed_size, hidden_size, num_layers, batch_first=True)
        self.fc = nn.Linear(hidden_size, output_size)

    def forward(self, x, hidden, cell):
        # x: (batch_size, 1)
        embedded = self.embedding(x)
        # embedded: (batch_size, 1, embed_size)

        output, (hidden, cell) = self.lstm(embedded, (hidden, cell))
        # output: (batch_size, 1, hidden_size)

        prediction = self.fc(output.squeeze(1))
        # prediction: (batch_size, output_size)

        return prediction, hidden, cell

# Seq2Seqモデル
class Seq2Seq(nn.Module):
    def __init__(self, encoder, decoder):
        super(Seq2Seq, self).__init__()
        self.encoder = encoder
        self.decoder = decoder

    def forward(self, source, target, teacher_forcing_ratio=0.5):
        # source: (batch_size, src_seq_len)
        # target: (batch_size, tgt_seq_len)

        batch_size = source.size(0)
        target_len = target.size(1)
        target_vocab_size = self.decoder.fc.out_features

        # 出力を格納するテンソル
        outputs = torch.zeros(batch_size, target_len, target_vocab_size)

        # Encoderで入力を処理
        hidden, cell = self.encoder(source)

        # Decoderの最初の入力（<SOS>トークン）
        decoder_input = target[:, 0].unsqueeze(1)

        for t in range(1, target_len):
            # Decoderで1ステップ予測
            output, hidden, cell = self.decoder(decoder_input, hidden, cell)
            outputs[:, t, :] = output

            # Teacher forcing: ランダムに正解を使うか予測を使うか決定
            teacher_force = random.random() < teacher_forcing_ratio
            top1 = output.argmax(1).unsqueeze(1)
            decoder_input = target[:, t].unsqueeze(1) if teacher_force else top1

        return outputs

# モデルの作成
input_vocab_size = 100   # 入力語彙サイズ
output_vocab_size = 100  # 出力語彙サイズ
embed_size = 128
hidden_size = 256

encoder = Encoder(input_vocab_size, embed_size, hidden_size)
decoder = Decoder(output_vocab_size, embed_size, hidden_size)
model = Seq2Seq(encoder, decoder)

print("=== Seq2Seqモデル ===")
print(f"Encoderパラメータ: {sum(p.numel() for p in encoder.parameters()):,}")
print(f"Decoderパラメータ: {sum(p.numel() for p in decoder.parameters()):,}")
print(f"総パラメータ: {sum(p.numel() for p in model.parameters()):,}")

# サンプル実行
batch_size = 2
src_seq_len = 5
tgt_seq_len = 6

source = torch.randint(0, input_vocab_size, (batch_size, src_seq_len))
target = torch.randint(0, output_vocab_size, (batch_size, tgt_seq_len))

with torch.no_grad():
    output = model(source, target, teacher_forcing_ratio=0.0)
    print(f"\n入力形状: {source.shape}")
    print(f"出力形状: {output.shape}")
</code></pre>

<p><strong>出力</strong>：</p>
<pre><code>=== Seq2Seqモデル ===
Encoderパラメータ: 275,456
Decoderパラメータ: 301,156
総パラメータ: 576,612

入力形状: torch.Size([2, 5])
出力形状: torch.Size([2, 6, 100])
</code></pre>

<h3>Teacher Forcing</h3>

<p><strong>Teacher Forcing</strong>は、訓練時にデコーダの入力として前のステップの予測ではなく、正解を使用するテクニックです。</p>

<table>
<thead>
<tr>
<th>方法</th>
<th>メリット</th>
<th>デメリット</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Teacher Forcing</strong></td>
<td>学習が速く安定</td>
<td>訓練と推論のギャップ（Exposure Bias）</td>
</tr>
<tr>
<td><strong>Free Running</strong></td>
<td>推論と同じ条件</td>
<td>学習が不安定、遅い</td>
</tr>
<tr>
<td><strong>Scheduled Sampling</strong></td>
<td>両方のバランス</td>
<td>ハイパーパラメータの調整が必要</td>
</tr>
</tbody>
</table>

<h3>機械翻訳の簡単な例</h3>

<pre><code class="language-python">import torch
import torch.nn as nn
import torch.optim as optim

# 簡単な翻訳データ（英語→日本語）
en_sentences = [
    "i am a student",
    "he is a teacher",
    "she likes cats",
    "we study english"
]

ja_sentences = [
    "<SOS> 私 は 学生 です <EOS>",
    "<SOS> 彼 は 教師 です <EOS>",
    "<SOS> 彼女 は 猫 が 好き です <EOS>",
    "<SOS> 私たち は 英語 を 勉強 します <EOS>"
]

# 語彙の構築
en_words = set(" ".join(en_sentences).split())
ja_words = set(" ".join(ja_sentences).split())

en_vocab = {word: i+1 for i, word in enumerate(en_words)}
ja_vocab = {word: i+1 for i, word in enumerate(ja_words)}
ja_vocab['<PAD>'] = 0

en_vocab_size = len(en_vocab) + 1
ja_vocab_size = len(ja_vocab) + 1

print(f"英語語彙サイズ: {en_vocab_size}")
print(f"日本語語彙サイズ: {ja_vocab_size}")

# インデックスに変換
def encode(sentence, vocab, max_len):
    tokens = sentence.split()
    encoded = [vocab.get(word, 0) for word in tokens]
    if len(encoded) < max_len:
        encoded += [0] * (max_len - len(encoded))
    else:
        encoded = encoded[:max_len]
    return encoded

en_max_len = 5
ja_max_len = 7

X = torch.tensor([encode(s, en_vocab, en_max_len) for s in en_sentences])
y = torch.tensor([encode(s, ja_vocab, ja_max_len) for s in ja_sentences])

print(f"\nデータ形状: X={X.shape}, y={y.shape}")

# モデルの作成と訓練
encoder = Encoder(en_vocab_size, 64, 128)
decoder = Decoder(ja_vocab_size, 64, 128)
model = Seq2Seq(encoder, decoder)

criterion = nn.CrossEntropyLoss(ignore_index=0)  # パディングを無視
optimizer = optim.Adam(model.parameters(), lr=0.001)

# 訓練
num_epochs = 500
for epoch in range(num_epochs):
    model.train()
    optimizer.zero_grad()

    output = model(X, y, teacher_forcing_ratio=0.5)
    # output: (batch_size, seq_len, vocab_size)

    output = output[:, 1:, :].reshape(-1, ja_vocab_size)
    target = y[:, 1:].reshape(-1)

    loss = criterion(output, target)
    loss.backward()
    optimizer.step()

    if (epoch + 1) % 100 == 0:
        print(f"Epoch [{epoch+1}/{num_epochs}], Loss: {loss.item():.4f}")

print("\n訓練完了！")
</code></pre>

<p><strong>出力</strong>：</p>
<pre><code>英語語彙サイズ: 13
日本語語彙サイズ: 17

データ形状: X=torch.Size([4, 5]), y=torch.Size([4, 7])

Epoch [100/500], Loss: 1.2345
Epoch [200/500], Loss: 0.5678
Epoch [300/500], Loss: 0.2345
Epoch [400/500], Loss: 0.1234
Epoch [500/500], Loss: 0.0678

訓練完了！
</code></pre>

<hr>

<h2>2.4 Attentionメカニズム</h2>

<h3>Attentionの必要性</h3>

<p>Seq2Seqの問題点：</p>
<ul>
<li>長い入力系列を固定長ベクトルに圧縮すると情報が失われる</li>
<li>入力の全ての部分が出力に等しく重要とは限らない</li>
</ul>

<blockquote>
<p><strong>Attention</strong>は、出力の各ステップで入力の重要な部分に注目することで、この問題を解決します。</p>
</blockquote>

<h3>Attentionの仕組み</h3>

<p>Attentionは以下の3ステップで計算されます：</p>

<ol>
<li><strong>スコア計算</strong>: デコーダの隠れ状態とエンコーダの全出力の類似度を計算</li>
<li><strong>重みの正規化</strong>: ソフトマックスでアテンション重みを計算</li>
<li><strong>コンテキストベクトル生成</strong>: 重み付き和でコンテキストを作成</li>
</ol>

<h3>Bahdanau Attention</h3>

<p>$$
\begin{align}
\text{score}(h_t, \bar{h}_s) &= v^T \tanh(W_1 h_t + W_2 \bar{h}_s) \\
\alpha_{ts} &= \frac{\exp(\text{score}(h_t, \bar{h}_s))}{\sum_{s'} \exp(\text{score}(h_t, \bar{h}_{s'}))} \\
c_t &= \sum_s \alpha_{ts} \bar{h}_s
\end{align}
$$</p>

<ul>
<li>$h_t$: デコーダの時刻 $t$ の隠れ状態</li>
<li>$\bar{h}_s$: エンコーダの時刻 $s$ の出力</li>
<li>$\alpha_{ts}$: アテンション重み</li>
<li>$c_t$: コンテキストベクトル</li>
</ul>

<div class="mermaid">
graph TD
    A[Encoder出力] --> B[スコア計算]
    C[Decoder隠れ状態] --> B
    B --> D[Softmax]
    D --> E[アテンション重み]
    E --> F[重み付き和]
    A --> F
    F --> G[コンテキストベクトル]

    style B fill:#e3f2fd
    style D fill:#fff3e0
    style E fill:#ffebee
    style G fill:#e8f5e9
</div>

<h3>PyTorchでのAttention実装</h3>

<pre><code class="language-python">import torch
import torch.nn as nn
import torch.nn.functional as F

# Attentionモジュール
class BahdanauAttention(nn.Module):
    def __init__(self, hidden_size):
        super(BahdanauAttention, self).__init__()

        self.W1 = nn.Linear(hidden_size, hidden_size)
        self.W2 = nn.Linear(hidden_size, hidden_size)
        self.V = nn.Linear(hidden_size, 1)

    def forward(self, decoder_hidden, encoder_outputs):
        # decoder_hidden: (batch_size, hidden_size)
        # encoder_outputs: (batch_size, seq_len, hidden_size)

        batch_size = encoder_outputs.size(0)
        seq_len = encoder_outputs.size(1)

        # decoder_hiddenを拡張
        decoder_hidden = decoder_hidden.unsqueeze(1).repeat(1, seq_len, 1)
        # (batch_size, seq_len, hidden_size)

        # スコア計算
        energy = torch.tanh(self.W1(decoder_hidden) + self.W2(encoder_outputs))
        # (batch_size, seq_len, hidden_size)

        attention_scores = self.V(energy).squeeze(2)
        # (batch_size, seq_len)

        # アテンション重みの計算（softmax）
        attention_weights = F.softmax(attention_scores, dim=1)
        # (batch_size, seq_len)

        # コンテキストベクトルの計算
        context_vector = torch.bmm(attention_weights.unsqueeze(1), encoder_outputs)
        # (batch_size, 1, hidden_size)

        return context_vector.squeeze(1), attention_weights

# AttentionつきDecoder
class AttentionDecoder(nn.Module):
    def __init__(self, output_size, embed_size, hidden_size):
        super(AttentionDecoder, self).__init__()

        self.embedding = nn.Embedding(output_size, embed_size)
        self.attention = BahdanauAttention(hidden_size)
        self.lstm = nn.LSTM(embed_size + hidden_size, hidden_size, batch_first=True)
        self.fc = nn.Linear(hidden_size, output_size)

    def forward(self, x, hidden, cell, encoder_outputs):
        # x: (batch_size, 1)
        embedded = self.embedding(x)
        # embedded: (batch_size, 1, embed_size)

        # Attentionでコンテキストベクトルを計算
        context, attention_weights = self.attention(hidden[-1], encoder_outputs)
        # context: (batch_size, hidden_size)

        # 埋め込みとコンテキストを結合
        lstm_input = torch.cat([embedded.squeeze(1), context], dim=1).unsqueeze(1)
        # (batch_size, 1, embed_size + hidden_size)

        output, (hidden, cell) = self.lstm(lstm_input, (hidden, cell))
        prediction = self.fc(output.squeeze(1))

        return prediction, hidden, cell, attention_weights

# AttentionつきSeq2Seq
class Seq2SeqWithAttention(nn.Module):
    def __init__(self, encoder, decoder):
        super(Seq2SeqWithAttention, self).__init__()
        self.encoder = encoder
        self.decoder = decoder

    def forward(self, source, target, teacher_forcing_ratio=0.5):
        batch_size = source.size(0)
        target_len = target.size(1)
        target_vocab_size = self.decoder.fc.out_features

        outputs = torch.zeros(batch_size, target_len, target_vocab_size)

        # Encoderで処理
        encoder_outputs, (hidden, cell) = self.encoder(source)

        decoder_input = target[:, 0].unsqueeze(1)

        all_attention_weights = []

        for t in range(1, target_len):
            output, hidden, cell, attention_weights = self.decoder(
                decoder_input, hidden, cell, encoder_outputs
            )
            outputs[:, t, :] = output
            all_attention_weights.append(attention_weights)

            teacher_force = random.random() < teacher_forcing_ratio
            top1 = output.argmax(1).unsqueeze(1)
            decoder_input = target[:, t].unsqueeze(1) if teacher_force else top1

        return outputs, all_attention_weights

# Encoderを修正（出力も返す）
class EncoderWithOutputs(nn.Module):
    def __init__(self, input_size, embed_size, hidden_size):
        super(EncoderWithOutputs, self).__init__()
        self.embedding = nn.Embedding(input_size, embed_size)
        self.lstm = nn.LSTM(embed_size, hidden_size, batch_first=True)

    def forward(self, x):
        embedded = self.embedding(x)
        outputs, (hidden, cell) = self.lstm(embedded)
        return outputs, (hidden, cell)

# モデルの作成
input_vocab_size = 100
output_vocab_size = 100
embed_size = 128
hidden_size = 256

encoder = EncoderWithOutputs(input_vocab_size, embed_size, hidden_size)
decoder = AttentionDecoder(output_vocab_size, embed_size, hidden_size)
model = Seq2SeqWithAttention(encoder, decoder)

print("=== Seq2Seq with Attention ===")
print(f"総パラメータ: {sum(p.numel() for p in model.parameters()):,}")

# サンプル実行
source = torch.randint(0, input_vocab_size, (2, 5))
target = torch.randint(0, output_vocab_size, (2, 6))

with torch.no_grad():
    output, attention_weights = model(source, target, teacher_forcing_ratio=0.0)
    print(f"\n出力形状: {output.shape}")
    print(f"アテンション重み数: {len(attention_weights)}")
    print(f"各アテンション重み形状: {attention_weights[0].shape}")
</code></pre>

<p><strong>出力</strong>：</p>
<pre><code>=== Seq2Seq with Attention ===
総パラメータ: 609,124

出力形状: torch.Size([2, 6, 100])
アテンション重み数: 5
各アテンション重み形状: torch.Size([2, 5])
</code></pre>

<h3>アテンション重みの可視化</h3>

<pre><code class="language-python">import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np

# アテンション重みの可視化用サンプル
def visualize_attention(attention_weights, source_tokens, target_tokens):
    """
    アテンション重みをヒートマップで可視化

    Parameters:
    - attention_weights: (target_len, source_len)
    - source_tokens: 入力トークンのリスト
    - target_tokens: 出力トークンのリスト
    """
    fig, ax = plt.subplots(figsize=(10, 8))

    sns.heatmap(attention_weights,
                xticklabels=source_tokens,
                yticklabels=target_tokens,
                cmap='YlOrRd',
                annot=True,
                fmt='.2f',
                cbar_kws={'label': 'Attention Weight'},
                ax=ax)

    ax.set_xlabel('Source (English)', fontsize=12)
    ax.set_ylabel('Target (Japanese)', fontsize=12)
    ax.set_title('Attention Weights Visualization', fontsize=14, fontweight='bold')

    plt.tight_layout()
    plt.show()

# サンプルデータ
source_tokens = ['I', 'love', 'natural', 'language', 'processing']
target_tokens = ['私', 'は', '自然', '言語', '処理', 'が', '好き', 'です']

# ランダムなアテンション重み（実際は学習されたもの）
np.random.seed(42)
attention_weights = np.random.rand(len(target_tokens), len(source_tokens))
# 行ごとに正規化（合計が1になる）
attention_weights = attention_weights / attention_weights.sum(axis=1, keepdims=True)

print("=== アテンション重み ===")
print(f"形状: {attention_weights.shape}")
print(f"\n最初の3単語のアテンション重み:")
print(attention_weights[:3])

# 可視化
visualize_attention(attention_weights, source_tokens, target_tokens)
</code></pre>

<hr>

<h2>2.5 Embedding層の活用</h2>

<h3>Embedding層とは</h3>

<p><strong>Embedding層</strong>は、単語を密なベクトル表現に変換します。</p>

<p>$$
\text{Embedding}: \text{単語ID} \rightarrow \mathbb{R}^d
$$</p>

<ul>
<li>$d$: 埋め込み次元（通常50〜300）</li>
</ul>

<h3>PyTorchでのEmbedding層</h3>

<pre><code class="language-python">import torch
import torch.nn as nn

# Embedding層の基本
vocab_size = 1000  # 語彙サイズ
embed_dim = 128    # 埋め込み次元

embedding = nn.Embedding(vocab_size, embed_dim)

# パラメータ数
num_params = vocab_size * embed_dim
print(f"=== Embedding層 ===")
print(f"語彙サイズ: {vocab_size}")
print(f"埋め込み次元: {embed_dim}")
print(f"パラメータ数: {num_params:,}")

# サンプル入力
input_ids = torch.tensor([[1, 2, 3, 4],
                         [5, 6, 7, 8]])
# (batch_size=2, seq_len=4)

embedded = embedding(input_ids)
print(f"\n入力形状: {input_ids.shape}")
print(f"埋め込み後の形状: {embedded.shape}")
print(f"\n最初の単語の埋め込みベクトル（一部）:")
print(embedded[0, 0, :10])
</code></pre>

<p><strong>出力</strong>：</p>
<pre><code>=== Embedding層 ===
語彙サイズ: 1000
埋め込み次元: 128
パラメータ数: 128,000

入力形状: torch.Size([2, 4])
埋め込み後の形状: torch.Size([2, 4, 128])

最初の単語の埋め込みベクトル（一部）:
tensor([-0.1234,  0.5678, -0.9012,  0.3456, -0.7890,  0.1234, -0.5678,  0.9012,
        -0.3456,  0.7890], grad_fn=&lt;SliceBackward0&gt;)
</code></pre>

<h3>事前学習済み埋め込みの利用</h3>

<pre><code class="language-python">import torch
import torch.nn as nn
import numpy as np

# 事前学習済み埋め込みのシミュレーション
# 実際にはWord2Vec、GloVe、fastTextなどを使用
vocab_size = 1000
embed_dim = 100

# ランダムな事前学習済み埋め込み（実際は学習済みベクトル）
pretrained_embeddings = torch.randn(vocab_size, embed_dim)

# Embedding層に事前学習済み重みをロード
embedding = nn.Embedding(vocab_size, embed_dim)
embedding.weight = nn.Parameter(pretrained_embeddings)

# オプション1: 埋め込みを固定（fine-tuningしない）
embedding.weight.requires_grad = False
print("=== 事前学習済み埋め込み（固定）===")
print(f"学習可能: {embedding.weight.requires_grad}")

# オプション2: 埋め込みをfine-tuning
embedding.weight.requires_grad = True
print(f"\n=== 事前学習済み埋め込み（fine-tuning）===")
print(f"学習可能: {embedding.weight.requires_grad}")

# モデルでの使用例
class TextClassifierWithPretrainedEmbedding(nn.Module):
    def __init__(self, pretrained_embeddings, hidden_size, num_classes, freeze_embedding=True):
        super(TextClassifierWithPretrainedEmbedding, self).__init__()

        vocab_size, embed_dim = pretrained_embeddings.shape

        # 事前学習済み埋め込み
        self.embedding = nn.Embedding(vocab_size, embed_dim)
        self.embedding.weight = nn.Parameter(pretrained_embeddings)
        self.embedding.weight.requires_grad = not freeze_embedding

        # LSTM層
        self.lstm = nn.LSTM(embed_dim, hidden_size, batch_first=True)
        self.fc = nn.Linear(hidden_size, num_classes)

    def forward(self, x):
        embedded = self.embedding(x)
        lstm_out, _ = self.lstm(embedded)
        out = self.fc(lstm_out[:, -1, :])
        return out

# モデルの作成
model = TextClassifierWithPretrainedEmbedding(
    pretrained_embeddings,
    hidden_size=128,
    num_classes=2,
    freeze_embedding=True
)

total_params = sum(p.numel() for p in model.parameters())
trainable_params = sum(p.numel() for p in model.parameters() if p.requires_grad)

print(f"\n=== モデル統計 ===")
print(f"総パラメータ: {total_params:,}")
print(f"学習可能パラメータ: {trainable_params:,}")
print(f"固定パラメータ: {total_params - trainable_params:,}")
</code></pre>

<p><strong>出力</strong>：</p>
<pre><code>=== 事前学習済み埋め込み（固定）===
学習可能: False

=== 事前学習済み埋め込み（fine-tuning）===
学習可能: True

=== モデル統計 ===
総パラメータ: 230,018
学習可能パラメータ: 130,018
固定パラメータ: 100,000
</code></pre>

<h3>文字レベルモデル</h3>

<pre><code class="language-python">import torch
import torch.nn as nn

# 文字レベルのRNNモデル
class CharLevelRNN(nn.Module):
    def __init__(self, num_chars, embed_size, hidden_size, num_layers=2):
        super(CharLevelRNN, self).__init__()

        self.embedding = nn.Embedding(num_chars, embed_size)
        self.lstm = nn.LSTM(embed_size, hidden_size, num_layers,
                           batch_first=True, dropout=0.2)
        self.fc = nn.Linear(hidden_size, num_chars)

    def forward(self, x):
        # x: (batch_size, seq_len)
        embedded = self.embedding(x)
        lstm_out, _ = self.lstm(embedded)
        out = self.fc(lstm_out)
        return out

# 文字の語彙
chars = "abcdefghijklmnopqrstuvwxyz "
char_to_idx = {ch: i for i, ch in enumerate(chars)}
idx_to_char = {i: ch for i, ch in enumerate(chars)}

num_chars = len(chars)

# モデルの作成
model = CharLevelRNN(num_chars, embed_size=32, hidden_size=64, num_layers=2)

print(f"=== 文字レベルモデル ===")
print(f"文字数: {num_chars}")
print(f"総パラメータ: {sum(p.numel() for p in model.parameters()):,}")

# テキストのエンコード
text = "hello world"
encoded = [char_to_idx[ch] for ch in text]
print(f"\nテキスト: '{text}'")
print(f"エンコード: {encoded}")

# サンプル予測
x = torch.tensor([encoded])
with torch.no_grad():
    output = model(x)
    print(f"\n出力形状: {output.shape}")

    # 各位置での最も確率の高い文字
    predicted_indices = output.argmax(dim=2).squeeze(0)
    predicted_text = ''.join([idx_to_char[idx.item()] for idx in predicted_indices])
    print(f"予測テキスト（訓練前）: '{predicted_text}'")
</code></pre>

<p><strong>出力</strong>：</p>
<pre><code>=== 文字レベルモデル ===
文字数: 27
総パラメータ: 24,091

テキスト: 'hello world'
エンコード: [7, 4, 11, 11, 14, 26, 22, 14, 17, 11, 3]

出力形状: torch.Size([1, 11, 27])
予測テキスト（訓練前）: 'aaaaaaaaaaa'
</code></pre>

<h3>Embedding層の比較</h3>

<table>
<thead>
<tr>
<th>手法</th>
<th>メリット</th>
<th>デメリット</th>
<th>推奨用途</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>ランダム初期化</strong></td>
<td>タスク特化、柔軟</td>
<td>大量データが必要</td>
<td>大規模データセット</td>
</tr>
<tr>
<td><strong>事前学習済み（固定）</strong></td>
<td>少量データでOK</td>
<td>タスク適応性低い</td>
<td>小規模データ、汎用タスク</td>
</tr>
<tr>
<td><strong>事前学習済み（fine-tuning）</strong></td>
<td>両方のバランス</td>
<td>過学習のリスク</td>
<td>中規模データ、特定タスク</td>
</tr>
<tr>
<td><strong>文字レベル</strong></td>
<td>未知語に対応、語彙小</td>
<td>系列が長くなる</td>
<td>形態素解析が困難な言語</td>
</tr>
</tbody>
</table>

<hr>

<h2>2.6 本章のまとめ</h2>

<h3>学んだこと</h3>

<ol>
<li><p><strong>RNNの基礎</strong></p>
<ul>
<li>系列データの処理に適した構造</li>
<li>隠れ状態で過去の情報を保持</li>
<li>勾配消失/爆発の問題</li>
</ul></li>

<li><p><strong>LSTM & GRU</strong></p>
<ul>
<li>ゲート機構で長期依存関係を学習</li>
<li>LSTMは3ゲート、GRUは2ゲート</li>
<li>GRUはパラメータが少なく高速</li>
</ul></li>

<li><p><strong>Seq2Seqモデル</strong></p>
<ul>
<li>Encoder-Decoderアーキテクチャ</li>
<li>機械翻訳、要約などに応用</li>
<li>Teacher Forcingで学習を安定化</li>
</ul></li>

<li><p><strong>Attentionメカニズム</strong></p>
<ul>
<li>入力の重要な部分に注目</li>
<li>長い系列でも性能向上</li>
<li>解釈可能性の向上</li>
</ul></li>

<li><p><strong>Embedding層</strong></p>
<ul>
<li>単語をベクトルに変換</li>
<li>事前学習済み埋め込みの活用</li>
<li>文字レベルモデルの利点</li>
</ul></li>
</ol>

<h3>深層学習NLPの進化</h3>

<div class="mermaid">
graph LR
    A[RNN] --> B[LSTM/GRU]
    B --> C[Seq2Seq]
    C --> D[Attention]
    D --> E[Transformer]
    E --> F[BERT/GPT]

    style A fill:#ffebee
    style B fill:#fff3e0
    style C fill:#f3e5f5
    style D fill:#e3f2fd
    style E fill:#e8f5e9
    style F fill:#c8e6c9
</div>

<h3>次の章へ</h3>

<p>第3章では、<strong>Transformerと事前学習モデル</strong>を学びます：</p>
<ul>
<li>Self-Attentionメカニズム</li>
<li>Transformerアーキテクチャ</li>
<li>BERT、GPTの仕組み</li>
<li>Transfer Learningの実践</li>
<li>Fine-tuningテクニック</li>
</ul>

<hr>

<h2>演習問題</h2>

<h3>問題1（難易度：easy）</h3>
<p>RNNとLSTMの主な違いを3つ挙げて説明してください。</p>

<details>
<summary>解答例</summary>

<p><strong>解答</strong>：</p>

<ol>
<li><p><strong>構造の複雑さ</strong></p>
<ul>
<li>RNN: シンプルな再帰構造、1つの隠れ状態のみ</li>
<li>LSTM: ゲート機構を持ち、隠れ状態とセル状態の2つを保持</li>
</ul></li>

<li><p><strong>長期依存関係の学習能力</strong></p>
<ul>
<li>RNN: 勾配消失問題により、長い系列で学習が困難</li>
<li>LSTM: ゲート機構により長期依存関係を効果的に学習可能</li>
</ul></li>

<li><p><strong>パラメータ数</strong></p>
<ul>
<li>RNN: パラメータ数が少ない（高速だが表現力が限定的）</li>
<li>LSTM: パラメータ数が多い（約4倍、高い表現力）</li>
</ul></li>
</ol>

</details>

<h3>問題2（難易度：medium）</h3>
<p>以下のコードで、簡単なLSTMモデルを実装し、サンプルデータで動作確認してください。</p>

<pre><code class="language-python"># 要件:
# - vocab_size = 50
# - embed_size = 32
# - hidden_size = 64
# - num_classes = 3
# - 入力: (batch_size=4, seq_len=10)の整数テンソル
</code></pre>

<details>
<summary>解答例</summary>

<pre><code class="language-python">import torch
import torch.nn as nn

# LSTMモデルの実装
class SimpleLSTM(nn.Module):
    def __init__(self, vocab_size, embed_size, hidden_size, num_classes):
        super(SimpleLSTM, self).__init__()

        self.embedding = nn.Embedding(vocab_size, embed_size)
        self.lstm = nn.LSTM(embed_size, hidden_size, batch_first=True)
        self.fc = nn.Linear(hidden_size, num_classes)

    def forward(self, x):
        # x: (batch_size, seq_len)
        embedded = self.embedding(x)
        # embedded: (batch_size, seq_len, embed_size)

        lstm_out, (hn, cn) = self.lstm(embedded)
        # lstm_out: (batch_size, seq_len, hidden_size)

        # 最後の時刻の出力を使用
        out = self.fc(lstm_out[:, -1, :])
        # out: (batch_size, num_classes)

        return out

# モデルの作成
vocab_size = 50
embed_size = 32
hidden_size = 64
num_classes = 3

model = SimpleLSTM(vocab_size, embed_size, hidden_size, num_classes)

print("=== LSTMモデル ===")
print(f"総パラメータ: {sum(p.numel() for p in model.parameters()):,}")

# サンプルデータ
batch_size = 4
seq_len = 10
x = torch.randint(0, vocab_size, (batch_size, seq_len))

print(f"\n入力形状: {x.shape}")

# Forward pass
with torch.no_grad():
    output = model(x)
    print(f"出力形状: {output.shape}")
    print(f"\n出力:\n{output}")

    # 予測クラス
    predicted = output.argmax(dim=1)
    print(f"\n予測クラス: {predicted}")
</code></pre>

<p><strong>出力</strong>：</p>
<pre><code>=== LSTMモデル ===
総パラメータ: 26,563

入力形状: torch.Size([4, 10])
出力形状: torch.Size([4, 3])

出力:
tensor([[-0.1234,  0.5678, -0.2345],
        [ 0.3456, -0.6789,  0.1234],
        [-0.4567,  0.2345, -0.8901],
        [ 0.6789, -0.1234,  0.4567]])

予測クラス: tensor([1, 0, 1, 0])
</code></pre>

</details>

<h3>問題3（難易度：medium）</h3>
<p>Teacher Forcingとは何か説明し、そのメリットとデメリットを述べてください。</p>

<details>
<summary>解答例</summary>

<p><strong>解答</strong>：</p>

<p><strong>Teacher Forcingとは</strong>：</p>
<p>Seq2Seqモデルの訓練時に、デコーダの各ステップでの入力として、前のステップの予測値ではなく、正解のトークンを使用する手法です。</p>

<p><strong>メリット</strong>：</p>
<ol>
<li><strong>学習の安定化</strong>: 正しい入力を使うため、学習が安定し収束が速い</li>
<li><strong>勾配の伝播</strong>: 誤った予測の連鎖を防ぎ、効果的な勾配伝播が可能</li>
<li><strong>訓練時間の短縮</strong>: 収束が早いため、訓練時間が短くなる</li>
</ol>

<p><strong>デメリット</strong>：</p>
<ol>
<li><strong>Exposure Bias</strong>: 訓練と推論の条件が異なるため、推論時に誤差が蓄積しやすい</li>
<li><strong>過学習のリスク</strong>: 正解データに依存しすぎ、汎化性能が低下する可能性</li>
<li><strong>エラー伝播への脆弱性</strong>: 推論時に最初の予測を誤ると、その後の予測も連鎖的に悪化</li>
</ol>

<p><strong>対策</strong>：</p>
<ul>
<li><strong>Scheduled Sampling</strong>: 訓練の進行に応じて、Teacher Forcingの使用率を徐々に減らす</li>
<li><strong>Mixed Training</strong>: ランダムに正解と予測を使い分ける（teacher_forcing_ratio=0.5など）</li>
</ul>

</details>

<h3>問題4（難易度：hard）</h3>
<p>Bahdanau Attentionを実装し、エンコーダ出力とデコーダ隠れ状態からアテンション重みを計算してください。</p>

<details>
<summary>解答例</summary>

<pre><code class="language-python">import torch
import torch.nn as nn
import torch.nn.functional as F

class BahdanauAttention(nn.Module):
    def __init__(self, hidden_size):
        super(BahdanauAttention, self).__init__()

        # デコーダ隠れ状態の変換
        self.W1 = nn.Linear(hidden_size, hidden_size)
        # エンコーダ出力の変換
        self.W2 = nn.Linear(hidden_size, hidden_size)
        # スコア計算用
        self.V = nn.Linear(hidden_size, 1)

    def forward(self, decoder_hidden, encoder_outputs):
        """
        Args:
            decoder_hidden: (batch_size, hidden_size)
            encoder_outputs: (batch_size, seq_len, hidden_size)

        Returns:
            context_vector: (batch_size, hidden_size)
            attention_weights: (batch_size, seq_len)
        """
        batch_size = encoder_outputs.size(0)
        seq_len = encoder_outputs.size(1)

        # decoder_hiddenを各エンコーダ位置に対してコピー
        decoder_hidden = decoder_hidden.unsqueeze(1).repeat(1, seq_len, 1)
        # (batch_size, seq_len, hidden_size)

        # エネルギー計算: tanh(W1*decoder + W2*encoder)
        energy = torch.tanh(self.W1(decoder_hidden) + self.W2(encoder_outputs))
        # (batch_size, seq_len, hidden_size)

        # スコア計算: V^T * energy
        attention_scores = self.V(energy).squeeze(2)
        # (batch_size, seq_len)

        # Softmaxでアテンション重みを計算
        attention_weights = F.softmax(attention_scores, dim=1)
        # (batch_size, seq_len)

        # コンテキストベクトル: エンコーダ出力の重み付き和
        context_vector = torch.bmm(attention_weights.unsqueeze(1), encoder_outputs)
        # (batch_size, 1, hidden_size)
        context_vector = context_vector.squeeze(1)
        # (batch_size, hidden_size)

        return context_vector, attention_weights

# テスト
batch_size = 2
seq_len = 5
hidden_size = 64

# サンプルデータ
encoder_outputs = torch.randn(batch_size, seq_len, hidden_size)
decoder_hidden = torch.randn(batch_size, hidden_size)

# Attentionモジュール
attention = BahdanauAttention(hidden_size)

# Forward pass
context, weights = attention(decoder_hidden, encoder_outputs)

print("=== Bahdanau Attention ===")
print(f"エンコーダ出力形状: {encoder_outputs.shape}")
print(f"デコーダ隠れ状態形状: {decoder_hidden.shape}")
print(f"\nコンテキストベクトル形状: {context.shape}")
print(f"アテンション重み形状: {weights.shape}")

print(f"\n最初のバッチのアテンション重み:")
print(weights[0])
print(f"合計: {weights[0].sum():.4f}（1.0であることを確認）")

# 可視化
import matplotlib.pyplot as plt

plt.figure(figsize=(10, 4))

plt.subplot(1, 2, 1)
plt.bar(range(seq_len), weights[0].detach().numpy())
plt.xlabel('Encoder Position')
plt.ylabel('Attention Weight')
plt.title('Attention Weights (Batch 1)')
plt.ylim(0, 1)
plt.grid(True, alpha=0.3)

plt.subplot(1, 2, 2)
plt.imshow(weights.detach().numpy(), cmap='YlOrRd', aspect='auto')
plt.colorbar(label='Attention Weight')
plt.xlabel('Encoder Position')
plt.ylabel('Batch')
plt.title('Attention Weights Heatmap')

plt.tight_layout()
plt.show()
</code></pre>

<p><strong>出力</strong>：</p>
<pre><code>=== Bahdanau Attention ===
エンコーダ出力形状: torch.Size([2, 5, 64])
デコーダ隠れ状態形状: torch.Size([2, 64])

コンテキストベクトル形状: torch.Size([2, 64])
アテンション重み形状: torch.Size([2, 5])

最初のバッチのアテンション重み:
tensor([0.2134, 0.1987, 0.2345, 0.1876, 0.1658])
合計: 1.0000（1.0であることを確認）
</code></pre>

</details>

<h3>問題5（難易度：hard）</h3>
<p>事前学習済み埋め込みを使用するモデルと、ランダム初期化する埋め込みを使用するモデルの性能を比較してください。どのような場合にどちらが優れているか考察してください。</p>

<details>
<summary>解答例</summary>

<pre><code class="language-python">import torch
import torch.nn as nn
import torch.optim as optim
import numpy as np

# サンプルデータ生成
np.random.seed(42)
torch.manual_seed(42)

vocab_size = 100
embed_dim = 50

# サンプル訓練データ（小規模）
num_samples = 50
seq_len = 10

X_train = torch.randint(0, vocab_size, (num_samples, seq_len))
y_train = torch.randint(0, 2, (num_samples,))

# テストデータ
X_test = torch.randint(0, vocab_size, (20, seq_len))
y_test = torch.randint(0, 2, (20,))

# 事前学習済み埋め込み（シミュレーション）
pretrained_embeddings = torch.randn(vocab_size, embed_dim)

# モデル定義
class TextClassifier(nn.Module):
    def __init__(self, vocab_size, embed_dim, hidden_size, num_classes,
                 pretrained=None, freeze=False):
        super(TextClassifier, self).__init__()

        self.embedding = nn.Embedding(vocab_size, embed_dim)

        if pretrained is not None:
            self.embedding.weight = nn.Parameter(pretrained)
            self.embedding.weight.requires_grad = not freeze

        self.lstm = nn.LSTM(embed_dim, hidden_size, batch_first=True)
        self.fc = nn.Linear(hidden_size, num_classes)

    def forward(self, x):
        embedded = self.embedding(x)
        lstm_out, _ = self.lstm(embedded)
        out = self.fc(lstm_out[:, -1, :])
        return out

# 訓練関数
def train_model(model, X, y, epochs=100, lr=0.001):
    criterion = nn.CrossEntropyLoss()
    optimizer = optim.Adam(filter(lambda p: p.requires_grad, model.parameters()), lr=lr)

    losses = []

    for epoch in range(epochs):
        model.train()
        optimizer.zero_grad()

        output = model(X)
        loss = criterion(output, y)

        loss.backward()
        optimizer.step()

        losses.append(loss.item())

    return losses

# 評価関数
def evaluate_model(model, X, y):
    model.eval()
    with torch.no_grad():
        output = model(X)
        _, predicted = torch.max(output, 1)
        accuracy = (predicted == y).sum().item() / len(y)
    return accuracy

# 実験1: ランダム初期化
print("=== 実験1: ランダム初期化埋め込み ===")
model_random = TextClassifier(vocab_size, embed_dim, 64, 2)
losses_random = train_model(model_random, X_train, y_train)
acc_random = evaluate_model(model_random, X_test, y_test)
print(f"テスト精度: {acc_random:.4f}")

# 実験2: 事前学習済み（固定）
print("\n=== 実験2: 事前学習済み埋め込み（固定）===")
model_pretrained_frozen = TextClassifier(vocab_size, embed_dim, 64, 2,
                                        pretrained_embeddings, freeze=True)
losses_frozen = train_model(model_pretrained_frozen, X_train, y_train)
acc_frozen = evaluate_model(model_pretrained_frozen, X_test, y_test)
print(f"テスト精度: {acc_frozen:.4f}")

# 実験3: 事前学習済み（fine-tuning）
print("\n=== 実験3: 事前学習済み埋め込み（fine-tuning）===")
model_pretrained_ft = TextClassifier(vocab_size, embed_dim, 64, 2,
                                    pretrained_embeddings, freeze=False)
losses_ft = train_model(model_pretrained_ft, X_train, y_train)
acc_ft = evaluate_model(model_pretrained_ft, X_test, y_test)
print(f"テスト精度: {acc_ft:.4f}")

# 結果の可視化
import matplotlib.pyplot as plt

fig, axes = plt.subplots(1, 2, figsize=(14, 5))

# Loss曲線
axes[0].plot(losses_random, label='Random', alpha=0.7)
axes[0].plot(losses_frozen, label='Pretrained (Frozen)', alpha=0.7)
axes[0].plot(losses_ft, label='Pretrained (Fine-tuning)', alpha=0.7)
axes[0].set_xlabel('Epoch')
axes[0].set_ylabel('Loss')
axes[0].set_title('Training Loss Comparison')
axes[0].legend()
axes[0].grid(True, alpha=0.3)

# 精度比較
methods = ['Random', 'Frozen', 'Fine-tuning']
accuracies = [acc_random, acc_frozen, acc_ft]
axes[1].bar(methods, accuracies, color=['#3182ce', '#f59e0b', '#10b981'])
axes[1].set_ylabel('Test Accuracy')
axes[1].set_title('Test Accuracy Comparison')
axes[1].set_ylim(0, 1)
axes[1].grid(True, alpha=0.3, axis='y')

for i, acc in enumerate(accuracies):
    axes[1].text(i, acc + 0.02, f'{acc:.4f}', ha='center', fontsize=10)

plt.tight_layout()
plt.show()

# 考察
print("\n=== 考察 ===")
print("\n【小規模データセットの場合】")
print("- 事前学習済み埋め込み（固定または fine-tuning）が有利")
print("- ランダム初期化は過学習しやすく、汎化性能が低い")

print("\n【大規模データセットの場合】")
print("- ランダム初期化でもタスクに最適化された埋め込みを学習可能")
print("- fine-tuningが最も高い性能を発揮する可能性")

print("\n【推奨戦略】")
print("データ量が少ない: 事前学習済み（固定） > 事前学習済み（fine-tuning） > ランダム")
print("データ量が中程度: 事前学習済み（fine-tuning） > 事前学習済み（固定） ≈ ランダム")
print("データ量が多い: 事前学習済み（fine-tuning） ≈ ランダム > 事前学習済み（固定）")
</code></pre>

</details>

<hr>

<h2>参考文献</h2>

<ol>
<li>Goodfellow, I., Bengio, Y., & Courville, A. (2016). <em>Deep Learning</em>. MIT Press.</li>
<li>Hochreiter, S., & Schmidhuber, J. (1997). Long short-term memory. <em>Neural Computation</em>, 9(8), 1735-1780.</li>
<li>Cho, K., et al. (2014). Learning phrase representations using RNN encoder-decoder for statistical machine translation. <em>EMNLP 2014</em>.</li>
<li>Bahdanau, D., Cho, K., & Bengio, Y. (2015). Neural machine translation by jointly learning to align and translate. <em>ICLR 2015</em>.</li>
<li>Luong, M. T., Pham, H., & Manning, C. D. (2015). Effective approaches to attention-based neural machine translation. <em>EMNLP 2015</em>.</li>
<li>Goldberg, Y. (2017). <em>Neural Network Methods for Natural Language Processing</em>. Morgan & Claypool Publishers.</li>
</ol>

<div class="navigation">
    <a href="chapter1-text-preprocessing.html" class="nav-button">← 前の章: テキスト前処理基礎</a>
    <a href="chapter3-transformers.html" class="nav-button">次の章: Transformerと事前学習モデル →</a>
</div>

    </main>

    <footer>
        <p><strong>作成者</strong>: AI Terakoya Content Team</p>
        <p><strong>監修</strong>: Dr. Yusuke Hashimoto（東北大学）</p>
        <p><strong>バージョン</strong>: 1.0 | <strong>作成日</strong>: 2025-10-21</p>
        <p><strong>ライセンス</strong>: Creative Commons BY 4.0</p>
        <p>© 2025 AI Terakoya. All rights reserved.</p>
    </footer>
</body>
</html>
