<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 4 - Ê∑±Â±§Â≠¶Áøí„Å´„Çà„ÇãÊé®Ëñ¶„Ç∑„Çπ„ÉÜ„É† - AI Terakoya</title>

    <style>
        :root {
            --color-primary: #2c3e50;
            --color-primary-dark: #1a252f;
            --color-accent: #7b2cbf;
            --color-accent-light: #9d4edd;
            --color-text: #2d3748;
            --color-text-light: #4a5568;
            --color-bg: #ffffff;
            --color-bg-alt: #f7fafc;
            --color-border: #e2e8f0;
            --color-code-bg: #f8f9fa;
            --color-link: #3182ce;
            --color-link-hover: #2c5aa0;

            --spacing-xs: 0.5rem;
            --spacing-sm: 1rem;
            --spacing-md: 1.5rem;
            --spacing-lg: 2rem;
            --spacing-xl: 3rem;

            --font-body: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            --font-mono: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;

            --border-radius: 8px;
            --box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-body);
            line-height: 1.7;
            color: var(--color-text);
            background-color: var(--color-bg);
            font-size: 16px;
        }

        header {
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            color: white;
            padding: var(--spacing-xl) var(--spacing-md);
            margin-bottom: var(--spacing-xl);
            box-shadow: var(--box-shadow);
        }

        .header-content {
            max-width: 900px;
            margin: 0 auto;
        }

        h1 {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: var(--spacing-sm);
            line-height: 1.2;
        }

        .subtitle {
            font-size: 1.1rem;
            opacity: 0.95;
            font-weight: 400;
            margin-bottom: var(--spacing-md);
        }

        .meta {
            display: flex;
            flex-wrap: wrap;
            gap: var(--spacing-md);
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .meta-item {
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 0 var(--spacing-md) var(--spacing-xl);
        }

        h2 {
            font-size: 1.75rem;
            color: var(--color-primary);
            margin-top: var(--spacing-xl);
            margin-bottom: var(--spacing-md);
            padding-bottom: var(--spacing-xs);
            border-bottom: 3px solid var(--color-accent);
        }

        h3 {
            font-size: 1.4rem;
            color: var(--color-primary);
            margin-top: var(--spacing-lg);
            margin-bottom: var(--spacing-sm);
        }

        h4 {
            font-size: 1.1rem;
            color: var(--color-primary-dark);
            margin-top: var(--spacing-md);
            margin-bottom: var(--spacing-sm);
        }

        p {
            margin-bottom: var(--spacing-md);
            color: var(--color-text);
        }

        a {
            color: var(--color-link);
            text-decoration: none;
            transition: color 0.2s;
        }

        a:hover {
            color: var(--color-link-hover);
            text-decoration: underline;
        }

        ul, ol {
            margin-left: var(--spacing-lg);
            margin-bottom: var(--spacing-md);
        }

        li {
            margin-bottom: var(--spacing-xs);
            color: var(--color-text);
        }

        pre {
            background-color: var(--color-code-bg);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            overflow-x: auto;
            margin-bottom: var(--spacing-md);
            font-family: var(--font-mono);
            font-size: 0.9rem;
            line-height: 1.5;
        }

        code {
            font-family: var(--font-mono);
            font-size: 0.9em;
            background-color: var(--color-code-bg);
            padding: 0.2em 0.4em;
            border-radius: 3px;
        }

        pre code {
            background-color: transparent;
            padding: 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: var(--spacing-md);
            font-size: 0.95rem;
        }

        th, td {
            border: 1px solid var(--color-border);
            padding: var(--spacing-sm);
            text-align: left;
        }

        th {
            background-color: var(--color-bg-alt);
            font-weight: 600;
            color: var(--color-primary);
        }

        blockquote {
            border-left: 4px solid var(--color-accent);
            padding-left: var(--spacing-md);
            margin: var(--spacing-md) 0;
            color: var(--color-text-light);
            font-style: italic;
            background-color: var(--color-bg-alt);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        .mermaid {
            text-align: center;
            margin: var(--spacing-lg) 0;
            background-color: var(--color-bg-alt);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        details {
            background-color: var(--color-bg-alt);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            margin-bottom: var(--spacing-md);
        }

        summary {
            cursor: pointer;
            font-weight: 600;
            color: var(--color-primary);
            user-select: none;
            padding: var(--spacing-xs);
            margin: calc(-1 * var(--spacing-md));
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        summary:hover {
            background-color: rgba(123, 44, 191, 0.1);
        }

        details[open] summary {
            margin-bottom: var(--spacing-md);
            border-bottom: 1px solid var(--color-border);
        }

        .learning-objectives {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            padding: var(--spacing-lg);
            border-radius: var(--border-radius);
            border-left: 4px solid var(--color-accent);
            margin-bottom: var(--spacing-xl);
        }

        .learning-objectives h2 {
            margin-top: 0;
            border-bottom: none;
        }

        .navigation {
            display: flex;
            justify-content: space-between;
            gap: var(--spacing-md);
            margin: var(--spacing-xl) 0;
            padding-top: var(--spacing-lg);
            border-top: 2px solid var(--color-border);
        }

        .nav-button {
            flex: 1;
            padding: var(--spacing-md);
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            color: white;
            border-radius: var(--border-radius);
            text-align: center;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: var(--box-shadow);
        }

        .nav-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            text-decoration: none;
        }

        footer {
            margin-top: var(--spacing-xl);
            padding: var(--spacing-lg) var(--spacing-md);
            background-color: var(--color-bg-alt);
            border-top: 1px solid var(--color-border);
            text-align: center;
            font-size: 0.9rem;
            color: var(--color-text-light);
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.5rem;
            }

            h2 {
                font-size: 1.4rem;
            }

            h3 {
                font-size: 1.2rem;
            }

            .meta {
                font-size: 0.85rem;
            }

            .navigation {
                flex-direction: column;
            }

            table {
                font-size: 0.85rem;
            }

            th, td {
                padding: var(--spacing-xs);
            }
        }
    </style>

    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <script>
        mermaid.initialize({ startOnLoad: true, theme: 'default', securityLevel: 'strict' });
    </script>

    <!-- MathJax for LaTeX equation rendering -->
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true,
                processEnvironments: true
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
                ignoreHtmlClass: 'mermaid'
            }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" id="MathJax-script" async></script>
</head>
<body>
    <header>
        <div class="header-content">
            <h1>Á¨¨4Á´†ÔºöÊ∑±Â±§Â≠¶Áøí„Å´„Çà„ÇãÊé®Ëñ¶„Ç∑„Çπ„ÉÜ„É†</h1>
            <p class="subtitle">Neural Collaborative Filtering„ÄÅTwo-Tower Models„ÄÅSequence-basedÊé®Ëñ¶</p>
            <div class="meta">
                <span class="meta-item">üìñ Ë™≠‰∫ÜÊôÇÈñì: 40-50ÂàÜ</span>
                <span class="meta-item">üìä Èõ£ÊòìÂ∫¶: ‰∏≠Á¥ö„Äú‰∏äÁ¥ö</span>
                <span class="meta-item">üíª „Ç≥„Éº„Éâ‰æã: 8ÂÄã</span>
                <span class="meta-item">üìù ÊºîÁøíÂïèÈ°å: 6Âïè</span>
            </div>
        </div>
    </header>

    <main class="container">

<div class="learning-objectives">
<h2>Â≠¶ÁøíÁõÆÊ®ô</h2>
<ul>
<li>Neural Collaborative Filtering (NCF) „ÅÆÁêÜË´ñ„Å®ÂÆüË£Ö„ÇíÁêÜËß£„Åô„Çã</li>
<li>Factorization Machines„Å®DeepFM„ÅÆ‰ªïÁµÑ„Åø„ÇíÂ≠¶„Å∂</li>
<li>Two-Tower Models„Å´„Çà„ÇãÂ§ßË¶èÊ®°Êé®Ëñ¶„Ç∑„Çπ„ÉÜ„É†„ÇíÊßãÁØâ„Åô„Çã</li>
<li>Sequence-basedÊé®Ëñ¶ÔºàRNN„ÄÅTransformerÔºâ„ÇíÂÆüË£Ö„Åô„Çã</li>
<li>ÂÆüË∑µÁöÑ„Å™Êé®Ëñ¶„Ç∑„Çπ„ÉÜ„É†„Éë„Ç§„Éó„É©„Ç§„É≥„ÇíË®≠Ë®à„Åô„Çã</li>
</ul>
</div>

<h2>4.1 Neural Collaborative Filtering (NCF)</h2>

<h3>4.1.1 NCF„ÅÆÂãïÊ©ü</h3>

<p><strong>ÂæìÊù•„ÅÆÂçîË™ø„Éï„Ç£„É´„Çø„É™„É≥„Ç∞„ÅÆÈôêÁïåÔºö</strong></p>
<ul>
<li>Matrix Factorization: Á∑öÂΩ¢„Å™ÂÜÖÁ©ç„ÅÆ„Åø„ÅßÁõ∏‰∫í‰ΩúÁî®„ÇíË°®Áèæ</li>
<li>$\hat{r}_{ui} = p_u^T q_i$ Ôºà„É¶„Éº„Ç∂„ÉºÂüã„ÇÅËæº„Åø √ó „Ç¢„Ç§„ÉÜ„É†Âüã„ÇÅËæº„ÅøÔºâ</li>
<li>ÂïèÈ°åÔºöÈùûÁ∑öÂΩ¢„Å™ÂóúÂ•Ω„Éë„Çø„Éº„É≥„ÇíÊçâ„Åà„Çâ„Çå„Å™„ÅÑ</li>
</ul>

<p><strong>NCF„ÅÆÊèêÊ°àÔºö</strong></p>
<ul>
<li>Multi-Layer Perceptron (MLP) „ÅßÈùûÁ∑öÂΩ¢ÊÄß„ÇíÂ∞éÂÖ•</li>
<li>Ë´ñÊñá: He et al. "Neural Collaborative Filtering" (WWW 2017)</li>
<li>ÂºïÁî®Êï∞: 4,000+Ôºà2024Âπ¥ÊôÇÁÇπÔºâ</li>
</ul>

<h3>4.1.2 NCF„Ç¢„Éº„Ç≠„ÉÜ„ÇØ„ÉÅ„É£</h3>

<p><strong>ÊßãÊàêË¶ÅÁ¥†Ôºö</strong></p>

<pre><code>Input Layer
‚îú‚îÄ User ID ‚Üí User Embedding (dim=K)
‚îî‚îÄ Item ID ‚Üí Item Embedding (dim=K)
    ‚Üì
Interaction Layer (Ë§áÊï∞„ÅÆÈÅ∏ÊäûËÇ¢)
‚îú‚îÄ (1) GMF: p_u ‚äô q_i (Ë¶ÅÁ¥†Á©ç)
‚îú‚îÄ (2) MLP: f(concat(p_u, q_i))
‚îî‚îÄ (3) NeuMF: GMF + MLP „ÅÆËûçÂêà
    ‚Üì
Output Layer: œÉ(weighted sum) ‚Üí ‰∫àÊ∏¨Ë©ï‰æ°ÂÄ§
</code></pre>

<p><strong>Êï∞ÂºèË°®ÁèæÔºö</strong></p>

<p><strong>GMF (Generalized Matrix Factorization):</strong></p>
$$
\hat{y}_{ui}^{GMF} = \sigma(h^T (p_u \odot q_i))
$$

<p><strong>MLP:</strong></p>
$$
\begin{aligned}
z_1 &= \phi_1(p_u, q_i) = \text{concat}(p_u, q_i) \\
z_2 &= \sigma(W_2^T z_1 + b_2) \\
&\vdots \\
z_L &= \sigma(W_L^T z_{L-1} + b_L) \\
\hat{y}_{ui}^{MLP} &= \sigma(h^T z_L)
\end{aligned}
$$

<p><strong>NeuMF (Neural Matrix Factorization):</strong></p>
$$
\hat{y}_{ui} = \sigma(h^T [\text{GMF output} \,||\, \text{MLP output}])
$$

<h3>4.1.3 PyTorchÂÆüË£Ö</h3>

<pre><code>import torch
import torch.nn as nn
import torch.optim as optim
from torch.utils.data import Dataset, DataLoader
import numpy as np
import pandas as pd

class NCFDataset(Dataset):
    """NCFÁî®„ÅÆ„Éá„Éº„Çø„Çª„ÉÉ„Éà"""
    def __init__(self, user_ids, item_ids, ratings):
        self.user_ids = torch.LongTensor(user_ids)
        self.item_ids = torch.LongTensor(item_ids)
        self.ratings = torch.FloatTensor(ratings)

    def __len__(self):
        return len(self.user_ids)

    def __getitem__(self, idx):
        return self.user_ids[idx], self.item_ids[idx], self.ratings[idx]


class GMF(nn.Module):
    """Generalized Matrix Factorization"""
    def __init__(self, n_users, n_items, embedding_dim=32):
        super(GMF, self).__init__()

        # Embeddings
        self.user_embedding = nn.Embedding(n_users, embedding_dim)
        self.item_embedding = nn.Embedding(n_items, embedding_dim)

        # Output layer
        self.fc = nn.Linear(embedding_dim, 1)

        # Initialize weights
        nn.init.normal_(self.user_embedding.weight, std=0.01)
        nn.init.normal_(self.item_embedding.weight, std=0.01)

    def forward(self, user_ids, item_ids):
        # Get embeddings
        user_emb = self.user_embedding(user_ids)  # (batch, dim)
        item_emb = self.item_embedding(item_ids)  # (batch, dim)

        # Element-wise product
        element_product = user_emb * item_emb  # (batch, dim)

        # Output
        output = self.fc(element_product)  # (batch, 1)
        return torch.sigmoid(output.squeeze())


class MLPModel(nn.Module):
    """MLP-based Collaborative Filtering"""
    def __init__(self, n_users, n_items, embedding_dim=32, layers=[64, 32, 16]):
        super(MLPModel, self).__init__()

        # Embeddings
        self.user_embedding = nn.Embedding(n_users, embedding_dim)
        self.item_embedding = nn.Embedding(n_items, embedding_dim)

        # MLP layers
        mlp_modules = []
        input_size = embedding_dim * 2
        for layer_size in layers:
            mlp_modules.append(nn.Linear(input_size, layer_size))
            mlp_modules.append(nn.ReLU())
            mlp_modules.append(nn.Dropout(0.2))
            input_size = layer_size

        self.mlp = nn.Sequential(*mlp_modules)
        self.fc = nn.Linear(layers[-1], 1)

        # Initialize weights
        nn.init.normal_(self.user_embedding.weight, std=0.01)
        nn.init.normal_(self.item_embedding.weight, std=0.01)

    def forward(self, user_ids, item_ids):
        # Get embeddings
        user_emb = self.user_embedding(user_ids)
        item_emb = self.item_embedding(item_ids)

        # Concatenate
        concat = torch.cat([user_emb, item_emb], dim=-1)  # (batch, dim*2)

        # MLP
        mlp_output = self.mlp(concat)
        output = self.fc(mlp_output)
        return torch.sigmoid(output.squeeze())


class NeuMF(nn.Module):
    """Neural Matrix Factorization (GMF + MLP)"""
    def __init__(self, n_users, n_items,
                 gmf_dim=32, mlp_dim=32, layers=[64, 32, 16]):
        super(NeuMF, self).__init__()

        # GMF Embeddings
        self.gmf_user_embedding = nn.Embedding(n_users, gmf_dim)
        self.gmf_item_embedding = nn.Embedding(n_items, gmf_dim)

        # MLP Embeddings
        self.mlp_user_embedding = nn.Embedding(n_users, mlp_dim)
        self.mlp_item_embedding = nn.Embedding(n_items, mlp_dim)

        # MLP layers
        mlp_modules = []
        input_size = mlp_dim * 2
        for layer_size in layers:
            mlp_modules.append(nn.Linear(input_size, layer_size))
            mlp_modules.append(nn.ReLU())
            mlp_modules.append(nn.Dropout(0.2))
            input_size = layer_size

        self.mlp = nn.Sequential(*mlp_modules)

        # Final prediction layer
        self.fc = nn.Linear(gmf_dim + layers[-1], 1)

        # Initialize
        self._init_weights()

    def _init_weights(self):
        nn.init.normal_(self.gmf_user_embedding.weight, std=0.01)
        nn.init.normal_(self.gmf_item_embedding.weight, std=0.01)
        nn.init.normal_(self.mlp_user_embedding.weight, std=0.01)
        nn.init.normal_(self.mlp_item_embedding.weight, std=0.01)

    def forward(self, user_ids, item_ids):
        # GMF part
        gmf_user_emb = self.gmf_user_embedding(user_ids)
        gmf_item_emb = self.gmf_item_embedding(item_ids)
        gmf_output = gmf_user_emb * gmf_item_emb  # (batch, gmf_dim)

        # MLP part
        mlp_user_emb = self.mlp_user_embedding(user_ids)
        mlp_item_emb = self.mlp_item_embedding(item_ids)
        mlp_concat = torch.cat([mlp_user_emb, mlp_item_emb], dim=-1)
        mlp_output = self.mlp(mlp_concat)  # (batch, layers[-1])

        # Concatenate GMF and MLP
        concat = torch.cat([gmf_output, mlp_output], dim=-1)
        output = self.fc(concat)
        return torch.sigmoid(output.squeeze())


def train_ncf(model, train_loader, n_epochs=10, lr=0.001):
    """NCF„É¢„Éá„É´„ÅÆË®ìÁ∑¥"""
    device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
    model = model.to(device)

    criterion = nn.BCELoss()
    optimizer = optim.Adam(model.parameters(), lr=lr)

    for epoch in range(n_epochs):
        model.train()
        total_loss = 0

        for user_ids, item_ids, ratings in train_loader:
            user_ids = user_ids.to(device)
            item_ids = item_ids.to(device)
            ratings = ratings.to(device)

            # Forward pass
            predictions = model(user_ids, item_ids)
            loss = criterion(predictions, ratings)

            # Backward pass
            optimizer.zero_grad()
            loss.backward()
            optimizer.step()

            total_loss += loss.item()

        avg_loss = total_loss / len(train_loader)
        print(f"Epoch {epoch+1}/{n_epochs}, Loss: {avg_loss:.4f}")

    return model


# ‰ΩøÁî®‰æã
if __name__ == "__main__":
    # „Çµ„É≥„Éó„É´„Éá„Éº„ÇøÁîüÊàê
    np.random.seed(42)
    n_users = 1000
    n_items = 500
    n_samples = 10000

    user_ids = np.random.randint(0, n_users, n_samples)
    item_ids = np.random.randint(0, n_items, n_samples)
    ratings = np.random.randint(0, 2, n_samples)  # Binary ratings

    # Dataset and DataLoader
    dataset = NCFDataset(user_ids, item_ids, ratings)
    train_loader = DataLoader(dataset, batch_size=256, shuffle=True)

    # NeuMF„É¢„Éá„É´„ÅÆË®ìÁ∑¥
    model = NeuMF(n_users, n_items, gmf_dim=32, mlp_dim=32, layers=[64, 32, 16])
    trained_model = train_ncf(model, train_loader, n_epochs=5, lr=0.001)

    print("\nNeuMF„É¢„Éá„É´„ÅÆË®ìÁ∑¥ÂÆå‰∫Ü")
</code></pre>

<h3>4.1.4 NCF„ÅÆÊÄßËÉΩ</h3>

<p><strong>ÂÆüÈ®ìÁµêÊûúÔºàMovieLens-1MÔºâÔºö</strong></p>

<table>
<tr>
<th>„É¢„Éá„É´</th>
<th>HR@10</th>
<th>NDCG@10</th>
<th>Ë®ìÁ∑¥ÊôÇÈñì</th>
</tr>
<tr>
<td>Matrix Factorization</td>
<td>0.692</td>
<td>0.425</td>
<td>5ÂàÜ</td>
</tr>
<tr>
<td>GMF</td>
<td>0.704</td>
<td>0.432</td>
<td>8ÂàÜ</td>
</tr>
<tr>
<td>MLP</td>
<td>0.718</td>
<td>0.445</td>
<td>12ÂàÜ</td>
</tr>
<tr>
<td>NeuMF</td>
<td>0.726</td>
<td>0.463</td>
<td>15ÂàÜ</td>
</tr>
</table>

<p><strong>ÁµêË´ñÔºö</strong> NeuMF„ÅåÊúÄÈ´òÊÄßËÉΩ„ÄÅMLP„Å®GMF„ÅÆÁµÑ„ÅøÂêà„Çè„Åõ„ÅåÂäπÊûúÁöÑ</p>

<hr>

<h2>4.2 Factorization Machines</h2>

<h3>4.2.1 FM„ÅÆÂãïÊ©ü</h3>

<p><strong>ÂïèÈ°åË®≠ÂÆöÔºö</strong></p>
<ul>
<li>„Çπ„Éë„Éº„Çπ„Å™ÁâπÂæ¥ÈáèÔºàcategorical featuresÔºâ„ÅÆÂá¶ÁêÜ</li>
<li>‰æãÔºö„É¶„Éº„Ç∂„ÉºID„ÄÅ„Ç¢„Ç§„ÉÜ„É†ID„ÄÅ„Ç´„ÉÜ„Ç¥„É™„ÄÅÊôÇÂàª„ÄÅ„Éá„Éê„Ç§„Çπ</li>
<li>One-hot encoding„ÅßÊï∞‰∏á„ÄúÊï∞Áôæ‰∏áÊ¨°ÂÖÉ</li>
</ul>

<p><strong>ÂæìÊù•ÊâãÊ≥ï„ÅÆÈôêÁïåÔºö</strong></p>
<ul>
<li>Á∑öÂΩ¢ÂõûÂ∏∞ÔºöÁâπÂæ¥ÈáèÈñì„ÅÆÁõ∏‰∫í‰ΩúÁî®„ÇíÊçâ„Åà„Çâ„Çå„Å™„ÅÑ</li>
<li>Â§öÈ†ÖÂºèÂõûÂ∏∞Ôºö„Éë„É©„É°„Éº„ÇøÊï∞„ÅåÁàÜÁô∫Ôºà$O(n^2)$Ôºâ</li>
<li>SVM„Å™„Å©ÔºöË®àÁÆó„Ç≥„Çπ„ÉàÈ´ò„ÄÅ„Çπ„Éë„Éº„Çπ„Éá„Éº„Çø„ÅßÊÄßËÉΩ‰Ωé‰∏ã</li>
</ul>

<p><strong>FM„ÅÆÊèêÊ°àÔºö</strong></p>
<ul>
<li>Ë´ñÊñá: Rendle "Factorization Machines" (ICDM 2010)</li>
<li>ÁâπÂæ¥ÈáèÈñì„ÅÆ2Ê¨°Áõ∏‰∫í‰ΩúÁî®„ÇíÂäπÁéáÁöÑ„Å´„É¢„Éá„É´Âåñ</li>
<li>ÊôÇÈñìË®àÁÆóÈáèÔºö$O(kn)$Ôºàk„ÅØÂüã„ÇÅËæº„ÅøÊ¨°ÂÖÉ„ÄÅn„ÅØÁâπÂæ¥ÈáèÊï∞Ôºâ</li>
</ul>

<h3>4.2.2 FMÊï∞Âºè</h3>

<p><strong>‰∫àÊ∏¨ÂºèÔºö</strong></p>
$$
\hat{y}(x) = w_0 + \sum_{i=1}^n w_i x_i + \sum_{i=1}^n \sum_{j=i+1}^n \langle v_i, v_j \rangle x_i x_j
$$

<p>„Åì„Åì„ÅßÔºö</p>
<ul>
<li>$w_0$: „Éê„Ç§„Ç¢„ÇπÈ†Ö</li>
<li>$w_i$: 1Ê¨°‰øÇÊï∞ÔºàÁ∑öÂΩ¢È†ÖÔºâ</li>
<li>$\langle v_i, v_j \rangle = \sum_{f=1}^k v_{i,f} \cdot v_{j,f}$: 2Ê¨°‰øÇÊï∞ÔºàÁõ∏‰∫í‰ΩúÁî®È†ÖÔºâ</li>
<li>$v_i \in \mathbb{R}^k$: ÁâπÂæ¥Èáè$i$„ÅÆÂüã„ÇÅËæº„Åø„Éô„ÇØ„Éà„É´Ôºà$k$Ê¨°ÂÖÉÔºâ</li>
</ul>

<p><strong>Ë®àÁÆóÈáèÂâäÊ∏õ„ÅÆ„Éà„É™„ÉÉ„ÇØÔºö</strong></p>
$$
\sum_{i=1}^n \sum_{j=i+1}^n \langle v_i, v_j \rangle x_i x_j = \frac{1}{2} \sum_{f=1}^k \left[ \left( \sum_{i=1}^n v_{i,f} x_i \right)^2 - \sum_{i=1}^n v_{i,f}^2 x_i^2 \right]
$$

<p>„Åì„Çå„Å´„Çà„ÇäË®àÁÆóÈáè„Åå $O(n^2) \to O(kn)$ „Å´ÂâäÊ∏õ</p>

<h3>4.2.3 Field-aware FM (FFM)</h3>

<p><strong>FM„ÅÆÊã°ÂºµÔºö</strong></p>
<ul>
<li>ÂêÑÁâπÂæ¥Èáè„ÅåË§áÊï∞„ÅÆ„Éï„Ç£„Éº„É´„ÉâÔºàfieldÔºâ„Å´ÂàÜÈ°û„Åï„Çå„Çã</li>
<li>‰æãÔºöUser fieldÔºàuser_id, age, genderÔºâ„ÄÅItem fieldÔºàitem_id, categoryÔºâ</li>
<li>Áï∞„Å™„Çãfield„Éö„Ç¢„ÅßÁï∞„Å™„ÇãÂüã„ÇÅËæº„Åø„Çí‰ΩøÁî®</li>
</ul>

<p><strong>FFM‰∫àÊ∏¨ÂºèÔºö</strong></p>
$$
\hat{y}(x) = w_0 + \sum_{i=1}^n w_i x_i + \sum_{i=1}^n \sum_{j=i+1}^n \langle v_{i,f_j}, v_{j,f_i} \rangle x_i x_j
$$

<ul>
<li>$v_{i,f_j}$: ÁâπÂæ¥Èáè$i$„Ååfield $f_j$„Å®Áõ∏‰∫í‰ΩúÁî®„Åô„Çã„Å®„Åç„ÅÆÂüã„ÇÅËæº„Åø</li>
<li>„Éë„É©„É°„Éº„ÇøÊï∞Ôºö$nfk$Ôºà$f$„ÅØ„Éï„Ç£„Éº„É´„ÉâÊï∞Ôºâ</li>
</ul>

<h3>4.2.4 DeepFM</h3>

<p><strong>FM + Deep Neural Network„ÅÆËûçÂêàÔºö</strong></p>
<ul>
<li>Ë´ñÊñá: Guo et al. "DeepFM" (IJCAI 2017)</li>
<li>‰ΩéÊ¨°Áõ∏‰∫í‰ΩúÁî®ÔºàFMÔºâ+ È´òÊ¨°Áõ∏‰∫í‰ΩúÁî®ÔºàDNNÔºâ</li>
</ul>

<p><strong>„Ç¢„Éº„Ç≠„ÉÜ„ÇØ„ÉÅ„É£Ôºö</strong></p>
<pre><code>Input: Sparse Features (one-hot)
    ‚Üì
Embedding Layer (ÂÖ±Êúâ)
    ‚îú‚îÄ FM Component
    ‚îÇ   ‚îî‚îÄ 1Ê¨°È†Ö + 2Ê¨°È†ÖÔºàÁõ∏‰∫í‰ΩúÁî®Ôºâ
    ‚îî‚îÄ Deep Component
        ‚îî‚îÄ MLP (Ë§áÊï∞Â±§„ÄÅReLU)
    ‚Üì
Output: œÉ(FM output + Deep output)
</code></pre>

<p><strong>Êï∞ÂºèÔºö</strong></p>
$$
\hat{y} = \sigma(y_{FM} + y_{DNN})
$$

<h3>4.2.5 DeepFMÂÆüË£Ö</h3>

<pre><code>import torch
import torch.nn as nn

class FMLayer(nn.Module):
    """Factorization Machine Layer"""
    def __init__(self, n_features, embedding_dim=10):
        super(FMLayer, self).__init__()

        # 1Ê¨°È†Ö
        self.linear = nn.Embedding(n_features, 1)

        # 2Ê¨°È†ÖÔºàÂüã„ÇÅËæº„ÅøÔºâ
        self.embedding = nn.Embedding(n_features, embedding_dim)

        # Initialize
        nn.init.xavier_uniform_(self.linear.weight)
        nn.init.xavier_uniform_(self.embedding.weight)

    def forward(self, x):
        """
        Args:
            x: (batch, n_fields) - feature indices
        Returns:
            fm_output: (batch,) - FM prediction
        """
        # 1Ê¨°È†Ö
        linear_part = self.linear(x).sum(dim=1).squeeze()  # (batch,)

        # 2Ê¨°È†Ö
        embeddings = self.embedding(x)  # (batch, n_fields, dim)

        # (sum of squares) - (square of sum)
        square_of_sum = torch.sum(embeddings, dim=1) ** 2  # (batch, dim)
        sum_of_square = torch.sum(embeddings ** 2, dim=1)  # (batch, dim)

        interaction = 0.5 * (square_of_sum - sum_of_square).sum(dim=1)  # (batch,)

        return linear_part + interaction


class DeepFM(nn.Module):
    """DeepFM: FM + Deep Neural Network"""
    def __init__(self, n_features, n_fields, embedding_dim=10,
                 deep_layers=[256, 128, 64]):
        super(DeepFM, self).__init__()

        self.n_fields = n_fields

        # ÂÖ±ÊúâEmbedding layer
        self.embedding = nn.Embedding(n_features, embedding_dim)

        # FM component
        self.linear = nn.Embedding(n_features, 1)
        self.bias = nn.Parameter(torch.zeros(1))

        # Deep component
        deep_input_dim = n_fields * embedding_dim
        deep_modules = []

        for i, layer_size in enumerate(deep_layers):
            if i == 0:
                deep_modules.append(nn.Linear(deep_input_dim, layer_size))
            else:
                deep_modules.append(nn.Linear(deep_layers[i-1], layer_size))
            deep_modules.append(nn.BatchNorm1d(layer_size))
            deep_modules.append(nn.ReLU())
            deep_modules.append(nn.Dropout(0.5))

        self.deep = nn.Sequential(*deep_modules)
        self.deep_fc = nn.Linear(deep_layers[-1], 1)

        # Initialize
        nn.init.xavier_uniform_(self.embedding.weight)
        nn.init.xavier_uniform_(self.linear.weight)

    def forward(self, x):
        """
        Args:
            x: (batch, n_fields) - feature indices
        Returns:
            output: (batch,) - prediction
        """
        # Embeddings
        embeddings = self.embedding(x)  # (batch, n_fields, dim)

        # FM part
        # 1Ê¨°È†Ö
        linear_part = self.linear(x).sum(dim=1).squeeze() + self.bias

        # 2Ê¨°È†Ö
        square_of_sum = torch.sum(embeddings, dim=1) ** 2
        sum_of_square = torch.sum(embeddings ** 2, dim=1)
        fm_interaction = 0.5 * (square_of_sum - sum_of_square).sum(dim=1)

        fm_output = linear_part + fm_interaction

        # Deep part
        deep_input = embeddings.view(-1, self.n_fields * embeddings.size(2))
        deep_output = self.deep(deep_input)
        deep_output = self.deep_fc(deep_output).squeeze()

        # Combine
        output = torch.sigmoid(fm_output + deep_output)
        return output


# ‰ΩøÁî®‰æã
if __name__ == "__main__":
    # „Çµ„É≥„Éó„É´„Éá„Éº„Çø
    batch_size = 128
    n_features = 10000  # Total unique features
    n_fields = 20       # Number of feature fields

    # „É©„É≥„ÉÄ„É†„Å™ÁâπÂæ¥„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ
    x = torch.randint(0, n_features, (batch_size, n_fields))

    # „É¢„Éá„É´
    model = DeepFM(n_features, n_fields, embedding_dim=10,
                   deep_layers=[256, 128, 64])

    # Forward pass
    output = model(x)
    print(f"Input shape: {x.shape}")
    print(f"Output shape: {output.shape}")
    print(f"Sample outputs: {output[:5]}")
</code></pre>

<hr>

<h2>4.3 Two-Tower Models</h2>

<h3>4.3.1 Two-Tower„Ç¢„Éº„Ç≠„ÉÜ„ÇØ„ÉÅ„É£</h3>

<p><strong>ÂãïÊ©üÔºö</strong></p>
<ul>
<li>Â§ßË¶èÊ®°Êé®Ëñ¶„Ç∑„Çπ„ÉÜ„É†ÔºàÊï∞ÂÑÑ„É¶„Éº„Ç∂„Éº √ó Êï∞ÂçÉ‰∏á„Ç¢„Ç§„ÉÜ„É†Ôºâ</li>
<li>„É™„Ç¢„É´„Çø„Ç§„É†Êé®Ë´ñ„ÅÆÂøÖË¶ÅÊÄß</li>
<li>User Tower„Å®Item Tower„ÇíÂàÜÈõ¢„Åó„Å¶„Çπ„Ç±„Éº„É©„Éñ„É´„Å´</li>
</ul>

<p><strong>„Ç¢„Éº„Ç≠„ÉÜ„ÇØ„ÉÅ„É£Ôºö</strong></p>
<pre><code>User Features          Item Features
    ‚Üì                      ‚Üì
User Tower            Item Tower
(DNN)                 (DNN)
    ‚Üì                      ‚Üì
User Embedding        Item Embedding
(dim=128)             (dim=128)
    ‚Üì                      ‚Üì
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ dot product ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                ‚Üì
          Similarity Score
</code></pre>

<p><strong>ÁâπÂæ¥Ôºö</strong></p>
<ul>
<li>User/ItemÂüã„ÇÅËæº„Åø„Çí‰∫ãÂâçË®àÁÆóÂèØËÉΩ</li>
<li>Êé®Ë´ñÊôÇÔºöÊúÄËøëÂÇçÊé¢Á¥¢ÔºàANN: Approximate Nearest NeighborÔºâ</li>
<li>Ë®àÁÆóÈáèÔºö$O(\log N)$ with ANN index (FAISS, ScaNN)</li>
</ul>

<h3>4.3.2 Contrastive Learning</h3>

<p><strong>Ë®ìÁ∑¥ÁõÆÊ®ôÔºö</strong></p>
<ul>
<li>Positive pairÔºà„É¶„Éº„Ç∂„Éº„ÅåÂÆüÈöõ„Å´Èñ≤Ë¶ß„Åó„Åü„Ç¢„Ç§„ÉÜ„É†Ôºâ„ÅÆÈ°û‰ººÂ∫¶„ÇíÊúÄÂ§ßÂåñ</li>
<li>Negative pairÔºà„É©„É≥„ÉÄ„É†„Çµ„É≥„Éó„É´Ôºâ„ÅÆÈ°û‰ººÂ∫¶„ÇíÊúÄÂ∞èÂåñ</li>
</ul>

<p><strong>ÊêçÂ§±Èñ¢Êï∞ÔºàTriplet LossÔºâÔºö</strong></p>
$$
L = \sum_{(u,i^+,i^-)} \max(0, \alpha - \text{sim}(u, i^+) + \text{sim}(u, i^-))
$$

<p>„Åæ„Åü„ÅØ<strong>InfoNCE Loss</strong>:</p>
$$
L = -\log \frac{\exp(\text{sim}(u, i^+) / \tau)}{\sum_{j \in \mathcal{N}} \exp(\text{sim}(u, i_j) / \tau)}
$$

<ul>
<li>$\tau$: temperature parameter</li>
<li>$\mathcal{N}$: negative samples</li>
</ul>

<h3>4.3.3 Two-TowerÂÆüË£Ö</h3>

<pre><code>import torch
import torch.nn as nn
import torch.nn.functional as F

class TowerNetwork(nn.Module):
    """Single Tower (User or Item)"""
    def __init__(self, input_dim, embedding_dim=128, hidden_dims=[256, 128]):
        super(TowerNetwork, self).__init__()

        layers = []
        prev_dim = input_dim

        for hidden_dim in hidden_dims:
            layers.append(nn.Linear(prev_dim, hidden_dim))
            layers.append(nn.BatchNorm1d(hidden_dim))
            layers.append(nn.ReLU())
            layers.append(nn.Dropout(0.3))
            prev_dim = hidden_dim

        # Final embedding layer
        layers.append(nn.Linear(prev_dim, embedding_dim))

        self.network = nn.Sequential(*layers)

    def forward(self, x):
        embedding = self.network(x)
        # L2 normalization
        embedding = F.normalize(embedding, p=2, dim=1)
        return embedding


class TwoTowerModel(nn.Module):
    """Two-Tower Recommendation Model"""
    def __init__(self, user_feature_dim, item_feature_dim,
                 embedding_dim=128, hidden_dims=[256, 128]):
        super(TwoTowerModel, self).__init__()

        self.user_tower = TowerNetwork(user_feature_dim, embedding_dim, hidden_dims)
        self.item_tower = TowerNetwork(item_feature_dim, embedding_dim, hidden_dims)

        self.temperature = nn.Parameter(torch.ones(1) * 0.07)

    def forward(self, user_features, item_features):
        """
        Args:
            user_features: (batch, user_dim)
            item_features: (batch, item_dim)
        Returns:
            similarity: (batch,)
        """
        user_emb = self.user_tower(user_features)  # (batch, emb_dim)
        item_emb = self.item_tower(item_features)  # (batch, emb_dim)

        # Cosine similarity (already L2 normalized)
        similarity = (user_emb * item_emb).sum(dim=1)
        return similarity

    def get_user_embedding(self, user_features):
        """Get user embedding for indexing"""
        return self.user_tower(user_features)

    def get_item_embedding(self, item_features):
        """Get item embedding for indexing"""
        return self.item_tower(item_features)


class InfoNCELoss(nn.Module):
    """InfoNCE Loss for contrastive learning"""
    def __init__(self, temperature=0.07):
        super(InfoNCELoss, self).__init__()
        self.temperature = temperature

    def forward(self, user_emb, pos_item_emb, neg_item_embs):
        """
        Args:
            user_emb: (batch, dim)
            pos_item_emb: (batch, dim) - positive items
            neg_item_embs: (batch, n_neg, dim) - negative items
        Returns:
            loss: scalar
        """
        # Positive similarity
        pos_sim = (user_emb * pos_item_emb).sum(dim=1) / self.temperature  # (batch,)

        # Negative similarities
        neg_sim = torch.bmm(neg_item_embs, user_emb.unsqueeze(2)).squeeze(2)  # (batch, n_neg)
        neg_sim = neg_sim / self.temperature

        # InfoNCE loss
        logits = torch.cat([pos_sim.unsqueeze(1), neg_sim], dim=1)  # (batch, 1+n_neg)
        labels = torch.zeros(logits.size(0), dtype=torch.long, device=logits.device)

        loss = F.cross_entropy(logits, labels)
        return loss


def train_two_tower(model, train_loader, n_epochs=10, lr=0.001, n_negatives=5):
    """Two-Tower„É¢„Éá„É´„ÅÆË®ìÁ∑¥"""
    device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
    model = model.to(device)

    criterion = InfoNCELoss(temperature=0.07)
    optimizer = torch.optim.Adam(model.parameters(), lr=lr)

    for epoch in range(n_epochs):
        model.train()
        total_loss = 0

        for batch in train_loader:
            user_feat = batch['user_features'].to(device)
            pos_item_feat = batch['pos_item_features'].to(device)
            neg_item_feats = batch['neg_item_features'].to(device)  # (batch, n_neg, dim)

            # Get embeddings
            user_emb = model.get_user_embedding(user_feat)
            pos_item_emb = model.get_item_embedding(pos_item_feat)

            # Negative embeddings
            batch_size, n_neg, feat_dim = neg_item_feats.shape
            neg_item_feats_flat = neg_item_feats.view(-1, feat_dim)
            neg_item_embs = model.get_item_embedding(neg_item_feats_flat)
            neg_item_embs = neg_item_embs.view(batch_size, n_neg, -1)

            # Compute loss
            loss = criterion(user_emb, pos_item_emb, neg_item_embs)

            # Backward
            optimizer.zero_grad()
            loss.backward()
            optimizer.step()

            total_loss += loss.item()

        avg_loss = total_loss / len(train_loader)
        print(f"Epoch {epoch+1}/{n_epochs}, Loss: {avg_loss:.4f}")

    return model


# ‰ΩøÁî®‰æã
if __name__ == "__main__":
    # „É¢„Éá„É´ÂÆöÁæ©
    user_feature_dim = 50   # User features (age, gender, history, etc.)
    item_feature_dim = 100  # Item features (category, price, brand, etc.)

    model = TwoTowerModel(user_feature_dim, item_feature_dim,
                          embedding_dim=128, hidden_dims=[256, 128])

    # „Çµ„É≥„Éó„É´ÂÖ•Âäõ
    batch_size = 64
    user_features = torch.randn(batch_size, user_feature_dim)
    item_features = torch.randn(batch_size, item_feature_dim)

    # Forward
    similarity = model(user_features, item_features)
    print(f"Similarity scores: {similarity[:5]}")

    # Get embeddings for indexing
    user_emb = model.get_user_embedding(user_features)
    item_emb = model.get_item_embedding(item_features)
    print(f"User embedding shape: {user_emb.shape}")
    print(f"Item embedding shape: {item_emb.shape}")
</code></pre>

<h3>4.3.4 ÂäπÁéáÁöÑ„Å™Êé®Ë´ñÔºàANNÔºâ</h3>

<p><strong>FAISS (Facebook AI Similarity Search) „ÅÆÂà©Áî®Ôºö</strong></p>

<pre><code>import faiss
import numpy as np

def build_item_index(item_embeddings, use_gpu=False):
    """
    Build FAISS index for fast retrieval

    Args:
        item_embeddings: (n_items, embedding_dim) numpy array
        use_gpu: whether to use GPU for indexing
    Returns:
        index: FAISS index
    """
    n_items, dim = item_embeddings.shape

    # Normalize embeddings
    faiss.normalize_L2(item_embeddings)

    # Build index (Inner Product = Cosine Similarity for normalized vectors)
    index = faiss.IndexFlatIP(dim)

    if use_gpu and faiss.get_num_gpus() > 0:
        res = faiss.StandardGpuResources()
        index = faiss.index_cpu_to_gpu(res, 0, index)

    index.add(item_embeddings)

    print(f"Built FAISS index with {index.ntotal} items")
    return index


def retrieve_top_k(user_embedding, item_index, k=10):
    """
    Retrieve top-k items for a user

    Args:
        user_embedding: (embedding_dim,) or (1, embedding_dim)
        item_index: FAISS index
        k: number of items to retrieve
    Returns:
        scores: (k,) similarity scores
        indices: (k,) item indices
    """
    if len(user_embedding.shape) == 1:
        user_embedding = user_embedding.reshape(1, -1)

    # Normalize
    faiss.normalize_L2(user_embedding)

    # Search
    scores, indices = item_index.search(user_embedding, k)

    return scores[0], indices[0]


# ‰ΩøÁî®‰æã
if __name__ == "__main__":
    # ‰ªÆ„ÅÆ„Ç¢„Ç§„ÉÜ„É†Âüã„ÇÅËæº„ÅøÔºà100‰∏á„Ç¢„Ç§„ÉÜ„É†Ôºâ
    n_items = 1_000_000
    embedding_dim = 128

    item_embeddings = np.random.randn(n_items, embedding_dim).astype('float32')

    # Build index
    index = build_item_index(item_embeddings, use_gpu=False)

    # User embedding
    user_emb = np.random.randn(embedding_dim).astype('float32')

    # Retrieve top-10
    scores, indices = retrieve_top_k(user_emb, index, k=10)

    print(f"Top-10 item indices: {indices}")
    print(f"Top-10 scores: {scores}")
</code></pre>

<hr>

<h2>4.4 Sequence-basedÊé®Ëñ¶</h2>

<h3>4.4.1 Session-based Recommendation</h3>

<p><strong>ÂïèÈ°åË®≠ÂÆöÔºö</strong></p>
<ul>
<li>„É¶„Éº„Ç∂„Éº„ÅÆË°åÂãïÂ±•Ê≠¥ÔºàsessionÔºâ„Åã„ÇâÊ¨°„ÅÆ„Ç¢„ÇØ„Ç∑„Éß„É≥„Çí‰∫àÊ∏¨</li>
<li>‰æãÔºöE-commerceÔºàÈñ≤Ë¶ßÂ±•Ê≠¥ ‚Üí Ê¨°„Å´Èñ≤Ë¶ß/Ë≥ºÂÖ•„Åô„ÇãÂïÜÂìÅÔºâ</li>
<li>ÂåøÂêç„É¶„Éº„Ç∂„Éº„Åß„ÇÇÈÅ©Áî®ÂèØËÉΩÔºàuser ID„Å™„ÅóÔºâ</li>
</ul>

<p><strong>„Éá„Éº„ÇøÂΩ¢ÂºèÔºö</strong></p>
<pre><code>Session 1: [item_5, item_12, item_3, item_8] ‚Üí item_15
Session 2: [item_1, item_6] ‚Üí item_9
Session 3: [item_12, item_15, item_2] ‚Üí item_7
</code></pre>

<h3>4.4.2 RNN/GRU for Sequential Recommendation</h3>

<p><strong>GRU4Rec (Session-based Recommendations with RNNs):</strong></p>
<ul>
<li>Ë´ñÊñá: Hidasi et al. (ICLR 2016)</li>
<li>GRU (Gated Recurrent Unit) „Åß„Çª„ÉÉ„Ç∑„Éß„É≥„Çí„É¢„Éá„É´Âåñ</li>
</ul>

<p><strong>„Ç¢„Éº„Ç≠„ÉÜ„ÇØ„ÉÅ„É£Ôºö</strong></p>
<pre><code>Input: item sequence [i_1, i_2, ..., i_t]
    ‚Üì
Embedding Layer: [e_1, e_2, ..., e_t]
    ‚Üì
GRU Layer: h_t = GRU(e_t, h_{t-1})
    ‚Üì
Output Layer: softmax(W h_t + b) ‚Üí P(next item)
</code></pre>

<h3>4.4.3 GRU4RecÂÆüË£Ö</h3>

<pre><code>import torch
import torch.nn as nn

class GRU4Rec(nn.Module):
    """GRU-based Session Recommendation"""
    def __init__(self, n_items, embedding_dim=100, hidden_dim=100, n_layers=1):
        super(GRU4Rec, self).__init__()

        self.n_items = n_items
        self.embedding_dim = embedding_dim
        self.hidden_dim = hidden_dim

        # Embedding layer
        self.item_embedding = nn.Embedding(n_items, embedding_dim, padding_idx=0)

        # GRU layer
        self.gru = nn.GRU(embedding_dim, hidden_dim, n_layers,
                          batch_first=True, dropout=0.2 if n_layers > 1 else 0)

        # Output layer
        self.fc = nn.Linear(hidden_dim, n_items)

        # Initialize
        nn.init.xavier_uniform_(self.item_embedding.weight)
        nn.init.xavier_uniform_(self.fc.weight)

    def forward(self, item_seq, lengths=None):
        """
        Args:
            item_seq: (batch, seq_len) - item ID sequence
            lengths: (batch,) - actual sequence lengths
        Returns:
            logits: (batch, n_items) - prediction for next item
        """
        # Embedding
        emb = self.item_embedding(item_seq)  # (batch, seq_len, emb_dim)

        # GRU
        if lengths is not None:
            # Pack sequence for efficiency
            packed = nn.utils.rnn.pack_padded_sequence(
                emb, lengths.cpu(), batch_first=True, enforce_sorted=False
            )
            gru_out, hidden = self.gru(packed)
            gru_out, _ = nn.utils.rnn.pad_packed_sequence(gru_out, batch_first=True)
        else:
            gru_out, hidden = self.gru(emb)  # (batch, seq_len, hidden)

        # Get last hidden state
        if lengths is not None:
            idx = (lengths - 1).view(-1, 1, 1).expand(-1, 1, gru_out.size(2))
            last_hidden = gru_out.gather(1, idx).squeeze(1)  # (batch, hidden)
        else:
            last_hidden = gru_out[:, -1, :]  # (batch, hidden)

        # Output
        logits = self.fc(last_hidden)  # (batch, n_items)
        return logits


def train_gru4rec(model, train_loader, n_epochs=10, lr=0.001):
    """GRU4Rec„ÅÆË®ìÁ∑¥"""
    device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
    model = model.to(device)

    criterion = nn.CrossEntropyLoss(ignore_index=0)  # Ignore padding
    optimizer = torch.optim.Adam(model.parameters(), lr=lr)

    for epoch in range(n_epochs):
        model.train()
        total_loss = 0

        for batch in train_loader:
            item_seq = batch['item_seq'].to(device)  # (batch, seq_len)
            target = batch['target'].to(device)      # (batch,)
            lengths = batch['lengths'].to(device)    # (batch,)

            # Forward
            logits = model(item_seq, lengths)
            loss = criterion(logits, target)

            # Backward
            optimizer.zero_grad()
            loss.backward()
            optimizer.step()

            total_loss += loss.item()

        avg_loss = total_loss / len(train_loader)
        print(f"Epoch {epoch+1}/{n_epochs}, Loss: {avg_loss:.4f}")

    return model


# ‰ΩøÁî®‰æã
if __name__ == "__main__":
    n_items = 10000
    model = GRU4Rec(n_items, embedding_dim=100, hidden_dim=100, n_layers=2)

    # „Çµ„É≥„Éó„É´ÂÖ•Âäõ
    batch_size = 32
    seq_len = 10
    item_seq = torch.randint(1, n_items, (batch_size, seq_len))
    lengths = torch.randint(5, seq_len+1, (batch_size,))

    logits = model(item_seq, lengths)
    print(f"Input shape: {item_seq.shape}")
    print(f"Output shape: {logits.shape}")

    # Top-k prediction
    k = 10
    _, top_k_items = torch.topk(logits, k, dim=1)
    print(f"Top-{k} predicted items (first sample): {top_k_items[0]}")
</code></pre>

<h3>4.4.4 Self-Attention for Sequential Recommendation (SASRec)</h3>

<p><strong>Self-Attention„ÅÆÂà©ÁÇπÔºö</strong></p>
<ul>
<li>RNN/GRU„ÅÆÈÄêÊ¨°Âá¶ÁêÜ„ÅÆÂà∂Á¥Ñ„ÇíÂÖãÊúç</li>
<li>‰∏¶ÂàóË®àÁÆóÂèØËÉΩ„ÄÅÈï∑Ë∑ùÈõ¢‰æùÂ≠òÈñ¢‰øÇ„ÇíÊçâ„Åà„ÇÑ„Åô„ÅÑ</li>
<li>Ë´ñÊñá: Kang & McAuley "SASRec" (ICDM 2018)</li>
</ul>

<p><strong>„Ç¢„Éº„Ç≠„ÉÜ„ÇØ„ÉÅ„É£Ôºö</strong></p>
<pre><code>Input: [i_1, i_2, ..., i_t]
    ‚Üì
Embedding + Positional Encoding
    ‚Üì
Self-Attention Blocks (√óL layers)
‚îú‚îÄ Multi-Head Self-Attention
‚îú‚îÄ Feed-Forward Network
‚îî‚îÄ Layer Normalization + Residual
    ‚Üì
Output Layer: Predict i_{t+1}
</code></pre>

<h3>4.4.5 SASRecÂÆüË£Ö</h3>

<pre><code>import torch
import torch.nn as nn
import torch.nn.functional as F
import math

class SelfAttention(nn.Module):
    """Multi-Head Self-Attention"""
    def __init__(self, hidden_dim, n_heads, dropout=0.1):
        super(SelfAttention, self).__init__()

        assert hidden_dim % n_heads == 0

        self.hidden_dim = hidden_dim
        self.n_heads = n_heads
        self.head_dim = hidden_dim // n_heads

        self.q_linear = nn.Linear(hidden_dim, hidden_dim)
        self.k_linear = nn.Linear(hidden_dim, hidden_dim)
        self.v_linear = nn.Linear(hidden_dim, hidden_dim)

        self.out_linear = nn.Linear(hidden_dim, hidden_dim)
        self.dropout = nn.Dropout(dropout)

    def forward(self, x, mask=None):
        """
        Args:
            x: (batch, seq_len, hidden_dim)
            mask: (batch, seq_len, seq_len) - causal mask
        Returns:
            out: (batch, seq_len, hidden_dim)
        """
        batch_size, seq_len, _ = x.shape

        # Linear projections
        Q = self.q_linear(x)  # (batch, seq_len, hidden)
        K = self.k_linear(x)
        V = self.v_linear(x)

        # Reshape for multi-head
        Q = Q.view(batch_size, seq_len, self.n_heads, self.head_dim).transpose(1, 2)
        K = K.view(batch_size, seq_len, self.n_heads, self.head_dim).transpose(1, 2)
        V = V.view(batch_size, seq_len, self.n_heads, self.head_dim).transpose(1, 2)
        # (batch, n_heads, seq_len, head_dim)

        # Attention scores
        scores = torch.matmul(Q, K.transpose(-2, -1)) / math.sqrt(self.head_dim)
        # (batch, n_heads, seq_len, seq_len)

        # Apply mask (causal)
        if mask is not None:
            scores = scores.masked_fill(mask == 0, -1e9)

        # Softmax
        attn = F.softmax(scores, dim=-1)
        attn = self.dropout(attn)

        # Apply attention to values
        out = torch.matmul(attn, V)  # (batch, n_heads, seq_len, head_dim)

        # Reshape back
        out = out.transpose(1, 2).contiguous().view(batch_size, seq_len, self.hidden_dim)

        # Final linear
        out = self.out_linear(out)
        return out


class FeedForward(nn.Module):
    """Position-wise Feed-Forward Network"""
    def __init__(self, hidden_dim, ff_dim, dropout=0.1):
        super(FeedForward, self).__init__()

        self.linear1 = nn.Linear(hidden_dim, ff_dim)
        self.linear2 = nn.Linear(ff_dim, hidden_dim)
        self.dropout = nn.Dropout(dropout)

    def forward(self, x):
        return self.linear2(self.dropout(F.relu(self.linear1(x))))


class SASRecBlock(nn.Module):
    """Single SASRec Transformer Block"""
    def __init__(self, hidden_dim, n_heads, ff_dim, dropout=0.1):
        super(SASRecBlock, self).__init__()

        self.attn = SelfAttention(hidden_dim, n_heads, dropout)
        self.ff = FeedForward(hidden_dim, ff_dim, dropout)

        self.ln1 = nn.LayerNorm(hidden_dim)
        self.ln2 = nn.LayerNorm(hidden_dim)

        self.dropout = nn.Dropout(dropout)

    def forward(self, x, mask):
        # Self-attention + residual
        attn_out = self.attn(self.ln1(x), mask)
        x = x + self.dropout(attn_out)

        # Feed-forward + residual
        ff_out = self.ff(self.ln2(x))
        x = x + self.dropout(ff_out)

        return x


class SASRec(nn.Module):
    """Self-Attentive Sequential Recommendation"""
    def __init__(self, n_items, max_len=50, hidden_dim=100,
                 n_heads=2, n_blocks=2, dropout=0.1):
        super(SASRec, self).__init__()

        self.n_items = n_items
        self.max_len = max_len

        # Embeddings
        self.item_embedding = nn.Embedding(n_items + 1, hidden_dim, padding_idx=0)
        self.pos_embedding = nn.Embedding(max_len, hidden_dim)

        # Transformer blocks
        self.blocks = nn.ModuleList([
            SASRecBlock(hidden_dim, n_heads, hidden_dim * 4, dropout)
            for _ in range(n_blocks)
        ])

        self.ln = nn.LayerNorm(hidden_dim)
        self.dropout = nn.Dropout(dropout)

        # Initialize
        nn.init.xavier_uniform_(self.item_embedding.weight)
        nn.init.xavier_uniform_(self.pos_embedding.weight)

    def forward(self, item_seq):
        """
        Args:
            item_seq: (batch, seq_len)
        Returns:
            logits: (batch, seq_len, n_items)
        """
        batch_size, seq_len = item_seq.shape

        # Item embeddings
        item_emb = self.item_embedding(item_seq)  # (batch, seq_len, hidden)

        # Positional embeddings
        positions = torch.arange(seq_len, device=item_seq.device).unsqueeze(0)
        pos_emb = self.pos_embedding(positions)  # (1, seq_len, hidden)

        # Combine
        x = item_emb + pos_emb
        x = self.dropout(x)

        # Causal mask (prevent looking at future items)
        mask = torch.tril(torch.ones((seq_len, seq_len), device=item_seq.device))
        mask = mask.unsqueeze(0).unsqueeze(0)  # (1, 1, seq_len, seq_len)

        # Transformer blocks
        for block in self.blocks:
            x = block(x, mask)

        x = self.ln(x)

        # Predict next item (using item embeddings as output weights)
        logits = torch.matmul(x, self.item_embedding.weight.T)  # (batch, seq_len, n_items+1)

        return logits[:, :, 1:]  # Remove padding index


# ‰ΩøÁî®‰æã
if __name__ == "__main__":
    n_items = 10000
    max_len = 50

    model = SASRec(n_items, max_len=max_len, hidden_dim=128,
                   n_heads=4, n_blocks=2, dropout=0.2)

    # „Çµ„É≥„Éó„É´ÂÖ•Âäõ
    batch_size = 16
    seq_len = 20
    item_seq = torch.randint(1, n_items, (batch_size, seq_len))

    logits = model(item_seq)
    print(f"Input shape: {item_seq.shape}")
    print(f"Output shape: {logits.shape}")

    # Predict next item (using last position)
    last_logits = logits[:, -1, :]  # (batch, n_items)
    _, top_k = torch.topk(last_logits, 10, dim=1)
    print(f"Top-10 predictions: {top_k[0]}")
</code></pre>

<h3>4.4.6 BERT4Rec</h3>

<p><strong>BERT for Sequential Recommendation:</strong></p>
<ul>
<li>Ë´ñÊñá: Sun et al. "BERT4Rec" (CIKM 2019)</li>
<li>ÂèåÊñπÂêëTransformerÔºàÈÅéÂéª+Êú™Êù•„ÅÆÊñáËÑà„ÇíÂà©Áî®Ôºâ</li>
<li>Masked Item Prediction (MLMÈ¢®)</li>
</ul>

<p><strong>Ë®ìÁ∑¥ÊñπÊ≥ïÔºö</strong></p>
<ul>
<li>ÂÖ•Âäõ„Ç∑„Éº„Ç±„É≥„Çπ„ÅÆ‰∏ÄÈÉ®„Çí„Éû„Çπ„ÇØÔºà[MASK]„Éà„Éº„ÇØ„É≥Ôºâ</li>
<li>„Éû„Çπ„ÇØ„Åï„Çå„Åü„Ç¢„Ç§„ÉÜ„É†„Çí‰∫àÊ∏¨</li>
<li>ÂèåÊñπÂêë„ÅÆÊñáËÑà„ÇíÂà©Áî®ÂèØËÉΩ</li>
</ul>

<hr>

<h2>4.5 ÂÆüË∑µÁöÑ„Å™Êé®Ëñ¶„Ç∑„Çπ„ÉÜ„É†„Éë„Ç§„Éó„É©„Ç§„É≥</h2>

<h3>4.5.1 End-to-End„Éë„Ç§„Éó„É©„Ç§„É≥</h3>

<p><strong>Êé®Ëñ¶„Ç∑„Çπ„ÉÜ„É†„ÅÆ2ÊÆµÈöé„Ç¢„Éº„Ç≠„ÉÜ„ÇØ„ÉÅ„É£Ôºö</strong></p>

<pre><code>Stage 1: Candidate GenerationÔºàÂÄôË£úÁîüÊàêÔºâ
‚îú‚îÄ Input: User context
‚îú‚îÄ Method: Two-Tower, Matrix Factorization, Graph-based
‚îú‚îÄ Output: Êï∞Áôæ„ÄúÊï∞ÂçÉ„ÅÆÂÄôË£ú„Ç¢„Ç§„ÉÜ„É†
‚îî‚îÄ ÁõÆÁöÑ: RecallÊúÄÂ§ßÂåñ„ÄÅÈ´òÈÄü

Stage 2: RankingÔºà„É©„É≥„Ç≠„É≥„Ç∞Ôºâ
‚îú‚îÄ Input: User + ÂÄôË£ú„Ç¢„Ç§„ÉÜ„É†
‚îú‚îÄ Method: DeepFM, Wide&Deep, DNN
‚îú‚îÄ Output: Top-KÊé®Ëñ¶„É™„Çπ„Éà
‚îî‚îÄ ÁõÆÁöÑ: PrecisionÊúÄÂ§ßÂåñ„ÄÅÁ≤æÂ∫¶ÈáçË¶ñ
</code></pre>

<h3>4.5.2 Candidate Generation‰æã</h3>

<pre><code>import numpy as np
from sklearn.metrics.pairwise import cosine_similarity

class CandidateGenerator:
    """ÂÄôË£úÁîüÊàê„É¢„Ç∏„É•„Éº„É´"""
    def __init__(self, user_embeddings, item_embeddings):
        """
        Args:
            user_embeddings: (n_users, dim)
            item_embeddings: (n_items, dim)
        """
        self.user_embeddings = user_embeddings
        self.item_embeddings = item_embeddings

        # Build FAISS index for fast retrieval
        import faiss
        dim = item_embeddings.shape[1]

        # Normalize for cosine similarity
        faiss.normalize_L2(item_embeddings)

        self.index = faiss.IndexFlatIP(dim)
        self.index.add(item_embeddings.astype('float32'))

    def generate_candidates(self, user_id, n_candidates=500, exclude_items=None):
        """
        Generate candidate items for a user

        Args:
            user_id: int
            n_candidates: number of candidates to retrieve
            exclude_items: set of item IDs to exclude
        Returns:
            candidate_items: list of item IDs
            scores: list of similarity scores
        """
        # Get user embedding
        user_emb = self.user_embeddings[user_id:user_id+1].astype('float32')

        # Normalize
        import faiss
        faiss.normalize_L2(user_emb)

        # Retrieve top candidates
        scores, indices = self.index.search(user_emb, n_candidates * 2)
        scores = scores[0]
        indices = indices[0]

        # Filter out excluded items
        if exclude_items is not None:
            mask = ~np.isin(indices, list(exclude_items))
            indices = indices[mask]
            scores = scores[mask]

        # Return top n_candidates
        return indices[:n_candidates].tolist(), scores[:n_candidates].tolist()


class Ranker:
    """„É©„É≥„Ç≠„É≥„Ç∞„É¢„Ç∏„É•„Éº„É´ÔºàDeepFM„Å™„Å©Ôºâ"""
    def __init__(self, ranking_model):
        self.model = ranking_model

    def rank(self, user_features, candidate_item_features, top_k=10):
        """
        Rank candidate items

        Args:
            user_features: user feature vector
            candidate_item_features: (n_candidates, item_dim)
            top_k: number of items to return
        Returns:
            ranked_items: list of item indices
            scores: list of ranking scores
        """
        import torch

        n_candidates = len(candidate_item_features)

        # Replicate user features
        user_feat_batch = np.tile(user_features, (n_candidates, 1))

        # Combine features
        features = np.concatenate([user_feat_batch, candidate_item_features], axis=1)
        features_tensor = torch.FloatTensor(features)

        # Predict scores
        with torch.no_grad():
            scores = self.model(features_tensor).numpy()

        # Sort by score
        sorted_indices = np.argsort(scores)[::-1]

        return sorted_indices[:top_k].tolist(), scores[sorted_indices[:top_k]].tolist()


class RecommendationPipeline:
    """Êé®Ëñ¶„Éë„Ç§„Éó„É©„Ç§„É≥ÔºàÂÄôË£úÁîüÊàê + „É©„É≥„Ç≠„É≥„Ç∞Ôºâ"""
    def __init__(self, candidate_generator, ranker):
        self.candidate_generator = candidate_generator
        self.ranker = ranker

    def recommend(self, user_id, user_features, item_features_db,
                  n_candidates=500, top_k=10, exclude_items=None):
        """
        Generate recommendations for a user

        Args:
            user_id: int
            user_features: user feature vector
            item_features_db: dict {item_id: features}
            n_candidates: number of candidates
            top_k: number of final recommendations
            exclude_items: set of item IDs to exclude
        Returns:
            recommendations: list of (item_id, score) tuples
        """
        # Stage 1: Candidate Generation
        candidate_ids, _ = self.candidate_generator.generate_candidates(
            user_id, n_candidates, exclude_items
        )

        # Get item features for candidates
        candidate_features = np.array([item_features_db[iid] for iid in candidate_ids])

        # Stage 2: Ranking
        ranked_indices, scores = self.ranker.rank(user_features, candidate_features, top_k)

        # Map back to item IDs
        recommendations = [(candidate_ids[idx], scores[i])
                          for i, idx in enumerate(ranked_indices)]

        return recommendations


# ‰ΩøÁî®‰æã
if __name__ == "__main__":
    # ‰ªÆ„ÅÆ„Éá„Éº„Çø
    n_users = 10000
    n_items = 50000
    emb_dim = 128

    user_embeddings = np.random.randn(n_users, emb_dim).astype('float32')
    item_embeddings = np.random.randn(n_items, emb_dim).astype('float32')

    # Candidate Generator
    candidate_gen = CandidateGenerator(user_embeddings, item_embeddings)

    # ‰ªÆ„ÅÆ„É©„É≥„Ç≠„É≥„Ç∞„É¢„Éá„É´ÔºàÂÆüÈöõ„Å´„ÅØDeepFM„Å™„Å©Ôºâ
    class DummyRanker:
        def __call__(self, x):
            return torch.rand(len(x))

    ranker = Ranker(DummyRanker())

    # Pipeline
    pipeline = RecommendationPipeline(candidate_gen, ranker)

    # Recommend
    user_id = 42
    user_feat = np.random.randn(50)
    item_feat_db = {i: np.random.randn(100) for i in range(n_items)}

    recommendations = pipeline.recommend(
        user_id, user_feat, item_feat_db,
        n_candidates=500, top_k=10, exclude_items={1, 5, 10}
    )

    print("Top-10 Recommendations:")
    for item_id, score in recommendations:
        print(f"  Item {item_id}: {score:.4f}")
</code></pre>

<h3>4.5.3 A/B„ÉÜ„Çπ„Éà</h3>

<p><strong>ÂÆüÈ®ìË®≠Ë®àÔºö</strong></p>
<ul>
<li>Control Group: Êó¢Â≠ò„ÅÆÊé®Ëñ¶„Ç¢„É´„Ç¥„É™„Ç∫„É†</li>
<li>Treatment Group: Êñ∞„Åó„ÅÑ„Ç¢„É´„Ç¥„É™„Ç∫„É†ÔºàDeepFM„ÄÅTwo-Tower„Å™„Å©Ôºâ</li>
<li>Ë©ï‰æ°ÊåáÊ®ôÔºöCTR„ÄÅConversion Rate„ÄÅRevenue„ÄÅUser Engagement</li>
</ul>

<p><strong>Áµ±Ë®àÁöÑÊúâÊÑèÊÄß„ÅÆÊ§úÂÆöÔºö</strong></p>
<ul>
<li>Â∏∞ÁÑ°‰ªÆË™¨Ôºö$H_0$: Êñ∞„Ç¢„É´„Ç¥„É™„Ç∫„É†„ÅÆÂäπÊûú„Å™„Åó</li>
<li>ÂØæÁ´ã‰ªÆË™¨Ôºö$H_1$: Êñ∞„Ç¢„É´„Ç¥„É™„Ç∫„É†„ÅÆÂäπÊûú„ÅÇ„Çä</li>
<li>ÊúâÊÑèÊ∞¥Ê∫ñÔºö$\alpha = 0.05$Ôºà5%Ôºâ</li>
<li>Ê§úÂÆöÊñπÊ≥ïÔºötÊ§úÂÆö„ÄÅWelch's t-test„ÄÅMann-Whitney UÊ§úÂÆö</li>
</ul>

<h3>4.5.4 Production Deployment</h3>

<p><strong>„Ç∑„Çπ„ÉÜ„É†Ë¶Å‰ª∂Ôºö</strong></p>
<ul>
<li>„É¨„Ç§„ÉÜ„É≥„Ç∑Ôºö< 100msÔºàÊé®Ë´ñÊôÇÈñìÔºâ</li>
<li>„Çπ„É´„Éº„Éó„ÉÉ„ÉàÔºö> 10,000 QPSÔºàQueries Per SecondÔºâ</li>
<li>„Çπ„Ç±„Éº„É©„Éì„É™„ÉÜ„Ç£ÔºöÊ∞¥Âπ≥„Çπ„Ç±„Éº„É´ÂèØËÉΩ</li>
</ul>

<p><strong>ÊäÄË°ì„Çπ„Çø„ÉÉ„ÇØ‰æãÔºö</strong></p>
<ul>
<li>„É¢„Éá„É´„Çµ„Éº„ÉñÔºöTensorFlow Serving„ÄÅTorchServe„ÄÅNVIDIA Triton</li>
<li>„Ç≠„É£„ÉÉ„Ç∑„É•ÔºöRedisÔºà„É¶„Éº„Ç∂„ÉºÂüã„ÇÅËæº„Åø„ÄÅ„Ç¢„Ç§„ÉÜ„É†Âüã„ÇÅËæº„ÅøÔºâ</li>
<li>ANNÊ§úÁ¥¢ÔºöFAISS„ÄÅScaNN„ÄÅMilvus</li>
<li>„É≠„Ç∞ÂèéÈõÜÔºöKafka„ÄÅFluentd</li>
<li>„É¢„Éã„Çø„É™„É≥„Ç∞ÔºöPrometheus„ÄÅGrafana</li>
</ul>

<hr>

<h2>„Åæ„Å®„ÇÅ</h2>

<p>Êú¨Á´†„ÅßÂ≠¶„Çì„Å†„Åì„Å®Ôºö</p>

<ol>
<li><strong>Neural Collaborative Filtering (NCF):</strong>
<ul>
<li>GMF„ÄÅMLP„ÄÅNeuMF„ÅÆ3„Å§„ÅÆ„Ç¢„Éó„É≠„Éº„ÉÅ</li>
<li>ÈùûÁ∑öÂΩ¢„Å™Áõ∏‰∫í‰ΩúÁî®„ÇíMLP„ÅßË°®Áèæ</li>
<li>MovieLens„ÅßHR@10 0.726ÈÅîÊàê</li>
</ul>
</li>

<li><strong>Factorization Machines:</strong>
<ul>
<li>2Ê¨°Áõ∏‰∫í‰ΩúÁî®„Çí$O(kn)$„ÅßË®àÁÆó</li>
<li>FFM„Åß„Éï„Ç£„Éº„É´„ÉâÂà•Âüã„ÇÅËæº„Åø</li>
<li>DeepFM„ÅßFM+DNN„ÇíËûçÂêà</li>
</ul>
</li>

<li><strong>Two-Tower Models:</strong>
<ul>
<li>User Tower„Å®Item Tower„ÇíÂàÜÈõ¢</li>
<li>FAISS/ScaNN„ÅßÈ´òÈÄüÊé®Ë´ñÔºà$O(\log N)$Ôºâ</li>
<li>InfoNCE Loss„ÅßÂØæÁÖßÂ≠¶Áøí</li>
</ul>
</li>

<li><strong>Sequence-basedÊé®Ëñ¶:</strong>
<ul>
<li>GRU4Rec: „Çª„ÉÉ„Ç∑„Éß„É≥„Éô„Éº„ÇπÊé®Ëñ¶</li>
<li>SASRec: Self-Attention„ÅßÈï∑Ë∑ùÈõ¢‰æùÂ≠ò</li>
<li>BERT4Rec: ÂèåÊñπÂêëTransformer„Åß„Éû„Çπ„ÇØ‰∫àÊ∏¨</li>
</ul>
</li>

<li><strong>ÂÆüË∑µÁöÑ„Éë„Ç§„Éó„É©„Ç§„É≥:</strong>
<ul>
<li>ÂÄôË£úÁîüÊàêÔºàRecallÈáçË¶ñÔºâ+ „É©„É≥„Ç≠„É≥„Ç∞ÔºàPrecisionÈáçË¶ñÔºâ</li>
<li>A/B„ÉÜ„Çπ„Éà„ÅßÂäπÊûúÊ§úË®º</li>
<li>Production deployment„ÅÆÊäÄË°ì„Çπ„Çø„ÉÉ„ÇØ</li>
</ul>
</li>
</ol>

<hr>

<h2>ÊºîÁøíÂïèÈ°å</h2>

<p><strong>Âïè1:</strong> NeuMF„ÅåMatrix Factorization„Çà„ÇäÈ´òÊÄßËÉΩ„Å™ÁêÜÁî±„Çí„ÄÅÁ∑öÂΩ¢ÊÄß„Å®ÈùûÁ∑öÂΩ¢ÊÄß„ÅÆË¶≥ÁÇπ„Åã„ÇâË™¨Êòé„Åõ„Çà„ÄÇ</p>

<p><strong>Âïè2:</strong> Factorization Machines„ÅÆ2Ê¨°Áõ∏‰∫í‰ΩúÁî®„ÅÆË®àÁÆóÈáè„Åå$O(n^2)$„Åã„Çâ$O(kn)$„Å´ÂâäÊ∏õ„Åï„Çå„Çã‰ªïÁµÑ„Åø„ÇíÊï∞Âºè„ÇíÁî®„ÅÑ„Å¶Á§∫„Åõ„ÄÇ</p>

<p><strong>Âïè3:</strong> Two-Tower Model„Åß„ÄÅUser Tower„Å®Item Tower„ÇíÂàÜÈõ¢„Åô„Çã„É°„É™„ÉÉ„Éà„Å®„Éá„É°„É™„ÉÉ„Éà„Çí3„Å§„Åö„Å§Êåô„Åí„Çà„ÄÇ</p>

<p><strong>Âïè4:</strong> SASRec„Å®GRU4Rec„ÅÆÈÅï„ÅÑ„Çí„ÄÅ‰∏¶ÂàóÂåñÂèØËÉΩÊÄß„Å®Èï∑Ë∑ùÈõ¢‰æùÂ≠ò„ÅÆÊçâ„ÅàÊñπ„ÅÆ2„Å§„ÅÆË¶≥ÁÇπ„Åã„ÇâË´ñ„Åò„Çà„ÄÇ</p>

<p><strong>Âïè5:</strong> Êé®Ëñ¶„Ç∑„Çπ„ÉÜ„É†„ÅÆCandidate GenerationÊÆµÈöé„ÅßRecall@500 = 0.8„ÄÅRankingÊÆµÈöé„ÅßPrecision@10 = 0.3„ÅÆÂ†¥Âêà„ÄÅÊúÄÁµÇÁöÑ„Å™Top-10Êé®Ëñ¶„ÅÆÊúüÂæÖÁöÑ‰∏≠Êï∞„ÇíË®àÁÆó„Åõ„Çà„ÄÇ</p>

<p><strong>Âïè6:</strong> Â§ßË¶èÊ®°Êé®Ëñ¶„Ç∑„Çπ„ÉÜ„É†Ôºà1ÂÑÑ„É¶„Éº„Ç∂„Éº √ó 1000‰∏á„Ç¢„Ç§„ÉÜ„É†Ôºâ„Åß„É¨„Ç§„ÉÜ„É≥„Ç∑ < 100ms„ÇíÈÅîÊàê„Åô„Çã„Åü„ÇÅ„ÅÆÊäÄË°ìÁöÑÂ∑•Â§´„Çí5„Å§ÊèêÊ°à„Åõ„Çà„ÄÇ</p>

<hr>

<h2>ÂèÇËÄÉÊñáÁåÆ</h2>

<ol>
<li>He, X. et al. "Neural Collaborative Filtering." <em>Proceedings of WWW</em> (2017).</li>
<li>Rendle, S. "Factorization Machines." <em>Proceedings of ICDM</em> (2010).</li>
<li>Juan, Y. et al. "Field-aware Factorization Machines for CTR Prediction." <em>RecSys</em> (2016).</li>
<li>Guo, H. et al. "DeepFM: A Factorization-Machine based Neural Network for CTR Prediction." <em>IJCAI</em> (2017).</li>
<li>Yi, X. et al. "Sampling-Bias-Corrected Neural Modeling for Large Corpus Item Recommendations." <em>RecSys</em> (2019). [Two-Tower]</li>
<li>Hidasi, B. et al. "Session-based Recommendations with Recurrent Neural Networks." <em>ICLR</em> (2016).</li>
<li>Kang, W. & McAuley, J. "Self-Attentive Sequential Recommendation." <em>ICDM</em> (2018).</li>
<li>Sun, F. et al. "BERT4Rec: Sequential Recommendation with Bidirectional Encoder Representations from Transformer." <em>CIKM</em> (2019).</li>
<li>Covington, P. et al. "Deep Neural Networks for YouTube Recommendations." <em>RecSys</em> (2016).</li>
<li>Cheng, H. et al. "Wide & Deep Learning for Recommender Systems." <em>DLRS Workshop</em> (2016).</li>
</ol>

<hr>

<div class="navigation">
    <a href="chapter3-hybrid-methods.html" class="nav-button">‚Üê Ââç„ÅÆÁ´†</a>
    <a href="index.html" class="nav-button">„Ç∑„É™„Éº„Ç∫ÁõÆÊ¨°„Å´Êàª„Çã</a>
    <a href="chapter5-advanced-topics.html" class="nav-button">Ê¨°„ÅÆÁ´† ‚Üí</a>
</div>

    </main>

    <footer>
        <p><strong>‰ΩúÊàêËÄÖ</strong>: AI Terakoya Content Team</p>
        <p><strong>Áõ£‰øÆ</strong>: Dr. Yusuke Hashimoto</p>
        <p><strong>„Éê„Éº„Ç∏„Éß„É≥</strong>: 1.0 | <strong>‰ΩúÊàêÊó•</strong>: 2025-10-21</p>
        <p><strong>„É©„Ç§„Çª„É≥„Çπ</strong>: Creative Commons BY 4.0</p>
        <p>¬© 2025 AI Terakoya. All rights reserved.</p>
    </footer>
</body>
</html>
