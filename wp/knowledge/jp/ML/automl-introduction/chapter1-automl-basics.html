<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>第1章：AutoML基礎 - AI Terakoya</title>

    <style>
        :root {
            --color-primary: #2c3e50;
            --color-primary-dark: #1a252f;
            --color-accent: #7b2cbf;
            --color-accent-light: #9d4edd;
            --color-text: #2d3748;
            --color-text-light: #4a5568;
            --color-bg: #ffffff;
            --color-bg-alt: #f7fafc;
            --color-border: #e2e8f0;
            --color-code-bg: #f8f9fa;
            --color-link: #3182ce;
            --color-link-hover: #2c5aa0;

            --spacing-xs: 0.5rem;
            --spacing-sm: 1rem;
            --spacing-md: 1.5rem;
            --spacing-lg: 2rem;
            --spacing-xl: 3rem;

            --font-body: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            --font-mono: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;

            --border-radius: 8px;
            --box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-body);
            line-height: 1.7;
            color: var(--color-text);
            background-color: var(--color-bg);
            font-size: 16px;
        }

        header {
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            color: white;
            padding: var(--spacing-xl) var(--spacing-md);
            margin-bottom: var(--spacing-xl);
            box-shadow: var(--box-shadow);
        }

        .header-content {
            max-width: 900px;
            margin: 0 auto;
        }

        h1 {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: var(--spacing-sm);
            line-height: 1.2;
        }

        .subtitle {
            font-size: 1.1rem;
            opacity: 0.95;
            font-weight: 400;
            margin-bottom: var(--spacing-md);
        }

        .meta {
            display: flex;
            flex-wrap: wrap;
            gap: var(--spacing-md);
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .meta-item {
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 0 var(--spacing-md) var(--spacing-xl);
        }

        h2 {
            font-size: 1.75rem;
            color: var(--color-primary);
            margin-top: var(--spacing-xl);
            margin-bottom: var(--spacing-md);
            padding-bottom: var(--spacing-xs);
            border-bottom: 3px solid var(--color-accent);
        }

        h3 {
            font-size: 1.4rem;
            color: var(--color-primary);
            margin-top: var(--spacing-lg);
            margin-bottom: var(--spacing-sm);
        }

        h4 {
            font-size: 1.1rem;
            color: var(--color-primary-dark);
            margin-top: var(--spacing-md);
            margin-bottom: var(--spacing-sm);
        }

        p {
            margin-bottom: var(--spacing-md);
            color: var(--color-text);
        }

        a {
            color: var(--color-link);
            text-decoration: none;
            transition: color 0.2s;
        }

        a:hover {
            color: var(--color-link-hover);
            text-decoration: underline;
        }

        ul, ol {
            margin-left: var(--spacing-lg);
            margin-bottom: var(--spacing-md);
        }

        li {
            margin-bottom: var(--spacing-xs);
            color: var(--color-text);
        }

        pre {
            background-color: var(--color-code-bg);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            overflow-x: auto;
            margin-bottom: var(--spacing-md);
            font-family: var(--font-mono);
            font-size: 0.9rem;
            line-height: 1.5;
        }

        code {
            font-family: var(--font-mono);
            font-size: 0.9em;
            background-color: var(--color-code-bg);
            padding: 0.2em 0.4em;
            border-radius: 3px;
        }

        pre code {
            background-color: transparent;
            padding: 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: var(--spacing-md);
            font-size: 0.95rem;
        }

        th, td {
            border: 1px solid var(--color-border);
            padding: var(--spacing-sm);
            text-align: left;
        }

        th {
            background-color: var(--color-bg-alt);
            font-weight: 600;
            color: var(--color-primary);
        }

        blockquote {
            border-left: 4px solid var(--color-accent);
            padding-left: var(--spacing-md);
            margin: var(--spacing-md) 0;
            color: var(--color-text-light);
            font-style: italic;
            background-color: var(--color-bg-alt);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        .mermaid {
            text-align: center;
            margin: var(--spacing-lg) 0;
            background-color: var(--color-bg-alt);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        details {
            background-color: var(--color-bg-alt);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            margin-bottom: var(--spacing-md);
        }

        summary {
            cursor: pointer;
            font-weight: 600;
            color: var(--color-primary);
            user-select: none;
            padding: var(--spacing-xs);
            margin: calc(-1 * var(--spacing-md));
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        summary:hover {
            background-color: rgba(123, 44, 191, 0.1);
        }

        details[open] summary {
            margin-bottom: var(--spacing-md);
            border-bottom: 1px solid var(--color-border);
        }

        .navigation {
            display: flex;
            justify-content: space-between;
            gap: var(--spacing-md);
            margin: var(--spacing-xl) 0;
            padding-top: var(--spacing-lg);
            border-top: 2px solid var(--color-border);
        }

        .nav-button {
            flex: 1;
            padding: var(--spacing-md);
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            color: white;
            border-radius: var(--border-radius);
            text-align: center;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: var(--box-shadow);
        }

        .nav-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            text-decoration: none;
        }

        footer {
            margin-top: var(--spacing-xl);
            padding: var(--spacing-lg) var(--spacing-md);
            background-color: var(--color-bg-alt);
            border-top: 1px solid var(--color-border);
            text-align: center;
            font-size: 0.9rem;
            color: var(--color-text-light);
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.5rem;
            }

            h2 {
                font-size: 1.4rem;
            }

            h3 {
                font-size: 1.2rem;
            }

            .meta {
                font-size: 0.85rem;
            }

            .navigation {
                flex-direction: column;
            }

            table {
                font-size: 0.85rem;
            }

            th, td {
                padding: var(--spacing-xs);
            }
        }
    </style>

    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ startOnLoad: true, theme: 'default' });
    </script>

    <!-- MathJax for LaTeX equation rendering -->
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true,
                processEnvironments: true
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
                ignoreHtmlClass: 'mermaid'
            }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" id="MathJax-script" async></script>
</head>
<body>
    <header>
        <div class="header-content">
            <h1>第1章：AutoML基礎</h1>
            <p class="subtitle">機械学習の民主化 - AutoMLの概念と構成要素</p>
            <div class="meta">
                <span class="meta-item">📖 読了時間: 25-30分</span>
                <span class="meta-item">📊 難易度: 初級</span>
                <span class="meta-item">💻 コード例: 7個</span>
                <span class="meta-item">📝 演習問題: 5問</span>
            </div>
        </div>
    </header>

    <main class="container">

<h2>学習目標</h2>
<p>この章を読むことで、以下を習得できます：</p>
<ul>
<li>✅ AutoMLの概念と目的を理解する</li>
<li>✅ 従来のMLワークフローとの違いを説明できる</li>
<li>✅ AutoMLの構成要素とその役割を把握する</li>
<li>✅ Neural Architecture Search（NAS）の基本を理解する</li>
<li>✅ Meta-Learningの概念と応用を学ぶ</li>
<li>✅ AutoMLの評価方法を習得する</li>
</ul>

<hr>

<h2>1.1 AutoMLとは</h2>

<h3>機械学習の民主化</h3>
<p><strong>AutoML（Automated Machine Learning）</strong>は、機械学習モデルの開発プロセスを自動化する技術です。データサイエンティストでなくても、高品質な機械学習モデルを構築できるようにすることを目指しています。</p>

<blockquote>
<p>「AutoMLは機械学習の民主化を実現し、より多くの人々がAI技術を活用できるようにする」</p>
</blockquote>

<h3>AutoMLの目的</h3>

<table>
<thead>
<tr>
<th>目的</th>
<th>説明</th>
<th>効果</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>効率化</strong></td>
<td>手作業のプロセスを自動化</td>
<td>開発時間を短縮</td>
</tr>
<tr>
<td><strong>専門知識の軽減</strong></td>
<td>機械学習の深い知識が不要に</td>
<td>参入障壁を下げる</td>
</tr>
<tr>
<td><strong>性能向上</strong></td>
<td>体系的な探索で最適解を発見</td>
<td>人間のバイアスを排除</td>
</tr>
<tr>
<td><strong>再現性</strong></td>
<td>標準化されたプロセス</td>
<td>結果の信頼性向上</td>
</tr>
</tbody>
</table>

<h3>従来のMLワークフローとの比較</h3>

<div class="mermaid">
graph TD
    subgraph "従来のワークフロー"
    A1[データ収集] --> B1[手動前処理]
    B1 --> C1[特徴量エンジニアリング]
    C1 --> D1[モデル選択]
    D1 --> E1[ハイパーパラメータ調整]
    E1 --> F1[評価]
    F1 -->|試行錯誤| C1
    end

    subgraph "AutoMLワークフロー"
    A2[データ収集] --> B2[自動前処理]
    B2 --> C2[自動特徴量生成]
    C2 --> D2[自動モデル選択]
    D2 --> E2[自動ハイパーパラメータ最適化]
    E2 --> F2[評価]
    end

    style A1 fill:#ffebee
    style A2 fill:#ffebee
    style B1 fill:#fff3e0
    style B2 fill:#e8f5e9
    style C1 fill:#f3e5f5
    style C2 fill:#e8f5e9
    style D1 fill:#e3f2fd
    style D2 fill:#e8f5e9
    style E1 fill:#fce4ec
    style E2 fill:#e8f5e9
</div>

<h3>AutoMLのメリット・デメリット</h3>

<h4>メリット</h4>
<ul>
<li><strong>時間短縮</strong>: 数週間かかる作業を数時間に短縮</li>
<li><strong>アクセシビリティ</strong>: 専門知識が少ない人でも利用可能</li>
<li><strong>最適化</strong>: 人間が見落とす組み合わせを発見</li>
<li><strong>ベストプラクティス</strong>: 自動的に適用される</li>
</ul>

<h4>デメリット</h4>
<ul>
<li><strong>計算コスト</strong>: 大規模な探索には多くのリソースが必要</li>
<li><strong>ブラックボックス化</strong>: プロセスの透明性が低下</li>
<li><strong>柔軟性の制約</strong>: カスタマイズが困難な場合がある</li>
<li><strong>ドメイン知識の軽視</strong>: データの背景知識が活かせない</li>
</ul>

<h3>実例：AutoMLの効果</h3>

<pre><code class="language-python">import numpy as np
import pandas as pd
from sklearn.datasets import load_breast_cancer
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score
import time

# データ準備
data = load_breast_cancer()
X, y = data.data, data.target
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, random_state=42
)

# 従来の手法（固定パラメータ）
start_time = time.time()
model_manual = RandomForestClassifier(n_estimators=100, random_state=42)
model_manual.fit(X_train, y_train)
y_pred_manual = model_manual.predict(X_test)
acc_manual = accuracy_score(y_test, y_pred_manual)
time_manual = time.time() - start_time

# AutoML風の簡易実装（グリッドサーチ）
from sklearn.model_selection import GridSearchCV

start_time = time.time()
param_grid = {
    'n_estimators': [50, 100, 200],
    'max_depth': [None, 10, 20, 30],
    'min_samples_split': [2, 5, 10]
}
model_auto = GridSearchCV(
    RandomForestClassifier(random_state=42),
    param_grid,
    cv=3,
    n_jobs=-1
)
model_auto.fit(X_train, y_train)
y_pred_auto = model_auto.predict(X_test)
acc_auto = accuracy_score(y_test, y_pred_auto)
time_auto = time.time() - start_time

print("=== 従来手法 vs AutoML的手法 ===")
print(f"\n従来手法:")
print(f"  精度: {acc_manual:.4f}")
print(f"  時間: {time_manual:.2f}秒")

print(f"\nAutoML的手法:")
print(f"  精度: {acc_auto:.4f}")
print(f"  時間: {time_auto:.2f}秒")
print(f"  最適パラメータ: {model_auto.best_params_}")

print(f"\n改善:")
print(f"  精度向上: {(acc_auto - acc_manual) * 100:.2f}%")
</code></pre>

<p><strong>出力例</strong>：</p>
<pre><code>=== 従来手法 vs AutoML的手法 ===

従来手法:
  精度: 0.9649
  時間: 0.15秒

AutoML的手法:
  精度: 0.9737
  時間: 12.34秒
  最適パラメータ: {'max_depth': 20, 'min_samples_split': 2, 'n_estimators': 100}

改善:
  精度向上: 0.88%
</code></pre>

<hr>

<h2>1.2 AutoMLの構成要素</h2>

<p>AutoMLシステムは、機械学習パイプライン全体を自動化するために、複数の構成要素から成り立っています。</p>

<h3>データ前処理の自動化</h3>

<p>生データから学習可能な形式への変換を自動化します：</p>

<ul>
<li><strong>欠損値処理</strong>: 自動検出と補完戦略の選択</li>
<li><strong>外れ値検出</strong>: 統計的手法やIsolation Forestによる検出</li>
<li><strong>スケーリング</strong>: StandardScaler、MinMaxScalerの自動選択</li>
<li><strong>エンコーディング</strong>: カテゴリカル変数の自動変換</li>
</ul>

<pre><code class="language-python">import numpy as np
import pandas as pd
from sklearn.compose import ColumnTransformer
from sklearn.preprocessing import StandardScaler, OneHotEncoder
from sklearn.impute import SimpleImputer
from sklearn.pipeline import Pipeline

# サンプルデータ（欠損値を含む）
np.random.seed(42)
data = pd.DataFrame({
    'age': [25, 30, np.nan, 45, 50, 35],
    'salary': [50000, 60000, 55000, np.nan, 80000, 65000],
    'department': ['Sales', 'IT', 'HR', 'IT', 'Sales', np.nan]
})

print("=== 元のデータ ===")
print(data)

# 自動前処理パイプライン
numeric_features = ['age', 'salary']
categorical_features = ['department']

numeric_transformer = Pipeline(steps=[
    ('imputer', SimpleImputer(strategy='median')),
    ('scaler', StandardScaler())
])

categorical_transformer = Pipeline(steps=[
    ('imputer', SimpleImputer(strategy='most_frequent')),
    ('encoder', OneHotEncoder(handle_unknown='ignore'))
])

preprocessor = ColumnTransformer(
    transformers=[
        ('num', numeric_transformer, numeric_features),
        ('cat', categorical_transformer, categorical_features)
    ])

# 前処理の実行
data_transformed = preprocessor.fit_transform(data)

print("\n=== 前処理後のデータ形状 ===")
print(f"形状: {data_transformed.shape}")
print(f"欠損値: 0（すべて処理済み）")
</code></pre>

<h3>特徴量エンジニアリング</h3>

<p>新しい特徴量を自動生成します：</p>

<ul>
<li><strong>多項式特徴量</strong>: 既存特徴量の組み合わせ</li>
<li><strong>集約特徴量</strong>: グループごとの統計量</li>
<li><strong>時系列特徴量</strong>: ラグ、移動平均、季節性</li>
<li><strong>テキスト特徴量</strong>: TF-IDF、埋め込み表現</li>
</ul>

<pre><code class="language-python">from sklearn.preprocessing import PolynomialFeatures
from sklearn.datasets import make_regression
import matplotlib.pyplot as plt

# サンプルデータ
X, y = make_regression(n_samples=100, n_features=2, noise=10, random_state=42)

# 多項式特徴量の生成
poly = PolynomialFeatures(degree=2, include_bias=False)
X_poly = poly.fit_transform(X)

print("=== 特徴量エンジニアリング ===")
print(f"元の特徴量数: {X.shape[1]}")
print(f"生成後の特徴量数: {X_poly.shape[1]}")
print(f"\n生成された特徴量:")
print(poly.get_feature_names_out(['x1', 'x2']))

# 性能比較
from sklearn.linear_model import LinearRegression
from sklearn.metrics import r2_score

# 元の特徴量
model_original = LinearRegression()
model_original.fit(X, y)
y_pred_original = model_original.predict(X)
r2_original = r2_score(y, y_pred_original)

# 多項式特徴量
model_poly = LinearRegression()
model_poly.fit(X_poly, y)
y_pred_poly = model_poly.predict(X_poly)
r2_poly = r2_score(y, y_pred_poly)

print(f"\n=== 性能比較 ===")
print(f"元の特徴量のR²: {r2_original:.4f}")
print(f"多項式特徴量のR²: {r2_poly:.4f}")
print(f"改善: {(r2_poly - r2_original) * 100:.2f}%")
</code></pre>

<h3>モデル選択</h3>

<p>タスクとデータに最適なアルゴリズムを自動選択します：</p>

<ul>
<li><strong>線形モデル</strong>: Logistic Regression, Ridge, Lasso</li>
<li><strong>ツリーベース</strong>: Decision Tree, Random Forest, XGBoost</li>
<li><strong>サポートベクターマシン</strong>: SVC, SVR</li>
<li><strong>ニューラルネットワーク</strong>: MLP, CNN, RNN</li>
</ul>

<pre><code class="language-python">from sklearn.datasets import load_iris
from sklearn.model_selection import cross_val_score
from sklearn.linear_model import LogisticRegression
from sklearn.tree import DecisionTreeClassifier
from sklearn.ensemble import RandomForestClassifier
from sklearn.svm import SVC
from sklearn.neighbors import KNeighborsClassifier

# データ準備
iris = load_iris()
X, y = iris.data, iris.target

# 複数のモデルを評価
models = {
    'Logistic Regression': LogisticRegression(max_iter=1000),
    'Decision Tree': DecisionTreeClassifier(),
    'Random Forest': RandomForestClassifier(),
    'SVM': SVC(),
    'KNN': KNeighborsClassifier()
}

print("=== 自動モデル選択 ===")
results = {}
for name, model in models.items():
    scores = cross_val_score(model, X, y, cv=5, scoring='accuracy')
    results[name] = scores.mean()
    print(f"{name:20s}: {scores.mean():.4f} (+/- {scores.std():.4f})")

# 最良モデルの選択
best_model = max(results, key=results.get)
print(f"\n最良モデル: {best_model} (精度: {results[best_model]:.4f})")
</code></pre>

<h3>ハイパーパラメータ最適化</h3>

<p>モデルのパラメータを自動調整します：</p>

<ul>
<li><strong>グリッドサーチ</strong>: 全組み合わせを探索</li>
<li><strong>ランダムサーチ</strong>: ランダムサンプリング</li>
<li><strong>ベイズ最適化</strong>: 効率的な探索</li>
<li><strong>進化的アルゴリズム</strong>: 遺伝的アルゴリズム</li>
</ul>

<pre><code class="language-python">from sklearn.model_selection import RandomizedSearchCV
from scipy.stats import randint, uniform

# データ準備
X, y = load_breast_cancer(return_X_y=True)
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, random_state=42
)

# ハイパーパラメータ探索空間
param_distributions = {
    'n_estimators': randint(50, 500),
    'max_depth': [None] + list(range(5, 50, 5)),
    'min_samples_split': randint(2, 20),
    'min_samples_leaf': randint(1, 10),
    'max_features': uniform(0.1, 0.9)
}

# ランダムサーチ
random_search = RandomizedSearchCV(
    RandomForestClassifier(random_state=42),
    param_distributions=param_distributions,
    n_iter=50,
    cv=3,
    random_state=42,
    n_jobs=-1,
    verbose=0
)

print("=== ハイパーパラメータ最適化 ===")
random_search.fit(X_train, y_train)

print(f"最良スコア (CV): {random_search.best_score_:.4f}")
print(f"最良パラメータ:")
for param, value in random_search.best_params_.items():
    print(f"  {param}: {value}")

# テストセットでの評価
test_score = random_search.score(X_test, y_test)
print(f"\nテストセット精度: {test_score:.4f}")
</code></pre>

<h3>AutoMLワークフロー図</h3>

<div class="mermaid">
graph TD
    A[生データ] --> B[データ前処理の自動化]
    B --> C[特徴量エンジニアリング]
    C --> D[モデル選択]
    D --> E[ハイパーパラメータ最適化]
    E --> F[アンサンブル]
    F --> G[最終モデル]

    B --> B1[欠損値処理]
    B --> B2[外れ値検出]
    B --> B3[スケーリング]

    C --> C1[多項式特徴量]
    C --> C2[集約特徴量]
    C --> C3[特徴選択]

    D --> D1[線形モデル]
    D --> D2[ツリーベース]
    D --> D3[ニューラルネット]

    E --> E1[グリッドサーチ]
    E --> E2[ベイズ最適化]
    E --> E3[進化的手法]

    style A fill:#ffebee
    style B fill:#fff3e0
    style C fill:#f3e5f5
    style D fill:#e3f2fd
    style E fill:#fce4ec
    style F fill:#e8f5e9
    style G fill:#c8e6c9
</div>

<hr>

<h2>1.3 Neural Architecture Search (NAS)</h2>

<h3>NASの概念</h3>

<p><strong>Neural Architecture Search（NAS）</strong>は、ニューラルネットワークのアーキテクチャを自動的に設計する技術です。人間が手作業で設計していたネットワーク構造を、アルゴリズムが自動的に探索します。</p>

<blockquote>
<p>NASは「ニューラルネットワークを設計するニューラルネットワーク」とも言えます</p>
</blockquote>

<h3>探索空間</h3>

<p>NASが探索する設計要素：</p>

<ul>
<li><strong>層の種類</strong>: 畳み込み層、全結合層、プーリング層など</li>
<li><strong>層の数</strong>: ネットワークの深さ</li>
<li><strong>層のパラメータ</strong>: フィルタ数、カーネルサイズ、ストライドなど</li>
<li><strong>接続パターン</strong>: スキップ接続、残差接続など</li>
<li><strong>活性化関数</strong>: ReLU、Sigmoid、Tanhなど</li>
</ul>

<h3>探索戦略</h3>

<h4>1. ランダムサーチ</h4>
<p>アーキテクチャをランダムにサンプリングして評価します。シンプルですが、効率は低いです。</p>

<h4>2. 強化学習ベース</h4>
<p>コントローラ（RNN）がアーキテクチャを生成し、その性能を報酬として学習します。</p>

<p>報酬関数：</p>
<p>$$
R = \text{Accuracy} - \lambda \cdot \text{Complexity}
$$</p>

<ul>
<li>$\text{Accuracy}$: 検証精度</li>
<li>$\text{Complexity}$: モデルの複雑さ（パラメータ数など）</li>
<li>$\lambda$: 複雑さのペナルティ係数</li>
</ul>

<h4>3. 進化的アルゴリズム</h4>
<p>遺伝的アルゴリズムを用いて、優れたアーキテクチャを進化させます。</p>

<ul>
<li><strong>突然変異</strong>: 層の追加・削除、パラメータ変更</li>
<li><strong>交叉</strong>: 2つのアーキテクチャの組み合わせ</li>
<li><strong>選択</strong>: 性能の高いアーキテクチャを残す</li>
</ul>

<h4>4. 勾配ベース手法（DARTS）</h4>
<p>探索空間を連続緩和し、勾配降下法で最適化します。計算効率が高いです。</p>

<h3>NAS実装例（簡易版）</h3>

<pre><code class="language-python">import numpy as np
from sklearn.datasets import load_digits
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score
from sklearn.neural_network import MLPClassifier

# データ準備
digits = load_digits()
X_train, X_test, y_train, y_test = train_test_split(
    digits.data, digits.target, test_size=0.2, random_state=42
)

# 簡易NAS: ランダムサーチでアーキテクチャを探索
def random_architecture_search(n_trials=10):
    best_score = 0
    best_architecture = None

    print("=== Neural Architecture Search ===")
    for i in range(n_trials):
        # ランダムにアーキテクチャを生成
        n_layers = np.random.randint(1, 4)  # 1-3層
        hidden_layer_sizes = tuple(
            np.random.choice([32, 64, 128, 256]) for _ in range(n_layers)
        )
        activation = np.random.choice(['relu', 'tanh', 'logistic'])

        # モデルの訓練と評価
        model = MLPClassifier(
            hidden_layer_sizes=hidden_layer_sizes,
            activation=activation,
            max_iter=100,
            random_state=42
        )
        model.fit(X_train, y_train)
        score = model.score(X_test, y_test)

        print(f"Trial {i+1}: layers={hidden_layer_sizes}, "
              f"activation={activation}, score={score:.4f}")

        if score > best_score:
            best_score = score
            best_architecture = {
                'hidden_layer_sizes': hidden_layer_sizes,
                'activation': activation,
                'score': score
            }

    return best_architecture

# NASの実行
best_arch = random_architecture_search(n_trials=10)

print(f"\n=== 最良アーキテクチャ ===")
print(f"層構成: {best_arch['hidden_layer_sizes']}")
print(f"活性化関数: {best_arch['activation']}")
print(f"精度: {best_arch['score']:.4f}")
</code></pre>

<h3>NASの課題</h3>

<table>
<thead>
<tr>
<th>課題</th>
<th>説明</th>
<th>対策</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>計算コスト</strong></td>
<td>数千のアーキテクチャを評価</td>
<td>早期停止、プロキシタスク使用</td>
</tr>
<tr>
<td><strong>探索空間の広さ</strong></td>
<td>組み合わせ爆発</td>
<td>探索空間の制約、階層的探索</td>
</tr>
<tr>
<td><strong>転移性の欠如</strong></td>
<td>タスクごとに探索が必要</td>
<td>転移学習、メタラーニング活用</td>
</tr>
<tr>
<td><strong>過学習</strong></td>
<td>検証データへの過適合</td>
<td>正則化、複数データセット使用</td>
</tr>
</tbody>
</table>

<hr>

<h2>1.4 Meta-Learning</h2>

<h3>Learning to Learn</h3>

<p><strong>Meta-Learning（メタ学習）</strong>は、「学習の仕方を学習する」手法です。過去のタスクでの経験を活用して、新しいタスクを効率的に学習します。</p>

<blockquote>
<p>「学習アルゴリズム自体を学習する」- メタ学習の本質</p>
</blockquote>

<h3>Few-shot Learning</h3>

<p>少数のサンプルから効率的に学習する手法です。</p>

<p><strong>N-way K-shot学習</strong>：</p>
<ul>
<li>N: クラス数</li>
<li>K: 各クラスのサンプル数</li>
<li>例: 5-way 1-shot = 5クラス、各1サンプル</li>
</ul>

<pre><code class="language-python">import numpy as np
from sklearn.neighbors import KNeighborsClassifier
from sklearn.datasets import load_digits
from sklearn.model_selection import train_test_split

# Few-shot学習のシミュレーション
def few_shot_learning_demo(n_way=5, k_shot=3):
    # データ準備
    digits = load_digits()
    X, y = digits.data, digits.target

    # タスクの選択（n_wayクラス）
    selected_classes = np.random.choice(10, n_way, replace=False)

    # サポートセット（学習用: k_shot × n_way サンプル）
    support_X, support_y = [], []
    # クエリセット（テスト用）
    query_X, query_y = [], []

    for cls in selected_classes:
        cls_indices = np.where(y == cls)[0]
        selected = np.random.choice(cls_indices, k_shot + 10, replace=False)

        # k_shotサンプルをサポートセットに
        support_X.extend(X[selected[:k_shot]])
        support_y.extend([cls] * k_shot)

        # 残りをクエリセットに
        query_X.extend(X[selected[k_shot:]])
        query_y.extend([cls] * 10)

    support_X = np.array(support_X)
    support_y = np.array(support_y)
    query_X = np.array(query_X)
    query_y = np.array(query_y)

    # Few-shot学習（KNN使用）
    model = KNeighborsClassifier(n_neighbors=min(3, k_shot))
    model.fit(support_X, support_y)

    # 評価
    accuracy = model.score(query_X, query_y)

    print(f"=== {n_way}-way {k_shot}-shot学習 ===")
    print(f"サポートセット: {len(support_X)}サンプル")
    print(f"クエリセット: {len(query_X)}サンプル")
    print(f"精度: {accuracy:.4f}")

    return accuracy

# 異なる設定で実験
for k in [1, 3, 5]:
    few_shot_learning_demo(n_way=5, k_shot=k)
    print()
</code></pre>

<h3>Transfer Learning</h3>

<p>ある タスクで学習した知識を別のタスクに転移させます。</p>

<ul>
<li><strong>事前学習済みモデル</strong>: ImageNet等で学習したモデルを利用</li>
<li><strong>ファインチューニング</strong>: 新しいタスクで調整</li>
<li><strong>ドメイン適応</strong>: ドメイン間の差を縮小</li>
</ul>

<h3>Warm-starting</h3>

<p>過去のタスクでの最適パラメータを初期値として使用し、新しいタスクの学習を高速化します。</p>

<pre><code class="language-python">from sklearn.linear_model import SGDClassifier
from sklearn.datasets import make_classification

# タスク1とタスク2（類似したタスク）
X1, y1 = make_classification(n_samples=1000, n_features=20,
                             n_informative=15, random_state=42)
X2, y2 = make_classification(n_samples=1000, n_features=20,
                             n_informative=15, random_state=43)

print("=== Warm-starting効果の検証 ===")

# コールドスタート（タスク2を最初から学習）
model_cold = SGDClassifier(max_iter=100, random_state=42)
model_cold.fit(X2[:100], y2[:100])  # 少ないデータで学習
score_cold = model_cold.score(X2[100:], y2[100:])

# ウォームスタート（タスク1で事前学習）
model_warm = SGDClassifier(max_iter=100, random_state=42)
model_warm.fit(X1, y1)  # タスク1で学習
model_warm.partial_fit(X2[:100], y2[:100])  # タスク2で追加学習
score_warm = model_warm.score(X2[100:], y2[100:])

print(f"コールドスタート精度: {score_cold:.4f}")
print(f"ウォームスタート精度: {score_warm:.4f}")
print(f"改善: {(score_warm - score_cold) * 100:.2f}%")
</code></pre>

<hr>

<h2>1.5 AutoMLの評価</h2>

<h3>Performance Metrics</h3>

<p>AutoMLシステムの性能を評価する指標：</p>

<table>
<thead>
<tr>
<th>指標</th>
<th>説明</th>
<th>重要性</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>予測精度</strong></td>
<td>モデルの予測性能</td>
<td>最も重要</td>
</tr>
<tr>
<td><strong>探索時間</strong></td>
<td>最適モデルを見つけるまでの時間</td>
<td>実用上重要</td>
</tr>
<tr>
<td><strong>計算コスト</strong></td>
<td>必要なリソース（CPU、GPU、メモリ）</td>
<td>スケーラビリティ</td>
</tr>
<tr>
<td><strong>ロバスト性</strong></td>
<td>異なるデータセットでの安定性</td>
<td>汎用性</td>
</tr>
</tbody>
</table>

<h3>計算コスト</h3>

<p>AutoMLの計算コストを定量化：</p>

<p>$$
\text{Total Cost} = \sum_{i=1}^{n} C_i \times T_i
$$</p>

<ul>
<li>$C_i$: i番目のモデルの計算コスト（FLOPS等）</li>
<li>$T_i$: i番目のモデルの訓練時間</li>
<li>$n$: 評価したモデルの総数</li>
</ul>

<h3>再現性</h3>

<p>同じ入力で同じ結果が得られるか：</p>

<ul>
<li><strong>乱数シード固定</strong>: 再現可能な実験</li>
<li><strong>パイプラインの保存</strong>: 学習済みモデルと前処理の保存</li>
<li><strong>バージョン管理</strong>: ライブラリバージョンの記録</li>
</ul>

<h3>解釈可能性</h3>

<p>AutoMLの決定プロセスを理解する：</p>

<ul>
<li><strong>特徴量重要度</strong>: どの特徴量が重要か</li>
<li><strong>モデル選択理由</strong>: なぜそのモデルが選ばれたか</li>
<li><strong>ハイパーパラメータの影響</strong>: 各パラメータの寄与度</li>
</ul>

<pre><code class="language-python">from sklearn.ensemble import RandomForestClassifier
from sklearn.inspection import permutation_importance
import matplotlib.pyplot as plt

# データ準備
iris = load_iris()
X, y = iris.data, iris.target
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, random_state=42
)

# モデル訓練
model = RandomForestClassifier(n_estimators=100, random_state=42)
model.fit(X_train, y_train)

# 特徴量重要度
feature_importance = model.feature_importances_
feature_names = iris.feature_names

# Permutation Importance
perm_importance = permutation_importance(
    model, X_test, y_test, n_repeats=10, random_state=42
)

# 可視化
fig, axes = plt.subplots(1, 2, figsize=(14, 5))

# 特徴量重要度
axes[0].barh(feature_names, feature_importance)
axes[0].set_xlabel('重要度')
axes[0].set_title('特徴量重要度（Gini）')
axes[0].grid(True, alpha=0.3)

# Permutation Importance
axes[1].barh(feature_names, perm_importance.importances_mean)
axes[1].set_xlabel('重要度')
axes[1].set_title('Permutation Importance')
axes[1].grid(True, alpha=0.3)

plt.tight_layout()
plt.show()

print("=== 解釈可能性分析 ===")
for name, importance in zip(feature_names, feature_importance):
    print(f"{name:20s}: {importance:.4f}")
</code></pre>

<hr>

<h2>1.6 本章のまとめ</h2>

<h3>学んだこと</h3>

<ol>
<li><p><strong>AutoMLの概念</strong></p>
<ul>
<li>機械学習の民主化を実現</li>
<li>効率化と専門知識の軽減</li>
<li>従来手法との違いと利点</li>
</ul></li>

<li><p><strong>AutoMLの構成要素</strong></p>
<ul>
<li>データ前処理の自動化</li>
<li>特徴量エンジニアリング</li>
<li>モデル選択とハイパーパラメータ最適化</li>
</ul></li>

<li><p><strong>Neural Architecture Search</strong></p>
<ul>
<li>ネットワーク構造の自動設計</li>
<li>探索戦略（RL、進化的、勾配ベース）</li>
<li>計算コストとの戦い</li>
</ul></li>

<li><p><strong>Meta-Learning</strong></p>
<ul>
<li>学習の仕方を学習</li>
<li>Few-shot learning、Transfer learning</li>
<li>Warm-startingによる高速化</li>
</ul></li>

<li><p><strong>AutoMLの評価</strong></p>
<ul>
<li>性能指標（精度、時間、コスト）</li>
<li>再現性と解釈可能性の重要性</li>
</ul></li>
</ol>

<h3>AutoMLの原則</h3>

<table>
<thead>
<tr>
<th>原則</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>自動化と透明性のバランス</strong></td>
<td>ブラックボックス化を避け、解釈可能性を維持</td>
</tr>
<tr>
<td><strong>効率性</strong></td>
<td>計算リソースを考慮した探索戦略</td>
</tr>
<tr>
<td><strong>汎用性</strong></td>
<td>様々なタスクとデータに適用可能</td>
</tr>
<tr>
<td><strong>ドメイン知識の活用</strong></td>
<td>自動化と専門知識の組み合わせ</td>
</tr>
<tr>
<td><strong>継続的改善</strong></td>
<td>メタ学習による学習効率の向上</td>
</tr>
</tbody>
</table>

<h3>次の章へ</h3>

<p>第2章では、<strong>AutoMLツールとフレームワーク</strong>を学びます：</p>
<ul>
<li>Auto-sklearn</li>
<li>TPOT</li>
<li>H2O AutoML</li>
<li>Google Cloud AutoML</li>
<li>AutoKeras</li>
</ul>

<hr>

<h2>演習問題</h2>

<h3>問題1（難易度：easy）</h3>
<p>AutoMLの主な目的を3つ挙げ、それぞれを説明してください。</p>

<details>
<summary>解答例</summary>

<p><strong>解答</strong>：</p>

<ol>
<li><p><strong>効率化</strong></p>
<ul>
<li>説明: 手作業で行っていたモデル開発プロセスを自動化し、開発時間を大幅に短縮する</li>
<li>効果: 数週間かかる作業を数時間に短縮可能</li>
</ul></li>

<li><p><strong>専門知識の軽減</strong></p>
<ul>
<li>説明: 機械学習の深い専門知識がなくても、高品質なモデルを構築できるようにする</li>
<li>効果: より多くの人々がAI技術を活用可能になる（民主化）</li>
</ul></li>

<li><p><strong>性能向上</strong></p>
<ul>
<li>説明: 体系的な探索により、人間が見落としがちな最適な組み合わせを発見する</li>
<li>効果: 人間のバイアスを排除し、客観的に最良のモデルを見つける</li>
</ul></li>
</ol>

</details>

<h3>問題2（難易度：medium）</h3>
<p>Neural Architecture Search（NAS）の4つの探索戦略を説明し、それぞれの長所と短所を述べてください。</p>

<details>
<summary>解答例</summary>

<p><strong>解答</strong>：</p>

<table>
<thead>
<tr>
<th>探索戦略</th>
<th>説明</th>
<th>長所</th>
<th>短所</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>ランダムサーチ</strong></td>
<td>アーキテクチャをランダムにサンプリング</td>
<td>実装が簡単、並列化が容易</td>
<td>効率が低い、大規模探索に不向き</td>
</tr>
<tr>
<td><strong>強化学習ベース</strong></td>
<td>RNNコントローラがアーキテクチャを生成</td>
<td>有望な領域を効率的に探索</td>
<td>計算コストが高い、安定性に課題</td>
</tr>
<tr>
<td><strong>進化的アルゴリズム</strong></td>
<td>遺伝的操作で優れたアーキテクチャを進化</td>
<td>多様性を保持、局所最適を回避</td>
<td>収束が遅い、大規模な集団が必要</td>
</tr>
<tr>
<td><strong>勾配ベース（DARTS）</strong></td>
<td>探索空間を連続緩和し勾配降下法で最適化</td>
<td>計算効率が高い、高速</td>
<td>離散化誤差、探索空間に制約</td>
</tr>
</tbody>
</table>

</details>

<h3>問題3（難易度：medium）</h3>
<p>Few-shot learningにおける「5-way 3-shot学習」とは何を意味するか説明し、この設定での学習サンプル数を計算してください。</p>

<details>
<summary>解答例</summary>

<p><strong>解答</strong>：</p>

<p><strong>「5-way 3-shot学習」の意味</strong>：</p>
<ul>
<li><strong>5-way</strong>: 5つのクラスを分類するタスク</li>
<li><strong>3-shot</strong>: 各クラスにつき3個のサンプルのみを学習に使用</li>
</ul>

<p><strong>学習サンプル数</strong>：</p>
<p>$$
\text{サンプル数} = \text{クラス数} \times \text{各クラスのサンプル数} = 5 \times 3 = 15
$$</p>

<p>つまり、わずか15サンプルで5クラス分類を学習します。</p>

<p><strong>具体例</strong>：</p>
<ul>
<li>5種類の動物（犬、猫、鳥、魚、馬）を分類</li>
<li>各動物の画像を3枚ずつ（合計15枚）だけ学習に使用</li>
<li>新しい動物の画像を正しく分類できるようになる</li>
</ul>

</details>

<h3>問題4（難易度：hard）</h3>
<p>以下のコードを完成させて、簡易的なAutoMLシステムを実装してください。データ前処理、モデル選択、ハイパーパラメータ最適化を含めること。</p>

<pre><code class="language-python">from sklearn.datasets import load_breast_cancer
from sklearn.model_selection import train_test_split

# データ準備
X, y = load_breast_cancer(return_X_y=True)
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, random_state=42
)

# ここにAutoMLシステムを実装
# TODO: 前処理パイプライン、モデル選択、ハイパーパラメータ最適化
</code></pre>

<details>
<summary>解答例</summary>

<pre><code class="language-python">from sklearn.datasets import load_breast_cancer
from sklearn.model_selection import train_test_split, GridSearchCV
from sklearn.preprocessing import StandardScaler
from sklearn.pipeline import Pipeline
from sklearn.ensemble import RandomForestClassifier
from sklearn.linear_model import LogisticRegression
from sklearn.svm import SVC
import numpy as np

# データ準備
X, y = load_breast_cancer(return_X_y=True)
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, random_state=42
)

print("=== 簡易AutoMLシステム ===\n")

# ステップ1: モデル候補とハイパーパラメータ空間の定義
models = {
    'Logistic Regression': {
        'model': LogisticRegression(max_iter=1000),
        'params': {
            'classifier__C': [0.1, 1.0, 10.0],
            'classifier__penalty': ['l2']
        }
    },
    'Random Forest': {
        'model': RandomForestClassifier(random_state=42),
        'params': {
            'classifier__n_estimators': [50, 100, 200],
            'classifier__max_depth': [None, 10, 20],
            'classifier__min_samples_split': [2, 5]
        }
    },
    'SVM': {
        'model': SVC(),
        'params': {
            'classifier__C': [0.1, 1.0, 10.0],
            'classifier__kernel': ['rbf', 'linear']
        }
    }
}

# ステップ2: 各モデルで前処理パイプライン + ハイパーパラメータ最適化
best_overall_score = 0
best_overall_model = None
best_overall_name = None

for name, config in models.items():
    print(f"--- {name} ---")

    # パイプライン構築（前処理 + モデル）
    pipeline = Pipeline([
        ('scaler', StandardScaler()),
        ('classifier', config['model'])
    ])

    # グリッドサーチでハイパーパラメータ最適化
    grid_search = GridSearchCV(
        pipeline,
        param_grid=config['params'],
        cv=5,
        scoring='accuracy',
        n_jobs=-1
    )

    grid_search.fit(X_train, y_train)

    # 結果
    cv_score = grid_search.best_score_
    test_score = grid_search.score(X_test, y_test)

    print(f"  最良CVスコア: {cv_score:.4f}")
    print(f"  テストスコア: {test_score:.4f}")
    print(f"  最良パラメータ: {grid_search.best_params_}")
    print()

    # 最良モデルの更新
    if cv_score > best_overall_score:
        best_overall_score = cv_score
        best_overall_model = grid_search.best_estimator_
        best_overall_name = name

# ステップ3: 最終結果
print("=" * 50)
print(f"最良モデル: {best_overall_name}")
print(f"CVスコア: {best_overall_score:.4f}")
print(f"テストスコア: {best_overall_model.score(X_test, y_test):.4f}")
print("=" * 50)
</code></pre>

<p><strong>出力例</strong>：</p>
<pre><code>=== 簡易AutoMLシステム ===

--- Logistic Regression ---
  最良CVスコア: 0.9780
  テストスコア: 0.9825
  最良パラメータ: {'classifier__C': 1.0, 'classifier__penalty': 'l2'}

--- Random Forest ---
  最良CVスコア: 0.9648
  テストスコア: 0.9649
  最良パラメータ: {'classifier__max_depth': None, ...}

--- SVM ---
  最良CVスコア: 0.9758
  テストスコア: 0.9737
  最良パラメータ: {'classifier__C': 1.0, 'classifier__kernel': 'linear'}

==================================================
最良モデル: Logistic Regression
CVスコア: 0.9780
テストスコア: 0.9825
==================================================
</code></pre>

</details>

<h3>問題5（難易度：hard）</h3>
<p>AutoMLにおける「計算コスト」と「予測精度」のトレードオフについて説明し、実用上どのようにバランスを取るべきか述べてください。</p>

<details>
<summary>解答例</summary>

<p><strong>解答</strong>：</p>

<p><strong>トレードオフの本質</strong>：</p>

<table>
<thead>
<tr>
<th>側面</th>
<th>高精度追求</th>
<th>低コスト追求</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>探索範囲</strong></td>
<td>広範囲の探索（数千モデル）</td>
<td>限定的な探索（数十モデル）</td>
</tr>
<tr>
<td><strong>時間</strong></td>
<td>数日〜数週間</td>
<td>数時間〜数日</td>
</tr>
<tr>
<td><strong>リソース</strong></td>
<td>大規模GPU/クラスタ</td>
<td>単一マシン</td>
</tr>
<tr>
<td><strong>精度向上</strong></td>
<td>+1-2%の改善</td>
<td>ベースライン達成</td>
</tr>
</tbody>
</table>

<p><strong>バランスを取る戦略</strong>：</p>

<ol>
<li><p><strong>段階的アプローチ</strong></p>
<ul>
<li>Phase 1: 高速探索で有望なモデル候補を絞り込み（数時間）</li>
<li>Phase 2: 候補に対して詳細な最適化（数日）</li>
</ul></li>

<li><p><strong>早期停止</strong></p>
<ul>
<li>検証精度が改善しなければ探索を打ち切り</li>
<li>計算予算（時間・コスト）の上限を設定</li>
</ul></li>

<li><p><strong>効率的な探索手法</strong></p>
<ul>
<li>ランダムサーチではなくベイズ最適化を使用</li>
<li>転移学習やメタ学習で初期状態を改善</li>
</ul></li>

<li><p><strong>タスクに応じた優先順位</strong></p>
<ul>
<li>本番システム: 精度優先（高コスト許容）</li>
<li>プロトタイプ: 速度優先（低コスト重視）</li>
<li>研究: 両方のバランス</li>
</ul></li>

<li><p><strong>多目的最適化</strong></p>
<ul>
<li>目的関数に計算コストを含める</li>
</ul></li>
</ol>

<p>$$
\text{Objective} = \alpha \cdot \text{Accuracy} - (1-\alpha) \cdot \log(\text{Cost})
$$</p>

<ul>
<li>$\alpha$: 精度とコストの重み（0〜1）</li>
</ul>

<p><strong>実用的な推奨</strong>：</p>
<ul>
<li>まず低コストで探索し、ベースライン性能を把握</li>
<li>ビジネス価値が高い場合のみ高コスト探索を実施</li>
<li>精度1%改善のコストと効果を定量的に評価</li>
</ul>

</details>

<hr>

<h2>参考文献</h2>

<ol>
<li>Hutter, F., Kotthoff, L., & Vanschoren, J. (Eds.). (2019). <em>Automated Machine Learning: Methods, Systems, Challenges</em>. Springer.</li>
<li>Elsken, T., Metzen, J. H., & Hutter, F. (2019). Neural Architecture Search: A Survey. <em>Journal of Machine Learning Research</em>, 20(55), 1-21.</li>
<li>Hospedales, T., Antoniou, A., Micaelli, P., & Storkey, A. (2021). Meta-Learning in Neural Networks: A Survey. <em>IEEE Transactions on Pattern Analysis and Machine Intelligence</em>.</li>
<li>Feurer, M., & Hutter, F. (2019). Hyperparameter Optimization. In <em>Automated Machine Learning</em> (pp. 3-33). Springer.</li>
<li>He, X., Zhao, K., & Chu, X. (2021). AutoML: A survey of the state-of-the-art. <em>Knowledge-Based Systems</em>, 212, 106622.</li>
</ol>

<div class="navigation">
    <a href="index.html" class="nav-button">← シリーズ目次</a>
    <a href="chapter2-automl-tools.html" class="nav-button">次の章: AutoMLツールとフレームワーク →</a>
</div>

    </main>

    <footer>
        <p><strong>作成者</strong>: AI Terakoya Content Team</p>
        <p><strong>監修</strong>: Dr. Yusuke Hashimoto（東北大学）</p>
        <p><strong>バージョン</strong>: 1.0 | <strong>作成日</strong>: 2025-10-21</p>
        <p><strong>ライセンス</strong>: Creative Commons BY 4.0</p>
        <p>© 2025 AI Terakoya. All rights reserved.</p>
    </footer>
</body>
</html>
