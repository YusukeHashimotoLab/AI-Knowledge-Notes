<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>第2章：Apache Sparkによる分散機械学習 - AI Terakoya</title>

    <style>
        :root {
            --color-primary: #2c3e50;
            --color-primary-dark: #1a252f;
            --color-accent: #7b2cbf;
            --color-accent-light: #9d4edd;
            --color-text: #2d3748;
            --color-text-light: #4a5568;
            --color-bg: #ffffff;
            --color-bg-alt: #f7fafc;
            --color-border: #e2e8f0;
            --color-code-bg: #f8f9fa;
            --color-link: #3182ce;
            --color-link-hover: #2c5aa0;

            --spacing-xs: 0.5rem;
            --spacing-sm: 1rem;
            --spacing-md: 1.5rem;
            --spacing-lg: 2rem;
            --spacing-xl: 3rem;

            --font-body: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            --font-mono: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;

            --border-radius: 8px;
            --box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-body);
            line-height: 1.7;
            color: var(--color-text);
            background-color: var(--color-bg);
            font-size: 16px;
        }

        header {
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            color: white;
            padding: var(--spacing-xl) var(--spacing-md);
            margin-bottom: var(--spacing-xl);
            box-shadow: var(--box-shadow);
        }

        .header-content {
            max-width: 900px;
            margin: 0 auto;
        }

        h1 {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: var(--spacing-sm);
            line-height: 1.2;
        }

        .subtitle {
            font-size: 1.1rem;
            opacity: 0.95;
            font-weight: 400;
            margin-bottom: var(--spacing-md);
        }

        .meta {
            display: flex;
            flex-wrap: wrap;
            gap: var(--spacing-md);
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .meta-item {
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 0 var(--spacing-md) var(--spacing-xl);
        }

        h2 {
            font-size: 1.75rem;
            color: var(--color-primary);
            margin-top: var(--spacing-xl);
            margin-bottom: var(--spacing-md);
            padding-bottom: var(--spacing-xs);
            border-bottom: 3px solid var(--color-accent);
        }

        h3 {
            font-size: 1.4rem;
            color: var(--color-primary);
            margin-top: var(--spacing-lg);
            margin-bottom: var(--spacing-sm);
        }

        h4 {
            font-size: 1.1rem;
            color: var(--color-primary-dark);
            margin-top: var(--spacing-md);
            margin-bottom: var(--spacing-sm);
        }

        p {
            margin-bottom: var(--spacing-md);
            color: var(--color-text);
        }

        a {
            color: var(--color-link);
            text-decoration: none;
            transition: color 0.2s;
        }

        a:hover {
            color: var(--color-link-hover);
            text-decoration: underline;
        }

        ul, ol {
            margin-left: var(--spacing-lg);
            margin-bottom: var(--spacing-md);
        }

        li {
            margin-bottom: var(--spacing-xs);
            color: var(--color-text);
        }

        pre {
            background-color: var(--color-code-bg);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            overflow-x: auto;
            margin-bottom: var(--spacing-md);
            font-family: var(--font-mono);
            font-size: 0.9rem;
            line-height: 1.5;
        }

        code {
            font-family: var(--font-mono);
            font-size: 0.9em;
            background-color: var(--color-code-bg);
            padding: 0.2em 0.4em;
            border-radius: 3px;
        }

        pre code {
            background-color: transparent;
            padding: 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: var(--spacing-md);
            font-size: 0.95rem;
        }

        th, td {
            border: 1px solid var(--color-border);
            padding: var(--spacing-sm);
            text-align: left;
        }

        th {
            background-color: var(--color-bg-alt);
            font-weight: 600;
            color: var(--color-primary);
        }

        blockquote {
            border-left: 4px solid var(--color-accent);
            padding-left: var(--spacing-md);
            margin: var(--spacing-md) 0;
            color: var(--color-text-light);
            font-style: italic;
            background-color: var(--color-bg-alt);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        .mermaid {
            text-align: center;
            margin: var(--spacing-lg) 0;
            background-color: var(--color-bg-alt);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        details {
            background-color: var(--color-bg-alt);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            margin-bottom: var(--spacing-md);
        }

        summary {
            cursor: pointer;
            font-weight: 600;
            color: var(--color-primary);
            user-select: none;
            padding: var(--spacing-xs);
            margin: calc(-1 * var(--spacing-md));
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        summary:hover {
            background-color: rgba(123, 44, 191, 0.1);
        }

        details[open] summary {
            margin-bottom: var(--spacing-md);
            border-bottom: 1px solid var(--color-border);
        }

        .navigation {
            display: flex;
            justify-content: space-between;
            gap: var(--spacing-md);
            margin: var(--spacing-xl) 0;
            padding-top: var(--spacing-lg);
            border-top: 2px solid var(--color-border);
        }

        .nav-button {
            flex: 1;
            padding: var(--spacing-md);
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            color: white;
            border-radius: var(--border-radius);
            text-align: center;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: var(--box-shadow);
        }

        .nav-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            text-decoration: none;
        }

        footer {
            margin-top: var(--spacing-xl);
            padding: var(--spacing-lg) var(--spacing-md);
            background-color: var(--color-bg-alt);
            border-top: 1px solid var(--color-border);
            text-align: center;
            font-size: 0.9rem;
            color: var(--color-text-light);
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.5rem;
            }

            h2 {
                font-size: 1.4rem;
            }

            h3 {
                font-size: 1.2rem;
            }

            .meta {
                font-size: 0.85rem;
            }

            .navigation {
                flex-direction: column;
            }

            table {
                font-size: 0.85rem;
            }

            th, td {
                padding: var(--spacing-xs);
            }
        }
    </style>

    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ startOnLoad: true, theme: 'default' });
    </script>

    <!-- MathJax for LaTeX equation rendering -->
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true,
                processEnvironments: true
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
                ignoreHtmlClass: 'mermaid'
            }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" id="MathJax-script" async></script>
</head>
<body>
    <header>
        <div class="header-content">
            <h1>第2章：Apache Sparkによる分散機械学習</h1>
            <p class="subtitle">ビッグデータMLの実践基盤 - Sparkで加速する大規模データ処理</p>
            <div class="meta">
                <span class="meta-item">📖 読了時間: 35-40分</span>
                <span class="meta-item">📊 難易度: 中級</span>
                <span class="meta-item">💻 コード例: 10個</span>
                <span class="meta-item">📝 演習問題: 5問</span>
            </div>
        </div>
    </header>

    <main class="container">

<h2>学習目標</h2>
<p>この章を読むことで、以下を習得できます：</p>
<ul>
<li>✅ Sparkアーキテクチャと分散処理の仕組みを理解する</li>
<li>✅ RDD、DataFrame、DatasetのAPIを使い分けられる</li>
<li>✅ Spark SQLで効率的なデータ操作ができる</li>
<li>✅ Spark MLlibで分散機械学習を実装できる</li>
<li>✅ パフォーマンス最適化の手法を適用できる</li>
<li>✅ 実データで大規模ML処理を実行できる</li>
</ul>

<hr>

<h2>2.1 Sparkアーキテクチャ</h2>

<h3>Apache Sparkとは</h3>
<p><strong>Apache Spark</strong>は、大規模データの高速分散処理フレームワークです。MapReduceの100倍以上の速度を実現し、機械学習、ストリーム処理、グラフ処理に対応します。</p>

<blockquote>
<p>「MapReduceの後継者」- メモリ内処理により、反復処理が圧倒的に高速化します。</p>
</blockquote>

<h3>Sparkの主要コンポーネント</h3>

<table>
<thead>
<tr>
<th>コンポーネント</th>
<th>用途</th>
<th>特徴</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Spark Core</strong></td>
<td>基本処理エンジン</td>
<td>RDD、タスクスケジューリング</td>
</tr>
<tr>
<td><strong>Spark SQL</strong></td>
<td>構造化データ処理</td>
<td>DataFrame、SQL クエリ</td>
</tr>
<tr>
<td><strong>Spark MLlib</strong></td>
<td>機械学習</td>
<td>分散ML、パイプライン</td>
</tr>
<tr>
<td><strong>Spark Streaming</strong></td>
<td>ストリーム処理</td>
<td>リアルタイムデータ処理</td>
</tr>
<tr>
<td><strong>GraphX</strong></td>
<td>グラフ処理</td>
<td>ネットワーク解析</td>
</tr>
</tbody>
</table>

<h3>Driver と Executor の関係</h3>

<div class="mermaid">
graph TB
    subgraph "Driver Program"
        A[SparkContext]
        B[DAG Scheduler]
        C[Task Scheduler]
    end

    subgraph "Cluster Manager"
        D[YARN / Mesos / K8s]
    end

    subgraph "Worker Node 1"
        E1[Executor 1]
        E2[Task]
        E3[Cache]
    end

    subgraph "Worker Node 2"
        F1[Executor 2]
        F2[Task]
        F3[Cache]
    end

    subgraph "Worker Node N"
        G1[Executor N]
        G2[Task]
        G3[Cache]
    end

    A --> B
    B --> C
    C --> D
    D --> E1
    D --> F1
    D --> G1

    style A fill:#e3f2fd
    style D fill:#fff3e0
    style E1 fill:#e8f5e9
    style F1 fill:#e8f5e9
    style G1 fill:#e8f5e9
</div>

<h3>Lazy Evaluation（遅延評価）</h3>

<p>Sparkは<strong>Transformation</strong>（変換）と<strong>Action</strong>（アクション）を区別します。</p>

<table>
<thead>
<tr>
<th>タイプ</th>
<th>説明</th>
<th>例</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Transformation</strong></td>
<td>新しいRDD/DataFrameを返す<br>遅延評価（計算は実行されない）</td>
<td><code>map()</code>, <code>filter()</code>, <code>groupBy()</code></td>
</tr>
<tr>
<td><strong>Action</strong></td>
<td>結果を返す/保存する<br>即時評価（実際の計算を実行）</td>
<td><code>count()</code>, <code>collect()</code>, <code>save()</code></td>
</tr>
</tbody>
</table>

<h3>DAG実行モデル</h3>

<div class="mermaid">
graph LR
    A[データ読み込み] --> B[filter]
    B --> C[map]
    C --> D[reduceByKey]
    D --> E[collect]

    style A fill:#e3f2fd
    style E fill:#ffebee
    style B fill:#f3e5f5
    style C fill:#f3e5f5
    style D fill:#f3e5f5

    classDef transformation fill:#f3e5f5
    classDef action fill:#ffebee
</div>

<p><strong>Transformation</strong>は実行計画（DAG）を構築し、<strong>Action</strong>が呼ばれた時に最適化された計算が実行されます。</p>

<h3>Sparkセッションの初期化</h3>

<pre><code class="language-python">from pyspark.sql import SparkSession

# Sparkセッションの作成
spark = SparkSession.builder \
    .appName("SparkMLExample") \
    .master("local[*]") \
    .config("spark.driver.memory", "4g") \
    .config("spark.executor.memory", "4g") \
    .getOrCreate()

print(f"Spark Version: {spark.version}")
print(f"Spark Master: {spark.sparkContext.master}")
print(f"App Name: {spark.sparkContext.appName}")

# Sparkセッションの設定確認
spark.sparkContext.getConf().getAll()
</code></pre>

<p><strong>出力</strong>：</p>
<pre><code>Spark Version: 3.5.0
Spark Master: local[*]
App Name: SparkMLExample
</code></pre>

<blockquote>
<p><strong>重要</strong>: <code>local[*]</code>はローカルモードで全CPUコアを使用します。クラスターモードでは<code>yarn</code>や<code>k8s://</code>を指定します。</p>
</blockquote>

<hr>

<h2>2.2 RDD（Resilient Distributed Datasets）</h2>

<h3>RDDとは</h3>

<p><strong>RDD（Resilient Distributed Dataset）</strong>は、Sparkの基本的なデータ抽象化で、分散コレクションの不変オブジェクトです。</p>

<h4>RDDの3つの特性</h4>

<ol>
<li><strong>Resilient（耐障害性）</strong>: Lineage（系譜）により、障害時に自動復旧</li>
<li><strong>Distributed（分散）</strong>: データはクラスター全体に分散</li>
<li><strong>Dataset（データセット）</strong>: メモリ内の不変コレクション</li>
</ol>

<h3>RDDの基本操作</h3>

<h4>RDD作成</h4>

<pre><code class="language-python">from pyspark import SparkContext

# SparkContextの取得（SparkSessionから）
sc = spark.sparkContext

# 方法1: Pythonリストから作成
data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
rdd = sc.parallelize(data, numSlices=4)  # 4パーティションに分割

print(f"パーティション数: {rdd.getNumPartitions()}")
print(f"最初の5要素: {rdd.take(5)}")

# 方法2: テキストファイルから作成
# text_rdd = sc.textFile("hdfs://path/to/file.txt")

# 方法3: 複数ファイルから作成
# multi_rdd = sc.wholeTextFiles("hdfs://path/to/directory/")
</code></pre>

<p><strong>出力</strong>：</p>
<pre><code>パーティション数: 4
最初の5要素: [1, 2, 3, 4, 5]
</code></pre>

<h3>Transformations（変換）</h3>

<pre><code class="language-python"># データ準備
numbers = sc.parallelize(range(1, 11))

# map: 各要素に関数を適用
squares = numbers.map(lambda x: x ** 2)
print(f"二乗: {squares.collect()}")

# filter: 条件に合う要素のみ抽出
evens = numbers.filter(lambda x: x % 2 == 0)
print(f"偶数: {evens.collect()}")

# flatMap: 各要素を複数要素に展開
words = sc.parallelize(["Hello World", "Apache Spark"])
all_words = words.flatMap(lambda line: line.split(" "))
print(f"単語: {all_words.collect()}")

# union: 2つのRDDを結合
rdd1 = sc.parallelize([1, 2, 3])
rdd2 = sc.parallelize([4, 5, 6])
combined = rdd1.union(rdd2)
print(f"結合: {combined.collect()}")

# distinct: 重複を削除
duplicates = sc.parallelize([1, 2, 2, 3, 3, 3, 4])
unique = duplicates.distinct()
print(f"ユニーク: {unique.collect()}")
</code></pre>

<p><strong>出力</strong>：</p>
<pre><code>二乗: [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
偶数: [2, 4, 6, 8, 10]
単語: ['Hello', 'World', 'Apache', 'Spark']
結合: [1, 2, 3, 4, 5, 6]
ユニーク: [1, 2, 3, 4]
</code></pre>

<h3>Key-Value RDD操作</h3>

<pre><code class="language-python"># ペアRDDの作成
pairs = sc.parallelize([("apple", 3), ("banana", 2), ("apple", 5), ("orange", 1)])

# reduceByKey: キーごとに値を集約
total_by_key = pairs.reduceByKey(lambda a, b: a + b)
print(f"キー別合計: {total_by_key.collect()}")

# groupByKey: キーごとに値をグループ化
grouped = pairs.groupByKey()
print(f"グループ化: {[(k, list(v)) for k, v in grouped.collect()]}")

# mapValues: 値のみに関数を適用
doubled_values = pairs.mapValues(lambda x: x * 2)
print(f"値を2倍: {doubled_values.collect()}")

# sortByKey: キーでソート
sorted_pairs = pairs.sortByKey()
print(f"ソート: {sorted_pairs.collect()}")

# join: 2つのペアRDDを結合
prices = sc.parallelize([("apple", 100), ("banana", 80), ("orange", 60)])
joined = pairs.join(prices)
print(f"結合: {joined.collect()}")
</code></pre>

<p><strong>出力</strong>：</p>
<pre><code>キー別合計: [('apple', 8), ('banana', 2), ('orange', 1)]
グループ化: [('apple', [3, 5]), ('banana', [2]), ('orange', [1])]
値を2倍: [('apple', 6), ('banana', 4), ('apple', 10), ('orange', 2)]
ソート: [('apple', 3), ('apple', 5), ('banana', 2), ('orange', 1)]
結合: [('apple', (3, 100)), ('apple', (5, 100)), ('banana', (2, 80)), ('orange', (1, 60))]
</code></pre>

<h3>Actions（アクション）</h3>

<pre><code class="language-python">numbers = sc.parallelize(range(1, 11))

# count: 要素数をカウント
print(f"要素数: {numbers.count()}")

# collect: すべての要素を取得（注意: メモリに収まるサイズのみ）
print(f"全要素: {numbers.collect()}")

# take: 最初のn要素を取得
print(f"最初の3要素: {numbers.take(3)}")

# first: 最初の要素を取得
print(f"最初の要素: {numbers.first()}")

# reduce: 全要素を集約
sum_all = numbers.reduce(lambda a, b: a + b)
print(f"合計: {sum_all}")

# foreach: 各要素に副作用のある処理を実行
numbers.foreach(lambda x: print(f"処理中: {x}"))

# saveAsTextFile: ファイルに保存
# numbers.saveAsTextFile("output/numbers")
</code></pre>

<p><strong>出力</strong>：</p>
<pre><code>要素数: 10
全要素: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
最初の3要素: [1, 2, 3]
最初の要素: 1
合計: 55
</code></pre>

<h3>Lineage（系譜）と耐障害性</h3>

<pre><code class="language-python"># RDDの系譜を確認
numbers = sc.parallelize(range(1, 101))
squares = numbers.map(lambda x: x ** 2)
evens = squares.filter(lambda x: x % 2 == 0)

# デバッグ文字列で系譜を表示
print("RDD系譜:")
print(evens.toDebugString().decode('utf-8'))
</code></pre>

<p><strong>出力</strong>：</p>
<pre><code>RDD系譜:
(4) PythonRDD[10] at RDD at PythonRDD.scala:53 []
 |  MapPartitionsRDD[9] at mapPartitions at PythonRDD.scala:145 []
 |  MapPartitionsRDD[8] at mapPartitions at PythonRDD.scala:145 []
 |  ParallelCollectionRDD[7] at parallelize at PythonRDD.scala:195 []
</code></pre>

<blockquote>
<p><strong>重要</strong>: Sparkは系譜を記録しており、ノード障害時にはこの系譜から自動的にデータを再計算します。</p>
</blockquote>

<hr>

<h2>2.3 Spark DataFrame と SQL</h2>

<h3>DataFrameとは</h3>

<p><strong>DataFrame</strong>は、名前付き列を持つ分散データセットで、RDDより高速で使いやすいAPIです。</p>

<h4>DataFrameの利点</h4>

<ul>
<li><strong>Catalyst Optimizer</strong>: クエリ最適化により高速化</li>
<li><strong>Tungsten実行エンジン</strong>: メモリ効率の向上</li>
<li><strong>スキーマ情報</strong>: 型安全性と最適化</li>
<li><strong>SQL互換性</strong>: SQLクエリが使える</li>
</ul>

<h3>DataFrame作成</h3>

<pre><code class="language-python">from pyspark.sql import Row
import pandas as pd

# 方法1: Pythonリストから作成
data = [
    ("Alice", 25, "Engineer"),
    ("Bob", 30, "Data Scientist"),
    ("Charlie", 35, "Manager"),
    ("Diana", 28, "Analyst")
]
columns = ["name", "age", "job"]
df = spark.createDataFrame(data, columns)

# データ確認
df.show()
df.printSchema()

# 方法2: Rowオブジェクトから作成
rows = [
    Row(name="Eve", age=32, job="Developer"),
    Row(name="Frank", age=29, job="Designer")
]
df2 = spark.createDataFrame(rows)

# 方法3: Pandas DataFrameから作成
pandas_df = pd.DataFrame({
    'name': ['Grace', 'Henry'],
    'age': [27, 31],
    'job': ['Researcher', 'Architect']
})
df3 = spark.createDataFrame(pandas_df)

# 方法4: CSVファイルから読み込み
# df_csv = spark.read.csv("data.csv", header=True, inferSchema=True)
</code></pre>

<p><strong>出力</strong>：</p>
<pre><code>+-------+---+---------------+
|   name|age|            job|
+-------+---+---------------+
|  Alice| 25|       Engineer|
|    Bob| 30|Data Scientist|
|Charlie| 35|        Manager|
|  Diana| 28|        Analyst|
+-------+---+---------------+

root
 |-- name: string (nullable = true)
 |-- age: long (nullable = true)
 |-- job: string (nullable = true)
</code></pre>

<h3>DataFrame操作</h3>

<h4>選択とフィルタリング</h4>

<pre><code class="language-python"># 列の選択
df.select("name", "age").show()

# 条件によるフィルタリング
df.filter(df.age > 28).show()

# where（filterの別名）
df.where(df.job == "Engineer").show()

# 複数条件
df.filter((df.age > 25) & (df.age < 32)).show()

# 新しい列の追加
from pyspark.sql.functions import col, lit

df_with_salary = df.withColumn("salary", col("age") * 1000)
df_with_salary.show()

# 列名の変更
df_renamed = df.withColumnRenamed("job", "position")
df_renamed.show()

# 列の削除
df_dropped = df.drop("job")
df_dropped.show()
</code></pre>

<h3>集約とグループ化</h3>

<pre><code class="language-python">from pyspark.sql.functions import avg, count, max, min, sum

# データ準備
sales_data = [
    ("Alice", "2024-01", 100),
    ("Alice", "2024-02", 150),
    ("Bob", "2024-01", 200),
    ("Bob", "2024-02", 180),
    ("Charlie", "2024-01", 120),
    ("Charlie", "2024-02", 140)
]
sales_df = spark.createDataFrame(sales_data, ["name", "month", "sales"])

# グループ化と集約
sales_summary = sales_df.groupBy("name").agg(
    sum("sales").alias("total_sales"),
    avg("sales").alias("avg_sales"),
    count("sales").alias("num_months")
)
sales_summary.show()

# 複数列でグループ化
monthly_stats = sales_df.groupBy("name", "month").agg(
    max("sales").alias("max_sales"),
    min("sales").alias("min_sales")
)
monthly_stats.show()

# ピボットテーブル
pivot_df = sales_df.groupBy("name").pivot("month").sum("sales")
pivot_df.show()
</code></pre>

<p><strong>出力</strong>：</p>
<pre><code>+-------+-----------+---------+----------+
|   name|total_sales|avg_sales|num_months|
+-------+-----------+---------+----------+
|  Alice|        250|    125.0|         2|
|    Bob|        380|    190.0|         2|
|Charlie|        260|    130.0|         2|
+-------+-----------+---------+----------+
</code></pre>

<h3>Spark SQLの利用</h3>

<pre><code class="language-python"># DataFrameをテンポラリビューとして登録
df.createOrReplaceTempView("employees")

# SQLクエリの実行
sql_result = spark.sql("""
    SELECT
        job,
        COUNT(*) as num_employees,
        AVG(age) as avg_age,
        MAX(age) as max_age,
        MIN(age) as min_age
    FROM employees
    GROUP BY job
    ORDER BY avg_age DESC
""")

sql_result.show()

# 複雑なSQLクエリ
advanced_query = spark.sql("""
    SELECT
        name,
        age,
        job,
        CASE
            WHEN age < 28 THEN 'Junior'
            WHEN age >= 28 AND age < 32 THEN 'Mid-level'
            ELSE 'Senior'
        END as level
    FROM employees
    WHERE age > 25
    ORDER BY age
""")

advanced_query.show()
</code></pre>

<h3>結合操作</h3>

<pre><code class="language-python"># データ準備
employees = spark.createDataFrame([
    (1, "Alice", "Engineering"),
    (2, "Bob", "Data Science"),
    (3, "Charlie", "Management")
], ["id", "name", "department"])

salaries = spark.createDataFrame([
    (1, 80000),
    (2, 95000),
    (4, 70000)  # id=4は社員テーブルに存在しない
], ["id", "salary"])

# Inner Join（内部結合）
inner_join = employees.join(salaries, "id", "inner")
print("Inner Join:")
inner_join.show()

# Left Outer Join（左外部結合）
left_join = employees.join(salaries, "id", "left")
print("Left Outer Join:")
left_join.show()

# Right Outer Join（右外部結合）
right_join = employees.join(salaries, "id", "right")
print("Right Outer Join:")
right_join.show()

# Full Outer Join（完全外部結合）
full_join = employees.join(salaries, "id", "outer")
print("Full Outer Join:")
full_join.show()
</code></pre>

<p><strong>出力（Inner Join）</strong>：</p>
<pre><code>+---+-----+-------------+------+
| id| name|   department|salary|
+---+-----+-------------+------+
|  1|Alice|  Engineering| 80000|
|  2|  Bob| Data Science| 95000|
+---+-----+-------------+------+
</code></pre>

<h3>Catalyst Optimizerの効果</h3>

<pre><code class="language-python"># クエリの実行計画を確認
df_filtered = df.filter(df.age > 25).select("name", "age")

# 物理実行計画
print("Physical Plan:")
df_filtered.explain(mode="formatted")

# 最適化前の論理プラン
print("\nLogical Plan:")
df_filtered.explain(mode="extended")
</code></pre>

<blockquote>
<p><strong>重要</strong>: Catalystは述語プッシュダウン、カラムプルーニング、定数畳み込みなどの最適化を自動的に適用します。</p>
</blockquote>

<hr>

<h2>2.4 Spark MLlib（機械学習）</h2>

<h3>MLlibとは</h3>

<p><strong>Spark MLlib</strong>は、Sparkの分散機械学習ライブラリで、大規模データに対する学習を効率的に実行します。</p>

<h4>MLlibの主要機能</h4>

<ul>
<li><strong>分類</strong>: ロジスティック回帰、決定木、ランダムフォレスト、GBT</li>
<li><strong>回帰</strong>: 線形回帰、回帰木、一般化線形モデル</li>
<li><strong>クラスタリング</strong>: K-Means、GMM、LDA</li>
<li><strong>協調フィルタリング</strong>: ALS（交互最小二乗法）</li>
<li><strong>次元削減</strong>: PCA、SVD</li>
<li><strong>特徴量変換</strong>: VectorAssembler、StringIndexer、OneHotEncoder</li>
</ul>

<h3>ML Pipelineの基本</h3>

<div class="mermaid">
graph LR
    A[生データ] --> B[StringIndexer]
    B --> C[VectorAssembler]
    C --> D[StandardScaler]
    D --> E[分類器]
    E --> F[予測結果]

    style A fill:#e3f2fd
    style B fill:#fff3e0
    style C fill:#fff3e0
    style D fill:#fff3e0
    style E fill:#f3e5f5
    style F fill:#e8f5e9
</div>

<h3>分類タスクの実装</h3>

<pre><code class="language-python">from pyspark.ml.feature import VectorAssembler, StringIndexer
from pyspark.ml.classification import LogisticRegression, RandomForestClassifier
from pyspark.ml.evaluation import BinaryClassificationEvaluator, MulticlassClassificationEvaluator
from pyspark.ml import Pipeline

# サンプルデータ生成
from pyspark.sql.functions import rand, when

# Irisデータセットのような構造のデータを生成
data = spark.range(0, 1000).select(
    (rand() * 3 + 4).alias("sepal_length"),
    (rand() * 2 + 2).alias("sepal_width"),
    (rand() * 3 + 1).alias("petal_length"),
    (rand() * 2 + 0.1).alias("petal_width")
)

# ターゲット変数の作成
data = data.withColumn(
    "species",
    when((data.petal_length < 2), "setosa")
    .when((data.petal_length >= 2) & (data.petal_length < 4), "versicolor")
    .otherwise("virginica")
)

# データの確認
data.show(10)
data.groupBy("species").count().show()

# 訓練・テストデータ分割
train_data, test_data = data.randomSplit([0.8, 0.2], seed=42)

print(f"訓練データ: {train_data.count()}行")
print(f"テストデータ: {test_data.count()}行")
</code></pre>

<h3>特徴量変換パイプライン</h3>

<pre><code class="language-python"># ステージ1: カテゴリ変数をインデックスに変換
label_indexer = StringIndexer(
    inputCol="species",
    outputCol="label"
)

# ステージ2: 特徴量をベクトルに結合
feature_columns = ["sepal_length", "sepal_width", "petal_length", "petal_width"]
vector_assembler = VectorAssembler(
    inputCols=feature_columns,
    outputCol="features"
)

# ステージ3: ロジスティック回帰モデル
lr = LogisticRegression(
    featuresCol="features",
    labelCol="label",
    maxIter=100,
    regParam=0.01
)

# パイプラインの構築
pipeline = Pipeline(stages=[label_indexer, vector_assembler, lr])

# モデルの訓練
print("モデルの訓練を開始...")
model = pipeline.fit(train_data)
print("訓練完了")

# 予測
predictions = model.transform(test_data)

# 予測結果の確認
predictions.select("species", "label", "features", "prediction", "probability").show(10, truncate=False)
</code></pre>

<h3>モデルの評価</h3>

<pre><code class="language-python"># 多クラス分類の評価
multi_evaluator = MulticlassClassificationEvaluator(
    labelCol="label",
    predictionCol="prediction"
)

# 精度（Accuracy）
accuracy = multi_evaluator.evaluate(predictions, {multi_evaluator.metricName: "accuracy"})
print(f"精度: {accuracy:.4f}")

# F1スコア
f1 = multi_evaluator.evaluate(predictions, {multi_evaluator.metricName: "f1"})
print(f"F1スコア: {f1:.4f}")

# 加重精度
weighted_precision = multi_evaluator.evaluate(
    predictions,
    {multi_evaluator.metricName: "weightedPrecision"}
)
print(f"加重精度: {weighted_precision:.4f}")

# 加重再現率
weighted_recall = multi_evaluator.evaluate(
    predictions,
    {multi_evaluator.metricName: "weightedRecall"}
)
print(f"加重再現率: {weighted_recall:.4f}")

# 混同行列の計算
from pyspark.ml.evaluation import MulticlassMetrics
prediction_and_labels = predictions.select("prediction", "label").rdd
metrics = MulticlassMetrics(prediction_and_labels)

print("\n混同行列:")
print(metrics.confusionMatrix().toArray())
</code></pre>

<h3>回帰タスクの実装</h3>

<pre><code class="language-python">from pyspark.ml.regression import LinearRegression, RandomForestRegressor
from pyspark.ml.evaluation import RegressionEvaluator

# 回帰用サンプルデータ生成
regression_data = spark.range(0, 1000).select(
    (rand() * 100).alias("feature1"),
    (rand() * 50).alias("feature2"),
    (rand() * 30).alias("feature3")
)

# ターゲット変数（線形関係 + ノイズ）
from pyspark.sql.functions import col
regression_data = regression_data.withColumn(
    "target",
    col("feature1") * 2 + col("feature2") * 1.5 - col("feature3") * 0.5 + (rand() * 10 - 5)
)

# 訓練・テスト分割
train_reg, test_reg = regression_data.randomSplit([0.8, 0.2], seed=42)

# 特徴量ベクトルの作成
feature_cols = ["feature1", "feature2", "feature3"]
assembler = VectorAssembler(inputCols=feature_cols, outputCol="features")

# 線形回帰モデル
lr_regressor = LinearRegression(
    featuresCol="features",
    labelCol="target",
    maxIter=100,
    regParam=0.1,
    elasticNetParam=0.5  # L1/L2正則化の混合比
)

# パイプライン構築
regression_pipeline = Pipeline(stages=[assembler, lr_regressor])

# 訓練
regression_model = regression_pipeline.fit(train_reg)

# 予測
regression_predictions = regression_model.transform(test_reg)

# 評価
reg_evaluator = RegressionEvaluator(
    labelCol="target",
    predictionCol="prediction"
)

rmse = reg_evaluator.evaluate(regression_predictions, {reg_evaluator.metricName: "rmse"})
mae = reg_evaluator.evaluate(regression_predictions, {reg_evaluator.metricName: "mae"})
r2 = reg_evaluator.evaluate(regression_predictions, {reg_evaluator.metricName: "r2"})

print(f"\n=== 回帰モデルの評価 ===")
print(f"RMSE: {rmse:.4f}")
print(f"MAE: {mae:.4f}")
print(f"R²: {r2:.4f}")

# モデルの係数
lr_model = regression_model.stages[-1]
print(f"\n係数: {lr_model.coefficients}")
print(f"切片: {lr_model.intercept:.4f}")
</code></pre>

<h3>ランダムフォレストによる分類</h3>

<pre><code class="language-python">from pyspark.ml.classification import RandomForestClassifier

# ランダムフォレストモデル
rf = RandomForestClassifier(
    featuresCol="features",
    labelCol="label",
    numTrees=100,
    maxDepth=10,
    seed=42
)

# パイプライン（特徴量変換 + RF）
rf_pipeline = Pipeline(stages=[label_indexer, vector_assembler, rf])

# 訓練
print("ランダムフォレストの訓練開始...")
rf_model = rf_pipeline.fit(train_data)
print("訓練完了")

# 予測
rf_predictions = rf_model.transform(test_data)

# 評価
rf_accuracy = multi_evaluator.evaluate(
    rf_predictions,
    {multi_evaluator.metricName: "accuracy"}
)
rf_f1 = multi_evaluator.evaluate(
    rf_predictions,
    {multi_evaluator.metricName: "f1"}
)

print(f"\n=== ランダムフォレストの評価 ===")
print(f"精度: {rf_accuracy:.4f}")
print(f"F1スコア: {rf_f1:.4f}")

# 特徴量の重要度
rf_classifier = rf_model.stages[-1]
feature_importances = rf_classifier.featureImportances

print("\n特徴量の重要度:")
for idx, importance in enumerate(feature_importances):
    print(f"{feature_columns[idx]}: {importance:.4f}")
</code></pre>

<h3>クロスバリデーションとハイパーパラメータ調整</h3>

<pre><code class="language-python">from pyspark.ml.tuning import CrossValidator, ParamGridBuilder

# パラメータグリッドの構築
param_grid = ParamGridBuilder() \
    .addGrid(lr.regParam, [0.001, 0.01, 0.1]) \
    .addGrid(lr.maxIter, [50, 100, 150]) \
    .build()

# クロスバリデーションの設定
cv = CrossValidator(
    estimator=pipeline,
    estimatorParamMaps=param_grid,
    evaluator=multi_evaluator,
    numFolds=3,
    seed=42
)

# クロスバリデーション実行
print("クロスバリデーション開始...")
cv_model = cv.fit(train_data)
print("完了")

# 最良モデルで予測
cv_predictions = cv_model.transform(test_data)

# 最良パラメータの確認
best_model = cv_model.bestModel
print("\n最良パラメータ:")
print(best_model.stages[-1].extractParamMap())

# 評価
cv_accuracy = multi_evaluator.evaluate(
    cv_predictions,
    {multi_evaluator.metricName: "accuracy"}
)
print(f"\nCV後の精度: {cv_accuracy:.4f}")
</code></pre>

<hr>

<h2>2.5 パフォーマンス最適化</h2>

<h3>パーティショニング戦略</h3>

<p>適切なパーティショニングは、Sparkの性能を大きく左右します。</p>

<h4>パーティション数の決定</h4>

<pre><code class="language-python"># デフォルトのパーティション数
print(f"デフォルトパーティション数: {spark.sparkContext.defaultParallelism}")

# RDDのパーティション数確認
rdd = sc.parallelize(range(1000))
print(f"RDDパーティション数: {rdd.getNumPartitions()}")

# DataFrameのパーティション数確認
df = spark.range(10000)
print(f"DataFrameパーティション数: {df.rdd.getNumPartitions()}")

# パーティション数の再設定
rdd_repartitioned = rdd.repartition(8)
print(f"再パーティション後: {rdd_repartitioned.getNumPartitions()}")

# coalesce: パーティション数を減らす（シャッフルなし）
rdd_coalesced = rdd.coalesce(4)
print(f"Coalesce後: {rdd_coalesced.getNumPartitions()}")
</code></pre>

<blockquote>
<p><strong>推奨</strong>: パーティション数は（CPUコア数 × 2〜3）が目安です。</p>
</blockquote>

<h4>カスタムパーティショナー</h4>

<pre><code class="language-python"># Key-Valueペアでのハッシュパーティショニング
pairs = sc.parallelize([("A", 1), ("B", 2), ("A", 3), ("C", 4), ("B", 5)])

# ハッシュパーティショニング
hash_partitioned = pairs.partitionBy(4)
print(f"ハッシュパーティション数: {hash_partitioned.getNumPartitions()}")

# 各パーティションの内容を確認
def show_partition_contents(index, iterator):
    yield f"Partition {index}: {list(iterator)}"

partition_contents = hash_partitioned.mapPartitionsWithIndex(show_partition_contents)
for content in partition_contents.collect():
    print(content)
</code></pre>

<h3>キャッシングと永続化</h3>

<h4>メモリキャッシング</h4>

<pre><code class="language-python"># DataFrameのキャッシュ
df_large = spark.range(0, 10000000)

# キャッシュ（デフォルト: メモリのみ）
df_large.cache()

# 初回アクションでキャッシュが作成される
count1 = df_large.count()
print(f"初回カウント（キャッシュ作成）: {count1}")

# 2回目以降はキャッシュから取得（高速）
count2 = df_large.count()
print(f"2回目カウント（キャッシュ使用）: {count2}")

# キャッシュ解放
df_large.unpersist()
</code></pre>

<h4>永続化レベルの選択</h4>

<pre><code class="language-python">from pyspark import StorageLevel

# RDDの永続化レベル
rdd = sc.parallelize(range(1000000))

# メモリとディスクの両方を使用
rdd.persist(StorageLevel.MEMORY_AND_DISK)

# シリアライズしてメモリに保存（メモリ効率向上）
rdd.persist(StorageLevel.MEMORY_ONLY_SER)

# レプリケーション（耐障害性向上）
rdd.persist(StorageLevel.MEMORY_AND_DISK_2)

print(f"ストレージレベル: {rdd.getStorageLevel()}")
</code></pre>

<table>
<thead>
<tr>
<th>ストレージレベル</th>
<th>説明</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>MEMORY_ONLY</code></td>
<td>メモリのみ（デフォルト）</td>
<td>十分なメモリがある場合</td>
</tr>
<tr>
<td><code>MEMORY_AND_DISK</code></td>
<td>メモリ → ディスクにスピル</td>
<td>大規模データ</td>
</tr>
<tr>
<td><code>MEMORY_ONLY_SER</code></td>
<td>シリアライズしてメモリ保存</td>
<td>メモリ効率重視</td>
</tr>
<tr>
<td><code>DISK_ONLY</code></td>
<td>ディスクのみ</td>
<td>メモリ不足時</td>
</tr>
<tr>
<td><code>OFF_HEAP</code></td>
<td>オフヒープメモリ</td>
<td>GC回避</td>
</tr>
</tbody>
</table>

<h3>ブロードキャスト変数</h3>

<pre><code class="language-python"># 小さなデータセットを全ノードに配布
lookup_table = {"A": 100, "B": 200, "C": 300, "D": 400}

# ブロードキャスト
broadcast_lookup = sc.broadcast(lookup_table)

# RDDでブロードキャスト変数を使用
data = sc.parallelize([("A", 1), ("B", 2), ("C", 3), ("A", 4)])

def enrich_data(pair):
    key, value = pair
    # ブロードキャスト変数を参照
    multiplier = broadcast_lookup.value.get(key, 1)
    return (key, value * multiplier)

enriched = data.map(enrich_data)
print(enriched.collect())

# ブロードキャスト変数の解放
broadcast_lookup.unpersist()
</code></pre>

<blockquote>
<p><strong>重要</strong>: ブロードキャスト変数は結合操作のパフォーマンスを大幅に向上させます（特に小さいテーブルとの結合）。</p>
</blockquote>

<h3>チューニングパラメータ</h3>

<h4>Sparkセッションの設定</h4>

<pre><code class="language-python"># パフォーマンス最適化の設定
spark_optimized = SparkSession.builder \
    .appName("OptimizedSparkApp") \
    .master("local[*]") \
    .config("spark.driver.memory", "4g") \
    .config("spark.executor.memory", "4g") \
    .config("spark.executor.cores", "4") \
    .config("spark.default.parallelism", "100") \
    .config("spark.sql.shuffle.partitions", "100") \
    .config("spark.sql.adaptive.enabled", "true") \
    .config("spark.sql.adaptive.coalescePartitions.enabled", "true") \
    .config("spark.serializer", "org.apache.spark.serializer.KryoSerializer") \
    .getOrCreate()

# 設定の確認
for conf in spark_optimized.sparkContext.getConf().getAll():
    print(f"{conf[0]}: {conf[1]}")
</code></pre>

<h4>主要チューニングパラメータ</h4>

<table>
<thead>
<tr>
<th>パラメータ</th>
<th>説明</th>
<th>推奨値</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>spark.executor.memory</code></td>
<td>Executorのメモリサイズ</td>
<td>利用可能メモリの70%</td>
</tr>
<tr>
<td><code>spark.executor.cores</code></td>
<td>Executor当たりのコア数</td>
<td>4-6コア</td>
</tr>
<tr>
<td><code>spark.default.parallelism</code></td>
<td>デフォルト並列度</td>
<td>コア数 × 2-3</td>
</tr>
<tr>
<td><code>spark.sql.shuffle.partitions</code></td>
<td>シャッフル時のパーティション数</td>
<td>100-200（データサイズ依存）</td>
</tr>
<tr>
<td><code>spark.sql.adaptive.enabled</code></td>
<td>適応的クエリ実行</td>
<td><code>true</code></td>
</tr>
<tr>
<td><code>spark.serializer</code></td>
<td>シリアライザ</td>
<td><code>KryoSerializer</code></td>
</tr>
</tbody>
</table>

<h3>実行計画の最適化</h3>

<pre><code class="language-python"># DataFrameの最適化例
large_df = spark.range(0, 10000000)
small_df = spark.range(0, 100)

# 最適化前: 大きいテーブルでフィルタ → 結合
result_unoptimized = large_df.filter(large_df.id % 2 == 0).join(small_df, "id")

# 最適化後: 結合 → フィルタ（述語プッシュダウン）
result_optimized = large_df.join(small_df, "id").filter(large_df.id % 2 == 0)

# 実行計画の比較
print("最適化前:")
result_unoptimized.explain()

print("\n最適化後:")
result_optimized.explain()

# Catalystが自動的に最適化するため、実際には両方とも同じ実行計画になる
</code></pre>

<hr>

<h2>2.6 本章のまとめ</h2>

<h3>学んだこと</h3>

<ol>
<li><p><strong>Sparkアーキテクチャ</strong></p>
<ul>
<li>Driver-Executor モデルによる分散処理</li>
<li>Lazy EvaluationとDAG実行</li>
<li>クラスターマネージャー（YARN、Mesos、K8s）</li>
<li>TransformationとActionの区別</li>
</ul></li>

<li><p><strong>RDD（Resilient Distributed Datasets）</strong></p>
<ul>
<li>不変・分散・耐障害性のあるコレクション</li>
<li>Lineageによる自動復旧</li>
<li>map、filter、reduceByKeyなどの操作</li>
<li>Key-Value ペアの処理</li>
</ul></li>

<li><p><strong>Spark DataFrame と SQL</strong></p>
<ul>
<li>Catalyst Optimizerによる高速化</li>
<li>スキーマ情報による型安全性</li>
<li>SQLクエリとDataFrame APIの統合</li>
<li>結合、集約、グループ化の効率的な処理</li>
</ul></li>

<li><p><strong>Spark MLlib</strong></p>
<ul>
<li>分散機械学習のパイプライン</li>
<li>特徴量変換と前処理</li>
<li>分類、回帰、クラスタリング</li>
<li>クロスバリデーションとハイパーパラメータ調整</li>
</ul></li>

<li><p><strong>パフォーマンス最適化</strong></p>
<ul>
<li>適切なパーティショニング戦略</li>
<li>キャッシングと永続化レベル</li>
<li>ブロードキャスト変数による結合最適化</li>
<li>チューニングパラメータの設定</li>
</ul></li>
</ol>

<h3>Spark活用のベストプラクティス</h3>

<table>
<thead>
<tr>
<th>項目</th>
<th>推奨事項</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>API選択</strong></td>
<td>DataFrame/Dataset > RDD（最適化の恩恵）</td>
</tr>
<tr>
<td><strong>パーティション</strong></td>
<td>適切な数（コア数 × 2-3）、均等な分散</td>
</tr>
<tr>
<td><strong>キャッシング</strong></td>
<td>再利用する中間結果のみキャッシュ</td>
</tr>
<tr>
<td><strong>シャッフル削減</strong></td>
<td>不要なgroupByKey回避、reduceByKey使用</td>
</tr>
<tr>
<td><strong>ブロードキャスト</strong></td>
<td>小さいテーブルとの結合に活用</td>
</tr>
<tr>
<td><strong>メモリ管理</strong></td>
<td>Executor メモリの適切な設定</td>
</tr>
</tbody>
</table>

<h3>次の章へ</h3>

<p>第3章では、<strong>分散深層学習フレームワーク</strong>を学びます：</p>
<ul>
<li>Horovod による分散学習</li>
<li>TensorFlow と PyTorch の分散戦略</li>
<li>Ray による超並列処理</li>
<li>MLflow による実験管理</li>
<li>分散ハイパーパラメータ最適化</li>
</ul>

<hr>

<h2>演習問題</h2>

<h3>問題1（難易度：easy）</h3>
<p>SparkにおけるTransformationとActionの違いを説明し、それぞれの例を3つずつ挙げてください。</p>

<details>
<summary>解答例</summary>

<p><strong>解答</strong>：</p>

<p><strong>Transformation（変換）</strong>：</p>
<ul>
<li>定義: 新しいRDD/DataFrameを返す操作で、遅延評価される</li>
<li>特徴: 実際の計算は実行されず、実行計画（DAG）が構築される</li>
<li>例:
<ol>
<li><code>map()</code> - 各要素に関数を適用</li>
<li><code>filter()</code> - 条件に合う要素のみ抽出</li>
<li><code>groupBy()</code> - キーでグループ化</li>
</ol></li>
</ul>

<p><strong>Action（アクション）</strong>：</p>
<ul>
<li>定義: 結果を返す/保存する操作で、即時評価される</li>
<li>特徴: 実際の計算が実行され、Driverまたはストレージにデータが返される</li>
<li>例:
<ol>
<li><code>count()</code> - 要素数をカウント</li>
<li><code>collect()</code> - すべての要素を取得</li>
<li><code>saveAsTextFile()</code> - ファイルに保存</li>
</ol></li>
</ul>

<p><strong>違いの重要性</strong>：</p>
<p>TransformationはDAGを構築するだけなので高速です。Actionが呼ばれた時に、Sparkは最適化された実行計画で計算を実行します。</p>

</details>

<h3>問題2（難易度：medium）</h3>
<p>以下のコードを実行すると、何が問題になる可能性がありますか？また、どのように修正すべきですか？</p>

<pre><code class="language-python">rdd = sc.parallelize(range(1, 1000000))
result = rdd.map(lambda x: x ** 2).collect()
print(result)
</code></pre>

<details>
<summary>解答例</summary>

<p><strong>問題点</strong>：</p>
<ol>
<li><strong>メモリ不足</strong>: <code>collect()</code>は全データをDriverメモリに集めるため、100万要素だとメモリ不足になる可能性</li>
<li><strong>パフォーマンス低下</strong>: 分散処理の利点が失われる</li>
<li><strong>ネットワーク負荷</strong>: 大量のデータをExecutorからDriverに転送</li>
</ol>

<p><strong>修正方法</strong>：</p>

<pre><code class="language-python"># 方法1: 必要な要素のみ取得
rdd = sc.parallelize(range(1, 1000000))
result = rdd.map(lambda x: x ** 2).take(10)  # 最初の10要素のみ
print(result)

# 方法2: ファイルに保存
rdd.map(lambda x: x ** 2).saveAsTextFile("output/squares")

# 方法3: 集約操作を使用
total = rdd.map(lambda x: x ** 2).sum()
print(f"合計: {total}")

# 方法4: サンプリング
sample = rdd.map(lambda x: x ** 2).sample(False, 0.01).collect()
print(f"サンプル: {sample[:10]}")
</code></pre>

<p><strong>ベストプラクティス</strong>：</p>
<ul>
<li><code>collect()</code>は小さなデータセット（数千行以下）のみに使用</li>
<li>大規模データは<code>take(n)</code>、<code>sample()</code>、<code>saveAsTextFile()</code>を使用</li>
</ul>

</details>

<h3>問題3（難易度：medium）</h3>
<p>Spark DataFrameで以下のSQLクエリと同等の処理をDataFrame APIで実装してください。</p>

<pre><code class="language-sql">SELECT
    department,
    AVG(salary) as avg_salary,
    MAX(salary) as max_salary,
    COUNT(*) as num_employees
FROM employees
WHERE age > 25
GROUP BY department
HAVING COUNT(*) > 5
ORDER BY avg_salary DESC
</code></pre>

<details>
<summary>解答例</summary>

<pre><code class="language-python">from pyspark.sql.functions import avg, max, count, col

# DataFrame API版
result = employees \
    .filter(col("age") > 25) \
    .groupBy("department") \
    .agg(
        avg("salary").alias("avg_salary"),
        max("salary").alias("max_salary"),
        count("*").alias("num_employees")
    ) \
    .filter(col("num_employees") > 5) \
    .orderBy(col("avg_salary").desc())

result.show()

# 別の書き方（メソッドチェーン）
result_alt = (employees
    .where("age > 25")
    .groupBy("department")
    .agg(
        {"salary": "avg", "salary": "max", "*": "count"}
    )
    .withColumnRenamed("avg(salary)", "avg_salary")
    .withColumnRenamed("max(salary)", "max_salary")
    .withColumnRenamed("count(1)", "num_employees")
    .filter("num_employees > 5")
    .sort(col("avg_salary").desc())
)
</code></pre>

<p><strong>説明</strong>：</p>
<ul>
<li><code>filter()</code> / <code>where()</code>: WHERE句</li>
<li><code>groupBy()</code>: GROUP BY句</li>
<li><code>agg()</code>: 集約関数（AVG、MAX、COUNT）</li>
<li><code>filter()</code>（2回目）: HAVING句</li>
<li><code>orderBy()</code> / <code>sort()</code>: ORDER BY句</li>
</ul>

</details>

<h3>問題4（難易度：hard）</h3>
<p>大規模データセット（1億行）でKey-Valueペアの結合を効率的に実行する方法を、以下の3つのシナリオで説明してください：</p>
<ol>
<li>両方のデータセットが大きい場合</li>
<li>片方のデータセットが小さい（メモリに収まる）場合</li>
<li>データが既にソート済みの場合</li>
</ol>

<details>
<summary>解答例</summary>

<p><strong>解答</strong>：</p>

<h4>シナリオ1: 両方のデータセットが大きい場合</h4>

<pre><code class="language-python"># 標準的なjoin（ソートマージ結合またはハッシュ結合）
large_df1 = spark.read.parquet("large_dataset1.parquet")
large_df2 = spark.read.parquet("large_dataset2.parquet")

# パーティション数を最適化
large_df1 = large_df1.repartition(200, "join_key")
large_df2 = large_df2.repartition(200, "join_key")

# 結合
result = large_df1.join(large_df2, "join_key", "inner")

# キャッシュ（再利用する場合）
result.cache()
result.count()  # キャッシュを実体化
</code></pre>

<p><strong>最適化ポイント</strong>：</p>
<ul>
<li>適切なパーティション数（データサイズに応じて調整）</li>
<li>結合キーで事前にパーティション化</li>
<li>適応的クエリ実行（AQE）を有効化</li>
</ul>

<h4>シナリオ2: 片方のデータセットが小さい場合</h4>

<pre><code class="language-python">from pyspark.sql.functions import broadcast

large_df = spark.read.parquet("large_dataset.parquet")
small_df = spark.read.parquet("small_dataset.parquet")

# ブロードキャスト結合（小さいテーブルを全ノードに配布）
result = large_df.join(broadcast(small_df), "join_key", "inner")

# または、自動ブロードキャスト閾値を設定
spark.conf.set("spark.sql.autoBroadcastJoinThreshold", 10485760)  # 10MB
</code></pre>

<p><strong>最適化ポイント</strong>：</p>
<ul>
<li>小さいテーブル（<10MB）をブロードキャスト</li>
<li>シャッフルが不要になり、大幅な高速化</li>
<li>メモリ使用量に注意（全Executorに配布される）</li>
</ul>

<h4>シナリオ3: データが既にソート済みの場合</h4>

<pre><code class="language-python"># データが結合キーでソート済み・パーティション化済みの場合
sorted_df1 = spark.read.parquet("sorted_dataset1.parquet")
sorted_df2 = spark.read.parquet("sorted_dataset2.parquet")

# ソートマージ結合を明示的に使用
result = sorted_df1.join(
    sorted_df2,
    sorted_df1["join_key"] == sorted_df2["join_key"],
    "inner"
)

# ヒントを使ってソートマージ結合を強制
from pyspark.sql.functions import expr
result = sorted_df1.hint("merge").join(sorted_df2, "join_key")
</code></pre>

<p><strong>最適化ポイント</strong>：</p>
<ul>
<li>既にソート済みならシャッフルが削減される</li>
<li>バケッティング（Bucketing）を使って事前にパーティション化</li>
<li>Parquet形式で保存時にソート順を維持</li>
</ul>

<h4>パフォーマンス比較</h4>

<table>
<thead>
<tr>
<th>シナリオ</th>
<th>結合タイプ</th>
<th>シャッフル</th>
<th>速度</th>
</tr>
</thead>
<tbody>
<tr>
<td>両方大きい</td>
<td>ソートマージ/ハッシュ</td>
<td>あり</td>
<td>中</td>
</tr>
<tr>
<td>片方小さい</td>
<td>ブロードキャスト</td>
<td>なし</td>
<td>速い</td>
</tr>
<tr>
<td>ソート済み</td>
<td>ソートマージ</td>
<td>部分的</td>
<td>速い</td>
</tr>
</tbody>
</table>

</details>

<h3>問題5（難易度：hard）</h3>
<p>Spark MLlibを使用して、テキスト分類タスク（スパム検出）の完全なパイプラインを構築してください。以下を含めてください：</p>
<ul>
<li>テキストの前処理（トークン化、ストップワード除去）</li>
<li>TF-IDF特徴量の作成</li>
<li>ロジスティック回帰モデルの訓練</li>
<li>クロスバリデーションによる評価</li>
</ul>

<details>
<summary>解答例</summary>

<pre><code class="language-python">from pyspark.ml.feature import Tokenizer, StopWordsRemover, HashingTF, IDF
from pyspark.ml.classification import LogisticRegression
from pyspark.ml import Pipeline
from pyspark.ml.evaluation import BinaryClassificationEvaluator, MulticlassClassificationEvaluator
from pyspark.ml.tuning import CrossValidator, ParamGridBuilder

# サンプルデータ作成
data = spark.createDataFrame([
    (0, "Free money now click here"),
    (0, "Congratulations you won a prize"),
    (1, "Meeting scheduled for tomorrow"),
    (1, "Please review the attached document"),
    (0, "Claim your free gift today"),
    (1, "Project update for next week"),
    (0, "Urgent account verification required"),
    (1, "Thanks for your help yesterday"),
    (0, "You have been selected winner"),
    (1, "Let's discuss the proposal")
] * 100, ["label", "text"])  # データを増やす

print(f"データ数: {data.count()}")
data.show(5)

# 訓練・テスト分割
train, test = data.randomSplit([0.8, 0.2], seed=42)

# ステージ1: トークン化
tokenizer = Tokenizer(inputCol="text", outputCol="words")

# ステージ2: ストップワード除去
remover = StopWordsRemover(inputCol="words", outputCol="filtered_words")

# ステージ3: ハッシング TF
hashingTF = HashingTF(
    inputCol="filtered_words",
    outputCol="raw_features",
    numFeatures=1000
)

# ステージ4: IDF
idf = IDF(inputCol="raw_features", outputCol="features")

# ステージ5: ロジスティック回帰
lr = LogisticRegression(maxIter=100, regParam=0.01)

# パイプライン構築
pipeline = Pipeline(stages=[tokenizer, remover, hashingTF, idf, lr])

# パラメータグリッド
paramGrid = ParamGridBuilder() \
    .addGrid(hashingTF.numFeatures, [500, 1000, 2000]) \
    .addGrid(lr.regParam, [0.001, 0.01, 0.1]) \
    .addGrid(lr.maxIter, [50, 100]) \
    .build()

# クロスバリデーション
cv = CrossValidator(
    estimator=pipeline,
    estimatorParamMaps=paramGrid,
    evaluator=BinaryClassificationEvaluator(),
    numFolds=3,
    seed=42
)

# 訓練
print("\nクロスバリデーション開始...")
cv_model = cv.fit(train)
print("訓練完了")

# 予測
predictions = cv_model.transform(test)

# 予測結果の確認
predictions.select("text", "label", "prediction", "probability").show(10, truncate=False)

# 評価
binary_evaluator = BinaryClassificationEvaluator()
multi_evaluator = MulticlassClassificationEvaluator()

auc = binary_evaluator.evaluate(predictions, {binary_evaluator.metricName: "areaUnderROC"})
accuracy = multi_evaluator.evaluate(predictions, {multi_evaluator.metricName: "accuracy"})
f1 = multi_evaluator.evaluate(predictions, {multi_evaluator.metricName: "f1"})

print("\n=== モデル評価 ===")
print(f"AUC: {auc:.4f}")
print(f"精度: {accuracy:.4f}")
print(f"F1スコア: {f1:.4f}")

# 最良パラメータ
best_model = cv_model.bestModel
print("\n最良パラメータ:")
print(f"numFeatures: {best_model.stages[2].getNumFeatures()}")
print(f"regParam: {best_model.stages[-1].getRegParam()}")
print(f"maxIter: {best_model.stages[-1].getMaxIter()}")

# 新しいテキストで予測
new_data = spark.createDataFrame([
    (0, "Free lottery winner claim now"),
    (1, "Project deadline next Monday")
], ["id", "text"])

new_predictions = cv_model.transform(new_data)
new_predictions.select("text", "prediction", "probability").show(truncate=False)
</code></pre>

<p><strong>出力例</strong>：</p>
<pre><code>=== モデル評価 ===
AUC: 0.9850
精度: 0.9500
F1スコア: 0.9495
</code></pre>

<p><strong>拡張アイデア</strong>：</p>
<ul>
<li>Word2Vec やGloVe埋め込みを使用</li>
<li>N-gram特徴量を追加</li>
<li>ランダムフォレストやGBTを試す</li>
<li>カスタム特徴量（文の長さ、大文字の割合など）を追加</li>
</ul>

</details>

<hr>

<h2>参考文献</h2>

<ol>
<li>Zaharia, M., et al. (2016). <em>Apache Spark: A Unified Engine for Big Data Processing</em>. Communications of the ACM, 59(11), 56-65.</li>
<li>Karau, H., Konwinski, A., Wendell, P., & Zaharia, M. (2015). <em>Learning Spark: Lightning-Fast Big Data Analysis</em>. O'Reilly Media.</li>
<li>Chambers, B., & Zaharia, M. (2018). <em>Spark: The Definitive Guide</em>. O'Reilly Media.</li>
<li>Meng, X., et al. (2016). <em>MLlib: Machine Learning in Apache Spark</em>. Journal of Machine Learning Research, 17(1), 1235-1241.</li>
<li>Apache Spark Documentation. (2024). <em>Spark SQL, DataFrames and Datasets Guide</em>. URL: https://spark.apache.org/docs/latest/sql-programming-guide.html</li>
<li>Databricks. (2024). <em>Apache Spark Performance Tuning Guide</em>. URL: https://www.databricks.com/blog/performance-tuning</li>
</ol>

<div class="navigation">
    <a href="index.html" class="nav-button">← シリーズ目次</a>
    <a href="chapter3-distributed-deep-learning.html" class="nav-button">次の章: 分散深層学習 →</a>
</div>

    </main>

    <footer>
        <p><strong>作成者</strong>: AI Terakoya Content Team</p>
        <p><strong>監修</strong>: Dr. Yusuke Hashimoto（東北大学）</p>
        <p><strong>バージョン</strong>: 1.0 | <strong>作成日</strong>: 2025-10-21</p>
        <p><strong>ライセンス</strong>: Creative Commons BY 4.0</p>
        <p>© 2025 AI Terakoya. All rights reserved.</p>
    </footer>
</body>
</html>
