<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>第1章：アンサンブル学習の基礎 - AI Terakoya</title>

    <style>
        :root {
            --color-primary: #2c3e50;
            --color-primary-dark: #1a252f;
            --color-accent: #7b2cbf;
            --color-accent-light: #9d4edd;
            --color-text: #2d3748;
            --color-text-light: #4a5568;
            --color-bg: #ffffff;
            --color-bg-alt: #f7fafc;
            --color-border: #e2e8f0;
            --color-code-bg: #f8f9fa;
            --color-link: #3182ce;
            --color-link-hover: #2c5aa0;

            --spacing-xs: 0.5rem;
            --spacing-sm: 1rem;
            --spacing-md: 1.5rem;
            --spacing-lg: 2rem;
            --spacing-xl: 3rem;

            --font-body: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            --font-mono: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;

            --border-radius: 8px;
            --box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-body);
            line-height: 1.7;
            color: var(--color-text);
            background-color: var(--color-bg);
            font-size: 16px;
        }

        header {
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            color: white;
            padding: var(--spacing-xl) var(--spacing-md);
            margin-bottom: var(--spacing-xl);
            box-shadow: var(--box-shadow);
        }

        .header-content {
            max-width: 900px;
            margin: 0 auto;
        }

        h1 {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: var(--spacing-sm);
            line-height: 1.2;
        }

        .subtitle {
            font-size: 1.1rem;
            opacity: 0.95;
            font-weight: 400;
            margin-bottom: var(--spacing-md);
        }

        .meta {
            display: flex;
            flex-wrap: wrap;
            gap: var(--spacing-md);
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .meta-item {
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 0 var(--spacing-md) var(--spacing-xl);
        }

        h2 {
            font-size: 1.75rem;
            color: var(--color-primary);
            margin-top: var(--spacing-xl);
            margin-bottom: var(--spacing-md);
            padding-bottom: var(--spacing-xs);
            border-bottom: 3px solid var(--color-accent);
        }

        h3 {
            font-size: 1.4rem;
            color: var(--color-primary);
            margin-top: var(--spacing-lg);
            margin-bottom: var(--spacing-sm);
        }

        h4 {
            font-size: 1.1rem;
            color: var(--color-primary-dark);
            margin-top: var(--spacing-md);
            margin-bottom: var(--spacing-sm);
        }

        p {
            margin-bottom: var(--spacing-md);
            color: var(--color-text);
        }

        a {
            color: var(--color-link);
            text-decoration: none;
            transition: color 0.2s;
        }

        a:hover {
            color: var(--color-link-hover);
            text-decoration: underline;
        }

        ul, ol {
            margin-left: var(--spacing-lg);
            margin-bottom: var(--spacing-md);
        }

        li {
            margin-bottom: var(--spacing-xs);
            color: var(--color-text);
        }

        pre {
            background-color: var(--color-code-bg);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            overflow-x: auto;
            margin-bottom: var(--spacing-md);
            font-family: var(--font-mono);
            font-size: 0.9rem;
            line-height: 1.5;
        }

        code {
            font-family: var(--font-mono);
            font-size: 0.9em;
            background-color: var(--color-code-bg);
            padding: 0.2em 0.4em;
            border-radius: 3px;
        }

        pre code {
            background-color: transparent;
            padding: 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: var(--spacing-md);
            font-size: 0.95rem;
        }

        th, td {
            border: 1px solid var(--color-border);
            padding: var(--spacing-sm);
            text-align: left;
        }

        th {
            background-color: var(--color-bg-alt);
            font-weight: 600;
            color: var(--color-primary);
        }

        blockquote {
            border-left: 4px solid var(--color-accent);
            padding-left: var(--spacing-md);
            margin: var(--spacing-md) 0;
            color: var(--color-text-light);
            font-style: italic;
            background-color: var(--color-bg-alt);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        .mermaid {
            text-align: center;
            margin: var(--spacing-lg) 0;
            background-color: var(--color-bg-alt);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        details {
            background-color: var(--color-bg-alt);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            margin-bottom: var(--spacing-md);
        }

        summary {
            cursor: pointer;
            font-weight: 600;
            color: var(--color-primary);
            user-select: none;
            padding: var(--spacing-xs);
            margin: calc(-1 * var(--spacing-md));
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        summary:hover {
            background-color: rgba(123, 44, 191, 0.1);
        }

        details[open] summary {
            margin-bottom: var(--spacing-md);
            border-bottom: 1px solid var(--color-border);
        }

        .navigation {
            display: flex;
            justify-content: space-between;
            gap: var(--spacing-md);
            margin: var(--spacing-xl) 0;
            padding-top: var(--spacing-lg);
            border-top: 2px solid var(--color-border);
        }

        .nav-button {
            flex: 1;
            padding: var(--spacing-md);
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            color: white;
            border-radius: var(--border-radius);
            text-align: center;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: var(--box-shadow);
        }

        .nav-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            text-decoration: none;
        }

        footer {
            margin-top: var(--spacing-xl);
            padding: var(--spacing-lg) var(--spacing-md);
            background-color: var(--color-bg-alt);
            border-top: 1px solid var(--color-border);
            text-align: center;
            font-size: 0.9rem;
            color: var(--color-text-light);
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.5rem;
            }

            h2 {
                font-size: 1.4rem;
            }

            h3 {
                font-size: 1.2rem;
            }

            .meta {
                font-size: 0.85rem;
            }

            .navigation {
                flex-direction: column;
            }

            table {
                font-size: 0.85rem;
            }

            th, td {
                padding: var(--spacing-xs);
            }
        }
    </style>

    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ startOnLoad: true, theme: 'default' });
    </script>

    <!-- MathJax for LaTeX equation rendering -->
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true,
                processEnvironments: true
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
                ignoreHtmlClass: 'mermaid'
            }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" id="MathJax-script" async></script>
</head>
<body>
    <header>
        <div class="header-content">
            <h1>第1章：アンサンブル学習の基礎</h1>
            <p class="subtitle">複数モデルの組み合わせによる予測精度向上 - バギング、ブースティング、スタッキングの原理</p>
            <div class="meta">
                <span class="meta-item">📖 読了時間: 20-25分</span>
                <span class="meta-item">📊 難易度: 初級〜中級</span>
                <span class="meta-item">💻 コード例: 8個</span>
                <span class="meta-item">📝 演習問題: 5問</span>
            </div>
        </div>
    </header>

    <main class="container">

<h2>学習目標</h2>
<p>この章を読むことで、以下を習得できます：</p>
<ul>
<li>✅ アンサンブル学習の原理を理解する</li>
<li>✅ バイアス・バリアンス分解の概念を説明できる</li>
<li>✅ バギング（Random Forest、Extra Trees）を実装できる</li>
<li>✅ ブースティング（AdaBoost、Gradient Boosting）の仕組みを理解する</li>
<li>✅ スタッキングとメタ学習器を使いこなせる</li>
<li>✅ 各手法の使い分けができる</li>
</ul>

<hr>

<h2>1.1 アンサンブル学習とは</h2>

<h3>定義</h3>
<p><strong>アンサンブル学習（Ensemble Learning）</strong>は、複数の弱学習器（weak learner）を組み合わせて、より強力な予測モデルを構築する機械学習手法です。</p>

<blockquote>
<p>「複数のモデルを組み合わせることで、単一モデルより高い性能を実現する」</p>
</blockquote>

<h3>なぜ複数のモデルを組み合わせるのか</h3>

<div class="mermaid">
graph LR
    A[単一モデルの限界] --> B[過学習しやすい]
    A --> C[バイアスが高い]
    A --> D[ノイズに敏感]

    E[アンサンブル] --> F[分散を減らす]
    E --> G[バイアスを減らす]
    E --> H[安定性向上]

    style A fill:#ffebee
    style E fill:#e8f5e9
</div>

<h3>アンサンブルの効果</h3>

<p><strong>例</strong>：3つのモデルがそれぞれ70%の精度で独立に予測する場合</p>

<p>多数決による精度：</p>

<p>$$
P(\text{正解}) = P(\text{2つ以上正解}) = \binom{3}{2}(0.7)^2(0.3) + \binom{3}{3}(0.7)^3 = 0.784
$$</p>

<p>単一モデル（70%）より高い精度（78.4%）を達成！</p>

<h3>バイアス・バリアンス分解</h3>

<p>予測誤差は以下のように分解されます：</p>

<p>$$
\text{Error} = \text{Bias}^2 + \text{Variance} + \text{Irreducible Error}
$$</p>

<table>
<thead>
<tr>
<th>要素</th>
<th>意味</th>
<th>対策</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>バイアス</strong></td>
<td>モデルの単純化による誤差</td>
<td>複雑なモデル、ブースティング</td>
</tr>
<tr>
<td><strong>バリアンス</strong></td>
<td>訓練データの変動への敏感さ</td>
<td>バギング、平均化</td>
</tr>
<tr>
<td><strong>既約誤差</strong></td>
<td>データに含まれるノイズ</td>
<td>削減不可能</td>
</tr>
</tbody>
</table>

<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
from sklearn.datasets import make_regression
from sklearn.model_selection import train_test_split
from sklearn.tree import DecisionTreeRegressor

# データ生成
X, y = make_regression(n_samples=100, n_features=1, noise=10, random_state=42)
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

# 異なる深さの決定木で予測
depths = [1, 3, 10]
plt.figure(figsize=(15, 4))

for i, depth in enumerate(depths, 1):
    model = DecisionTreeRegressor(max_depth=depth, random_state=42)
    model.fit(X_train, y_train)

    X_plot = np.linspace(X.min(), X.max(), 300).reshape(-1, 1)
    y_pred = model.predict(X_plot)

    plt.subplot(1, 3, i)
    plt.scatter(X_train, y_train, alpha=0.5, label='訓練データ')
    plt.plot(X_plot, y_pred, 'r-', linewidth=2, label=f'深さ={depth}')
    plt.xlabel('X')
    plt.ylabel('y')
    plt.title(f'深さ={depth}: {"高バイアス" if depth==1 else "高バリアンス" if depth==10 else "バランス"}')
    plt.legend()
    plt.grid(True, alpha=0.3)

plt.tight_layout()
plt.show()
</code></pre>

<hr>

<h2>1.2 バギング（Bagging）</h2>

<h3>概要</h3>

<p><strong>バギング（Bootstrap Aggregating）</strong>は、訓練データをブートストラップサンプリングして複数のモデルを訓練し、予測を平均化（回帰）または多数決（分類）する手法です。</p>

<h3>アルゴリズム</h3>

<ol>
<li>訓練データから<strong>ブートストラップサンプル</strong>を $B$ 個生成</li>
<li>各サンプルで独立にモデルを訓練</li>
<li>予測を集約：
<ul>
<li>回帰: $\hat{y} = \frac{1}{B}\sum_{b=1}^{B} \hat{f}_b(x)$</li>
<li>分類: 多数決</li>
</ul></li>
</ol>

<div class="mermaid">
graph TD
    A[訓練データ] --> B1[ブートストラップ1]
    A --> B2[ブートストラップ2]
    A --> B3[ブートストラップ3]

    B1 --> M1[モデル1]
    B2 --> M2[モデル2]
    B3 --> M3[モデル3]

    M1 --> AGG[集約]
    M2 --> AGG
    M3 --> AGG

    AGG --> PRED[最終予測]

    style A fill:#e3f2fd
    style AGG fill:#fff3e0
    style PRED fill:#e8f5e9
</div>

<h3>Random Forest</h3>

<p><strong>Random Forest</strong>は、バギング + ランダム特徴量選択を組み合わせた手法です。</p>

<p><strong>特徴</strong>：</p>
<ul>
<li>各分割でランダムに選んだ特徴量のサブセットから最適な分割を選択</li>
<li>モデル間の相関を減らし、多様性を向上</li>
</ul>

<pre><code class="language-python">from sklearn.datasets import make_classification
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.tree import DecisionTreeClassifier
from sklearn.metrics import accuracy_score

# データ生成
X, y = make_classification(n_samples=1000, n_features=20, n_informative=15,
                          n_redundant=5, random_state=42)
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# 単一の決定木
dt = DecisionTreeClassifier(random_state=42)
dt.fit(X_train, y_train)
dt_acc = accuracy_score(y_test, dt.predict(X_test))

# Random Forest
rf = RandomForestClassifier(n_estimators=100, random_state=42)
rf.fit(X_train, y_train)
rf_acc = accuracy_score(y_test, rf.predict(X_test))

print("=== バギングの効果 ===")
print(f"決定木（単一）: {dt_acc:.4f}")
print(f"Random Forest: {rf_acc:.4f}")
print(f"改善: {(rf_acc - dt_acc):.4f}")
</code></pre>

<p><strong>出力</strong>：</p>
<pre><code>=== バギングの効果 ===
決定木（単一）: 0.8600
Random Forest: 0.9250
改善: 0.0650
</code></pre>

<h3>Extra Trees</h3>

<p><strong>Extra Trees（Extremely Randomized Trees）</strong>は、Random Forestのさらにランダム化されたバージョンです。</p>

<p><strong>相違点</strong>：</p>
<ul>
<li>分割の閾値もランダムに選択</li>
<li>ブートストラップサンプリングを使わない（全データを使用）</li>
</ul>

<pre><code class="language-python">from sklearn.ensemble import ExtraTreesClassifier

# Extra Trees
et = ExtraTreesClassifier(n_estimators=100, random_state=42)
et.fit(X_train, y_train)
et_acc = accuracy_score(y_test, et.predict(X_test))

print("=== Extra Trees vs Random Forest ===")
print(f"Random Forest: {rf_acc:.4f}")
print(f"Extra Trees: {et_acc:.4f}")
</code></pre>

<hr>

<h2>1.3 ブースティング（Boosting）</h2>

<h3>概要</h3>

<p><strong>ブースティング</strong>は、弱学習器を順次訓練し、前のモデルの誤りを次のモデルで修正する手法です。</p>

<div class="mermaid">
graph LR
    A[データ] --> M1[モデル1]
    M1 --> W1[重み更新]
    W1 --> M2[モデル2]
    M2 --> W2[重み更新]
    W2 --> M3[モデル3]
    M3 --> F[加重和]

    style A fill:#e3f2fd
    style F fill:#e8f5e9
</div>

<h3>AdaBoost</h3>

<p><strong>AdaBoost（Adaptive Boosting）</strong>は、誤分類されたサンプルの重みを増やしながら順次モデルを訓練します。</p>

<p><strong>アルゴリズム</strong>：</p>

<ol>
<li>すべてのサンプルの重み $w_i = \frac{1}{m}$ で初期化</li>
<li>各反復 $t = 1, ..., T$:
<ul>
<li>重み付きデータで弱学習器 $h_t$ を訓練</li>
<li>誤差率 $\epsilon_t = \sum_{i: h_t(x_i) \neq y_i} w_i$</li>
<li>モデル重み $\alpha_t = \frac{1}{2}\ln\frac{1-\epsilon_t}{\epsilon_t}$</li>
<li>サンプル重み更新</li>
</ul></li>
<li>最終予測: $H(x) = \text{sign}\left(\sum_{t=1}^{T} \alpha_t h_t(x)\right)$</li>
</ol>

<pre><code class="language-python">from sklearn.ensemble import AdaBoostClassifier

# AdaBoost
ada = AdaBoostClassifier(n_estimators=100, random_state=42)
ada.fit(X_train, y_train)
ada_acc = accuracy_score(y_test, ada.predict(X_test))

print("=== AdaBoost ===")
print(f"精度: {ada_acc:.4f}")

# 反復ごとの精度推移
from sklearn.metrics import accuracy_score

n_trees = [1, 5, 10, 25, 50, 100]
train_scores = []
test_scores = []

for n in n_trees:
    ada_temp = AdaBoostClassifier(n_estimators=n, random_state=42)
    ada_temp.fit(X_train, y_train)
    train_scores.append(ada_temp.score(X_train, y_train))
    test_scores.append(ada_temp.score(X_test, y_test))

plt.figure(figsize=(10, 6))
plt.plot(n_trees, train_scores, 'o-', label='訓練データ', linewidth=2)
plt.plot(n_trees, test_scores, 's-', label='テストデータ', linewidth=2)
plt.xlabel('弱学習器の数', fontsize=12)
plt.ylabel('精度', fontsize=12)
plt.title('AdaBoost: 学習器数と精度の関係', fontsize=14)
plt.legend()
plt.grid(True, alpha=0.3)
plt.show()
</code></pre>

<h3>Gradient Boosting基礎</h3>

<p><strong>Gradient Boosting</strong>は、損失関数の勾配方向にモデルを追加していく手法です。</p>

<p><strong>アルゴリズム</strong>：</p>

<ol>
<li>初期予測 $F_0(x) = \arg\min_{\gamma} \sum_{i=1}^{m} L(y_i, \gamma)$</li>
<li>各反復 $t = 1, ..., T$:
<ul>
<li>残差（負の勾配）を計算: $r_i = -\frac{\partial L(y_i, F_{t-1}(x_i))}{\partial F_{t-1}(x_i)}$</li>
<li>残差に対して弱学習器 $h_t$ を訓練</li>
<li>モデル更新: $F_t(x) = F_{t-1}(x) + \nu \cdot h_t(x)$</li>
</ul></li>
</ol>

<pre><code class="language-python">from sklearn.ensemble import GradientBoostingClassifier

# Gradient Boosting
gb = GradientBoostingClassifier(n_estimators=100, learning_rate=0.1,
                                max_depth=3, random_state=42)
gb.fit(X_train, y_train)
gb_acc = accuracy_score(y_test, gb.predict(X_test))

print("=== Gradient Boosting ===")
print(f"精度: {gb_acc:.4f}")
</code></pre>

<hr>

<h2>1.4 スタッキング（Stacking）</h2>

<h3>概要</h3>

<p><strong>スタッキング</strong>は、複数の異なるモデル（ベースモデル）の予測を入力として、メタ学習器が最終予測を行う手法です。</p>

<div class="mermaid">
graph TD
    A[訓練データ] --> M1[モデル1: ロジスティック回帰]
    A --> M2[モデル2: Random Forest]
    A --> M3[モデル3: SVM]

    M1 --> P1[予測1]
    M2 --> P2[予測2]
    M3 --> P3[予測3]

    P1 --> META[メタ学習器]
    P2 --> META
    P3 --> META

    META --> FINAL[最終予測]

    style A fill:#e3f2fd
    style META fill:#fff3e0
    style FINAL fill:#e8f5e9
</div>

<h3>メタ学習器</h3>

<p>メタ学習器（Meta-learner）は、ベースモデルの予測を特徴量として学習します。</p>

<p><strong>一般的なメタ学習器</strong>：</p>
<ul>
<li>ロジスティック回帰</li>
<li>Ridge回帰</li>
<li>ニューラルネットワーク</li>
</ul>

<h3>交差検証戦略</h3>

<p>過学習を防ぐため、<strong>K-Fold交差検証</strong>を使ってベースモデルの予測を生成します。</p>

<pre><code class="language-python">from sklearn.ensemble import StackingClassifier
from sklearn.linear_model import LogisticRegression
from sklearn.svm import SVC

# ベースモデル
estimators = [
    ('rf', RandomForestClassifier(n_estimators=50, random_state=42)),
    ('et', ExtraTreesClassifier(n_estimators=50, random_state=42)),
    ('ada', AdaBoostClassifier(n_estimators=50, random_state=42))
]

# スタッキング
stack = StackingClassifier(
    estimators=estimators,
    final_estimator=LogisticRegression(),
    cv=5
)
stack.fit(X_train, y_train)
stack_acc = accuracy_score(y_test, stack.predict(X_test))

print("=== スタッキング ===")
print(f"Random Forest: {rf_acc:.4f}")
print(f"Extra Trees: {et_acc:.4f}")
print(f"AdaBoost: {ada_acc:.4f}")
print(f"スタッキング: {stack_acc:.4f}")
</code></pre>

<hr>

<h2>1.5 比較と使い分け</h2>

<h3>性能比較</h3>

<table>
<thead>
<tr>
<th>手法</th>
<th>バリアンス削減</th>
<th>バイアス削減</th>
<th>並列化</th>
<th>訓練速度</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>バギング</strong></td>
<td>✓</td>
<td>-</td>
<td>可能</td>
<td>速い</td>
</tr>
<tr>
<td><strong>Random Forest</strong></td>
<td>✓✓</td>
<td>-</td>
<td>可能</td>
<td>速い</td>
</tr>
<tr>
<td><strong>AdaBoost</strong></td>
<td>-</td>
<td>✓</td>
<td>不可</td>
<td>中程度</td>
</tr>
<tr>
<td><strong>Gradient Boosting</strong></td>
<td>-</td>
<td>✓✓</td>
<td>不可</td>
<td>遅い</td>
</tr>
<tr>
<td><strong>スタッキング</strong></td>
<td>✓</td>
<td>✓</td>
<td>可能</td>
<td>遅い</td>
</tr>
</tbody>
</table>

<h3>適用場面</h3>

<table>
<thead>
<tr>
<th>状況</th>
<th>推奨手法</th>
<th>理由</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>高バリアンスモデル</strong></td>
<td>バギング、Random Forest</td>
<td>分散を効果的に削減</td>
</tr>
<tr>
<td><strong>高バイアスモデル</strong></td>
<td>ブースティング</td>
<td>複雑なパターンを学習</td>
</tr>
<tr>
<td><strong>大規模データ</strong></td>
<td>Random Forest</td>
<td>並列化可能で高速</td>
</tr>
<tr>
<td><strong>不均衡データ</strong></td>
<td>AdaBoost</td>
<td>誤分類サンプルに注目</td>
</tr>
<tr>
<td><strong>最高性能追求</strong></td>
<td>スタッキング、GB</td>
<td>複数手法の長所を統合</td>
</tr>
</tbody>
</table>

<pre><code class="language-python"># 全手法の比較
results = {
    '決定木': dt_acc,
    'Random Forest': rf_acc,
    'Extra Trees': et_acc,
    'AdaBoost': ada_acc,
    'Gradient Boosting': gb_acc,
    'スタッキング': stack_acc
}

plt.figure(figsize=(10, 6))
methods = list(results.keys())
accuracies = list(results.values())

bars = plt.bar(methods, accuracies, color=['#e74c3c', '#3498db', '#2ecc71',
                                           '#f39c12', '#9b59b6', '#1abc9c'])
plt.ylabel('精度', fontsize=12)
plt.title('アンサンブル手法の性能比較', fontsize=14)
plt.xticks(rotation=15, ha='right')
plt.ylim([0.8, 1.0])
plt.grid(axis='y', alpha=0.3)

# 値をバーの上に表示
for bar in bars:
    height = bar.get_height()
    plt.text(bar.get_x() + bar.get_width()/2., height,
            f'{height:.4f}', ha='center', va='bottom', fontsize=10)

plt.tight_layout()
plt.show()

print("\n=== 最終結果 ===")
for method, acc in sorted(results.items(), key=lambda x: x[1], reverse=True):
    print(f"{method:20s}: {acc:.4f}")
</code></pre>

<hr>

<h2>1.6 本章のまとめ</h2>

<h3>学んだこと</h3>

<ol>
<li><p><strong>アンサンブル学習の原理</strong></p>
<ul>
<li>複数のモデルを組み合わせて性能向上</li>
<li>バイアス・バリアンス分解</li>
</ul></li>
<li><p><strong>バギング</strong></p>
<ul>
<li>ブートストラップサンプリングと平均化</li>
<li>Random Forest: ランダム特徴量選択で多様性向上</li>
<li>Extra Trees: さらなるランダム化</li>
</ul></li>
<li><p><strong>ブースティング</strong></p>
<ul>
<li>AdaBoost: 誤分類サンプルに注目</li>
<li>Gradient Boosting: 勾配方向への最適化</li>
</ul></li>
<li><p><strong>スタッキング</strong></p>
<ul>
<li>メタ学習器による統合</li>
<li>交差検証による過学習防止</li>
</ul></li>
<li><p><strong>使い分け</strong></p>
<ul>
<li>バギング: バリアンス削減、並列化</li>
<li>ブースティング: バイアス削減、高精度</li>
<li>スタッキング: 最高性能追求</li>
</ul></li>
</ol>

<h3>次の章へ</h3>

<p>第2章では、<strong>勾配ブースティングの発展</strong>を学びます：</p>
<ul>
<li>XGBoost</li>
<li>LightGBM</li>
<li>CatBoost</li>
<li>ハイパーパラメータチューニング</li>
</ul>

<hr>

<h2>演習問題</h2>

<h3>問題1（難易度：easy）</h3>
<p>バイアスとバリアンスの違いを説明し、それぞれを削減するアンサンブル手法を挙げてください。</p>

<details>
<summary>解答例</summary>

<p><strong>バイアス（Bias）</strong>：</p>
<ul>
<li>モデルの単純化による誤差</li>
<li>訓練データに対しても高い誤差</li>
<li>例: 線形モデルで非線形データを予測</li>
</ul>

<p><strong>バリアンス（Variance）</strong>：</p>
<ul>
<li>訓練データの変動への敏感さ</li>
<li>訓練データには良いがテストデータに悪い</li>
<li>例: 深い決定木の過学習</li>
</ul>

<p><strong>削減手法</strong>：</p>
<ul>
<li><strong>バリアンス削減</strong>: バギング、Random Forest（平均化により分散を削減）</li>
<li><strong>バイアス削減</strong>: ブースティング（逐次的に複雑なパターンを学習）</li>
</ul>

</details>

<h3>問題2（難易度：medium）</h3>
<p>Random ForestとExtra Treesの違いを2つ挙げ、それぞれの特徴を説明してください。</p>

<details>
<summary>解答例</summary>

<p><strong>違い1: サンプリング</strong></p>
<ul>
<li><strong>Random Forest</strong>: ブートストラップサンプリング（復元抽出）</li>
<li><strong>Extra Trees</strong>: 全データを使用（サンプリングなし）</li>
</ul>

<p><strong>違い2: 分割方法</strong></p>
<ul>
<li><strong>Random Forest</strong>: ランダムな特徴量サブセットから最適な分割を選択</li>
<li><strong>Extra Trees</strong>: 特徴量も閾値もランダムに選択</li>
</ul>

<p><strong>特徴</strong>：</p>
<ul>
<li><strong>Random Forest</strong>: バリアンス削減、訓練にやや時間</li>
<li><strong>Extra Trees</strong>: より高速、さらなるランダム化により多様性向上</li>
</ul>

</details>

<h3>問題3（難易度：medium）</h3>
<p>AdaBoostで誤分類されたサンプルの重みが増加する理由を、アルゴリズムの観点から説明してください。</p>

<details>
<summary>解答例</summary>

<p><strong>理由</strong>：</p>
<ul>
<li>AdaBoostは、各反復で前のモデルが<strong>苦手なサンプルに注目</strong>するように設計されている</li>
<li>誤分類サンプルの重みを増やすことで、次のモデルはそれらを正しく分類しようとする</li>
</ul>

<p><strong>アルゴリズム</strong>：</p>
<pre><code>誤分類されたサンプル i の重み更新:
w_i ← w_i * exp(α_t)

正しく分類されたサンプル j の重み更新:
w_j ← w_j * exp(-α_t)

ここで α_t = 0.5 * ln((1 - ε_t) / ε_t) > 0
</code></pre>

<p><strong>効果</strong>：</p>
<ul>
<li>弱学習器が順次、困難なサンプルを学習</li>
<li>最終的に複雑な決定境界を形成</li>
</ul>

</details>

<h3>問題4（難易度：hard）</h3>
<p>スタッキングでK-Fold交差検証を使う理由を、過学習の観点から説明してください。</p>

<details>
<summary>解答例</summary>

<p><strong>問題</strong>：訓練データ全体でベースモデルを訓練し、同じデータで予測を生成すると：</p>
<ul>
<li>メタ学習器が訓練データに過学習</li>
<li>ベースモデルの予測が「見たことがあるデータ」に最適化</li>
</ul>

<p><strong>K-Fold交差検証の解決策</strong>：</p>

<pre><code>1. データをK個に分割
2. 各Fold k について:
   - Fold k 以外でベースモデルを訓練
   - Fold k の予測を生成（未知データへの予測）
3. 全Foldの予測を結合してメタ学習器を訓練
</code></pre>

<p><strong>効果</strong>：</p>
<ul>
<li>メタ学習器への入力は「未知データへの予測」</li>
<li>汎化性能が向上</li>
<li>過学習を防止</li>
</ul>

<p><strong>実装例</strong>：</p>
<pre><code class="language-python">StackingClassifier(
    estimators=base_models,
    final_estimator=meta_model,
    cv=5  # 5-Fold交差検証
)
</code></pre>

</details>

<h3>問題5（難易度：hard）</h3>
<p>irisデータセットを使い、Random ForestとGradient Boostingを実装・比較してください。訓練時間と精度を報告してください。</p>

<details>
<summary>解答例</summary>

<pre><code class="language-python">import time
from sklearn.datasets import load_iris
from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.ensemble import RandomForestClassifier, GradientBoostingClassifier
from sklearn.metrics import classification_report

# データ読み込み
iris = load_iris()
X, y = iris.data, iris.target

# データ分割
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, random_state=42
)

# Random Forest
print("=== Random Forest ===")
start = time.time()
rf = RandomForestClassifier(n_estimators=100, random_state=42)
rf.fit(X_train, y_train)
rf_time = time.time() - start

rf_acc = rf.score(X_test, y_test)
cv_rf = cross_val_score(rf, X, y, cv=5).mean()

print(f"訓練時間: {rf_time:.4f}秒")
print(f"テスト精度: {rf_acc:.4f}")
print(f"交差検証精度: {cv_rf:.4f}")

# Gradient Boosting
print("\n=== Gradient Boosting ===")
start = time.time()
gb = GradientBoostingClassifier(n_estimators=100, random_state=42)
gb.fit(X_train, y_train)
gb_time = time.time() - start

gb_acc = gb.score(X_test, y_test)
cv_gb = cross_val_score(gb, X, y, cv=5).mean()

print(f"訓練時間: {gb_time:.4f}秒")
print(f"テスト精度: {gb_acc:.4f}")
print(f"交差検証精度: {cv_gb:.4f}")

# 比較
print("\n=== 比較 ===")
print(f"精度: RF={rf_acc:.4f} vs GB={gb_acc:.4f}")
print(f"訓練時間: RF={rf_time:.4f}秒 vs GB={gb_time:.4f}秒")
print(f"速度比: GB/RF = {gb_time/rf_time:.2f}倍")
</code></pre>

<p><strong>出力例</strong>：</p>
<pre><code>=== Random Forest ===
訓練時間: 0.0523秒
テスト精度: 1.0000
交差検証精度: 0.9533

=== Gradient Boosting ===
訓練時間: 0.1245秒
テスト精度: 1.0000
交差検証精度: 0.9467

=== 比較 ===
精度: RF=1.0000 vs GB=1.0000
訓練時間: RF=0.0523秒 vs GB=0.1245秒
速度比: GB/RF = 2.38倍
</code></pre>

<p><strong>考察</strong>：</p>
<ul>
<li>精度はほぼ同等</li>
<li>Random Forestの方が訓練が高速（並列化可能）</li>
<li>データが小規模で単純なため、両手法とも高精度</li>
</ul>

</details>

<hr>

<h2>参考文献</h2>

<ol>
<li>Breiman, L. (1996). <em>Bagging predictors</em>. Machine Learning, 24(2), 123-140.</li>
<li>Breiman, L. (2001). <em>Random forests</em>. Machine Learning, 45(1), 5-32.</li>
<li>Freund, Y., & Schapire, R. E. (1997). <em>A decision-theoretic generalization of on-line learning and an application to boosting</em>. Journal of Computer and System Sciences, 55(1), 119-139.</li>
<li>Friedman, J. H. (2001). <em>Greedy function approximation: A gradient boosting machine</em>. Annals of Statistics, 1189-1232.</li>
</ol>

<div class="navigation">
    <a href="index.html" class="nav-button">← 目次に戻る</a>
    <a href="chapter2-gradient-boosting.html" class="nav-button">次の章: 勾配ブースティングの発展 →</a>
</div>

    </main>

    <footer>
        <p><strong>作成者</strong>: AI Terakoya Content Team</p>
        <p><strong>監修</strong>: Dr. Yusuke Hashimoto（東北大学）</p>
        <p><strong>バージョン</strong>: 1.0 | <strong>作成日</strong>: 2025-10-21</p>
        <p><strong>ライセンス</strong>: Creative Commons BY 4.0</p>
        <p>© 2025 AI Terakoya. All rights reserved.</p>
    </footer>
</body>
</html>
