<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>第1章：パーセプトロンの基礎 - AI Terakoya</title>

    <style>
        :root {
            --color-primary: #2c3e50;
            --color-primary-dark: #1a252f;
            --color-accent: #7b2cbf;
            --color-accent-light: #9d4edd;
            --color-text: #2d3748;
            --color-text-light: #4a5568;
            --color-bg: #ffffff;
            --color-bg-alt: #f7fafc;
            --color-border: #e2e8f0;
            --color-code-bg: #f8f9fa;
            --color-link: #3182ce;
            --color-link-hover: #2c5aa0;

            --spacing-xs: 0.5rem;
            --spacing-sm: 1rem;
            --spacing-md: 1.5rem;
            --spacing-lg: 2rem;
            --spacing-xl: 3rem;

            --font-body: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            --font-mono: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;

            --border-radius: 8px;
            --box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-body);
            line-height: 1.7;
            color: var(--color-text);
            background-color: var(--color-bg);
            font-size: 16px;
        }

        header {
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            color: white;
            padding: var(--spacing-xl) var(--spacing-md);
            margin-bottom: var(--spacing-xl);
            box-shadow: var(--box-shadow);
        }

        .header-content {
            max-width: 900px;
            margin: 0 auto;
        }

        h1 {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: var(--spacing-sm);
            line-height: 1.2;
        }

        .subtitle {
            font-size: 1.1rem;
            opacity: 0.95;
            font-weight: 400;
            margin-bottom: var(--spacing-md);
        }

        .meta {
            display: flex;
            flex-wrap: wrap;
            gap: var(--spacing-md);
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .meta-item {
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 0 var(--spacing-md) var(--spacing-xl);
        }

        h2 {
            font-size: 1.75rem;
            color: var(--color-primary);
            margin-top: var(--spacing-xl);
            margin-bottom: var(--spacing-md);
            padding-bottom: var(--spacing-xs);
            border-bottom: 3px solid var(--color-accent);
        }

        h3 {
            font-size: 1.4rem;
            color: var(--color-primary);
            margin-top: var(--spacing-lg);
            margin-bottom: var(--spacing-sm);
        }

        h4 {
            font-size: 1.1rem;
            color: var(--color-primary-dark);
            margin-top: var(--spacing-md);
            margin-bottom: var(--spacing-sm);
        }

        p {
            margin-bottom: var(--spacing-md);
            color: var(--color-text);
        }

        a {
            color: var(--color-link);
            text-decoration: none;
            transition: color 0.2s;
        }

        a:hover {
            color: var(--color-link-hover);
            text-decoration: underline;
        }

        ul, ol {
            margin-left: var(--spacing-lg);
            margin-bottom: var(--spacing-md);
        }

        li {
            margin-bottom: var(--spacing-xs);
            color: var(--color-text);
        }

        pre {
            background-color: var(--color-code-bg);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            overflow-x: auto;
            margin-bottom: var(--spacing-md);
            font-family: var(--font-mono);
            font-size: 0.9rem;
            line-height: 1.5;
        }

        code {
            font-family: var(--font-mono);
            font-size: 0.9em;
            background-color: var(--color-code-bg);
            padding: 0.2em 0.4em;
            border-radius: 3px;
        }

        pre code {
            background-color: transparent;
            padding: 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: var(--spacing-md);
            font-size: 0.95rem;
        }

        th, td {
            border: 1px solid var(--color-border);
            padding: var(--spacing-sm);
            text-align: left;
        }

        th {
            background-color: var(--color-bg-alt);
            font-weight: 600;
            color: var(--color-primary);
        }

        blockquote {
            border-left: 4px solid var(--color-accent);
            padding-left: var(--spacing-md);
            margin: var(--spacing-md) 0;
            color: var(--color-text-light);
            font-style: italic;
            background-color: var(--color-bg-alt);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        .mermaid {
            text-align: center;
            margin: var(--spacing-lg) 0;
            background-color: var(--color-bg-alt);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        details {
            background-color: var(--color-bg-alt);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            margin-bottom: var(--spacing-md);
        }

        summary {
            cursor: pointer;
            font-weight: 600;
            color: var(--color-primary);
            user-select: none;
            padding: var(--spacing-xs);
            margin: calc(-1 * var(--spacing-md));
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        summary:hover {
            background-color: rgba(123, 44, 191, 0.1);
        }

        details[open] summary {
            margin-bottom: var(--spacing-md);
            border-bottom: 1px solid var(--color-border);
        }

        .navigation {
            display: flex;
            justify-content: space-between;
            gap: var(--spacing-md);
            margin: var(--spacing-xl) 0;
            padding-top: var(--spacing-lg);
            border-top: 2px solid var(--color-border);
        }

        .nav-button {
            flex: 1;
            padding: var(--spacing-md);
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            color: white;
            border-radius: var(--border-radius);
            text-align: center;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: var(--box-shadow);
        }

        .nav-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            text-decoration: none;
        }

        footer {
            margin-top: var(--spacing-xl);
            padding: var(--spacing-lg) var(--spacing-md);
            background-color: var(--color-bg-alt);
            border-top: 1px solid var(--color-border);
            text-align: center;
            font-size: 0.9rem;
            color: var(--color-text-light);
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.5rem;
            }

            h2 {
                font-size: 1.4rem;
            }

            h3 {
                font-size: 1.2rem;
            }

            .meta {
                font-size: 0.85rem;
            }

            .navigation {
                flex-direction: column;
            }

            table {
                font-size: 0.85rem;
            }

            th, td {
                padding: var(--spacing-xs);
            }
        }
    </style>

    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ startOnLoad: true, theme: 'default' });
    </script>

    <!-- MathJax for LaTeX equation rendering -->
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true,
                processEnvironments: true
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
                ignoreHtmlClass: 'mermaid'
            }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" id="MathJax-script" async></script>
</head>
<body>
    <header>
        <div class="header-content">
            <h1>第1章：パーセプトロンの基礎</h1>
            <p class="subtitle">ニューラルネットワークの原点 - 最も単純な学習モデル</p>
            <div class="meta">
                <span class="meta-item">📖 読了時間: 20-25分</span>
                <span class="meta-item">📊 難易度: 入門</span>
                <span class="meta-item">💻 コード例: 9個</span>
                <span class="meta-item">📝 演習問題: 5問</span>
            </div>
        </div>
    </header>

    <main class="container">

<h2>学習目標</h2>
<p>この章を読むことで、以下を習得できます：</p>
<ul>
<li>✅ パーセプトロンの構造と動作原理を理解する</li>
<li>✅ 重み（weight）とバイアス（bias）の役割を説明できる</li>
<li>✅ 論理ゲート（AND、OR、NAND）をPythonで実装できる</li>
<li>✅ 線形分離可能性の概念を理解する</li>
<li>✅ XOR問題から多層化の必要性を学ぶ</li>
</ul>

<hr>

<h2>1.1 パーセプトロンとは</h2>

<h3>歴史的背景</h3>
<p><strong>パーセプトロン（Perceptron）</strong>は、1957年にフランク・ローゼンブラット（Frank Rosenblatt）によって考案されました。これは人間の脳の神経細胞（ニューロン）を模倣した最初の機械学習アルゴリズムです。</p>

<blockquote>
<p>「パーセプトロンは、複数の信号を入力として受け取り、1つの信号を出力します。入力信号に重みを掛けて合計し、閾値を超えたら発火（出力1）する仕組みです。」</p>
</blockquote>

<h3>パーセプトロンの構造</h3>

<div class="mermaid">
graph LR
    x1[入力 x1] -->|重み w1| sum[Σ 総和]
    x2[入力 x2] -->|重み w2| sum
    b[バイアス b] --> sum
    sum --> activation[活性化関数]
    activation --> y[出力 y]

    style x1 fill:#e3f2fd
    style x2 fill:#e3f2fd
    style sum fill:#fff3e0
    style activation fill:#f3e5f5
    style y fill:#e8f5e9
</div>

<p><strong>数式表現</strong>：</p>
<p>$$
y = \begin{cases}
1 & \text{if } w_1x_1 + w_2x_2 + b > 0 \\
0 & \text{otherwise}
\end{cases}
$$</p>

<p>または、ステップ関数を使って：</p>
<p>$$
y = h(w_1x_1 + w_2x_2 + b)
$$</p>

<p>ここで、$h(x)$はヘビサイド関数（Heaviside function）：</p>
<p>$$
h(x) = \begin{cases}
1 & \text{if } x > 0 \\
0 & \text{otherwise}
\end{cases}
$$</p>

<h3>構成要素の説明</h3>

<table>
<thead>
<tr>
<th>要素</th>
<th>記号</th>
<th>意味</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>入力</strong></td>
<td>$x_1, x_2, \ldots, x_n$</td>
<td>パーセプトロンへの入力信号</td>
</tr>
<tr>
<td><strong>重み</strong></td>
<td>$w_1, w_2, \ldots, w_n$</td>
<td>各入力の重要度（調整可能なパラメータ）</td>
</tr>
<tr>
<td><strong>バイアス</strong></td>
<td>$b$</td>
<td>発火のしやすさ（閾値の調整）</td>
</tr>
<tr>
<td><strong>出力</strong></td>
<td>$y$</td>
<td>0 または 1（二値分類）</td>
</tr>
</tbody>
</table>

<hr>

<h2>1.2 論理ゲートの実装</h2>

<h3>ANDゲート</h3>

<p><strong>真理値表</strong>：</p>

<table>
<thead>
<tr>
<th>x1</th>
<th>x2</th>
<th>y</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>

<p><strong>Python実装</strong>：</p>

<pre><code class="language-python">import numpy as np

def AND(x1, x2):
    """
    ANDゲートの実装
    重み: w1=0.5, w2=0.5
    バイアス: b=-0.7
    """
    x = np.array([x1, x2])
    w = np.array([0.5, 0.5])
    b = -0.7

    # 総和を計算
    tmp = np.sum(w * x) + b

    # 活性化関数（ステップ関数）
    if tmp > 0:
        return 1
    else:
        return 0

# テスト
print("=== ANDゲート ===")
print(f"AND(0, 0) = {AND(0, 0)}")  # 0
print(f"AND(0, 1) = {AND(0, 1)}")  # 0
print(f"AND(1, 0) = {AND(1, 0)}")  # 0
print(f"AND(1, 1) = {AND(1, 1)}")  # 1
</code></pre>

<p><strong>出力</strong>：</p>
<pre><code>=== ANDゲート ===
AND(0, 0) = 0
AND(0, 1) = 0
AND(1, 0) = 0
AND(1, 1) = 1
</code></pre>

<h3>ORゲート</h3>

<p><strong>真理値表</strong>：</p>

<table>
<thead>
<tr>
<th>x1</th>
<th>x2</th>
<th>y</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>

<pre><code class="language-python">def OR(x1, x2):
    """
    ORゲートの実装
    重み: w1=0.5, w2=0.5
    バイアス: b=-0.2
    """
    x = np.array([x1, x2])
    w = np.array([0.5, 0.5])
    b = -0.2  # ANDより発火しやすい

    tmp = np.sum(w * x) + b

    if tmp > 0:
        return 1
    else:
        return 0

# テスト
print("\n=== ORゲート ===")
print(f"OR(0, 0) = {OR(0, 0)}")  # 0
print(f"OR(0, 1) = {OR(0, 1)}")  # 1
print(f"OR(1, 0) = {OR(1, 0)}")  # 1
print(f"OR(1, 1) = {OR(1, 1)}")  # 1
</code></pre>

<h3>NANDゲート</h3>

<p><strong>NAND（NOT AND）</strong>は、ANDの出力を反転させたものです。</p>

<table>
<thead>
<tr>
<th>x1</th>
<th>x2</th>
<th>y</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>

<pre><code class="language-python">def NAND(x1, x2):
    """
    NANDゲートの実装
    重み: w1=-0.5, w2=-0.5（負の重み）
    バイアス: b=0.7
    """
    x = np.array([x1, x2])
    w = np.array([-0.5, -0.5])  # 負の重み
    b = 0.7

    tmp = np.sum(w * x) + b

    if tmp > 0:
        return 1
    else:
        return 0

# テスト
print("\n=== NANDゲート ===")
print(f"NAND(0, 0) = {NAND(0, 0)}")  # 1
print(f"NAND(0, 1) = {NAND(0, 1)}")  # 1
print(f"NAND(1, 0) = {NAND(1, 0)}")  # 1
print(f"NAND(1, 1) = {NAND(1, 1)}")  # 0
</code></pre>

<h3>汎用パーセプトロンクラス</h3>

<pre><code class="language-python">class Perceptron:
    """汎用パーセプトロンクラス"""

    def __init__(self, weights, bias):
        """
        Args:
            weights: 重みのnumpy配列
            bias: バイアス値
        """
        self.w = np.array(weights)
        self.b = bias

    def forward(self, x):
        """
        順伝播（forward propagation）

        Args:
            x: 入力値の配列

        Returns:
            0 または 1
        """
        tmp = np.sum(self.w * x) + self.b
        return 1 if tmp > 0 else 0

    def __call__(self, *inputs):
        """呼び出し可能にする"""
        x = np.array(inputs)
        return self.forward(x)

# パーセプトロンで論理ゲートを定義
and_gate = Perceptron(weights=[0.5, 0.5], bias=-0.7)
or_gate = Perceptron(weights=[0.5, 0.5], bias=-0.2)
nand_gate = Perceptron(weights=[-0.5, -0.5], bias=0.7)

# テスト
print("\n=== 汎用パーセプトロン ===")
print(f"AND(1, 1) = {and_gate(1, 1)}")    # 1
print(f"OR(0, 1) = {or_gate(0, 1)}")      # 1
print(f"NAND(1, 1) = {nand_gate(1, 1)}")  # 0
</code></pre>

<hr>

<h2>1.3 重みとバイアスの役割</h2>

<h3>重み（Weight）の意味</h3>

<p>重みは<strong>入力の重要度</strong>を表します。</p>

<ul>
<li><strong>大きい重み</strong>: その入力が重要</li>
<li><strong>小さい重み</strong>: その入力は重要でない</li>
<li><strong>負の重み</strong>: その入力が出力を抑制</li>
</ul>

<pre><code class="language-python">import matplotlib.pyplot as plt

# 重みを変化させたときの出力
def visualize_weight_effect():
    """重みの効果を可視化"""
    weights = np.linspace(-2, 2, 100)
    x1, x2 = 1, 1
    b = -0.7

    outputs = []
    for w in weights:
        tmp = w * x1 + w * x2 + b
        y = 1 if tmp > 0 else 0
        outputs.append(y)

    plt.figure(figsize=(10, 4))
    plt.plot(weights, outputs, linewidth=2)
    plt.xlabel('Weight (w1 = w2 = w)', fontsize=12)
    plt.ylabel('Output', fontsize=12)
    plt.title('重みの変化とパーセプトロン出力 (x1=1, x2=1, b=-0.7)', fontsize=14)
    plt.grid(True, alpha=0.3)
    plt.ylim(-0.1, 1.1)
    plt.axhline(y=0.5, color='r', linestyle='--', alpha=0.5)
    plt.axvline(x=0.35, color='g', linestyle='--', alpha=0.5, label='閾値')
    plt.legend()
    plt.show()

visualize_weight_effect()
</code></pre>

<h3>バイアス（Bias）の意味</h3>

<p>バイアスは<strong>発火のしやすさ</strong>を調整します。</p>

<ul>
<li><strong>大きいバイアス</strong>: 発火しやすい（出力1になりやすい）</li>
<li><strong>小さいバイアス</strong>: 発火しにくい（出力0になりやすい）</li>
</ul>

<pre><code class="language-python">def compare_bias():
    """バイアスの違いを比較"""
    x1, x2 = 0.5, 0.5
    w1, w2 = 0.5, 0.5

    biases = [-1.0, -0.5, 0.0, 0.5, 1.0]

    print("=== バイアスの効果 ===")
    print(f"入力: x1={x1}, x2={x2}")
    print(f"重み: w1={w1}, w2={w2}")
    print()

    for b in biases:
        tmp = w1*x1 + w2*x2 + b
        y = 1 if tmp > 0 else 0
        print(f"バイアス b={b:5.1f} → 総和={tmp:5.2f} → 出力={y}")

compare_bias()
</code></pre>

<p><strong>出力</strong>：</p>
<pre><code>=== バイアスの効果 ===
入力: x1=0.5, x2=0.5
重み: w1=0.5, w2=0.5

バイアス b= -1.0 → 総和=-0.50 → 出力=0
バイアス b= -0.5 → 総和= 0.00 → 出力=0
バイアス b=  0.0 → 総和= 0.50 → 出力=1
バイアス b=  0.5 → 総和= 1.00 → 出力=1
バイアス b=  1.0 → 総和= 1.50 → 出力=1
</code></pre>

<hr>

<h2>1.4 線形分離可能性</h2>

<h3>概念の説明</h3>

<p><strong>線形分離可能（Linearly Separable）</strong>とは、データを<strong>1本の直線（2次元）または平面（高次元）で分離できる</strong>ことを意味します。</p>

<p>パーセプトロンが学習できるのは、<strong>線形分離可能な問題のみ</strong>です。</p>

<div class="mermaid">
graph LR
    A[線形分離可能] --> B[ANDゲート]
    A --> C[ORゲート]
    A --> D[NANDゲート]
    E[線形分離不可能] --> F[XORゲート]

    style A fill:#e8f5e9
    style E fill:#ffebee
</div>

<h3>ANDゲートの決定境界</h3>

<pre><code class="language-python">import matplotlib.pyplot as plt
import numpy as np

def plot_decision_boundary_AND():
    """ANDゲートの決定境界を可視化"""
    # データ点
    x1 = np.array([0, 0, 1, 1])
    x2 = np.array([0, 1, 0, 1])
    y = np.array([0, 0, 0, 1])  # ANDの出力

    # プロット
    plt.figure(figsize=(8, 6))

    # クラス0（出力0）
    plt.scatter(x1[y==0], x2[y==0], s=200, c='blue', marker='o',
                label='出力 = 0', edgecolors='k', linewidths=2)

    # クラス1（出力1）
    plt.scatter(x1[y==1], x2[y==1], s=200, c='red', marker='s',
                label='出力 = 1', edgecolors='k', linewidths=2)

    # 決定境界: w1*x1 + w2*x2 + b = 0
    # 0.5*x1 + 0.5*x2 - 0.7 = 0
    # x2 = -x1 + 1.4
    x_line = np.linspace(-0.5, 1.5, 100)
    y_line = -x_line + 1.4
    plt.plot(x_line, y_line, 'g--', linewidth=2, label='決定境界')

    # 領域の塗りつぶし
    plt.fill_between(x_line, y_line, 2, alpha=0.2, color='red', label='出力=1の領域')
    plt.fill_between(x_line, -1, y_line, alpha=0.2, color='blue', label='出力=0の領域')

    plt.xlim(-0.5, 1.5)
    plt.ylim(-0.5, 1.5)
    plt.xlabel('x1', fontsize=14)
    plt.ylabel('x2', fontsize=14)
    plt.title('ANDゲートの決定境界', fontsize=16, fontweight='bold')
    plt.grid(True, alpha=0.3)
    plt.legend(fontsize=10, loc='upper right')
    plt.show()

plot_decision_boundary_AND()
</code></pre>

<h3>ORゲートの決定境界</h3>

<pre><code class="language-python">def plot_decision_boundary_OR():
    """ORゲートの決定境界を可視化"""
    # データ点
    x1 = np.array([0, 0, 1, 1])
    x2 = np.array([0, 1, 0, 1])
    y = np.array([0, 1, 1, 1])  # ORの出力

    plt.figure(figsize=(8, 6))

    # クラス0
    plt.scatter(x1[y==0], x2[y==0], s=200, c='blue', marker='o',
                label='出力 = 0', edgecolors='k', linewidths=2)

    # クラス1
    plt.scatter(x1[y==1], x2[y==1], s=200, c='red', marker='s',
                label='出力 = 1', edgecolors='k', linewidths=2)

    # 決定境界: 0.5*x1 + 0.5*x2 - 0.2 = 0
    # x2 = -x1 + 0.4
    x_line = np.linspace(-0.5, 1.5, 100)
    y_line = -x_line + 0.4
    plt.plot(x_line, y_line, 'g--', linewidth=2, label='決定境界')

    plt.fill_between(x_line, y_line, 2, alpha=0.2, color='red')
    plt.fill_between(x_line, -1, y_line, alpha=0.2, color='blue')

    plt.xlim(-0.5, 1.5)
    plt.ylim(-0.5, 1.5)
    plt.xlabel('x1', fontsize=14)
    plt.ylabel('x2', fontsize=14)
    plt.title('ORゲートの決定境界', fontsize=16, fontweight='bold')
    plt.grid(True, alpha=0.3)
    plt.legend(fontsize=10, loc='upper right')
    plt.show()

plot_decision_boundary_OR()
</code></pre>

<hr>

<h2>1.5 XOR問題 - パーセプトロンの限界</h2>

<h3>XORゲートとは</h3>

<p><strong>XOR（Exclusive OR、排他的論理和）</strong>は、「どちらか一方だけが1のときに1を出力」する論理演算です。</p>

<table>
<thead>
<tr>
<th>x1</th>
<th>x2</th>
<th>y</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>

<h3>単層パーセプトロンでは実現できない</h3>

<pre><code class="language-python">def plot_XOR_problem():
    """XOR問題の可視化 - 線形分離不可能"""
    x1 = np.array([0, 0, 1, 1])
    x2 = np.array([0, 1, 0, 1])
    y = np.array([0, 1, 1, 0])  # XORの出力

    plt.figure(figsize=(8, 6))

    # クラス0
    plt.scatter(x1[y==0], x2[y==0], s=200, c='blue', marker='o',
                label='出力 = 0', edgecolors='k', linewidths=2)

    # クラス1
    plt.scatter(x1[y==1], x2[y==1], s=200, c='red', marker='s',
                label='出力 = 1', edgecolors='k', linewidths=2)

    # 線形分離不可能を示す
    plt.text(0.5, 1.3, '1本の直線では\n分離できない！',
             fontsize=14, ha='center',
             bbox=dict(boxstyle='round', facecolor='yellow', alpha=0.5))

    plt.xlim(-0.5, 1.5)
    plt.ylim(-0.5, 1.5)
    plt.xlabel('x1', fontsize=14)
    plt.ylabel('x2', fontsize=14)
    plt.title('XOR問題 - 線形分離不可能', fontsize=16, fontweight='bold')
    plt.grid(True, alpha=0.3)
    plt.legend(fontsize=10, loc='upper right')
    plt.show()

plot_XOR_problem()
</code></pre>

<h3>多層パーセプトロンによる解決</h3>

<p>XOR問題は、<strong>複数のパーセプトロンを組み合わせる</strong>ことで解決できます。</p>

<div class="mermaid">
graph LR
    x1[x1] --> nand[NAND]
    x2[x2] --> nand
    x1 --> or[OR]
    x2 --> or
    nand --> and[AND]
    or --> and
    and --> y[出力 y]

    style x1 fill:#e3f2fd
    style x2 fill:#e3f2fd
    style nand fill:#fff3e0
    style or fill:#fff3e0
    style and fill:#f3e5f5
    style y fill:#e8f5e9
</div>

<pre><code class="language-python">def XOR(x1, x2):
    """
    XORゲートの実装
    NAND、OR、ANDを組み合わせる
    """
    s1 = NAND(x1, x2)
    s2 = OR(x1, x2)
    y = AND(s1, s2)
    return y

# テスト
print("\n=== XORゲート（多層パーセプトロン）===")
print(f"XOR(0, 0) = {XOR(0, 0)}")  # 0
print(f"XOR(0, 1) = {XOR(0, 1)}")  # 1
print(f"XOR(1, 0) = {XOR(1, 0)}")  # 1
print(f"XOR(1, 1) = {XOR(1, 1)}")  # 0
</code></pre>

<p><strong>出力</strong>：</p>
<pre><code>=== XORゲート（多層パーセプトロン）===
XOR(0, 0) = 0
XOR(0, 1) = 1
XOR(1, 0) = 1
XOR(1, 1) = 0
</code></pre>

<h3>多層化による表現力の向上</h3>

<blockquote>
<p><strong>重要な洞察</strong>: パーセプトロンを<strong>多層化</strong>することで、線形分離不可能な問題も解けるようになります。これが<strong>ニューラルネットワーク</strong>の本質です。</p>
</blockquote>

<hr>

<h2>1.6 本章のまとめ</h2>

<h3>学んだこと</h3>

<ol>
<li><p><strong>パーセプトロンの構造</strong></p>
<ul>
<li>入力、重み、バイアス、活性化関数、出力</li>
<li>数式: $y = h(w_1x_1 + w_2x_2 + b)$</li>
</ul></li>
<li><p><strong>論理ゲートの実装</strong></p>
<ul>
<li>AND、OR、NANDは単層パーセプトロンで実現可能</li>
<li>重みとバイアスを適切に設定することで実装</li>
</ul></li>
<li><p><strong>重みとバイアスの役割</strong></p>
<ul>
<li>重み: 入力の重要度</li>
<li>バイアス: 発火のしやすさ</li>
</ul></li>
<li><p><strong>線形分離可能性</strong></p>
<ul>
<li>パーセプトロンは線形分離可能な問題のみ解ける</li>
<li>決定境界は直線（2D）または超平面（高次元）</li>
</ul></li>
<li><p><strong>XOR問題と多層化</strong></p>
<ul>
<li>XORは線形分離不可能</li>
<li>多層パーセプトロンで解決可能</li>
<li>これがディープラーニングへの道</li>
</ul></li>
</ol>

<h3>重要なポイント</h3>

<table>
<thead>
<tr>
<th>概念</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>パーセプトロン</strong></td>
<td>最も単純なニューラルネットワーク</td>
</tr>
<tr>
<td><strong>重み</strong></td>
<td>調整可能なパラメータ、学習の対象</td>
</tr>
<tr>
<td><strong>バイアス</strong></td>
<td>閾値の調整、発火しやすさ</td>
</tr>
<tr>
<td><strong>活性化関数</strong></td>
<td>ステップ関数（ヘビサイド関数）</td>
</tr>
<tr>
<td><strong>線形分離可能性</strong></td>
<td>単層パーセプトロンの限界</td>
</tr>
<tr>
<td><strong>多層化</strong></td>
<td>表現力の向上、非線形問題を解決</td>
</tr>
</tbody>
</table>

<h3>次の章へ</h3>

<p>第2章では、<strong>多層パーセプトロン（MLP）と誤差逆伝播法</strong>を学びます：</p>
<ul>
<li>多層ネットワークの構造</li>
<li>誤差逆伝播法（Backpropagation）</li>
<li>勾配降下法による学習</li>
<li>NumPyによる完全実装</li>
</ul>

<hr>

<h2>演習問題</h2>

<h3>問題1（難易度：easy）</h3>
<p>以下の文章の正誤を判定してください。</p>
<ol>
<li>パーセプトロンは重みとバイアスを持つ</li>
<li>ANDゲートは単層パーセプトロンで実装できる</li>
<li>XORゲートは単層パーセプトロンで実装できる</li>
<li>バイアスが大きいほど発火しにくい</li>
</ol>

<details>
<summary>解答例</summary>

<p><strong>解答</strong>：</p>
<ol>
<li><strong>正</strong> - パーセプトロンの基本構造</li>
<li><strong>正</strong> - 線形分離可能なため実装可能</li>
<li><strong>誤</strong> - XORは線形分離不可能、多層化が必要</li>
<li><strong>誤</strong> - バイアスが大きいほど発火<strong>しやすい</strong></li>
</ol>

</details>

<h3>問題2（難易度：medium）</h3>
<p>NORゲート（NOT OR）を実装してください。真理値表は以下の通りです：</p>

<table>
<thead>
<tr>
<th>x1</th>
<th>x2</th>
<th>y</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>

<details>
<summary>ヒント</summary>

<ul>
<li>ORの出力を反転させる</li>
<li>負の重みを使用する</li>
<li>適切なバイアスを設定する</li>
</ul>

</details>

<details>
<summary>解答例</summary>

<pre><code class="language-python">def NOR(x1, x2):
    """
    NORゲートの実装
    重み: w1=-0.5, w2=-0.5
    バイアス: b=0.2
    """
    x = np.array([x1, x2])
    w = np.array([-0.5, -0.5])
    b = 0.2

    tmp = np.sum(w * x) + b

    if tmp > 0:
        return 1
    else:
        return 0

# テスト
print("=== NORゲート ===")
for x1, x2 in [(0,0), (0,1), (1,0), (1,1)]:
    y = NOR(x1, x2)
    print(f"NOR({x1}, {x2}) = {y}")
</code></pre>

<p><strong>出力</strong>：</p>
<pre><code>=== NORゲート ===
NOR(0, 0) = 1
NOR(0, 1) = 0
NOR(1, 0) = 0
NOR(1, 1) = 0
</code></pre>

</details>

<h3>問題3（難易度：medium）</h3>
<p>3入力ANDゲートを実装してください。出力は、3つの入力がすべて1のときのみ1になります。</p>

<details>
<summary>解答例</summary>

<pre><code class="language-python">def AND3(x1, x2, x3):
    """
    3入力ANDゲートの実装
    重み: w1=0.5, w2=0.5, w3=0.5
    バイアス: b=-1.2
    """
    x = np.array([x1, x2, x3])
    w = np.array([0.5, 0.5, 0.5])
    b = -1.2  # 3つの入力の合計が1.5になるときのみ発火

    tmp = np.sum(w * x) + b

    if tmp > 0:
        return 1
    else:
        return 0

# テスト
print("=== 3入力ANDゲート ===")
for x1 in [0, 1]:
    for x2 in [0, 1]:
        for x3 in [0, 1]:
            y = AND3(x1, x2, x3)
            print(f"AND3({x1}, {x2}, {x3}) = {y}")
</code></pre>

<p><strong>出力</strong>：</p>
<pre><code>=== 3入力ANDゲート ===
AND3(0, 0, 0) = 0
AND3(0, 0, 1) = 0
AND3(0, 1, 0) = 0
AND3(0, 1, 1) = 0
AND3(1, 0, 0) = 0
AND3(1, 0, 1) = 0
AND3(1, 1, 0) = 0
AND3(1, 1, 1) = 1
</code></pre>

</details>

<h3>問題4（難易度：hard）</h3>
<p>XNOR（XORの否定）ゲートを多層パーセプトロンで実装してください。真理値表：</p>

<table>
<thead>
<tr>
<th>x1</th>
<th>x2</th>
<th>y</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>

<details>
<summary>ヒント</summary>

<ul>
<li>XORゲートの出力を反転させる</li>
<li>OR、NAND、NANDの組み合わせも可能</li>
</ul>

</details>

<details>
<summary>解答例</summary>

<pre><code class="language-python">def XNOR_v1(x1, x2):
    """
    XNORゲート（方法1）: XORの出力を反転
    """
    xor_out = XOR(x1, x2)
    # 反転するにはNOTゲート（NANDで実現可能）
    return 1 if xor_out == 0 else 0

def XNOR_v2(x1, x2):
    """
    XNORゲート（方法2）: OR、NAND、NANDの組み合わせ
    """
    s1 = OR(x1, x2)
    s2 = NAND(x1, x2)
    y = NAND(s1, s2)
    return y

# テスト
print("=== XNORゲート ===")
print("方法1（XOR + NOT）:")
for x1, x2 in [(0,0), (0,1), (1,0), (1,1)]:
    y = XNOR_v1(x1, x2)
    print(f"XNOR({x1}, {x2}) = {y}")

print("\n方法2（OR + NAND + NAND）:")
for x1, x2 in [(0,0), (0,1), (1,0), (1,1)]:
    y = XNOR_v2(x1, x2)
    print(f"XNOR({x1}, {x2}) = {y}")
</code></pre>

</details>

<h3>問題5（難易度：hard）</h3>
<p>パーセプトロンを使って簡単な分類問題を解いてください。以下のデータを正しく分類する重みとバイアスを見つけてください：</p>

<ul>
<li>クラス0: (0, 0), (0, 1)</li>
<li>クラス1: (1, 0), (1, 1)</li>
</ul>

<details>
<summary>解答例</summary>

<pre><code class="language-python">def custom_classifier(x1, x2):
    """
    カスタム分類器
    x1が重要な特徴
    """
    w1 = 1.0  # x1を重視
    w2 = 0.0  # x2は無視
    b = -0.5

    tmp = w1*x1 + w2*x2 + b
    return 1 if tmp > 0 else 0

# テスト
print("=== カスタム分類器 ===")
data = [
    ((0, 0), 0),
    ((0, 1), 0),
    ((1, 0), 1),
    ((1, 1), 1)
]

correct = 0
for (x1, x2), expected in data:
    pred = custom_classifier(x1, x2)
    result = "✓" if pred == expected else "✗"
    print(f"入力({x1}, {x2}) → 予測={pred}, 正解={expected} {result}")
    if pred == expected:
        correct += 1

print(f"\n精度: {correct}/{len(data)} = {100*correct/len(data):.1f}%")
</code></pre>

<p><strong>解説</strong>：</p>
<ul>
<li>この問題では、x1の値だけで分類可能</li>
<li>x1=0 → クラス0、x1=1 → クラス1</li>
<li>従って、w1を大きく、w2を小さく（または0に）設定</li>
</ul>

</details>

<hr>

<h2>参考文献</h2>

<ol>
<li>Rosenblatt, F. (1958). "The Perceptron: A Probabilistic Model for Information Storage and Organization in the Brain." <em>Psychological Review</em>, 65(6), 386-408.</li>
<li>Minsky, M., & Papert, S. (1969). <em>Perceptrons: An Introduction to Computational Geometry</em>. MIT Press.</li>
<li>斎藤康毅 (2016). 『ゼロから作るDeep Learning』オライリージャパン.</li>
</ol>

<div class="navigation">
    <a href="index.html" class="nav-button">← シリーズ目次</a>
    <a href="chapter2-mlp.html" class="nav-button">次の章: 多層パーセプトロン →</a>
</div>

    </main>

    <footer>
        <p><strong>作成者</strong>: AI Terakoya Content Team</p>
        <p><strong>バージョン</strong>: 1.0 | <strong>作成日</strong>: 2025-10-20</p>
        <p><strong>ライセンス</strong>: Creative Commons BY 4.0</p>
        <p>© 2025 AI Terakoya. All rights reserved.</p>
    </footer>
</body>
</html>
