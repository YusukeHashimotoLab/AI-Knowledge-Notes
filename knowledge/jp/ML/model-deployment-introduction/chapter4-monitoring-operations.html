<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>第4章：モニタリングと運用 - AI Terakoya</title>

    <style>
        :root {
            --color-primary: #2c3e50;
            --color-primary-dark: #1a252f;
            --color-accent: #7b2cbf;
            --color-accent-light: #9d4edd;
            --color-text: #2d3748;
            --color-text-light: #4a5568;
            --color-bg: #ffffff;
            --color-bg-alt: #f7fafc;
            --color-border: #e2e8f0;
            --color-code-bg: #f8f9fa;
            --color-link: #3182ce;
            --color-link-hover: #2c5aa0;

            --spacing-xs: 0.5rem;
            --spacing-sm: 1rem;
            --spacing-md: 1.5rem;
            --spacing-lg: 2rem;
            --spacing-xl: 3rem;

            --font-body: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            --font-mono: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;

            --border-radius: 8px;
            --box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-body);
            line-height: 1.7;
            color: var(--color-text);
            background-color: var(--color-bg);
            font-size: 16px;
        }

        header {
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            color: white;
            padding: var(--spacing-xl) var(--spacing-md);
            margin-bottom: var(--spacing-xl);
            box-shadow: var(--box-shadow);
        }

        .header-content {
            max-width: 900px;
            margin: 0 auto;
        }

        h1 {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: var(--spacing-sm);
            line-height: 1.2;
        }

        .subtitle {
            font-size: 1.1rem;
            opacity: 0.95;
            font-weight: 400;
            margin-bottom: var(--spacing-md);
        }

        .meta {
            display: flex;
            flex-wrap: wrap;
            gap: var(--spacing-md);
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .meta-item {
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 0 var(--spacing-md) var(--spacing-xl);
        }

        h2 {
            font-size: 1.75rem;
            color: var(--color-primary);
            margin-top: var(--spacing-xl);
            margin-bottom: var(--spacing-md);
            padding-bottom: var(--spacing-xs);
            border-bottom: 3px solid var(--color-accent);
        }

        h3 {
            font-size: 1.4rem;
            color: var(--color-primary);
            margin-top: var(--spacing-lg);
            margin-bottom: var(--spacing-sm);
        }

        h4 {
            font-size: 1.1rem;
            color: var(--color-primary-dark);
            margin-top: var(--spacing-md);
            margin-bottom: var(--spacing-sm);
        }

        p {
            margin-bottom: var(--spacing-md);
            color: var(--color-text);
        }

        a {
            color: var(--color-link);
            text-decoration: none;
            transition: color 0.2s;
        }

        a:hover {
            color: var(--color-link-hover);
            text-decoration: underline;
        }

        ul, ol {
            margin-left: var(--spacing-lg);
            margin-bottom: var(--spacing-md);
        }

        li {
            margin-bottom: var(--spacing-xs);
            color: var(--color-text);
        }

        pre {
            background-color: var(--color-code-bg);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            overflow-x: auto;
            margin-bottom: var(--spacing-md);
            font-family: var(--font-mono);
            font-size: 0.9rem;
            line-height: 1.5;
        }

        code {
            font-family: var(--font-mono);
            font-size: 0.9em;
            background-color: var(--color-code-bg);
            padding: 0.2em 0.4em;
            border-radius: 3px;
        }

        pre code {
            background-color: transparent;
            padding: 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: var(--spacing-md);
            font-size: 0.95rem;
        }

        th, td {
            border: 1px solid var(--color-border);
            padding: var(--spacing-sm);
            text-align: left;
        }

        th {
            background-color: var(--color-bg-alt);
            font-weight: 600;
            color: var(--color-primary);
        }

        blockquote {
            border-left: 4px solid var(--color-accent);
            padding-left: var(--spacing-md);
            margin: var(--spacing-md) 0;
            color: var(--color-text-light);
            font-style: italic;
            background-color: var(--color-bg-alt);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        .mermaid {
            text-align: center;
            margin: var(--spacing-lg) 0;
            background-color: var(--color-bg-alt);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        details {
            background-color: var(--color-bg-alt);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            margin-bottom: var(--spacing-md);
        }

        summary {
            cursor: pointer;
            font-weight: 600;
            color: var(--color-primary);
            user-select: none;
            padding: var(--spacing-xs);
            margin: calc(-1 * var(--spacing-md));
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        summary:hover {
            background-color: rgba(123, 44, 191, 0.1);
        }

        details[open] summary {
            margin-bottom: var(--spacing-md);
            border-bottom: 1px solid var(--color-border);
        }

        .navigation {
            display: flex;
            justify-content: space-between;
            gap: var(--spacing-md);
            margin: var(--spacing-xl) 0;
            padding-top: var(--spacing-lg);
            border-top: 2px solid var(--color-border);
        }

        .nav-button {
            flex: 1;
            padding: var(--spacing-md);
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            color: white;
            border-radius: var(--border-radius);
            text-align: center;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: var(--box-shadow);
        }

        .nav-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            text-decoration: none;
        }

        footer {
            margin-top: var(--spacing-xl);
            padding: var(--spacing-lg) var(--spacing-md);
            background-color: var(--color-bg-alt);
            border-top: 1px solid var(--color-border);
            text-align: center;
            font-size: 0.9rem;
            color: var(--color-text-light);
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.5rem;
            }

            h2 {
                font-size: 1.4rem;
            }

            h3 {
                font-size: 1.2rem;
            }

            .meta {
                font-size: 0.85rem;
            }

            .navigation {
                flex-direction: column;
            }

            table {
                font-size: 0.85rem;
            }

            th, td {
                padding: var(--spacing-xs);
            }
        }
    </style>

    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ startOnLoad: true, theme: 'default' });
    </script>

    <!-- MathJax for LaTeX equation rendering -->
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true,
                processEnvironments: true
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
                ignoreHtmlClass: 'mermaid'
            }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" id="MathJax-script" async></script>
</head>
<body>
    <header>
        <div class="header-content">
            <h1>第4章：モニタリングと運用</h1>
            <p class="subtitle">本番環境での継続的な監視と改善</p>
            <div class="meta">
                <span class="meta-item">📖 読了時間: 25-30分</span>
                <span class="meta-item">📊 難易度: 中級〜上級</span>
                <span class="meta-item">💻 コード例: 8個</span>
                <span class="meta-item">📝 演習問題: 5問</span>
            </div>
        </div>
    </header>

    <main class="container">

<h2>学習目標</h2>
<p>この章を読むことで、以下を習得できます：</p>
<ul>
<li>✅ 構造化ログとモニタリングシステムを構築できる</li>
<li>✅ Prometheus + Grafanaでメトリクス監視を実装できる</li>
<li>✅ データドリフトとモデルドリフトを検出できる</li>
<li>✅ A/Bテストとカナリアデプロイを実装できる</li>
<li>✅ モデル更新と再訓練のパイプラインを設計できる</li>
<li>✅ 本番運用のベストプラクティスを適用できる</li>
</ul>

<hr>

<h2>4.1 ログとモニタリング</h2>

<h3>構造化ログ（JSON Logging）</h3>

<p><strong>構造化ログ</strong>は、機械可読な形式（JSON）でログを記録し、分析と検索を容易にします。</p>

<pre><code class="language-python">import json
import logging
from datetime import datetime
from typing import Dict, Any

class JSONFormatter(logging.Formatter):
    """構造化JSONログのカスタムフォーマッター"""

    def format(self, record: logging.LogRecord) -> str:
        log_data = {
            'timestamp': datetime.utcnow().isoformat(),
            'level': record.levelname,
            'logger': record.name,
            'message': record.getMessage(),
            'module': record.module,
            'function': record.funcName,
            'line': record.lineno
        }

        # 追加のカスタムフィールド
        if hasattr(record, 'prediction_id'):
            log_data['prediction_id'] = record.prediction_id
        if hasattr(record, 'model_version'):
            log_data['model_version'] = record.model_version
        if hasattr(record, 'latency_ms'):
            log_data['latency_ms'] = record.latency_ms
        if hasattr(record, 'input_features'):
            log_data['input_features'] = record.input_features

        # 例外情報
        if record.exc_info:
            log_data['exception'] = self.formatException(record.exc_info)

        return json.dumps(log_data)


# ロガーのセットアップ
def setup_logger(name: str, log_file: str = 'model_predictions.log') -> logging.Logger:
    """構造化ログを使用するロガーを設定"""
    logger = logging.getLogger(name)
    logger.setLevel(logging.INFO)

    # ファイルハンドラー
    file_handler = logging.FileHandler(log_file)
    file_handler.setFormatter(JSONFormatter())

    # コンソールハンドラー（開発用）
    console_handler = logging.StreamHandler()
    console_handler.setFormatter(
        logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    )

    logger.addHandler(file_handler)
    logger.addHandler(console_handler)

    return logger


# 使用例
logger = setup_logger('ml_model')

# 通常のログ
logger.info('Model service started')

# 予測ログ（追加メタデータ付き）
import time
start_time = time.time()

# ... 予測処理 ...

logger.info(
    'Prediction completed',
    extra={
        'prediction_id': 'pred-12345',
        'model_version': 'v1.2.0',
        'latency_ms': (time.time() - start_time) * 1000,
        'input_features': {'age': 35, 'income': 50000}
    }
)

print("\n=== 構造化ログの例 ===")
print("ログは model_predictions.log に JSON形式で保存されます")
</code></pre>

<p><strong>出力されるJSONログ</strong>：</p>
<pre><code class="language-json">{
  "timestamp": "2025-10-23T12:34:56.789012",
  "level": "INFO",
  "logger": "ml_model",
  "message": "Prediction completed",
  "module": "main",
  "function": "predict",
  "line": 42,
  "prediction_id": "pred-12345",
  "model_version": "v1.2.0",
  "latency_ms": 123.45,
  "input_features": {"age": 35, "income": 50000}
}
</code></pre>

<h3>Prometheus + Grafanaセットアップ</h3>

<p><strong>Prometheus</strong>は時系列データベース、<strong>Grafana</strong>は可視化ツールです。</p>

<h4>Prometheusメトリクスの実装</h4>

<pre><code class="language-python">from prometheus_client import Counter, Histogram, Gauge, start_http_server
import time
import random

# メトリクスの定義
prediction_counter = Counter(
    'model_predictions_total',
    'Total number of predictions',
    ['model_version', 'status']
)

prediction_latency = Histogram(
    'model_prediction_latency_seconds',
    'Prediction latency in seconds',
    ['model_version'],
    buckets=(0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1.0, 2.5, 5.0, 10.0)
)

active_predictions = Gauge(
    'model_active_predictions',
    'Number of predictions currently being processed'
)

model_accuracy = Gauge(
    'model_accuracy',
    'Current model accuracy',
    ['model_version']
)


class ModelMonitor:
    """モデル予測のモニタリングクラス"""

    def __init__(self, model_version: str = 'v1.0.0'):
        self.model_version = model_version

    def predict_with_monitoring(self, features: dict) -> dict:
        """モニタリング付き予測"""
        active_predictions.inc()  # アクティブ予測数を増やす

        try:
            # 予測時間の計測
            with prediction_latency.labels(model_version=self.model_version).time():
                # 実際の予測処理（ダミー）
                time.sleep(random.uniform(0.01, 0.2))
                prediction = random.choice([0, 1])
                confidence = random.uniform(0.6, 0.99)

            # 成功カウント
            prediction_counter.labels(
                model_version=self.model_version,
                status='success'
            ).inc()

            return {
                'prediction': prediction,
                'confidence': confidence,
                'model_version': self.model_version
            }

        except Exception as e:
            # エラーカウント
            prediction_counter.labels(
                model_version=self.model_version,
                status='error'
            ).inc()
            raise

        finally:
            active_predictions.dec()  # アクティブ予測数を減らす

    def update_accuracy(self, accuracy: float):
        """モデル精度の更新"""
        model_accuracy.labels(model_version=self.model_version).set(accuracy)


# メトリクスサーバーの起動
print("Starting Prometheus metrics server on port 8000...")
start_http_server(8000)

# 使用例
monitor = ModelMonitor(model_version='v1.2.0')

# 複数の予測を実行
print("\n=== 予測実行とメトリクス収集 ===")
for i in range(10):
    result = monitor.predict_with_monitoring({'feature1': i})
    print(f"予測 {i+1}: {result['prediction']} (信頼度: {result['confidence']:.2f})")
    time.sleep(0.1)

# 精度を更新
monitor.update_accuracy(0.92)
print(f"\nモデル精度を更新: 92%")
print(f"\nメトリクスは http://localhost:8000/metrics で確認できます")
</code></pre>

<h4>Prometheus設定ファイル（prometheus.yml）</h4>

<pre><code class="language-yaml">global:
  scrape_interval: 15s
  evaluation_interval: 15s

scrape_configs:
  - job_name: 'ml_model'
    static_configs:
      - targets: ['localhost:8000']
        labels:
          environment: 'production'
          service: 'recommendation_model'
</code></pre>

<h3>カスタムメトリクス</h3>

<pre><code class="language-python">from prometheus_client import Summary, Info
import numpy as np
from typing import List

# より詳細なメトリクス
prediction_score_summary = Summary(
    'model_prediction_score',
    'Distribution of prediction scores',
    ['model_version']
)

feature_summary = Summary(
    'model_input_feature_value',
    'Distribution of input feature values',
    ['feature_name']
)

model_info = Info(
    'model_metadata',
    'Model metadata information'
)


class AdvancedModelMonitor:
    """高度なモニタリング機能"""

    def __init__(self, model_version: str):
        self.model_version = model_version

        # モデルメタデータの設定
        model_info.info({
            'version': model_version,
            'framework': 'scikit-learn',
            'algorithm': 'RandomForest',
            'trained_date': '2025-10-20'
        })

    def track_prediction(self, features: dict, prediction_score: float):
        """予測スコアと特徴量を追跡"""
        # 予測スコアの分布
        prediction_score_summary.labels(
            model_version=self.model_version
        ).observe(prediction_score)

        # 各特徴量の分布
        for feature_name, value in features.items():
            if isinstance(value, (int, float)):
                feature_summary.labels(
                    feature_name=feature_name
                ).observe(value)

    def track_batch_predictions(self, batch_features: List[dict],
                               batch_scores: List[float]):
        """バッチ予測の追跡"""
        for features, score in zip(batch_features, batch_scores):
            self.track_prediction(features, score)


# 使用例
advanced_monitor = AdvancedModelMonitor(model_version='v1.2.0')

# バッチ予測のシミュレーション
print("\n=== バッチ予測のモニタリング ===")
batch_size = 100
batch_features = [
    {
        'age': np.random.randint(18, 80),
        'income': np.random.randint(20000, 150000),
        'credit_score': np.random.randint(300, 850)
    }
    for _ in range(batch_size)
]
batch_scores = np.random.beta(5, 2, batch_size).tolist()

advanced_monitor.track_batch_predictions(batch_features, batch_scores)
print(f"{batch_size}件の予測を追跡しました")
</code></pre>

<h3>アラート設定</h3>

<h4>Prometheusアラートルール（alerts.yml）</h4>

<pre><code class="language-yaml">groups:
  - name: ml_model_alerts
    interval: 30s
    rules:
      # レイテンシアラート
      - alert: HighPredictionLatency
        expr: histogram_quantile(0.95, rate(model_prediction_latency_seconds_bucket[5m])) > 1.0
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "High prediction latency detected"
          description: "95th percentile latency is {{ $value }}s (threshold: 1.0s)"

      # エラー率アラート
      - alert: HighErrorRate
        expr: rate(model_predictions_total{status="error"}[5m]) / rate(model_predictions_total[5m]) > 0.05
        for: 5m
        labels:
          severity: critical
        annotations:
          summary: "High error rate detected"
          description: "Error rate is {{ $value | humanizePercentage }} (threshold: 5%)"

      # 精度低下アラート
      - alert: ModelAccuracyDrop
        expr: model_accuracy < 0.85
        for: 10m
        labels:
          severity: critical
        annotations:
          summary: "Model accuracy dropped below threshold"
          description: "Current accuracy is {{ $value }} (threshold: 0.85)"

      # トラフィック急増アラート
      - alert: TrafficSpike
        expr: rate(model_predictions_total[5m]) > 1000
        for: 2m
        labels:
          severity: warning
        annotations:
          summary: "Unexpected traffic spike"
          description: "Request rate is {{ $value }} req/s (threshold: 1000 req/s)"
</code></pre>

<hr>

<h2>4.2 モデルパフォーマンス追跡</h2>

<h3>データドリフト検出</h3>

<p><strong>データドリフト</strong>は、入力データの分布が時間とともに変化する現象です。</p>

<pre><code class="language-python">import numpy as np
import pandas as pd
from scipy.stats import ks_2samp, chi2_contingency
from typing import Tuple, Dict
import warnings

class DataDriftDetector:
    """データドリフト検出器"""

    def __init__(self, reference_data: pd.DataFrame, threshold: float = 0.05):
        """
        Args:
            reference_data: 基準データ（訓練データ）
            threshold: 統計的有意水準（デフォルト: 0.05）
        """
        self.reference_data = reference_data
        self.threshold = threshold

    def detect_drift_numerical(self, current_data: pd.DataFrame,
                               feature: str) -> Tuple[bool, float]:
        """
        数値特徴量のドリフト検出（Kolmogorov-Smirnov検定）

        Returns:
            (ドリフト有無, p値)
        """
        ref_values = self.reference_data[feature].dropna()
        cur_values = current_data[feature].dropna()

        # KS検定
        statistic, p_value = ks_2samp(ref_values, cur_values)

        # p値が閾値より小さい場合、ドリフトあり
        drift_detected = p_value < self.threshold

        return drift_detected, p_value

    def detect_drift_categorical(self, current_data: pd.DataFrame,
                                 feature: str) -> Tuple[bool, float]:
        """
        カテゴリカル特徴量のドリフト検出（カイ二乗検定）

        Returns:
            (ドリフト有無, p値)
        """
        ref_counts = self.reference_data[feature].value_counts()
        cur_counts = current_data[feature].value_counts()

        # 共通のカテゴリを取得
        all_categories = set(ref_counts.index) | set(cur_counts.index)

        # 度数表の作成
        ref_freq = [ref_counts.get(cat, 0) for cat in all_categories]
        cur_freq = [cur_counts.get(cat, 0) for cat in all_categories]

        # カイ二乗検定
        contingency_table = [ref_freq, cur_freq]

        with warnings.catch_warnings():
            warnings.simplefilter("ignore")
            chi2, p_value, dof, expected = chi2_contingency(contingency_table)

        drift_detected = p_value < self.threshold

        return drift_detected, p_value

    def detect_all_features(self, current_data: pd.DataFrame) -> Dict[str, dict]:
        """全特徴量のドリフト検出"""
        results = {}

        for feature in self.reference_data.columns:
            try:
                # データ型に応じて検定方法を選択
                if pd.api.types.is_numeric_dtype(self.reference_data[feature]):
                    drift, p_value = self.detect_drift_numerical(current_data, feature)
                    method = 'KS-test'
                else:
                    drift, p_value = self.detect_drift_categorical(current_data, feature)
                    method = 'Chi-squared'

                results[feature] = {
                    'drift_detected': drift,
                    'p_value': p_value,
                    'method': method
                }
            except Exception as e:
                results[feature] = {
                    'drift_detected': None,
                    'p_value': None,
                    'error': str(e)
                }

        return results


# サンプルデータでのデモ
np.random.seed(42)

# 基準データ（訓練時のデータ）
reference_data = pd.DataFrame({
    'age': np.random.normal(45, 12, 1000),
    'income': np.random.normal(60000, 15000, 1000),
    'category': np.random.choice(['A', 'B', 'C'], 1000, p=[0.5, 0.3, 0.2])
})

# 現在のデータ（ドリフトあり）
current_data = pd.DataFrame({
    'age': np.random.normal(40, 12, 1000),  # 平均が変化
    'income': np.random.normal(60000, 15000, 1000),  # 変化なし
    'category': np.random.choice(['A', 'B', 'C'], 1000, p=[0.3, 0.4, 0.3])  # 分布が変化
})

# ドリフト検出
detector = DataDriftDetector(reference_data, threshold=0.05)
drift_results = detector.detect_all_features(current_data)

print("=== データドリフト検出結果 ===\n")
for feature, result in drift_results.items():
    if 'error' not in result:
        status = "ドリフト検出" if result['drift_detected'] else "正常"
        print(f"{feature}:")
        print(f"  状態: {status}")
        print(f"  p値: {result['p_value']:.4f}")
        print(f"  検定方法: {result['method']}\n")
</code></pre>

<h3>Evidently AIの活用</h3>

<p><strong>Evidently AI</strong>は、MLモデルのモニタリングとドリフト検出のための専用ライブラリです。</p>

<pre><code class="language-python"># Evidently AIを使用したドリフト検出
# pip install evidently

from evidently.report import Report
from evidently.metric_preset import DataDriftPreset, DataQualityPreset
from evidently.test_suite import TestSuite
from evidently.test_preset import DataDriftTestPreset
import pandas as pd
import numpy as np

# サンプルデータ生成
np.random.seed(42)
n_samples = 1000

reference = pd.DataFrame({
    'age': np.random.normal(45, 12, n_samples),
    'income': np.random.normal(60000, 15000, n_samples),
    'credit_score': np.random.normal(700, 50, n_samples),
    'target': np.random.binomial(1, 0.3, n_samples)
})

# ドリフトを含む現在のデータ
current = pd.DataFrame({
    'age': np.random.normal(42, 12, n_samples),  # ドリフト
    'income': np.random.normal(65000, 18000, n_samples),  # ドリフト
    'credit_score': np.random.normal(700, 50, n_samples),  # 正常
    'target': np.random.binomial(1, 0.35, n_samples)  # ドリフト
})

# データドリフトレポート生成
data_drift_report = Report(metrics=[
    DataDriftPreset(),
])

data_drift_report.run(reference_data=reference, current_data=current)

# HTMLレポート保存
data_drift_report.save_html('data_drift_report.html')

print("=== Evidently AI データドリフトレポート ===")
print("レポートは data_drift_report.html に保存されました")
print("\n主要な検出結果:")
print(f"- 年齢: ドリフト検出の可能性あり")
print(f"- 収入: ドリフト検出の可能性あり")
print(f"- クレジットスコア: 正常")

# データドリフトテスト
data_drift_test = TestSuite(tests=[
    DataDriftTestPreset(),
])

data_drift_test.run(reference_data=reference, current_data=current)

# テスト結果をJSON形式で取得
test_results = data_drift_test.as_dict()

print(f"\nテスト合格: {test_results['summary']['success']}")
print(f"総テスト数: {test_results['summary']['total']}")
print(f"失敗テスト数: {test_results['summary']['failed']}")
</code></pre>

<h3>モデルドリフト検出</h3>

<p><strong>モデルドリフト</strong>は、モデルの予測性能が時間とともに低下する現象です。</p>

<pre><code class="language-python">import numpy as np
from sklearn.metrics import accuracy_score, roc_auc_score
from collections import deque
from typing import List, Optional
import datetime

class ModelPerformanceMonitor:
    """モデル性能のリアルタイムモニタリング"""

    def __init__(self, window_size: int = 1000, alert_threshold: float = 0.05):
        """
        Args:
            window_size: モニタリングウィンドウサイズ
            alert_threshold: アラート発生の閾値（性能低下率）
        """
        self.window_size = window_size
        self.alert_threshold = alert_threshold

        # 履歴データ
        self.predictions = deque(maxlen=window_size)
        self.actuals = deque(maxlen=window_size)
        self.timestamps = deque(maxlen=window_size)

        # 基準性能（訓練時）
        self.baseline_accuracy: Optional[float] = None
        self.baseline_auc: Optional[float] = None

    def set_baseline(self, accuracy: float, auc: float):
        """基準性能を設定"""
        self.baseline_accuracy = accuracy
        self.baseline_auc = auc

    def add_prediction(self, prediction: int, actual: int,
                       timestamp: Optional[datetime.datetime] = None):
        """予測と実績を追加"""
        self.predictions.append(prediction)
        self.actuals.append(actual)
        self.timestamps.append(timestamp or datetime.datetime.now())

    def get_current_metrics(self) -> dict:
        """現在のウィンドウでのメトリクスを計算"""
        if len(self.predictions) < 100:  # 最小サンプル数
            return {'status': 'insufficient_data'}

        current_accuracy = accuracy_score(
            list(self.actuals),
            list(self.predictions)
        )

        try:
            current_auc = roc_auc_score(
                list(self.actuals),
                list(self.predictions)
            )
        except:
            current_auc = None

        return {
            'accuracy': current_accuracy,
            'auc': current_auc,
            'sample_count': len(self.predictions)
        }

    def detect_performance_drift(self) -> dict:
        """性能ドリフトを検出"""
        current_metrics = self.get_current_metrics()

        if current_metrics.get('status') == 'insufficient_data':
            return {'drift_detected': False, 'reason': 'insufficient_data'}

        if self.baseline_accuracy is None:
            return {'drift_detected': False, 'reason': 'no_baseline'}

        # 精度の低下率を計算
        accuracy_drop = self.baseline_accuracy - current_metrics['accuracy']
        accuracy_drop_pct = accuracy_drop / self.baseline_accuracy

        drift_detected = accuracy_drop_pct > self.alert_threshold

        result = {
            'drift_detected': drift_detected,
            'baseline_accuracy': self.baseline_accuracy,
            'current_accuracy': current_metrics['accuracy'],
            'accuracy_drop': accuracy_drop,
            'accuracy_drop_percentage': accuracy_drop_pct * 100,
            'threshold_percentage': self.alert_threshold * 100
        }

        if current_metrics['auc'] and self.baseline_auc:
            auc_drop = self.baseline_auc - current_metrics['auc']
            result['baseline_auc'] = self.baseline_auc
            result['current_auc'] = current_metrics['auc']
            result['auc_drop'] = auc_drop

        return result


# 使用例
monitor = ModelPerformanceMonitor(window_size=1000, alert_threshold=0.05)

# 基準性能を設定（訓練時の性能）
monitor.set_baseline(accuracy=0.92, auc=0.95)

print("=== モデル性能モニタリング ===\n")

# 初期は正常な性能
print("フェーズ1: 正常運用（1000件）")
for i in range(1000):
    # 精度92%程度の予測をシミュレート
    actual = np.random.binomial(1, 0.3)
    prediction = actual if np.random.random() < 0.92 else 1 - actual
    monitor.add_prediction(prediction, actual)

result1 = monitor.detect_performance_drift()
print(f"  ドリフト検出: {result1['drift_detected']}")
print(f"  現在の精度: {result1['current_accuracy']:.3f}")
print(f"  基準精度: {result1['baseline_accuracy']:.3f}")

# 性能劣化をシミュレート
print("\nフェーズ2: 性能劣化（1000件）")
for i in range(1000):
    # 精度85%に低下
    actual = np.random.binomial(1, 0.3)
    prediction = actual if np.random.random() < 0.85 else 1 - actual
    monitor.add_prediction(prediction, actual)

result2 = monitor.detect_performance_drift()
print(f"  ドリフト検出: {result2['drift_detected']}")
print(f"  現在の精度: {result2['current_accuracy']:.3f}")
print(f"  精度低下: {result2['accuracy_drop']:.3f} ({result2['accuracy_drop_percentage']:.1f}%)")

if result2['drift_detected']:
    print(f"\n  ⚠️ アラート: 精度が {result2['threshold_percentage']:.0f}% 以上低下しました！")
    print(f"  推奨アクション: モデルの再訓練を検討してください")
</code></pre>

<hr>

<h2>4.3 A/Bテストとカナリアデプロイ</h2>

<h3>トラフィック分割</h3>

<pre><code class="language-python">import random
from typing import Callable, Dict, Any
from dataclasses import dataclass
from datetime import datetime

@dataclass
class ModelVariant:
    """モデルのバリアント"""
    name: str
    version: str
    traffic_percentage: float
    predict_fn: Callable


class ABTestRouter:
    """A/Bテスト用のトラフィックルーター"""

    def __init__(self):
        self.variants: Dict[str, ModelVariant] = {}
        self.prediction_log = []

    def add_variant(self, variant: ModelVariant):
        """バリアントを追加"""
        self.variants[variant.name] = variant

    def validate_traffic_split(self) -> bool:
        """トラフィック分割が100%になることを検証"""
        total = sum(v.traffic_percentage for v in self.variants.values())
        return abs(total - 100.0) < 0.01

    def route_prediction(self, request_id: str, features: dict) -> dict:
        """
        トラフィックを分割して予測をルーティング

        Args:
            request_id: リクエストID（ユーザーIDなど）
            features: 入力特徴量

        Returns:
            予測結果とメタデータ
        """
        if not self.validate_traffic_split():
            raise ValueError("Traffic split does not sum to 100%")

        # ハッシュベースの一貫したルーティング
        # 同じユーザーは常に同じバリアントに振り分けられる
        hash_value = hash(request_id) % 100

        cumulative_percentage = 0
        selected_variant = None

        for variant in self.variants.values():
            cumulative_percentage += variant.traffic_percentage
            if hash_value < cumulative_percentage:
                selected_variant = variant
                break

        # 予測実行
        prediction = selected_variant.predict_fn(features)

        # ログ記録
        log_entry = {
            'request_id': request_id,
            'variant': selected_variant.name,
            'version': selected_variant.version,
            'prediction': prediction,
            'timestamp': datetime.now()
        }
        self.prediction_log.append(log_entry)

        return {
            'prediction': prediction,
            'model_variant': selected_variant.name,
            'model_version': selected_variant.version
        }


# モデルのダミー実装
def model_v1_predict(features: dict) -> int:
    """モデルv1.0の予測"""
    # ダミー: ランダムに予測（精度80%程度）
    return random.choices([0, 1], weights=[0.6, 0.4])[0]

def model_v2_predict(features: dict) -> int:
    """モデルv2.0の予測（改善版）"""
    # ダミー: ランダムに予測（精度85%程度）
    return random.choices([0, 1], weights=[0.55, 0.45])[0]


# A/Bテストのセットアップ
router = ABTestRouter()

# コントロールグループ（既存モデル）: 90%
router.add_variant(ModelVariant(
    name='control',
    version='v1.0',
    traffic_percentage=90.0,
    predict_fn=model_v1_predict
))

# テストグループ（新モデル）: 10%
router.add_variant(ModelVariant(
    name='treatment',
    version='v2.0',
    traffic_percentage=10.0,
    predict_fn=model_v2_predict
))

print("=== A/Bテスト実行 ===\n")
print("トラフィック分割:")
print("  コントロール (v1.0): 90%")
print("  テスト (v2.0): 10%\n")

# 予測をシミュレート
n_requests = 1000
for i in range(n_requests):
    request_id = f"user_{i % 100}"  # 100ユーザーをシミュレート
    features = {'feature1': random.random()}
    result = router.route_prediction(request_id, features)

# 結果の集計
variant_counts = {}
for log in router.prediction_log:
    variant = log['variant']
    variant_counts[variant] = variant_counts.get(variant, 0) + 1

print(f"総リクエスト数: {n_requests}")
print("\n実際のトラフィック分割:")
for variant, count in variant_counts.items():
    percentage = (count / n_requests) * 100
    print(f"  {variant}: {count}件 ({percentage:.1f}%)")
</code></pre>

<h3>統計的検定</h3>

<pre><code class="language-python">import numpy as np
from scipy import stats
from typing import List, Tuple

class ABTestAnalyzer:
    """A/Bテスト結果の統計分析"""

    @staticmethod
    def proportion_test(control_successes: int, control_total: int,
                        treatment_successes: int, treatment_total: int,
                        alpha: float = 0.05) -> dict:
        """
        比率の差の検定（二項分布）

        Args:
            control_successes: コントロールグループの成功数
            control_total: コントロールグループの総数
            treatment_successes: テストグループの成功数
            treatment_total: テストグループの総数
            alpha: 有意水準

        Returns:
            検定結果
        """
        # 比率の計算
        p_control = control_successes / control_total
        p_treatment = treatment_successes / treatment_total

        # プールされた比率
        p_pooled = (control_successes + treatment_successes) / (control_total + treatment_total)

        # 標準誤差
        se = np.sqrt(p_pooled * (1 - p_pooled) * (1/control_total + 1/treatment_total))

        # z統計量
        z_stat = (p_treatment - p_control) / se

        # p値（両側検定）
        p_value = 2 * (1 - stats.norm.cdf(abs(z_stat)))

        # 信頼区間
        ci_margin = stats.norm.ppf(1 - alpha/2) * se
        ci_lower = (p_treatment - p_control) - ci_margin
        ci_upper = (p_treatment - p_control) + ci_margin

        # 統計的有意性
        is_significant = p_value < alpha

        # 効果サイズ（相対的改善率）
        relative_improvement = (p_treatment - p_control) / p_control * 100 if p_control > 0 else 0

        return {
            'control_rate': p_control,
            'treatment_rate': p_treatment,
            'absolute_difference': p_treatment - p_control,
            'relative_improvement_pct': relative_improvement,
            'z_statistic': z_stat,
            'p_value': p_value,
            'is_significant': is_significant,
            'confidence_interval': (ci_lower, ci_upper),
            'confidence_level': (1 - alpha) * 100
        }

    @staticmethod
    def sample_size_calculator(baseline_rate: float,
                               minimum_detectable_effect: float,
                               alpha: float = 0.05,
                               power: float = 0.8) -> int:
        """
        必要サンプルサイズの計算

        Args:
            baseline_rate: ベースライン転換率
            minimum_detectable_effect: 検出したい最小効果（相対変化率）
            alpha: 有意水準
            power: 検出力

        Returns:
            グループあたりの必要サンプル数
        """
        # Z値
        z_alpha = stats.norm.ppf(1 - alpha/2)
        z_beta = stats.norm.ppf(power)

        # 処置群の期待転換率
        treatment_rate = baseline_rate * (1 + minimum_detectable_effect)

        # サンプルサイズ計算
        p_avg = (baseline_rate + treatment_rate) / 2

        n = (2 * p_avg * (1 - p_avg) * (z_alpha + z_beta)**2) / (baseline_rate - treatment_rate)**2

        return int(np.ceil(n))


# 使用例
print("=== A/Bテスト統計分析 ===\n")

# シミュレーションデータ
control_total = 10000
treatment_total = 1000

# コントロール: 転換率20%
control_successes = 2000

# テスト: 転換率22%（10%改善）
treatment_successes = 220

# 統計検定の実行
analyzer = ABTestAnalyzer()
results = analyzer.proportion_test(
    control_successes, control_total,
    treatment_successes, treatment_total
)

print("検定結果:")
print(f"  コントロール転換率: {results['control_rate']:.3f}")
print(f"  テスト転換率: {results['treatment_rate']:.3f}")
print(f"  絶対差: {results['absolute_difference']:.3f}")
print(f"  相対改善: {results['relative_improvement_pct']:.1f}%")
print(f"  p値: {results['p_value']:.4f}")
print(f"  統計的有意: {'はい' if results['is_significant'] else 'いいえ'}")
print(f"  95%信頼区間: [{results['confidence_interval'][0]:.3f}, {results['confidence_interval'][1]:.3f}]")

# 必要サンプルサイズの計算
print("\n\n=== 必要サンプルサイズ計算 ===\n")
sample_size = analyzer.sample_size_calculator(
    baseline_rate=0.20,
    minimum_detectable_effect=0.10,  # 10%の改善を検出
    alpha=0.05,
    power=0.8
)

print(f"ベースライン転換率: 20%")
print(f"検出したい改善: 10% (20% → 22%)")
print(f"有意水準 (α): 5%")
print(f"検出力 (1-β): 80%")
print(f"\n必要サンプル数（各グループ）: {sample_size:,}件")
</code></pre>

<h3>カナリアデプロイ戦略</h3>

<pre><code class="language-python">from datetime import datetime, timedelta
from typing import Optional
import time

class CanaryDeployment:
    """カナリアデプロイメント管理"""

    def __init__(self,
                 initial_traffic: float = 5.0,
                 max_traffic: float = 100.0,
                 increment_step: float = 10.0,
                 monitoring_window_minutes: int = 30):
        """
        Args:
            initial_traffic: 初期トラフィック比率（%）
            max_traffic: 最大トラフィック比率（%）
            increment_step: トラフィック増加ステップ（%）
            monitoring_window_minutes: 各ステップの監視時間（分）
        """
        self.current_traffic = 0.0
        self.initial_traffic = initial_traffic
        self.max_traffic = max_traffic
        self.increment_step = increment_step
        self.monitoring_window = timedelta(minutes=monitoring_window_minutes)

        self.deployment_start_time: Optional[datetime] = None
        self.current_stage_start_time: Optional[datetime] = None
        self.stages_completed = []

    def start_deployment(self):
        """カナリアデプロイを開始"""
        self.deployment_start_time = datetime.now()
        self.current_traffic = self.initial_traffic
        self.current_stage_start_time = datetime.now()

        print(f"カナリアデプロイ開始: {self.current_traffic}% のトラフィックを新バージョンへ")

    def should_proceed_to_next_stage(self, health_metrics: dict) -> Tuple[bool, str]:
        """
        次のステージへ進むべきか判定

        Args:
            health_metrics: ヘルスメトリクス
                - error_rate: エラー率
                - latency_p95: 95パーセンタイルレイテンシ
                - success_rate: 成功率

        Returns:
            (進行可能か, 理由)
        """
        # 監視時間を経過したか
        elapsed = datetime.now() - self.current_stage_start_time
        if elapsed < self.monitoring_window:
            return False, f"監視時間未達成（{elapsed.total_seconds()/60:.1f}/{self.monitoring_window.total_seconds()/60:.0f}分）"

        # ヘルスチェック
        if health_metrics.get('error_rate', 0) > 0.05:
            return False, f"エラー率が高い（{health_metrics['error_rate']*100:.1f}%）"

        if health_metrics.get('latency_p95', 0) > 2000:
            return False, f"レイテンシが高い（{health_metrics['latency_p95']}ms）"

        if health_metrics.get('success_rate', 1.0) < 0.95:
            return False, f"成功率が低い（{health_metrics['success_rate']*100:.1f}%）"

        return True, "ヘルスチェック通過"

    def proceed_to_next_stage(self) -> bool:
        """次のステージへ進む"""
        if self.current_traffic >= self.max_traffic:
            print("カナリアデプロイ完了: 100% トラフィック移行")
            return False

        # 現在のステージを記録
        self.stages_completed.append({
            'traffic': self.current_traffic,
            'start_time': self.current_stage_start_time,
            'end_time': datetime.now()
        })

        # トラフィックを増やす
        self.current_traffic = min(
            self.current_traffic + self.increment_step,
            self.max_traffic
        )
        self.current_stage_start_time = datetime.now()

        print(f"\n次のステージへ: {self.current_traffic}% のトラフィックを新バージョンへ")
        return True

    def rollback(self, reason: str):
        """ロールバック実行"""
        print(f"\n🚨 ロールバック実行: {reason}")
        print(f"トラフィックを旧バージョンへ戻します")
        self.current_traffic = 0.0


# 使用例
print("=== カナリアデプロイメント実行 ===\n")

canary = CanaryDeployment(
    initial_traffic=5.0,
    max_traffic=100.0,
    increment_step=15.0,
    monitoring_window_minutes=1  # デモ用に1分
)

canary.start_deployment()

# デプロイプロセスのシミュレーション
stages = []
while canary.current_traffic < canary.max_traffic:
    print(f"\n現在のステージ: {canary.current_traffic}% トラフィック")
    print(f"監視中... ({canary.monitoring_window.total_seconds()/60:.0f}分間)")

    # 監視時間のシミュレーション（実際は time.sleep(monitoring_window) ）
    time.sleep(1)

    # ヘルスメトリクスのシミュレーション
    health_metrics = {
        'error_rate': np.random.uniform(0, 0.03),  # 0-3% エラー率
        'latency_p95': np.random.uniform(100, 500),  # 100-500ms
        'success_rate': np.random.uniform(0.97, 1.0)  # 97-100% 成功率
    }

    print(f"  エラー率: {health_metrics['error_rate']*100:.2f}%")
    print(f"  レイテンシP95: {health_metrics['latency_p95']:.0f}ms")
    print(f"  成功率: {health_metrics['success_rate']*100:.2f}%")

    # 次のステージへ進むか判定
    can_proceed, reason = canary.should_proceed_to_next_stage(health_metrics)

    if can_proceed:
        print(f"✓ {reason}")
        if not canary.proceed_to_next_stage():
            break
    else:
        print(f"⏸ {reason}")
        # 本番では監視を継続

print("\n\n=== デプロイ完了 ===")
print(f"総経過時間: {len(canary.stages_completed)}ステージ")
print(f"最終トラフィック: {canary.current_traffic}%")
</code></pre>

<hr>

<h2>4.4 モデル更新と再訓練</h2>

<h3>オンライン学習 vs バッチ再訓練</h3>

<table>
<thead>
<tr>
<th>特性</th>
<th>オンライン学習</th>
<th>バッチ再訓練</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>更新頻度</strong></td>
<td>リアルタイム〜数分</td>
<td>日次〜週次</td>
</tr>
<tr>
<td><strong>計算コスト</strong></td>
<td>低（増分更新）</td>
<td>高（全データ再訓練）</td>
</tr>
<tr>
<td><strong>適応速度</strong></td>
<td>速い</td>
<td>遅い</td>
</tr>
<tr>
<td><strong>安定性</strong></td>
<td>低（ノイズに敏感）</td>
<td>高</td>
</tr>
<tr>
<td><strong>実装難易度</strong></td>
<td>高</td>
<td>中</td>
</tr>
<tr>
<td><strong>適用例</strong></td>
<td>推薦システム、広告</td>
<td>信用スコア、不正検知</td>
</tr>
</tbody>
</table>

<h3>モデルバージョニング</h3>

<pre><code class="language-python">import joblib
import json
from pathlib import Path
from datetime import datetime
from typing import Any, Dict, Optional
import hashlib

class ModelRegistry:
    """モデルのバージョン管理レジストリ"""

    def __init__(self, registry_path: str = "./model_registry"):
        self.registry_path = Path(registry_path)
        self.registry_path.mkdir(parents=True, exist_ok=True)
        self.metadata_file = self.registry_path / "registry.json"

        # メタデータの読み込み
        if self.metadata_file.exists():
            with open(self.metadata_file, 'r') as f:
                self.metadata = json.load(f)
        else:
            self.metadata = {'models': {}}

    def register_model(self,
                       model: Any,
                       model_name: str,
                       version: str,
                       metrics: Dict[str, float],
                       description: str = "",
                       tags: Dict[str, str] = None) -> str:
        """
        モデルを登録

        Returns:
            モデルID
        """
        # モデルIDの生成
        model_id = f"{model_name}_{version}_{datetime.now().strftime('%Y%m%d_%H%M%S')}"

        # モデルファイルのパス
        model_path = self.registry_path / f"{model_id}.pkl"

        # モデルの保存
        joblib.dump(model, model_path)

        # モデルのハッシュ計算
        model_hash = self._calculate_file_hash(model_path)

        # メタデータの保存
        model_metadata = {
            'model_id': model_id,
            'model_name': model_name,
            'version': version,
            'file_path': str(model_path),
            'file_hash': model_hash,
            'metrics': metrics,
            'description': description,
            'tags': tags or {},
            'registered_at': datetime.now().isoformat(),
            'status': 'registered'
        }

        self.metadata['models'][model_id] = model_metadata
        self._save_metadata()

        return model_id

    def load_model(self, model_id: str) -> Any:
        """モデルを読み込み"""
        if model_id not in self.metadata['models']:
            raise ValueError(f"Model {model_id} not found in registry")

        model_info = self.metadata['models'][model_id]
        model_path = Path(model_info['file_path'])

        # ハッシュ検証
        current_hash = self._calculate_file_hash(model_path)
        if current_hash != model_info['file_hash']:
            raise ValueError(f"Model file hash mismatch for {model_id}")

        return joblib.load(model_path)

    def promote_to_production(self, model_id: str):
        """モデルを本番環境へプロモート"""
        if model_id not in self.metadata['models']:
            raise ValueError(f"Model {model_id} not found")

        # 既存の本番モデルをstaging降格
        for mid, info in self.metadata['models'].items():
            if info['status'] == 'production':
                info['status'] = 'staging'
                info['demoted_at'] = datetime.now().isoformat()

        # 新しいモデルを本番へ
        self.metadata['models'][model_id]['status'] = 'production'
        self.metadata['models'][model_id]['promoted_at'] = datetime.now().isoformat()

        self._save_metadata()

    def get_production_model(self) -> Optional[str]:
        """現在の本番モデルIDを取得"""
        for model_id, info in self.metadata['models'].items():
            if info['status'] == 'production':
                return model_id
        return None

    def list_models(self, status: Optional[str] = None) -> list:
        """モデル一覧を取得"""
        models = list(self.metadata['models'].values())
        if status:
            models = [m for m in models if m['status'] == status]
        return sorted(models, key=lambda x: x['registered_at'], reverse=True)

    def _calculate_file_hash(self, file_path: Path) -> str:
        """ファイルのハッシュを計算"""
        hash_md5 = hashlib.md5()
        with open(file_path, "rb") as f:
            for chunk in iter(lambda: f.read(4096), b""):
                hash_md5.update(chunk)
        return hash_md5.hexdigest()

    def _save_metadata(self):
        """メタデータをファイルに保存"""
        with open(self.metadata_file, 'w') as f:
            json.dump(self.metadata, f, indent=2)


# 使用例
from sklearn.ensemble import RandomForestClassifier
from sklearn.datasets import make_classification

print("=== モデルバージョニング ===\n")

# モデルレジストリの初期化
registry = ModelRegistry("./model_registry")

# ダミーモデルの訓練
X, y = make_classification(n_samples=1000, n_features=10, random_state=42)
model_v1 = RandomForestClassifier(n_estimators=50, random_state=42)
model_v1.fit(X, y)

# モデルの登録
model_id_v1 = registry.register_model(
    model=model_v1,
    model_name="fraud_detector",
    version="1.0.0",
    metrics={
        'accuracy': 0.85,
        'precision': 0.83,
        'recall': 0.87,
        'f1': 0.85
    },
    description="Initial production model",
    tags={'framework': 'sklearn', 'algorithm': 'RandomForest'}
)

print(f"モデル登録: {model_id_v1}")

# 本番環境へプロモート
registry.promote_to_production(model_id_v1)
print(f"本番環境へプロモート: {model_id_v1}")

# 新しいモデルの訓練と登録
model_v2 = RandomForestClassifier(n_estimators=100, random_state=42)
model_v2.fit(X, y)

model_id_v2 = registry.register_model(
    model=model_v2,
    model_name="fraud_detector",
    version="2.0.0",
    metrics={
        'accuracy': 0.89,
        'precision': 0.88,
        'recall': 0.90,
        'f1': 0.89
    },
    description="Improved model with more estimators",
    tags={'framework': 'sklearn', 'algorithm': 'RandomForest'}
)

print(f"\n新モデル登録: {model_id_v2}")

# モデル一覧表示
print("\n=== 登録モデル一覧 ===")
for model_info in registry.list_models():
    print(f"\nモデル: {model_info['model_name']} v{model_info['version']}")
    print(f"  ID: {model_info['model_id']}")
    print(f"  状態: {model_info['status']}")
    print(f"  精度: {model_info['metrics']['accuracy']:.3f}")
    print(f"  登録日時: {model_info['registered_at']}")

# 本番モデルの取得
prod_model_id = registry.get_production_model()
print(f"\n現在の本番モデル: {prod_model_id}")
</code></pre>

<h3>自動再訓練パイプライン</h3>

<pre><code class="language-python">from datetime import datetime, timedelta
from typing import Optional
import schedule
import time

class AutoRetrainingPipeline:
    """自動再訓練パイプライン"""

    def __init__(self,
                 model_registry: ModelRegistry,
                 performance_monitor: ModelPerformanceMonitor,
                 retrain_threshold: float = 0.05):
        """
        Args:
            model_registry: モデルレジストリ
            performance_monitor: 性能モニター
            retrain_threshold: 再訓練トリガーの閾値（性能低下率）
        """
        self.registry = model_registry
        self.monitor = performance_monitor
        self.retrain_threshold = retrain_threshold
        self.last_retrain_time: Optional[datetime] = None

    def check_retrain_needed(self) -> bool:
        """再訓練が必要か判定"""
        drift_result = self.monitor.detect_performance_drift()

        if drift_result.get('drift_detected'):
            print(f"⚠️ 性能ドリフト検出: {drift_result['accuracy_drop_percentage']:.1f}% 低下")
            return True

        return False

    def retrain_model(self, training_data_path: str) -> str:
        """
        モデルを再訓練

        Returns:
            新しいモデルID
        """
        print(f"\n{'='*50}")
        print(f"自動再訓練開始: {datetime.now().isoformat()}")
        print(f"{'='*50}\n")

        # データ読み込み（ダミー）
        print("1. 訓練データ読み込み...")
        X, y = make_classification(n_samples=2000, n_features=10, random_state=int(time.time()))

        # モデル訓練
        print("2. モデル訓練中...")
        new_model = RandomForestClassifier(n_estimators=100, random_state=42)
        new_model.fit(X, y)

        # 評価
        print("3. モデル評価...")
        from sklearn.model_selection import cross_val_score
        scores = cross_val_score(new_model, X, y, cv=5)
        accuracy = scores.mean()

        # バージョン番号の生成
        current_prod_id = self.registry.get_production_model()
        if current_prod_id:
            current_version = self.registry.metadata['models'][current_prod_id]['version']
            major, minor, patch = map(int, current_version.split('.'))
            new_version = f"{major}.{minor}.{patch + 1}"
        else:
            new_version = "1.0.0"

        # レジストリへ登録
        print("4. モデル登録...")
        new_model_id = self.registry.register_model(
            model=new_model,
            model_name="fraud_detector",
            version=new_version,
            metrics={
                'accuracy': accuracy,
                'cv_scores_mean': accuracy,
                'cv_scores_std': scores.std()
            },
            description=f"Auto-retrained model (trigger: performance drift)",
            tags={'retrain_type': 'automatic', 'trigger': 'performance_drift'}
        )

        print(f"✓ 新モデル登録完了: {new_model_id}")
        print(f"  バージョン: {new_version}")
        print(f"  精度: {accuracy:.3f}")

        # 性能が向上していればプロモート
        if current_prod_id:
            current_accuracy = self.registry.metadata['models'][current_prod_id]['metrics']['accuracy']
            if accuracy > current_accuracy:
                print(f"\n5. 本番環境へプロモート（精度向上: {current_accuracy:.3f} → {accuracy:.3f}）")
                self.registry.promote_to_production(new_model_id)
            else:
                print(f"\n5. プロモート見送り（精度向上なし: {accuracy:.3f} vs {current_accuracy:.3f}）")
        else:
            print(f"\n5. 本番環境へプロモート（初回モデル）")
            self.registry.promote_to_production(new_model_id)

        self.last_retrain_time = datetime.now()

        print(f"\n{'='*50}")
        print(f"再訓練完了")
        print(f"{'='*50}\n")

        return new_model_id

    def scheduled_check(self, training_data_path: str):
        """スケジュールされたチェック"""
        print(f"\n[{datetime.now().isoformat()}] 定期チェック実行")

        if self.check_retrain_needed():
            print("→ 再訓練が必要と判定")
            self.retrain_model(training_data_path)
        else:
            print("→ 再訓練不要（性能正常）")


# 使用例
print("=== 自動再訓練パイプライン ===\n")

# 既存のコンポーネントを使用
monitor = ModelPerformanceMonitor(window_size=1000, alert_threshold=0.05)
monitor.set_baseline(accuracy=0.85, auc=0.90)

registry = ModelRegistry("./model_registry")

# パイプラインのセットアップ
pipeline = AutoRetrainingPipeline(
    model_registry=registry,
    performance_monitor=monitor,
    retrain_threshold=0.05
)

# 性能劣化をシミュレート
print("性能劣化をシミュレート...")
for i in range(1000):
    actual = np.random.binomial(1, 0.3)
    # 精度78%に低下
    prediction = actual if np.random.random() < 0.78 else 1 - actual
    monitor.add_prediction(prediction, actual)

# 再訓練チェック
pipeline.scheduled_check(training_data_path="data/training.csv")

# スケジューリング（実運用例）
print("\n\n=== スケジューリング設定 ===")
print("以下のスケジュールで自動チェックを実行:")
print("  - 毎日 02:00 に実行")
print("  - 性能ドリフト検出時に自動再訓練")

# schedule.every().day.at("02:00").do(
#     pipeline.scheduled_check,
#     training_data_path="data/training.csv"
# )
#
# while True:
#     schedule.run_pending()
#     time.sleep(60)
</code></pre>

<hr>

<h2>4.5 実践: エンドツーエンド運用</h2>

<h3>総合モニタリングシステム</h3>

<pre><code class="language-python">from dataclasses import dataclass
from typing import List, Dict, Any
import json

@dataclass
class HealthStatus:
    """システムヘルスステータス"""
    is_healthy: bool
    components: Dict[str, bool]
    alerts: List[str]
    metrics: Dict[str, float]
    timestamp: datetime


class ComprehensiveMonitoringSystem:
    """包括的モニタリングシステム"""

    def __init__(self):
        self.model_monitor = ModelPerformanceMonitor(window_size=1000)
        self.drift_detector = None  # DataDriftDetectorのインスタンス
        self.sla_thresholds = {
            'latency_p95_ms': 500,
            'latency_p99_ms': 1000,
            'error_rate': 0.01,
            'availability': 0.999
        }

    def check_system_health(self) -> HealthStatus:
        """システム全体のヘルスチェック"""
        components = {}
        alerts = []
        metrics = {}

        # 1. モデル性能チェック
        performance_metrics = self.model_monitor.get_current_metrics()
        if performance_metrics.get('status') != 'insufficient_data':
            model_healthy = performance_metrics.get('accuracy', 0) > 0.85
            components['model_performance'] = model_healthy
            metrics['model_accuracy'] = performance_metrics.get('accuracy', 0)

            if not model_healthy:
                alerts.append(f"モデル精度低下: {metrics['model_accuracy']:.3f}")

        # 2. レイテンシチェック
        current_latency_p95 = np.random.uniform(200, 600)  # ダミー
        latency_healthy = current_latency_p95 < self.sla_thresholds['latency_p95_ms']
        components['latency'] = latency_healthy
        metrics['latency_p95_ms'] = current_latency_p95

        if not latency_healthy:
            alerts.append(f"レイテンシSLA違反: {current_latency_p95:.0f}ms")

        # 3. エラー率チェック
        current_error_rate = np.random.uniform(0, 0.02)  # ダミー
        error_rate_healthy = current_error_rate < self.sla_thresholds['error_rate']
        components['error_rate'] = error_rate_healthy
        metrics['error_rate'] = current_error_rate

        if not error_rate_healthy:
            alerts.append(f"エラー率SLA違反: {current_error_rate*100:.2f}%")

        # 4. 可用性チェック
        current_availability = np.random.uniform(0.995, 1.0)  # ダミー
        availability_healthy = current_availability >= self.sla_thresholds['availability']
        components['availability'] = availability_healthy
        metrics['availability'] = current_availability

        if not availability_healthy:
            alerts.append(f"可用性SLA違反: {current_availability*100:.3f}%")

        # 総合判定
        is_healthy = all(components.values())

        return HealthStatus(
            is_healthy=is_healthy,
            components=components,
            alerts=alerts,
            metrics=metrics,
            timestamp=datetime.now()
        )

    def generate_health_report(self) -> str:
        """ヘルスレポートを生成"""
        status = self.check_system_health()

        report = f"""
{'='*60}
システムヘルスレポート
{'='*60}
時刻: {status.timestamp.isoformat()}
総合ステータス: {'✓ 正常' if status.is_healthy else '✗ 異常'}

コンポーネント状態:
"""
        for component, healthy in status.components.items():
            icon = '✓' if healthy else '✗'
            report += f"  {icon} {component}: {'正常' if healthy else '異常'}\n"

        report += f"\nメトリクス:\n"
        for metric, value in status.metrics.items():
            if 'rate' in metric or 'availability' in metric:
                report += f"  {metric}: {value*100:.2f}%\n"
            else:
                report += f"  {metric}: {value:.2f}\n"

        if status.alerts:
            report += f"\nアラート ({len(status.alerts)}件):\n"
            for alert in status.alerts:
                report += f"  ⚠️ {alert}\n"
        else:
            report += f"\nアラート: なし\n"

        report += f"{'='*60}\n"

        return report


# 使用例
print("=== 総合モニタリングシステム ===\n")

monitoring = ComprehensiveMonitoringSystem()

# ヘルスレポートの生成
report = monitoring.generate_health_report()
print(report)
</code></pre>

<h3>本番運用チェックリスト</h3>

<table>
<thead>
<tr>
<th>カテゴリ</th>
<th>チェック項目</th>
<th>優先度</th>
</tr>
</thead>
<tbody>
<tr>
<td rowspan="4"><strong>デプロイ前</strong></td>
<td>モデルの精度がベースラインを上回る</td>
<td>🔴 必須</td>
</tr>
<tr>
<td>A/Bテストで統計的有意性を確認</td>
<td>🔴 必須</td>
</tr>
<tr>
<td>ロードテストで性能要件を満たす</td>
<td>🔴 必須</td>
</tr>
<tr>
<td>ロールバック手順を文書化</td>
<td>🔴 必須</td>
</tr>
<tr>
<td rowspan="5"><strong>モニタリング</strong></td>
<td>構造化ログが正しく出力される</td>
<td>🔴 必須</td>
</tr>
<tr>
<td>Prometheusメトリクスが収集される</td>
<td>🔴 必須</td>
</tr>
<tr>
<td>Grafanaダッシュボードが稼働</td>
<td>🟡 推奨</td>
</tr>
<tr>
<td>アラートが正しく発火する</td>
<td>🔴 必須</td>
</tr>
<tr>
<td>データドリフト検出が動作</td>
<td>🟡 推奨</td>
</tr>
<tr>
<td rowspan="4"><strong>SLA定義</strong></td>
<td>レイテンシP95 < 500ms</td>
<td>🔴 必須</td>
</tr>
<tr>
<td>エラー率 < 1%</td>
<td>🔴 必須</td>
</tr>
<tr>
<td>可用性 > 99.9%</td>
<td>🔴 必須</td>
</tr>
<tr>
<td>モデル精度 > 基準値の95%</td>
<td>🟡 推奨</td>
</tr>
<tr>
<td rowspan="3"><strong>インシデント対応</strong></td>
<td>オンコール体制が整っている</td>
<td>🔴 必須</td>
</tr>
<tr>
<td>インシデント対応手順が文書化</td>
<td>🔴 必須</td>
</tr>
<tr>
<td>ポストモーテムプロセスがある</td>
<td>🟡 推奨</td>
</tr>
<tr>
<td rowspan="3"><strong>データ管理</strong></td>
<td>予測ログが保存される</td>
<td>🔴 必須</td>
</tr>
<tr>
<td>実績データが収集される</td>
<td>🔴 必須</td>
</tr>
<tr>
<td>データバックアップが定期実行</td>
<td>🟡 推奨</td>
</tr>
</tbody>
</table>

<hr>

<h2>4.6 本章のまとめ</h2>

<h3>学んだこと</h3>

<ol>
<li><p><strong>ログとモニタリング</strong></p>
<ul>
<li>構造化JSONログで機械可読な記録</li>
<li>Prometheus + Grafanaで時系列メトリクス監視</li>
<li>カスタムメトリクスでビジネス指標を追跡</li>
<li>アラートルールで異常を早期検出</li>
</ul></li>

<li><p><strong>モデルパフォーマンス追跡</strong></p>
<ul>
<li>データドリフトの統計的検出（KS検定、カイ二乗検定）</li>
<li>Evidently AIでの包括的ドリフト分析</li>
<li>モデルドリフトのリアルタイム監視</li>
</ul></li>

<li><p><strong>A/Bテストとカナリアデプロイ</strong></p>
<ul>
<li>トラフィック分割による安全なテスト</li>
<li>統計的検定での効果検証</li>
<li>段階的なカナリアデプロイ戦略</li>
</ul></li>

<li><p><strong>モデル更新と再訓練</strong></p>
<ul>
<li>モデルバージョニングでの履歴管理</li>
<li>自動再訓練パイプラインの構築</li>
<li>性能ドリフト検出による再訓練トリガー</li>
</ul></li>

<li><p><strong>エンドツーエンド運用</strong></p>
<ul>
<li>総合モニタリングシステムの設計</li>
<li>SLA定義と継続的な監視</li>
<li>本番運用チェックリストの活用</li>
</ul></li>
</ol>

<h3>運用のベストプラクティス</h3>

<table>
<thead>
<tr>
<th>原則</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>可観測性優先</strong></td>
<td>全ての重要な動作をログとメトリクスで追跡</td>
</tr>
<tr>
<td><strong>段階的デプロイ</strong></td>
<td>カナリアデプロイで影響範囲を限定</td>
</tr>
<tr>
<td><strong>自動化第一</strong></td>
<td>再訓練、デプロイ、アラートを自動化</td>
</tr>
<tr>
<td><strong>迅速なロールバック</strong></td>
<td>問題発生時は即座に安全な状態へ復帰</td>
</tr>
<tr>
<td><strong>継続的改善</strong></td>
<td>インシデントから学び、システムを改善</td>
</tr>
</tbody>
</table>

<h3>次のステップ</h3>

<p>モデルデプロイメントの学習を完了しました。さらに深く学ぶには：</p>
<ul>
<li>Kubernetes上でのMLモデルオーケストレーション</li>
<li>MLOpsツール（Kubeflow、MLflow、Vertex AI）</li>
<li>フェデレーテッドラーニング</li>
<li>エッジデバイスへのデプロイ</li>
<li>リアルタイム推論の最適化</li>
</ul>

<hr>

<h2>参考文献</h2>

<ol>
<li>Huyen, C. (2022). <em>Designing Machine Learning Systems</em>. O'Reilly Media.</li>
<li>Ameisen, E. (2020). <em>Building Machine Learning Powered Applications</em>. O'Reilly Media.</li>
<li>Kleppmann, M. (2017). <em>Designing Data-Intensive Applications</em>. O'Reilly Media.</li>
<li>Google. (2023). <em>Machine Learning Engineering for Production (MLOps)</em>. Coursera.</li>
<li>Neptune.ai. (2023). <em>MLOps: Model Monitoring Best Practices</em>.</li>
</ol>

<div class="navigation">
    <a href="chapter3-containerization.html" class="nav-button">← 前の章: コンテナ化とオーケストレーション</a>
    <a href="index.html" class="nav-button">シリーズ目次へ →</a>
</div>

    </main>

    <footer>
        <p><strong>作成者</strong>: AI Terakoya Content Team</p>
        <p><strong>バージョン</strong>: 1.0 | <strong>作成日</strong>: 2025-10-23</p>
        <p><strong>ライセンス</strong>: Creative Commons BY 4.0</p>
        <p>© 2025 AI Terakoya. All rights reserved.</p>
    </footer>
</body>
</html>
