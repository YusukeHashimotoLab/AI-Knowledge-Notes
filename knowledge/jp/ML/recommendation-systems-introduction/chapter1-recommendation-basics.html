<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>第1章：推薦システム基礎 - AI Terakoya</title>

    <style>
        :root {
            --color-primary: #2c3e50;
            --color-primary-dark: #1a252f;
            --color-accent: #7b2cbf;
            --color-accent-light: #9d4edd;
            --color-text: #2d3748;
            --color-text-light: #4a5568;
            --color-bg: #ffffff;
            --color-bg-alt: #f7fafc;
            --color-border: #e2e8f0;
            --color-code-bg: #f8f9fa;
            --color-link: #3182ce;
            --color-link-hover: #2c5aa0;

            --spacing-xs: 0.5rem;
            --spacing-sm: 1rem;
            --spacing-md: 1.5rem;
            --spacing-lg: 2rem;
            --spacing-xl: 3rem;

            --font-body: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            --font-mono: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;

            --border-radius: 8px;
            --box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-body);
            line-height: 1.7;
            color: var(--color-text);
            background-color: var(--color-bg);
            font-size: 16px;
        }

        header {
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            color: white;
            padding: var(--spacing-xl) var(--spacing-md);
            margin-bottom: var(--spacing-xl);
            box-shadow: var(--box-shadow);
        }

        .header-content {
            max-width: 900px;
            margin: 0 auto;
        }

        h1 {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: var(--spacing-sm);
            line-height: 1.2;
        }

        .subtitle {
            font-size: 1.1rem;
            opacity: 0.95;
            font-weight: 400;
            margin-bottom: var(--spacing-md);
        }

        .meta {
            display: flex;
            flex-wrap: wrap;
            gap: var(--spacing-md);
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .meta-item {
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 0 var(--spacing-md) var(--spacing-xl);
        }

        h2 {
            font-size: 1.75rem;
            color: var(--color-primary);
            margin-top: var(--spacing-xl);
            margin-bottom: var(--spacing-md);
            padding-bottom: var(--spacing-xs);
            border-bottom: 3px solid var(--color-accent);
        }

        h3 {
            font-size: 1.4rem;
            color: var(--color-primary);
            margin-top: var(--spacing-lg);
            margin-bottom: var(--spacing-sm);
        }

        h4 {
            font-size: 1.1rem;
            color: var(--color-primary-dark);
            margin-top: var(--spacing-md);
            margin-bottom: var(--spacing-sm);
        }

        p {
            margin-bottom: var(--spacing-md);
            color: var(--color-text);
        }

        a {
            color: var(--color-link);
            text-decoration: none;
            transition: color 0.2s;
        }

        a:hover {
            color: var(--color-link-hover);
            text-decoration: underline;
        }

        ul, ol {
            margin-left: var(--spacing-lg);
            margin-bottom: var(--spacing-md);
        }

        li {
            margin-bottom: var(--spacing-xs);
            color: var(--color-text);
        }

        pre {
            background-color: var(--color-code-bg);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            overflow-x: auto;
            margin-bottom: var(--spacing-md);
            font-family: var(--font-mono);
            font-size: 0.9rem;
            line-height: 1.5;
        }

        code {
            font-family: var(--font-mono);
            font-size: 0.9em;
            background-color: var(--color-code-bg);
            padding: 0.2em 0.4em;
            border-radius: 3px;
        }

        pre code {
            background-color: transparent;
            padding: 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: var(--spacing-md);
            font-size: 0.95rem;
        }

        th, td {
            border: 1px solid var(--color-border);
            padding: var(--spacing-sm);
            text-align: left;
        }

        th {
            background-color: var(--color-bg-alt);
            font-weight: 600;
            color: var(--color-primary);
        }

        blockquote {
            border-left: 4px solid var(--color-accent);
            padding-left: var(--spacing-md);
            margin: var(--spacing-md) 0;
            color: var(--color-text-light);
            font-style: italic;
            background-color: var(--color-bg-alt);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        .mermaid {
            text-align: center;
            margin: var(--spacing-lg) 0;
            background-color: var(--color-bg-alt);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        details {
            background-color: var(--color-bg-alt);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            margin-bottom: var(--spacing-md);
        }

        summary {
            cursor: pointer;
            font-weight: 600;
            color: var(--color-primary);
            user-select: none;
            padding: var(--spacing-xs);
            margin: calc(-1 * var(--spacing-md));
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        summary:hover {
            background-color: rgba(123, 44, 191, 0.1);
        }

        details[open] summary {
            margin-bottom: var(--spacing-md);
            border-bottom: 1px solid var(--color-border);
        }

        .navigation {
            display: flex;
            justify-content: space-between;
            gap: var(--spacing-md);
            margin: var(--spacing-xl) 0;
            padding-top: var(--spacing-lg);
            border-top: 2px solid var(--color-border);
        }

        .nav-button {
            flex: 1;
            padding: var(--spacing-md);
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            color: white;
            border-radius: var(--border-radius);
            text-align: center;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: var(--box-shadow);
        }

        .nav-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            text-decoration: none;
        }

        footer {
            margin-top: var(--spacing-xl);
            padding: var(--spacing-lg) var(--spacing-md);
            background-color: var(--color-bg-alt);
            border-top: 1px solid var(--color-border);
            text-align: center;
            font-size: 0.9rem;
            color: var(--color-text-light);
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.5rem;
            }

            h2 {
                font-size: 1.4rem;
            }

            h3 {
                font-size: 1.2rem;
            }

            .meta {
                font-size: 0.85rem;
            }

            .navigation {
                flex-direction: column;
            }

            table {
                font-size: 0.85rem;
            }

            th, td {
                padding: var(--spacing-xs);
            }
        }
    </style>

    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ startOnLoad: true, theme: 'default' });
    </script>

    <!-- MathJax for LaTeX equation rendering -->
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true,
                processEnvironments: true
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
                ignoreHtmlClass: 'mermaid'
            }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" id="MathJax-script" async></script>
</head>
<body>
    <header>
        <div class="header-content">
            <h1>第1章：推薦システム基礎</h1>
            <p class="subtitle">推薦システムの基本概念とデータ処理の基盤</p>
            <div class="meta">
                <span class="meta-item">📖 読了時間: 25-30分</span>
                <span class="meta-item">📊 難易度: 初級</span>
                <span class="meta-item">💻 コード例: 9個</span>
                <span class="meta-item">📝 演習問題: 5問</span>
            </div>
        </div>
    </header>

    <main class="container">

<h2>学習目標</h2>
<p>この章を読むことで、以下を習得できます：</p>
<ul>
<li>✅ 推薦システムの役割とビジネス価値を理解する</li>
<li>✅ 推薦タスクの分類と評価指標を学ぶ</li>
<li>✅ Cold Start問題など主要な課題を把握する</li>
<li>✅ MovieLensデータセットの前処理ができる</li>
<li>✅ User-Item行列を構築し、Train-Test分割を実装できる</li>
<li>✅ Pythonで推薦システムの基礎を実装できる</li>
</ul>

<hr>

<h2>1.1 推薦システムとは</h2>

<h3>パーソナライゼーションの重要性</h3>
<p><strong>推薦システム（Recommendation System）</strong>は、ユーザーの好みや行動に基づいて、最適なアイテム（商品、コンテンツ、サービスなど）を提案する技術です。</p>

<blockquote>
<p>「情報過多の時代において、推薦システムはユーザーと価値あるコンテンツを結びつける重要な役割を果たします。」</p>
</blockquote>

<h3>推薦システムの応用例</h3>

<table>
<thead>
<tr>
<th>業界</th>
<th>応用例</th>
<th>推薦対象</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>E-commerce</strong></td>
<td>Amazon, 楽天</td>
<td>商品</td>
</tr>
<tr>
<td><strong>動画配信</strong></td>
<td>Netflix, YouTube</td>
<td>映画、動画</td>
</tr>
<tr>
<td><strong>音楽配信</strong></td>
<td>Spotify, Apple Music</td>
<td>楽曲、プレイリスト</td>
</tr>
<tr>
<td><strong>SNS</strong></td>
<td>Facebook, Twitter</td>
<td>友人、投稿</td>
</tr>
<tr>
<td><strong>ニュース</strong></td>
<td>Google News</td>
<td>記事</td>
</tr>
<tr>
<td><strong>求人</strong></td>
<td>LinkedIn</td>
<td>求人、候補者</td>
</tr>
</tbody>
</table>

<h3>ビジネス価値</h3>

<ul>
<li><strong>売上向上</strong>: クロスセル・アップセルによる収益増加（Amazonの売上の35%は推薦から）</li>
<li><strong>エンゲージメント向上</strong>: ユーザーの滞在時間とコンテンツ消費量の増加</li>
<li><strong>顧客満足度向上</strong>: パーソナライズされた体験による満足度向上</li>
<li><strong>チャーン率低下</strong>: 関連性の高いコンテンツ提供による離脱防止</li>
<li><strong>在庫最適化</strong>: ロングテール商品の発見と販売促進</li>
</ul>

<h3>推薦の種類</h3>

<div class="mermaid">
graph TD
    A[推薦システム] --> B[協調フィルタリング]
    A --> C[コンテンツベース]
    A --> D[ハイブリッド]

    B --> B1[User-based]
    B --> B2[Item-based]
    B --> B3[Matrix Factorization]

    C --> C1[特徴量抽出]
    C --> C2[類似度計算]

    D --> D1[Weighted Hybrid]
    D --> D2[Switching Hybrid]
    D --> D3[Feature Combination]

    style A fill:#e8f5e9
    style B fill:#e3f2fd
    style C fill:#fff3e0
    style D fill:#f3e5f5
</div>

<hr>

<h2>1.2 推薦タスクの分類</h2>

<h3>Explicit vs Implicit Feedback</h3>

<p>ユーザーのフィードバックには、明示的なものと暗黙的なものがあります。</p>

<table>
<thead>
<tr>
<th>フィードバック種類</th>
<th>説明</th>
<th>例</th>
<th>長所</th>
<th>短所</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Explicit</strong><br>（明示的）</td>
<td>ユーザーが直接評価</td>
<td>星評価、いいね、レビュー</td>
<td>明確な好み情報</td>
<td>データが少ない</td>
</tr>
<tr>
<td><strong>Implicit</strong><br>（暗黙的）</td>
<td>行動から推測</td>
<td>クリック、視聴時間、購入</td>
<td>大量のデータ</td>
<td>解釈が曖昧</td>
</tr>
</tbody>
</table>

<h4>Explicit Feedbackの例</h4>

<pre><code class="language-python">import pandas as pd
import numpy as np

# Explicit Feedback: 映画の評価データ
np.random.seed(42)
n_ratings = 100

explicit_data = pd.DataFrame({
    'user_id': np.random.randint(1, 21, n_ratings),
    'item_id': np.random.randint(1, 51, n_ratings),
    'rating': np.random.randint(1, 6, n_ratings),  # 1-5の評価
    'timestamp': pd.date_range('2024-01-01', periods=n_ratings, freq='H')
})

print("=== Explicit Feedback（評価データ）===")
print(explicit_data.head(10))
print(f"\n評価の分布:")
print(explicit_data['rating'].value_counts().sort_index())
print(f"\n平均評価: {explicit_data['rating'].mean():.2f}")
print(f"評価の標準偏差: {explicit_data['rating'].std():.2f}")
</code></pre>

<p><strong>出力</strong>：</p>
<pre><code>=== Explicit Feedback（評価データ）===
   user_id  item_id  rating           timestamp
0        7       40       4 2024-01-01 00:00:00
1       20       34       3 2024-01-01 01:00:00
2       18       48       1 2024-01-01 02:00:00
3       11       14       5 2024-01-01 03:00:00
4        6       21       1 2024-01-01 04:00:00
5       17       28       4 2024-01-01 05:00:00
6        3        9       1 2024-01-01 06:00:00
7        9       37       4 2024-01-01 07:00:00
8       20       17       5 2024-01-01 08:00:00
9        8       46       2 2024-01-01 09:00:00

評価の分布:
1    23
2    19
3    18
4    21
5    19
Name: rating, dtype: int64

平均評価: 2.98
評価の標準偏差: 1.47
</code></pre>

<h4>Implicit Feedbackの例</h4>

<pre><code class="language-python"># Implicit Feedback: 視聴データ
implicit_data = pd.DataFrame({
    'user_id': np.random.randint(1, 21, n_ratings),
    'item_id': np.random.randint(1, 51, n_ratings),
    'watch_time': np.random.randint(1, 120, n_ratings),  # 分
    'completed': np.random.choice([0, 1], n_ratings, p=[0.3, 0.7]),
    'timestamp': pd.date_range('2024-01-01', periods=n_ratings, freq='H')
})

# Implicit Feedbackから好みを推測
# 視聴時間が長い、または完了した場合を「好き」と推定
implicit_data['preference'] = (
    (implicit_data['watch_time'] > 60) |
    (implicit_data['completed'] == 1)
).astype(int)

print("\n=== Implicit Feedback（視聴データ）===")
print(implicit_data.head(10))
print(f"\n完了率: {implicit_data['completed'].mean():.1%}")
print(f"推定好み率: {implicit_data['preference'].mean():.1%}")
</code></pre>

<h3>Rating Prediction</h3>

<p><strong>Rating Prediction（評価予測）</strong>は、ユーザーがまだ評価していないアイテムに対する評価値を予測するタスクです。</p>

<p>$$
\hat{r}_{ui} = f(\text{user}_u, \text{item}_i)
$$</p>

<ul>
<li>$\hat{r}_{ui}$: ユーザー$u$のアイテム$i$に対する予測評価</li>
<li>$f$: 推薦モデル</li>
</ul>

<pre><code class="language-python">from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error, mean_absolute_error
import numpy as np

# User-Item行列の構築（簡易版）
ratings_matrix = explicit_data.pivot_table(
    index='user_id',
    columns='item_id',
    values='rating',
    aggfunc='mean'
)

print("=== User-Item評価行列 ===")
print(f"形状: {ratings_matrix.shape}")
print(f"欠損率: {ratings_matrix.isnull().sum().sum() / (ratings_matrix.shape[0] * ratings_matrix.shape[1]):.1%}")
print(f"\n行列（一部）:")
print(ratings_matrix.iloc[:5, :5])
</code></pre>

<h3>Top-N Recommendation</h3>

<p><strong>Top-N推薦</strong>は、各ユーザーに対して上位N個のアイテムを推薦するタスクです。</p>

<pre><code class="language-python"># 簡易的なTop-N推薦（人気ベース）
def popularity_based_recommendation(data, n=5):
    """人気度ベースのTop-N推薦"""
    item_popularity = data.groupby('item_id')['rating'].agg(['count', 'mean'])
    item_popularity['score'] = (
        item_popularity['count'] * 0.3 +
        item_popularity['mean'] * 0.7
    )
    top_n = item_popularity.nlargest(n, 'score')
    return top_n

top_items = popularity_based_recommendation(explicit_data, n=5)

print("\n=== Top-5推薦アイテム（人気ベース）===")
print(top_items)
print(f"\n推薦理由:")
print("- スコア = 評価数 × 0.3 + 平均評価 × 0.7")
</code></pre>

<h3>Ranking Problems</h3>

<p><strong>ランキング問題</strong>は、候補アイテムの順序付けを行うタスクです。関連度の高い順にアイテムを並べます。</p>

<pre><code class="language-python"># ランキングの例: ユーザーごとにアイテムをスコア順に並べる
def rank_items_for_user(user_id, data):
    """特定ユーザーに対するアイテムランキング"""
    # ユーザーの過去の評価傾向を考慮
    user_ratings = data[data['user_id'] == user_id]
    user_avg_rating = user_ratings['rating'].mean()

    # 全アイテムの情報
    all_items = data.groupby('item_id')['rating'].agg(['mean', 'count'])

    # スコアリング（簡易版）
    all_items['score'] = (
        all_items['mean'] * 0.5 +
        user_avg_rating * 0.3 +
        np.log1p(all_items['count']) * 0.2
    )

    ranked_items = all_items.sort_values('score', ascending=False)
    return ranked_items

# ユーザー7へのランキング
user_ranking = rank_items_for_user(7, explicit_data)
print("\n=== ユーザー7へのアイテムランキング（上位10）===")
print(user_ranking.head(10))
</code></pre>

<hr>

<h2>1.3 評価指標</h2>

<h3>Precision, Recall, F1</h3>

<p>推薦システムの精度を測定する基本的な指標です。</p>

<p>$$
\text{Precision@K} = \frac{\text{推薦した関連アイテム数}}{K}
$$</p>

<p>$$
\text{Recall@K} = \frac{\text{推薦した関連アイテム数}}{\text{全関連アイテム数}}
$$</p>

<p>$$
\text{F1@K} = 2 \cdot \frac{\text{Precision@K} \cdot \text{Recall@K}}{\text{Precision@K} + \text{Recall@K}}
$$</p>

<pre><code class="language-python">def precision_recall_at_k(recommended, relevant, k):
    """Precision@K と Recall@K を計算"""
    recommended_k = recommended[:k]

    # 推薦した中で関連があるもの
    hits = len(set(recommended_k) & set(relevant))

    precision = hits / k if k > 0 else 0
    recall = hits / len(relevant) if len(relevant) > 0 else 0

    if precision + recall > 0:
        f1 = 2 * precision * recall / (precision + recall)
    else:
        f1 = 0

    return precision, recall, f1

# 例: ユーザーへの推薦
recommended_items = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]  # 推薦したアイテム
relevant_items = [2, 3, 5, 8, 11, 15]  # 実際に関連するアイテム

for k in [5, 10]:
    p, r, f = precision_recall_at_k(recommended_items, relevant_items, k)
    print(f"\n=== K={k} での評価 ===")
    print(f"Precision@{k}: {p:.3f}")
    print(f"Recall@{k}: {r:.3f}")
    print(f"F1@{k}: {f:.3f}")
</code></pre>

<p><strong>出力</strong>：</p>
<pre><code>=== K=5 での評価 ===
Precision@5: 0.400
Recall@5: 0.333
F1@5: 0.364

=== K=10 での評価 ===
Precision@10: 0.400
Recall@10: 0.667
F1@10: 0.500
</code></pre>

<h3>NDCG (Normalized Discounted Cumulative Gain)</h3>

<p><strong>NDCG</strong>は、ランキングの質を評価する指標です。上位により関連性の高いアイテムを配置することを重視します。</p>

<p>$$
\text{DCG@K} = \sum_{i=1}^{K} \frac{2^{rel_i} - 1}{\log_2(i + 1)}
$$</p>

<p>$$
\text{NDCG@K} = \frac{\text{DCG@K}}{\text{IDCG@K}}
$$</p>

<pre><code class="language-python">import numpy as np

def dcg_at_k(relevances, k):
    """DCG@K を計算"""
    relevances = np.array(relevances[:k])
    if relevances.size:
        discounts = np.log2(np.arange(2, relevances.size + 2))
        return np.sum((2**relevances - 1) / discounts)
    return 0.0

def ndcg_at_k(relevances, k):
    """NDCG@K を計算"""
    dcg = dcg_at_k(relevances, k)
    ideal_relevances = sorted(relevances, reverse=True)
    idcg = dcg_at_k(ideal_relevances, k)

    if idcg == 0:
        return 0.0
    return dcg / idcg

# 例: 推薦結果の関連度スコア（5段階）
relevances = [3, 2, 5, 0, 1, 4, 2, 0, 3, 1]  # 推薦順の関連度

print("=== NDCG評価 ===")
for k in [3, 5, 10]:
    ndcg = ndcg_at_k(relevances, k)
    print(f"NDCG@{k}: {ndcg:.3f}")

print(f"\n関連度リスト（推薦順）: {relevances}")
print(f"理想的な順序: {sorted(relevances, reverse=True)}")
</code></pre>

<h3>MAP (Mean Average Precision)</h3>

<p><strong>MAP</strong>は、全ユーザーのAverage Precisionの平均です。</p>

<p>$$
\text{AP@K} = \frac{1}{\min(m, K)} \sum_{k=1}^{K} \text{Precision@k} \cdot \text{rel}(k)
$$</p>

<p>$$
\text{MAP@K} = \frac{1}{|U|} \sum_{u \in U} \text{AP@K}_u
$$</p>

<pre><code class="language-python">def average_precision_at_k(recommended, relevant, k):
    """Average Precision@K を計算"""
    recommended_k = recommended[:k]

    score = 0.0
    num_hits = 0.0

    for i, item in enumerate(recommended_k):
        if item in relevant:
            num_hits += 1.0
            score += num_hits / (i + 1.0)

    if len(relevant) == 0:
        return 0.0

    return score / min(len(relevant), k)

# 例: 複数ユーザーのMAP計算
users_recommendations = [
    ([1, 3, 5, 7, 9], [3, 5, 9]),      # ユーザー1
    ([2, 4, 6, 8, 10], [4, 8]),        # ユーザー2
    ([1, 2, 3, 4, 5], [1, 2, 5]),      # ユーザー3
]

aps = []
for recommended, relevant in users_recommendations:
    ap = average_precision_at_k(recommended, relevant, k=5)
    aps.append(ap)
    print(f"推薦: {recommended}, 関連: {relevant} -> AP@5: {ap:.3f}")

map_score = np.mean(aps)
print(f"\n=== MAP@5: {map_score:.3f} ===")
</code></pre>

<h3>Coverage, Diversity, Serendipity</h3>

<p>推薦の質を多面的に評価する指標です。</p>

<table>
<thead>
<tr>
<th>指標</th>
<th>説明</th>
<th>目的</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Coverage</strong><br>（カバレッジ）</td>
<td>推薦されるアイテムの割合</td>
<td>ロングテールアイテムの発見</td>
</tr>
<tr>
<td><strong>Diversity</strong><br>（多様性）</td>
<td>推薦リスト内のアイテムの多様性</td>
<td>フィルターバブル回避</td>
</tr>
<tr>
<td><strong>Serendipity</strong><br>（意外性）</td>
<td>予想外で関連性の高い推薦</td>
<td>新規発見の促進</td>
</tr>
</tbody>
</table>

<pre><code class="language-python">def calculate_coverage(all_recommendations, total_items):
    """カバレッジを計算"""
    unique_recommended = set()
    for recs in all_recommendations:
        unique_recommended.update(recs)

    coverage = len(unique_recommended) / total_items
    return coverage

def calculate_diversity(recommendations):
    """推薦リストの多様性を計算（ユニーク率）"""
    unique_items = len(set(recommendations))
    diversity = unique_items / len(recommendations)
    return diversity

# 例: カバレッジと多様性の計算
all_recs = [
    [1, 2, 3, 4, 5],
    [1, 3, 6, 7, 8],
    [2, 4, 9, 10, 11],
    [1, 5, 12, 13, 14]
]

total_items = 50  # アイテム総数

coverage = calculate_coverage(all_recs, total_items)
print(f"=== カバレッジと多様性 ===")
print(f"カバレッジ: {coverage:.1%}")
print(f"推薦されたユニークアイテム: {len(set([item for recs in all_recs for item in recs]))}")

for i, recs in enumerate(all_recs):
    diversity = calculate_diversity(recs)
    print(f"ユーザー{i+1}の推薦多様性: {diversity:.1%}")
</code></pre>

<hr>

<h2>1.4 推薦システムの課題</h2>

<h3>Cold Start Problem</h3>

<p><strong>Cold Start問題</strong>は、新規ユーザーや新規アイテムに対してデータが不足している問題です。</p>

<table>
<thead>
<tr>
<th>種類</th>
<th>説明</th>
<th>対策</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>User Cold Start</strong></td>
<td>新規ユーザーの好み不明</td>
<td>人気アイテム推薦、デモグラフィック情報活用</td>
</tr>
<tr>
<td><strong>Item Cold Start</strong></td>
<td>新規アイテムの評価なし</td>
<td>コンテンツベース推薦、メタデータ活用</td>
</tr>
<tr>
<td><strong>System Cold Start</strong></td>
<td>システム全体のデータ不足</td>
<td>外部データ、クラウドソーシング</td>
</tr>
</tbody>
</table>

<h3>Data Sparsity</h3>

<p><strong>データ希薄性</strong>は、User-Item行列のほとんどが欠損値である問題です。</p>

<div class="mermaid">
graph LR
    A[User-Item行列] --> B[評価済み: 1%]
    A --> C[未評価: 99%]

    B --> D[協調フィルタリング可能]
    C --> E[推薦困難]

    style A fill:#fff3e0
    style B fill:#c8e6c9
    style C fill:#ffcdd2
    style D fill:#e8f5e9
    style E fill:#ffebee
</div>

<h3>Scalability</h3>

<p><strong>スケーラビリティ</strong>は、ユーザー数とアイテム数の増加に伴う計算量の問題です。</p>

<ul>
<li>ユーザー数: 100万人</li>
<li>アイテム数: 10万個</li>
<li>→ User-Item行列: 1000億セル</li>
</ul>

<blockquote>
<p><strong>対策</strong>: 次元削減（Matrix Factorization）、近似最近傍探索（ANN）、分散処理</p>
</blockquote>

<h3>Filter Bubble</h3>

<p><strong>フィルターバブル</strong>は、似たアイテムばかり推薦され、多様性が失われる問題です。</p>

<ul>
<li><strong>原因</strong>: 過度なパーソナライゼーション</li>
<li><strong>影響</strong>: 新規発見の減少、偏った情報消費</li>
<li><strong>対策</strong>: 多様性の考慮、セレンディピティの導入、探索と活用のバランス</li>
</ul>

<hr>

<h2>1.5 データセットと前処理</h2>

<h3>MovieLens Dataset</h3>

<p><strong>MovieLens</strong>は、推薦システム研究で最も広く使われるデータセットです。</p>

<table>
<thead>
<tr>
<th>バージョン</th>
<th>評価数</th>
<th>ユーザー数</th>
<th>映画数</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>100K</td>
<td>10万</td>
<td>943</td>
<td>1,682</td>
<td>学習、プロトタイプ</td>
</tr>
<tr>
<td>1M</td>
<td>100万</td>
<td>6,040</td>
<td>3,706</td>
<td>研究、評価</td>
</tr>
<tr>
<td>10M</td>
<td>1000万</td>
<td>71,567</td>
<td>10,681</td>
<td>スケーラビリティ検証</td>
</tr>
<tr>
<td>25M</td>
<td>2500万</td>
<td>162,541</td>
<td>62,423</td>
<td>大規模実験</td>
</tr>
</tbody>
</table>

<h3>User-Item Matrix</h3>

<p><strong>User-Item行列</strong>は、推薦システムの基本的なデータ構造です。</p>

<pre><code class="language-python">import pandas as pd
import numpy as np
from scipy.sparse import csr_matrix

# サンプルデータの作成（MovieLens風）
np.random.seed(42)
n_users = 100
n_items = 50
n_ratings = 500

ratings_data = pd.DataFrame({
    'user_id': np.random.randint(1, n_users + 1, n_ratings),
    'item_id': np.random.randint(1, n_items + 1, n_ratings),
    'rating': np.random.randint(1, 6, n_ratings),
    'timestamp': pd.date_range('2024-01-01', periods=n_ratings, freq='H')
})

# 重複を削除（同じユーザー・アイテムペアの最新評価を保持）
ratings_data = ratings_data.sort_values('timestamp').drop_duplicates(
    subset=['user_id', 'item_id'],
    keep='last'
)

print("=== 評価データ ===")
print(ratings_data.head(10))
print(f"\n総評価数: {len(ratings_data)}")
print(f"ユニークユーザー: {ratings_data['user_id'].nunique()}")
print(f"ユニークアイテム: {ratings_data['item_id'].nunique()}")
print(f"評価分布:\n{ratings_data['rating'].value_counts().sort_index()}")

# User-Item行列の構築
user_item_matrix = ratings_data.pivot_table(
    index='user_id',
    columns='item_id',
    values='rating',
    fill_value=0
)

print(f"\n=== User-Item行列 ===")
print(f"形状: {user_item_matrix.shape}")
print(f"密度: {(user_item_matrix > 0).sum().sum() / (user_item_matrix.shape[0] * user_item_matrix.shape[1]):.1%}")
print(f"\n行列の一部（最初の5ユーザー × 5アイテム）:")
print(user_item_matrix.iloc[:5, :5])

# 疎行列への変換（メモリ効率化）
sparse_matrix = csr_matrix(user_item_matrix.values)
print(f"\n疎行列サイズ: {sparse_matrix.data.nbytes / 1024:.2f} KB")
print(f"密行列サイズ: {user_item_matrix.values.nbytes / 1024:.2f} KB")
print(f"メモリ削減率: {(1 - sparse_matrix.data.nbytes / user_item_matrix.values.nbytes):.1%}")
</code></pre>

<h3>Train-Test Split Strategies</h3>

<p>推薦システムでは、時系列を考慮した分割が重要です。</p>

<pre><code class="language-python">from sklearn.model_selection import train_test_split

# 1. ランダム分割（単純だが時系列を無視）
train_random, test_random = train_test_split(
    ratings_data,
    test_size=0.2,
    random_state=42
)

print("=== 1. ランダム分割 ===")
print(f"訓練データ: {len(train_random)}件")
print(f"テストデータ: {len(test_random)}件")

# 2. 時系列分割（より現実的）
ratings_data_sorted = ratings_data.sort_values('timestamp')
split_idx = int(len(ratings_data_sorted) * 0.8)

train_temporal = ratings_data_sorted.iloc[:split_idx]
test_temporal = ratings_data_sorted.iloc[split_idx:]

print("\n=== 2. 時系列分割 ===")
print(f"訓練期間: {train_temporal['timestamp'].min()} ~ {train_temporal['timestamp'].max()}")
print(f"テスト期間: {test_temporal['timestamp'].min()} ~ {test_temporal['timestamp'].max()}")
print(f"訓練データ: {len(train_temporal)}件")
print(f"テストデータ: {len(test_temporal)}件")

# 3. ユーザーごとの分割（Leave-One-Out）
def leave_one_out_split(data):
    """各ユーザーの最新評価をテストセットに"""
    train_list = []
    test_list = []

    for user_id, group in data.groupby('user_id'):
        group_sorted = group.sort_values('timestamp')
        if len(group_sorted) > 1:
            train_list.append(group_sorted.iloc[:-1])
            test_list.append(group_sorted.iloc[-1:])
        else:
            train_list.append(group_sorted)

    train = pd.concat(train_list)
    test = pd.concat(test_list) if test_list else pd.DataFrame()

    return train, test

train_loo, test_loo = leave_one_out_split(ratings_data)

print("\n=== 3. Leave-One-Out分割 ===")
print(f"訓練データ: {len(train_loo)}件")
print(f"テストデータ: {len(test_loo)}件")
print(f"テストユーザー数: {test_loo['user_id'].nunique()}")
</code></pre>

<h3>Python Preprocessing</h3>

<p>推薦システムのデータ前処理の実践例です。</p>

<pre><code class="language-python">import pandas as pd
import numpy as np

class RecommendationDataPreprocessor:
    """推薦システムデータの前処理クラス"""

    def __init__(self, min_user_ratings=5, min_item_ratings=5):
        self.min_user_ratings = min_user_ratings
        self.min_item_ratings = min_item_ratings
        self.user_mapping = {}
        self.item_mapping = {}

    def filter_rare_users_items(self, data):
        """評価数が少ないユーザー・アイテムを除外"""
        print("=== フィルタリング前 ===")
        print(f"ユーザー数: {data['user_id'].nunique()}")
        print(f"アイテム数: {data['item_id'].nunique()}")
        print(f"評価数: {len(data)}")

        # ユーザーのフィルタリング
        user_counts = data['user_id'].value_counts()
        valid_users = user_counts[user_counts >= self.min_user_ratings].index
        data = data[data['user_id'].isin(valid_users)]

        # アイテムのフィルタリング
        item_counts = data['item_id'].value_counts()
        valid_items = item_counts[item_counts >= self.min_item_ratings].index
        data = data[data['item_id'].isin(valid_items)]

        print("\n=== フィルタリング後 ===")
        print(f"ユーザー数: {data['user_id'].nunique()}")
        print(f"アイテム数: {data['item_id'].nunique()}")
        print(f"評価数: {len(data)}")

        return data

    def create_mappings(self, data):
        """ユーザー・アイテムIDを連続した整数にマッピング"""
        unique_users = sorted(data['user_id'].unique())
        unique_items = sorted(data['item_id'].unique())

        self.user_mapping = {uid: idx for idx, uid in enumerate(unique_users)}
        self.item_mapping = {iid: idx for idx, iid in enumerate(unique_items)}

        data['user_idx'] = data['user_id'].map(self.user_mapping)
        data['item_idx'] = data['item_id'].map(self.item_mapping)

        print("\n=== IDマッピング ===")
        print(f"ユーザーID範囲: {data['user_id'].min()} ~ {data['user_id'].max()}")
        print(f"ユーザーインデックス範囲: {data['user_idx'].min()} ~ {data['user_idx'].max()}")
        print(f"アイテムID範囲: {data['item_id'].min()} ~ {data['item_id'].max()}")
        print(f"アイテムインデックス範囲: {data['item_idx'].min()} ~ {data['item_idx'].max()}")

        return data

    def normalize_ratings(self, data, method='mean'):
        """評価値を正規化"""
        if method == 'mean':
            # 平均を引く
            user_means = data.groupby('user_id')['rating'].transform('mean')
            data['rating_normalized'] = data['rating'] - user_means
        elif method == 'minmax':
            # [0, 1]にスケーリング
            data['rating_normalized'] = (data['rating'] - data['rating'].min()) / (
                data['rating'].max() - data['rating'].min()
            )

        print(f"\n=== 評価正規化（{method}）===")
        print(f"元の評価範囲: [{data['rating'].min()}, {data['rating'].max()}]")
        print(f"正規化後の範囲: [{data['rating_normalized'].min():.2f}, {data['rating_normalized'].max():.2f}]")

        return data

# 前処理の実行
preprocessor = RecommendationDataPreprocessor(
    min_user_ratings=3,
    min_item_ratings=3
)

# データのフィルタリング
filtered_data = preprocessor.filter_rare_users_items(ratings_data)

# IDマッピング
mapped_data = preprocessor.create_mappings(filtered_data)

# 評価正規化
normalized_data = preprocessor.normalize_ratings(mapped_data, method='mean')

print("\n=== 前処理完了データ（サンプル）===")
print(normalized_data[['user_id', 'user_idx', 'item_id', 'item_idx',
                        'rating', 'rating_normalized']].head(10))
</code></pre>

<hr>

<h2>1.6 本章のまとめ</h2>

<h3>学んだこと</h3>

<ol>
<li><p><strong>推薦システムの役割</strong></p>
<ul>
<li>情報過多の時代に最適なコンテンツを提案</li>
<li>売上向上、エンゲージメント向上、顧客満足度向上に貢献</li>
<li>協調フィルタリング、コンテンツベース、ハイブリッド手法</li>
</ul></li>

<li><p><strong>推薦タスクの種類</strong></p>
<ul>
<li>Explicit vs Implicit Feedback</li>
<li>Rating Prediction、Top-N推薦、ランキング</li>
<li>タスクに応じた適切な手法選択</li>
</ul></li>

<li><p><strong>評価指標</strong></p>
<ul>
<li>Precision、Recall、F1: 精度の基本指標</li>
<li>NDCG: ランキング品質の評価</li>
<li>MAP: 平均精度の評価</li>
<li>Coverage、Diversity、Serendipity: 推薦の質</li>
</ul></li>

<li><p><strong>主要な課題</strong></p>
<ul>
<li>Cold Start問題: 新規ユーザー・アイテムの対処</li>
<li>Data Sparsity: 疎なデータの扱い</li>
<li>Scalability: 大規模データの処理</li>
<li>Filter Bubble: 多様性の確保</li>
</ul></li>

<li><p><strong>データ処理の実践</strong></p>
<ul>
<li>MovieLensデータセットの活用</li>
<li>User-Item行列の構築</li>
<li>適切なTrain-Test分割</li>
<li>前処理パイプラインの構築</li>
</ul></li>
</ol>

<h3>推薦システム設計の原則</h3>

<table>
<thead>
<tr>
<th>原則</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>ユーザー中心設計</strong></td>
<td>ユーザーの満足度と体験を最優先</td>
</tr>
<tr>
<td><strong>多面的評価</strong></td>
<td>精度だけでなく多様性、新規性も考慮</td>
</tr>
<tr>
<td><strong>時系列考慮</strong></td>
<td>評価の時系列を尊重した分割と評価</td>
</tr>
<tr>
<td><strong>スケーラビリティ</strong></td>
<td>大規模データに対応できる設計</td>
</tr>
<tr>
<td><strong>継続的改善</strong></td>
<td>A/Bテストと定期的な評価で改善</td>
</tr>
</tbody>
</table>

<h3>次の章へ</h3>

<p>第2章では、<strong>協調フィルタリング</strong>を学びます：</p>
<ul>
<li>User-based協調フィルタリング</li>
<li>Item-based協調フィルタリング</li>
<li>類似度計算（コサイン類似度、ピアソン相関）</li>
<li>近傍探索とk-NN</li>
<li>実装と評価</li>
</ul>

<hr>

<h2>演習問題</h2>

<h3>問題1（難易度：easy）</h3>
<p>Explicit FeedbackとImplicit Feedbackの違いを説明し、それぞれの長所と短所を述べてください。</p>

<details>
<summary>解答例</summary>

<p><strong>解答</strong>：</p>

<p><strong>Explicit Feedback（明示的フィードバック）</strong>：</p>
<ul>
<li>定義: ユーザーが意図的に提供する評価（星評価、いいね、レビュー）</li>
<li>長所: 明確な好み情報、解釈が容易</li>
<li>短所: データ収集が困難、ユーザーの負担が大きい、データ量が少ない</li>
</ul>

<p><strong>Implicit Feedback（暗黙的フィードバック）</strong>：</p>
<ul>
<li>定義: ユーザーの行動から推測される好み（クリック、視聴時間、購入）</li>
<li>長所: 大量のデータ、ユーザー負担なし、自然な行動</li>
<li>短所: 解釈が曖昧（クリックが好みとは限らない）、ネガティブフィードバック不明</li>
</ul>

<p><strong>使い分け</strong>：</p>
<ul>
<li>Explicit: 評価が重要な分野（映画、書籍レビュー）</li>
<li>Implicit: 大規模サービス（動画配信、ECサイト）</li>
<li>Hybrid: 両方を組み合わせて精度向上</li>
</ul>

</details>

<h3>問題2（難易度：medium）</h3>
<p>以下の推薦結果に対して、Precision@5とRecall@5を計算してください。</p>

<pre><code class="language-python">recommended = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]
relevant = [2, 3, 5, 8, 11, 15, 20]
</code></pre>

<details>
<summary>解答例</summary>

<pre><code class="language-python">def precision_recall_at_k(recommended, relevant, k):
    """Precision@K と Recall@K を計算"""
    recommended_k = recommended[:k]

    # 推薦した中で関連があるもの
    hits = len(set(recommended_k) & set(relevant))

    precision = hits / k if k > 0 else 0
    recall = hits / len(relevant) if len(relevant) > 0 else 0

    return precision, recall

recommended = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]
relevant = [2, 3, 5, 8, 11, 15, 20]

precision, recall = precision_recall_at_k(recommended, relevant, k=5)

print("=== 計算過程 ===")
print(f"推薦アイテム（上位5件）: {recommended[:5]}")
print(f"関連アイテム: {relevant}")
print(f"ヒット: {set(recommended[:5]) & set(relevant)}")
print(f"ヒット数: {len(set(recommended[:5]) & set(relevant))}")
print(f"\nPrecision@5 = {len(set(recommended[:5]) & set(relevant))} / 5 = {precision:.3f}")
print(f"Recall@5 = {len(set(recommended[:5]) & set(relevant))} / {len(relevant)} = {recall:.3f}")
</code></pre>

<p><strong>出力</strong>：</p>
<pre><code>=== 計算過程 ===
推薦アイテム（上位5件）: [1, 3, 5, 7, 9]
関連アイテム: [2, 3, 5, 8, 11, 15, 20]
ヒット: {3, 5}
ヒット数: 2

Precision@5 = 2 / 5 = 0.400
Recall@5 = 2 / 7 = 0.286
</code></pre>

</details>

<h3>問題3（難易度：medium）</h3>
<p>Cold Start問題の3つの種類（User、Item、System）をそれぞれ説明し、対処法を提案してください。</p>

<details>
<summary>解答例</summary>

<p><strong>解答</strong>：</p>

<p><strong>1. User Cold Start（新規ユーザー問題）</strong>：</p>
<ul>
<li>説明: 新規ユーザーは評価履歴がなく、好みが不明</li>
<li>対処法:
<ul>
<li>人気アイテムの推薦（全体での人気度）</li>
<li>デモグラフィック情報（年齢、性別、地域）を活用</li>
<li>初期質問によるプロファイリング</li>
<li>ソーシャルネットワーク情報の活用</li>
</ul>
</li>
</ul>

<p><strong>2. Item Cold Start（新規アイテム問題）</strong>：</p>
<ul>
<li>説明: 新規アイテムは評価がなく、推薦できない</li>
<li>対処法:
<ul>
<li>コンテンツベース推薦（アイテムの特徴から類似性計算）</li>
<li>メタデータ活用（ジャンル、タグ、説明文）</li>
<li>アクティブユーザーへの優先提示</li>
<li>専門家による初期評価</li>
</ul>
</li>
</ul>

<p><strong>3. System Cold Start（システム全体の問題）</strong>：</p>
<ul>
<li>説明: サービス開始直後でユーザー・アイテムともにデータ不足</li>
<li>対処法:
<ul>
<li>外部データソースの活用（既存レビューサイト）</li>
<li>クラウドソーシングによる初期データ収集</li>
<li>エキスパートキュレーション</li>
<li>Transfer Learning（他ドメインからの知識転移）</li>
</ul>
</li>
</ul>

<p><strong>実例</strong>：</p>
<ul>
<li>Netflix: 新規ユーザーに好きな作品を3つ選ばせる</li>
<li>Spotify: 好きなアーティストを選択させてプロファイル作成</li>
<li>Amazon: 閲覧履歴と人気商品を組み合わせて推薦</li>
</ul>

</details>

<h3>問題4（難易度：hard）</h3>
<p>以下のデータに対して、User-Item行列を構築し、時系列分割（訓練80%、テスト20%）を実装してください。また、行列の密度も計算してください。</p>

<pre><code class="language-python">import pandas as pd
import numpy as np

np.random.seed(42)
data = pd.DataFrame({
    'user_id': [1, 1, 2, 2, 2, 3, 3, 4, 4, 5],
    'item_id': [10, 20, 10, 30, 40, 20, 30, 10, 50, 40],
    'rating': [5, 4, 3, 5, 2, 4, 5, 3, 4, 5],
    'timestamp': pd.date_range('2024-01-01', periods=10, freq='D')
})
</code></pre>

<details>
<summary>解答例</summary>

<pre><code class="language-python">import pandas as pd
import numpy as np

np.random.seed(42)
data = pd.DataFrame({
    'user_id': [1, 1, 2, 2, 2, 3, 3, 4, 4, 5],
    'item_id': [10, 20, 10, 30, 40, 20, 30, 10, 50, 40],
    'rating': [5, 4, 3, 5, 2, 4, 5, 3, 4, 5],
    'timestamp': pd.date_range('2024-01-01', periods=10, freq='D')
})

print("=== 元データ ===")
print(data)

# User-Item行列の構築
user_item_matrix = data.pivot_table(
    index='user_id',
    columns='item_id',
    values='rating',
    fill_value=0
)

print("\n=== User-Item行列 ===")
print(user_item_matrix)

# 密度の計算
total_cells = user_item_matrix.shape[0] * user_item_matrix.shape[1]
non_zero_cells = (user_item_matrix > 0).sum().sum()
density = non_zero_cells / total_cells

print(f"\n=== 行列の統計 ===")
print(f"形状: {user_item_matrix.shape}")
print(f"総セル数: {total_cells}")
print(f"評価済みセル数: {non_zero_cells}")
print(f"密度: {density:.1%}")
print(f"疎度: {(1 - density):.1%}")

# 時系列分割
data_sorted = data.sort_values('timestamp')
split_idx = int(len(data_sorted) * 0.8)

train_data = data_sorted.iloc[:split_idx]
test_data = data_sorted.iloc[split_idx:]

print("\n=== 時系列分割 ===")
print(f"訓練データ件数: {len(train_data)}")
print(f"テストデータ件数: {len(test_data)}")
print(f"\n訓練期間: {train_data['timestamp'].min()} ~ {train_data['timestamp'].max()}")
print(f"テスト期間: {test_data['timestamp'].min()} ~ {test_data['timestamp'].max()}")

print("\n訓練データ:")
print(train_data)
print("\nテストデータ:")
print(test_data)

# 訓練データとテストデータのUser-Item行列
train_matrix = train_data.pivot_table(
    index='user_id',
    columns='item_id',
    values='rating',
    fill_value=0
)

print("\n=== 訓練データのUser-Item行列 ===")
print(train_matrix)
</code></pre>

<p><strong>出力</strong>：</p>
<pre><code>=== 元データ ===
   user_id  item_id  rating  timestamp
0        1       10       5 2024-01-01
1        1       20       4 2024-01-02
2        2       10       3 2024-01-03
3        2       30       5 2024-01-04
4        2       40       2 2024-01-05
5        3       20       4 2024-01-06
6        3       30       5 2024-01-07
7        4       10       3 2024-01-08
8        4       50       4 2024-01-09
9        5       40       5 2024-01-10

=== User-Item行列 ===
item_id  10  20  30  40  50
user_id
1         5   4   0   0   0
2         3   0   5   2   0
3         0   4   5   0   0
4         3   0   0   0   4
5         0   0   0   5   0

=== 行列の統計 ===
形状: (5, 5)
総セル数: 25
評価済みセル数: 10
密度: 40.0%
疎度: 60.0%

=== 時系列分割 ===
訓練データ件数: 8
テストデータ件数: 2

訓練期間: 2024-01-01 ~ 2024-01-08
テスト期間: 2024-01-09 ~ 2024-01-10

訓練データ:
   user_id  item_id  rating  timestamp
0        1       10       5 2024-01-01
1        1       20       4 2024-01-02
2        2       10       3 2024-01-03
3        2       30       5 2024-01-04
4        2       40       2 2024-01-05
5        3       20       4 2024-01-06
6        3       30       5 2024-01-07
7        4       10       3 2024-01-08

テストデータ:
   user_id  item_id  rating  timestamp
8        4       50       4 2024-01-09
9        5       40       5 2024-01-10

=== 訓練データのUser-Item行列 ===
item_id  10  20  30  40
user_id
1         5   4   0   0
2         3   0   5   2
3         0   4   5   0
4         3   0   0   0
</code></pre>

</details>

<h3>問題5（難易度：hard）</h3>
<p>NDCG@5を計算する関数を実装し、以下の推薦結果の品質を評価してください。関連度スコアは5段階（0-4）です。</p>

<pre><code class="language-python">relevances = [3, 2, 0, 1, 4, 0, 2, 3, 1, 0]  # 推薦順の関連度
</code></pre>

<details>
<summary>解答例</summary>

<pre><code class="language-python">import numpy as np

def dcg_at_k(relevances, k):
    """DCG@K を計算

    DCG@K = Σ (2^rel_i - 1) / log2(i + 1)
    """
    relevances = np.array(relevances[:k])
    if relevances.size:
        # 位置iのディスカウント係数: log2(i + 1)
        # i=1から始まるため、log2(2), log2(3), ...
        discounts = np.log2(np.arange(2, relevances.size + 2))
        gains = 2**relevances - 1
        dcg = np.sum(gains / discounts)
        return dcg
    return 0.0

def ndcg_at_k(relevances, k):
    """NDCG@K を計算

    NDCG@K = DCG@K / IDCG@K
    """
    dcg = dcg_at_k(relevances, k)

    # Ideal DCG: 関連度を降順にソートした場合のDCG
    ideal_relevances = sorted(relevances, reverse=True)
    idcg = dcg_at_k(ideal_relevances, k)

    if idcg == 0:
        return 0.0

    ndcg = dcg / idcg
    return ndcg

# 例: 推薦結果の評価
relevances = [3, 2, 0, 1, 4, 0, 2, 3, 1, 0]

print("=== NDCG評価 ===")
print(f"推薦順の関連度: {relevances}")
print(f"理想的な順序: {sorted(relevances, reverse=True)}")

for k in [3, 5, 10]:
    dcg = dcg_at_k(relevances, k)
    ideal_relevances = sorted(relevances, reverse=True)
    idcg = dcg_at_k(ideal_relevances, k)
    ndcg = ndcg_at_k(relevances, k)

    print(f"\n=== K={k} ===")
    print(f"DCG@{k}: {dcg:.3f}")
    print(f"IDCG@{k}: {idcg:.3f}")
    print(f"NDCG@{k}: {ndcg:.3f}")

# 詳細計算例（K=5）
print("\n=== 詳細計算（K=5）===")
k = 5
rels = relevances[:k]
print(f"上位{k}件の関連度: {rels}")

for i, rel in enumerate(rels):
    pos = i + 1
    gain = 2**rel - 1
    discount = np.log2(pos + 1)
    contribution = gain / discount
    print(f"位置{pos}: rel={rel}, gain={gain}, discount={discount:.3f}, contribution={contribution:.3f}")

dcg = dcg_at_k(relevances, k)
print(f"\nDCG@5 = {dcg:.3f}")

ideal_rels = sorted(relevances, reverse=True)[:k]
print(f"\n理想的な上位{k}件: {ideal_rels}")
idcg = dcg_at_k(ideal_rels, k)
print(f"IDCG@5 = {idcg:.3f}")

ndcg = ndcg_at_k(relevances, k)
print(f"\nNDCG@5 = {dcg:.3f} / {idcg:.3f} = {ndcg:.3f}")
</code></pre>

<p><strong>出力</strong>：</p>
<pre><code>=== NDCG評価 ===
推薦順の関連度: [3, 2, 0, 1, 4, 0, 2, 3, 1, 0]
理想的な順序: [4, 3, 3, 2, 2, 1, 1, 0, 0, 0]

=== K=3 ===
DCG@3: 7.500
IDCG@3: 11.131
NDCG@3: 0.674

=== K=5 ===
DCG@5: 16.714
IDCG@5: 19.714
NDCG@5: 0.848

=== K=10 ===
DCG@10: 20.344
IDCG@10: 23.344
NDCG@10: 0.871

=== 詳細計算（K=5）===
上位5件の関連度: [3, 2, 0, 1, 4]
位置1: rel=3, gain=7, discount=1.000, contribution=7.000
位置2: rel=2, gain=3, discount=1.585, contribution=1.893
位置3: rel=0, gain=0, discount=2.000, contribution=0.000
位置4: rel=1, gain=1, discount=2.322, contribution=0.431
位置5: rel=4, gain=15, discount=2.585, contribution=5.803

DCG@5 = 15.127

理想的な上位5件: [4, 3, 3, 2, 2]
IDCG@5 = 19.714

NDCG@5 = 15.127 / 19.714 = 0.767
</code></pre>

</details>

<hr>

<h2>参考文献</h2>

<ol>
<li>Ricci, F., Rokach, L., & Shapira, B. (2015). <em>Recommender Systems Handbook</em> (2nd ed.). Springer.</li>
<li>Aggarwal, C. C. (2016). <em>Recommender Systems: The Textbook</em>. Springer.</li>
<li>Falk, K. (2019). <em>Practical Recommender Systems</em>. Manning Publications.</li>
<li>Harper, F. M., & Konstan, J. A. (2015). The MovieLens Datasets: History and Context. <em>ACM Transactions on Interactive Intelligent Systems</em>, 5(4), 1-19.</li>
<li>Koren, Y., Bell, R., & Volinsky, C. (2009). Matrix Factorization Techniques for Recommender Systems. <em>Computer</em>, 42(8), 30-37.</li>
</ol>

<div class="navigation">
    <a href="index.html" class="nav-button">← シリーズ目次</a>
    <a href="chapter2-collaborative-filtering.html" class="nav-button">次の章: 協調フィルタリング →</a>
</div>

    </main>

    <footer>
        <p><strong>作成者</strong>: AI Terakoya Content Team</p>
        <p><strong>監修</strong>: Dr. Yusuke Hashimoto（東北大学）</p>
        <p><strong>バージョン</strong>: 1.0 | <strong>作成日</strong>: 2025-10-21</p>
        <p><strong>ライセンス</strong>: Creative Commons BY 4.0</p>
        <p>© 2025 AI Terakoya. All rights reserved.</p>
    </footer>
</body>
</html>
