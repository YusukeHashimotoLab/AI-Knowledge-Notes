<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>第2章：交差検証とデータ分割 - AI Terakoya</title>

    <style>
        :root {
            --color-primary: #2c3e50;
            --color-primary-dark: #1a252f;
            --color-accent: #7b2cbf;
            --color-accent-light: #9d4edd;
            --color-text: #2d3748;
            --color-text-light: #4a5568;
            --color-bg: #ffffff;
            --color-bg-alt: #f7fafc;
            --color-border: #e2e8f0;
            --color-code-bg: #f8f9fa;
            --color-link: #3182ce;
            --color-link-hover: #2c5aa0;

            --spacing-xs: 0.5rem;
            --spacing-sm: 1rem;
            --spacing-md: 1.5rem;
            --spacing-lg: 2rem;
            --spacing-xl: 3rem;

            --font-body: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            --font-mono: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;

            --border-radius: 8px;
            --box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-body);
            line-height: 1.7;
            color: var(--color-text);
            background-color: var(--color-bg);
            font-size: 16px;
        }

        header {
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            color: white;
            padding: var(--spacing-xl) var(--spacing-md);
            margin-bottom: var(--spacing-xl);
            box-shadow: var(--box-shadow);
        }

        .header-content {
            max-width: 900px;
            margin: 0 auto;
        }

        h1 {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: var(--spacing-sm);
            line-height: 1.2;
        }

        .subtitle {
            font-size: 1.1rem;
            opacity: 0.95;
            font-weight: 400;
            margin-bottom: var(--spacing-md);
        }

        .meta {
            display: flex;
            flex-wrap: wrap;
            gap: var(--spacing-md);
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .meta-item {
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 0 var(--spacing-md) var(--spacing-xl);
        }

        h2 {
            font-size: 1.75rem;
            color: var(--color-primary);
            margin-top: var(--spacing-xl);
            margin-bottom: var(--spacing-md);
            padding-bottom: var(--spacing-xs);
            border-bottom: 3px solid var(--color-accent);
        }

        h3 {
            font-size: 1.4rem;
            color: var(--color-primary);
            margin-top: var(--spacing-lg);
            margin-bottom: var(--spacing-sm);
        }

        h4 {
            font-size: 1.1rem;
            color: var(--color-primary-dark);
            margin-top: var(--spacing-md);
            margin-bottom: var(--spacing-sm);
        }

        p {
            margin-bottom: var(--spacing-md);
            color: var(--color-text);
        }

        a {
            color: var(--color-link);
            text-decoration: none;
            transition: color 0.2s;
        }

        a:hover {
            color: var(--color-link-hover);
            text-decoration: underline;
        }

        ul, ol {
            margin-left: var(--spacing-lg);
            margin-bottom: var(--spacing-md);
        }

        li {
            margin-bottom: var(--spacing-xs);
            color: var(--color-text);
        }

        pre {
            background-color: var(--color-code-bg);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            overflow-x: auto;
            margin-bottom: var(--spacing-md);
            font-family: var(--font-mono);
            font-size: 0.9rem;
            line-height: 1.5;
        }

        code {
            font-family: var(--font-mono);
            font-size: 0.9em;
            background-color: var(--color-code-bg);
            padding: 0.2em 0.4em;
            border-radius: 3px;
        }

        pre code {
            background-color: transparent;
            padding: 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: var(--spacing-md);
            font-size: 0.95rem;
        }

        th, td {
            border: 1px solid var(--color-border);
            padding: var(--spacing-sm);
            text-align: left;
        }

        th {
            background-color: var(--color-bg-alt);
            font-weight: 600;
            color: var(--color-primary);
        }

        blockquote {
            border-left: 4px solid var(--color-accent);
            padding-left: var(--spacing-md);
            margin: var(--spacing-md) 0;
            color: var(--color-text-light);
            font-style: italic;
            background-color: var(--color-bg-alt);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        .mermaid {
            text-align: center;
            margin: var(--spacing-lg) 0;
            background-color: var(--color-bg-alt);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        details {
            background-color: var(--color-bg-alt);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            margin-bottom: var(--spacing-md);
        }

        summary {
            cursor: pointer;
            font-weight: 600;
            color: var(--color-primary);
            user-select: none;
            padding: var(--spacing-xs);
            margin: calc(-1 * var(--spacing-md));
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        summary:hover {
            background-color: rgba(123, 44, 191, 0.1);
        }

        details[open] summary {
            margin-bottom: var(--spacing-md);
            border-bottom: 1px solid var(--color-border);
        }

        .navigation {
            display: flex;
            justify-content: space-between;
            gap: var(--spacing-md);
            margin: var(--spacing-xl) 0;
            padding-top: var(--spacing-lg);
            border-top: 2px solid var(--color-border);
        }

        .nav-button {
            flex: 1;
            padding: var(--spacing-md);
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            color: white;
            border-radius: var(--border-radius);
            text-align: center;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: var(--box-shadow);
        }

        .nav-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            text-decoration: none;
        }

        footer {
            margin-top: var(--spacing-xl);
            padding: var(--spacing-lg) var(--spacing-md);
            background-color: var(--color-bg-alt);
            border-top: 1px solid var(--color-border);
            text-align: center;
            font-size: 0.9rem;
            color: var(--color-text-light);
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.5rem;
            }

            h2 {
                font-size: 1.4rem;
            }

            h3 {
                font-size: 1.2rem;
            }

            .meta {
                font-size: 0.85rem;
            }

            .navigation {
                flex-direction: column;
            }

            table {
                font-size: 0.85rem;
            }

            th, td {
                padding: var(--spacing-xs);
            }
        }
    </style>

    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ startOnLoad: true, theme: 'default' });
    </script>

    <!-- MathJax for LaTeX equation rendering -->
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true,
                processEnvironments: true
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
                ignoreHtmlClass: 'mermaid'
            }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" id="MathJax-script" async></script>
</head>
<body>
    <header>
        <div class="header-content">
            <h1>第2章：交差検証とデータ分割</h1>
            <p class="subtitle">モデルの汎化性能を正しく評価するためのデータ分割戦略</p>
            <div class="meta">
                <span class="meta-item">📖 読了時間: 20-25分</span>
                <span class="meta-item">📊 難易度: 初級〜中級</span>
                <span class="meta-item">💻 コード例: 12個</span>
                <span class="meta-item">📝 演習問題: 5問</span>
            </div>
        </div>
    </header>

    <main class="container">

<h2>学習目標</h2>
<p>この章を読むことで、以下を習得できます：</p>
<ul>
<li>✅ Train/Validation/Testセットの役割と分割方法を理解する</li>
<li>✅ Hold-out法の問題点とその解決策を説明できる</li>
<li>✅ K-Fold交差検証の原理と実装ができる</li>
<li>✅ Stratified K-Foldの必要性を理解する</li>
<li>✅ 時系列データにおける交差検証の特殊性を把握する</li>
<li>✅ データリーケージを防ぐ前処理の方法を実践できる</li>
<li>✅ Nested Cross-Validationでハイパーパラメータ調整ができる</li>
</ul>

<hr>

<h2>2.1 データ分割の基礎</h2>

<h3>なぜデータを分割するのか</h3>

<p>機械学習モデルの最終目的は、<strong>未知のデータに対して正確な予測を行うこと</strong>です。そのため、モデルの性能を評価する際には、訓練データとは別の「見たことのないデータ」でテストする必要があります。</p>

<blockquote>
<p>「訓練データでの性能が良くても、新しいデータで性能が悪ければ、そのモデルは実用的ではない」</p>
</blockquote>

<h3>3つのデータセット</h3>

<table>
<thead>
<tr>
<th>セット名</th>
<th>英語名</th>
<th>役割</th>
<th>典型的な割合</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>訓練セット</strong></td>
<td>Training Set</td>
<td>モデルのパラメータを学習する</td>
<td>60-80%</td>
</tr>
<tr>
<td><strong>検証セット</strong></td>
<td>Validation Set</td>
<td>ハイパーパラメータの調整とモデル選択</td>
<td>10-20%</td>
</tr>
<tr>
<td><strong>テストセット</strong></td>
<td>Test Set</td>
<td>最終的な汎化性能の評価</td>
<td>10-20%</td>
</tr>
</tbody>
</table>

<div class="mermaid">
graph LR
    A[全データセット] --> B[訓練セット 60-80%]
    A --> C[検証セット 10-20%]
    A --> D[テストセット 10-20%]

    B --> E[パラメータ学習]
    C --> F[ハイパーパラメータ調整]
    D --> G[最終性能評価]

    style A fill:#e1f5ff
    style B fill:#b3e5fc
    style C fill:#81d4fa
    style D fill:#4fc3f7
</div>

<h3>Hold-out法：基本的なデータ分割</h3>

<p><strong>Hold-out法</strong>は、データを一度だけ訓練セットとテストセットに分割する最もシンプルな方法です。</p>

<pre><code class="language-python">import numpy as np
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.datasets import load_iris
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score

# サンプルデータ読み込み
iris = load_iris()
X, y = iris.data, iris.target

# 訓練データとテストデータに分割（8:2）
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, random_state=42
)

print(f"訓練データサイズ: {X_train.shape[0]}")
print(f"テストデータサイズ: {X_test.shape[0]}")

# モデル訓練
model = LogisticRegression(max_iter=200)
model.fit(X_train, y_train)

# 評価
train_score = accuracy_score(y_train, model.predict(X_train))
test_score = accuracy_score(y_test, model.predict(X_test))

print(f"\n訓練精度: {train_score:.4f}")
print(f"テスト精度: {test_score:.4f}")
</code></pre>

<h3>Hold-out法の問題点</h3>

<p>Hold-out法にはいくつかの<strong>重大な問題</strong>があります：</p>

<ol>
<li><strong>データの偏り</strong>：たまたま難しいサンプルがテストセットに集中する可能性</li>
<li><strong>データの無駄</strong>：テストセットとして分離したデータは訓練に使えない</li>
<li><strong>不安定性</strong>：分割方法によって評価結果が大きく変動する</li>
<li><strong>小規模データでの問題</strong>：データが少ない場合、テストセットが極端に小さくなる</li>
</ol>

<details>
<summary><strong>実験：Hold-out法の不安定性を確認</strong></summary>

<pre><code class="language-python">import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.datasets import load_iris
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score

# データ読み込み
iris = load_iris()
X, y = iris.data, iris.target

# 異なるrandom_stateで10回実験
test_scores = []
for seed in range(10):
    X_train, X_test, y_train, y_test = train_test_split(
        X, y, test_size=0.2, random_state=seed
    )

    model = LogisticRegression(max_iter=200)
    model.fit(X_train, y_train)
    score = accuracy_score(y_test, model.predict(X_test))
    test_scores.append(score)

print("=== Hold-out法の不安定性 ===")
print(f"テスト精度の平均: {np.mean(test_scores):.4f}")
print(f"テスト精度の標準偏差: {np.std(test_scores):.4f}")
print(f"最小値: {np.min(test_scores):.4f}")
print(f"最大値: {np.max(test_scores):.4f}")
print(f"\n精度の変動幅: {np.max(test_scores) - np.min(test_scores):.4f}")
</code></pre>

<p>出力例：</p>
<pre><code>=== Hold-out法の不安定性 ===
テスト精度の平均: 0.9533
テスト精度の標準偏差: 0.0356
最小値: 0.9000
最大値: 1.0000

精度の変動幅: 0.1000
</code></pre>

<p>このように、同じアルゴリズムでもデータ分割方法によって<strong>最大10%もの精度差</strong>が生じることがあります。</p>

</details>

<hr>

<h2>2.2 K-Fold交差検証</h2>

<h3>K-Fold Cross-Validationとは</h3>

<p><strong>K-Fold交差検証（K-Fold Cross-Validation）</strong>は、データをK個のサブセット（Fold）に分割し、各Foldを一度ずつテストセットとして使用する手法です。</p>

<div class="mermaid">
graph TD
    A[全データ] --> B[Fold 1]
    A --> C[Fold 2]
    A --> D[Fold 3]
    A --> E[Fold 4]
    A --> F[Fold 5]

    G[Round 1] --> H[Test: Fold 1<br/>Train: Fold 2,3,4,5]
    I[Round 2] --> J[Test: Fold 2<br/>Train: Fold 1,3,4,5]
    K[Round 3] --> L[Test: Fold 3<br/>Train: Fold 1,2,4,5]
    M[Round 4] --> N[Test: Fold 4<br/>Train: Fold 1,2,3,5]
    O[Round 5] --> P[Test: Fold 5<br/>Train: Fold 1,2,3,4]

    H --> Q[Score 1]
    J --> R[Score 2]
    L --> S[Score 3]
    N --> T[Score 4]
    P --> U[Score 5]

    Q --> V[平均スコア]
    R --> V
    S --> V
    T --> V
    U --> V

    style A fill:#e1f5ff
    style V fill:#4fc3f7
</div>

<h3>K-Fold交差検証のアルゴリズム</h3>

<ol>
<li>データを$K$個のサブセット（Fold）にランダム分割</li>
<li>各Fold $i$ ($i = 1, 2, ..., K$) に対して：
<ul>
<li>Fold $i$ をテストセットとする</li>
<li>残りの $K-1$ 個のFoldを訓練セットとする</li>
<li>モデルを訓練し、Fold $i$ で評価してスコア $S_i$ を得る</li>
</ul>
</li>
<li>$K$個のスコアの平均を最終評価とする：
$$
\text{CV Score} = \frac{1}{K} \sum_{i=1}^{K} S_i
$$
</li>
</ol>

<h3>基本的な実装</h3>

<pre><code class="language-python">import numpy as np
from sklearn.model_selection import KFold, cross_val_score
from sklearn.datasets import load_iris
from sklearn.linear_model import LogisticRegression

# データ読み込み
iris = load_iris()
X, y = iris.data, iris.target

# モデル作成
model = LogisticRegression(max_iter=200)

# 5-Fold交差検証
kfold = KFold(n_splits=5, shuffle=True, random_state=42)
scores = cross_val_score(model, X, y, cv=kfold, scoring='accuracy')

print("=== 5-Fold交差検証の結果 ===")
for i, score in enumerate(scores, 1):
    print(f"Fold {i}: {score:.4f}")

print(f"\n平均精度: {scores.mean():.4f}")
print(f"標準偏差: {scores.std():.4f}")
print(f"95%信頼区間: [{scores.mean() - 1.96*scores.std():.4f}, "
      f"{scores.mean() + 1.96*scores.std():.4f}]")
</code></pre>

<h3>K-Fold交差検証の利点</h3>

<ul>
<li><strong>安定した評価</strong>：複数回の評価の平均を取るため、偶然の影響を減らせる</li>
<li><strong>データの有効活用</strong>：すべてのデータが訓練とテストの両方に使われる</li>
<li><strong>信頼区間の推定</strong>：標準偏差からモデルの安定性を評価できる</li>
<li><strong>小規模データでも有効</strong>：限られたデータでも信頼性の高い評価が可能</li>
</ul>

<h3>K値の選択</h3>

<table>
<thead>
<tr>
<th>K値</th>
<th>訓練データ割合</th>
<th>メリット</th>
<th>デメリット</th>
<th>推奨ケース</th>
</tr>
</thead>
<tbody>
<tr>
<td>3</td>
<td>67%</td>
<td>計算が高速</td>
<td>評価が不安定</td>
<td>大規模データ、初期実験</td>
</tr>
<tr>
<td>5</td>
<td>80%</td>
<td>バランスが良い</td>
<td>-</td>
<td>標準的な選択</td>
</tr>
<tr>
<td>10</td>
<td>90%</td>
<td>評価が安定</td>
<td>計算コストが高い</td>
<td>中規模データ</td>
</tr>
<tr>
<td>N (LOOCV)</td>
<td>100% - 1</td>
<td>バイアスが最小</td>
<td>計算コストが極めて高い</td>
<td>小規模データ（N &lt; 100）</td>
</tr>
</tbody>
</table>

<blockquote>
<p><strong>経験則</strong>：実務では<strong>K=5</strong>または<strong>K=10</strong>が最もよく使われます。K=5は計算効率と評価の安定性のバランスが良いため、多くの場合に推奨されます。</p>
</blockquote>

<hr>

<h2>2.3 Stratified K-Fold</h2>

<h3>クラス不均衡問題</h3>

<p>通常のK-Fold交差検証では、各Foldにクラスが均等に分配される保証がありません。特に<strong>クラス不均衡データ</strong>（例：正例10%、負例90%）では、以下の問題が発生します：</p>

<ul>
<li>あるFoldに特定のクラスがほとんど含まれない</li>
<li>少数クラスがテストセットに全く含まれない</li>
<li>評価指標が不安定になる</li>
</ul>

<h3>Stratified K-Foldの原理</h3>

<p><strong>Stratified K-Fold</strong>は、各Foldで<strong>クラスの比率を元データと同じに保つ</strong>ように分割します。</p>

<div class="mermaid">
graph TD
    A[元データ<br/>Class A: 70%<br/>Class B: 30%] --> B[Stratified分割]

    B --> C[Fold 1<br/>Class A: 70%<br/>Class B: 30%]
    B --> D[Fold 2<br/>Class A: 70%<br/>Class B: 30%]
    B --> E[Fold 3<br/>Class A: 70%<br/>Class B: 30%]
    B --> F[Fold 4<br/>Class A: 70%<br/>Class B: 30%]
    B --> G[Fold 5<br/>Class A: 70%<br/>Class B: 30%]

    style A fill:#e1f5ff
    style C fill:#b3e5fc
    style D fill:#b3e5fc
    style E fill:#b3e5fc
    style F fill:#b3e5fc
    style G fill:#b3e5fc
</div>

<h3>実装と比較</h3>

<pre><code class="language-python">import numpy as np
from sklearn.model_selection import KFold, StratifiedKFold, cross_val_score
from sklearn.datasets import make_classification
from sklearn.linear_model import LogisticRegression

# 不均衡データを作成（正例:負例 = 1:9）
X, y = make_classification(
    n_samples=1000,
    n_features=20,
    n_informative=15,
    n_redundant=5,
    weights=[0.9, 0.1],  # 90% vs 10%
    random_state=42
)

print(f"クラス分布: Class 0 = {np.sum(y==0)}, Class 1 = {np.sum(y==1)}")
print(f"クラス比率: {np.sum(y==1)/len(y):.2%} が Class 1\n")

# モデル作成
model = LogisticRegression(max_iter=200)

# 通常のK-Fold
kfold = KFold(n_splits=5, shuffle=True, random_state=42)
scores_kfold = cross_val_score(model, X, y, cv=kfold, scoring='f1')

# Stratified K-Fold
stratified_kfold = StratifiedKFold(n_splits=5, shuffle=True, random_state=42)
scores_stratified = cross_val_score(model, X, y, cv=stratified_kfold, scoring='f1')

print("=== K-Fold vs Stratified K-Fold ===")
print(f"通常のK-Fold:")
print(f"  平均F1スコア: {scores_kfold.mean():.4f} ± {scores_kfold.std():.4f}")

print(f"\nStratified K-Fold:")
print(f"  平均F1スコア: {scores_stratified.mean():.4f} ± {scores_stratified.std():.4f}")

print(f"\n改善率: {(scores_stratified.mean() - scores_kfold.mean()) / scores_kfold.mean() * 100:.2f}%")
</code></pre>

<h3>各Foldのクラス分布を確認</h3>

<pre><code class="language-python">import numpy as np
from sklearn.model_selection import KFold, StratifiedKFold
from sklearn.datasets import make_classification

# 不均衡データ作成
X, y = make_classification(
    n_samples=1000,
    weights=[0.9, 0.1],
    random_state=42
)

# 通常のK-Fold
print("=== 通常のK-Fold のクラス分布 ===")
kfold = KFold(n_splits=5, shuffle=True, random_state=42)
for i, (train_idx, test_idx) in enumerate(kfold.split(X), 1):
    y_test = y[test_idx]
    class_1_ratio = np.sum(y_test == 1) / len(y_test)
    print(f"Fold {i}: Class 1 の割合 = {class_1_ratio:.2%}")

# Stratified K-Fold
print("\n=== Stratified K-Fold のクラス分布 ===")
stratified_kfold = StratifiedKFold(n_splits=5, shuffle=True, random_state=42)
for i, (train_idx, test_idx) in enumerate(stratified_kfold.split(X, y), 1):
    y_test = y[test_idx]
    class_1_ratio = np.sum(y_test == 1) / len(y_test)
    print(f"Fold {i}: Class 1 の割合 = {class_1_ratio:.2%}")
</code></pre>

<h3>いつStratified K-Foldを使うべきか</h3>

<ul>
<li><strong>必ず使うべき</strong>：分類問題でクラスが不均衡な場合</li>
<li><strong>推奨</strong>：すべての分類問題（バランスが良くても安定性向上）</li>
<li><strong>使えない</strong>：回帰問題（目的変数が連続値）</li>
</ul>

<blockquote>
<p><strong>ベストプラクティス</strong>：分類問題では、デフォルトで<code>StratifiedKFold</code>を使いましょう。クラスがバランスしていても、評価の安定性が向上します。</p>
</blockquote>

<hr>

<h2>2.4 Leave-One-Out交差検証</h2>

<h3>Leave-One-Out Cross-Validation (LOOCV)</h3>

<p><strong>LOOCV</strong>は、K-Foldの特殊ケースで、$K = N$（データ数）とした極端な交差検証です。</p>

<ul>
<li>各イテレーションで<strong>1つのサンプルだけ</strong>をテストセットとする</li>
<li>残りの$N-1$個のサンプルで訓練</li>
<li>$N$回の訓練と評価を実行</li>
</ul>

<h3>LOOCVの特徴</h3>

<table>
<thead>
<tr>
<th>項目</th>
<th>LOOCV</th>
<th>K-Fold (K=5)</th>
</tr>
</thead>
<tbody>
<tr>
<td>訓練データ割合</td>
<td>$(N-1)/N$ ≈ 100%</td>
<td>80%</td>
</tr>
<tr>
<td>評価回数</td>
<td>$N$回</td>
<td>5回</td>
</tr>
<tr>
<td>バイアス</td>
<td>極めて低い</td>
<td>やや高い</td>
</tr>
<tr>
<td>分散</td>
<td>高い</td>
<td>低い</td>
</tr>
<tr>
<td>計算コスト</td>
<td>非常に高い</td>
<td>低い</td>
</tr>
<tr>
<td>推奨データサイズ</td>
<td>$N < 100$</td>
<td>任意</td>
</tr>
</tbody>
</table>

<h3>実装例</h3>

<pre><code class="language-python">import numpy as np
from sklearn.model_selection import LeaveOneOut, cross_val_score
from sklearn.datasets import load_iris
from sklearn.linear_model import LogisticRegression
import time

# 小規模データで実験
iris = load_iris()
X, y = iris.data[:50], iris.target[:50]  # 50サンプルのみ

model = LogisticRegression(max_iter=200)

# LOOCV
loo = LeaveOneOut()
start_time = time.time()
scores_loo = cross_val_score(model, X, y, cv=loo, scoring='accuracy')
loo_time = time.time() - start_time

print("=== Leave-One-Out交差検証 ===")
print(f"評価回数: {len(scores_loo)}回")
print(f"平均精度: {scores_loo.mean():.4f}")
print(f"標準偏差: {scores_loo.std():.4f}")
print(f"実行時間: {loo_time:.3f}秒")

# 5-Fold CVと比較
from sklearn.model_selection import KFold
kfold = KFold(n_splits=5, shuffle=True, random_state=42)
start_time = time.time()
scores_kfold = cross_val_score(model, X, y, cv=kfold, scoring='accuracy')
kfold_time = time.time() - start_time

print("\n=== 5-Fold交差検証（比較） ===")
print(f"評価回数: {len(scores_kfold)}回")
print(f"平均精度: {scores_kfold.mean():.4f}")
print(f"標準偏差: {scores_kfold.std():.4f}")
print(f"実行時間: {kfold_time:.3f}秒")

print(f"\n速度比: LOOCV は 5-Fold の {loo_time/kfold_time:.1f}倍遅い")
</code></pre>

<h3>LOOCVのメリットとデメリット</h3>

<p><strong>メリット</strong>：</p>
<ul>
<li>訓練データを最大限活用できる（バイアスが最小）</li>
<li>決定論的（ランダム性がない）</li>
<li>小規模データで有効</li>
</ul>

<p><strong>デメリット</strong>：</p>
<ul>
<li>計算コストが極めて高い（$N$回の訓練）</li>
<li>分散が大きい（各テストが1サンプルのみ）</li>
<li>大規模データでは実用的でない</li>
</ul>

<blockquote>
<p><strong>実務での使い分け</strong>：データ数が100未満の場合のみLOOCVを検討し、それ以外はK-Foldを使用するのが現実的です。</p>
</blockquote>

<hr>

<h2>2.5 時系列データの交差検証</h2>

<h3>時系列データの特殊性</h3>

<p>時系列データでは、<strong>時間的な順序が重要</strong>です。通常のK-Foldをランダムに適用すると、以下の問題が発生します：</p>

<ul>
<li><strong>未来の情報リーク</strong>：訓練データに未来のデータが含まれる</li>
<li><strong>時間依存性の無視</strong>：過去→現在→未来という因果関係が崩れる</li>
<li><strong>非現実的な評価</strong>：実運用では常に未来を予測するのに、過去も未来も混ぜて訓練してしまう</li>
</ul>

<div class="mermaid">
graph LR
    A[❌ 通常のK-Fold] --> B[時間順序を無視]
    B --> C[未来データで訓練<br/>過去データでテスト]
    C --> D[過大評価]

    E[✅ Time Series Split] --> F[時間順序を保持]
    F --> G[過去データで訓練<br/>未来データでテスト]
    G --> H[正しい評価]

    style A fill:#ffcdd2
    style E fill:#c8e6c9
</div>

<h3>TimeSeriesSplit</h3>

<p><strong>TimeSeriesSplit</strong>は、時系列データのために設計された交差検証で、以下の特徴があります：</p>

<ul>
<li>訓練セットは常に<strong>テストセットより前</strong>の時間のデータ</li>
<li>各Foldで訓練セットが<strong>拡大</strong>していく（累積型）</li>
<li>テストセットは常に未来の一定期間</li>
</ul>

<div class="mermaid">
graph TD
    A[時系列データ: t1, t2, t3, t4, t5, t6, t7, t8, t9] --> B[Fold 1]
    A --> C[Fold 2]
    A --> D[Fold 3]
    A --> E[Fold 4]

    B --> F[Train: t1,t2,t3 | Test: t4,t5]
    C --> G[Train: t1,t2,t3,t4,t5 | Test: t6,t7]
    D --> H[Train: t1,t2,t3,t4,t5,t6,t7 | Test: t8,t9]

    style A fill:#e1f5ff
    style F fill:#b3e5fc
    style G fill:#81d4fa
    style H fill:#4fc3f7
</div>

<h3>実装例</h3>

<pre><code class="language-python">import numpy as np
import pandas as pd
from sklearn.model_selection import TimeSeriesSplit, cross_val_score
from sklearn.linear_model import Ridge
from sklearn.metrics import mean_squared_error
import matplotlib.pyplot as plt

# 時系列データ生成（日次売上データをシミュレート）
np.random.seed(42)
n_samples = 365  # 1年間の日次データ
dates = pd.date_range('2023-01-01', periods=n_samples, freq='D')

# トレンド + 季節性 + ノイズ
trend = np.linspace(100, 150, n_samples)
seasonality = 20 * np.sin(2 * np.pi * np.arange(n_samples) / 7)  # 週次周期
noise = np.random.randn(n_samples) * 5
y = trend + seasonality + noise

# 特徴量作成（過去7日間の移動平均など）
X = np.column_stack([
    np.roll(y, 1),  # 1日前
    np.roll(y, 7),  # 7日前
    pd.Series(y).rolling(7).mean().fillna(method='bfill'),  # 7日移動平均
])

# 最初の7日間を除去（rollによるデータ不足を回避）
X, y = X[7:], y[7:]

# TimeSeriesSplit
tscv = TimeSeriesSplit(n_splits=5)

print("=== TimeSeriesSplit の分割パターン ===")
for i, (train_index, test_index) in enumerate(tscv.split(X), 1):
    print(f"Fold {i}:")
    print(f"  訓練: {len(train_index)}サンプル (index {train_index[0]} ~ {train_index[-1]})")
    print(f"  テスト: {len(test_index)}サンプル (index {test_index[0]} ~ {test_index[-1]})")

# モデル評価
model = Ridge(alpha=1.0)
scores = cross_val_score(model, X, y, cv=tscv, scoring='neg_mean_squared_error')
rmse_scores = np.sqrt(-scores)

print(f"\n=== 各Foldの性能 ===")
for i, rmse in enumerate(rmse_scores, 1):
    print(f"Fold {i} RMSE: {rmse:.2f}")

print(f"\n平均RMSE: {rmse_scores.mean():.2f} ± {rmse_scores.std():.2f}")
</code></pre>

<h3>通常のK-Foldとの比較</h3>

<pre><code class="language-python">import numpy as np
from sklearn.model_selection import KFold, TimeSeriesSplit, cross_val_score
from sklearn.linear_model import Ridge

# 同じデータで通常のK-Foldを実行
kfold = KFold(n_splits=5, shuffle=False)  # shuffle=Falseで時系列順序を維持
scores_kfold = cross_val_score(model, X, y, cv=kfold, scoring='neg_mean_squared_error')
rmse_kfold = np.sqrt(-scores_kfold)

# TimeSeriesSplit
tscv = TimeSeriesSplit(n_splits=5)
scores_tscv = cross_val_score(model, X, y, cv=tscv, scoring='neg_mean_squared_error')
rmse_tscv = np.sqrt(-scores_tscv)

print("=== K-Fold vs TimeSeriesSplit ===")
print(f"K-Fold 平均RMSE: {rmse_kfold.mean():.2f} ± {rmse_kfold.std():.2f}")
print(f"TimeSeriesSplit 平均RMSE: {rmse_tscv.mean():.2f} ± {rmse_tscv.std():.2f}")

print(f"\n差分: {rmse_kfold.mean() - rmse_tscv.mean():.2f}")
print("（K-Foldの方が良い結果 = 未来情報リークによる過大評価の可能性）")
</code></pre>

<h3>時系列CVのベストプラクティス</h3>

<ul>
<li><strong>必須</strong>：時系列データには必ずTimeSeriesSplitを使う</li>
<li><strong>推奨</strong>：テストセット期間を実運用と同じ長さに設定する</li>
<li><strong>注意</strong>：特徴量作成時にも未来情報を使わない（ラグ特徴量を使用）</li>
<li><strong>検討</strong>：Walking Forward Validation（段階的検証）も検討する</li>
</ul>

<hr>

<h2>2.6 データリーケージの防止</h2>

<h3>データリーケージとは</h3>

<p><strong>データリーケージ（Data Leakage）</strong>とは、訓練データに<strong>本来知り得ない情報</strong>が混入し、モデルが過大評価される現象です。</p>

<blockquote>
<p>「訓練時に未来やテストデータの情報を使ってしまい、実運用では再現できない高性能が出てしまう」</p>
</blockquote>

<h3>よくあるデータリーケージのパターン</h3>

<table>
<thead>
<tr>
<th>リーケージの種類</th>
<th>原因</th>
<th>結果</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>前処理リーケージ</strong></td>
<td>全データで正規化してから分割</td>
<td>テストセットの統計量を訓練に使用</td>
</tr>
<tr>
<td><strong>時間的リーケージ</strong></td>
<td>未来のデータで訓練</td>
<td>因果関係が逆転</td>
</tr>
<tr>
<td><strong>ターゲットリーケージ</strong></td>
<td>目的変数から作った特徴量</td>
<td>テスト時に利用不可能な情報</td>
</tr>
<tr>
<td><strong>重複データ</strong></td>
<td>同じデータが訓練とテストに存在</td>
<td>記憶による過大評価</td>
</tr>
</tbody>
</table>

<h3>間違った前処理の例</h3>

<pre><code class="language-python">import numpy as np
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score
from sklearn.datasets import make_classification

# データ生成
X, y = make_classification(n_samples=1000, n_features=20, random_state=42)

# ❌ 間違い：分割前に全データで正規化
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)  # 全データの平均・標準偏差を使用

X_train, X_test, y_train, y_test = train_test_split(
    X_scaled, y, test_size=0.2, random_state=42
)

model = LogisticRegression(max_iter=200)
model.fit(X_train, y_train)
score_wrong = accuracy_score(y_test, model.predict(X_test))

print(f"❌ リーケージあり（間違い）: テスト精度 = {score_wrong:.4f}")
</code></pre>

<h3>正しい前処理の例</h3>

<pre><code class="language-python">import numpy as np
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score
from sklearn.datasets import make_classification

# データ生成
X, y = make_classification(n_samples=1000, n_features=20, random_state=42)

# ✅ 正しい：先に分割してから訓練データのみで正規化
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, random_state=42
)

scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)  # 訓練データのみで学習
X_test_scaled = scaler.transform(X_test)  # 訓練データの統計量を適用

model = LogisticRegression(max_iter=200)
model.fit(X_train_scaled, y_train)
score_correct = accuracy_score(y_test, model.predict(X_test_scaled))

print(f"✅ リーケージなし（正しい）: テスト精度 = {score_correct:.4f}")
</code></pre>

<h3>Pipelineを使った安全な実装</h3>

<p><code>sklearn.pipeline.Pipeline</code>を使うと、前処理とモデルを一体化し、リーケージを防げます。</p>

<pre><code class="language-python">import numpy as np
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import StandardScaler
from sklearn.linear_model import LogisticRegression
from sklearn.model_selection import cross_val_score, StratifiedKFold
from sklearn.datasets import make_classification

# データ生成
X, y = make_classification(n_samples=1000, n_features=20, random_state=42)

# Pipelineで前処理とモデルを統合
pipeline = Pipeline([
    ('scaler', StandardScaler()),
    ('classifier', LogisticRegression(max_iter=200))
])

# 交差検証（各Foldで自動的に正しく前処理される）
cv = StratifiedKFold(n_splits=5, shuffle=True, random_state=42)
scores = cross_val_score(pipeline, X, y, cv=cv, scoring='accuracy')

print("=== Pipeline + Cross-Validation ===")
print(f"各Foldで訓練データのみを使って正規化が実行されます")
print(f"平均精度: {scores.mean():.4f} ± {scores.std():.4f}")
</code></pre>

<h3>Pipelineのメリット</h3>

<ul>
<li><strong>安全性</strong>：リーケージを構造的に防止</li>
<li><strong>簡潔性</strong>：コードが短く読みやすい</li>
<li><strong>再現性</strong>：前処理パラメータが一緒に保存される</li>
<li><strong>ハイパーパラメータ調整</strong>：GridSearchCVでも正しく動作</li>
</ul>

<blockquote>
<p><strong>ベストプラクティス</strong>：実務では必ず<code>Pipeline</code>を使い、前処理をモデルと一体化させましょう。これにより、データリーケージを防ぎ、コードの保守性も向上します。</p>
</blockquote>

<hr>

<h2>2.7 Group K-Fold</h2>

<h3>グループ構造を持つデータ</h3>

<p>実世界のデータには、<strong>同じグループに属するサンプルが複数存在</strong>するケースがあります：</p>

<ul>
<li><strong>医療データ</strong>：同じ患者から複数の測定値</li>
<li><strong>画像データ</strong>：同じ人物の複数枚の写真</li>
<li><strong>時系列データ</strong>：同じ店舗の複数日のデータ</li>
</ul>

<p>通常のK-Foldでは、<strong>同じグループのデータが訓練とテストに分散</strong>してしまい、過大評価につながります。</p>

<h3>Group K-Foldの原理</h3>

<p><strong>Group K-Fold</strong>は、同じグループのデータを必ず同じFoldに配置します。</p>

<div class="mermaid">
graph TD
    A[データ<br/>Patient A: 5枚<br/>Patient B: 3枚<br/>Patient C: 4枚] --> B[Group K-Fold]

    B --> C[Fold 1<br/>Patient A の全データ]
    B --> D[Fold 2<br/>Patient B の全データ]
    B --> E[Fold 3<br/>Patient C の全データ]

    F[❌ 通常のK-Fold] --> G[Patient A のデータが<br/>訓練とテストに分散]

    style A fill:#e1f5ff
    style B fill:#c8e6c9
    style F fill:#ffcdd2
</div>

<h3>実装例</h3>

<pre><code class="language-python">import numpy as np
from sklearn.model_selection import GroupKFold, KFold, cross_val_score
from sklearn.linear_model import LogisticRegression
from sklearn.datasets import make_classification

# グループ構造を持つデータ作成
X, y = make_classification(n_samples=100, n_features=20, random_state=42)

# グループID（例：患者ID、店舗IDなど）
# 患者1が30サンプル、患者2が25サンプル、患者3が20サンプル...
groups = np.array([1]*30 + [2]*25 + [3]*20 + [4]*15 + [5]*10)

print(f"グループ数: {len(np.unique(groups))}")
print(f"各グループのサンプル数: {[np.sum(groups==g) for g in np.unique(groups)]}\n")

# モデル
model = LogisticRegression(max_iter=200)

# Group K-Fold
group_kfold = GroupKFold(n_splits=5)
scores_group = cross_val_score(model, X, y, cv=group_kfold.split(X, y, groups),
                                scoring='accuracy')

print("=== Group K-Fold ===")
print(f"平均精度: {scores_group.mean():.4f} ± {scores_group.std():.4f}")

# 通常のK-Fold（比較）
kfold = KFold(n_splits=5, shuffle=True, random_state=42)
scores_kfold = cross_val_score(model, X, y, cv=kfold, scoring='accuracy')

print("\n=== 通常のK-Fold（参考） ===")
print(f"平均精度: {scores_kfold.mean():.4f} ± {scores_kfold.std():.4f}")

print(f"\n差分: {scores_kfold.mean() - scores_group.mean():.4f}")
print("（K-Foldの方が良い = グループリーケージによる過大評価）")
</code></pre>

<h3>各Foldのグループ構成を確認</h3>

<pre><code class="language-python">import numpy as np
from sklearn.model_selection import GroupKFold

# グループK-Foldの分割パターンを確認
group_kfold = GroupKFold(n_splits=5)

print("=== Group K-Fold の分割パターン ===")
for i, (train_idx, test_idx) in enumerate(group_kfold.split(X, y, groups), 1):
    train_groups = np.unique(groups[train_idx])
    test_groups = np.unique(groups[test_idx])

    print(f"Fold {i}:")
    print(f"  訓練グループ: {train_groups}")
    print(f"  テストグループ: {test_groups}")
    print(f"  訓練サンプル数: {len(train_idx)}, テストサンプル数: {len(test_idx)}")
</code></pre>

<h3>いつGroup K-Foldを使うべきか</h3>

<ul>
<li><strong>必須</strong>：同じエンティティから複数のサンプルがある場合</li>
<li><strong>推奨</strong>：医療データ、時系列の複数観測、画像の複数ショット</li>
<li><strong>注意</strong>：グループ数が少ない（<10）場合は評価が不安定</li>
</ul>

<hr>

<h2>2.8 Nested Cross-Validation</h2>

<h3>ハイパーパラメータ調整の問題</h3>

<p>ハイパーパラメータをチューニングする際、以下のような<strong>間違ったアプローチ</strong>をすると、テストセットにフィットしてしまいます：</p>

<pre><code class="language-python"># ❌ 間違ったアプローチ
from sklearn.model_selection import GridSearchCV, train_test_split

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)

# テストセットを使ってハイパーパラメータ調整
best_params = try_different_hyperparameters(X_train, y_train, X_test, y_test)

# 同じテストセットで最終評価 → 過大評価！
final_score = evaluate(best_model, X_test, y_test)
</code></pre>

<h3>Nested CVの原理</h3>

<p><strong>Nested Cross-Validation（入れ子交差検証）</strong>は、交差検証を2段階に分けます：</p>

<ul>
<li><strong>外側のCV</strong>：汎化性能の評価</li>
<li><strong>内側のCV</strong>：ハイパーパラメータの選択</li>
</ul>

<div class="mermaid">
graph TD
    A[全データ] --> B[外側CV: 5-Fold]

    B --> C[Fold 1]
    B --> D[Fold 2]
    B --> E[Fold 3]

    C --> F[訓練データ<br/>80%]
    C --> G[テストデータ<br/>20%]

    F --> H[内側CV: 5-Fold<br/>ハイパーパラメータ調整]
    H --> I[最良パラメータ]
    I --> J[全訓練データで再学習]
    J --> K[外側テストで評価]

    style A fill:#e1f5ff
    style H fill:#fff9c4
    style K fill:#c8e6c9
</div>

<h3>実装例</h3>

<pre><code class="language-python">import numpy as np
from sklearn.model_selection import GridSearchCV, cross_val_score, KFold
from sklearn.svm import SVC
from sklearn.datasets import make_classification

# データ生成
X, y = make_classification(n_samples=500, n_features=20, random_state=42)

# モデルとハイパーパラメータ空間
model = SVC()
param_grid = {
    'C': [0.1, 1, 10, 100],
    'gamma': [0.001, 0.01, 0.1, 1],
    'kernel': ['rbf', 'linear']
}

# 内側CV：ハイパーパラメータ調整
inner_cv = KFold(n_splits=3, shuffle=True, random_state=42)
clf = GridSearchCV(
    estimator=model,
    param_grid=param_grid,
    cv=inner_cv,
    scoring='accuracy',
    n_jobs=-1
)

# 外側CV：汎化性能評価
outer_cv = KFold(n_splits=5, shuffle=True, random_state=42)
nested_scores = cross_val_score(clf, X, y, cv=outer_cv, scoring='accuracy')

print("=== Nested Cross-Validation ===")
print(f"外側CVの各Foldスコア: {nested_scores}")
print(f"平均精度: {nested_scores.mean():.4f} ± {nested_scores.std():.4f}")

# 比較：通常のCV（ハイパーパラメータ固定）
simple_model = SVC(C=1.0, gamma=0.01, kernel='rbf')
simple_scores = cross_val_score(simple_model, X, y, cv=outer_cv, scoring='accuracy')

print("\n=== 通常のCV（C=1.0, gamma=0.01 固定） ===")
print(f"平均精度: {simple_scores.mean():.4f} ± {simple_scores.std():.4f}")
</code></pre>

<h3>Nested CVのベストプラクティス</h3>

<ul>
<li><strong>外側CV</strong>：K=5または10（汎化性能の信頼性の高い推定）</li>
<li><strong>内側CV</strong>：K=3または5（計算コストとのバランス）</li>
<li><strong>総訓練回数</strong>：外側K × 内側K × ハイパーパラメータ数</li>
<li><strong>並列化</strong>：<code>n_jobs=-1</code>で高速化</li>
</ul>

<h3>計算コストの例</h3>

<table>
<thead>
<tr>
<th>設定</th>
<th>訓練回数</th>
<th>推奨ケース</th>
</tr>
</thead>
<tbody>
<tr>
<td>外側5 × 内側3</td>
<td>15回 × パラメータ数</td>
<td>標準的な設定</td>
</tr>
<tr>
<td>外側5 × 内側5</td>
<td>25回 × パラメータ数</td>
<td>高精度が必要な場合</td>
</tr>
<tr>
<td>外側10 × 内側5</td>
<td>50回 × パラメータ数</td>
<td>小〜中規模データ</td>
</tr>
</tbody>
</table>

<blockquote>
<p><strong>注意</strong>：Nested CVは計算コストが高いため、大規模データやディープラーニングでは実用的でない場合があります。その場合は、Hold-out法で検証セットを明示的に分離し、テストセットは最後まで触らない戦略を取ります。</p>
</blockquote>

<hr>

<h2>2.9 交差検証のベストプラクティス</h2>

<h3>タスク別の交差検証選択フローチャート</h3>

<div class="mermaid">
graph TD
    A[データ分析開始] --> B{時系列データ?}
    B -->|Yes| C[TimeSeriesSplit]
    B -->|No| D{グループ構造?}

    D -->|Yes| E[GroupKFold]
    D -->|No| F{分類タスク?}

    F -->|Yes| G{クラス不均衡?}
    G -->|Yes| H[StratifiedKFold]
    G -->|No| I{データサイズ?}

    F -->|No| J[回帰タスク]
    J --> I

    I -->|N < 100| K[LeaveOneOut]
    I -->|N >= 100| L[KFold K=5 or 10]

    H --> M{ハイパーパラメータ調整?}
    L --> M
    K --> M
    C --> M
    E --> M

    M -->|Yes| N[Nested CV]
    M -->|No| O[通常のCV]

    style A fill:#e1f5ff
    style C fill:#b3e5fc
    style E fill:#81d4fa
    style H fill:#4fc3f7
    style N fill:#c8e6c9
</div>

<h3>チェックリスト：データリーケージ防止</h3>

<ul>
<li>✅ <strong>前処理</strong>：分割後に訓練データのみで学習（StandardScaler等）</li>
<li>✅ <strong>特徴量選択</strong>：各Fold内で独立して実行</li>
<li>✅ <strong>欠損値補完</strong>：訓練データの統計量のみ使用</li>
<li>✅ <strong>Pipeline使用</strong>：前処理とモデルを統合</li>
<li>✅ <strong>時系列</strong>：TimeSeriesSplitを使用</li>
<li>✅ <strong>グループ</strong>：GroupKFoldで同一グループを分離</li>
<li>✅ <strong>テストセット</strong>：最終評価まで一切触らない</li>
</ul>

<h3>パフォーマンス最適化</h3>

<pre><code class="language-python">from sklearn.model_selection import cross_val_score
from sklearn.ensemble import RandomForestClassifier
from sklearn.datasets import make_classification

X, y = make_classification(n_samples=10000, n_features=50, random_state=42)

# n_jobs=-1 で並列化（全CPUコアを使用）
model = RandomForestClassifier(n_estimators=100, n_jobs=-1, random_state=42)

# cross_val_score でも並列化可能
from sklearn.model_selection import StratifiedKFold
cv = StratifiedKFold(n_splits=5, shuffle=True, random_state=42)

# 並列実行（推奨）
scores = cross_val_score(model, X, y, cv=cv, scoring='accuracy', n_jobs=-1)
print(f"並列実行: 平均精度 = {scores.mean():.4f}")
</code></pre>

<h3>実務での交差検証戦略</h3>

<table>
<thead>
<tr>
<th>フェーズ</th>
<th>推奨手法</th>
<th>理由</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>初期探索</strong></td>
<td>3-Fold CV</td>
<td>高速にモデルの方向性を確認</td>
</tr>
<tr>
<td><strong>モデル開発</strong></td>
<td>5-Fold Stratified CV</td>
<td>バランスと計算コストの最適化</td>
</tr>
<tr>
<td><strong>ハイパーパラメータ調整</strong></td>
<td>Nested CV (5×3)</td>
<td>過学習を防ぎながらチューニング</td>
</tr>
<tr>
<td><strong>最終評価</strong></td>
<td>Hold-out Test Set</td>
<td>未使用データで真の汎化性能測定</td>
</tr>
</tbody>
</table>

<h3>まとめ：推奨される実装パターン</h3>

<pre><code class="language-python">import numpy as np
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import StandardScaler
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import StratifiedKFold, cross_val_score
from sklearn.datasets import make_classification

# データ準備
X, y = make_classification(n_samples=1000, n_features=20, random_state=42)

# ベストプラクティス：Pipeline + Stratified K-Fold
pipeline = Pipeline([
    ('scaler', StandardScaler()),  # 前処理
    ('classifier', RandomForestClassifier(n_estimators=100, random_state=42))
])

# Stratified K-Fold（分類タスクの標準）
cv = StratifiedKFold(n_splits=5, shuffle=True, random_state=42)

# 交差検証実行
scores = cross_val_score(
    pipeline, X, y,
    cv=cv,
    scoring='accuracy',
    n_jobs=-1  # 並列化
)

print("=== 推奨実装パターン ===")
print(f"平均精度: {scores.mean():.4f}")
print(f"標準偏差: {scores.std():.4f}")
print(f"95%信頼区間: [{scores.mean() - 1.96*scores.std():.4f}, "
      f"{scores.mean() + 1.96*scores.std():.4f}]")
</code></pre>

<hr>

<h2>演習問題</h2>

<details>
<summary><strong>演習1：Hold-out法とK-Foldの比較</strong></summary>

<p>以下のコードを完成させ、Hold-out法（テスト20%）と5-Fold CVの性能を比較してください。どちらがより安定した評価を与えますか？</p>

<pre><code class="language-python">from sklearn.datasets import load_breast_cancer
from sklearn.model_selection import train_test_split, cross_val_score, KFold
from sklearn.tree import DecisionTreeClassifier

# データ読み込み
data = load_breast_cancer()
X, y = data.data, data.target

# TODO: Hold-out法で評価
# ヒント: train_test_split を使用

# TODO: 5-Fold CVで評価
# ヒント: cross_val_score を使用

# TODO: 結果を比較
</code></pre>

</details>

<details>
<summary><strong>演習2：Stratified K-Foldの重要性</strong></summary>

<p>不均衡データ（正例5%）を作成し、通常のK-FoldとStratified K-Foldでクラス分布がどう異なるか確認してください。</p>

<pre><code class="language-python">from sklearn.datasets import make_classification
from sklearn.model_selection import KFold, StratifiedKFold
import numpy as np

# 不均衡データ生成
X, y = make_classification(
    n_samples=1000,
    weights=[0.95, 0.05],  # 5% positive class
    random_state=42
)

# TODO: 各Foldのクラス分布を確認
# ヒント: 各Foldのy_testでクラス1の割合を計算
</code></pre>

</details>

<details>
<summary><strong>演習3：時系列データの交差検証</strong></summary>

<p>時系列データで通常のK-FoldとTimeSeriesSplitを比較し、情報リーケージの影響を確認してください。</p>

<pre><code class="language-python">import numpy as np
import pandas as pd
from sklearn.model_selection import KFold, TimeSeriesSplit
from sklearn.linear_model import Ridge

# 時系列データ生成
np.random.seed(42)
n = 200
t = np.arange(n)
y = 0.5 * t + 10 * np.sin(t / 10) + np.random.randn(n) * 5

# 特徴量（過去の値）
X = np.column_stack([np.roll(y, i) for i in range(1, 6)])
X, y = X[5:], y[5:]

# TODO: K-FoldとTimeSeriesSplitで評価を比較
# どちらの方がRMSEが良いですか？その理由は？
</code></pre>

</details>

<details>
<summary><strong>演習4：データリーケージの検出</strong></summary>

<p>以下のコードにはデータリーケージがあります。どこが問題で、どう修正すべきですか？</p>

<pre><code class="language-python">from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import cross_val_score, KFold
from sklearn.linear_model import LogisticRegression
from sklearn.datasets import make_classification

X, y = make_classification(n_samples=500, n_features=20, random_state=42)

# 全データで正規化
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)

# 交差検証
model = LogisticRegression(max_iter=200)
cv = KFold(n_splits=5, shuffle=True, random_state=42)
scores = cross_val_score(model, X_scaled, y, cv=cv)

print(f"精度: {scores.mean():.4f}")

# TODO: この実装の問題点を指摘し、Pipelineを使って修正してください
</code></pre>

</details>

<details>
<summary><strong>演習5：Nested CVの実装</strong></summary>

<p>SVMのハイパーパラメータ（CとGamma）をNested CVで調整し、真の汎化性能を推定してください。</p>

<pre><code class="language-python">from sklearn.model_selection import GridSearchCV, cross_val_score, KFold
from sklearn.svm import SVC
from sklearn.datasets import load_digits

# データ読み込み
digits = load_digits()
X, y = digits.data, digits.target

# TODO: Nested CVを実装
# 外側CV: 5-Fold
# 内側CV: 3-Fold
# パラメータ: C=[0.1, 1, 10], gamma=[0.001, 0.01, 0.1]

# ヒント: GridSearchCVをcross_val_scoreに渡す
</code></pre>

</details>

<hr>

<h2>まとめ</h2>

<p>この章では、モデル評価の要となる<strong>交差検証とデータ分割</strong>について学びました。</p>

<h3>重要ポイント</h3>

<ul>
<li><strong>Hold-out法</strong>は簡単だが不安定。K-Fold CVで安定した評価を得る</li>
<li><strong>K-Fold CV</strong>：データを有効活用し、複数回の評価で信頼性を向上</li>
<li><strong>Stratified K-Fold</strong>：分類問題では必須。クラス比率を保持</li>
<li><strong>TimeSeriesSplit</strong>：時系列データでは時間順序を守る</li>
<li><strong>Group K-Fold</strong>：同じエンティティのデータを分離</li>
<li><strong>データリーケージ</strong>：Pipelineで防止。前処理は訓練データのみで学習</li>
<li><strong>Nested CV</strong>：ハイパーパラメータ調整と性能評価を分離</li>
</ul>

<h3>次のステップ</h3>

<p>次章では、交差検証で得たスコアをもとに、さまざまな<strong>評価指標</strong>（精度、適合率、再現率、F1スコア、AUC-ROCなど）を学び、タスクに応じた適切な指標選択を習得します。</p>

<div class="navigation">
    <a href="chapter1-evaluation-basics.html" class="nav-button">← 第1章：モデル評価の基礎</a>
    <a href="chapter3-classification-metrics.html" class="nav-button">第3章：分類評価指標 →</a>
</div>

</main>

<footer>
    <p>&copy; 2024 AI Terakoya. All rights reserved.</p>
</footer>

</body>
</html>
