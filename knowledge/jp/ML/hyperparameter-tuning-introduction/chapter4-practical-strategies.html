<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>第4章：実践的チューニング戦略 - AI Terakoya</title>

    <style>
        :root {
            --color-primary: #2c3e50;
            --color-primary-dark: #1a252f;
            --color-accent: #7b2cbf;
            --color-accent-light: #9d4edd;
            --color-text: #2d3748;
            --color-text-light: #4a5568;
            --color-bg: #ffffff;
            --color-bg-alt: #f7fafc;
            --color-border: #e2e8f0;
            --color-code-bg: #f8f9fa;
            --color-link: #3182ce;
            --color-link-hover: #2c5aa0;
            --spacing-xs: 0.5rem;
            --spacing-sm: 1rem;
            --spacing-md: 1.5rem;
            --spacing-lg: 2rem;
            --spacing-xl: 3rem;
            --font-body: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            --font-mono: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;
            --border-radius: 8px;
            --box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: var(--font-body); line-height: 1.7; color: var(--color-text); background-color: var(--color-bg); font-size: 16px; }
        header { background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%); color: white; padding: var(--spacing-xl) var(--spacing-md); margin-bottom: var(--spacing-xl); box-shadow: var(--box-shadow); }
        .header-content { max-width: 900px; margin: 0 auto; }
        h1 { font-size: 2rem; font-weight: 700; margin-bottom: var(--spacing-sm); line-height: 1.2; }
        .subtitle { font-size: 1.1rem; opacity: 0.95; font-weight: 400; margin-bottom: var(--spacing-md); }
        .meta { display: flex; flex-wrap: wrap; gap: var(--spacing-md); font-size: 0.9rem; opacity: 0.9; }
        .meta-item { display: flex; align-items: center; gap: 0.3rem; }
        .container { max-width: 900px; margin: 0 auto; padding: 0 var(--spacing-md) var(--spacing-xl); }
        h2 { font-size: 1.75rem; color: var(--color-primary); margin-top: var(--spacing-xl); margin-bottom: var(--spacing-md); padding-bottom: var(--spacing-xs); border-bottom: 3px solid var(--color-accent); }
        h3 { font-size: 1.4rem; color: var(--color-primary); margin-top: var(--spacing-lg); margin-bottom: var(--spacing-sm); }
        h4 { font-size: 1.1rem; color: var(--color-primary-dark); margin-top: var(--spacing-md); margin-bottom: var(--spacing-sm); }
        p { margin-bottom: var(--spacing-md); color: var(--color-text); }
        a { color: var(--color-link); text-decoration: none; transition: color 0.2s; }
        a:hover { color: var(--color-link-hover); text-decoration: underline; }
        ul, ol { margin-left: var(--spacing-lg); margin-bottom: var(--spacing-md); }
        li { margin-bottom: var(--spacing-xs); color: var(--color-text); }
        pre { background-color: var(--color-code-bg); border: 1px solid var(--color-border); border-radius: var(--border-radius); padding: var(--spacing-md); overflow-x: auto; margin-bottom: var(--spacing-md); font-family: var(--font-mono); font-size: 0.9rem; line-height: 1.5; }
        code { font-family: var(--font-mono); font-size: 0.9em; background-color: var(--color-code-bg); padding: 0.2em 0.4em; border-radius: 3px; }
        pre code { background-color: transparent; padding: 0; }
        table { width: 100%; border-collapse: collapse; margin-bottom: var(--spacing-md); font-size: 0.95rem; }
        th, td { border: 1px solid var(--color-border); padding: var(--spacing-sm); text-align: left; }
        th { background-color: var(--color-bg-alt); font-weight: 600; color: var(--color-primary); }
        blockquote { border-left: 4px solid var(--color-accent); padding-left: var(--spacing-md); margin: var(--spacing-md) 0; color: var(--color-text-light); font-style: italic; background-color: var(--color-bg-alt); padding: var(--spacing-md); border-radius: var(--border-radius); }
        .mermaid { text-align: center; margin: var(--spacing-lg) 0; background-color: var(--color-bg-alt); padding: var(--spacing-md); border-radius: var(--border-radius); }
        details { background-color: var(--color-bg-alt); border: 1px solid var(--color-border); border-radius: var(--border-radius); padding: var(--spacing-md); margin-bottom: var(--spacing-md); }
        summary { cursor: pointer; font-weight: 600; color: var(--color-primary); user-select: none; padding: var(--spacing-xs); margin: calc(-1 * var(--spacing-md)); padding: var(--spacing-md); border-radius: var(--border-radius); }
        summary:hover { background-color: rgba(123, 44, 191, 0.1); }
        details[open] summary { margin-bottom: var(--spacing-md); border-bottom: 1px solid var(--color-border); }
        .navigation { display: flex; justify-content: space-between; gap: var(--spacing-md); margin: var(--spacing-xl) 0; padding-top: var(--spacing-lg); border-top: 2px solid var(--color-border); }
        .nav-button { flex: 1; padding: var(--spacing-md); background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%); color: white; border-radius: var(--border-radius); text-align: center; font-weight: 600; transition: transform 0.2s, box-shadow 0.2s; box-shadow: var(--box-shadow); }
        .nav-button:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15); text-decoration: none; }
        footer { margin-top: var(--spacing-xl); padding: var(--spacing-lg) var(--spacing-md); background-color: var(--color-bg-alt); border-top: 1px solid var(--color-border); text-align: center; font-size: 0.9rem; color: var(--color-text-light); }
        .project-box { background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 50%); border-radius: var(--border-radius); padding: var(--spacing-lg); margin: var(--spacing-lg) 0; box-shadow: var(--box-shadow); }
        .tip-box { background: linear-gradient(135deg, #fff3cd 0%, #ffe69c 50%); border-left: 4px solid #ffc107; border-radius: var(--border-radius); padding: var(--spacing-md); margin: var(--spacing-md) 0; }
        .warning-box { background: linear-gradient(135deg, #f8d7da 0%, #f5c2c7 50%); border-left: 4px solid #dc3545; border-radius: var(--border-radius); padding: var(--spacing-md); margin: var(--spacing-md) 0; }
        @media (max-width: 768px) { h1 { font-size: 1.5rem; } h2 { font-size: 1.4rem; } h3 { font-size: 1.2rem; } .meta { font-size: 0.85rem; } .navigation { flex-direction: column; } table { font-size: 0.85rem; } th, td { padding: var(--spacing-xs); } }
    </style>

    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ startOnLoad: true, theme: 'default' });
    </script>
    <script>
        MathJax = {
            tex: { inlineMath: [['$', '$'], ['\\(', '\\)']], displayMath: [['$$', '$$'], ['\\[', '\\]']], processEscapes: true, processEnvironments: true },
            options: { skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'], ignoreHtmlClass: 'mermaid' }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" id="MathJax-script" async></script>
</head>
<body>
    <header>
        <div class="header-content">
            <h1>第4章：実践的チューニング戦略</h1>
            <p class="subtitle">マルチ目的最適化から本番運用まで - 実務で使える高度なテクニック</p>
            <div class="meta">
                <span class="meta-item">📖 読了時間: 25分</span>
                <span class="meta-item">📊 難易度: 上級</span>
                <span class="meta-item">💻 コード例: 6個</span>
                <span class="meta-item">🎯 実践重視</span>
            </div>
        </div>
    </header>

    <main class="container">

<h2>学習目標</h2>
<p>この章を読むことで、以下を習得できます：</p>
<ul>
<li>✅ マルチ目的最適化によるトレードオフバランスの取得</li>
<li>✅ Early Stoppingによる効率的な探索空間の絞り込み</li>
<li>✅ 分散環境でのスケーラブルなハイパーパラメータチューニング</li>
<li>✅ 転移学習とウォームスタートによる事前知識の活用</li>
<li>✅ 本番環境での実践的なチューニング運用ガイドライン</li>
</ul>

<h2>1. マルチ目的最適化</h2>

<p>実際のMLシステムでは、精度だけでなくレイテンシ、モデルサイズ、推論コストなど複数の指標をバランスさせる必要があります。</p>

<h3>1.1 精度とレイテンシのトレードオフ</h3>

<p>単一指標の最適化では、実運用に適さないモデルが選択される可能性があります。例えば：</p>

<ul>
<li><strong>高精度だが遅いモデル：</strong>リアルタイム推論に不適</li>
<li><strong>高速だが低精度なモデル：</strong>ビジネス要件を満たさない</li>
<li><strong>バランス型モデル：</strong>実用的な妥協点</li>
</ul>

<div class="mermaid">
graph LR
    A[精度重視] -->|トレードオフ| B[Paretoフロンティア]
    C[速度重視] -->|トレードオフ| B
    B --> D[最適解の集合]
    D --> E[ビジネス要件から選択]
</div>

<h3>1.2 Paretoフロンティアの理解</h3>

<p>Paretoフロンティアは、どちらの指標も改善できない解の集合です。これにより複数の候補モデルから最適なものを選択できます。</p>

<blockquote>
<strong>Pareto最適性：</strong>ある解が他のすべての指標で劣ることなく、少なくとも1つの指標で優れている状態。
</blockquote>

<h3>1.3 Optunaのマルチ目的最適化</h3>

<p>Optunaは複数の目的関数を同時に最適化するマルチ目的最適化をサポートしています。</p>

<pre><code class="language-python">import optuna
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import cross_val_score
from sklearn.datasets import load_breast_cancer
import time
import numpy as np

# データセット準備
X, y = load_breast_cancer(return_X_y=True)

def objective(trial):
    """精度とレイテンシを同時に最適化"""
    # ハイパーパラメータの提案
    params = {
        'n_estimators': trial.suggest_int('n_estimators', 10, 200),
        'max_depth': trial.suggest_int('max_depth', 2, 32),
        'min_samples_split': trial.suggest_int('min_samples_split', 2, 20),
        'min_samples_leaf': trial.suggest_int('min_samples_leaf', 1, 10),
        'max_features': trial.suggest_categorical('max_features', ['sqrt', 'log2', None])
    }

    # モデル学習と精度評価
    clf = RandomForestClassifier(**params, random_state=42, n_jobs=-1)
    accuracy = cross_val_score(clf, X, y, cv=3, n_jobs=-1).mean()

    # レイテンシ測定（推論時間）
    clf.fit(X, y)
    start_time = time.time()
    _ = clf.predict(X[:100])  # 100サンプルの推論時間測定
    latency = (time.time() - start_time) * 1000  # ミリ秒

    # 2つの目的関数を返す：精度を最大化、レイテンシを最小化
    return accuracy, latency

# マルチ目的最適化study
study = optuna.create_study(
    directions=['maximize', 'minimize'],  # 精度は最大化、レイテンシは最小化
    study_name='multi_objective_optimization'
)

study.optimize(objective, n_trials=50)

# Paretoフロンティアの解を取得
print("=== Pareto最適解 ===")
for trial in study.best_trials:
    print(f"Trial {trial.number}:")
    print(f"  Accuracy: {trial.values[0]:.4f}")
    print(f"  Latency: {trial.values[1]:.2f} ms")
    print(f"  Params: {trial.params}\n")
</code></pre>

<div class="tip-box">
<strong>💡 実践的なヒント：</strong>
<ul>
<li>目的関数の数は通常2〜3個に抑える（4個以上は解釈が困難）</li>
<li>各目的関数のスケールを揃える（正規化推奨）</li>
<li>ビジネス要件に応じてParetoフロンティアから最終モデルを選択</li>
</ul>
</div>

<h3>1.4 Paretoフロンティアの可視化</h3>

<pre><code class="language-python">import matplotlib.pyplot as plt

def visualize_pareto_frontier(study):
    """Paretoフロンティアの可視化"""
    # すべての試行結果を取得
    trials = study.trials
    accuracies = [t.values[0] for t in trials]
    latencies = [t.values[1] for t in trials]

    # Pareto最適解を取得
    pareto_trials = study.best_trials
    pareto_accuracies = [t.values[0] for t in pareto_trials]
    pareto_latencies = [t.values[1] for t in pareto_trials]

    # プロット
    plt.figure(figsize=(10, 6))
    plt.scatter(latencies, accuracies, alpha=0.5, label='All trials')
    plt.scatter(pareto_latencies, pareto_accuracies,
                color='red', s=100, marker='*', label='Pareto frontier')

    # Paretoフロンティアを線で接続
    sorted_pareto = sorted(zip(pareto_latencies, pareto_accuracies))
    plt.plot([p[0] for p in sorted_pareto], [p[1] for p in sorted_pareto],
             'r--', alpha=0.5)

    plt.xlabel('Latency (ms)')
    plt.ylabel('Accuracy')
    plt.title('Multi-Objective Optimization: Accuracy vs Latency')
    plt.legend()
    plt.grid(True, alpha=0.3)
    plt.tight_layout()
    plt.show()

visualize_pareto_frontier(study)
</code></pre>

<h2>2. Early Stopping戦略</h2>

<p>有望でない試行を早期に打ち切ることで、計算リソースを効率的に使用し、より多くの探索を実行できます。</p>

<h3>2.1 Pruning（枝刈り）の重要性</h3>

<p>ハイパーパラメータチューニングでは、多くの試行が最終的に良い結果を生まないため、早期に打ち切ることが効率化の鍵です。</p>

<table>
<thead>
<tr>
<th>戦略</th>
<th>特徴</th>
<th>適用場面</th>
</tr>
</thead>
<tbody>
<tr>
<td>MedianPruner</td>
<td>中央値と比較して劣る試行を打ち切り</td>
<td>一般的な用途、バランス型</td>
</tr>
<tr>
<td>PercentilePruner</td>
<td>上位X%に入らない試行を打ち切り</td>
<td>積極的な探索削減が必要な場合</td>
</tr>
<tr>
<td>SuccessiveHalvingPruner</td>
<td>段階的にリソースを配分</td>
<td>学習曲線が利用可能な場合</td>
</tr>
<tr>
<td>HyperbandPruner</td>
<td>複数のSuccessiveHalvingを並列実行</td>
<td>大規模探索、最先端手法</td>
</tr>
</tbody>
</table>

<h3>2.2 MedianPrunerの実装</h3>

<pre><code class="language-python">import optuna
from optuna.pruners import MedianPruner
from sklearn.model_selection import cross_validate
from sklearn.ensemble import GradientBoostingClassifier
import numpy as np

def objective_with_pruning(trial):
    """Pruningを使った目的関数"""
    params = {
        'n_estimators': trial.suggest_int('n_estimators', 50, 500),
        'learning_rate': trial.suggest_float('learning_rate', 0.01, 0.3),
        'max_depth': trial.suggest_int('max_depth', 3, 10),
        'subsample': trial.suggest_float('subsample', 0.5, 1.0),
    }

    clf = GradientBoostingClassifier(**params, random_state=42)

    # 段階的な評価（学習の途中経過を報告）
    for step in range(5):
        # 段階的にn_estimatorsを増やして評価
        intermediate_clf = GradientBoostingClassifier(
            n_estimators=(step + 1) * 20,
            learning_rate=params['learning_rate'],
            max_depth=params['max_depth'],
            subsample=params['subsample'],
            random_state=42
        )

        # 中間評価
        scores = cross_validate(intermediate_clf, X, y, cv=3,
                                scoring='accuracy', n_jobs=-1)
        intermediate_score = scores['test_score'].mean()

        # 中間結果を報告
        trial.report(intermediate_score, step)

        # Pruningの判断
        if trial.should_prune():
            raise optuna.TrialPruned()

    # 最終評価
    final_scores = cross_validate(clf, X, y, cv=5, scoring='accuracy', n_jobs=-1)
    return final_scores['test_score'].mean()

# MedianPrunerを使用したstudy
pruner = MedianPruner(
    n_startup_trials=5,  # 最初の5試行はPruningしない
    n_warmup_steps=2,    # 最初の2ステップはPruningしない
    interval_steps=1     # 各ステップでPruning判断
)

study = optuna.create_study(
    direction='maximize',
    pruner=pruner,
    study_name='pruning_optimization'
)

study.optimize(objective_with_pruning, n_trials=50)

print(f"Best accuracy: {study.best_value:.4f}")
print(f"Best params: {study.best_params}")
print(f"Pruned trials: {len([t for t in study.trials if t.state == optuna.trial.TrialState.PRUNED])}")
print(f"Completed trials: {len([t for t in study.trials if t.state == optuna.trial.TrialState.COMPLETE])}")
</code></pre>

<h3>2.3 PercentilePrunerの実装</h3>

<pre><code class="language-python">from optuna.pruners import PercentilePruner

# PercentilePruner：上位25%に入らない試行を打ち切り
pruner = PercentilePruner(
    percentile=25.0,      # 上位25%のみ継続
    n_startup_trials=5,   # 最初の5試行は必ず完了
    n_warmup_steps=2      # 最初の2ステップはPruningしない
)

study = optuna.create_study(
    direction='maximize',
    pruner=pruner,
    study_name='percentile_pruning'
)

study.optimize(objective_with_pruning, n_trials=50)

# Pruning効果の分析
pruned_count = len([t for t in study.trials if t.state == optuna.trial.TrialState.PRUNED])
completed_count = len([t for t in study.trials if t.state == optuna.trial.TrialState.COMPLETE])
pruning_rate = pruned_count / len(study.trials) * 100

print(f"Pruning rate: {pruning_rate:.1f}%")
print(f"Time saved: ~{pruning_rate * 0.8:.1f}% (estimated)")
</code></pre>

<div class="warning-box">
<strong>⚠️ 注意点：</strong>
<ul>
<li>Pruningが積極的すぎると有望な試行も打ち切られる可能性がある</li>
<li>n_startup_trialsは探索空間の複雑さに応じて調整する</li>
<li>学習曲線が不安定な場合はn_warmup_stepsを大きくする</li>
</ul>
</div>

<h2>3. 分散ハイパーパラメータチューニング</h2>

<p>大規模な探索空間や計算量の多いモデルでは、分散環境でチューニングを実行することで大幅な時間短縮が可能です。</p>

<h3>3.1 Optuna分散最適化の仕組み</h3>

<p>Optunaは共有ストレージ（RDB、Redis等）を通じて複数のワーカーが協調して最適化を実行できます。</p>

<div class="mermaid">
graph TD
    A[共有ストレージ<br/>RDB/Redis] --> B[Worker 1]
    A --> C[Worker 2]
    A --> D[Worker 3]
    A --> E[Worker N]
    B --> F[試行結果を保存]
    C --> F
    D --> F
    E --> F
    F --> A
</div>

<h3>3.2 RDBを使った分散最適化</h3>

<pre><code class="language-python">import optuna
from optuna.storages import RDBStorage

# 共有ストレージの設定（PostgreSQL例）
storage = RDBStorage(
    url='postgresql://user:password@localhost/optuna_db',
    engine_kwargs={
        'pool_size': 20,
        'max_overflow': 0,
    }
)

# 分散study作成（複数ワーカーで共有）
study = optuna.create_study(
    study_name='distributed_optimization',
    storage=storage,
    direction='maximize',
    load_if_exists=True  # 既存studyがあれば再利用
)

# 各ワーカーでこのコードを実行
def objective(trial):
    x = trial.suggest_float('x', -10, 10)
    y = trial.suggest_float('y', -10, 10)
    return -(x**2 + y**2)

# 各ワーカーが並列で最適化
study.optimize(objective, n_trials=100)

print(f"Best value: {study.best_value}")
print(f"Best params: {study.best_params}")
print(f"Total trials: {len(study.trials)}")
</code></pre>

<div class="tip-box">
<strong>💡 分散最適化のベストプラクティス：</strong>
<ul>
<li><strong>ストレージ選択：</strong> 小〜中規模→SQLite、大規模→PostgreSQL/MySQL、超高速→Redis</li>
<li><strong>ワーカー数：</strong> CPU数、ネットワーク帯域、ストレージ性能を考慮</li>
<li><strong>負荷分散：</strong> 各ワーカーのn_trialsを調整してバランスを取る</li>
</ul>
</div>

<h3>3.3 Ray Tuneによる分散チューニング</h3>

<p>Ray Tuneは分散実行とスケジューリングに特化したフレームワークで、大規模クラスタでの並列チューニングに適しています。</p>

<pre><code class="language-python">from ray import tune
from ray.tune.schedulers import ASHAScheduler
from ray.tune.search.optuna import OptunaSearch
import numpy as np

def train_model(config):
    """訓練関数（Ray Tuneが並列実行）"""
    # シミュレーション：実際にはモデル訓練を実装
    for epoch in range(10):
        # config['lr']やconfig['batch_size']を使った訓練
        accuracy = 1 - (config['lr'] - 0.01)**2 - (config['batch_size'] - 32)**2 / 1000
        accuracy += np.random.normal(0, 0.01)  # ノイズ

        # 中間結果を報告
        tune.report(accuracy=accuracy)

# 探索空間定義
search_space = {
    'lr': tune.loguniform(1e-4, 1e-1),
    'batch_size': tune.choice([16, 32, 64, 128]),
    'hidden_size': tune.choice([64, 128, 256, 512]),
}

# ASHA Scheduler（効率的なearly stopping）
scheduler = ASHAScheduler(
    max_t=10,           # 最大エポック数
    grace_period=1,     # 最小実行エポック数
    reduction_factor=2  # 各段階で半分を打ち切り
)

# Optuna検索アルゴリズムを使用
search_alg = OptunaSearch()

# 分散チューニング実行
analysis = tune.run(
    train_model,
    config=search_space,
    num_samples=50,           # 試行回数
    scheduler=scheduler,
    search_alg=search_alg,
    resources_per_trial={     # 各試行のリソース
        'cpu': 2,
        'gpu': 0.5
    },
    verbose=1
)

# 最適パラメータ取得
best_config = analysis.best_config
print(f"Best config: {best_config}")
print(f"Best accuracy: {analysis.best_result['accuracy']:.4f}")
</code></pre>

<h3>3.4 スケーラビリティの考慮事項</h3>

<table>
<thead>
<tr>
<th>規模</th>
<th>推奨フレームワーク</th>
<th>ストレージ</th>
<th>ワーカー数</th>
</tr>
</thead>
<tbody>
<tr>
<td>小規模（〜100試行）</td>
<td>Optuna</td>
<td>SQLite</td>
<td>1-4</td>
</tr>
<tr>
<td>中規模（100〜1000試行）</td>
<td>Optuna</td>
<td>PostgreSQL</td>
<td>4-16</td>
</tr>
<tr>
<td>大規模（1000〜10000試行）</td>
<td>Ray Tune</td>
<td>PostgreSQL/Redis</td>
<td>16-64</td>
</tr>
<tr>
<td>超大規模（10000試行〜）</td>
<td>Ray Tune</td>
<td>分散Redis</td>
<td>64+</td>
</tr>
</tbody>
</table>

<h2>4. 転移学習とウォームスタート</h2>

<p>過去のチューニング結果や類似タスクの知識を活用することで、探索を大幅に効率化できます。</p>

<h3>4.1 事前知識の活用</h3>

<p>ゼロからチューニングを開始するのではなく、既知の良好なハイパーパラメータから探索を開始する方法です。</p>

<h4>ウォームスタートの利点</h4>
<ul>
<li><strong>探索時間短縮：</strong>良好な初期値から開始することで収束が早い</li>
<li><strong>リスク低減：</strong>最低限の性能を担保できる</li>
<li><strong>知識の蓄積：</strong>過去の経験を活かせる</li>
</ul>

<h3>4.2 Optunaでのウォームスタート実装</h3>

<pre><code class="language-python">import optuna
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import cross_val_score

# 既知の良好なハイパーパラメータ（過去の経験やドメイン知識）
known_good_params = [
    {'n_estimators': 100, 'max_depth': 10, 'min_samples_split': 5},
    {'n_estimators': 200, 'max_depth': 15, 'min_samples_split': 2},
    {'n_estimators': 150, 'max_depth': 12, 'min_samples_split': 4},
]

def objective(trial):
    params = {
        'n_estimators': trial.suggest_int('n_estimators', 50, 300),
        'max_depth': trial.suggest_int('max_depth', 5, 20),
        'min_samples_split': trial.suggest_int('min_samples_split', 2, 10),
    }

    clf = RandomForestClassifier(**params, random_state=42, n_jobs=-1)
    score = cross_val_score(clf, X, y, cv=3, n_jobs=-1).mean()
    return score

# Study作成
study = optuna.create_study(direction='maximize')

# ウォームスタート：既知の良好なパラメータを事前に追加
for params in known_good_params:
    study.enqueue_trial(params)

# 最適化実行（enqueueされた試行が優先的に実行される）
study.optimize(objective, n_trials=50)

print(f"Best score: {study.best_value:.4f}")
print(f"Best params: {study.best_params}")

# 事前登録したパラメータの効果確認
warmstart_trials = study.trials[:len(known_good_params)]
print("\n=== Warmstart trials performance ===")
for i, trial in enumerate(warmstart_trials):
    print(f"Params {i+1}: {trial.params} -> Score: {trial.value:.4f}")
</code></pre>

<h3>4.3 メタ学習の応用</h3>

<p>複数の類似タスクから学習し、新しいタスクに対する良好な初期パラメータを予測する手法です。</p>

<blockquote>
<strong>メタ学習：</strong>「学習の学習」と呼ばれ、複数のタスクでの経験から新しいタスクへの適応を高速化する技術。
</blockquote>

<h4>実践的なメタ学習アプローチ</h4>

<ol>
<li><strong>過去のチューニング履歴を保存：</strong>データセット特性とベストパラメータのペアを記録</li>
<li><strong>類似タスク検索：</strong>新しいタスクに類似する過去タスクを特定</li>
<li><strong>パラメータ推奨：</strong>類似タスクのベストパラメータを初期値として使用</li>
</ol>

<pre><code class="language-python">import json
import numpy as np
from sklearn.metrics.pairwise import cosine_similarity

class MetaLearningOptimizer:
    """メタ学習を使ったハイパーパラメータ最適化"""

    def __init__(self, history_file='tuning_history.json'):
        self.history_file = history_file
        self.history = self.load_history()

    def load_history(self):
        """過去のチューニング履歴を読み込み"""
        try:
            with open(self.history_file, 'r') as f:
                return json.load(f)
        except FileNotFoundError:
            return []

    def save_history(self, dataset_features, best_params, best_score):
        """新しいチューニング結果を保存"""
        self.history.append({
            'dataset_features': dataset_features,
            'best_params': best_params,
            'best_score': best_score
        })
        with open(self.history_file, 'w') as f:
            json.dump(self.history, f, indent=2)

    def get_dataset_features(self, X, y):
        """データセットの特徴量を抽出"""
        return {
            'n_samples': X.shape[0],
            'n_features': X.shape[1],
            'n_classes': len(np.unique(y)),
            'class_imbalance': np.std(np.bincount(y)) / np.mean(np.bincount(y)),
            'feature_correlation': np.mean(np.abs(np.corrcoef(X.T))),
        }

    def find_similar_tasks(self, current_features, top_k=3):
        """類似タスクを検索"""
        if not self.history:
            return []

        # 特徴量ベクトル化
        current_vec = np.array(list(current_features.values())).reshape(1, -1)

        similarities = []
        for record in self.history:
            hist_vec = np.array(list(record['dataset_features'].values())).reshape(1, -1)
            sim = cosine_similarity(current_vec, hist_vec)[0][0]
            similarities.append((sim, record))

        # 類似度順にソート
        similarities.sort(reverse=True, key=lambda x: x[0])
        return [record for _, record in similarities[:top_k]]

    def get_warmstart_params(self, X, y):
        """ウォームスタート用パラメータを推奨"""
        current_features = self.get_dataset_features(X, y)
        similar_tasks = self.find_similar_tasks(current_features)

        if not similar_tasks:
            return []

        # 類似タスクのベストパラメータを返す
        return [task['best_params'] for task in similar_tasks]

# 使用例
meta_optimizer = MetaLearningOptimizer()

# 新しいタスクに対するウォームスタート
warmstart_params = meta_optimizer.get_warmstart_params(X, y)

if warmstart_params:
    print("=== Recommended warmstart parameters ===")
    for i, params in enumerate(warmstart_params):
        print(f"Recommendation {i+1}: {params}")

    # Optunaでウォームスタート
    study = optuna.create_study(direction='maximize')
    for params in warmstart_params:
        study.enqueue_trial(params)
    study.optimize(objective, n_trials=50)
else:
    # 履歴がない場合は通常の最適化
    study = optuna.create_study(direction='maximize')
    study.optimize(objective, n_trials=50)

# 結果を履歴に保存
dataset_features = meta_optimizer.get_dataset_features(X, y)
meta_optimizer.save_history(dataset_features, study.best_params, study.best_value)
</code></pre>

<h3>4.4 転移学習の実践的アプローチ</h3>

<table>
<thead>
<tr>
<th>アプローチ</th>
<th>適用場面</th>
<th>効果</th>
</tr>
</thead>
<tbody>
<tr>
<td>ウォームスタート</td>
<td>類似タスクの経験がある</td>
<td>探索時間20-40%短縮</td>
</tr>
<tr>
<td>メタ学習</td>
<td>多数の過去タスクがある</td>
<td>初期性能向上+探索効率化</td>
</tr>
<tr>
<td>ドメイン知識注入</td>
<td>専門家の知見がある</td>
<td>リスク低減+高速収束</td>
</tr>
<tr>
<td>アンサンブル活用</td>
<td>複数の候補パラメータ</td>
<td>ロバスト性向上</td>
</tr>
</tbody>
</table>

<h2>5. チューニング実践ガイド</h2>

<p>理論を実務に適用する際のベストプラクティス、デバッグ手法、本番運用のノウハウを解説します。</p>

<h3>5.1 探索空間設計のベストプラクティス</h3>

<h4>効果的な探索空間の設計原則</h4>

<ol>
<li><strong>影響度順に優先順位付け</strong>
   <ul>
   <li>学習率、正則化パラメータ → 高優先度</li>
   <li>バッチサイズ、エポック数 → 中優先度</li>
   <li>微調整パラメータ → 低優先度</li>
   </ul>
</li>
<li><strong>適切なスケール選択</strong>
   <ul>
   <li>学習率：対数スケール（loguniform）</li>
   <li>正則化強度：対数スケール</li>
   <li>層数、ユニット数：整数、線形スケール</li>
   </ul>
</li>
<li><strong>条件付きパラメータの活用</strong>
   <ul>
   <li>特定の選択に依存するパラメータは条件分岐</li>
   </ul>
</li>
</ol>

<div class="tip-box">
<strong>💡 探索空間設計のチェックリスト：</strong>
<ul>
<li>✅ パラメータ間の依存関係を明確化しているか</li>
<li>✅ 適切な分布（uniform、loguniform等）を選択しているか</li>
<li>✅ 探索範囲が広すぎ/狭すぎないか</li>
<li>✅ 計算コストの高いパラメータを絞り込んでいるか</li>
</ul>
</div>

<h3>5.2 デバッグとトラブルシューティング</h3>

<h4>よくある問題と解決策</h4>

<table>
<thead>
<tr>
<th>問題</th>
<th>原因</th>
<th>解決策</th>
</tr>
</thead>
<tbody>
<tr>
<td>収束しない</td>
<td>探索空間が広すぎる</td>
<td>事前実験で範囲を絞る</td>
</tr>
<tr>
<td>同じパラメータばかり</td>
<td>サンプラーの偏り</td>
<td>RandomSamplerと比較</td>
</tr>
<tr>
<td>Pruningが多すぎ</td>
<td>Pruner設定が厳しい</td>
<td>n_warmup_steps増加</td>
</tr>
<tr>
<td>結果が不安定</td>
<td>評価のランダム性</td>
<td>CV fold数増加、seed固定</td>
</tr>
<tr>
<td>メモリ不足</td>
<td>大きすぎるモデル</td>
<td>バッチサイズ削減、勾配蓄積</td>
</tr>
</tbody>
</table>

<h4>デバッグのための可視化</h4>

<pre><code class="language-python">import optuna
from optuna.visualization import (
    plot_optimization_history,
    plot_param_importances,
    plot_parallel_coordinate,
    plot_slice
)

# 最適化実行後の可視化
study = optuna.create_study(direction='maximize')
study.optimize(objective, n_trials=100)

# 1. 最適化履歴：時間経過とともに改善しているか確認
fig1 = plot_optimization_history(study)
fig1.show()

# 2. パラメータ重要度：どのパラメータが重要か確認
fig2 = plot_param_importances(study)
fig2.show()

# 3. 並列座標プロット：パラメータ間の関係性を確認
fig3 = plot_parallel_coordinate(study)
fig3.show()

# 4. スライスプロット：各パラメータの影響を個別確認
fig4 = plot_slice(study)
fig4.show()
</code></pre>

<h3>5.3 本番環境での運用</h3>

<h4>本番運用のワークフロー</h4>

<div class="mermaid">
graph TD
    A[開発環境で探索] --> B[候補パラメータ選定]
    B --> C[ステージング環境で検証]
    C --> D{性能・安定性OK?}
    D -->|No| A
    D -->|Yes| E[本番環境デプロイ]
    E --> F[モニタリング]
    F --> G{性能劣化検知?}
    G -->|Yes| H[再チューニング]
    G -->|No| F
    H --> A
</div>

<h4>本番運用のベストプラクティス</h4>

<ol>
<li><strong>段階的ロールアウト</strong>
   <ul>
   <li>Canary deployment：一部トラフィックで検証</li>
   <li>A/Bテスト：既存モデルと並行運用</li>
   <li>段階的な切り替え：問題発生時の即座のロールバック</li>
   </ul>
</li>
<li><strong>継続的モニタリング</strong>
   <ul>
   <li>予測性能の追跡（精度、AUC等）</li>
   <li>レイテンシ、スループットの監視</li>
   <li>データドリフト検知</li>
   </ul>
</li>
<li><strong>定期的な再チューニング</strong>
   <ul>
   <li>データ分布の変化に応じて四半期ごと等に実施</li>
   <li>新しいアルゴリズムや手法の評価</li>
   <li>過去の結果を活かしたメタ学習</li>
   </ul>
</li>
</ol>

<div class="warning-box">
<strong>⚠️ 本番運用での注意点：</strong>
<ul>
<li><strong>再現性の確保：</strong>乱数シード、ライブラリバージョンを固定</li>
<li><strong>バックアップ：</strong>既存モデルをいつでも復元できる状態に</li>
<li><strong>ドキュメント化：</strong>チューニング履歴、パラメータ変更理由を記録</li>
<li><strong>アラート設定：</strong>性能劣化時の自動通知</li>
</ul>
</div>

<h3>5.4 実践的なチューニング戦略まとめ</h3>

<table>
<thead>
<tr>
<th>フェーズ</th>
<th>目的</th>
<th>推奨手法</th>
<th>試行回数</th>
</tr>
</thead>
<tbody>
<tr>
<td>初期探索</td>
<td>全体像把握</td>
<td>Random Search</td>
<td>20-50</td>
</tr>
<tr>
<td>絞り込み</td>
<td>有望領域特定</td>
<td>TPE + Pruning</td>
<td>50-100</td>
</tr>
<tr>
<td>精密探索</td>
<td>最適解発見</td>
<td>CMA-ES/GP</td>
<td>100-200</td>
</tr>
<tr>
<td>マルチ目的</td>
<td>トレードオフ調整</td>
<td>Multi-objective TPE</td>
<td>100-300</td>
</tr>
<tr>
<td>本番検証</td>
<td>最終確認</td>
<td>Cross-validation増</td>
<td>5-10</td>
</tr>
</tbody>
</table>

<h3>5.5 チューニング効率化のチートシート</h3>

<blockquote>
<strong>時間がない時のクイックチューニング手順：</strong>
<ol>
<li>ドメイン知識/過去経験から初期値設定（ウォームスタート）</li>
<li>重要パラメータ2-3個に絞って探索（学習率、正則化）</li>
<li>MedianPruner有効化で無駄な試行削減</li>
<li>並列実行（4-8ワーカー）で時間短縮</li>
<li>50-100試行で実用的な性能を確保</li>
</ol>
</blockquote>

<h2>章末演習問題</h2>

<details>
<summary><strong>演習1：マルチ目的最適化の実装（難易度：中）</strong></summary>
<p>精度、推論時間、モデルサイズの3つを同時に最適化するOptunaのstudyを実装してください。Paretoフロンティアを可視化し、ビジネス要件（精度0.90以上、推論時間50ms以下）を満たす解を選択してください。</p>
</details>

<details>
<summary><strong>演習2：Pruning戦略の比較（難易度：中）</strong></summary>
<p>MedianPruner、PercentilePruner、HyperbandPrunerの3つを比較実験してください。同じ目的関数に対して、各Prunerの打ち切り率、最終性能、計算時間を比較し、どのPrunerが最も効率的か評価してください。</p>
</details>

<details>
<summary><strong>演習3：分散チューニングの実装（難易度：上級）</strong></summary>
<p>PostgreSQLを使ったOptuna分散最適化を実装してください。3つの異なるワーカーから同時にstudyにアクセスし、合計150試行を効率的に実行してください。各ワーカーの貢献度を分析してください。</p>
</details>

<details>
<summary><strong>演習4：メタ学習システムの構築（難易度：上級）</strong></summary>
<p>複数のデータセット（UCI MLリポジトリ等）に対してチューニングを実行し、その履歴から新しいデータセットに対する最適なハイパーパラメータを推奨するメタ学習システムを構築してください。</p>
</details>

<details>
<summary><strong>演習5：本番運用シミュレーション（難易度：上級）</strong></summary>
<p>時系列データを使って、本番運用のシミュレーションを実装してください。データドリフトが発生した際の性能劣化を検知し、自動的に再チューニングをトリガーする仕組みを作成してください。</p>
</details>

<h2>まとめ</h2>

<p>本章では実践的なハイパーパラメータチューニング戦略を学びました：</p>

<ul>
<li>✅ <strong>マルチ目的最適化：</strong>精度とレイテンシ等、複数指標のトレードオフをParetoフロンティアで解決</li>
<li>✅ <strong>Early Stopping：</strong>Pruningにより有望でない試行を打ち切り、計算効率を大幅向上</li>
<li>✅ <strong>分散チューニング：</strong>RDBやRedisを使った並列実行で大規模探索を実現</li>
<li>✅ <strong>転移学習：</strong>過去の知識を活用したウォームスタート、メタ学習で探索効率化</li>
<li>✅ <strong>本番運用：</strong>段階的デプロイ、継続的モニタリング、定期的再チューニングのワークフロー</li>
</ul>

<p>これらの技術を組み合わせることで、実務で求められる高品質かつ効率的なハイパーパラメータチューニングが可能になります。</p>

<div class="project-box">
<h3>📊 実践プロジェクト：エンドツーエンドのチューニングパイプライン</h3>
<p>本章で学んだすべての技術を統合し、実際のビジネス課題を解決するエンドツーエンドのチューニングパイプラインを構築してください：</p>
<ol>
<li>Kaggleコンペティションや実データセットを選択</li>
<li>マルチ目的最適化で精度と推論時間を最適化</li>
<li>Pruningで探索効率化、分散実行で時間短縮</li>
<li>メタ学習で過去の知識を活用</li>
<li>本番運用を想定したモニタリング・再チューニング機構の実装</li>
</ol>
<p>このプロジェクトを通じて、実務レベルのハイパーパラメータチューニングスキルを確立しましょう。</p>
</div>

<div class="navigation">
    <a href="chapter3-advanced-methods.html" class="nav-button">← 第3章：高度な最適化手法</a>
    <a href="index.html" class="nav-button">目次に戻る</a>
</div>

    </main>

    <footer>
        <p>&copy; 2025 AI Terakoya. All rights reserved.</p>
    </footer>

</body>
</html>
