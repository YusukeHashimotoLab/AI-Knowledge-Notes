<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç¬¬2ç« ï¼šçµ±è¨ˆçš„ç•°å¸¸æ¤œçŸ¥ - AI Terakoya</title>

    <style>
        :root {
            --color-primary: #2c3e50;
            --color-primary-dark: #1a252f;
            --color-accent: #7b2cbf;
            --color-accent-light: #9d4edd;
            --color-text: #2d3748;
            --color-text-light: #4a5568;
            --color-bg: #ffffff;
            --color-bg-alt: #f7fafc;
            --color-border: #e2e8f0;
            --color-code-bg: #f8f9fa;
            --color-link: #3182ce;
            --color-link-hover: #2c5aa0;

            --spacing-xs: 0.5rem;
            --spacing-sm: 1rem;
            --spacing-md: 1.5rem;
            --spacing-lg: 2rem;
            --spacing-xl: 3rem;

            --font-body: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            --font-mono: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;

            --border-radius: 8px;
            --box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-body);
            line-height: 1.7;
            color: var(--color-text);
            background-color: var(--color-bg);
            font-size: 16px;
        }

        header {
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            color: white;
            padding: var(--spacing-xl) var(--spacing-md);
            margin-bottom: var(--spacing-xl);
            box-shadow: var(--box-shadow);
        }

        .header-content {
            max-width: 900px;
            margin: 0 auto;
        }

        h1 {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: var(--spacing-sm);
            line-height: 1.2;
        }

        .subtitle {
            font-size: 1.1rem;
            opacity: 0.95;
            font-weight: 400;
            margin-bottom: var(--spacing-md);
        }

        .meta {
            display: flex;
            flex-wrap: wrap;
            gap: var(--spacing-md);
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .meta-item {
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 0 var(--spacing-md) var(--spacing-xl);
        }

        h2 {
            font-size: 1.75rem;
            color: var(--color-primary);
            margin-top: var(--spacing-xl);
            margin-bottom: var(--spacing-md);
            padding-bottom: var(--spacing-xs);
            border-bottom: 3px solid var(--color-accent);
        }

        h3 {
            font-size: 1.4rem;
            color: var(--color-primary);
            margin-top: var(--spacing-lg);
            margin-bottom: var(--spacing-sm);
        }

        h4 {
            font-size: 1.1rem;
            color: var(--color-primary-dark);
            margin-top: var(--spacing-md);
            margin-bottom: var(--spacing-sm);
        }

        p {
            margin-bottom: var(--spacing-md);
            color: var(--color-text);
        }

        a {
            color: var(--color-link);
            text-decoration: none;
            transition: color 0.2s;
        }

        a:hover {
            color: var(--color-link-hover);
            text-decoration: underline;
        }

        ul, ol {
            margin-left: var(--spacing-lg);
            margin-bottom: var(--spacing-md);
        }

        li {
            margin-bottom: var(--spacing-xs);
            color: var(--color-text);
        }

        pre {
            background-color: var(--color-code-bg);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            overflow-x: auto;
            margin-bottom: var(--spacing-md);
            font-family: var(--font-mono);
            font-size: 0.9rem;
            line-height: 1.5;
        }

        code {
            font-family: var(--font-mono);
            font-size: 0.9em;
            background-color: var(--color-code-bg);
            padding: 0.2em 0.4em;
            border-radius: 3px;
        }

        pre code {
            background-color: transparent;
            padding: 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: var(--spacing-md);
            font-size: 0.95rem;
        }

        th, td {
            border: 1px solid var(--color-border);
            padding: var(--spacing-sm);
            text-align: left;
        }

        th {
            background-color: var(--color-bg-alt);
            font-weight: 600;
            color: var(--color-primary);
        }

        blockquote {
            border-left: 4px solid var(--color-accent);
            padding-left: var(--spacing-md);
            margin: var(--spacing-md) 0;
            color: var(--color-text-light);
            font-style: italic;
            background-color: var(--color-bg-alt);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        .mermaid {
            text-align: center;
            margin: var(--spacing-lg) 0;
            background-color: var(--color-bg-alt);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        details {
            background-color: var(--color-bg-alt);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            margin-bottom: var(--spacing-md);
        }

        summary {
            cursor: pointer;
            font-weight: 600;
            color: var(--color-primary);
            user-select: none;
            padding: var(--spacing-xs);
            margin: calc(-1 * var(--spacing-md));
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        summary:hover {
            background-color: rgba(123, 44, 191, 0.1);
        }

        details[open] summary {
            margin-bottom: var(--spacing-md);
            border-bottom: 1px solid var(--color-border);
        }

        .navigation {
            display: flex;
            justify-content: space-between;
            gap: var(--spacing-md);
            margin: var(--spacing-xl) 0;
            padding-top: var(--spacing-lg);
            border-top: 2px solid var(--color-border);
        }

        .nav-button {
            flex: 1;
            padding: var(--spacing-md);
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            color: white;
            border-radius: var(--border-radius);
            text-align: center;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: var(--box-shadow);
        }

        .nav-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            text-decoration: none;
        }

        footer {
            margin-top: var(--spacing-xl);
            padding: var(--spacing-lg) var(--spacing-md);
            background-color: var(--color-bg-alt);
            border-top: 1px solid var(--color-border);
            text-align: center;
            font-size: 0.9rem;
            color: var(--color-text-light);
        }
        .disclaimer {
            max-width: 900px;
            margin: 2rem auto;
            padding: 1.5rem;
            background: #f8f9fa;
            border-left: 4px solid #6c757d;
            border-radius: 4px;
        }

        .disclaimer h3 {
            color: #495057;
            margin-bottom: 1rem;
            font-size: 1.1rem;
        }

        .disclaimer ul {
            list-style: none;
            padding-left: 0;
        }

        .disclaimer li {
            padding: 0.5rem 0;
            padding-left: 1.5rem;
            position: relative;
            font-size: 0.9rem;
            color: #6c757d;
            line-height: 1.6;
        }

        .disclaimer li::before {
            content: "âš ï¸";
            position: absolute;
            left: 0;
        }


        @media (max-width: 768px) {
            h1 {
                font-size: 1.5rem;
            }

            h2 {
                font-size: 1.4rem;
            }

            h3 {
                font-size: 1.2rem;
            }

            .meta {
                font-size: 0.85rem;
            }

            .navigation {
                flex-direction: column;
            }

            table {
                font-size: 0.85rem;
            }

            th, td {
                padding: var(--spacing-xs);
            }
        }
    </style>

    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ startOnLoad: true, theme: 'default' });
    </script>

    <!-- MathJax for LaTeX equation rendering -->
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true,
                processEnvironments: true
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
                ignoreHtmlClass: 'mermaid'
            }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" id="MathJax-script" async></script>
</head>
<body>
    <header>
        <div class="header-content">
            <h1>ç¬¬2ç« ï¼šçµ±è¨ˆçš„ç•°å¸¸æ¤œçŸ¥</h1>
            <p class="subtitle">çµ±è¨ˆçš„æ‰‹æ³•ã«ã‚ˆã‚‹ç•°å¸¸æ¤œçŸ¥ã®åŸºç¤ã¨å¿œç”¨</p>
            <div class="meta">
                <span class="meta-item">ğŸ“– èª­äº†æ™‚é–“: 30-35åˆ†</span>
                <span class="meta-item">ğŸ“Š é›£æ˜“åº¦: åˆç´šã€œä¸­ç´š</span>
                <span class="meta-item">ğŸ’» ã‚³ãƒ¼ãƒ‰ä¾‹: 8å€‹</span>
                <span class="meta-item">ğŸ“ æ¼”ç¿’å•é¡Œ: 5å•</span>
            </div>
        </div>
    </header>

    <main class="container">

<h2>å­¦ç¿’ç›®æ¨™</h2>
<p>ã“ã®ç« ã‚’èª­ã‚€ã“ã¨ã§ã€ä»¥ä¸‹ã‚’ç¿’å¾—ã§ãã¾ã™ï¼š</p>
<ul>
<li>âœ… Z-scoreã¨IQRã«ã‚ˆã‚‹å¤–ã‚Œå€¤æ¤œå‡ºã‚’å®Ÿè£…ã§ãã‚‹</li>
<li>âœ… Mahalanobisè·é›¢ã¨å¤šå¤‰é‡ã‚¬ã‚¦ã‚¹åˆ†å¸ƒã‚’ç†è§£ã™ã‚‹</li>
<li>âœ… çµ±è¨ˆçš„ä»®èª¬æ¤œå®šï¼ˆGrubbs, ESDï¼‰ã‚’é©ç”¨ã§ãã‚‹</li>
<li>âœ… æ™‚ç³»åˆ—ãƒ‡ãƒ¼ã‚¿ã®ç•°å¸¸æ¤œçŸ¥æ‰‹æ³•ã‚’ä½¿ãˆã‚‹</li>
<li>âœ… çµ±è¨ˆçš„æ‰‹æ³•ã®å®Œå…¨ãªãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚’æ§‹ç¯‰ã§ãã‚‹</li>
</ul>

<hr>

<h2>2.1 çµ±è¨ˆçš„å¤–ã‚Œå€¤æ¤œå‡º</h2>

<h3>Z-scoreï¼ˆæ¨™æº–åŒ–ã‚¹ã‚³ã‚¢ï¼‰</h3>

<p><strong>Z-score</strong>ã¯ã€ãƒ‡ãƒ¼ã‚¿ãƒã‚¤ãƒ³ãƒˆãŒå¹³å‡ã‹ã‚‰ã©ã‚Œã ã‘æ¨™æº–åå·®é›¢ã‚Œã¦ã„ã‚‹ã‹ã‚’ç¤ºã™æŒ‡æ¨™ã§ã™ã€‚</p>

<blockquote>
<p>Z-score = $\frac{x - \mu}{\sigma}$</p>
<p>ä¸€èˆ¬çš„ãªé–¾å€¤ï¼š$|Z| > 3$ ã‚’ç•°å¸¸ã¨ã™ã‚‹</p>
</blockquote>

<h4>Z-scoreã®ç‰¹å¾´</h4>
<ul>
<li><strong>åˆ©ç‚¹</strong>: ã‚·ãƒ³ãƒ—ãƒ«ã§è§£é‡ˆã—ã‚„ã™ã„ã€è¨ˆç®—ãŒé«˜é€Ÿ</li>
<li><strong>æ¬ ç‚¹</strong>: æ­£è¦åˆ†å¸ƒã‚’ä»®å®šã€å¤–ã‚Œå€¤ã®å½±éŸ¿ã‚’å—ã‘ã‚„ã™ã„</li>
<li><strong>é©ç”¨å ´é¢</strong>: å˜å¤‰é‡ãƒ‡ãƒ¼ã‚¿ã€æ­£è¦åˆ†å¸ƒã«è¿‘ã„ãƒ‡ãƒ¼ã‚¿</li>
</ul>

<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
from scipy import stats

# ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆ
np.random.seed(42)
normal_data = np.random.normal(loc=0, scale=1, size=300)
outliers = np.array([5, -5, 6, -6, 7])
data = np.concatenate([normal_data, outliers])

# Z-scoreã®è¨ˆç®—
z_scores = np.abs(stats.zscore(data))
threshold = 3
anomalies = z_scores > threshold

# å¯è¦–åŒ–
fig, axes = plt.subplots(1, 2, figsize=(14, 6))

# ãƒ‡ãƒ¼ã‚¿åˆ†å¸ƒ
axes[0].hist(data, bins=30, alpha=0.7, edgecolor='black', color='steelblue')
axes[0].axvline(x=data.mean() + 3*data.std(), color='red',
                linestyle='--', linewidth=2, label='Â±3Ïƒ')
axes[0].axvline(x=data.mean() - 3*data.std(), color='red',
                linestyle='--', linewidth=2)
axes[0].set_xlabel('å€¤', fontsize=12)
axes[0].set_ylabel('é »åº¦', fontsize=12)
axes[0].set_title('ãƒ‡ãƒ¼ã‚¿åˆ†å¸ƒã¨Z-scoreé–¾å€¤', fontsize=14, fontweight='bold')
axes[0].legend(fontsize=10)
axes[0].grid(True, alpha=0.3)

# Z-scoreãƒ—ãƒ­ãƒƒãƒˆ
axes[1].scatter(range(len(data)), z_scores, alpha=0.6, s=30, c='blue')
axes[1].scatter(np.where(anomalies)[0], z_scores[anomalies],
                c='red', s=100, marker='X', label='ç•°å¸¸', zorder=5, edgecolors='black')
axes[1].axhline(y=threshold, color='red', linestyle='--', linewidth=2, label='é–¾å€¤=3')
axes[1].set_xlabel('ã‚µãƒ³ãƒ—ãƒ«ç•ªå·', fontsize=12)
axes[1].set_ylabel('|Z-score|', fontsize=12)
axes[1].set_title('Z-scoreã«ã‚ˆã‚‹ç•°å¸¸æ¤œçŸ¥', fontsize=14, fontweight='bold')
axes[1].legend(fontsize=10)
axes[1].grid(True, alpha=0.3)

plt.tight_layout()
plt.show()

print("=== Z-scoreç•°å¸¸æ¤œçŸ¥çµæœ ===")
print(f"ç•°å¸¸æ¤œå‡ºæ•°: {anomalies.sum()}å€‹")
print(f"ç•°å¸¸ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹: {np.where(anomalies)[0]}")
print(f"ç•°å¸¸å€¤: {data[anomalies]}")
</code></pre>

<h3>IQRï¼ˆå››åˆ†ä½ç¯„å›²ï¼‰</h3>

<p><strong>IQRæ³•</strong>ã¯ã€å¤–ã‚Œå€¤ã«å¯¾ã—ã¦ãƒ­ãƒã‚¹ãƒˆãªæ¤œå‡ºæ‰‹æ³•ã§ã™ã€‚</p>

<blockquote>
<p>IQR = Q3 - Q1<br>
ç•°å¸¸åˆ¤å®šï¼š$x < Q1 - 1.5 \times IQR$ ã¾ãŸã¯ $x > Q3 + 1.5 \times IQR$</p>
</blockquote>

<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt

# ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆ
np.random.seed(42)
normal_data = np.random.normal(loc=50, scale=10, size=300)
outliers = np.array([100, 5, 110, 0])
data = np.concatenate([normal_data, outliers])

# IQRã®è¨ˆç®—
Q1 = np.percentile(data, 25)
Q3 = np.percentile(data, 75)
IQR = Q3 - Q1
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# ç•°å¸¸æ¤œå‡º
anomalies = (data < lower_bound) | (data > upper_bound)

# å¯è¦–åŒ–
fig, axes = plt.subplots(1, 2, figsize=(14, 6))

# ãƒœãƒƒã‚¯ã‚¹ãƒ—ãƒ­ãƒƒãƒˆ
bp = axes[0].boxplot(data, vert=True, patch_artist=True)
bp['boxes'][0].set_facecolor('lightblue')
bp['boxes'][0].set_edgecolor('black')
axes[0].scatter([1]*anomalies.sum(), data[anomalies],
                c='red', s=100, marker='X', label='ç•°å¸¸', zorder=5, edgecolors='black')
axes[0].set_ylabel('å€¤', fontsize=12)
axes[0].set_title('ç®±ã²ã’å›³ã¨IQRç•°å¸¸æ¤œçŸ¥', fontsize=14, fontweight='bold')
axes[0].legend(fontsize=10)
axes[0].grid(True, alpha=0.3, axis='y')

# æ•£å¸ƒå›³
axes[1].scatter(range(len(data)), data, alpha=0.6, s=30, c='blue', label='æ­£å¸¸')
axes[1].scatter(np.where(anomalies)[0], data[anomalies],
                c='red', s=100, marker='X', label='ç•°å¸¸', zorder=5, edgecolors='black')
axes[1].axhline(y=upper_bound, color='red', linestyle='--', linewidth=2, label='IQRå¢ƒç•Œ')
axes[1].axhline(y=lower_bound, color='red', linestyle='--', linewidth=2)
axes[1].axhline(y=Q1, color='green', linestyle=':', linewidth=1.5, label='Q1/Q3')
axes[1].axhline(y=Q3, color='green', linestyle=':', linewidth=1.5)
axes[1].set_xlabel('ã‚µãƒ³ãƒ—ãƒ«ç•ªå·', fontsize=12)
axes[1].set_ylabel('å€¤', fontsize=12)
axes[1].set_title('IQRæ³•ã«ã‚ˆã‚‹ç•°å¸¸æ¤œçŸ¥', fontsize=14, fontweight='bold')
axes[1].legend(fontsize=10)
axes[1].grid(True, alpha=0.3)

plt.tight_layout()
plt.show()

print("=== IQRç•°å¸¸æ¤œçŸ¥çµæœ ===")
print(f"Q1: {Q1:.2f}, Q3: {Q3:.2f}, IQR: {IQR:.2f}")
print(f"ä¸‹é™: {lower_bound:.2f}, ä¸Šé™: {upper_bound:.2f}")
print(f"ç•°å¸¸æ¤œå‡ºæ•°: {anomalies.sum()}å€‹")
print(f"ç•°å¸¸å€¤: {data[anomalies]}")
</code></pre>

<blockquote>
<p><strong>é‡è¦</strong>: IQRã¯Z-scoreã¨ç•°ãªã‚Šã€æ­£è¦åˆ†å¸ƒã‚’ä»®å®šã›ãšã€å¤–ã‚Œå€¤ã®å½±éŸ¿ã‚’å—ã‘ã«ãã„ãƒ­ãƒã‚¹ãƒˆãªæ‰‹æ³•ã§ã™ã€‚</p>
</blockquote>

<hr>

<h2>2.2 ç¢ºç‡åˆ†å¸ƒãƒ™ãƒ¼ã‚¹ã®ç•°å¸¸æ¤œçŸ¥</h2>

<h3>Mahalanobisè·é›¢</h3>

<p><strong>Mahalanobisè·é›¢</strong>ã¯ã€å¤šå¤‰é‡ãƒ‡ãƒ¼ã‚¿ã«ãŠã„ã¦ã€å…±åˆ†æ•£ã‚’è€ƒæ…®ã—ãŸè·é›¢æŒ‡æ¨™ã§ã™ã€‚</p>

<blockquote>
<p>$D_M(x) = \sqrt{(x - \mu)^T \Sigma^{-1} (x - \mu)}$</p>
<p>ã“ã“ã§ã€$\mu$ã¯å¹³å‡ãƒ™ã‚¯ãƒˆãƒ«ã€$\Sigma$ã¯å…±åˆ†æ•£è¡Œåˆ—</p>
</blockquote>

<h4>ç‰¹å¾´</h4>
<ul>
<li><strong>åˆ©ç‚¹</strong>: å¤‰æ•°é–“ã®ç›¸é–¢ã‚’è€ƒæ…®ã€ã‚¹ã‚±ãƒ¼ãƒ«ä¸å¤‰</li>
<li><strong>æ¬ ç‚¹</strong>: å…±åˆ†æ•£è¡Œåˆ—ã®é€†è¡Œåˆ—è¨ˆç®—ãŒå¿…è¦ã€è¨ˆç®—ã‚³ã‚¹ãƒˆãŒé«˜ã„</li>
<li><strong>é©ç”¨å ´é¢</strong>: å¤šå¤‰é‡ãƒ‡ãƒ¼ã‚¿ã€ç›¸é–¢ã®ã‚ã‚‹ç‰¹å¾´é‡</li>
</ul>

<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
from scipy.spatial.distance import mahalanobis
from scipy.stats import chi2

# ç›¸é–¢ã®ã‚ã‚‹2å¤‰é‡ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆ
np.random.seed(42)
mean = [0, 0]
cov = [[1, 0.8], [0.8, 1]]  # ç›¸é–¢ä¿‚æ•°0.8
normal_data = np.random.multivariate_normal(mean, cov, size=300)

# ç•°å¸¸ãƒ‡ãƒ¼ã‚¿ã®è¿½åŠ 
outliers = np.array([[4, 4], [-4, -4], [4, -4]])
data = np.vstack([normal_data, outliers])

# Mahalanobisè·é›¢ã®è¨ˆç®—
mean_vec = normal_data.mean(axis=0)
cov_matrix = np.cov(normal_data.T)
cov_inv = np.linalg.inv(cov_matrix)

mahal_distances = np.array([mahalanobis(x, mean_vec, cov_inv) for x in data])

# é–¾å€¤ï¼ˆè‡ªç”±åº¦2ã®ã‚«ã‚¤äºŒä¹—åˆ†å¸ƒã®99%ç‚¹ï¼‰
threshold = np.sqrt(chi2.ppf(0.99, df=2))
anomalies = mahal_distances > threshold

# å¯è¦–åŒ–
fig, axes = plt.subplots(1, 2, figsize=(14, 6))

# ãƒ‡ãƒ¼ã‚¿åˆ†å¸ƒ
axes[0].scatter(normal_data[:, 0], normal_data[:, 1],
                alpha=0.6, s=50, c='blue', label='æ­£å¸¸', edgecolors='black')
axes[0].scatter(outliers[:, 0], outliers[:, 1],
                c='red', s=150, marker='X', label='ç•°å¸¸', zorder=5, edgecolors='black', linewidths=2)

# ä¿¡é ¼æ¥•å††ï¼ˆ99%ï¼‰
from matplotlib.patches import Ellipse
eigenvalues, eigenvectors = np.linalg.eig(cov_matrix)
angle = np.degrees(np.arctan2(eigenvectors[1, 0], eigenvectors[0, 0]))
width, height = 2 * threshold * np.sqrt(eigenvalues)
ellipse = Ellipse(mean_vec, width, height, angle=angle,
                  edgecolor='red', facecolor='none', linewidth=2, linestyle='--', label='99%ä¿¡é ¼æ¥•å††')
axes[0].add_patch(ellipse)

axes[0].set_xlabel('ç‰¹å¾´é‡ 1', fontsize=12)
axes[0].set_ylabel('ç‰¹å¾´é‡ 2', fontsize=12)
axes[0].set_title('Mahalanobisè·é›¢ã«ã‚ˆã‚‹ç•°å¸¸æ¤œçŸ¥', fontsize=14, fontweight='bold')
axes[0].legend(fontsize=10)
axes[0].grid(True, alpha=0.3)
axes[0].axis('equal')

# Mahalanobisè·é›¢åˆ†å¸ƒ
axes[1].hist(mahal_distances, bins=30, alpha=0.7, edgecolor='black', color='steelblue')
axes[1].axvline(x=threshold, color='red', linestyle='--', linewidth=2, label=f'é–¾å€¤={threshold:.2f}')
axes[1].set_xlabel('Mahalanobisè·é›¢', fontsize=12)
axes[1].set_ylabel('é »åº¦', fontsize=12)
axes[1].set_title('Mahalanobisè·é›¢ã®åˆ†å¸ƒ', fontsize=14, fontweight='bold')
axes[1].legend(fontsize=10)
axes[1].grid(True, alpha=0.3)

plt.tight_layout()
plt.show()

print("=== Mahalanobisè·é›¢ç•°å¸¸æ¤œçŸ¥çµæœ ===")
print(f"é–¾å€¤: {threshold:.3f}")
print(f"ç•°å¸¸æ¤œå‡ºæ•°: {anomalies.sum()}å€‹")
print(f"ç•°å¸¸ã®Mahalanobisè·é›¢: {mahal_distances[anomalies]}")
</code></pre>

<h3>å¤šå¤‰é‡ã‚¬ã‚¦ã‚¹åˆ†å¸ƒ</h3>

<p><strong>å¤šå¤‰é‡ã‚¬ã‚¦ã‚¹åˆ†å¸ƒ</strong>ã‚’ç”¨ã„ãŸç•°å¸¸æ¤œçŸ¥ã¯ã€ç¢ºç‡å¯†åº¦ã«åŸºã¥ã„ã¦ç•°å¸¸ã‚’åˆ¤å®šã—ã¾ã™ã€‚</p>

<blockquote>
<p>$p(x) = \frac{1}{(2\pi)^{n/2} |\Sigma|^{1/2}} \exp\left(-\frac{1}{2}(x-\mu)^T \Sigma^{-1} (x-\mu)\right)$</p>
<p>ç•°å¸¸åˆ¤å®šï¼š$p(x) < \epsilon$ ï¼ˆé–¾å€¤ï¼‰</p>
</blockquote>

<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import multivariate_normal

# ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆ
np.random.seed(42)
mean = [0, 0]
cov = [[1, 0.5], [0.5, 1]]
normal_data = np.random.multivariate_normal(mean, cov, size=300)
outliers = np.array([[5, 5], [-5, -5], [5, -5]])
data = np.vstack([normal_data, outliers])

# å¤šå¤‰é‡ã‚¬ã‚¦ã‚¹åˆ†å¸ƒã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿æ¨å®š
mean_vec = normal_data.mean(axis=0)
cov_matrix = np.cov(normal_data.T)
mvn = multivariate_normal(mean=mean_vec, cov=cov_matrix)

# ç¢ºç‡å¯†åº¦ã®è¨ˆç®—
densities = mvn.pdf(data)

# é–¾å€¤ï¼ˆ1%ç‚¹ï¼‰
threshold = np.percentile(densities, 1)
anomalies = densities < threshold

# ã‚°ãƒªãƒƒãƒ‰ä¸Šã§ç¢ºç‡å¯†åº¦ã‚’è¨ˆç®—ï¼ˆãƒ’ãƒ¼ãƒˆãƒãƒƒãƒ—ç”¨ï¼‰
x_range = np.linspace(-6, 6, 200)
y_range = np.linspace(-6, 6, 200)
xx, yy = np.meshgrid(x_range, y_range)
positions = np.dstack((xx, yy))
Z = mvn.pdf(positions)

# å¯è¦–åŒ–
fig, axes = plt.subplots(1, 2, figsize=(14, 6))

# ç¢ºç‡å¯†åº¦ãƒ’ãƒ¼ãƒˆãƒãƒƒãƒ—
contour = axes[0].contourf(xx, yy, Z, levels=20, cmap='viridis', alpha=0.7)
axes[0].scatter(normal_data[:, 0], normal_data[:, 1],
                alpha=0.6, s=30, c='blue', label='æ­£å¸¸', edgecolors='black')
axes[0].scatter(data[anomalies, 0], data[anomalies, 1],
                c='red', s=150, marker='X', label='ç•°å¸¸', zorder=5, edgecolors='black', linewidths=2)
plt.colorbar(contour, ax=axes[0], label='ç¢ºç‡å¯†åº¦')
axes[0].set_xlabel('ç‰¹å¾´é‡ 1', fontsize=12)
axes[0].set_ylabel('ç‰¹å¾´é‡ 2', fontsize=12)
axes[0].set_title('å¤šå¤‰é‡ã‚¬ã‚¦ã‚¹åˆ†å¸ƒã«ã‚ˆã‚‹ç•°å¸¸æ¤œçŸ¥', fontsize=14, fontweight='bold')
axes[0].legend(fontsize=10)
axes[0].grid(True, alpha=0.3)

# ç¢ºç‡å¯†åº¦ã®ãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ 
axes[1].hist(np.log(densities), bins=30, alpha=0.7, edgecolor='black', color='steelblue')
axes[1].axvline(x=np.log(threshold), color='red', linestyle='--', linewidth=2, label='é–¾å€¤')
axes[1].set_xlabel('log(ç¢ºç‡å¯†åº¦)', fontsize=12)
axes[1].set_ylabel('é »åº¦', fontsize=12)
axes[1].set_title('ç¢ºç‡å¯†åº¦ã®åˆ†å¸ƒ', fontsize=14, fontweight='bold')
axes[1].legend(fontsize=10)
axes[1].grid(True, alpha=0.3)

plt.tight_layout()
plt.show()

print("=== å¤šå¤‰é‡ã‚¬ã‚¦ã‚¹åˆ†å¸ƒç•°å¸¸æ¤œçŸ¥çµæœ ===")
print(f"é–¾å€¤: {threshold:.6f}")
print(f"ç•°å¸¸æ¤œå‡ºæ•°: {anomalies.sum()}å€‹")
print(f"ç•°å¸¸ã®ç¢ºç‡å¯†åº¦: {densities[anomalies]}")
</code></pre>

<blockquote>
<p><strong>é‡è¦</strong>: Mahalanobisè·é›¢ã¨å¤šå¤‰é‡ã‚¬ã‚¦ã‚¹åˆ†å¸ƒã¯æ•°å­¦çš„ã«ç­‰ä¾¡ã§ã™ã€‚Mahalanobisè·é›¢ã®äºŒä¹—ã¯ã€å¯¾æ•°ç¢ºç‡å¯†åº¦ã«æ¯”ä¾‹ã—ã¾ã™ã€‚</p>
</blockquote>

<hr>

<h2>2.3 çµ±è¨ˆçš„ä»®èª¬æ¤œå®š</h2>

<h3>Grubbs' Testï¼ˆã‚°ãƒ©ãƒ–ã‚¹æ¤œå®šï¼‰</h3>

<p><strong>Grubbs' Test</strong>ã¯ã€å˜ä¸€ã®å¤–ã‚Œå€¤ã‚’æ¤œå‡ºã™ã‚‹ä»®èª¬æ¤œå®šã§ã™ã€‚</p>

<blockquote>
<p>å¸°ç„¡ä»®èª¬ $H_0$: å¤–ã‚Œå€¤ã¯å­˜åœ¨ã—ãªã„<br>
æ¤œå®šçµ±è¨ˆé‡: $G = \frac{\max|x_i - \bar{x}|}{s}$<br>
ã“ã“ã§ã€$s$ã¯æ¨™æº–åå·®</p>
</blockquote>

<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
from scipy import stats

def grubbs_test(data, alpha=0.05):
    """Grubbs' Testã«ã‚ˆã‚‹å¤–ã‚Œå€¤æ¤œå‡º"""
    n = len(data)
    mean = np.mean(data)
    std = np.std(data, ddof=1)

    # æ¤œå®šçµ±è¨ˆé‡ã®è¨ˆç®—
    deviations = np.abs(data - mean)
    max_idx = np.argmax(deviations)
    G = deviations[max_idx] / std

    # è‡¨ç•Œå€¤ã®è¨ˆç®—
    t_dist = stats.t.ppf(1 - alpha / (2 * n), n - 2)
    G_critical = ((n - 1) / np.sqrt(n)) * np.sqrt(t_dist**2 / (n - 2 + t_dist**2))

    is_outlier = G > G_critical

    return {
        'G': G,
        'G_critical': G_critical,
        'is_outlier': is_outlier,
        'outlier_idx': max_idx if is_outlier else None,
        'outlier_value': data[max_idx] if is_outlier else None,
        'p_value': 1 - stats.t.cdf(G * np.sqrt(n) / np.sqrt(n - 1), n - 2)
    }

# ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆ
np.random.seed(42)
data = np.concatenate([np.random.normal(50, 5, size=30), [80]])  # 80ãŒå¤–ã‚Œå€¤

# Grubbs' Testå®Ÿè¡Œ
result = grubbs_test(data, alpha=0.05)

# å¯è¦–åŒ–
fig, axes = plt.subplots(1, 2, figsize=(14, 6))

# ãƒ‡ãƒ¼ã‚¿ãƒ—ãƒ­ãƒƒãƒˆ
axes[0].scatter(range(len(data)), data, alpha=0.6, s=50, c='blue', label='ãƒ‡ãƒ¼ã‚¿')
if result['is_outlier']:
    axes[0].scatter(result['outlier_idx'], result['outlier_value'],
                    c='red', s=200, marker='X', label='å¤–ã‚Œå€¤', zorder=5, edgecolors='black', linewidths=2)
axes[0].axhline(y=data.mean(), color='green', linestyle='--', linewidth=2, label='å¹³å‡')
axes[0].axhline(y=data.mean() + 3*data.std(), color='orange', linestyle=':', linewidth=1.5, label='Â±3Ïƒ')
axes[0].axhline(y=data.mean() - 3*data.std(), color='orange', linestyle=':', linewidth=1.5)
axes[0].set_xlabel('ã‚µãƒ³ãƒ—ãƒ«ç•ªå·', fontsize=12)
axes[0].set_ylabel('å€¤', fontsize=12)
axes[0].set_title("Grubbs' Testçµæœ", fontsize=14, fontweight='bold')
axes[0].legend(fontsize=10)
axes[0].grid(True, alpha=0.3)

# æ¤œå®šçµ±è¨ˆé‡ã®æ¯”è¼ƒ
axes[1].bar(['Gçµ±è¨ˆé‡', 'è‡¨ç•Œå€¤'], [result['G'], result['G_critical']],
            color=['steelblue', 'red'], edgecolor='black', alpha=0.7)
axes[1].set_ylabel('å€¤', fontsize=12)
axes[1].set_title('æ¤œå®šçµ±è¨ˆé‡ vs è‡¨ç•Œå€¤', fontsize=14, fontweight='bold')
axes[1].grid(True, alpha=0.3, axis='y')

plt.tight_layout()
plt.show()

print("=== Grubbs' Testçµæœ ===")
print(f"Gçµ±è¨ˆé‡: {result['G']:.3f}")
print(f"è‡¨ç•Œå€¤: {result['G_critical']:.3f}")
print(f"på€¤: {result['p_value']:.4f}")
print(f"å¤–ã‚Œå€¤æ¤œå‡º: {'Yes' if result['is_outlier'] else 'No'}")
if result['is_outlier']:
    print(f"å¤–ã‚Œå€¤: index={result['outlier_idx']}, value={result['outlier_value']:.2f}")
</code></pre>

<h3>ESD Testï¼ˆæ¥µç«¯ãªã‚¹ãƒãƒ¥ãƒ¼ãƒ‡ãƒ³ãƒˆåŒ–åå·®æ¤œå®šï¼‰</h3>

<p><strong>Generalized ESD Test</strong>ã¯ã€è¤‡æ•°ã®å¤–ã‚Œå€¤ã‚’æ¤œå‡ºã§ãã‚‹æ‹¡å¼µç‰ˆã§ã™ã€‚</p>

<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
from scipy import stats

def generalized_esd_test(data, max_outliers, alpha=0.05):
    """Generalized ESD Testã«ã‚ˆã‚‹è¤‡æ•°å¤–ã‚Œå€¤æ¤œå‡º"""
    n = len(data)
    outliers = []
    data_copy = data.copy()

    for i in range(max_outliers):
        mean = np.mean(data_copy)
        std = np.std(data_copy, ddof=1)

        # æ¤œå®šçµ±è¨ˆé‡ã®è¨ˆç®—
        deviations = np.abs(data_copy - mean)
        max_idx = np.argmax(deviations)
        R = deviations[max_idx] / std

        # è‡¨ç•Œå€¤ã®è¨ˆç®—
        n_current = len(data_copy)
        p = 1 - alpha / (2 * (n_current - i))
        t_dist = stats.t.ppf(p, n_current - i - 2)
        lambda_critical = ((n_current - i - 1) * t_dist) / np.sqrt((n_current - i - 2 + t_dist**2) * (n_current - i))

        if R > lambda_critical:
            outlier_idx = np.where(data == data_copy[max_idx])[0][0]
            outliers.append({'index': outlier_idx, 'value': data_copy[max_idx], 'R': R})
            data_copy = np.delete(data_copy, max_idx)
        else:
            break

    return outliers

# ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆ
np.random.seed(42)
normal_data = np.random.normal(50, 5, size=30)
outlier_values = [80, 85, 15]
data = np.concatenate([normal_data, outlier_values])

# ESD Testå®Ÿè¡Œ
outliers = generalized_esd_test(data, max_outliers=5, alpha=0.05)

# å¯è¦–åŒ–
plt.figure(figsize=(12, 6))
plt.scatter(range(len(data)), data, alpha=0.6, s=50, c='blue', label='æ­£å¸¸ãƒ‡ãƒ¼ã‚¿')

if outliers:
    outlier_indices = [o['index'] for o in outliers]
    outlier_values_detected = [o['value'] for o in outliers]
    plt.scatter(outlier_indices, outlier_values_detected,
                c='red', s=200, marker='X', label='å¤–ã‚Œå€¤', zorder=5, edgecolors='black', linewidths=2)

plt.axhline(y=data.mean(), color='green', linestyle='--', linewidth=2, label='å¹³å‡')
plt.axhline(y=data.mean() + 3*data.std(), color='orange', linestyle=':', linewidth=1.5, label='Â±3Ïƒ')
plt.axhline(y=data.mean() - 3*data.std(), color='orange', linestyle=':', linewidth=1.5)
plt.xlabel('ã‚µãƒ³ãƒ—ãƒ«ç•ªå·', fontsize=12)
plt.ylabel('å€¤', fontsize=12)
plt.title('Generalized ESD Testçµæœ', fontsize=14, fontweight='bold')
plt.legend(fontsize=10)
plt.grid(True, alpha=0.3)
plt.tight_layout()
plt.show()

print("=== Generalized ESD Testçµæœ ===")
print(f"æ¤œå‡ºã•ã‚ŒãŸå¤–ã‚Œå€¤æ•°: {len(outliers)}å€‹")
for i, o in enumerate(outliers, 1):
    print(f"å¤–ã‚Œå€¤{i}: index={o['index']}, value={o['value']:.2f}, R={o['R']:.3f}")
</code></pre>

<blockquote>
<p><strong>é‡è¦</strong>: Grubbs' Testã¯1ã¤ã®å¤–ã‚Œå€¤ã®ã¿æ¤œå‡ºå¯èƒ½ã§ã™ãŒã€ESD Testã¯è¤‡æ•°ã®å¤–ã‚Œå€¤ã‚’é€æ¬¡çš„ã«æ¤œå‡ºã§ãã¾ã™ã€‚</p>
</blockquote>

<hr>

<h2>2.4 æ™‚ç³»åˆ—ç•°å¸¸æ¤œçŸ¥</h2>

<h3>ç§»å‹•å¹³å‡ã«ã‚ˆã‚‹ç•°å¸¸æ¤œçŸ¥</h3>

<p><strong>ç§»å‹•å¹³å‡</strong>ã¯ã€æ™‚ç³»åˆ—ãƒ‡ãƒ¼ã‚¿ã®å‚¾å‘ã‚’æ‰ãˆã€é€¸è„±ã‚’æ¤œå‡ºã—ã¾ã™ã€‚</p>

<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt

# æ™‚ç³»åˆ—ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆ
np.random.seed(42)
n_samples = 300
time = np.arange(n_samples)
trend = 0.05 * time
seasonal = 10 * np.sin(2 * np.pi * time / 50)
noise = np.random.normal(0, 2, n_samples)
data = trend + seasonal + noise

# ç•°å¸¸ã‚’è¿½åŠ 
anomaly_indices = [50, 150, 250]
data[anomaly_indices] += [20, -25, 30]

# ç§»å‹•å¹³å‡ã®è¨ˆç®—
window_size = 20
moving_avg = np.convolve(data, np.ones(window_size)/window_size, mode='same')
moving_std = np.array([data[max(0, i-window_size//2):min(len(data), i+window_size//2)].std()
                       for i in range(len(data))])

# ç•°å¸¸æ¤œå‡ºï¼ˆ3Ïƒãƒ«ãƒ¼ãƒ«ï¼‰
residuals = np.abs(data - moving_avg)
threshold = 3 * moving_std
anomalies = residuals > threshold

# å¯è¦–åŒ–
fig, axes = plt.subplots(2, 1, figsize=(14, 10))

# æ™‚ç³»åˆ—ãƒ‡ãƒ¼ã‚¿
axes[0].plot(time, data, alpha=0.7, linewidth=1, label='å…ƒãƒ‡ãƒ¼ã‚¿', color='blue')
axes[0].plot(time, moving_avg, linewidth=2, label=f'ç§»å‹•å¹³å‡(window={window_size})', color='green')
axes[0].fill_between(time, moving_avg - 3*moving_std, moving_avg + 3*moving_std,
                     alpha=0.2, color='green', label='Â±3Ïƒ')
axes[0].scatter(time[anomalies], data[anomalies],
                c='red', s=100, marker='X', label='ç•°å¸¸', zorder=5, edgecolors='black', linewidths=2)
axes[0].set_xlabel('æ™‚åˆ»', fontsize=12)
axes[0].set_ylabel('å€¤', fontsize=12)
axes[0].set_title('ç§»å‹•å¹³å‡ã«ã‚ˆã‚‹æ™‚ç³»åˆ—ç•°å¸¸æ¤œçŸ¥', fontsize=14, fontweight='bold')
axes[0].legend(fontsize=10)
axes[0].grid(True, alpha=0.3)

# æ®‹å·®ãƒ—ãƒ­ãƒƒãƒˆ
axes[1].plot(time, residuals, alpha=0.7, linewidth=1, color='blue')
axes[1].plot(time, threshold, linestyle='--', linewidth=2, color='red', label='é–¾å€¤(3Ïƒ)')
axes[1].scatter(time[anomalies], residuals[anomalies],
                c='red', s=100, marker='X', label='ç•°å¸¸', zorder=5, edgecolors='black', linewidths=2)
axes[1].set_xlabel('æ™‚åˆ»', fontsize=12)
axes[1].set_ylabel('æ®‹å·®', fontsize=12)
axes[1].set_title('æ®‹å·®ã¨ç•°å¸¸é–¾å€¤', fontsize=14, fontweight='bold')
axes[1].legend(fontsize=10)
axes[1].grid(True, alpha=0.3)

plt.tight_layout()
plt.show()

print("=== ç§»å‹•å¹³å‡ç•°å¸¸æ¤œçŸ¥çµæœ ===")
print(f"ç•°å¸¸æ¤œå‡ºæ•°: {anomalies.sum()}å€‹")
print(f"ç•°å¸¸ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹: {np.where(anomalies)[0]}")
</code></pre>

<h3>å­£ç¯€æ€§åˆ†è§£ã«ã‚ˆã‚‹ç•°å¸¸æ¤œçŸ¥</h3>

<p><strong>STLåˆ†è§£</strong>ï¼ˆSeasonal and Trend decomposition using Loessï¼‰ã«ã‚ˆã‚Šã€å­£ç¯€æ€§ãƒ»ãƒˆãƒ¬ãƒ³ãƒ‰ãƒ»æ®‹å·®ã«åˆ†è§£ã—ã¾ã™ã€‚</p>

<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
from statsmodels.tsa.seasonal import seasonal_decompose

# æ™‚ç³»åˆ—ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆï¼ˆæ˜ç¢ºãªå­£ç¯€æ€§ï¼‰
np.random.seed(42)
n_samples = 200
time = np.arange(n_samples)
trend = 0.1 * time
seasonal = 15 * np.sin(2 * np.pi * time / 30)  # å‘¨æœŸ30
noise = np.random.normal(0, 2, n_samples)
data = trend + seasonal + noise

# ç•°å¸¸ã‚’è¿½åŠ 
anomaly_indices = [50, 120, 180]
data[anomaly_indices] += [30, -30, 25]

# å­£ç¯€æ€§åˆ†è§£
result = seasonal_decompose(data, model='additive', period=30, extrapolate_trend='freq')

# æ®‹å·®ã‹ã‚‰ç•°å¸¸æ¤œå‡º
residual = result.resid
threshold = 3 * np.nanstd(residual)
anomalies = np.abs(residual) > threshold

# å¯è¦–åŒ–
fig, axes = plt.subplots(4, 1, figsize=(14, 12))

# å…ƒãƒ‡ãƒ¼ã‚¿
axes[0].plot(time, data, linewidth=1, color='blue')
axes[0].scatter(time[anomalies], data[anomalies],
                c='red', s=100, marker='X', label='ç•°å¸¸', zorder=5, edgecolors='black', linewidths=2)
axes[0].set_ylabel('å…ƒãƒ‡ãƒ¼ã‚¿', fontsize=11)
axes[0].set_title('å­£ç¯€æ€§åˆ†è§£ã«ã‚ˆã‚‹æ™‚ç³»åˆ—ç•°å¸¸æ¤œçŸ¥', fontsize=14, fontweight='bold')
axes[0].legend(fontsize=10)
axes[0].grid(True, alpha=0.3)

# ãƒˆãƒ¬ãƒ³ãƒ‰
axes[1].plot(time, result.trend, linewidth=2, color='green')
axes[1].set_ylabel('ãƒˆãƒ¬ãƒ³ãƒ‰', fontsize=11)
axes[1].grid(True, alpha=0.3)

# å­£ç¯€æ€§
axes[2].plot(time, result.seasonal, linewidth=2, color='orange')
axes[2].set_ylabel('å­£ç¯€æ€§', fontsize=11)
axes[2].grid(True, alpha=0.3)

# æ®‹å·®
axes[3].plot(time, residual, linewidth=1, color='blue')
axes[3].axhline(y=threshold, color='red', linestyle='--', linewidth=2, label='é–¾å€¤(Â±3Ïƒ)')
axes[3].axhline(y=-threshold, color='red', linestyle='--', linewidth=2)
axes[3].scatter(time[anomalies], residual[anomalies],
                c='red', s=100, marker='X', label='ç•°å¸¸', zorder=5, edgecolors='black', linewidths=2)
axes[3].set_xlabel('æ™‚åˆ»', fontsize=12)
axes[3].set_ylabel('æ®‹å·®', fontsize=11)
axes[3].legend(fontsize=10)
axes[3].grid(True, alpha=0.3)

plt.tight_layout()
plt.show()

print("=== å­£ç¯€æ€§åˆ†è§£ç•°å¸¸æ¤œçŸ¥çµæœ ===")
print(f"å‘¨æœŸ: 30")
print(f"ç•°å¸¸æ¤œå‡ºæ•°: {anomalies.sum()}å€‹")
print(f"ç•°å¸¸ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹: {np.where(anomalies)[0]}")
</code></pre>

<blockquote>
<p><strong>é‡è¦</strong>: å­£ç¯€æ€§åˆ†è§£ã¯ã€ãƒˆãƒ¬ãƒ³ãƒ‰ã¨å­£ç¯€æ€§ã‚’é™¤å»ã™ã‚‹ã“ã¨ã§ã€çœŸã®ç•°å¸¸ã‚’æ®‹å·®ã¨ã—ã¦æ˜ç¢ºã«æ¤œå‡ºã§ãã¾ã™ã€‚</p>
</blockquote>

<hr>

<h2>2.5 å®Ÿè£…ã¨å¿œç”¨</h2>

<h3>çµ±è¨ˆçš„ç•°å¸¸æ¤œçŸ¥ã®å®Œå…¨ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³</h3>

<p>å®Ÿå‹™ã§ä½¿ãˆã‚‹çµ±è¨ˆçš„ç•°å¸¸æ¤œçŸ¥ã‚·ã‚¹ãƒ†ãƒ ã‚’æ§‹ç¯‰ã—ã¾ã™ã€‚</p>

<pre><code class="language-python">import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy import stats
from statsmodels.tsa.seasonal import seasonal_decompose

class StatisticalAnomalyDetector:
    """çµ±è¨ˆçš„ç•°å¸¸æ¤œçŸ¥ã®çµ±åˆã‚¯ãƒ©ã‚¹"""

    def __init__(self, method='zscore', threshold=3.0, window_size=20):
        """
        Parameters:
        -----------
        method : str
            æ¤œå‡ºæ‰‹æ³• ('zscore', 'iqr', 'mahalanobis', 'moving_avg', 'seasonal')
        threshold : float
            ç•°å¸¸åˆ¤å®šé–¾å€¤
        window_size : int
            ç§»å‹•å¹³å‡ã®ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚µã‚¤ã‚º
        """
        self.method = method
        self.threshold = threshold
        self.window_size = window_size
        self.fitted = False

    def fit(self, X):
        """è¨“ç·´ãƒ‡ãƒ¼ã‚¿ã§çµ±è¨ˆé‡ã‚’å­¦ç¿’"""
        if self.method == 'zscore':
            self.mean_ = np.mean(X, axis=0)
            self.std_ = np.std(X, axis=0)
        elif self.method == 'iqr':
            self.q1_ = np.percentile(X, 25, axis=0)
            self.q3_ = np.percentile(X, 75, axis=0)
            self.iqr_ = self.q3_ - self.q1_
        elif self.method == 'mahalanobis':
            self.mean_ = np.mean(X, axis=0)
            self.cov_ = np.cov(X.T)
            self.cov_inv_ = np.linalg.inv(self.cov_)

        self.fitted = True
        return self

    def predict(self, X):
        """ç•°å¸¸ã‚¹ã‚³ã‚¢ã®è¨ˆç®—ã¨ç•°å¸¸åˆ¤å®š"""
        if not self.fitted and self.method not in ['moving_avg', 'seasonal']:
            raise ValueError("ãƒ¢ãƒ‡ãƒ«ãŒæœªå­¦ç¿’ã§ã™ã€‚fit()ã‚’å…ˆã«å®Ÿè¡Œã—ã¦ãã ã•ã„ã€‚")

        if self.method == 'zscore':
            scores = np.abs((X - self.mean_) / self.std_)
            anomalies = np.any(scores > self.threshold, axis=1)

        elif self.method == 'iqr':
            lower = self.q1_ - 1.5 * self.iqr_
            upper = self.q3_ + 1.5 * self.iqr_
            anomalies = np.any((X < lower) | (X > upper), axis=1)
            scores = np.max(np.abs(X - self.mean_) / self.std_, axis=1)

        elif self.method == 'mahalanobis':
            from scipy.spatial.distance import mahalanobis
            scores = np.array([mahalanobis(x, self.mean_, self.cov_inv_) for x in X])
            anomalies = scores > self.threshold

        elif self.method == 'moving_avg':
            # 1æ¬¡å…ƒæ™‚ç³»åˆ—ã®ã¿å¯¾å¿œ
            moving_avg = np.convolve(X.flatten(), np.ones(self.window_size)/self.window_size, mode='same')
            moving_std = np.array([X.flatten()[max(0, i-self.window_size//2):min(len(X), i+self.window_size//2)].std()
                                   for i in range(len(X))])
            scores = np.abs(X.flatten() - moving_avg)
            anomalies = scores > self.threshold * moving_std

        elif self.method == 'seasonal':
            # 1æ¬¡å…ƒæ™‚ç³»åˆ—ã®ã¿å¯¾å¿œ
            result = seasonal_decompose(X.flatten(), model='additive', period=self.window_size, extrapolate_trend='freq')
            scores = np.abs(result.resid)
            threshold_val = self.threshold * np.nanstd(result.resid)
            anomalies = scores > threshold_val

        return anomalies.astype(int), scores

    def fit_predict(self, X):
        """å­¦ç¿’ã¨äºˆæ¸¬ã‚’ä¸€åº¦ã«å®Ÿè¡Œ"""
        self.fit(X)
        return self.predict(X)

# ãƒ‡ãƒ¢ãƒ³ã‚¹ãƒˆãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
np.random.seed(42)

# ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆç”Ÿæˆ
n_samples = 300
n_features = 2
X_normal = np.random.multivariate_normal([0, 0], [[1, 0.5], [0.5, 1]], size=n_samples)
X_outliers = np.array([[5, 5], [-5, -5], [5, -5], [-5, 5]])
X = np.vstack([X_normal, X_outliers])
y_true = np.array([0]*n_samples + [1]*len(X_outliers))

# å„æ‰‹æ³•ã§ç•°å¸¸æ¤œçŸ¥
methods = ['zscore', 'iqr', 'mahalanobis']
fig, axes = plt.subplots(1, 3, figsize=(16, 5))

for i, method in enumerate(methods):
    detector = StatisticalAnomalyDetector(method=method, threshold=3.0)
    detector.fit(X_normal)  # æ­£å¸¸ãƒ‡ãƒ¼ã‚¿ã®ã¿ã§å­¦ç¿’
    y_pred, scores = detector.predict(X)

    # å¯è¦–åŒ–
    axes[i].scatter(X[y_pred==0, 0], X[y_pred==0, 1],
                    alpha=0.6, s=50, c='blue', label='æ­£å¸¸', edgecolors='black')
    axes[i].scatter(X[y_pred==1, 0], X[y_pred==1, 1],
                    c='red', s=150, marker='X', label='ç•°å¸¸', zorder=5, edgecolors='black', linewidths=2)
    axes[i].set_xlabel('ç‰¹å¾´é‡ 1', fontsize=12)
    axes[i].set_ylabel('ç‰¹å¾´é‡ 2', fontsize=12)
    axes[i].set_title(f'{method.upper()}æ³•', fontsize=14, fontweight='bold')
    axes[i].legend(fontsize=10)
    axes[i].grid(True, alpha=0.3)

    # è©•ä¾¡
    from sklearn.metrics import precision_score, recall_score, f1_score
    precision = precision_score(y_true, y_pred)
    recall = recall_score(y_true, y_pred)
    f1 = f1_score(y_true, y_pred)
    print(f"=== {method.upper()}æ³• ===")
    print(f"Precision: {precision:.3f}, Recall: {recall:.3f}, F1: {f1:.3f}\n")

plt.tight_layout()
plt.show()
</code></pre>

<blockquote>
<p><strong>é‡è¦</strong>: å®Ÿå‹™ã§ã¯ã€è¤‡æ•°ã®çµ±è¨ˆçš„æ‰‹æ³•ã‚’çµ„ã¿åˆã‚ã›ãŸã‚¢ãƒ³ã‚µãƒ³ãƒ–ãƒ«ãŒåŠ¹æœçš„ã§ã™ã€‚å„æ‰‹æ³•ã®å¼·ã¿ã‚’æ´»ã‹ã™ã“ã¨ã§ã€ãƒ­ãƒã‚¹ãƒˆãªç•°å¸¸æ¤œçŸ¥ãŒå¯èƒ½ã«ãªã‚Šã¾ã™ã€‚</p>
</blockquote>

<hr>

<h2>æœ¬ç« ã®ã¾ã¨ã‚</h2>

<h3>å­¦ã‚“ã ã“ã¨</h3>

<ol>
<li><p><strong>çµ±è¨ˆçš„å¤–ã‚Œå€¤æ¤œå‡º</strong></p>
<ul>
<li>Z-score: ç°¡å˜ã§é«˜é€Ÿã€æ­£è¦åˆ†å¸ƒã‚’ä»®å®š</li>
<li>IQR: ãƒ­ãƒã‚¹ãƒˆã€åˆ†å¸ƒã«ä¾å­˜ã—ãªã„</li>
</ul></li>

<li><p><strong>ç¢ºç‡åˆ†å¸ƒãƒ™ãƒ¼ã‚¹</strong></p>
<ul>
<li>Mahalanobisè·é›¢: å¤šå¤‰é‡ã€å…±åˆ†æ•£è€ƒæ…®</li>
<li>å¤šå¤‰é‡ã‚¬ã‚¦ã‚¹åˆ†å¸ƒ: ç¢ºç‡å¯†åº¦ã«ã‚ˆã‚‹åˆ¤å®š</li>
</ul></li>

<li><p><strong>çµ±è¨ˆçš„ä»®èª¬æ¤œå®š</strong></p>
<ul>
<li>Grubbs' Test: å˜ä¸€å¤–ã‚Œå€¤ã®å³å¯†ãªæ¤œå®š</li>
<li>ESD Test: è¤‡æ•°å¤–ã‚Œå€¤ã®é€æ¬¡æ¤œå‡º</li>
</ul></li>

<li><p><strong>æ™‚ç³»åˆ—ç•°å¸¸æ¤œçŸ¥</strong></p>
<ul>
<li>ç§»å‹•å¹³å‡: ãƒˆãƒ¬ãƒ³ãƒ‰è¿½å¾“ã¨æ®‹å·®æ¤œå‡º</li>
<li>å­£ç¯€æ€§åˆ†è§£: å­£ç¯€æ€§ãƒ»ãƒˆãƒ¬ãƒ³ãƒ‰é™¤å»</li>
</ul></li>

<li><p><strong>å®Ÿè£…ã¨å¿œç”¨</strong></p>
<ul>
<li>çµ±åˆãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³: è¤‡æ•°æ‰‹æ³•ã®çµ±ä¸€ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹</li>
<li>å®Ÿå‹™é©ç”¨: ãƒ‰ãƒ¡ã‚¤ãƒ³ã«å¿œã˜ãŸæ‰‹æ³•é¸æŠ</li>
</ul></li>
</ol>

<h3>çµ±è¨ˆçš„æ‰‹æ³•ã®é¸æŠåŸºæº–</h3>

<table>
<thead>
<tr>
<th>æ‰‹æ³•</th>
<th>ãƒ‡ãƒ¼ã‚¿ã‚¿ã‚¤ãƒ—</th>
<th>åˆ©ç‚¹</th>
<th>æ¬ ç‚¹</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Z-score</strong></td>
<td>å˜å¤‰é‡ã€æ­£è¦åˆ†å¸ƒ</td>
<td>ã‚·ãƒ³ãƒ—ãƒ«ã€é«˜é€Ÿ</td>
<td>å¤–ã‚Œå€¤ã®å½±éŸ¿å¤§</td>
</tr>
<tr>
<td><strong>IQR</strong></td>
<td>å˜å¤‰é‡ã€ä»»æ„åˆ†å¸ƒ</td>
<td>ãƒ­ãƒã‚¹ãƒˆ</td>
<td>å¤šå¤‰é‡ã«ä¸å‘ã</td>
</tr>
<tr>
<td><strong>Mahalanobis</strong></td>
<td>å¤šå¤‰é‡ã€ç›¸é–¢ã‚ã‚Š</td>
<td>å…±åˆ†æ•£è€ƒæ…®</td>
<td>è¨ˆç®—ã‚³ã‚¹ãƒˆé«˜</td>
</tr>
<tr>
<td><strong>Grubbs/ESD</strong></td>
<td>å˜å¤‰é‡ã€æ­£è¦åˆ†å¸ƒ</td>
<td>çµ±è¨ˆçš„æ ¹æ‹ æ˜ç¢º</td>
<td>é€æ¬¡çš„å‡¦ç†</td>
</tr>
<tr>
<td><strong>ç§»å‹•å¹³å‡</strong></td>
<td>æ™‚ç³»åˆ—</td>
<td>ãƒˆãƒ¬ãƒ³ãƒ‰è¿½å¾“</td>
<td>ãƒ©ã‚°ã‚ã‚Š</td>
</tr>
<tr>
<td><strong>å­£ç¯€æ€§åˆ†è§£</strong></td>
<td>å­£ç¯€æ€§æ™‚ç³»åˆ—</td>
<td>å­£ç¯€æ€§é™¤å»</td>
<td>å‘¨æœŸè¦äº‹å‰çŸ¥è­˜</td>
</tr>
</tbody>
</table>

<h3>æ¬¡ã®ç« ã¸</h3>

<p>ç¬¬3ç« ã§ã¯ã€<strong>æ©Ÿæ¢°å­¦ç¿’ã«ã‚ˆã‚‹ç•°å¸¸æ¤œçŸ¥</strong>ã‚’å­¦ã³ã¾ã™ï¼š</p>
<ul>
<li>Isolation Forest, LOF</li>
<li>One-Class SVM</li>
<li>ã‚¯ãƒ©ã‚¹ã‚¿ãƒªãƒ³ã‚°ãƒ™ãƒ¼ã‚¹æ‰‹æ³•</li>
<li>ã‚¢ãƒ³ã‚µãƒ³ãƒ–ãƒ«æ‰‹æ³•</li>
</ul>

<hr>

<h2>æ¼”ç¿’å•é¡Œ</h2>

<h3>å•é¡Œ1ï¼ˆé›£æ˜“åº¦ï¼šeasyï¼‰</h3>
<p>Z-scoreã¨IQRæ³•ã®é•ã„ã‚’èª¬æ˜ã—ã€ãã‚Œãã‚ŒãŒã©ã®ã‚ˆã†ãªå ´é¢ã§é©ã—ã¦ã„ã‚‹ã‹è¿°ã¹ã¦ãã ã•ã„ã€‚</p>

<details>
<summary>è§£ç­”ä¾‹</summary>

<p><strong>è§£ç­”</strong>ï¼š</p>

<p><strong>Z-score</strong>:</p>
<ul>
<li>è¨ˆç®—å¼: $(x - \mu) / \sigma$</li>
<li>ä»®å®š: ãƒ‡ãƒ¼ã‚¿ãŒæ­£è¦åˆ†å¸ƒã«å¾“ã†</li>
<li>é–¾å€¤: é€šå¸¸ $|Z| > 3$</li>
<li>ç‰¹å¾´: å¹³å‡ã¨æ¨™æº–åå·®ã‚’ä½¿ç”¨ã™ã‚‹ãŸã‚ã€å¤–ã‚Œå€¤ã®å½±éŸ¿ã‚’å—ã‘ã‚„ã™ã„</li>
</ul>

<p><strong>IQRæ³•</strong>:</p>
<ul>
<li>è¨ˆç®—å¼: $IQR = Q3 - Q1$ã€ç•°å¸¸ã¯ $x < Q1 - 1.5 \times IQR$ ã¾ãŸã¯ $x > Q3 + 1.5 \times IQR$</li>
<li>ä»®å®š: åˆ†å¸ƒã«ä¾å­˜ã—ãªã„ï¼ˆãƒãƒ³ãƒ‘ãƒ©ãƒ¡ãƒˆãƒªãƒƒã‚¯ï¼‰</li>
<li>ç‰¹å¾´: å››åˆ†ä½æ•°ã‚’ä½¿ç”¨ã™ã‚‹ãŸã‚ã€å¤–ã‚Œå€¤ã«å¯¾ã—ã¦ãƒ­ãƒã‚¹ãƒˆ</li>
</ul>

<p><strong>é©ç”¨å ´é¢</strong>:</p>

<table>
<thead>
<tr>
<th>çŠ¶æ³</th>
<th>æ¨å¥¨æ‰‹æ³•</th>
<th>ç†ç”±</th>
</tr>
</thead>
<tbody>
<tr>
<td>æ­£è¦åˆ†å¸ƒã«è¿‘ã„ãƒ‡ãƒ¼ã‚¿</td>
<td>Z-score</td>
<td>çµ±è¨ˆçš„æ ¹æ‹ ãŒæ˜ç¢º</td>
</tr>
<tr>
<td>åˆ†å¸ƒãŒæœªçŸ¥ãƒ»éæ­£è¦</td>
<td>IQR</td>
<td>åˆ†å¸ƒã®ä»®å®šä¸è¦</td>
</tr>
<tr>
<td>å¤–ã‚Œå€¤ãŒæ—¢ã«æ··å…¥</td>
<td>IQR</td>
<td>ãƒ­ãƒã‚¹ãƒˆæ€§ãŒé«˜ã„</td>
</tr>
<tr>
<td>é«˜é€Ÿå‡¦ç†ãŒå¿…è¦</td>
<td>Z-score</td>
<td>è¨ˆç®—ãŒå˜ç´”</td>
</tr>
</tbody>
</table>

</details>

<h3>å•é¡Œ2ï¼ˆé›£æ˜“åº¦ï¼šmediumï¼‰</h3>
<p>Mahalanobisè·é›¢ãŒãƒ¦ãƒ¼ã‚¯ãƒªãƒƒãƒ‰è·é›¢ã‚ˆã‚Šå„ªã‚Œã¦ã„ã‚‹ç‚¹ã‚’ã€ç›¸é–¢ã®ã‚ã‚‹ãƒ‡ãƒ¼ã‚¿ã®ä¾‹ã‚’ç”¨ã„ã¦èª¬æ˜ã—ã¦ãã ã•ã„ã€‚ç°¡å˜ãªPythonã‚³ãƒ¼ãƒ‰ã‚’å«ã‚ã¦ãã ã•ã„ã€‚</p>

<details>
<summary>è§£ç­”ä¾‹</summary>

<p><strong>è§£ç­”</strong>ï¼š</p>

<p><strong>Mahalanobisè·é›¢ã®å„ªä½æ€§</strong>:</p>

<ol>
<li><strong>å…±åˆ†æ•£ã‚’è€ƒæ…®</strong>: å¤‰æ•°é–“ã®ç›¸é–¢ã‚’åæ˜ </li>
<li><strong>ã‚¹ã‚±ãƒ¼ãƒ«ä¸å¤‰</strong>: ç‰¹å¾´é‡ã®ã‚¹ã‚±ãƒ¼ãƒ«ã«ä¾å­˜ã—ãªã„</li>
<li><strong>æ¥•å††çŠ¶ã®å¢ƒç•Œ</strong>: ãƒ‡ãƒ¼ã‚¿ã®åˆ†å¸ƒå½¢çŠ¶ã«é©å¿œ</li>
</ol>

<p><strong>å®Ÿè£…ä¾‹</strong>:</p>

<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
from scipy.spatial.distance import euclidean, mahalanobis

# ç›¸é–¢ã®å¼·ã„ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆ
np.random.seed(42)
mean = [0, 0]
cov = [[1, 0.9], [0.9, 1]]  # ç›¸é–¢ä¿‚æ•°0.9
data = np.random.multivariate_normal(mean, cov, size=300)

# ãƒ†ã‚¹ãƒˆãƒã‚¤ãƒ³ãƒˆï¼ˆãƒ‡ãƒ¼ã‚¿åˆ†å¸ƒã®å¤–ï¼‰
test_point1 = np.array([2, 2])  # ç›¸é–¢æ–¹å‘ã«æ²¿ã£ãŸç‚¹
test_point2 = np.array([2, -2])  # ç›¸é–¢æ–¹å‘ã«å‚ç›´ãªç‚¹

# è·é›¢è¨ˆç®—
mean_vec = data.mean(axis=0)
cov_matrix = np.cov(data.T)
cov_inv = np.linalg.inv(cov_matrix)

euclidean_dist1 = euclidean(test_point1, mean_vec)
euclidean_dist2 = euclidean(test_point2, mean_vec)
mahal_dist1 = mahalanobis(test_point1, mean_vec, cov_inv)
mahal_dist2 = mahalanobis(test_point2, mean_vec, cov_inv)

# å¯è¦–åŒ–
plt.figure(figsize=(10, 8))
plt.scatter(data[:, 0], data[:, 1], alpha=0.5, s=30, c='blue', label='ãƒ‡ãƒ¼ã‚¿')
plt.scatter(*test_point1, c='red', s=200, marker='X', label='ãƒã‚¤ãƒ³ãƒˆ1(ç›¸é–¢æ–¹å‘)',
            edgecolors='black', linewidths=2, zorder=5)
plt.scatter(*test_point2, c='orange', s=200, marker='X', label='ãƒã‚¤ãƒ³ãƒˆ2(å‚ç›´æ–¹å‘)',
            edgecolors='black', linewidths=2, zorder=5)
plt.scatter(*mean_vec, c='green', s=200, marker='o', label='ä¸­å¿ƒ',
            edgecolors='black', linewidths=2, zorder=5)

# ä¿¡é ¼æ¥•å††
from matplotlib.patches import Ellipse
eigenvalues, eigenvectors = np.linalg.eig(cov_matrix)
angle = np.degrees(np.arctan2(eigenvectors[1, 0], eigenvectors[0, 0]))
width, height = 2 * 3 * np.sqrt(eigenvalues)
ellipse = Ellipse(mean_vec, width, height, angle=angle,
                  edgecolor='green', facecolor='none', linewidth=2, linestyle='--')
plt.gca().add_patch(ellipse)

plt.xlabel('ç‰¹å¾´é‡ 1', fontsize=12)
plt.ylabel('ç‰¹å¾´é‡ 2', fontsize=12)
plt.title('ãƒ¦ãƒ¼ã‚¯ãƒªãƒƒãƒ‰è·é›¢ vs Mahalanobisè·é›¢', fontsize=14, fontweight='bold')
plt.legend(fontsize=10)
plt.grid(True, alpha=0.3)
plt.axis('equal')
plt.tight_layout()
plt.show()

print("=== è·é›¢ã®æ¯”è¼ƒ ===")
print(f"ãƒã‚¤ãƒ³ãƒˆ1ï¼ˆç›¸é–¢æ–¹å‘ï¼‰:")
print(f"  ãƒ¦ãƒ¼ã‚¯ãƒªãƒƒãƒ‰è·é›¢: {euclidean_dist1:.3f}")
print(f"  Mahalanobisè·é›¢: {mahal_dist1:.3f}")
print(f"\nãƒã‚¤ãƒ³ãƒˆ2ï¼ˆå‚ç›´æ–¹å‘ï¼‰:")
print(f"  ãƒ¦ãƒ¼ã‚¯ãƒªãƒƒãƒ‰è·é›¢: {euclidean_dist2:.3f}")
print(f"  Mahalanobisè·é›¢: {mahal_dist2:.3f}")
print(f"\nâ†’ ãƒ¦ãƒ¼ã‚¯ãƒªãƒƒãƒ‰è·é›¢ã¯ç­‰ã—ã„ãŒã€Mahalanobisè·é›¢ã¯ãƒã‚¤ãƒ³ãƒˆ2ãŒé ã„")
print("  ï¼ˆãƒ‡ãƒ¼ã‚¿ã®åˆ†å¸ƒå½¢çŠ¶ã‚’æ­£ã—ãåæ˜ ï¼‰")
</code></pre>

<p><strong>çµè«–</strong>:</p>
<ul>
<li>ãƒ¦ãƒ¼ã‚¯ãƒªãƒƒãƒ‰è·é›¢ã¯ä¸¡ç‚¹ã¨ã‚‚ç­‰è·é›¢ã¨åˆ¤å®šï¼ˆ$\sqrt{8} \approx 2.83$ï¼‰</li>
<li>Mahalanobisè·é›¢ã¯ãƒã‚¤ãƒ³ãƒˆ2ã‚’ç•°å¸¸ã¨æ­£ã—ãåˆ¤å®š</li>
<li>ç›¸é–¢ã‚’è€ƒæ…®ã™ã‚‹ã“ã¨ã§ã€ãƒ‡ãƒ¼ã‚¿ã®çœŸã®åˆ†å¸ƒã‚’æ‰ãˆã‚‹</li>
</ul>

</details>

<h3>å•é¡Œ3ï¼ˆé›£æ˜“åº¦ï¼šmediumï¼‰</h3>
<p>Grubbs' Testã¨Generalized ESD Testã®é•ã„ã‚’èª¬æ˜ã—ã€è¤‡æ•°ã®å¤–ã‚Œå€¤ãŒã‚ã‚‹å ´åˆã«ã©ã¡ã‚‰ãŒé©åˆ‡ã‹è¿°ã¹ã¦ãã ã•ã„ã€‚</p>

<details>
<summary>è§£ç­”ä¾‹</summary>

<p><strong>è§£ç­”</strong>ï¼š</p>

<p><strong>Grubbs' Test</strong>:</p>
<ul>
<li><strong>ç›®çš„</strong>: å˜ä¸€ã®å¤–ã‚Œå€¤ã‚’æ¤œå‡º</li>
<li><strong>æ‰‹é †</strong>: æœ€ã‚‚æ¥µç«¯ãªå€¤1ã¤ã‚’æ¤œå®š</li>
<li><strong>å•é¡Œç‚¹</strong>: è¤‡æ•°å¤–ã‚Œå€¤ãŒã‚ã‚‹å ´åˆã€ãƒã‚¹ã‚­ãƒ³ã‚°åŠ¹æœã«ã‚ˆã‚Šæ¤œå‡ºå¤±æ•—</li>
<li><strong>ãƒã‚¹ã‚­ãƒ³ã‚°åŠ¹æœ</strong>: è¤‡æ•°ã®å¤–ã‚Œå€¤ãŒäº’ã„ã«å¹³å‡ãƒ»æ¨™æº–åå·®ã‚’æ­ªã‚ã€æ¤œå‡ºã‚’å¦¨ã’ã‚‹</li>
</ul>

<p><strong>Generalized ESD Test</strong>:</p>
<ul>
<li><strong>ç›®çš„</strong>: è¤‡æ•°ã®å¤–ã‚Œå€¤ã‚’æ¤œå‡ºï¼ˆæœ€å¤§kå€‹ã¾ã§ï¼‰</li>
<li><strong>æ‰‹é †</strong>: é€æ¬¡çš„ã«å¤–ã‚Œå€¤ã‚’é™¤å»ã—ãªãŒã‚‰æ¤œå®šã‚’ç¹°ã‚Šè¿”ã™</li>
<li><strong>åˆ©ç‚¹</strong>: ãƒã‚¹ã‚­ãƒ³ã‚°åŠ¹æœã‚’å›é¿</li>
<li><strong>æ³¨æ„ç‚¹</strong>: æœ€å¤§å¤–ã‚Œå€¤æ•°kã‚’äº‹å‰ã«æŒ‡å®šå¿…è¦</li>
</ul>

<p><strong>æ¨å¥¨</strong>:</p>

<table>
<thead>
<tr>
<th>çŠ¶æ³</th>
<th>æ¨å¥¨æ‰‹æ³•</th>
<th>ç†ç”±</th>
</tr>
</thead>
<tbody>
<tr>
<td>å¤–ã‚Œå€¤ãŒ1å€‹ã®ã¿ç¢ºå®Ÿ</td>
<td>Grubbs' Test</td>
<td>ã‚·ãƒ³ãƒ—ãƒ«ã§æ˜ç¢º</td>
</tr>
<tr>
<td>è¤‡æ•°å¤–ã‚Œå€¤ã®å¯èƒ½æ€§</td>
<td>Generalized ESD</td>
<td>ãƒã‚¹ã‚­ãƒ³ã‚°å›é¿</td>
</tr>
<tr>
<td>å¤–ã‚Œå€¤æ•°ãŒæœªçŸ¥</td>
<td>Generalized ESD</td>
<td>ä¿å®ˆçš„ã«kè¨­å®š</td>
</tr>
</tbody>
</table>

<p><strong>å…·ä½“ä¾‹</strong>:</p>
<p>ãƒ‡ãƒ¼ã‚¿: [50, 51, 49, 52, 48, 100, 105]ï¼ˆå¤–ã‚Œå€¤2å€‹ï¼š100, 105ï¼‰</p>
<ul>
<li>Grubbs' Test: 105ã®ã¿æ¤œå‡ºï¼ˆ100ã¯å¹³å‡ãŒæ­ªã‚“ã§æ¤œå‡ºå¤±æ•—ï¼‰</li>
<li>ESD Test: 105ã‚’æ¤œå‡ºãƒ»é™¤å» â†’ 100ã‚’æ¤œå‡ºï¼ˆé€æ¬¡çš„å‡¦ç†ã§æˆåŠŸï¼‰</li>
</ul>

</details>

<h3>å•é¡Œ4ï¼ˆé›£æ˜“åº¦ï¼šhardï¼‰</h3>
<p>å­£ç¯€æ€§åˆ†è§£ï¼ˆSTLï¼‰ã‚’ç”¨ã„ãŸæ™‚ç³»åˆ—ç•°å¸¸æ¤œçŸ¥ã«ãŠã„ã¦ã€å‘¨æœŸãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®è¨­å®šãŒé‡è¦ãªç†ç”±ã‚’èª¬æ˜ã—ã€èª¤ã£ãŸå‘¨æœŸã‚’è¨­å®šã—ãŸå ´åˆã®å•é¡Œç‚¹ã‚’ç¤ºã—ã¦ãã ã•ã„ã€‚å®Ÿè£…ä¾‹ã‚’å«ã‚ã¦ãã ã•ã„ã€‚</p>

<details>
<summary>è§£ç­”ä¾‹</summary>

<p><strong>è§£ç­”</strong>ï¼š</p>

<p><strong>å‘¨æœŸãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®é‡è¦æ€§</strong>:</p>

<ol>
<li><strong>æ­£ç¢ºãªå­£ç¯€æ€§é™¤å»</strong>: æ­£ã—ã„å‘¨æœŸã§åˆ†è§£ã—ãªã„ã¨ã€å­£ç¯€æˆåˆ†ãŒæ®‹å·®ã«æ··å…¥</li>
<li><strong>ç•°å¸¸æ¤œå‡ºç²¾åº¦</strong>: æ®‹å·®ã«å­£ç¯€æ€§ãŒæ®‹ã‚‹ã¨ã€èª¤æ¤œå‡ºï¼ˆFPï¼‰ãŒå¢—åŠ </li>
<li><strong>ãƒˆãƒ¬ãƒ³ãƒ‰æ¨å®š</strong>: å‘¨æœŸãŒä¸é©åˆ‡ã ã¨ã€ãƒˆãƒ¬ãƒ³ãƒ‰æˆåˆ†ã‚‚æ­ªã‚€</li>
</ol>

<p><strong>èª¤ã£ãŸå‘¨æœŸè¨­å®šã®å•é¡Œ</strong>:</p>
<ul>
<li><strong>éå°è¨­å®š</strong>ï¼ˆçœŸã®å‘¨æœŸã‚ˆã‚ŠçŸ­ã„ï¼‰: å­£ç¯€æ€§ã‚’éå‰°ã«é™¤å»ã€çœŸã®ãƒˆãƒ¬ãƒ³ãƒ‰ã‚’å­£ç¯€æ€§ã¨èª¤èª</li>
<li><strong>éå¤§è¨­å®š</strong>ï¼ˆçœŸã®å‘¨æœŸã‚ˆã‚Šé•·ã„ï¼‰: å­£ç¯€æ€§ãŒæ®‹å·®ã«æ®‹ã‚‹ã€æ­£å¸¸ãªå­£ç¯€å¤‰å‹•ã‚’ç•°å¸¸åˆ¤å®š</li>
</ul>

<p><strong>å®Ÿè£…ä¾‹</strong>:</p>

<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
from statsmodels.tsa.seasonal import seasonal_decompose

# çœŸã®å‘¨æœŸ30ã®æ™‚ç³»åˆ—ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆ
np.random.seed(42)
n_samples = 300
time = np.arange(n_samples)
trend = 0.05 * time
seasonal = 10 * np.sin(2 * np.pi * time / 30)  # å‘¨æœŸ30
noise = np.random.normal(0, 1, n_samples)
data = trend + seasonal + noise

# ç•°å¸¸ã‚’è¿½åŠ 
data[100] += 25
data[200] -= 25

# 3ç¨®é¡ã®å‘¨æœŸè¨­å®šã§åˆ†è§£
periods = [15, 30, 60]  # éå°ã€æ­£ç¢ºã€éå¤§
fig, axes = plt.subplots(3, 3, figsize=(16, 12))

for i, period in enumerate(periods):
    result = seasonal_decompose(data, model='additive', period=period, extrapolate_trend='freq')

    # å…ƒãƒ‡ãƒ¼ã‚¿
    axes[i, 0].plot(time, data, linewidth=1, alpha=0.7)
    axes[i, 0].set_ylabel(f'å‘¨æœŸ={period}\nå…ƒãƒ‡ãƒ¼ã‚¿', fontsize=10)
    axes[i, 0].grid(True, alpha=0.3)

    # å­£ç¯€æ€§
    axes[i, 1].plot(time, result.seasonal, linewidth=1, color='orange')
    axes[i, 1].set_ylabel('å­£ç¯€æ€§', fontsize=10)
    axes[i, 1].grid(True, alpha=0.3)

    # æ®‹å·®ã¨ç•°å¸¸æ¤œå‡º
    residual = result.resid
    threshold = 3 * np.nanstd(residual)
    anomalies = np.abs(residual) > threshold

    axes[i, 2].plot(time, residual, linewidth=1, alpha=0.7)
    axes[i, 2].axhline(y=threshold, color='red', linestyle='--', linewidth=2)
    axes[i, 2].axhline(y=-threshold, color='red', linestyle='--', linewidth=2)
    axes[i, 2].scatter(time[anomalies], residual[anomalies],
                       c='red', s=50, marker='X', zorder=5)
    axes[i, 2].set_ylabel('æ®‹å·®', fontsize=10)
    axes[i, 2].grid(True, alpha=0.3)

    # è©•ä¾¡
    print(f"=== å‘¨æœŸ={period} ===")
    print(f"ç•°å¸¸æ¤œå‡ºæ•°: {anomalies.sum()}å€‹")
    print(f"ç•°å¸¸ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹: {np.where(anomalies)[0]}\n")

axes[0, 0].set_title('å…ƒãƒ‡ãƒ¼ã‚¿', fontsize=12, fontweight='bold')
axes[0, 1].set_title('å­£ç¯€æ€§æˆåˆ†', fontsize=12, fontweight='bold')
axes[0, 2].set_title('æ®‹å·®ï¼ˆç•°å¸¸æ¤œå‡ºï¼‰', fontsize=12, fontweight='bold')
axes[2, 0].set_xlabel('æ™‚åˆ»', fontsize=11)
axes[2, 1].set_xlabel('æ™‚åˆ»', fontsize=11)
axes[2, 2].set_xlabel('æ™‚åˆ»', fontsize=11)

plt.tight_layout()
plt.show()

print("=== çµè«– ===")
print("å‘¨æœŸ=15ï¼ˆéå°ï¼‰: å­£ç¯€æ€§ãŒè¤‡é›‘åŒ–ã€èª¤æ¤œå‡ºãŒå¢—åŠ ")
print("å‘¨æœŸ=30ï¼ˆæ­£ç¢ºï¼‰: é©åˆ‡ãªåˆ†è§£ã€ç•°å¸¸ã‚’æ­£ç¢ºã«æ¤œå‡º")
print("å‘¨æœŸ=60ï¼ˆéå¤§ï¼‰: å­£ç¯€æ€§ãŒæ®‹å·®ã«æ®‹ã‚‹ã€æ­£å¸¸å¤‰å‹•ã‚’èª¤æ¤œå‡º")
</code></pre>

<p><strong>çµè«–</strong>:</p>
<ul>
<li>æ­£ç¢ºãªå‘¨æœŸè¨­å®šãŒç•°å¸¸æ¤œçŸ¥ã®ç²¾åº¦ã‚’æ±ºå®š</li>
<li>å‘¨æœŸã¯äº‹å‰çŸ¥è­˜ï¼ˆãƒ“ã‚¸ãƒã‚¹ã‚µã‚¤ã‚¯ãƒ«ã€å­£ç¯€ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼‰ã¾ãŸã¯ACF/PACFåˆ†æã§æ±ºå®š</li>
<li>ä¸æ˜ãªå ´åˆã¯ã€è¤‡æ•°å‘¨æœŸã‚’è©¦ã—ã¦æ®‹å·®ã®åˆ†æ•£ãŒæœ€å°ã«ãªã‚‹å‘¨æœŸã‚’é¸æŠ</li>
</ul>

</details>

<h3>å•é¡Œ5ï¼ˆé›£æ˜“åº¦ï¼šhardï¼‰</h3>
<p>çµ±è¨ˆçš„ç•°å¸¸æ¤œçŸ¥ã®3ã¤ã®æ‰‹æ³•ï¼ˆZ-score, IQR, Mahalanobisè·é›¢ï¼‰ã‚’çµ„ã¿åˆã‚ã›ãŸã‚¢ãƒ³ã‚µãƒ³ãƒ–ãƒ«ç•°å¸¸æ¤œçŸ¥ã‚·ã‚¹ãƒ†ãƒ ã‚’è¨­è¨ˆã—ã¦ãã ã•ã„ã€‚å¤šæ•°æ±ºã¾ãŸã¯é‡ã¿ä»˜ã‘æŠ•ç¥¨ã‚’å®Ÿè£…ã—ã€å˜ä¸€æ‰‹æ³•ã‚ˆã‚Šæ€§èƒ½ãŒå‘ä¸Šã™ã‚‹ã“ã¨ã‚’ç¤ºã—ã¦ãã ã•ã„ã€‚</p>

<details>
<summary>è§£ç­”ä¾‹</summary>

<p><strong>è§£ç­”</strong>ï¼š</p>

<p><strong>ã‚¢ãƒ³ã‚µãƒ³ãƒ–ãƒ«ç•°å¸¸æ¤œçŸ¥ã®è¨­è¨ˆ</strong>:</p>

<ol>
<li><strong>åŸºæœ¬æ‰‹æ³•ã®çµ„ã¿åˆã‚ã›</strong>: ç•°ãªã‚‹åŸç†ã®æ‰‹æ³•ã‚’çµ±åˆï¼ˆZ-score, IQR, Mahalanobisï¼‰</li>
<li><strong>æŠ•ç¥¨æˆ¦ç•¥</strong>: å¤šæ•°æ±ºã¾ãŸã¯ã‚½ãƒ•ãƒˆæŠ•ç¥¨ï¼ˆã‚¹ã‚³ã‚¢ã®å¹³å‡ï¼‰</li>
<li><strong>é‡ã¿ä»˜ã‘</strong>: å„æ‰‹æ³•ã®ä¿¡é ¼æ€§ã«å¿œã˜ãŸé‡ã¿</li>
</ol>

<p><strong>å®Ÿè£…</strong>:</p>

<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
from scipy import stats
from scipy.spatial.distance import mahalanobis
from sklearn.metrics import precision_score, recall_score, f1_score, roc_auc_score

class EnsembleAnomalyDetector:
    """ã‚¢ãƒ³ã‚µãƒ³ãƒ–ãƒ«ç•°å¸¸æ¤œçŸ¥"""

    def __init__(self, voting='hard', weights=None):
        """
        Parameters:
        -----------
        voting : str
            'hard' (å¤šæ•°æ±º) ã¾ãŸã¯ 'soft' (ã‚¹ã‚³ã‚¢å¹³å‡)
        weights : list or None
            å„æ‰‹æ³•ã®é‡ã¿ [zscore, iqr, mahalanobis]
        """
        self.voting = voting
        self.weights = weights if weights is not None else [1/3, 1/3, 1/3]

    def fit(self, X):
        """çµ±è¨ˆé‡ã®å­¦ç¿’"""
        # Z-scoreç”¨
        self.mean_ = np.mean(X, axis=0)
        self.std_ = np.std(X, axis=0)

        # IQRç”¨
        self.q1_ = np.percentile(X, 25, axis=0)
        self.q3_ = np.percentile(X, 75, axis=0)
        self.iqr_ = self.q3_ - self.q1_

        # Mahalanobisç”¨
        self.cov_ = np.cov(X.T)
        self.cov_inv_ = np.linalg.inv(self.cov_)

        return self

    def predict(self, X, threshold_zscore=3, threshold_mahal=3):
        """ã‚¢ãƒ³ã‚µãƒ³ãƒ–ãƒ«äºˆæ¸¬"""
        n_samples = len(X)

        # 1. Z-score
        z_scores = np.abs((X - self.mean_) / self.std_)
        z_anomalies = np.any(z_scores > threshold_zscore, axis=1).astype(int)
        z_scores_norm = np.max(z_scores, axis=1) / 5  # æ­£è¦åŒ–

        # 2. IQR
        lower = self.q1_ - 1.5 * self.iqr_
        upper = self.q3_ + 1.5 * self.iqr_
        iqr_anomalies = np.any((X < lower) | (X > upper), axis=1).astype(int)
        iqr_scores = np.max(np.abs(X - self.mean_) / (self.iqr_ + 1e-10), axis=1)
        iqr_scores_norm = np.clip(iqr_scores / 5, 0, 1)  # æ­£è¦åŒ–

        # 3. Mahalanobisè·é›¢
        mahal_scores = np.array([mahalanobis(x, self.mean_, self.cov_inv_) for x in X])
        mahal_anomalies = (mahal_scores > threshold_mahal).astype(int)
        mahal_scores_norm = mahal_scores / 10  # æ­£è¦åŒ–

        # ã‚¢ãƒ³ã‚µãƒ³ãƒ–ãƒ«æŠ•ç¥¨
        if self.voting == 'hard':
            # å¤šæ•°æ±ºï¼ˆ2/3ä»¥ä¸ŠãŒç•°å¸¸ã¨åˆ¤å®šï¼‰
            votes = z_anomalies + iqr_anomalies + mahal_anomalies
            predictions = (votes >= 2).astype(int)
            scores = votes / 3

        elif self.voting == 'soft':
            # ã‚¹ã‚³ã‚¢ã®é‡ã¿ä»˜ã‘å¹³å‡
            scores = (self.weights[0] * z_scores_norm +
                     self.weights[1] * iqr_scores_norm +
                     self.weights[2] * mahal_scores_norm)
            predictions = (scores > 0.5).astype(int)

        return predictions, scores, {
            'zscore': z_anomalies,
            'iqr': iqr_anomalies,
            'mahalanobis': mahal_anomalies
        }

# è©•ä¾¡å®Ÿé¨“
np.random.seed(42)

# ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆ
n_normal = 300
n_anomaly = 30
X_normal = np.random.multivariate_normal([0, 0], [[1, 0.5], [0.5, 1]], size=n_normal)
X_anomaly = np.random.uniform(-5, 5, size=(n_anomaly, 2))
X_anomaly += np.array([[3, 3], [-3, -3], [3, -3], [-3, 3]]).mean(axis=0)  # ãƒã‚¤ã‚¢ã‚¹

X = np.vstack([X_normal, X_anomaly])
y_true = np.array([0]*n_normal + [1]*n_anomaly)

# ãƒ¢ãƒ‡ãƒ«è¨“ç·´ï¼ˆæ­£å¸¸ãƒ‡ãƒ¼ã‚¿ã®ã¿ï¼‰
ensemble = EnsembleAnomalyDetector(voting='soft', weights=[0.3, 0.3, 0.4])
ensemble.fit(X_normal)

# äºˆæ¸¬
y_pred_ensemble, scores_ensemble, individual_preds = ensemble.predict(X)

# å„æ‰‹æ³•ã®å€‹åˆ¥è©•ä¾¡
results = {}
for method_name, preds in individual_preds.items():
    results[method_name] = {
        'precision': precision_score(y_true, preds),
        'recall': recall_score(y_true, preds),
        'f1': f1_score(y_true, preds)
    }

# ã‚¢ãƒ³ã‚µãƒ³ãƒ–ãƒ«ã®è©•ä¾¡
results['ensemble'] = {
    'precision': precision_score(y_true, y_pred_ensemble),
    'recall': recall_score(y_true, y_pred_ensemble),
    'f1': f1_score(y_true, y_pred_ensemble)
}

# å¯è¦–åŒ–
fig, axes = plt.subplots(2, 2, figsize=(14, 12))

methods = ['zscore', 'iqr', 'mahalanobis', 'ensemble']
titles = ['Z-score', 'IQR', 'Mahalanobisè·é›¢', 'ã‚¢ãƒ³ã‚µãƒ³ãƒ–ãƒ«']
predictions_list = [individual_preds['zscore'], individual_preds['iqr'],
                    individual_preds['mahalanobis'], y_pred_ensemble]

for i, (method, title, preds) in enumerate(zip(methods, titles, predictions_list)):
    ax = axes[i // 2, i % 2]
    ax.scatter(X[preds==0, 0], X[preds==0, 1],
               alpha=0.6, s=50, c='blue', label='æ­£å¸¸', edgecolors='black')
    ax.scatter(X[preds==1, 0], X[preds==1, 1],
               c='red', s=100, marker='X', label='ç•°å¸¸', zorder=5, edgecolors='black', linewidths=2)

    # æ€§èƒ½è¡¨ç¤º
    r = results[method]
    ax.set_xlabel('ç‰¹å¾´é‡ 1', fontsize=12)
    ax.set_ylabel('ç‰¹å¾´é‡ 2', fontsize=12)
    ax.set_title(f'{title}\nF1={r["f1"]:.3f}, Precision={r["precision"]:.3f}, Recall={r["recall"]:.3f}',
                 fontsize=12, fontweight='bold')
    ax.legend(fontsize=10)
    ax.grid(True, alpha=0.3)

plt.tight_layout()
plt.show()

# çµæœã‚µãƒãƒª
print("=== æ€§èƒ½æ¯”è¼ƒ ===")
for method, metrics in results.items():
    print(f"{method.upper():15s} - Precision: {metrics['precision']:.3f}, "
          f"Recall: {metrics['recall']:.3f}, F1: {metrics['f1']:.3f}")

print("\n=== çµè«– ===")
print("ã‚¢ãƒ³ã‚µãƒ³ãƒ–ãƒ«ã¯å„æ‰‹æ³•ã®å¼·ã¿ã‚’çµ„ã¿åˆã‚ã›ã€å˜ä¸€æ‰‹æ³•ã‚ˆã‚Šå®‰å®šã—ãŸæ€§èƒ½ã‚’å®Ÿç¾")
</code></pre>

<p><strong>çµè«–</strong>:</p>
<ul>
<li>ã‚¢ãƒ³ã‚µãƒ³ãƒ–ãƒ«ã¯å˜ä¸€æ‰‹æ³•ã®ãƒã‚¤ã‚¢ã‚¹ã‚’è»½æ¸›</li>
<li>ã‚½ãƒ•ãƒˆæŠ•ç¥¨ã¯æŸ”è»Ÿæ€§ãŒé«˜ãã€é‡ã¿èª¿æ•´ã§æœ€é©åŒ–å¯èƒ½</li>
<li>å®Ÿå‹™ã§ã¯ã€ãƒ‰ãƒ¡ã‚¤ãƒ³çŸ¥è­˜ã«åŸºã¥ã„ã¦é‡ã¿ã‚’è¨­å®š</li>
</ul>

</details>

<hr>

<h2>å‚è€ƒæ–‡çŒ®</h2>

<ol>
<li>Rousseeuw, P. J., & Hubert, M. (2011). <em>Robust statistics for outlier detection</em>. Wiley interdisciplinary reviews: Data mining and knowledge discovery, 1(1), 73-79.</li>
<li>Barnett, V., & Lewis, T. (1994). <em>Outliers in statistical data</em> (3rd ed.). John Wiley & Sons.</li>
<li>Grubbs, F. E. (1969). <em>Procedures for detecting outlying observations in samples</em>. Technometrics, 11(1), 1-21.</li>
<li>Rosner, B. (1983). <em>Percentage points for a generalized ESD many-outlier procedure</em>. Technometrics, 25(2), 165-172.</li>
<li>Cleveland, R. B., Cleveland, W. S., McRae, J. E., & Terpenning, I. (1990). <em>STL: A seasonal-trend decomposition procedure based on loess</em>. Journal of Official Statistics, 6(1), 3-73.</li>
</ol>

<div class="navigation">
    <a href="chapter1-anomaly-detection-basics.html" class="nav-button">â† å‰ã®ç« : ç•°å¸¸æ¤œçŸ¥åŸºç¤</a>
    <a href="chapter3-ml-anomaly-detection.html" class="nav-button">æ¬¡ã®ç« : æ©Ÿæ¢°å­¦ç¿’ã«ã‚ˆã‚‹ç•°å¸¸æ¤œçŸ¥ â†’</a>
</div>

    </main>

    
    <section class="disclaimer">
        <h3>å…è²¬äº‹é …</h3>
        <ul>
            <li>æœ¬ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã¯æ•™è‚²ãƒ»ç ”ç©¶ãƒ»æƒ…å ±æä¾›ã®ã¿ã‚’ç›®çš„ã¨ã—ã¦ãŠã‚Šã€å°‚é–€çš„ãªåŠ©è¨€(æ³•å¾‹ãƒ»ä¼šè¨ˆãƒ»æŠ€è¡“çš„ä¿è¨¼ãªã©)ã‚’æä¾›ã™ã‚‹ã‚‚ã®ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚</li>
            <li>æœ¬ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãŠã‚ˆã³ä»˜éšã™ã‚‹ã‚³ãƒ¼ãƒ‰ä¾‹ã¯ã€Œç¾çŠ¶æœ‰å§¿(AS IS)ã€ã§æä¾›ã•ã‚Œã€æ˜ç¤ºã¾ãŸã¯é»™ç¤ºã‚’å•ã‚ãšã€å•†å“æ€§ã€ç‰¹å®šç›®çš„é©åˆæ€§ã€æ¨©åˆ©éä¾µå®³ã€æ­£ç¢ºæ€§ãƒ»å®Œå…¨æ€§ã€å‹•ä½œãƒ»å®‰å…¨æ€§ç­‰ã„ã‹ãªã‚‹ä¿è¨¼ã‚‚ã—ã¾ã›ã‚“ã€‚</li>
            <li>å¤–éƒ¨ãƒªãƒ³ã‚¯ã€ç¬¬ä¸‰è€…ãŒæä¾›ã™ã‚‹ãƒ‡ãƒ¼ã‚¿ãƒ»ãƒ„ãƒ¼ãƒ«ãƒ»ãƒ©ã‚¤ãƒ–ãƒ©ãƒªç­‰ã®å†…å®¹ãƒ»å¯ç”¨æ€§ãƒ»å®‰å…¨æ€§ã«ã¤ã„ã¦ã€ä½œæˆè€…ãŠã‚ˆã³æ±åŒ—å¤§å­¦ã¯ä¸€åˆ‡ã®è²¬ä»»ã‚’è² ã„ã¾ã›ã‚“ã€‚</li>
            <li>æœ¬ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®åˆ©ç”¨ãƒ»å®Ÿè¡Œãƒ»è§£é‡ˆã«ã‚ˆã‚Šç›´æ¥çš„ãƒ»é–“æ¥çš„ãƒ»ä»˜éšçš„ãƒ»ç‰¹åˆ¥ãƒ»çµæœçš„ãƒ»æ‡²ç½°çš„æå®³ãŒç”Ÿã˜ãŸå ´åˆã§ã‚‚ã€é©ç”¨æ³•ã§è¨±å®¹ã•ã‚Œã‚‹æœ€å¤§é™ã®ç¯„å›²ã§ã€ä½œæˆè€…ãŠã‚ˆã³æ±åŒ—å¤§å­¦ã¯è²¬ä»»ã‚’è² ã„ã¾ã›ã‚“ã€‚</li>
            <li>æœ¬ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®å†…å®¹ã¯ã€äºˆå‘Šãªãå¤‰æ›´ãƒ»æ›´æ–°ãƒ»æä¾›åœæ­¢ã•ã‚Œã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚</li>
            <li>æœ¬ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®è‘—ä½œæ¨©ãƒ»ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã¯æ˜è¨˜ã•ã‚ŒãŸæ¡ä»¶(ä¾‹: CC BY 4.0)ã«å¾“ã„ã¾ã™ã€‚å½“è©²ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã¯é€šå¸¸ã€ç„¡ä¿è¨¼æ¡é …ã‚’å«ã¿ã¾ã™ã€‚</li>
        </ul>
    </section>

<footer>
        <p><strong>ä½œæˆè€…</strong>: AI Terakoya Content Team</p>
        <p><strong>ãƒãƒ¼ã‚¸ãƒ§ãƒ³</strong>: 1.0 | <strong>ä½œæˆæ—¥</strong>: 2025-10-21</p>
        <p><strong>ãƒ©ã‚¤ã‚»ãƒ³ã‚¹</strong>: Creative Commons BY 4.0</p>
        <p>Â© 2025 AI Terakoya. All rights reserved.</p>
    </footer>
</body>
</html>
