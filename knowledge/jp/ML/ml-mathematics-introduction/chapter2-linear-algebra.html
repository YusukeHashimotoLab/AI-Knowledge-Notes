<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="æ©Ÿæ¢°å­¦ç¿’ã®æ•°ç†å…¥é–€ã‚·ãƒªãƒ¼ã‚º ç¬¬2ç« ï¼šç·šå½¢ä»£æ•°ã®åŸºç¤ - è¡Œåˆ—åˆ†è§£ã€PCAã€ç·šå½¢å¤‰æ›ã‚’ç†è«–ã¨å®Ÿè£…ã§å­¦ã¶">
    <title>ç¬¬2ç« ï¼šç·šå½¢ä»£æ•°ã®åŸºç¤ - æ©Ÿæ¢°å­¦ç¿’ã®æ•°ç†å…¥é–€ã‚·ãƒªãƒ¼ã‚º</title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js"></script>
    <style>
        :root {
            --primary-color: #2c3e50;
            --secondary-color: #3498db;
            --accent-color: #e74c3c;
            --bg-color: #ffffff;
            --text-color: #333333;
            --border-color: #e0e0e0;
            --code-bg: #f5f5f5;
            --link-color: #3498db;
            --link-hover: #2980b9;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Hiragino Sans", "Hiragino Kaku Gothic ProN", Meiryo, sans-serif;
            line-height: 1.8;
            color: var(--text-color);
            background: var(--bg-color);
            padding: 0;
            margin: 0;
        }
        .container { max-width: 900px; margin: 0 auto; padding: 2rem 1.5rem; }
        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 2rem 0;
            margin-bottom: 2rem;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        header .container { padding: 0 1.5rem; }
        h1 { font-size: 2rem; margin-bottom: 0.5rem; font-weight: 700; }
        .meta {
            display: flex;
            gap: 1.5rem;
            flex-wrap: wrap;
            font-size: 0.9rem;
            opacity: 0.95;
            margin-top: 1rem;
        }
        .meta span { display: inline-flex; align-items-center; gap: 0.3rem; }
        h2 {
            font-size: 1.75rem;
            margin-top: 2.5rem;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 3px solid var(--secondary-color);
            color: var(--primary-color);
        }
        h3 { font-size: 1.4rem; margin-top: 2rem; margin-bottom: 0.8rem; color: var(--primary-color); }
        h4 { font-size: 1.2rem; margin-top: 1.5rem; margin-bottom: 0.6rem; color: var(--primary-color); }
        p { margin-bottom: 1.2rem; }
        a { color: var(--link-color); text-decoration: none; transition: color 0.2s; }
        a:hover { color: var(--link-hover); text-decoration: underline; }
        ul, ol { margin-left: 2rem; margin-bottom: 1.2rem; }
        li { margin-bottom: 0.5rem; }
        code {
            background: var(--code-bg);
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
            font-size: 0.9em;
        }
        pre {
            background: var(--code-bg);
            padding: 1.2rem;
            border-radius: 6px;
            overflow-x: auto;
            margin-bottom: 1.5rem;
            border-left: 4px solid var(--secondary-color);
        }
        pre code {
            background: none;
            padding: 0;
            font-size: 0.85em;
            line-height: 1.6;
        }
        .info-box {
            background: #e8f4f8;
            border-left: 4px solid var(--secondary-color);
            padding: 1rem 1.2rem;
            margin: 1.5rem 0;
            border-radius: 4px;
        }
        .info-box strong {
            color: var(--secondary-color);
            display: block;
            margin-bottom: 0.5rem;
        }
        .warning-box {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 1rem 1.2rem;
            margin: 1.5rem 0;
            border-radius: 4px;
        }
        .warning-box strong {
            color: #856404;
            display: block;
            margin-bottom: 0.5rem;
        }
        .math-block {
            margin: 1.5rem 0;
            padding: 1rem;
            text-align: center;
            overflow-x: auto;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1.5rem 0;
        }
        th, td {
            border: 1px solid var(--border-color);
            padding: 0.8rem;
            text-align: left;
        }
        th {
            background: #f8f9fa;
            font-weight: 600;
        }
        .nav-buttons {
            display: flex;
            justify-content: space-between;
            margin: 3rem 0;
            gap: 1rem;
            flex-wrap: wrap;
        }
        .nav-button {
            display: inline-block;
            padding: 0.8rem 1.5rem;
            background: var(--secondary-color);
            color: white;
            border-radius: 6px;
            text-decoration: none;
            transition: all 0.3s;
            font-weight: 600;
        }
        .nav-button:hover {
            background: var(--link-hover);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
            text-decoration: none;
        }
        footer {
            margin-top: 4rem;
            padding: 2rem 0;
            border-top: 2px solid var(--border-color);
            text-align: center;
            color: #666;
            font-size: 0.9rem;
        }
        @media (max-width: 768px) {
            .container { padding: 1rem; }
            h1 { font-size: 1.6rem; }
            h2 { font-size: 1.4rem; }
            .meta { font-size: 0.85rem; }
        }
    
        .feedback-notice {
            background: #fff3cd;
            border: 2px solid #ffc107;
            border-radius: 8px;
            padding: 2rem;
            margin: 3rem auto;
            max-width: 900px;
        }

        .feedback-notice h3 {
            color: #856404;
            font-size: 1.3rem;
            margin-bottom: 1rem;
            text-align: center;
        }

        .feedback-notice p {
            color: #856404;
            font-size: 1rem;
            margin-bottom: 1.5rem;
            text-align: center;
        }

        .feedback-options {
            display: flex;
            justify-content: center;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .feedback-button {
            display: inline-block;
            padding: 0.8rem 1.5rem;
            background: #3498db;
            color: white;
            text-decoration: none;
            border-radius: 6px;
            font-weight: 600;
            transition: all 0.3s;
        }

        .feedback-button:hover {
            background: #2980b9;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
        }

    </style>
</head>
<body>
    <header>
        <div class="container">
            <h1>ç¬¬2ç« ï¼šç·šå½¢ä»£æ•°ã®åŸºç¤</h1>
            <p style="font-size: 1.1rem; margin-top: 0.5rem; opacity: 0.95;">æ©Ÿæ¢°å­¦ç¿’ã®æ•°ç†å…¥é–€ã‚·ãƒªãƒ¼ã‚º v1.0</p>
            <div class="meta">
                <span>ğŸ“– å­¦ç¿’æ™‚é–“: 30-35åˆ†</span>
                <span>ğŸ“Š ãƒ¬ãƒ™ãƒ«: ä¸Šç´š</span>
                <span>ğŸ’» ã‚³ãƒ¼ãƒ‰ä¾‹: 6å€‹</span>
                <span>ğŸ¯ ã‚·ãƒªãƒ¼ã‚º: ML-P05</span>
            </div>
        </div>
    </header>

    <main class="container">
        <p><strong>æ©Ÿæ¢°å­¦ç¿’ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã®æ•°å­¦çš„åŸºç›¤ã¨ãªã‚‹ç·šå½¢ä»£æ•°ã‚’ç†è«–ã¨å®Ÿè£…ã®ä¸¡é¢ã‹ã‚‰æ·±ãç†è§£ã™ã‚‹</strong></p>

        <div class="info-box">
            <strong>ã“ã®ç« ã§å­¦ã¹ã‚‹ã“ã¨</strong>
            <ul style="margin-left: 1.5rem; margin-bottom: 0;">
                <li>ãƒ™ã‚¯ãƒˆãƒ«ã¨è¡Œåˆ—ã®åŸºæœ¬æ¼”ç®—ã¨å¹¾ä½•çš„æ„å‘³</li>
                <li>å›ºæœ‰å€¤åˆ†è§£ã€SVDã€QRåˆ†è§£ã®ç†è«–ã¨å®Ÿè£…</li>
                <li>ä¸»æˆåˆ†åˆ†æï¼ˆPCAï¼‰ã®æ•°å­¦çš„åŸç†ã¨å¿œç”¨</li>
                <li>ç·šå½¢å¤‰æ›ã¨å°„å½±ã®å¹¾ä½•å­¦çš„ç†è§£</li>
                <li>ç·šå½¢å›å¸°ã¨Ridgeå›å¸°ã¸ã®ç·šå½¢ä»£æ•°ã®é©ç”¨</li>
            </ul>
        </div>

        <h2>1. ãƒ™ã‚¯ãƒˆãƒ«ã¨è¡Œåˆ—ã®åŸºç¤</h2>

        <h3>1.1 ãƒ™ã‚¯ãƒˆãƒ«ã®å†…ç©ã¨ãƒãƒ«ãƒ </h3>

        <p>ãƒ™ã‚¯ãƒˆãƒ«ã®å†…ç©ï¼ˆãƒ‰ãƒƒãƒˆç©ï¼‰ã¯ã€2ã¤ã®ãƒ™ã‚¯ãƒˆãƒ«ã®é¡ä¼¼åº¦ã‚’æ¸¬ã‚‹åŸºæœ¬çš„ãªæ¼”ç®—ã§ã™ã€‚</p>

        <div class="math-block">
            $$\mathbf{x} \cdot \mathbf{y} = \mathbf{x}^T\mathbf{y} = \sum_{i=1}^{n} x_i y_i = \|\mathbf{x}\|\|\mathbf{y}\|\cos\theta$$
        </div>

        <p>ã“ã“ã§ã€Î¸ã¯ãƒ™ã‚¯ãƒˆãƒ«é–“ã®è§’åº¦ã§ã™ã€‚å†…ç©ã®å¹¾ä½•çš„æ„å‘³ï¼š</p>
        <ul>
            <li><strong>æ­£</strong>: åŒã˜æ–¹å‘ã‚’å‘ã„ã¦ã„ã‚‹ï¼ˆé‹­è§’ï¼‰</li>
            <li><strong>ã‚¼ãƒ­</strong>: ç›´äº¤ã—ã¦ã„ã‚‹ï¼ˆå‚ç›´ï¼‰</li>
            <li><strong>è² </strong>: åå¯¾æ–¹å‘ã‚’å‘ã„ã¦ã„ã‚‹ï¼ˆéˆè§’ï¼‰</li>
        </ul>

        <p>ãƒ™ã‚¯ãƒˆãƒ«ã®ãƒãƒ«ãƒ ï¼ˆé•·ã•ï¼‰ã¯ã€ãƒ™ã‚¯ãƒˆãƒ«ã®å¤§ãã•ã‚’è¡¨ã—ã¾ã™ã€‚</p>

        <div class="math-block">
            $$\|\mathbf{x}\|_2 = \sqrt{\mathbf{x}^T\mathbf{x}} = \sqrt{\sum_{i=1}^{n} x_i^2} \quad \text{ï¼ˆL2ãƒãƒ«ãƒ ï¼‰}$$
            $$\|\mathbf{x}\|_1 = \sum_{i=1}^{n} |x_i| \quad \text{ï¼ˆL1ãƒãƒ«ãƒ ï¼‰}$$
        </div>

        <div class="info-box">
            <strong>æ©Ÿæ¢°å­¦ç¿’ã§ã®å¿œç”¨</strong>
            L2ãƒãƒ«ãƒ ã¯Ridgeå›å¸°ã®æ­£å‰‡åŒ–é …ã€L1ãƒãƒ«ãƒ ã¯Lassoå›å¸°ã®æ­£å‰‡åŒ–é …ã¨ã—ã¦ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚ã¾ãŸã€ã‚³ã‚µã‚¤ãƒ³é¡ä¼¼åº¦ã¯æ–‡æ›¸åˆ†é¡ã‚„æ¨è–¦ã‚·ã‚¹ãƒ†ãƒ ã§é »ç¹ã«ä½¿ã‚ã‚Œã¾ã™ã€‚
        </div>

        <h3>1.2 è¡Œåˆ—ã®åŸºæœ¬æ¼”ç®—</h3>

        <p>è¡Œåˆ—ç©ã¯ç·šå½¢å¤‰æ›ã‚’åˆæˆã™ã‚‹æ¼”ç®—ã§ã™ã€‚</p>

        <div class="math-block">
            $$(\mathbf{AB})_{ij} = \sum_{k=1}^{m} A_{ik}B_{kj}$$
        </div>

        <p><strong>é‡è¦ãªæ€§è³ªï¼š</strong></p>
        <ul>
            <li>çµåˆå¾‹: \((\mathbf{AB})\mathbf{C} = \mathbf{A}(\mathbf{BC})\)</li>
            <li>åˆ†é…å¾‹: \(\mathbf{A}(\mathbf{B}+\mathbf{C}) = \mathbf{AB} + \mathbf{AC}\)</li>
            <li>è»¢ç½®: \((\mathbf{AB})^T = \mathbf{B}^T\mathbf{A}^T\)</li>
            <li>éå¯æ›æ€§: ä¸€èˆ¬ã« \(\mathbf{AB} \neq \mathbf{BA}\)</li>
        </ul>

        <h3>å®Ÿè£…ä¾‹1ï¼šãƒ™ã‚¯ãƒˆãƒ«ãƒ»è¡Œåˆ—æ¼”ç®—ã®å®Ÿè£…</h3>

<pre><code>import numpy as np

class LinearAlgebraOps:
    """ç·šå½¢ä»£æ•°ã®åŸºæœ¬æ¼”ç®—ã‚’å®Ÿè£…ã™ã‚‹ã‚¯ãƒ©ã‚¹"""

    @staticmethod
    def inner_product(x, y):
        """
        å†…ç©ã®è¨ˆç®—: xãƒ»y = Î£ x_i * y_i

        Parameters:
        -----------
        x, y : array-like
            å…¥åŠ›ãƒ™ã‚¯ãƒˆãƒ«

        Returns:
        --------
        float : å†…ç©
        """
        x, y = np.array(x), np.array(y)
        assert x.shape == y.shape, "ãƒ™ã‚¯ãƒˆãƒ«ã®æ¬¡å…ƒãŒä¸€è‡´ã—ã¾ã›ã‚“"
        return np.sum(x * y)

    @staticmethod
    def cosine_similarity(x, y):
        """
        ã‚³ã‚µã‚¤ãƒ³é¡ä¼¼åº¦: cos(Î¸) = (xãƒ»y) / (||x|| * ||y||)

        Returns:
        --------
        float : -1ã‹ã‚‰1ã®ç¯„å›²ã®é¡ä¼¼åº¦
        """
        x, y = np.array(x), np.array(y)
        dot_product = LinearAlgebraOps.inner_product(x, y)
        norm_x = np.linalg.norm(x)
        norm_y = np.linalg.norm(y)

        if norm_x == 0 or norm_y == 0:
            return 0.0

        return dot_product / (norm_x * norm_y)

    @staticmethod
    def vector_norm(x, p=2):
        """
        ãƒ™ã‚¯ãƒˆãƒ«ã®Lpãƒãƒ«ãƒ 

        Parameters:
        -----------
        x : array-like
            å…¥åŠ›ãƒ™ã‚¯ãƒˆãƒ«
        p : int or float
            ãƒãƒ«ãƒ ã®æ¬¡æ•°ï¼ˆ1, 2, np.inf ãªã©ï¼‰

        Returns:
        --------
        float : ãƒãƒ«ãƒ 
        """
        x = np.array(x)
        if p == 1:
            return np.sum(np.abs(x))
        elif p == 2:
            return np.sqrt(np.sum(x**2))
        elif p == np.inf:
            return np.max(np.abs(x))
        else:
            return np.sum(np.abs(x)**p)**(1/p)

    @staticmethod
    def matrix_multiply(A, B):
        """
        è¡Œåˆ—ç©ã®å®Ÿè£…: C = AB

        Parameters:
        -----------
        A : ndarray of shape (m, n)
        B : ndarray of shape (n, p)

        Returns:
        --------
        ndarray of shape (m, p)
        """
        A, B = np.array(A), np.array(B)
        assert A.shape[1] == B.shape[0], f"è¡Œåˆ—ã®å½¢çŠ¶ãŒä¸é©åˆ‡: {A.shape} ã¨ {B.shape}"

        m, n = A.shape
        p = B.shape[1]
        C = np.zeros((m, p))

        for i in range(m):
            for j in range(p):
                C[i, j] = np.sum(A[i, :] * B[:, j])

        return C

    @staticmethod
    def outer_product(x, y):
        """
        å¤–ç©ï¼ˆãƒ†ãƒ³ã‚½ãƒ«ç©ï¼‰: xy^T

        Returns:
        --------
        ndarray : è¡Œåˆ—
        """
        x, y = np.array(x).reshape(-1, 1), np.array(y).reshape(-1, 1)
        return x @ y.T

# ä½¿ç”¨ä¾‹
ops = LinearAlgebraOps()

# ãƒ™ã‚¯ãƒˆãƒ«æ¼”ç®—
v1 = np.array([1, 2, 3])
v2 = np.array([4, 5, 6])

print("ãƒ™ã‚¯ãƒˆãƒ«æ¼”ç®—:")
print(f"v1 = {v1}")
print(f"v2 = {v2}")
print(f"å†…ç©: {ops.inner_product(v1, v2)}")
print(f"ã‚³ã‚µã‚¤ãƒ³é¡ä¼¼åº¦: {ops.cosine_similarity(v1, v2):.4f}")
print(f"L1ãƒãƒ«ãƒ : {ops.vector_norm(v1, p=1):.4f}")
print(f"L2ãƒãƒ«ãƒ : {ops.vector_norm(v1, p=2):.4f}")

# è¡Œåˆ—æ¼”ç®—
A = np.array([[1, 2], [3, 4]])
B = np.array([[5, 6], [7, 8]])

print(f"\nè¡Œåˆ—ç©:")
print(f"A @ B =\n{ops.matrix_multiply(A, B)}")
print(f"NumPyæ¤œè¨¼:\n{A @ B}")

# å¤–ç©
print(f"\nå¤–ç© v1 âŠ— v2 =\n{ops.outer_product(v1, v2)}")
</code></pre>

        <h2>2. è¡Œåˆ—åˆ†è§£</h2>

        <h3>2.1 å›ºæœ‰å€¤åˆ†è§£ï¼ˆEigendecompositionï¼‰</h3>

        <p>æ­£æ–¹è¡Œåˆ—Aã®å›ºæœ‰å€¤Î»ã¨å›ºæœ‰ãƒ™ã‚¯ãƒˆãƒ«vã¯ä»¥ä¸‹ã‚’æº€ãŸã—ã¾ã™ï¼š</p>

        <div class="math-block">
            $$\mathbf{A}\mathbf{v} = \lambda\mathbf{v}$$
        </div>

        <p>å¯¾ç§°è¡Œåˆ—ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«å¯¾è§’åŒ–ã§ãã¾ã™ï¼š</p>

        <div class="math-block">
            $$\mathbf{A} = \mathbf{Q}\mathbf{\Lambda}\mathbf{Q}^T$$
        </div>

        <p>ã“ã“ã§ï¼š</p>
        <ul>
            <li><strong>Q</strong>: å›ºæœ‰ãƒ™ã‚¯ãƒˆãƒ«ã‚’åˆ—ã«æŒã¤ç›´äº¤è¡Œåˆ—</li>
            <li><strong>Î›</strong>: å›ºæœ‰å€¤ã‚’å¯¾è§’æˆåˆ†ã«æŒã¤å¯¾è§’è¡Œåˆ—</li>
        </ul>

        <div class="info-box">
            <strong>å¹¾ä½•çš„æ„å‘³</strong>
            å›ºæœ‰ãƒ™ã‚¯ãƒˆãƒ«ã¯è¡Œåˆ—ã«ã‚ˆã‚‹å¤‰æ›ã§æ–¹å‘ãŒå¤‰ã‚ã‚‰ãªã„ãƒ™ã‚¯ãƒˆãƒ«ã§ã€å›ºæœ‰å€¤ã¯ãã®æ‹¡å¤§ç‡ã‚’è¡¨ã—ã¾ã™ã€‚å›ºæœ‰å€¤ãŒå¤§ãã„ã»ã©ã€ãã®æ–¹å‘ã®å¤‰å‹•ãŒå¤§ãã„ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚
        </div>

        <h3>2.2 ç‰¹ç•°å€¤åˆ†è§£ï¼ˆSVDï¼‰</h3>

        <p>ä»»æ„ã®è¡Œåˆ—Aã¯ä»¥ä¸‹ã®ã‚ˆã†ã«åˆ†è§£ã§ãã¾ã™ï¼š</p>

        <div class="math-block">
            $$\mathbf{A} = \mathbf{U}\mathbf{\Sigma}\mathbf{V}^T$$
        </div>

        <p>ã“ã“ã§ï¼š</p>
        <ul>
            <li><strong>U</strong>: å·¦ç‰¹ç•°ãƒ™ã‚¯ãƒˆãƒ«ï¼ˆmÃ—mç›´äº¤è¡Œåˆ—ï¼‰</li>
            <li><strong>Î£</strong>: ç‰¹ç•°å€¤ã®å¯¾è§’è¡Œåˆ—ï¼ˆmÃ—nï¼‰</li>
            <li><strong>V</strong>: å³ç‰¹ç•°ãƒ™ã‚¯ãƒˆãƒ«ï¼ˆnÃ—nç›´äº¤è¡Œåˆ—ï¼‰</li>
        </ul>

        <p>ç‰¹ç•°å€¤ã¯é™é †ã«ä¸¦ã¹ã‚‰ã‚Œã€Ïƒâ‚ â‰¥ Ïƒâ‚‚ â‰¥ ... â‰¥ 0 ã§ã™ã€‚</p>

        <div class="info-box">
            <strong>æ©Ÿæ¢°å­¦ç¿’ã§ã®å¿œç”¨</strong>
            SVDã¯ä¸»æˆåˆ†åˆ†æï¼ˆPCAï¼‰ã€æ¨è–¦ã‚·ã‚¹ãƒ†ãƒ ï¼ˆå”èª¿ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ï¼‰ã€è‡ªç„¶è¨€èªå‡¦ç†ï¼ˆLSAï¼‰ã€ç”»åƒåœ§ç¸®ãªã©å¹…åºƒãä½¿ç”¨ã•ã‚Œã¾ã™ã€‚
        </div>

        <h3>2.3 QRåˆ†è§£</h3>

        <p>ä»»æ„ã®è¡Œåˆ—Aã¯ç›´äº¤è¡Œåˆ—Qã¨ä¸Šä¸‰è§’è¡Œåˆ—Rã®ç©ã«åˆ†è§£ã§ãã¾ã™ï¼š</p>

        <div class="math-block">
            $$\mathbf{A} = \mathbf{QR}$$
        </div>

        <p>QRåˆ†è§£ã¯ã€æœ€å°äºŒä¹—æ³•ã®æ•°å€¤çš„ã«å®‰å®šãªè§£æ³•ã¨ã—ã¦ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚</p>

        <h3>å®Ÿè£…ä¾‹2ï¼šè¡Œåˆ—åˆ†è§£ã®å®Ÿè£…ã¨æ¯”è¼ƒ</h3>

<pre><code>import numpy as np
from scipy import linalg

class MatrixDecomposition:
    """è¡Œåˆ—åˆ†è§£ã®å®Ÿè£…ã¨å¿œç”¨"""

    @staticmethod
    def eigen_decomposition(A, symmetric=True):
        """
        å›ºæœ‰å€¤åˆ†è§£: A = QÎ›Q^T

        Parameters:
        -----------
        A : ndarray of shape (n, n)
            åˆ†è§£ã™ã‚‹è¡Œåˆ—
        symmetric : bool
            å¯¾ç§°è¡Œåˆ—ã‹ã©ã†ã‹

        Returns:
        --------
        eigenvalues : ndarray
            å›ºæœ‰å€¤ï¼ˆé™é †ï¼‰
        eigenvectors : ndarray
            å¯¾å¿œã™ã‚‹å›ºæœ‰ãƒ™ã‚¯ãƒˆãƒ«
        """
        A = np.array(A)
        assert A.shape[0] == A.shape[1], "æ­£æ–¹è¡Œåˆ—ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™"

        if symmetric:
            eigenvalues, eigenvectors = np.linalg.eigh(A)
        else:
            eigenvalues, eigenvectors = np.linalg.eig(A)

        # å›ºæœ‰å€¤ã®é™é †ã«ã‚½ãƒ¼ãƒˆ
        idx = eigenvalues.argsort()[::-1]
        eigenvalues = eigenvalues[idx]
        eigenvectors = eigenvectors[:, idx]

        return eigenvalues, eigenvectors

    @staticmethod
    def svd_decomposition(A, full_matrices=False):
        """
        ç‰¹ç•°å€¤åˆ†è§£: A = UÎ£V^T

        Parameters:
        -----------
        A : ndarray of shape (m, n)
            åˆ†è§£ã™ã‚‹è¡Œåˆ—
        full_matrices : bool
            å®Œå…¨ãªè¡Œåˆ—ã‚’è¿”ã™ã‹

        Returns:
        --------
        U : ndarray of shape (m, m) or (m, k)
            å·¦ç‰¹ç•°ãƒ™ã‚¯ãƒˆãƒ«
        S : ndarray of shape (k,)
            ç‰¹ç•°å€¤ï¼ˆé™é †ï¼‰
        Vt : ndarray of shape (n, n) or (k, n)
            å³ç‰¹ç•°ãƒ™ã‚¯ãƒˆãƒ«ã®è»¢ç½®
        """
        A = np.array(A)
        U, S, Vt = np.linalg.svd(A, full_matrices=full_matrices)
        return U, S, Vt

    @staticmethod
    def qr_decomposition(A):
        """
        QRåˆ†è§£: A = QR

        Parameters:
        -----------
        A : ndarray of shape (m, n)
            åˆ†è§£ã™ã‚‹è¡Œåˆ—

        Returns:
        --------
        Q : ndarray of shape (m, m)
            ç›´äº¤è¡Œåˆ—
        R : ndarray of shape (m, n)
            ä¸Šä¸‰è§’è¡Œåˆ—
        """
        A = np.array(A)
        Q, R = np.linalg.qr(A)
        return Q, R

    @staticmethod
    def low_rank_approximation(A, k):
        """
        SVDã‚’ä½¿ã£ãŸä½ãƒ©ãƒ³ã‚¯è¿‘ä¼¼

        Parameters:
        -----------
        A : ndarray of shape (m, n)
            å…ƒã®è¡Œåˆ—
        k : int
            è¿‘ä¼¼ã®ãƒ©ãƒ³ã‚¯

        Returns:
        --------
        A_approx : ndarray
            ãƒ©ãƒ³ã‚¯kã®è¿‘ä¼¼è¡Œåˆ—
        reconstruction_error : float
            ãƒ•ãƒ­ãƒ™ãƒ‹ã‚¦ã‚¹ãƒãƒ«ãƒ ã§ã®å†æ§‹æˆèª¤å·®
        """
        U, S, Vt = MatrixDecomposition.svd_decomposition(A, full_matrices=False)

        # ä¸Šä½kå€‹ã®ç‰¹ç•°å€¤ã®ã¿ä½¿ç”¨
        U_k = U[:, :k]
        S_k = S[:k]
        Vt_k = Vt[:k, :]

        # ä½ãƒ©ãƒ³ã‚¯è¿‘ä¼¼
        A_approx = U_k @ np.diag(S_k) @ Vt_k

        # å†æ§‹æˆèª¤å·®
        reconstruction_error = np.linalg.norm(A - A_approx, 'fro')

        return A_approx, reconstruction_error

# ä½¿ç”¨ä¾‹
decomp = MatrixDecomposition()

# å¯¾ç§°è¡Œåˆ—ã®å›ºæœ‰å€¤åˆ†è§£
print("=" * 60)
print("å›ºæœ‰å€¤åˆ†è§£")
print("=" * 60)
A_sym = np.array([[4, 2], [2, 3]])
eigenvalues, eigenvectors = decomp.eigen_decomposition(A_sym)
print(f"å…ƒã®è¡Œåˆ— A:\n{A_sym}\n")
print(f"å›ºæœ‰å€¤: {eigenvalues}")
print(f"å›ºæœ‰ãƒ™ã‚¯ãƒˆãƒ«:\n{eigenvectors}\n")

# å†æ§‹æˆã®æ¤œè¨¼
Lambda = np.diag(eigenvalues)
A_reconstructed = eigenvectors @ Lambda @ eigenvectors.T
print(f"å†æ§‹æˆ A = QÎ›Q^T:\n{A_reconstructed}")
print(f"å†æ§‹æˆèª¤å·®: {np.linalg.norm(A_sym - A_reconstructed):.10f}\n")

# SVD
print("=" * 60)
print("ç‰¹ç•°å€¤åˆ†è§£ï¼ˆSVDï¼‰")
print("=" * 60)
A = np.array([[1, 2, 3], [4, 5, 6]])
U, S, Vt = decomp.svd_decomposition(A, full_matrices=True)
print(f"å…ƒã®è¡Œåˆ— A ({A.shape}):\n{A}\n")
print(f"U ({U.shape}):\n{U}\n")
print(f"ç‰¹ç•°å€¤ S: {S}\n")
print(f"V^T ({Vt.shape}):\n{Vt}\n")

# å†æ§‹æˆ
Sigma = np.zeros_like(A, dtype=float)
Sigma[:len(S), :len(S)] = np.diag(S)
A_reconstructed = U @ Sigma @ Vt
print(f"å†æ§‹æˆ A = UÎ£V^T:\n{A_reconstructed}")
print(f"å†æ§‹æˆèª¤å·®: {np.linalg.norm(A - A_reconstructed):.10f}\n")

# ä½ãƒ©ãƒ³ã‚¯è¿‘ä¼¼
print("=" * 60)
print("ä½ãƒ©ãƒ³ã‚¯è¿‘ä¼¼")
print("=" * 60)
A_large = np.random.randn(10, 8)
for k in [1, 2, 4, 8]:
    A_approx, error = decomp.low_rank_approximation(A_large, k)
    compression_ratio = (k * (A_large.shape[0] + A_large.shape[1])) / A_large.size
    print(f"ãƒ©ãƒ³ã‚¯ {k}: å†æ§‹æˆèª¤å·® = {error:.4f}, åœ§ç¸®ç‡ = {compression_ratio:.2%}")

# QRåˆ†è§£
print("\n" + "=" * 60)
print("QRåˆ†è§£")
print("=" * 60)
A = np.array([[1, 2], [3, 4], [5, 6]], dtype=float)
Q, R = decomp.qr_decomposition(A)
print(f"å…ƒã®è¡Œåˆ— A:\n{A}\n")
print(f"Q (ç›´äº¤è¡Œåˆ—):\n{Q}\n")
print(f"R (ä¸Šä¸‰è§’è¡Œåˆ—):\n{R}\n")
print(f"Q^T Q (å˜ä½è¡Œåˆ—):\n{Q.T @ Q}")
print(f"å†æ§‹æˆ A = QR:\n{Q @ R}")
</code></pre>

        <h2>3. ä¸»æˆåˆ†åˆ†æï¼ˆPCAï¼‰</h2>

        <h3>3.1 PCAã®æ•°å­¦çš„å®šå¼åŒ–</h3>

        <p>ä¸»æˆåˆ†åˆ†æã¯ã€ãƒ‡ãƒ¼ã‚¿ã®åˆ†æ•£ã‚’æœ€å¤§åŒ–ã™ã‚‹ç›´äº¤è»¸ã‚’è¦‹ã¤ã‘ã‚‹æ¬¡å…ƒå‰Šæ¸›æ‰‹æ³•ã§ã™ã€‚</p>

        <p><strong>ç›®çš„ï¼š</strong>ãƒ‡ãƒ¼ã‚¿è¡Œåˆ— X (nÃ—d) ã‚’ä½æ¬¡å…ƒç©ºé–“ (nÃ—k, k < d) ã«å°„å½±</p>

        <div class="math-block">
            $$\max_{\mathbf{w}} \mathbf{w}^T\mathbf{S}\mathbf{w} \quad \text{s.t.} \quad \|\mathbf{w}\|^2 = 1$$
        </div>

        <p>ã“ã“ã§ã€Sã¯å…±åˆ†æ•£è¡Œåˆ—ã§ã™ï¼š</p>

        <div class="math-block">
            $$\mathbf{S} = \frac{1}{n}\sum_{i=1}^{n}(\mathbf{x}_i - \bar{\mathbf{x}})(\mathbf{x}_i - \bar{\mathbf{x}})^T = \frac{1}{n}\mathbf{X}_c^T\mathbf{X}_c$$
        </div>

        <p><strong>è§£æ³•ï¼š</strong>å…±åˆ†æ•£è¡Œåˆ—ã®å›ºæœ‰å€¤åˆ†è§£</p>

        <div class="math-block">
            $$\mathbf{S} = \mathbf{Q}\mathbf{\Lambda}\mathbf{Q}^T$$
        </div>

        <p>ä¸»æˆåˆ†ã¯å›ºæœ‰å€¤ã®å¤§ãã„é †ã®å›ºæœ‰ãƒ™ã‚¯ãƒˆãƒ«ã§ã™ã€‚</p>

        <h3>3.2 PCAã®æ‰‹é †</h3>

        <ol>
            <li><strong>ä¸­å¿ƒåŒ–</strong>: ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰å¹³å‡ã‚’å¼•ã</li>
            <li><strong>å…±åˆ†æ•£è¡Œåˆ—ã®è¨ˆç®—</strong>: S = (1/n)X_c^T X_c</li>
            <li><strong>å›ºæœ‰å€¤åˆ†è§£</strong>: å›ºæœ‰å€¤ã¨å›ºæœ‰ãƒ™ã‚¯ãƒˆãƒ«ã‚’è¨ˆç®—</li>
            <li><strong>ä¸»æˆåˆ†ã®é¸æŠ</strong>: å›ºæœ‰å€¤ã®å¤§ãã„é †ã«kå€‹é¸æŠ</li>
            <li><strong>å°„å½±</strong>: ãƒ‡ãƒ¼ã‚¿ã‚’ä¸»æˆåˆ†ç©ºé–“ã«å¤‰æ›</li>
        </ol>

        <div class="info-box">
            <strong>å¯„ä¸ç‡ã¨ç´¯ç©å¯„ä¸ç‡</strong>
            ç¬¬iä¸»æˆåˆ†ã®å¯„ä¸ç‡ = Î»_i / Î£Î»_j ã¯ã€ãã®ä¸»æˆåˆ†ãŒèª¬æ˜ã™ã‚‹åˆ†æ•£ã®å‰²åˆã§ã™ã€‚ç´¯ç©å¯„ä¸ç‡ãŒ90%ä»¥ä¸Šã«ãªã‚‹æ¬¡å…ƒæ•°ã‚’é¸ã¶ã®ãŒä¸€èˆ¬çš„ã§ã™ã€‚
        </div>

        <h3>å®Ÿè£…ä¾‹3ï¼šä¸»æˆåˆ†åˆ†æï¼ˆPCAï¼‰ã®å®Œå…¨å®Ÿè£…</h3>

<pre><code>import numpy as np
import matplotlib.pyplot as plt

class PCA:
    """ä¸»æˆåˆ†åˆ†æã®å®Ÿè£…"""

    def __init__(self, n_components=None):
        """
        Parameters:
        -----------
        n_components : int or None
            ä¿æŒã™ã‚‹ä¸»æˆåˆ†ã®æ•°ï¼ˆNoneã®å ´åˆã¯å…¨ã¦ï¼‰
        """
        self.n_components = n_components
        self.components_ = None
        self.explained_variance_ = None
        self.explained_variance_ratio_ = None
        self.mean_ = None

    def fit(self, X):
        """
        ä¸»æˆåˆ†åˆ†æã‚’å®Ÿè¡Œ

        Parameters:
        -----------
        X : ndarray of shape (n_samples, n_features)
            å…¥åŠ›ãƒ‡ãƒ¼ã‚¿

        Returns:
        --------
        self
        """
        X = np.array(X)
        n_samples, n_features = X.shape

        # 1. ãƒ‡ãƒ¼ã‚¿ã®ä¸­å¿ƒåŒ–
        self.mean_ = np.mean(X, axis=0)
        X_centered = X - self.mean_

        # 2. å…±åˆ†æ•£è¡Œåˆ—ã®è¨ˆç®—
        cov_matrix = (X_centered.T @ X_centered) / n_samples

        # 3. å›ºæœ‰å€¤åˆ†è§£
        eigenvalues, eigenvectors = np.linalg.eigh(cov_matrix)

        # 4. å›ºæœ‰å€¤ã®é™é †ã«ã‚½ãƒ¼ãƒˆ
        idx = eigenvalues.argsort()[::-1]
        eigenvalues = eigenvalues[idx]
        eigenvectors = eigenvectors[:, idx]

        # 5. ä¸»æˆåˆ†ã®é¸æŠ
        if self.n_components is None:
            self.n_components = n_features
        else:
            self.n_components = min(self.n_components, n_features)

        self.components_ = eigenvectors[:, :self.n_components].T
        self.explained_variance_ = eigenvalues[:self.n_components]
        self.explained_variance_ratio_ = (
            self.explained_variance_ / np.sum(eigenvalues)
        )

        return self

    def transform(self, X):
        """
        ãƒ‡ãƒ¼ã‚¿ã‚’ä¸»æˆåˆ†ç©ºé–“ã«å¤‰æ›

        Parameters:
        -----------
        X : ndarray of shape (n_samples, n_features)
            å…¥åŠ›ãƒ‡ãƒ¼ã‚¿

        Returns:
        --------
        ndarray of shape (n_samples, n_components)
            å¤‰æ›ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿
        """
        X = np.array(X)
        X_centered = X - self.mean_
        return X_centered @ self.components_.T

    def fit_transform(self, X):
        """fitã¨transformã‚’åŒæ™‚ã«å®Ÿè¡Œ"""
        return self.fit(X).transform(X)

    def inverse_transform(self, X_transformed):
        """
        ä¸»æˆåˆ†ç©ºé–“ã‹ã‚‰å…ƒã®ç©ºé–“ã«æˆ»ã™

        Parameters:
        -----------
        X_transformed : ndarray of shape (n_samples, n_components)
            å¤‰æ›ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿

        Returns:
        --------
        ndarray of shape (n_samples, n_features)
            å†æ§‹æˆã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿
        """
        return X_transformed @ self.components_ + self.mean_

    def reconstruction_error(self, X):
        """
        å†æ§‹æˆèª¤å·®ã‚’è¨ˆç®—

        Returns:
        --------
        float : å¹³å‡äºŒä¹—å†æ§‹æˆèª¤å·®
        """
        X_transformed = self.transform(X)
        X_reconstructed = self.inverse_transform(X_transformed)
        return np.mean((X - X_reconstructed) ** 2)

# ä½¿ç”¨ä¾‹ï¼š2æ¬¡å…ƒãƒ‡ãƒ¼ã‚¿ã§ã®å¯è¦–åŒ–
np.random.seed(42)

# ç›¸é–¢ã®ã‚ã‚‹2æ¬¡å…ƒãƒ‡ãƒ¼ã‚¿ã‚’ç”Ÿæˆ
mean = [0, 0]
cov = [[3, 1.5], [1.5, 1]]
X = np.random.multivariate_normal(mean, cov, 300)

# PCAã®å®Ÿè¡Œ
pca = PCA(n_components=2)
pca.fit(X)
X_pca = pca.transform(X)

print("=" * 60)
print("PCAçµæœ")
print("=" * 60)
print(f"ä¸»æˆåˆ†ï¼ˆå›ºæœ‰ãƒ™ã‚¯ãƒˆãƒ«ï¼‰:\n{pca.components_}")
print(f"èª¬æ˜åˆ†æ•£ï¼ˆå›ºæœ‰å€¤ï¼‰: {pca.explained_variance_}")
print(f"å¯„ä¸ç‡: {pca.explained_variance_ratio_}")
print(f"ç´¯ç©å¯„ä¸ç‡: {np.cumsum(pca.explained_variance_ratio_)}")

# å¯è¦–åŒ–
fig, axes = plt.subplots(1, 2, figsize=(14, 5))

# å…ƒã®ãƒ‡ãƒ¼ã‚¿ã¨ä¸»æˆåˆ†è»¸
ax1 = axes[0]
ax1.scatter(X[:, 0], X[:, 1], alpha=0.5, s=30)
ax1.set_xlabel('ç‰¹å¾´é‡1')
ax1.set_ylabel('ç‰¹å¾´é‡2')
ax1.set_title('å…ƒã®ãƒ‡ãƒ¼ã‚¿ã¨ä¸»æˆåˆ†è»¸')
ax1.grid(True, alpha=0.3)
ax1.axis('equal')

# ä¸»æˆåˆ†è»¸ã‚’æç”»
for i, (comp, var) in enumerate(zip(pca.components_, pca.explained_variance_)):
    ax1.arrow(0, 0, comp[0]*np.sqrt(var)*3, comp[1]*np.sqrt(var)*3,
             head_width=0.3, head_length=0.2, fc=f'C{i+1}', ec=f'C{i+1}',
             linewidth=2, label=f'PC{i+1} ({pca.explained_variance_ratio_[i]:.1%})')
ax1.legend()

# ä¸»æˆåˆ†ç©ºé–“ã§ã®ãƒ‡ãƒ¼ã‚¿
ax2 = axes[1]
ax2.scatter(X_pca[:, 0], X_pca[:, 1], alpha=0.5, s=30)
ax2.set_xlabel('ç¬¬1ä¸»æˆåˆ†')
ax2.set_ylabel('ç¬¬2ä¸»æˆåˆ†')
ax2.set_title('ä¸»æˆåˆ†ç©ºé–“ã§ã®ãƒ‡ãƒ¼ã‚¿')
ax2.grid(True, alpha=0.3)
ax2.axhline(y=0, color='k', linewidth=0.5)
ax2.axvline(x=0, color='k', linewidth=0.5)
ax2.axis('equal')

plt.tight_layout()
plt.savefig('pca_visualization.png', dpi=150, bbox_inches='tight')
print("\nPCAã®å¯è¦–åŒ–ã‚’ä¿å­˜ã—ã¾ã—ãŸ")

# æ¬¡å…ƒå‰Šæ¸›ã®åŠ¹æœ
print("\n" + "=" * 60)
print("æ¬¡å…ƒå‰Šæ¸›ã®åŠ¹æœ")
print("=" * 60)
for n_comp in [1, 2]:
    pca_reduced = PCA(n_components=n_comp)
    pca_reduced.fit(X)
    error = pca_reduced.reconstruction_error(X)
    cum_var = np.sum(pca_reduced.explained_variance_ratio_)
    print(f"{n_comp}æ¬¡å…ƒ: ç´¯ç©å¯„ä¸ç‡={cum_var:.2%}, å†æ§‹æˆèª¤å·®={error:.4f}")
</code></pre>

        <h2>4. ç·šå½¢å¤‰æ›ã¨å°„å½±</h2>

        <h3>4.1 ç·šå½¢å¤‰æ›ã®å¹¾ä½•å­¦</h3>

        <p>ç·šå½¢å¤‰æ›ã¯è¡Œåˆ—Aã«ã‚ˆã£ã¦ãƒ™ã‚¯ãƒˆãƒ«ã‚’å¤‰æ›ã™ã‚‹æ“ä½œã§ã™ï¼š</p>

        <div class="math-block">
            $$\mathbf{y} = \mathbf{A}\mathbf{x}$$
        </div>

        <p><strong>ä»£è¡¨çš„ãªç·šå½¢å¤‰æ›ï¼š</strong></p>
        <ul>
            <li><strong>å›è»¢</strong>: ç›´äº¤è¡Œåˆ—ã«ã‚ˆã‚‹å¤‰æ›ï¼ˆé•·ã•ä¿å­˜ï¼‰</li>
            <li><strong>æ‹¡å¤§ç¸®å°</strong>: å¯¾è§’è¡Œåˆ—ã«ã‚ˆã‚‹å¤‰æ›</li>
            <li><strong>ã›ã‚“æ–­</strong>: éå¯¾è§’æˆåˆ†ã‚’æŒã¤å¤‰æ›</li>
            <li><strong>å°„å½±</strong>: éƒ¨åˆ†ç©ºé–“ã¸ã®æŠ•å½±</li>
        </ul>

        <h3>4.2 å°„å½±è¡Œåˆ—</h3>

        <p>ãƒ™ã‚¯ãƒˆãƒ«bã‚’åˆ—ç©ºé–“C(A)ã«å°„å½±ã™ã‚‹å°„å½±è¡Œåˆ—ã¯ï¼š</p>

        <div class="math-block">
            $$\mathbf{P} = \mathbf{A}(\mathbf{A}^T\mathbf{A})^{-1}\mathbf{A}^T$$
        </div>

        <p>å°„å½±ãƒ™ã‚¯ãƒˆãƒ«ã¯ p = Pb ã§ã€æ®‹å·®ã¯ e = b - p ã§ã™ã€‚</p>

        <p><strong>å°„å½±è¡Œåˆ—ã®æ€§è³ªï¼š</strong></p>
        <ul>
            <li>å¯¾ç§°æ€§: P^T = P</li>
            <li>å†ªç­‰æ€§: PÂ² = P</li>
            <li>æ®‹å·®ã®ç›´äº¤æ€§: A^T(b - Pb) = 0</li>
        </ul>

        <div class="info-box">
            <strong>æœ€å°äºŒä¹—æ³•ã¨ã®é–¢ä¿‚</strong>
            ç·šå½¢å›å¸°ã®æœ€å°äºŒä¹—è§£ã¯ã€yã‚’X ã®åˆ—ç©ºé–“ã«å°„å½±ã™ã‚‹ã“ã¨ã§å¾—ã‚‰ã‚Œã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€æ®‹å·®ãŒåˆ—ç©ºé–“ã¨ç›´äº¤ã™ã‚‹ã“ã¨ãŒä¿è¨¼ã•ã‚Œã¾ã™ã€‚
        </div>

        <h3>å®Ÿè£…ä¾‹4ï¼šç·šå½¢å¤‰æ›ã¨å°„å½±ã®å¯è¦–åŒ–</h3>

<pre><code>import numpy as np
import matplotlib.pyplot as plt

class LinearTransformation:
    """ç·šå½¢å¤‰æ›ã¨å°„å½±ã®å®Ÿè£…"""

    @staticmethod
    def rotation_matrix(theta):
        """
        2æ¬¡å…ƒå›è»¢è¡Œåˆ—

        Parameters:
        -----------
        theta : float
            å›è»¢è§’ï¼ˆãƒ©ã‚¸ã‚¢ãƒ³ï¼‰

        Returns:
        --------
        ndarray : 2x2å›è»¢è¡Œåˆ—
        """
        c, s = np.cos(theta), np.sin(theta)
        return np.array([[c, -s], [s, c]])

    @staticmethod
    def scaling_matrix(sx, sy):
        """
        2æ¬¡å…ƒã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°è¡Œåˆ—

        Parameters:
        -----------
        sx, sy : float
            xæ–¹å‘ã€yæ–¹å‘ã®ã‚¹ã‚±ãƒ¼ãƒ«

        Returns:
        --------
        ndarray : 2x2ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°è¡Œåˆ—
        """
        return np.array([[sx, 0], [0, sy]])

    @staticmethod
    def projection_matrix(A):
        """
        åˆ—ç©ºé–“ã¸ã®å°„å½±è¡Œåˆ—: P = A(A^T A)^(-1)A^T

        Parameters:
        -----------
        A : ndarray of shape (m, n)
            åŸºåº•ã‚’åˆ—ã«æŒã¤è¡Œåˆ—

        Returns:
        --------
        ndarray of shape (m, m) : å°„å½±è¡Œåˆ—
        """
        A = np.array(A)
        return A @ np.linalg.inv(A.T @ A) @ A.T

    @staticmethod
    def project_onto_subspace(b, A):
        """
        ãƒ™ã‚¯ãƒˆãƒ«bã‚’A ã®åˆ—ç©ºé–“ã«å°„å½±

        Parameters:
        -----------
        b : ndarray
            å°„å½±ã™ã‚‹ãƒ™ã‚¯ãƒˆãƒ«
        A : ndarray
            éƒ¨åˆ†ç©ºé–“ã‚’å¼µã‚‹è¡Œåˆ—

        Returns:
        --------
        projection : ndarray
            å°„å½±ãƒ™ã‚¯ãƒˆãƒ«
        residual : ndarray
            æ®‹å·®ãƒ™ã‚¯ãƒˆãƒ«
        """
        P = LinearTransformation.projection_matrix(A)
        projection = P @ b
        residual = b - projection
        return projection, residual

# å¯è¦–åŒ–ä¾‹ï¼šç·šå½¢å¤‰æ›
print("=" * 60)
print("ç·šå½¢å¤‰æ›ã®å¯è¦–åŒ–")
print("=" * 60)

# å˜ä½æ­£æ–¹å½¢ã®é ‚ç‚¹
square = np.array([[0, 1, 1, 0, 0],
                   [0, 0, 1, 1, 0]])

# å„ç¨®å¤‰æ›
transformations = {
    'å›è»¢ (45Â°)': LinearTransformation.rotation_matrix(np.pi/4),
    'ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚° (2, 0.5)': LinearTransformation.scaling_matrix(2, 0.5),
    'ã›ã‚“æ–­': np.array([[1, 0.5], [0, 1]]),
    'è¤‡åˆå¤‰æ›': LinearTransformation.rotation_matrix(np.pi/6) @ \
                LinearTransformation.scaling_matrix(1.5, 0.8)
}

fig, axes = plt.subplots(2, 2, figsize=(12, 12))
axes = axes.ravel()

for idx, (name, A) in enumerate(transformations.items()):
    ax = axes[idx]

    # å…ƒã®å›³å½¢
    ax.plot(square[0], square[1], 'b-', linewidth=2, label='å…ƒã®å›³å½¢')
    ax.fill(square[0], square[1], 'blue', alpha=0.2)

    # å¤‰æ›å¾Œã®å›³å½¢
    transformed = A @ square
    ax.plot(transformed[0], transformed[1], 'r-', linewidth=2, label='å¤‰æ›å¾Œ')
    ax.fill(transformed[0], transformed[1], 'red', alpha=0.2)

    # åŸºåº•ãƒ™ã‚¯ãƒˆãƒ«ã®å¤‰æ›
    basis = np.array([[1, 0], [0, 1]]).T
    transformed_basis = A @ basis
    for i in range(2):
        ax.arrow(0, 0, transformed_basis[0, i], transformed_basis[1, i],
                head_width=0.1, head_length=0.1, fc=f'C{i+2}', ec=f'C{i+2}',
                linewidth=2)

    ax.set_xlabel('x')
    ax.set_ylabel('y')
    ax.set_title(f'{name}\nè¡Œåˆ—å¼: {np.linalg.det(A):.2f}')
    ax.grid(True, alpha=0.3)
    ax.legend()
    ax.set_aspect('equal')
    ax.set_xlim(-2, 3)
    ax.set_ylim(-2, 3)

plt.tight_layout()
plt.savefig('linear_transformations.png', dpi=150, bbox_inches='tight')
print("ç·šå½¢å¤‰æ›ã®å¯è¦–åŒ–ã‚’ä¿å­˜ã—ã¾ã—ãŸ")

# å°„å½±ã®ä¾‹
print("\n" + "=" * 60)
print("å°„å½±ã®è¨ˆç®—")
print("=" * 60)

# 2æ¬¡å…ƒã§ã®1æ¬¡å…ƒéƒ¨åˆ†ç©ºé–“ã¸ã®å°„å½±
a = np.array([[1], [2]])  # éƒ¨åˆ†ç©ºé–“ã®åŸºåº•
b = np.array([3, 2])      # å°„å½±ã™ã‚‹ãƒ™ã‚¯ãƒˆãƒ«

proj, resid = LinearTransformation.project_onto_subspace(b, a)

print(f"åŸºåº•ãƒ™ã‚¯ãƒˆãƒ« a: {a.flatten()}")
print(f"ãƒ™ã‚¯ãƒˆãƒ« b: {b}")
print(f"å°„å½± p: {proj}")
print(f"æ®‹å·® e: {resid}")
print(f"å†…ç© a^T e (ç›´äº¤æ€§ã®ç¢ºèª): {a.T @ resid}")
print(f"||b||Â²: {np.linalg.norm(b)**2:.4f}")
print(f"||p||Â² + ||e||Â²: {np.linalg.norm(proj)**2 + np.linalg.norm(resid)**2:.4f}")

# å°„å½±ã®å¯è¦–åŒ–
plt.figure(figsize=(8, 8))
plt.arrow(0, 0, b[0], b[1], head_width=0.2, head_length=0.2,
         fc='blue', ec='blue', linewidth=2, label='å…ƒã®ãƒ™ã‚¯ãƒˆãƒ« b')
plt.arrow(0, 0, proj[0], proj[1], head_width=0.2, head_length=0.2,
         fc='green', ec='green', linewidth=2, label='å°„å½± p')
plt.arrow(0, 0, a[0, 0]*2, a[1, 0]*2, head_width=0.2, head_length=0.2,
         fc='red', ec='red', linewidth=2, linestyle='--', label='éƒ¨åˆ†ç©ºé–“ã®åŸºåº•')
plt.plot([proj[0], b[0]], [proj[1], b[1]], 'k--', linewidth=1, label='æ®‹å·® e')

plt.xlabel('x')
plt.ylabel('y')
plt.title('ãƒ™ã‚¯ãƒˆãƒ«ã®éƒ¨åˆ†ç©ºé–“ã¸ã®å°„å½±')
plt.grid(True, alpha=0.3)
plt.legend()
plt.axis('equal')
plt.xlim(-1, 4)
plt.ylim(-1, 5)
plt.savefig('projection_visualization.png', dpi=150, bbox_inches='tight')
print("å°„å½±ã®å¯è¦–åŒ–ã‚’ä¿å­˜ã—ã¾ã—ãŸ")
</code></pre>

        <h2>5. å®Ÿè·µå¿œç”¨</h2>

        <h3>5.1 ç·šå½¢å›å¸°ã®ç·šå½¢ä»£æ•°çš„è§£æ³•</h3>

        <p>ç·šå½¢å›å¸°ã®ç›®çš„ã¯ã€æœ€å°äºŒä¹—èª¤å·®ã‚’æœ€å°åŒ–ã™ã‚‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿wã‚’è¦‹ã¤ã‘ã‚‹ã“ã¨ã§ã™ï¼š</p>

        <div class="math-block">
            $$\min_{\mathbf{w}} \|\mathbf{y} - \mathbf{Xw}\|^2$$
        </div>

        <p>æ­£è¦æ–¹ç¨‹å¼ã«ã‚ˆã‚‹è§£ï¼š</p>

        <div class="math-block">
            $$\mathbf{w}^* = (\mathbf{X}^T\mathbf{X})^{-1}\mathbf{X}^T\mathbf{y}$$
        </div>

        <p>ã“ã‚Œã¯ã€yã‚’Xã®åˆ—ç©ºé–“ã«å°„å½±ã™ã‚‹æ“ä½œã¨ç­‰ä¾¡ã§ã™ã€‚</p>

        <h3>5.2 Ridgeå›å¸°ï¼ˆL2æ­£å‰‡åŒ–ï¼‰</h3>

        <p>Ridgeå›å¸°ã¯ã€éå­¦ç¿’ã‚’é˜²ããŸã‚ã«L2æ­£å‰‡åŒ–é …ã‚’è¿½åŠ ã—ã¾ã™ï¼š</p>

        <div class="math-block">
            $$\min_{\mathbf{w}} \|\mathbf{y} - \mathbf{Xw}\|^2 + \lambda\|\mathbf{w}\|^2$$
        </div>

        <p>è§£ã¯ä»¥ä¸‹ã®å½¢ã«ãªã‚Šã¾ã™ï¼š</p>

        <div class="math-block">
            $$\mathbf{w}_{ridge} = (\mathbf{X}^T\mathbf{X} + \lambda\mathbf{I})^{-1}\mathbf{X}^T\mathbf{y}$$
        </div>

        <p>Î»ãŒå¤§ãã„ã»ã©ã€ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®å¤§ãã•ãŒåˆ¶é™ã•ã‚Œã¾ã™ã€‚</p>

        <h3>å®Ÿè£…ä¾‹5ï¼šç·šå½¢å›å¸°ã¨Ridgeå›å¸°ã®å®Ÿè£…</h3>

<pre><code>import numpy as np
import matplotlib.pyplot as plt

class LinearRegression:
    """ç·šå½¢å›å¸°ã®å®Ÿè£…ï¼ˆè¡Œåˆ—æ¼”ç®—ã«ã‚ˆã‚‹ï¼‰"""

    def __init__(self, fit_intercept=True):
        """
        Parameters:
        -----------
        fit_intercept : bool
            åˆ‡ç‰‡ã‚’å«ã‚ã‚‹ã‹
        """
        self.fit_intercept = fit_intercept
        self.coef_ = None
        self.intercept_ = None

    def fit(self, X, y):
        """
        æ­£è¦æ–¹ç¨‹å¼ã§æœ€å°äºŒä¹—è§£ã‚’è¨ˆç®—: w = (X^T X)^(-1) X^T y

        Parameters:
        -----------
        X : ndarray of shape (n_samples, n_features)
            ç‰¹å¾´é‡è¡Œåˆ—
        y : ndarray of shape (n_samples,)
            ç›®çš„å¤‰æ•°

        Returns:
        --------
        self
        """
        X, y = np.array(X), np.array(y).reshape(-1, 1)

        if self.fit_intercept:
            # åˆ‡ç‰‡é …ã‚’è¿½åŠ 
            X = np.hstack([np.ones((X.shape[0], 1)), X])

        # æ­£è¦æ–¹ç¨‹å¼: (X^T X) w = X^T y
        XtX = X.T @ X
        Xty = X.T @ y
        w = np.linalg.solve(XtX, Xty)

        if self.fit_intercept:
            self.intercept_ = w[0, 0]
            self.coef_ = w[1:].flatten()
        else:
            self.intercept_ = 0
            self.coef_ = w.flatten()

        return self

    def predict(self, X):
        """äºˆæ¸¬"""
        X = np.array(X)
        return X @ self.coef_ + self.intercept_

class RidgeRegression:
    """Ridgeå›å¸°ã®å®Ÿè£…ï¼ˆL2æ­£å‰‡åŒ–ï¼‰"""

    def __init__(self, alpha=1.0, fit_intercept=True):
        """
        Parameters:
        -----------
        alpha : float
            æ­£å‰‡åŒ–ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ï¼ˆÎ»ï¼‰
        fit_intercept : bool
            åˆ‡ç‰‡ã‚’å«ã‚ã‚‹ã‹
        """
        self.alpha = alpha
        self.fit_intercept = fit_intercept
        self.coef_ = None
        self.intercept_ = None

    def fit(self, X, y):
        """
        Ridgeå›å¸°ã®è§£ã‚’è¨ˆç®—: w = (X^T X + Î»I)^(-1) X^T y

        Parameters:
        -----------
        X : ndarray of shape (n_samples, n_features)
            ç‰¹å¾´é‡è¡Œåˆ—
        y : ndarray of shape (n_samples,)
            ç›®çš„å¤‰æ•°

        Returns:
        --------
        self
        """
        X, y = np.array(X), np.array(y).reshape(-1, 1)

        if self.fit_intercept:
            X = np.hstack([np.ones((X.shape[0], 1)), X])

        # Ridgeå›å¸°ã®è§£
        n_features = X.shape[1]
        ridge_matrix = X.T @ X + self.alpha * np.eye(n_features)

        # åˆ‡ç‰‡ã«ã¯æ­£å‰‡åŒ–ã‚’é©ç”¨ã—ãªã„
        if self.fit_intercept:
            ridge_matrix[0, 0] = X.T[0] @ X[:, 0]

        w = np.linalg.solve(ridge_matrix, X.T @ y)

        if self.fit_intercept:
            self.intercept_ = w[0, 0]
            self.coef_ = w[1:].flatten()
        else:
            self.intercept_ = 0
            self.coef_ = w.flatten()

        return self

    def predict(self, X):
        """äºˆæ¸¬"""
        X = np.array(X)
        return X @ self.coef_ + self.intercept_

# ä½¿ç”¨ä¾‹ã¨QRåˆ†è§£ã«ã‚ˆã‚‹è§£æ³•ã®æ¯”è¼ƒ
def solve_with_qr(X, y):
    """QRåˆ†è§£ã‚’ä½¿ã£ãŸæ•°å€¤çš„ã«å®‰å®šãªæœ€å°äºŒä¹—è§£"""
    Q, R = np.linalg.qr(X)
    return np.linalg.solve(R, Q.T @ y)

# ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆ
np.random.seed(42)
n_samples = 100
X = np.random.randn(n_samples, 1)
y_true = 3 * X.squeeze() + 2
y = y_true + np.random.randn(n_samples) * 0.5

# ç·šå½¢å›å¸°
lr = LinearRegression()
lr.fit(X, y)
y_pred_lr = lr.predict(X)

print("=" * 60)
print("ç·šå½¢å›å¸°ã®çµæœ")
print("=" * 60)
print(f"ä¿‚æ•°: {lr.coef_}")
print(f"åˆ‡ç‰‡: {lr.intercept_:.4f}")
print(f"MSE: {np.mean((y - y_pred_lr)**2):.4f}")

# Ridgeå›å¸°ï¼ˆç•°ãªã‚‹Î±ã§æ¯”è¼ƒï¼‰
alphas = [0.01, 0.1, 1.0, 10.0]
ridge_models = []

print("\n" + "=" * 60)
print("Ridgeå›å¸°ã®çµæœ")
print("=" * 60)

for alpha in alphas:
    ridge = RidgeRegression(alpha=alpha)
    ridge.fit(X, y)
    y_pred = ridge.predict(X)
    mse = np.mean((y - y_pred)**2)
    ridge_models.append(ridge)
    print(f"Î±={alpha:5.2f}: ä¿‚æ•°={ridge.coef_[0]:6.3f}, "
          f"åˆ‡ç‰‡={ridge.intercept_:6.3f}, MSE={mse:.4f}")

# å¯è¦–åŒ–
plt.figure(figsize=(14, 5))

# å·¦å›³: ç·šå½¢å›å¸°
plt.subplot(1, 2, 1)
plt.scatter(X, y, alpha=0.5, s=30, label='ãƒ‡ãƒ¼ã‚¿')
plt.plot(X, y_true, 'g--', linewidth=2, label='çœŸã®é–¢æ•°')
plt.plot(X, y_pred_lr, 'r-', linewidth=2, label='ç·šå½¢å›å¸°')
plt.xlabel('x')
plt.ylabel('y')
plt.title('ç·šå½¢å›å¸°')
plt.legend()
plt.grid(True, alpha=0.3)

# å³å›³: Ridgeå›å¸°ã®æ¯”è¼ƒ
plt.subplot(1, 2, 2)
plt.scatter(X, y, alpha=0.5, s=30, label='ãƒ‡ãƒ¼ã‚¿')
plt.plot(X, y_true, 'g--', linewidth=2, label='çœŸã®é–¢æ•°')
X_sorted = np.sort(X, axis=0)
for ridge, alpha in zip(ridge_models, alphas):
    y_line = ridge.predict(X_sorted)
    plt.plot(X_sorted, y_line, linewidth=2, label=f'Ridge (Î±={alpha})')
plt.xlabel('x')
plt.ylabel('y')
plt.title('Ridgeå›å¸°ï¼ˆæ­£å‰‡åŒ–ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®å½±éŸ¿ï¼‰')
plt.legend()
plt.grid(True, alpha=0.3)

plt.tight_layout()
plt.savefig('linear_ridge_regression.png', dpi=150, bbox_inches='tight')
print("\nå›å¸°çµæœã®å¯è¦–åŒ–ã‚’ä¿å­˜ã—ã¾ã—ãŸ")

# å¤šé‡å…±ç·šæ€§ã®ä¾‹
print("\n" + "=" * 60)
print("å¤šé‡å…±ç·šæ€§ã®ä¾‹")
print("=" * 60)

# é«˜åº¦ã«ç›¸é–¢ã—ãŸç‰¹å¾´é‡ã‚’ç”Ÿæˆ
X_corr = np.random.randn(50, 1)
X_multi = np.hstack([X_corr, X_corr + np.random.randn(50, 1) * 0.1, X_corr * 2])
y_multi = X_corr.squeeze() + np.random.randn(50) * 0.5

# ç·šå½¢å›å¸°ï¼ˆä¸å®‰å®šï¼‰
lr_multi = LinearRegression()
lr_multi.fit(X_multi, y_multi)

# Ridgeå›å¸°ï¼ˆå®‰å®šï¼‰
ridge_multi = RidgeRegression(alpha=1.0)
ridge_multi.fit(X_multi, y_multi)

print("ç·šå½¢å›å¸°ã®ä¿‚æ•°:", lr_multi.coef_)
print("Ridgeå›å¸°ã®ä¿‚æ•°:", ridge_multi.coef_)
print("ä¿‚æ•°ã®L2ãƒãƒ«ãƒ :")
print(f"  ç·šå½¢å›å¸°: {np.linalg.norm(lr_multi.coef_):.4f}")
print(f"  Ridgeå›å¸°: {np.linalg.norm(ridge_multi.coef_):.4f}")
</code></pre>

        <h3>5.3 ç”»åƒãƒ‡ãƒ¼ã‚¿ã¸ã®PCAé©ç”¨</h3>

        <p>PCAã¯ç”»åƒã®æ¬¡å…ƒå‰Šæ¸›ã¨åœ§ç¸®ã«åºƒãä½¿ç”¨ã•ã‚Œã¾ã™ã€‚å„ãƒ”ã‚¯ã‚»ãƒ«ã‚’ç‰¹å¾´é‡ã¨ã—ã¦æ‰±ã„ã¾ã™ã€‚</p>

        <h3>å®Ÿè£…ä¾‹6ï¼šç”»åƒåœ§ç¸®ã¸ã®PCA/SVDã®é©ç”¨</h3>

<pre><code>import numpy as np
import matplotlib.pyplot as plt

class ImageCompressionPCA:
    """ç”»åƒåœ§ç¸®ã®ãŸã‚ã®PCA/SVDå®Ÿè£…"""

    @staticmethod
    def compress_with_svd(image, n_components):
        """
        SVDã‚’ä½¿ã£ãŸç”»åƒåœ§ç¸®

        Parameters:
        -----------
        image : ndarray of shape (height, width)
            ã‚°ãƒ¬ãƒ¼ã‚¹ã‚±ãƒ¼ãƒ«ç”»åƒ
        n_components : int
            ä¿æŒã™ã‚‹ç‰¹ç•°å€¤ã®æ•°

        Returns:
        --------
        compressed : ndarray
            åœ§ç¸®ã•ã‚ŒãŸç”»åƒ
        compression_ratio : float
            åœ§ç¸®ç‡
        """
        # SVDåˆ†è§£
        U, S, Vt = np.linalg.svd(image, full_matrices=False)

        # ä¸Šä½n_componentså€‹ã®ã¿ä½¿ç”¨
        U_k = U[:, :n_components]
        S_k = S[:n_components]
        Vt_k = Vt[:n_components, :]

        # å†æ§‹æˆ
        compressed = U_k @ np.diag(S_k) @ Vt_k

        # åœ§ç¸®ç‡ã®è¨ˆç®—
        original_size = image.shape[0] * image.shape[1]
        compressed_size = n_components * (image.shape[0] + image.shape[1] + 1)
        compression_ratio = compressed_size / original_size

        return compressed, compression_ratio

    @staticmethod
    def analyze_singular_values(image):
        """
        ç‰¹ç•°å€¤ã®åˆ†æ

        Returns:
        --------
        singular_values : ndarray
            ç‰¹ç•°å€¤
        cumulative_energy : ndarray
            ç´¯ç©ã‚¨ãƒãƒ«ã‚®ãƒ¼
        """
        _, S, _ = np.linalg.svd(image, full_matrices=False)

        # ã‚¨ãƒãƒ«ã‚®ãƒ¼ï¼ˆå„ç‰¹ç•°å€¤ã®2ä¹—ï¼‰
        energy = S ** 2
        total_energy = np.sum(energy)
        cumulative_energy = np.cumsum(energy) / total_energy

        return S, cumulative_energy

# ä½¿ç”¨ä¾‹ï¼šåˆæˆç”»åƒã§ã®å®Ÿé¨“
print("=" * 60)
print("ç”»åƒåœ§ç¸®ã®å®Ÿé¨“")
print("=" * 60)

# åˆæˆç”»åƒã®ç”Ÿæˆï¼ˆã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã¨ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼‰
height, width = 200, 200
x = np.linspace(-5, 5, width)
y = np.linspace(-5, 5, height)
X, Y = np.meshgrid(x, y)

# è¤‡é›‘ãªãƒ‘ã‚¿ãƒ¼ãƒ³ã®ç”»åƒ
image = (np.sin(X) * np.cos(Y) +
         0.5 * np.sin(2*X + Y) +
         0.3 * np.cos(X - 2*Y))
image = (image - image.min()) / (image.max() - image.min())  # æ­£è¦åŒ–

# ç‰¹ç•°å€¤ã®åˆ†æ
compressor = ImageCompressionPCA()
singular_values, cumulative_energy = compressor.analyze_singular_values(image)

print(f"ç”»åƒã‚µã‚¤ã‚º: {image.shape}")
print(f"ç·ç‰¹ç•°å€¤æ•°: {len(singular_values)}")
print(f"90%ã‚¨ãƒãƒ«ã‚®ãƒ¼ã«å¿…è¦ãªæˆåˆ†æ•°: {np.argmax(cumulative_energy >= 0.90) + 1}")
print(f"99%ã‚¨ãƒãƒ«ã‚®ãƒ¼ã«å¿…è¦ãªæˆåˆ†æ•°: {np.argmax(cumulative_energy >= 0.99) + 1}")

# ç•°ãªã‚‹åœ§ç¸®ç‡ã§ã®æ¯”è¼ƒ
n_components_list = [5, 10, 20, 50]

fig, axes = plt.subplots(2, 3, figsize=(15, 10))
axes = axes.ravel()

# å…ƒç”»åƒ
axes[0].imshow(image, cmap='gray')
axes[0].set_title('å…ƒç”»åƒ')
axes[0].axis('off')

# åœ§ç¸®ç”»åƒ
for idx, n_comp in enumerate(n_components_list, 1):
    compressed, comp_ratio = compressor.compress_with_svd(image, n_comp)

    axes[idx].imshow(compressed, cmap='gray')

    # PSNRã®è¨ˆç®—
    mse = np.mean((image - compressed) ** 2)
    psnr = 10 * np.log10(1.0 / mse) if mse > 0 else float('inf')

    energy_retained = cumulative_energy[n_comp - 1]

    axes[idx].set_title(f'æˆåˆ†æ•°: {n_comp}\n'
                       f'åœ§ç¸®ç‡: {comp_ratio:.1%}\n'
                       f'PSNR: {psnr:.1f}dB\n'
                       f'ã‚¨ãƒãƒ«ã‚®ãƒ¼: {energy_retained:.1%}')
    axes[idx].axis('off')

# ç‰¹ç•°å€¤ã®æ¸›è¡°ã‚’ãƒ—ãƒ­ãƒƒãƒˆ
axes[5].plot(singular_values[:100], 'b-', linewidth=2)
axes[5].set_xlabel('æˆåˆ†ç•ªå·')
axes[5].set_ylabel('ç‰¹ç•°å€¤')
axes[5].set_title('ç‰¹ç•°å€¤ã®æ¸›è¡°')
axes[5].grid(True, alpha=0.3)
axes[5].set_yscale('log')

plt.tight_layout()
plt.savefig('image_compression_pca.png', dpi=150, bbox_inches='tight')
print("\nç”»åƒåœ§ç¸®ã®å¯è¦–åŒ–ã‚’ä¿å­˜ã—ã¾ã—ãŸ")

# ç´¯ç©ã‚¨ãƒãƒ«ã‚®ãƒ¼ã®ãƒ—ãƒ­ãƒƒãƒˆ
plt.figure(figsize=(10, 6))
plt.plot(cumulative_energy[:100], linewidth=2)
plt.axhline(y=0.9, color='r', linestyle='--', label='90%ã‚¨ãƒãƒ«ã‚®ãƒ¼')
plt.axhline(y=0.99, color='g', linestyle='--', label='99%ã‚¨ãƒãƒ«ã‚®ãƒ¼')
plt.xlabel('æˆåˆ†æ•°')
plt.ylabel('ç´¯ç©ã‚¨ãƒãƒ«ã‚®ãƒ¼')
plt.title('SVDæˆåˆ†ã®ç´¯ç©ã‚¨ãƒãƒ«ã‚®ãƒ¼')
plt.legend()
plt.grid(True, alpha=0.3)
plt.savefig('cumulative_energy.png', dpi=150, bbox_inches='tight')
print("ç´¯ç©ã‚¨ãƒãƒ«ã‚®ãƒ¼ãƒ—ãƒ­ãƒƒãƒˆã‚’ä¿å­˜ã—ã¾ã—ãŸ")

# å®Ÿç”¨çš„ãªåœ§ç¸®ç‡ã®åˆ†æ
print("\n" + "=" * 60)
print("åœ§ç¸®ç‡ã¨PSNRã®é–¢ä¿‚")
print("=" * 60)
print(f"{'æˆåˆ†æ•°':>8} {'åœ§ç¸®ç‡':>10} {'PSNR (dB)':>12} {'ã‚¨ãƒãƒ«ã‚®ãƒ¼':>12}")
print("-" * 60)

for n_comp in [1, 2, 5, 10, 20, 50, 100]:
    if n_comp <= min(image.shape):
        compressed, comp_ratio = compressor.compress_with_svd(image, n_comp)
        mse = np.mean((image - compressed) ** 2)
        psnr = 10 * np.log10(1.0 / mse) if mse > 0 else float('inf')
        energy = cumulative_energy[n_comp - 1]
        print(f"{n_comp:8d} {comp_ratio:9.1%} {psnr:11.2f} {energy:11.1%}")
</code></pre>

        <h2>ã¾ã¨ã‚</h2>

        <p>ã“ã®ç« ã§ã¯ã€æ©Ÿæ¢°å­¦ç¿’ã®æ•°å­¦çš„åŸºç›¤ã¨ãªã‚‹ç·šå½¢ä»£æ•°ã‚’å­¦ã³ã¾ã—ãŸã€‚</p>

        <div class="info-box">
            <strong>å­¦ç¿’ã—ãŸå†…å®¹</strong>
            <ul style="margin-left: 1.5rem; margin-bottom: 0;">
                <li><strong>ãƒ™ã‚¯ãƒˆãƒ«ã¨è¡Œåˆ—</strong>: å†…ç©ã€ãƒãƒ«ãƒ ã€è¡Œåˆ—æ¼”ç®—ã®å¹¾ä½•çš„æ„å‘³</li>
                <li><strong>è¡Œåˆ—åˆ†è§£</strong>: å›ºæœ‰å€¤åˆ†è§£ã€SVDã€QRåˆ†è§£ã®ç†è«–ã¨å®Ÿè£…</li>
                <li><strong>ä¸»æˆåˆ†åˆ†æ</strong>: ãƒ‡ãƒ¼ã‚¿ã®åˆ†æ•£ã‚’æœ€å¤§åŒ–ã™ã‚‹æ¬¡å…ƒå‰Šæ¸›æ‰‹æ³•</li>
                <li><strong>ç·šå½¢å¤‰æ›ã¨å°„å½±</strong>: æœ€å°äºŒä¹—æ³•ã®å¹¾ä½•å­¦çš„ç†è§£</li>
                <li><strong>å®Ÿè·µå¿œç”¨</strong>: ç·šå½¢å›å¸°ã€Ridgeå›å¸°ã€ç”»åƒåœ§ç¸®</li>
            </ul>
        </div>

        <div class="warning-box">
            <strong>æ¬¡ç« ã¸ã®æº–å‚™</strong>
            ç¬¬3ç« ã§ã¯ã€æœ€é©åŒ–ç†è«–ã‚’å­¦ã³ã¾ã™ã€‚ç·šå½¢å›å¸°ã®æ­£è¦æ–¹ç¨‹å¼ã¯æœ€é©åŒ–å•é¡Œã®è§£æè§£ã§ã™ãŒã€æ¬¡ç« ã§ã¯å‹¾é…é™ä¸‹æ³•ãªã©ã®æ•°å€¤çš„è§£æ³•ã‚’å­¦ã³ã€ãƒ‹ãƒ¥ãƒ¼ãƒ©ãƒ«ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã®å­¦ç¿’ã«é©ç”¨ã—ã¾ã™ã€‚
        </div>

        <h3>è¡Œåˆ—åˆ†è§£ã®æ¯”è¼ƒ</h3>

        <table>
            <thead>
                <tr>
                    <th>åˆ†è§£æ³•</th>
                    <th>å½¢å¼</th>
                    <th>å¯¾è±¡è¡Œåˆ—</th>
                    <th>ä¸»ãªç”¨é€”</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>å›ºæœ‰å€¤åˆ†è§£</td>
                    <td>A = QÎ›Q^T</td>
                    <td>æ­£æ–¹å¯¾ç§°è¡Œåˆ—</td>
                    <td>PCAã€ã‚°ãƒ©ãƒ•è§£æ</td>
                </tr>
                <tr>
                    <td>SVD</td>
                    <td>A = UÎ£V^T</td>
                    <td>ä»»æ„ã®è¡Œåˆ—</td>
                    <td>æ¬¡å…ƒå‰Šæ¸›ã€æ¨è–¦ã‚·ã‚¹ãƒ†ãƒ </td>
                </tr>
                <tr>
                    <td>QRåˆ†è§£</td>
                    <td>A = QR</td>
                    <td>ä»»æ„ã®è¡Œåˆ—</td>
                    <td>æœ€å°äºŒä¹—æ³•ã€å›ºæœ‰å€¤è¨ˆç®—</td>
                </tr>
                <tr>
                    <td>ã‚³ãƒ¬ã‚¹ã‚­ãƒ¼åˆ†è§£</td>
                    <td>A = LL^T</td>
                    <td>æ­£å®šå€¤å¯¾ç§°è¡Œåˆ—</td>
                    <td>ç·šå½¢ã‚·ã‚¹ãƒ†ãƒ ã€ã‚¬ã‚¦ã‚¹éç¨‹</td>
                </tr>
            </tbody>
        </table>

        <h3>æ¼”ç¿’å•é¡Œ</h3>

        <ol>
            <li>2ã¤ã®ãƒ™ã‚¯ãƒˆãƒ«ãŒç›´äº¤ã™ã‚‹ã¨ãã€ã‚³ã‚µã‚¤ãƒ³é¡ä¼¼åº¦ãŒã©ã†ãªã‚‹ã‹ç¢ºèªã—ã¦ãã ã•ã„</li>
            <li>3Ã—3ã®å¯¾ç§°è¡Œåˆ—ã‚’ä½œæˆã—ã€å›ºæœ‰å€¤åˆ†è§£ã—ã¦å†æ§‹æˆèª¤å·®ã‚’ç¢ºèªã—ã¦ãã ã•ã„</li>
            <li>ãƒ©ãƒ³ãƒ€ãƒ ãª5Ã—3è¡Œåˆ—ã§SVDã‚’å®Ÿè¡Œã—ã€ãƒ©ãƒ³ã‚¯2è¿‘ä¼¼ã‚’ä½œæˆã—ã¦ãã ã•ã„</li>
            <li>3æ¬¡å…ƒãƒ‡ãƒ¼ã‚¿ã§PCAã‚’å®Ÿè¡Œã—ã€2æ¬¡å…ƒã«æ¬¡å…ƒå‰Šæ¸›ã—ã¦å¯è¦–åŒ–ã—ã¦ãã ã•ã„</li>
            <li>å¤šé …å¼å›å¸°ï¼ˆ2æ¬¡ã€3æ¬¡ï¼‰ã§Ridgeå›å¸°ã®æ­£å‰‡åŒ–åŠ¹æœã‚’æ¯”è¼ƒã—ã¦ãã ã•ã„</li>
            <li>å®Ÿéš›ã®ç”»åƒãƒ‡ãƒ¼ã‚¿ï¼ˆã‚°ãƒ¬ãƒ¼ã‚¹ã‚±ãƒ¼ãƒ«ï¼‰ã«SVDã‚’é©ç”¨ã—ã€æœ€é©ãªåœ§ç¸®ç‡ã‚’è¦‹ã¤ã‘ã¦ãã ã•ã„</li>
        </ol>

        <h3>å‚è€ƒæ–‡çŒ®</h3>

        <ul>
            <li>G. Strang, "Linear Algebra and Its Applications" (2016)</li>
            <li>L.N. Trefethen and D. Bau, "Numerical Linear Algebra" (1997)</li>
            <li>æ–è—¤æ­£å½¦, "ç·šå‹ä»£æ•°å…¥é–€" æ±äº¬å¤§å­¦å‡ºç‰ˆä¼š (1966)</li>
            <li>I. Goodfellow et al., "Deep Learning" Chapter 2 (2016)</li>
        </ul>

        <div class="nav-buttons">
            <a href="./chapter1-probability-statistics.html" class="nav-button">â† ç¬¬1ç« ï¼šç¢ºç‡çµ±è¨ˆã®åŸºç¤</a>
            <a href="./chapter3-optimization.html" class="nav-button">ç¬¬3ç« ï¼šæœ€é©åŒ–ç†è«– â†’</a>
        </div>
    </main>


        <div class="feedback-notice">
            <h3>âš ï¸ ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®å“è³ªå‘ä¸Šã«ã”å”åŠ›ãã ã•ã„</h3>
            <p>ã“ã®ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã¯AIã‚’æ´»ç”¨ã—ã¦ä½œæˆã•ã‚Œã¦ã„ã¾ã™ã€‚èª¤ã‚Šã‚„æ”¹å–„ç‚¹ã‚’è¦‹ã¤ã‘ã‚‰ã‚ŒãŸå ´åˆã¯ã€ä»¥ä¸‹ã®æ–¹æ³•ã§ã”å ±å‘Šãã ã•ã„ï¼š</p>
            <div class="feedback-options">
                <a href="https://forms.gle/9GfVBa2Qa7Uy9taQA" target="_blank" class="feedback-button">
                    ğŸ“ ä¿®æ­£ä¾é ¼ãƒ•ã‚©ãƒ¼ãƒ 
                </a>
                <a href="mailto:yusuke.hashimoto.d8@tohoku.ac.jp" class="feedback-button">
                    âœ‰ï¸ ãƒ¡ãƒ¼ãƒ«ã§é€£çµ¡
                </a>
            </div>
        </div>

    <footer>
        <div class="container">
            <p>&copy; 2025 AI Terakoya - Dr. Yusuke Hashimoto, Tohoku University</p>
            <p>Licensed under CC BY 4.0</p>
        </div>
    </footer>
</body>
</html>
