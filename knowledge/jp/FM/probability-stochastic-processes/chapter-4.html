<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç¬¬4ç« : ç¢ºç‡å¾®åˆ†æ–¹ç¨‹å¼ã¨Wieneréç¨‹ | ç¢ºç‡è«–ã¨ç¢ºç‡éç¨‹</title>
    <meta name="description" content="Wieneréç¨‹ã€ç¢ºç‡å¾®åˆ†æ–¹ç¨‹å¼ã€ItÃ´ç©åˆ†ã€å¹¾ä½•ãƒ–ãƒ©ã‚¦ãƒ³é‹å‹•ã€Ornstein-Uhlenbeckéç¨‹ã‚’å­¦ã³ã¾ã™ã€‚">
            <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; line-height: 1.8; color: #333; background: #f5f5f5; }
        header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 1.5rem; text-align: center; }
        h1 { font-size: 1.8rem; margin-bottom: 0.5rem; }
        .subtitle { opacity: 0.9; }
        .container { max-width: 900px; margin: 2rem auto; padding: 0 1rem; }
        .breadcrumb { margin-bottom: 1.5rem; font-size: 0.9rem; }
        .breadcrumb a { color: #667eea; text-decoration: none; }
        .content { background: white; padding: 2.5rem; border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-bottom: 2rem; }
        h2 { color: #667eea; margin: 2rem 0 1rem 0; padding-bottom: 0.5rem; border-bottom: 2px solid #e0e0e0; }
        h3 { color: #764ba2; margin: 1.5rem 0 0.8rem 0; }
        .definition { background: #e7f3ff; border-left: 4px solid #667eea; padding: 1rem 1.5rem; margin: 1.5rem 0; border-radius: 4px; }
        .theorem { background: #f3e5f5; border-left: 4px solid #764ba2; padding: 1rem 1.5rem; margin: 1.5rem 0; border-radius: 4px; }
        .example { background: #fff3e0; border-left: 4px solid #ff9800; padding: 1rem 1.5rem; margin: 1.5rem 0; border-radius: 4px; }
        .code-title {
            background: #667eea;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 6px 6px 0 0;
            font-weight: 600;
            margin-top: 1.5rem;
        }
        .code-example {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 1.5rem;
            border-radius: 0 0 8px 8px;
            overflow-x: auto;
            margin: 0 0 1rem 0;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            line-height: 1.6;
            white-space: pre-wrap;
        }
        .code-block {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 1.5rem;
            border-radius: 8px;
            overflow-x: auto;
            margin: 1rem 0;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            line-height: 1.6;
            white-space: pre-wrap;
        }
        .code-block code {
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            line-height: 1.6;
            white-space: pre-wrap;
        }
        .output { background: #f8f9fa; border: 1px solid #dee2e6; padding: 1rem; border-radius: 6px; margin: 1rem 0; font-family: monospace; font-size: 0.9rem; }
        table { width: 100%; border-collapse: collapse; margin: 1.5rem 0; }
        th, td { padding: 0.8rem; text-align: left; border: 1px solid #ddd; }
        th { background: #667eea; color: white; }
        .note { background: #fff3cd; border-left: 4px solid #ffc107; padding: 1rem 1.5rem; margin: 1.5rem 0; border-radius: 4px; }
        .exercise { background: #d4edda; border-left: 4px solid #28a745; padding: 1rem 1.5rem; margin: 1.5rem 0; border-radius: 4px; }
        .nav-buttons { display: flex; justify-content: space-between; margin: 2rem 0; }
        .nav-button { padding: 0.8rem 1.5rem; background: #667eea; color: white; text-decoration: none; border-radius: 6px; font-weight: 600; }
        .nav-button:hover { background: #764ba2; }
        footer { background: #2c3e50; color: white; text-align: center; padding: 2rem 1rem; margin-top: 3rem; }
        @media (max-width: 768px) { .content { padding: 1.5rem; } h1 { font-size: 1.5rem; } }
    </style>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <style>
        /* Locale Switcher Styles */
        .locale-switcher {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 6px;
            font-size: 0.9rem;
            margin-bottom: 1rem;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .current-locale {
            font-weight: 600;
            color: #7b2cbf;
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .locale-separator {
            color: #adb5bd;
            font-weight: 300;
        }

        .locale-link {
            color: #f093fb;
            text-decoration: none;
            font-weight: 500;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 0.25rem;
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
        }

        .locale-link:hover {
            background: rgba(240, 147, 251, 0.1);
            color: #d07be8;
            transform: translateY(-1px);
        }

        .locale-meta {
            color: #868e96;
            font-size: 0.85rem;
            font-style: italic;
            margin-left: auto;
        }

        @media (max-width: 768px) {
            .locale-switcher {
                font-size: 0.85rem;
                padding: 0.4rem 0.8rem;
            }
            .locale-meta {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div class="locale-switcher">
<span class="current-locale">ğŸŒ JP</span>
<span class="locale-separator">|</span>
<a href="../../../en/FM/probability-stochastic-processes/chapter-4.html" class="locale-link">ğŸ‡¬ğŸ‡§ EN</a>
<span class="locale-separator">|</span>
<span class="locale-meta">Last sync: 2025-11-16</span>
</div>
<header>
        <h1>ç¬¬4ç« : ç¢ºç‡å¾®åˆ†æ–¹ç¨‹å¼ã¨Wieneréç¨‹</h1>
        <p class="subtitle">Stochastic Differential Equations and Wiener Process</p>
    </header>

    <div class="container">
                <div class="breadcrumb">
            <a href="../index.html">åŸºç¤æ•°ç†é“å ´</a> &gt;
            <a href="index.html">ç¢ºç‡è«–ã¨ç¢ºç‡éç¨‹</a> &gt;
            ç¬¬4ç« 
        </div>

        <div class="content">
            <h2>4.1 Wieneréç¨‹ï¼ˆãƒ–ãƒ©ã‚¦ãƒ³é‹å‹•ï¼‰</h2>

            <div class="definition">
                <strong>ğŸ“ å®šç¾©: Wieneréç¨‹ï¼ˆæ¨™æº–ãƒ–ãƒ©ã‚¦ãƒ³é‹å‹•ï¼‰</strong><br>
                ç¢ºç‡éç¨‹ \(\{W(t)\}_{t \geq 0}\) ãŒ<strong>Wieneréç¨‹</strong>ã§ã‚ã‚‹ã¨ã¯ï¼š

                <ol>
                    <li>\(W(0) = 0\) ï¼ˆã‚¼ãƒ­ã‹ã‚‰é–‹å§‹ï¼‰</li>
                    <li>ç‹¬ç«‹å¢—åˆ†æ€§: \(W(t_1), W(t_2) - W(t_1), W(t_3) - W(t_2), \ldots\) ã¯ç‹¬ç«‹</li>
                    <li>å®šå¸¸å¢—åˆ†æ€§: \(W(t+s) - W(s) \sim N(0, t)\)</li>
                    <li>é€£ç¶šãªçµŒè·¯: \(W(t)\) ã¯ \(t\) ã«ã¤ã„ã¦é€£ç¶šé–¢æ•°</li>
                </ol>

                <strong>æ€§è³ª:</strong>
                \[E[W(t)] = 0, \quad Var(W(t)) = t, \quad Cov(W(s), W(t)) = \min(s, t)\]
            </div>

            <h3>ğŸ’» ã‚³ãƒ¼ãƒ‰ä¾‹1: Wieneréç¨‹ï¼ˆãƒ–ãƒ©ã‚¦ãƒ³é‹å‹•ï¼‰ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³</h3>
            <div class="code-block">import numpy as np
import matplotlib.pyplot as plt
from scipy import stats

# Wieneréç¨‹ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
np.random.seed(42)

def simulate_wiener_process(T, dt):
    """Wieneréç¨‹ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³"""
    n_steps = int(T / dt)
    t = np.linspace(0, T, n_steps + 1)

    # å¢—åˆ† dW ~ N(0, dt)
    dW = np.random.normal(0, np.sqrt(dt), n_steps)

    # ç´¯ç©å’Œã§Wieneréç¨‹ã‚’æ§‹ç¯‰
    W = np.concatenate([[0], np.cumsum(dW)])

    return t, W

# ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
T = 10  # çµ‚äº†æ™‚åˆ»
dt = 0.01  # æ™‚é–“åˆ»ã¿

# è¤‡æ•°çµŒè·¯ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
n_paths = 10

fig, axes = plt.subplots(2, 2, figsize=(14, 10))

# (1) ã‚µãƒ³ãƒ—ãƒ«çµŒè·¯
for _ in range(n_paths):
    t, W = simulate_wiener_process(T, dt)
    axes[0, 0].plot(t, W, alpha=0.6, linewidth=1.5)

axes[0, 0].axhline(y=0, color='red', linestyle='--', linewidth=2, label='E[W(t)] = 0')
axes[0, 0].set_xlabel('æ™‚é–“ t', fontsize=11)
axes[0, 0].set_ylabel('W(t)', fontsize=11)
axes[0, 0].set_title('Wieneréç¨‹ã®ã‚µãƒ³ãƒ—ãƒ«çµŒè·¯', fontsize=12, fontweight='bold')
axes[0, 0].legend()
axes[0, 0].grid(alpha=0.3)

# (2) åˆ†æ•£ã®æ™‚é–“ç™ºå±•
n_simulations = 1000
t_checkpoints = [1, 2, 5, 10]

for t_check in t_checkpoints:
    W_values = []
    for _ in range(n_simulations):
        t, W = simulate_wiener_process(t_check, dt)
        W_values.append(W[-1])

    W_values = np.array(W_values)

    # ãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ 
    axes[0, 1].hist(W_values, bins=50, alpha=0.4, density=True,
                     label=f't={t_check}')

# ç†è«–åˆ†å¸ƒ N(0, t)
x = np.linspace(-6, 6, 1000)
for t_check in t_checkpoints:
    theoretical_pdf = stats.norm.pdf(x, 0, np.sqrt(t_check))
    axes[0, 1].plot(x, theoretical_pdf, linewidth=2, linestyle='--')

axes[0, 1].set_xlabel('W(t)', fontsize=11)
axes[0, 1].set_ylabel('å¯†åº¦', fontsize=11)
axes[0, 1].set_title('W(t)ã®åˆ†å¸ƒï¼ˆç•°ãªã‚‹æ™‚åˆ»ï¼‰', fontsize=12, fontweight='bold')
axes[0, 1].legend()
axes[0, 1].grid(alpha=0.3)

# (3) å¹³å‡ã¨åˆ†æ•£ã®æ™‚é–“æ¨ç§»
t, W_sample = simulate_wiener_process(T, dt)
n_paths_analysis = 500

all_paths = []
for _ in range(n_paths_analysis):
    t, W = simulate_wiener_process(T, dt)
    all_paths.append(W)

all_paths = np.array(all_paths)

mean_W = all_paths.mean(axis=0)
std_W = all_paths.std(axis=0)

axes[1, 0].plot(t, mean_W, color='#667eea', linewidth=2.5, label='å®Ÿæ¸¬å¹³å‡')
axes[1, 0].fill_between(t, mean_W - std_W, mean_W + std_W,
                          alpha=0.3, color='#667eea', label='å®Ÿæ¸¬Â±1Ïƒ')
axes[1, 0].plot(t, np.zeros_like(t), 'r--', linewidth=2, label='ç†è«–å¹³å‡=0')
axes[1, 0].plot(t, np.sqrt(t), 'g--', linewidth=2, label='ç†è«–Ïƒ=âˆšt')
axes[1, 0].plot(t, -np.sqrt(t), 'g--', linewidth=2)

axes[1, 0].set_xlabel('æ™‚é–“ t', fontsize=11)
axes[1, 0].set_ylabel('W(t)', fontsize=11)
axes[1, 0].set_title('å¹³å‡ã¨åˆ†æ•£ã®æ™‚é–“æ¨ç§»', fontsize=12, fontweight='bold')
axes[1, 0].legend()
axes[1, 0].grid(alpha=0.3)

# (4) å…±åˆ†æ•£æ§‹é€  Cov(W(s), W(t)) = min(s, t)
s_values = np.linspace(0, T, 100)
t_values = np.linspace(0, T, 100)
S, T_grid = np.meshgrid(s_values, t_values)

# ç†è«–å…±åˆ†æ•£
Cov_theory = np.minimum(S, T_grid)

im = axes[1, 1].imshow(Cov_theory, extent=[0, T, 0, T], origin='lower',
                        cmap='viridis', aspect='auto')
axes[1, 1].set_xlabel('æ™‚åˆ» s', fontsize=11)
axes[1, 1].set_ylabel('æ™‚åˆ» t', fontsize=11)
axes[1, 1].set_title('Cov(W(s), W(t)) = min(s, t)', fontsize=12, fontweight='bold')
plt.colorbar(im, ax=axes[1, 1])

plt.tight_layout()
plt.show()

print("Wieneréç¨‹ã®æ€§è³ªæ¤œè¨¼:")
print("="*60)
for t_check in t_checkpoints:
    W_values = []
    for _ in range(n_simulations):
        t, W = simulate_wiener_process(t_check, dt)
        W_values.append(W[-1])
    W_values = np.array(W_values)

    print(f"t={t_check}:")
    print(f"  ç†è«–: E[W(t)]={0:.4f}, Var(W(t))={t_check:.4f}")
    print(f"  å®Ÿæ¸¬: E[W(t)]={W_values.mean():.4f}, Var(W(t))={W_values.var():.4f}")</div>

            <h2>4.2 ãƒ‰ãƒªãƒ•ãƒˆã¨ãƒœãƒ©ãƒ†ã‚£ãƒªãƒ†ã‚£</h2>

            <div class="definition">
                <strong>ğŸ“ å®šç¾©: ãƒ‰ãƒªãƒ•ãƒˆä»˜ãWieneréç¨‹</strong><br>
                ãƒ‰ãƒªãƒ•ãƒˆä¿‚æ•° \(\mu\) ã¨ãƒœãƒ©ãƒ†ã‚£ãƒªãƒ†ã‚£ä¿‚æ•° \(\sigma\) ã‚’æŒã¤Wieneréç¨‹ï¼š
                \[X(t) = X_0 + \mu t + \sigma W(t)\]

                <strong>æœŸå¾…å€¤ã¨åˆ†æ•£:</strong>
                \[E[X(t)] = X_0 + \mu t, \quad Var(X(t)) = \sigma^2 t\]

                ãƒ‰ãƒªãƒ•ãƒˆ \(\mu\) ã¯æ±ºå®šçš„ãªãƒˆãƒ¬ãƒ³ãƒ‰ã€ãƒœãƒ©ãƒ†ã‚£ãƒªãƒ†ã‚£ \(\sigma\) ã¯ãƒ©ãƒ³ãƒ€ãƒ ãªå¤‰å‹•ã®å¤§ãã•ã‚’è¡¨ã—ã¾ã™ã€‚
            </div>

            <h3>ğŸ’» ã‚³ãƒ¼ãƒ‰ä¾‹2: ãƒ‰ãƒªãƒ•ãƒˆã¨ãƒœãƒ©ãƒ†ã‚£ãƒªãƒ†ã‚£ã®åŠ¹æœ</h3>
            <div class="code-block"># ãƒ‰ãƒªãƒ•ãƒˆä»˜ãWieneréç¨‹ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
np.random.seed(42)

def simulate_drift_wiener(X0, mu, sigma, T, dt):
    """ãƒ‰ãƒªãƒ•ãƒˆä»˜ãWieneréç¨‹ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³"""
    t, W = simulate_wiener_process(T, dt)
    X = X0 + mu * t + sigma * W
    return t, X

# ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿è¨­å®š
X0 = 100
T = 5
dt = 0.01

# ç•°ãªã‚‹ãƒ‰ãƒªãƒ•ãƒˆã¨ãƒœãƒ©ãƒ†ã‚£ãƒªãƒ†ã‚£ã®çµ„ã¿åˆã‚ã›
configs = [
    {'mu': 0, 'sigma': 1, 'label': 'Î¼=0, Ïƒ=1 (æ¨™æº–Wiener)'},
    {'mu': 2, 'sigma': 1, 'label': 'Î¼=2, Ïƒ=1 (æ­£ã®ãƒ‰ãƒªãƒ•ãƒˆ)'},
    {'mu': -1, 'sigma': 1, 'label': 'Î¼=-1, Ïƒ=1 (è² ã®ãƒ‰ãƒªãƒ•ãƒˆ)'},
    {'mu': 0, 'sigma': 3, 'label': 'Î¼=0, Ïƒ=3 (é«˜ãƒœãƒ©ãƒ†ã‚£ãƒªãƒ†ã‚£)'},
]

fig, axes = plt.subplots(2, 2, figsize=(14, 10))
axes = axes.flatten()

for idx, config in enumerate(configs):
    mu = config['mu']
    sigma = config['sigma']

    # è¤‡æ•°çµŒè·¯ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
    for _ in range(20):
        t, X = simulate_drift_wiener(X0, mu, sigma, T, dt)
        axes[idx].plot(t, X, alpha=0.4, linewidth=1.5, color='#667eea')

    # æœŸå¾…å€¤
    t_theory = np.linspace(0, T, 1000)
    E_X = X0 + mu * t_theory
    axes[idx].plot(t_theory, E_X, 'r--', linewidth=2.5, label=f'E[X(t)]={X0}+{mu}t')

    # Â±1Ïƒ ä¿¡é ¼å¸¯
    std_X = sigma * np.sqrt(t_theory)
    axes[idx].fill_between(t_theory, E_X - std_X, E_X + std_X,
                             alpha=0.2, color='red', label='E[X]Â±Ïƒ')

    axes[idx].set_xlabel('æ™‚é–“ t', fontsize=11)
    axes[idx].set_ylabel('X(t)', fontsize=11)
    axes[idx].set_title(config['label'], fontsize=12, fontweight='bold')
    axes[idx].legend()
    axes[idx].grid(alpha=0.3)

plt.tight_layout()
plt.show()

# çµ±è¨ˆçš„æ¤œè¨¼
print("\nãƒ‰ãƒªãƒ•ãƒˆä»˜ãWieneréç¨‹ã®çµ±è¨ˆçš„æ¤œè¨¼:")
print("="*60)
for config in configs:
    mu = config['mu']
    sigma = config['sigma']

    # è¤‡æ•°çµŒè·¯ã®æœ€çµ‚å€¤
    n_sims = 1000
    final_values = []
    for _ in range(n_sims):
        t, X = simulate_drift_wiener(X0, mu, sigma, T, dt)
        final_values.append(X[-1])

    final_values = np.array(final_values)

    print(f"\n{config['label']}:")
    print(f"  ç†è«–: E[X({T})]={X0 + mu*T:.2f}, Var(X({T}))={sigma**2*T:.2f}")
    print(f"  å®Ÿæ¸¬: E[X({T})]={final_values.mean():.2f}, Var(X({T}))={final_values.var():.2f}")</div>

            <h2>4.3 ç¢ºç‡å¾®åˆ†æ–¹ç¨‹å¼ï¼ˆSDEï¼‰ã¨Euler-Maruyamaæ³•</h2>

            <div class="definition">
                <strong>ğŸ“ å®šç¾©: ç¢ºç‡å¾®åˆ†æ–¹ç¨‹å¼ï¼ˆSDEï¼‰</strong><br>
                ç¢ºç‡å¾®åˆ†æ–¹ç¨‹å¼ã®ä¸€èˆ¬å½¢ï¼š
                \[dX(t) = \mu(X, t) \, dt + \sigma(X, t) \, dW(t)\]

                ã“ã“ã§ï¼š
                <ul>
                    <li>\(\mu(X, t)\): ãƒ‰ãƒªãƒ•ãƒˆé …ï¼ˆæ±ºå®šè«–çš„éƒ¨åˆ†ï¼‰</li>
                    <li>\(\sigma(X, t)\): æ‹¡æ•£é …ï¼ˆç¢ºç‡è«–çš„éƒ¨åˆ†ï¼‰</li>
                    <li>\(dW(t)\): Wieneréç¨‹ã®å¾®å°å¢—åˆ†</li>
                </ul>

                <strong>Euler-Maruyamaæ³•ï¼ˆæ•°å€¤è§£æ³•ï¼‰:</strong>
                \[X_{n+1} = X_n + \mu(X_n, t_n) \Delta t + \sigma(X_n, t_n) \sqrt{\Delta t} \, Z_n\]
                ã“ã“ã§ \(Z_n \sim N(0, 1)\) ã¯ç‹¬ç«‹ãªæ¨™æº–æ­£è¦ä¹±æ•°ã€‚
            </div>

            <h3>ğŸ’» ã‚³ãƒ¼ãƒ‰ä¾‹3: Euler-Maruyamaæ³•ã«ã‚ˆã‚‹SDEæ•°å€¤è§£æ³•</h3>
            <div class="code-block"># Euler-Maruyamaæ³•ã®å®Ÿè£…
def euler_maruyama(mu_func, sigma_func, X0, T, dt):
    """
    Euler-Maruyamaæ³•ã«ã‚ˆã‚‹SDEã®æ•°å€¤è§£æ³•

    Parameters:
    -----------
    mu_func : function
        ãƒ‰ãƒªãƒ•ãƒˆé … Î¼(X, t)
    sigma_func : function
        æ‹¡æ•£é … Ïƒ(X, t)
    X0 : float
        åˆæœŸå€¤
    T : float
        çµ‚äº†æ™‚åˆ»
    dt : float
        æ™‚é–“åˆ»ã¿
    """
    n_steps = int(T / dt)
    t = np.linspace(0, T, n_steps + 1)
    X = np.zeros(n_steps + 1)
    X[0] = X0

    for i in range(n_steps):
        dW = np.random.normal(0, np.sqrt(dt))
        X[i+1] = X[i] + mu_func(X[i], t[i]) * dt + sigma_func(X[i], t[i]) * dW

    return t, X

# ä¾‹1: ç·šå½¢SDE dX = -Î¸X dt + Ïƒ dW ï¼ˆOrnstein-Uhlenbeckéç¨‹ã®ç‰¹æ®Šã‚±ãƒ¼ã‚¹ï¼‰
theta = 0.5
sigma = 1.0

mu_func = lambda X, t: -theta * X
sigma_func = lambda X, t: sigma

np.random.seed(42)
X0 = 5
T = 10
dt = 0.01

fig, axes = plt.subplots(2, 2, figsize=(14, 10))

# (1) è¤‡æ•°çµŒè·¯ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
for _ in range(20):
    t, X = euler_maruyama(mu_func, sigma_func, X0, T, dt)
    axes[0, 0].plot(t, X, alpha=0.4, linewidth=1.5, color='#667eea')

axes[0, 0].axhline(y=0, color='red', linestyle='--', linewidth=2, label='å¹³è¡¡ç‚¹')
axes[0, 0].set_xlabel('æ™‚é–“ t', fontsize=11)
axes[0, 0].set_ylabel('X(t)', fontsize=11)
axes[0, 0].set_title('ç·šå½¢SDE: dX = -Î¸X dt + Ïƒ dW', fontsize=12, fontweight='bold')
axes[0, 0].legend()
axes[0, 0].grid(alpha=0.3)

# (2) ç•°ãªã‚‹æ™‚é–“åˆ»ã¿ã§ã®æ¯”è¼ƒ
dts = [0.1, 0.01, 0.001]
np.random.seed(42)

for dt_test in dts:
    t, X = euler_maruyama(mu_func, sigma_func, X0, T, dt_test)
    axes[0, 1].plot(t, X, linewidth=2, alpha=0.7, label=f'Î”t={dt_test}')

axes[0, 1].set_xlabel('æ™‚é–“ t', fontsize=11)
axes[0, 1].set_ylabel('X(t)', fontsize=11)
axes[0, 1].set_title('æ™‚é–“åˆ»ã¿ã®å½±éŸ¿', fontsize=12, fontweight='bold')
axes[0, 1].legend()
axes[0, 1].grid(alpha=0.3)

# (3) å¹³å‡ã¸ã®åæŸï¼ˆå¹³å‡å›å¸°ï¼‰
n_paths = 500
all_paths = []

for _ in range(n_paths):
    t, X = euler_maruyama(mu_func, sigma_func, X0, T, dt)
    all_paths.append(X)

all_paths = np.array(all_paths)
mean_X = all_paths.mean(axis=0)
std_X = all_paths.std(axis=0)

axes[1, 0].plot(t, mean_X, color='#667eea', linewidth=2.5, label='å®Ÿæ¸¬å¹³å‡')
axes[1, 0].fill_between(t, mean_X - std_X, mean_X + std_X,
                          alpha=0.3, color='#667eea', label='Â±1Ïƒ')

# ç†è«–çš„ãªå¹³å‡ï¼ˆè§£æè§£ï¼‰: E[X(t)] = X0 * exp(-Î¸t)
E_X_theory = X0 * np.exp(-theta * t)
axes[1, 0].plot(t, E_X_theory, 'r--', linewidth=2, label='ç†è«–å¹³å‡')

axes[1, 0].set_xlabel('æ™‚é–“ t', fontsize=11)
axes[1, 0].set_ylabel('E[X(t)]', fontsize=11)
axes[1, 0].set_title('å¹³å‡ã¸ã®åæŸï¼ˆå¹³å‡å›å¸°ï¼‰', fontsize=12, fontweight='bold')
axes[1, 0].legend()
axes[1, 0].grid(alpha=0.3)

# (4) å®šå¸¸åˆ†å¸ƒ
# ååˆ†æ™‚é–“ãŒçµŒéã—ãŸå¾Œã®åˆ†å¸ƒï¼ˆtâ†’âˆã§ N(0, ÏƒÂ²/(2Î¸))ï¼‰
final_values = all_paths[:, -1]

axes[1, 1].hist(final_values, bins=50, density=True, alpha=0.6,
                 color='#667eea', edgecolor='black', label='å®Ÿæ¸¬')

# ç†è«–çš„å®šå¸¸åˆ†å¸ƒ
x = np.linspace(final_values.min(), final_values.max(), 1000)
stationary_var = sigma**2 / (2 * theta)
stationary_pdf = stats.norm.pdf(x, 0, np.sqrt(stationary_var))
axes[1, 1].plot(x, stationary_pdf, 'r-', linewidth=2.5,
                 label=f'N(0, {stationary_var:.2f})')

axes[1, 1].set_xlabel('X(âˆ)', fontsize=11)
axes[1, 1].set_ylabel('å¯†åº¦', fontsize=11)
axes[1, 1].set_title('å®šå¸¸åˆ†å¸ƒ', fontsize=12, fontweight='bold')
axes[1, 1].legend()
axes[1, 1].grid(alpha=0.3)

plt.tight_layout()
plt.show()

print("ç·šå½¢SDEã®æ¤œè¨¼:")
print(f"ç†è«–å®šå¸¸åˆ†æ•£: ÏƒÂ²/(2Î¸) = {stationary_var:.4f}")
print(f"å®Ÿæ¸¬å®šå¸¸åˆ†æ•£: {final_values.var():.4f}")</div>

            <h2>4.4 å¹¾ä½•ãƒ–ãƒ©ã‚¦ãƒ³é‹å‹•ï¼ˆæ ªä¾¡ãƒ¢ãƒ‡ãƒ«ï¼‰</h2>

            <div class="theorem">
                <strong>ğŸ“Š å®šç†: å¹¾ä½•ãƒ–ãƒ©ã‚¦ãƒ³é‹å‹•</strong><br>
                å¹¾ä½•ãƒ–ãƒ©ã‚¦ãƒ³é‹å‹•ã¯æ¬¡ã®SDEã§å®šç¾©ã•ã‚Œã¾ã™ï¼š
                \[dS(t) = \mu S(t) \, dt + \sigma S(t) \, dW(t)\]

                <strong>è§£æè§£ï¼ˆItÃ´ã®å…¬å¼ã«ã‚ˆã‚‹ï¼‰:</strong>
                \[S(t) = S_0 \exp\left[\left(\mu - \frac{\sigma^2}{2}\right)t + \sigma W(t)\right]\]

                æœŸå¾…å€¤: \(E[S(t)] = S_0 e^{\mu t}\)<br>
                åˆ†æ•£: \(Var(S(t)) = S_0^2 e^{2\mu t}(e^{\sigma^2 t} - 1)\)

                <strong>å¿œç”¨:</strong> Black-Scholesãƒ¢ãƒ‡ãƒ«ï¼ˆæ ªä¾¡ã€ç‚ºæ›¿ãƒ¬ãƒ¼ãƒˆï¼‰
            </div>

            <h3>ğŸ’» ã‚³ãƒ¼ãƒ‰ä¾‹4: å¹¾ä½•ãƒ–ãƒ©ã‚¦ãƒ³é‹å‹•ï¼ˆæ ªä¾¡ãƒ¢ãƒ‡ãƒ«ï¼‰</h3>
            <div class="code-block"># å¹¾ä½•ãƒ–ãƒ©ã‚¦ãƒ³é‹å‹•ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
np.random.seed(42)

def geometric_brownian_motion(S0, mu, sigma, T, dt):
    """å¹¾ä½•ãƒ–ãƒ©ã‚¦ãƒ³é‹å‹•ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆè§£æè§£ã‚’ä½¿ç”¨ï¼‰"""
    n_steps = int(T / dt)
    t = np.linspace(0, T, n_steps + 1)

    # Wieneréç¨‹ã‚’ç”Ÿæˆ
    dW = np.random.normal(0, np.sqrt(dt), n_steps)
    W = np.concatenate([[0], np.cumsum(dW)])

    # è§£æè§£
    S = S0 * np.exp((mu - 0.5 * sigma**2) * t + sigma * W)

    return t, S

# ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ï¼ˆæ ªä¾¡ãƒ¢ãƒ‡ãƒ«ï¼‰
S0 = 100  # åˆæœŸæ ªä¾¡
mu = 0.1  # ãƒ‰ãƒªãƒ•ãƒˆï¼ˆå¹´ç‡ãƒªã‚¿ãƒ¼ãƒ³ï¼‰
sigma = 0.2  # ãƒœãƒ©ãƒ†ã‚£ãƒªãƒ†ã‚£ï¼ˆå¹´ç‡ï¼‰
T = 1  # 1å¹´é–“
dt = 1/252  # 1å–¶æ¥­æ—¥

fig, axes = plt.subplots(2, 2, figsize=(14, 10))

# (1) ã‚µãƒ³ãƒ—ãƒ«çµŒè·¯
n_paths = 50
for _ in range(n_paths):
    t, S = geometric_brownian_motion(S0, mu, sigma, T, dt)
    axes[0, 0].plot(t, S, alpha=0.4, linewidth=1.5, color='#667eea')

# æœŸå¾…å€¤
t_theory = np.linspace(0, T, 1000)
E_S = S0 * np.exp(mu * t_theory)
axes[0, 0].plot(t_theory, E_S, 'r--', linewidth=2.5, label=f'E[S(t)]={S0}e^{{Î¼t}}')

axes[0, 0].set_xlabel('æ™‚é–“ï¼ˆå¹´ï¼‰', fontsize=11)
axes[0, 0].set_ylabel('æ ªä¾¡ S(t)', fontsize=11)
axes[0, 0].set_title('å¹¾ä½•ãƒ–ãƒ©ã‚¦ãƒ³é‹å‹•ï¼ˆæ ªä¾¡ãƒ¢ãƒ‡ãƒ«ï¼‰', fontsize=12, fontweight='bold')
axes[0, 0].legend()
axes[0, 0].grid(alpha=0.3)
axes[0, 0].set_ylim([0, 200])

# (2) å¯¾æ•°åç›Šç‡ã®åˆ†å¸ƒ
# log(S(t)/S0) ~ N((Î¼ - ÏƒÂ²/2)t, ÏƒÂ²t)
n_sims = 5000
final_prices = []
for _ in range(n_sims):
    t, S = geometric_brownian_motion(S0, mu, sigma, T, dt)
    final_prices.append(S[-1])

final_prices = np.array(final_prices)
log_returns = np.log(final_prices / S0)

axes[0, 1].hist(log_returns, bins=50, density=True, alpha=0.6,
                 color='#667eea', edgecolor='black', label='ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³')

# ç†è«–åˆ†å¸ƒ
x = np.linspace(log_returns.min(), log_returns.max(), 1000)
theoretical_mean = (mu - 0.5 * sigma**2) * T
theoretical_std = sigma * np.sqrt(T)
theoretical_pdf = stats.norm.pdf(x, theoretical_mean, theoretical_std)
axes[0, 1].plot(x, theoretical_pdf, 'r-', linewidth=2.5, label='ç†è«–åˆ†å¸ƒ')

axes[0, 1].set_xlabel('å¯¾æ•°åç›Šç‡ log(S(T)/Sâ‚€)', fontsize=11)
axes[0, 1].set_ylabel('å¯†åº¦', fontsize=11)
axes[0, 1].set_title('å¯¾æ•°åç›Šç‡ã®åˆ†å¸ƒ', fontsize=12, fontweight='bold')
axes[0, 1].legend()
axes[0, 1].grid(alpha=0.3)

# (3) ç•°ãªã‚‹ãƒœãƒ©ãƒ†ã‚£ãƒªãƒ†ã‚£ã§ã®æ¯”è¼ƒ
sigmas = [0.1, 0.2, 0.3, 0.4]
colors = ['blue', 'green', 'orange', 'red']

for sig, color in zip(sigmas, colors):
    for _ in range(10):
        t, S = geometric_brownian_motion(S0, mu, sig, T, dt)
        axes[1, 0].plot(t, S, alpha=0.3, linewidth=1.5, color=color)

    # å„ãƒœãƒ©ãƒ†ã‚£ãƒªãƒ†ã‚£ã®æœŸå¾…å€¤
    axes[1, 0].plot(t_theory, S0 * np.exp(mu * t_theory), '--',
                     linewidth=2, color=color, label=f'Ïƒ={sig}')

axes[1, 0].set_xlabel('æ™‚é–“ï¼ˆå¹´ï¼‰', fontsize=11)
axes[1, 0].set_ylabel('æ ªä¾¡ S(t)', fontsize=11)
axes[1, 0].set_title('ç•°ãªã‚‹ãƒœãƒ©ãƒ†ã‚£ãƒªãƒ†ã‚£ã§ã®æ¯”è¼ƒ', fontsize=12, fontweight='bold')
axes[1, 0].legend()
axes[1, 0].grid(alpha=0.3)

# (4) ãƒ¢ãƒ³ãƒ†ã‚«ãƒ«ãƒ­ä¾¡æ ¼è©•ä¾¡ï¼ˆãƒ¨ãƒ¼ãƒ­ãƒ”ã‚¢ãƒ³ã‚³ãƒ¼ãƒ«ã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
K = 100  # è¡Œä½¿ä¾¡æ ¼
r = 0.05  # ãƒªã‚¹ã‚¯ãƒ•ãƒªãƒ¼ãƒ¬ãƒ¼ãƒˆ

# ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®ãƒšã‚¤ã‚ªãƒ• max(S(T) - K, 0)
payoffs = np.maximum(final_prices - K, 0)
option_price_mc = np.exp(-r * T) * payoffs.mean()

# Black-Scholeså…¬å¼ï¼ˆè§£æè§£ï¼‰
from scipy.stats import norm as norm_dist
d1 = (np.log(S0/K) + (r + 0.5*sigma**2)*T) / (sigma*np.sqrt(T))
d2 = d1 - sigma*np.sqrt(T)
option_price_bs = S0*norm_dist.cdf(d1) - K*np.exp(-r*T)*norm_dist.cdf(d2)

axes[1, 1].hist(payoffs, bins=50, alpha=0.6, color='#667eea', edgecolor='black')
axes[1, 1].axvline(payoffs.mean(), color='red', linestyle='--', linewidth=2,
                    label=f'å¹³å‡ãƒšã‚¤ã‚ªãƒ•={payoffs.mean():.2f}')
axes[1, 1].set_xlabel('ãƒšã‚¤ã‚ªãƒ• max(S(T)-K, 0)', fontsize=11)
axes[1, 1].set_ylabel('é »åº¦', fontsize=11)
axes[1, 1].set_title('ã‚ªãƒ—ã‚·ãƒ§ãƒ³ãƒšã‚¤ã‚ªãƒ•ã®åˆ†å¸ƒ', fontsize=12, fontweight='bold')
axes[1, 1].legend()
axes[1, 1].grid(alpha=0.3)

plt.tight_layout()
plt.show()

print("å¹¾ä½•ãƒ–ãƒ©ã‚¦ãƒ³é‹å‹•ã®æ¤œè¨¼:")
print(f"ç†è«–: E[S(T)] = {S0 * np.exp(mu * T):.2f}")
print(f"å®Ÿæ¸¬: E[S(T)] = {final_prices.mean():.2f}")
print(f"\nã‚ªãƒ—ã‚·ãƒ§ãƒ³ä¾¡æ ¼:")
print(f"ãƒ¢ãƒ³ãƒ†ã‚«ãƒ«ãƒ­: {option_price_mc:.4f}")
print(f"Black-Scholes: {option_price_bs:.4f}")</div>

            <h2>4.5 Ornstein-Uhlenbeckéç¨‹ï¼ˆå¹³å‡å›å¸°ï¼‰</h2>

            <div class="definition">
                <strong>ğŸ“ å®šç¾©: Ornstein-Uhlenbeckéç¨‹</strong><br>
                Ornstein-Uhlenbeckéç¨‹ã¯ã€å¹³å‡å›å¸°æ€§ã‚’æŒã¤SDEã§ã™ï¼š
                \[dX(t) = \theta(\mu - X(t)) \, dt + \sigma \, dW(t)\]

                ã“ã“ã§ï¼š
                <ul>
                    <li>\(\mu\): é•·æœŸå¹³å‡ï¼ˆå¹³è¡¡ç‚¹ï¼‰</li>
                    <li>\(\theta > 0\): å›å¸°é€Ÿåº¦</li>
                    <li>\(\sigma\): ãƒœãƒ©ãƒ†ã‚£ãƒªãƒ†ã‚£</li>
                </ul>

                <strong>è§£æè§£:</strong>
                \[X(t) = X_0 e^{-\theta t} + \mu(1 - e^{-\theta t}) + \sigma \int_0^t e^{-\theta(t-s)} dW(s)\]

                å®šå¸¸åˆ†å¸ƒ: \(X(\infty) \sim N\left(\mu, \frac{\sigma^2}{2\theta}\right)\)
            </div>

            <h3>ğŸ’» ã‚³ãƒ¼ãƒ‰ä¾‹5: Ornstein-Uhlenbeckéç¨‹ï¼ˆå¹³å‡å›å¸°ï¼‰</h3>
            <div class="code-block"># Ornstein-Uhlenbeckéç¨‹ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
np.random.seed(42)

def ornstein_uhlenbeck(X0, theta, mu, sigma, T, dt):
    """Ornstein-Uhlenbeckéç¨‹ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³"""
    mu_func = lambda X, t: theta * (mu - X)
    sigma_func = lambda X, t: sigma
    return euler_maruyama(mu_func, sigma_func, X0, T, dt)

# ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
X0 = 10
theta = 2.0  # å›å¸°é€Ÿåº¦
mu = 5  # é•·æœŸå¹³å‡
sigma = 1.5  # ãƒœãƒ©ãƒ†ã‚£ãƒªãƒ†ã‚£
T = 10
dt = 0.01

fig, axes = plt.subplots(2, 2, figsize=(14, 10))

# (1) ç•°ãªã‚‹åˆæœŸå€¤ã‹ã‚‰ã®å¹³å‡å›å¸°
initial_values = [0, 3, 5, 7, 10]
colors = plt.cm.viridis(np.linspace(0, 1, len(initial_values)))

for X0_test, color in zip(initial_values, colors):
    for _ in range(5):
        t, X = ornstein_uhlenbeck(X0_test, theta, mu, sigma, T, dt)
        axes[0, 0].plot(t, X, alpha=0.4, linewidth=1.5, color=color)

axes[0, 0].axhline(y=mu, color='red', linestyle='--', linewidth=2.5,
                    label=f'é•·æœŸå¹³å‡ Î¼={mu}')
axes[0, 0].set_xlabel('æ™‚é–“ t', fontsize=11)
axes[0, 0].set_ylabel('X(t)', fontsize=11)
axes[0, 0].set_title('å¹³å‡å›å¸°ã®å¯è¦–åŒ–', fontsize=12, fontweight='bold')
axes[0, 0].legend()
axes[0, 0].grid(alpha=0.3)

# (2) ç•°ãªã‚‹å›å¸°é€Ÿåº¦ã®æ¯”è¼ƒ
thetas = [0.5, 1.0, 2.0, 5.0]
for theta_test in thetas:
    for _ in range(10):
        t, X = ornstein_uhlenbeck(X0, theta_test, mu, sigma, T, dt)
        axes[0, 1].plot(t, X, alpha=0.3, linewidth=1.5, label=f'Î¸={theta_test}' if _ == 0 else None)

axes[0, 1].axhline(y=mu, color='red', linestyle='--', linewidth=2)
axes[0, 1].set_xlabel('æ™‚é–“ t', fontsize=11)
axes[0, 1].set_ylabel('X(t)', fontsize=11)
axes[0, 1].set_title('å›å¸°é€Ÿåº¦Î¸ã®åŠ¹æœ', fontsize=12, fontweight='bold')
axes[0, 1].legend()
axes[0, 1].grid(alpha=0.3)

# (3) å®šå¸¸åˆ†å¸ƒ
n_paths = 5000
final_values = []

for _ in range(n_paths):
    t, X = ornstein_uhlenbeck(X0, theta, mu, sigma, T, dt)
    final_values.append(X[-1])

final_values = np.array(final_values)

axes[1, 0].hist(final_values, bins=50, density=True, alpha=0.6,
                 color='#667eea', edgecolor='black', label='ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³')

# ç†è«–çš„å®šå¸¸åˆ†å¸ƒ N(Î¼, ÏƒÂ²/(2Î¸))
x = np.linspace(final_values.min(), final_values.max(), 1000)
stationary_var = sigma**2 / (2 * theta)
stationary_pdf = stats.norm.pdf(x, mu, np.sqrt(stationary_var))
axes[1, 0].plot(x, stationary_pdf, 'r-', linewidth=2.5,
                 label=f'N({mu}, {stationary_var:.2f})')

axes[1, 0].set_xlabel('X(âˆ)', fontsize=11)
axes[1, 0].set_ylabel('å¯†åº¦', fontsize=11)
axes[1, 0].set_title('å®šå¸¸åˆ†å¸ƒ', fontsize=12, fontweight='bold')
axes[1, 0].legend()
axes[1, 0].grid(alpha=0.3)

# (4) å¹³å‡ã¨åˆ†æ•£ã®æ™‚é–“ç™ºå±•
all_paths = []
for _ in range(1000):
    t, X = ornstein_uhlenbeck(X0, theta, mu, sigma, T, dt)
    all_paths.append(X)

all_paths = np.array(all_paths)
mean_X = all_paths.mean(axis=0)
var_X = all_paths.var(axis=0)

# ç†è«–çš„å¹³å‡ã¨åˆ†æ•£
E_X_theory = X0 * np.exp(-theta * t) + mu * (1 - np.exp(-theta * t))
Var_X_theory = (sigma**2 / (2*theta)) * (1 - np.exp(-2*theta*t))

axes[1, 1].plot(t, mean_X, color='#667eea', linewidth=2.5, label='å®Ÿæ¸¬å¹³å‡')
axes[1, 1].plot(t, E_X_theory, 'r--', linewidth=2, label='ç†è«–å¹³å‡')
axes[1, 1].fill_between(t, mean_X - np.sqrt(var_X), mean_X + np.sqrt(var_X),
                          alpha=0.2, color='#667eea', label='å®Ÿæ¸¬Â±1Ïƒ')
axes[1, 1].fill_between(t, E_X_theory - np.sqrt(Var_X_theory),
                          E_X_theory + np.sqrt(Var_X_theory),
                          alpha=0.2, color='red')

axes[1, 1].set_xlabel('æ™‚é–“ t', fontsize=11)
axes[1, 1].set_ylabel('E[X(t)]', fontsize=11)
axes[1, 1].set_title('å¹³å‡ã¨åˆ†æ•£ã®æ™‚é–“ç™ºå±•', fontsize=12, fontweight='bold')
axes[1, 1].legend()
axes[1, 1].grid(alpha=0.3)

plt.tight_layout()
plt.show()

print("Ornstein-Uhlenbeckéç¨‹ã®æ¤œè¨¼:")
print(f"ç†è«–å®šå¸¸åˆ†å¸ƒ: N({mu}, {stationary_var:.4f})")
print(f"å®Ÿæ¸¬å®šå¸¸åˆ†å¸ƒ: N({final_values.mean():.4f}, {final_values.var():.4f})")</div>

            <h2>4.6 ç¢ºç‡ç©åˆ†ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³</h2>

            <h3>ğŸ’» ã‚³ãƒ¼ãƒ‰ä¾‹6: ç¢ºç‡ç©åˆ†ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³</h3>
            <div class="code-block"># ItÃ´ç©åˆ†ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³: I(t) = âˆ«â‚€áµ— f(s) dW(s)
np.random.seed(42)

def stochastic_integral(f_func, T, dt):
    """ç¢ºç‡ç©åˆ† âˆ«â‚€áµ— f(s) dW(s) ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³"""
    n_steps = int(T / dt)
    t = np.linspace(0, T, n_steps + 1)

    # Wieneréç¨‹ã®å¢—åˆ†
    dW = np.random.normal(0, np.sqrt(dt), n_steps)

    # ç¢ºç‡ç©åˆ†ã®è¨ˆç®—ï¼ˆItÃ´ç©åˆ†ï¼‰
    I = np.zeros(n_steps + 1)
    for i in range(n_steps):
        I[i+1] = I[i] + f_func(t[i]) * dW[i]

    return t, I

T = 5
dt = 0.01

fig, axes = plt.subplots(2, 2, figsize=(14, 10))

# (1) f(t) = 1 ã®å ´åˆ: âˆ«â‚€áµ— dW(s) = W(t)
f_const = lambda t: 1
n_paths = 20

for _ in range(n_paths):
    t, I = stochastic_integral(f_const, T, dt)
    axes[0, 0].plot(t, I, alpha=0.4, linewidth=1.5, color='#667eea')

axes[0, 0].set_xlabel('æ™‚é–“ t', fontsize=11)
axes[0, 0].set_ylabel('âˆ«â‚€áµ— dW(s)', fontsize=11)
axes[0, 0].set_title('ItÃ´ç©åˆ†: âˆ«â‚€áµ— dW(s) = W(t)', fontsize=12, fontweight='bold')
axes[0, 0].grid(alpha=0.3)

# (2) f(t) = t ã®å ´åˆ: âˆ«â‚€áµ— s dW(s)
f_linear = lambda t: t

for _ in range(n_paths):
    t, I = stochastic_integral(f_linear, T, dt)
    axes[0, 1].plot(t, I, alpha=0.4, linewidth=1.5, color='#764ba2')

axes[0, 1].set_xlabel('æ™‚é–“ t', fontsize=11)
axes[0, 1].set_ylabel('âˆ«â‚€áµ— s dW(s)', fontsize=11)
axes[0, 1].set_title('ItÃ´ç©åˆ†: âˆ«â‚€áµ— s dW(s)', fontsize=12, fontweight='bold')
axes[0, 1].grid(alpha=0.3)

# (3) ItÃ´ç©åˆ†ã®æ€§è³ª: E[I(t)] = 0
n_sims = 1000
final_values_const = []
final_values_linear = []

for _ in range(n_sims):
    t, I_const = stochastic_integral(f_const, T, dt)
    t, I_linear = stochastic_integral(f_linear, T, dt)
    final_values_const.append(I_const[-1])
    final_values_linear.append(I_linear[-1])

axes[1, 0].hist(final_values_const, bins=50, alpha=0.6, density=True,
                 color='#667eea', edgecolor='black', label='âˆ«â‚€áµ— dW(s)')
axes[1, 0].hist(final_values_linear, bins=50, alpha=0.6, density=True,
                 color='#764ba2', edgecolor='black', label='âˆ«â‚€áµ— s dW(s)')

axes[1, 0].axvline(0, color='red', linestyle='--', linewidth=2, label='E[I]=0')
axes[1, 0].set_xlabel('I(T)', fontsize=11)
axes[1, 0].set_ylabel('å¯†åº¦', fontsize=11)
axes[1, 0].set_title('ItÃ´ç©åˆ†ã®åˆ†å¸ƒ', fontsize=12, fontweight='bold')
axes[1, 0].legend()
axes[1, 0].grid(alpha=0.3)

# (4) ItÃ´ç©åˆ†ã®åˆ†æ•£: Var(âˆ«â‚€áµ— f(s) dW(s)) = âˆ«â‚€áµ— f(s)Â² ds
# f(t) = t ã®å ´åˆ: Var = âˆ«â‚€áµ— sÂ² ds = tÂ³/3
theoretical_var = T**3 / 3

print("ItÃ´ç©åˆ†ã®æ€§è³ª:")
print(f"âˆ«â‚€áµ— dW(s): E={np.mean(final_values_const):.6f}, Var={np.var(final_values_const):.4f} (ç†è«–Var={T:.4f})")
print(f"âˆ«â‚€áµ— s dW(s): E={np.mean(final_values_linear):.6f}, Var={np.var(final_values_linear):.4f} (ç†è«–Var={theoretical_var:.4f})")

# ItÃ´ç©åˆ†ã®äºŒä¹—å¯å¤‰åˆ†
# (âˆ«â‚€áµ— f(s) dW(s))Â² - âˆ«â‚€áµ— f(s)Â² ds ã¯ martingale
squared_integrals = []
quadratic_variations = []

for _ in range(n_sims):
    t, I = stochastic_integral(f_linear, T, dt)
    squared_integrals.append(I[-1]**2)
    # âˆ«â‚€áµ— sÂ² ds = tÂ³/3
    quadratic_variations.append(I[-1]**2 - T**3/3)

axes[1, 1].hist(quadratic_variations, bins=50, alpha=0.6,
                 color='#667eea', edgecolor='black')
axes[1, 1].axvline(np.mean(quadratic_variations), color='red',
                    linestyle='--', linewidth=2,
                    label=f'å¹³å‡={np.mean(quadratic_variations):.4f}')
axes[1, 1].set_xlabel('IÂ² - [I,I]', fontsize=11)
axes[1, 1].set_ylabel('é »åº¦', fontsize=11)
axes[1, 1].set_title('äºŒä¹—å¯å¤‰åˆ†ï¼ˆMartingaleæ€§ï¼‰', fontsize=12, fontweight='bold')
axes[1, 1].legend()
axes[1, 1].grid(alpha=0.3)

plt.tight_layout()
plt.show()</div>

            <h2>4.7 ãƒ©ãƒ³ã‚¸ãƒ¥ãƒãƒ³æ–¹ç¨‹å¼</h2>

            <h3>ğŸ’» ã‚³ãƒ¼ãƒ‰ä¾‹7: ãƒ©ãƒ³ã‚¸ãƒ¥ãƒãƒ³æ–¹ç¨‹å¼</h3>
            <div class="code-block"># ãƒ©ãƒ³ã‚¸ãƒ¥ãƒãƒ³æ–¹ç¨‹å¼ï¼ˆéæ¸›è¡°ç³»ï¼‰: dv = -Î³v dt + Ïƒ dW
# ææ–™ç§‘å­¦ã¸ã®å¿œç”¨ï¼šãƒ–ãƒ©ã‚¦ãƒ³ç²’å­ã®é‹å‹•

np.random.seed(42)

# ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
gamma = 1.0  # æ‘©æ“¦ä¿‚æ•°
sigma = np.sqrt(2 * gamma)  # ãƒœãƒ©ãƒ†ã‚£ãƒªãƒ†ã‚£ï¼ˆæºå‹•æ•£é€¸å®šç†ã«ã‚ˆã‚‹ï¼‰
T_sim = 20
dt = 0.01

# é€Ÿåº¦ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆOrnstein-Uhlenbeckéç¨‹ï¼‰
def simulate_velocity(v0, gamma, sigma, T, dt):
    """ãƒ©ãƒ³ã‚¸ãƒ¥ãƒãƒ³æ–¹ç¨‹å¼ã«ã‚ˆã‚‹é€Ÿåº¦ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³"""
    mu_func = lambda v, t: -gamma * v
    sigma_func = lambda v, t: sigma
    return euler_maruyama(mu_func, sigma_func, v0, T, dt)

fig, axes = plt.subplots(2, 2, figsize=(14, 10))

# (1) é€Ÿåº¦ã®æ™‚é–“ç™ºå±•
v0 = 5
n_paths = 50

for _ in range(n_paths):
    t, v = simulate_velocity(v0, gamma, sigma, T_sim, dt)
    axes[0, 0].plot(t, v, alpha=0.4, linewidth=1.5, color='#667eea')

axes[0, 0].axhline(y=0, color='red', linestyle='--', linewidth=2, label='å¹³è¡¡é€Ÿåº¦=0')
axes[0, 0].set_xlabel('æ™‚é–“', fontsize=11)
axes[0, 0].set_ylabel('é€Ÿåº¦ v(t)', fontsize=11)
axes[0, 0].set_title('ãƒ©ãƒ³ã‚¸ãƒ¥ãƒãƒ³æ–¹ç¨‹å¼ã«ã‚ˆã‚‹é€Ÿåº¦ã®æ™‚é–“ç™ºå±•', fontsize=12, fontweight='bold')
axes[0, 0].legend()
axes[0, 0].grid(alpha=0.3)

# (2) é€Ÿåº¦ã®å®šå¸¸åˆ†å¸ƒï¼ˆMaxwell-Boltzmannåˆ†å¸ƒï¼‰
n_sims = 5000
final_velocities = []

for _ in range(n_sims):
    t, v = simulate_velocity(v0, gamma, sigma, T_sim, dt)
    final_velocities.append(v[-1])

final_velocities = np.array(final_velocities)

axes[0, 1].hist(final_velocities, bins=50, density=True, alpha=0.6,
                 color='#667eea', edgecolor='black', label='ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³')

# ç†è«–åˆ†å¸ƒï¼ˆæºå‹•æ•£é€¸å®šç†ã«ã‚ˆã‚Š N(0, ÏƒÂ²/(2Î³))ï¼‰
x = np.linspace(final_velocities.min(), final_velocities.max(), 1000)
stationary_var = sigma**2 / (2 * gamma)
stationary_pdf = stats.norm.pdf(x, 0, np.sqrt(stationary_var))
axes[0, 1].plot(x, stationary_pdf, 'r-', linewidth=2.5,
                 label=f'N(0, {stationary_var:.2f})')

axes[0, 1].set_xlabel('é€Ÿåº¦ v', fontsize=11)
axes[0, 1].set_ylabel('å¯†åº¦', fontsize=11)
axes[0, 1].set_title('é€Ÿåº¦ã®å®šå¸¸åˆ†å¸ƒï¼ˆMaxwell-Boltzmannï¼‰', fontsize=12, fontweight='bold')
axes[0, 1].legend()
axes[0, 1].grid(alpha=0.3)

# (3) ä½ç½®ã®æ™‚é–“ç™ºå±•ï¼ˆé€Ÿåº¦ã‚’ç©åˆ†ï¼‰
def simulate_position(v0, gamma, sigma, T, dt):
    """ä½ç½®ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆé€Ÿåº¦ã‚’æ™‚é–“ç©åˆ†ï¼‰"""
    t, v = simulate_velocity(v0, gamma, sigma, T, dt)
    x = np.cumsum(v) * dt
    return t, x, v

for _ in range(20):
    t, x, v = simulate_position(v0, gamma, sigma, T_sim, dt)
    axes[1, 0].plot(t, x, alpha=0.4, linewidth=1.5, color='#764ba2')

axes[1, 0].set_xlabel('æ™‚é–“', fontsize=11)
axes[1, 0].set_ylabel('ä½ç½® x(t)', fontsize=11)
axes[1, 0].set_title('ãƒ–ãƒ©ã‚¦ãƒ³ç²’å­ã®ä½ç½®ï¼ˆæ‹¡æ•£ï¼‰', fontsize=12, fontweight='bold')
axes[1, 0].grid(alpha=0.3)

# (4) å¹³å‡äºŒä¹—å¤‰ä½ï¼ˆMSD: Mean Square Displacementï¼‰
# æ‹¡æ•£ä¿‚æ•°ã®æ¸¬å®š
n_paths_msd = 500
all_positions = []

for _ in range(n_paths_msd):
    t, x, v = simulate_position(0, gamma, sigma, T_sim, dt)
    all_positions.append(x)

all_positions = np.array(all_positions)
msd = np.mean(all_positions**2, axis=0)

# ç†è«–çš„MSDï¼ˆé•·æ™‚é–“æ¥µé™ï¼‰: <xÂ²> = 2Dt, D = ÏƒÂ²/(2Î³Â²) = 1/Î³
D_theory = 1 / gamma
msd_theory = 2 * D_theory * t

axes[1, 1].plot(t, msd, color='#667eea', linewidth=2.5, label='å®Ÿæ¸¬MSD')
axes[1, 1].plot(t, msd_theory, 'r--', linewidth=2, label=f'ç†è«–MSD=2Dt (D={D_theory:.2f})')
axes[1, 1].set_xlabel('æ™‚é–“', fontsize=11)
axes[1, 1].set_ylabel('<xÂ²(t)>', fontsize=11)
axes[1, 1].set_title('å¹³å‡äºŒä¹—å¤‰ä½ï¼ˆæ‹¡æ•£ä¿‚æ•°ã®æ¸¬å®šï¼‰', fontsize=12, fontweight='bold')
axes[1, 1].legend()
axes[1, 1].grid(alpha=0.3)

plt.tight_layout()
plt.show()

# æ‹¡æ•£ä¿‚æ•°ã®æ¸¬å®š
# MSD = 2Dt ã®å‚¾ãã‹ã‚‰æ‹¡æ•£ä¿‚æ•°ã‚’æ¨å®š
from scipy.stats import linregress
slope, intercept, r_value, p_value, std_err = linregress(t[100:], msd[100:])
D_measured = slope / 2

print("ãƒ©ãƒ³ã‚¸ãƒ¥ãƒãƒ³æ–¹ç¨‹å¼ã«ã‚ˆã‚‹æ‹¡æ•£:")
print(f"ç†è«–æ‹¡æ•£ä¿‚æ•°: D = ÏƒÂ²/(2Î³Â²) = {D_theory:.4f}")
print(f"æ¸¬å®šæ‹¡æ•£ä¿‚æ•°: D = {D_measured:.4f}")
print(f"Einsteiné–¢ä¿‚å¼: D = kT/Î³ï¼ˆæºå‹•æ•£é€¸å®šç†ï¼‰")</div>

            <div class="note">
                <strong>ğŸ’¡ Note:</strong> ãƒ©ãƒ³ã‚¸ãƒ¥ãƒãƒ³æ–¹ç¨‹å¼ã¯ã€ãƒ–ãƒ©ã‚¦ãƒ³ç²’å­ã®é‹å‹•ã€ã‚³ãƒ­ã‚¤ãƒ‰ã®æ‹¡æ•£ã€ãƒãƒªãƒãƒ¼ã®å‹•åŠ›å­¦ãªã©ã€ææ–™ç§‘å­¦ã«ãŠã‘ã‚‹æ§˜ã€…ãªç¾è±¡ã®ãƒ¢ãƒ‡ãƒªãƒ³ã‚°ã«ä½¿ã‚ã‚Œã¾ã™ã€‚æºå‹•æ•£é€¸å®šç†ã«ã‚ˆã‚Šã€ç†±å¹³è¡¡çŠ¶æ…‹ã§ã¯æ‘©æ“¦ã¨ãƒ©ãƒ³ãƒ€ãƒ åŠ›ã®å¼·åº¦ãŒé–¢ä¿‚ã¥ã‘ã‚‰ã‚Œã¾ã™ã€‚
            </div>

            <h2>æ¼”ç¿’å•é¡Œ</h2>

            <div class="exercise">
                <strong>ğŸ“ æ¼”ç¿’1: Wieneréç¨‹ã®æ€§è³ª</strong><br>
                Wieneréç¨‹ W(t) ã«ã¤ã„ã¦ï¼š
                <ol>
                    <li>W(2) - W(1) ã¨ W(4) - W(3) ãŒç‹¬ç«‹ã§ã‚ã‚‹ã“ã¨ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã§ç¢ºèªã›ã‚ˆ</li>
                    <li>Cov(W(2), W(5)) = min(2, 5) = 2 ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã§æ¤œè¨¼ã›ã‚ˆ</li>
                    <li>W(t) ã®çµŒè·¯ãŒè‡³ã‚‹æ‰€å¾®åˆ†ä¸å¯èƒ½ã§ã‚ã‚‹ã“ã¨ã‚’ã€æ•°å€¤å¾®åˆ†ã§ç¢ºèªã›ã‚ˆ</li>
                </ol>
            </div>

            <div class="exercise">
                <strong>ğŸ“ æ¼”ç¿’2: å¹¾ä½•ãƒ–ãƒ©ã‚¦ãƒ³é‹å‹•ã®å¿œç”¨</strong><br>
                åˆæœŸæ ªä¾¡ Sâ‚€=100, Î¼=0.08, Ïƒ=0.25 ã®å¹¾ä½•ãƒ–ãƒ©ã‚¦ãƒ³é‹å‹•ã‚’è€ƒãˆã‚‹ï¼š
                <ol>
                    <li>1å¹´å¾Œã®æ ªä¾¡åˆ†å¸ƒã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã—ã€ãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ ã§å¯è¦–åŒ–ã›ã‚ˆ</li>
                    <li>è¡Œä½¿ä¾¡æ ¼ K=110 ã®ãƒ¨ãƒ¼ãƒ­ãƒ”ã‚¢ãƒ³ã‚³ãƒ¼ãƒ«ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®ä¾¡æ ¼ã‚’ãƒ¢ãƒ³ãƒ†ã‚«ãƒ«ãƒ­æ³•ã§è¨ˆç®—ã›ã‚ˆ</li>
                    <li>Black-Scholeså…¬å¼ã¨æ¯”è¼ƒã—ã€èª¤å·®ã‚’è©•ä¾¡ã›ã‚ˆ</li>
                </ol>
            </div>

            <div class="exercise">
                <strong>ğŸ“ æ¼”ç¿’3: Ornstein-Uhlenbeckéç¨‹ã®è§£æ</strong><br>
                OUéç¨‹ dX = 3(2-X)dt + 1.5 dW ã«ã¤ã„ã¦ï¼š
                <ol>
                    <li>Xâ‚€=5 ã‹ã‚‰é–‹å§‹ã™ã‚‹ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å®Ÿè¡Œã—ã€å¹³å‡ã¸ã®åæŸã‚’å¯è¦–åŒ–ã›ã‚ˆ</li>
                    <li>å®šå¸¸åˆ†å¸ƒã‚’ç†è«–å€¤ã¨æ¯”è¼ƒã›ã‚ˆ</li>
                    <li>å›å¸°é€Ÿåº¦ Î¸ ã‚’å¤‰åŒ–ã•ã›ãŸã¨ãã€åæŸæ™‚é–“ãŒã©ã†å¤‰ã‚ã‚‹ã‹ã‚’èª¿ã¹ã‚ˆ</li>
                </ol>
            </div>

            <div class="nav-buttons">
                <a href="chapter-3.html" class="nav-button">â† ç¬¬3ç« </a>
                <a href="chapter-5.html" class="nav-button">ç¬¬5ç« ã¸ â†’</a>
            </div>
        </div>
    </div>

    <footer>
        <p>&copy; 2025 AI Terakoya - Fundamentals of Mathematics & Physics Dojo</p>
    </footer>
</body>
</html>
