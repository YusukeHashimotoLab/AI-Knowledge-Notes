<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç¬¬4ç« : å¤‰åˆ†æ³•ã¨æœ€é©åŒ– | FM Dojo - åå¾®åˆ†æ–¹ç¨‹å¼ã¨å¢ƒç•Œå€¤å•é¡Œ</title>
    <meta name="description" content="å¤‰åˆ†æ³•ã¨æœ€é©åŒ–ï¼šã‚ªã‚¤ãƒ©ãƒ¼-ãƒ©ã‚°ãƒ©ãƒ³ã‚¸ãƒ¥æ–¹ç¨‹å¼ã€æ±é–¢æ•°ã®æ¥µå€¤å•é¡Œã€æœ€é€Ÿé™ä¸‹ç·šã€æ¸¬åœ°ç·šã€æœ€å°ä½œç”¨ã®åŸç†ã€ç­‰å‘¨å•é¡Œã‚’å­¦ã³ã€ææ–™ç§‘å­¦ã¸ã®å¿œç”¨ã‚’å®Ÿè£…ã—ã¾ã™ã€‚">
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            line-height: 1.8;
            color: #333;
            background: #f5f5f5;
        }
        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 2rem 1rem;
            text-align: center;
        }
        .breadcrumb {
            max-width: 1200px;
            margin: 1rem auto;
            padding: 0 1rem;
            font-size: 0.9rem;
        }
        .breadcrumb a { color: #667eea; text-decoration: none; }
        .breadcrumb a:hover { text-decoration: underline; }
        .container {
            max-width: 1200px;
            margin: 2rem auto;
            padding: 0 1rem;
        }
        .content {
            background: white;
            padding: 2rem;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            margin-bottom: 2rem;
        }
        h1 { font-size: 2rem; margin-bottom: 1rem; }
        h2 {
            font-size: 1.5rem;
            margin: 2rem 0 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 3px solid #764ba2;
            color: #667eea;
        }
        h3 { font-size: 1.2rem; margin: 1.5rem 0 1rem; color: #555; }
        p { margin-bottom: 1rem; }
        ul, ol { margin: 1rem 0 1rem 2rem; }
        li { margin-bottom: 0.5rem; }
        .theory-box {
            background: linear-gradient(to right, #f0f4ff, #faf5ff);
            border-left: 4px solid #667eea;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-radius: 8px;
        }
        .code-example {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 1.5rem;
            border-radius: 8px;
            overflow-x: auto;
            margin: 1rem 0;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            line-height: 1.6;
        }
        .code-title {
            background: #667eea;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 6px 6px 0 0;
            font-weight: 600;
            margin-top: 1.5rem;
        }
        .exercise {
            background: #fff9e6;
            border-left: 4px solid #f59e0b;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-radius: 8px;
        }
        .navigation {
            display: flex;
            justify-content: space-between;
            margin-top: 3rem;
            gap: 1rem;
        }
        .nav-button {
            padding: 0.75rem 1.5rem;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            text-decoration: none;
            border-radius: 8px;
            font-weight: 600;
            transition: transform 0.3s;
        }
        .nav-button:hover { transform: translateY(-2px); }
        footer {
            background: #2c3e50;
            color: white;
            text-align: center;
            padding: 2rem 1rem;
            margin-top: 4rem;
        }
        @media (max-width: 768px) {
            .content { padding: 1.5rem; }
            h1 { font-size: 1.5rem; }
            h2 { font-size: 1.3rem; }
            .navigation { flex-direction: column; }
        }
    </style>
</head>
<body>
    <header>
        <h1>ğŸ“ ç¬¬4ç« : å¤‰åˆ†æ³•ã¨æœ€é©åŒ–</h1>
        <p>Calculus of Variations and Optimization</p>
    </header>

    <div class="breadcrumb">
        <a href="../../index.html">ãƒŠãƒ¬ãƒƒã‚¸ãƒ™ãƒ¼ã‚¹</a> &gt;
        <a href="../index.html">FM Dojo</a> &gt;
        <a href="index.html">åå¾®åˆ†æ–¹ç¨‹å¼ã¨å¢ƒç•Œå€¤å•é¡Œ</a> &gt;
        ç¬¬4ç« 
    </div>

    <div class="container">
        <div class="content">
            <h2>ğŸ¯ å­¦ç¿’ç›®æ¨™</h2>
            <ul>
                <li>å¤‰åˆ†æ³•ã®åŸºç¤æ¦‚å¿µã¨æ±é–¢æ•°ã‚’ç†è§£ã™ã‚‹</li>
                <li>ã‚ªã‚¤ãƒ©ãƒ¼-ãƒ©ã‚°ãƒ©ãƒ³ã‚¸ãƒ¥æ–¹ç¨‹å¼ã®å°å‡ºã¨å¿œç”¨ã‚’å­¦ã¶</li>
                <li>æœ€é€Ÿé™ä¸‹ç·šï¼ˆãƒ–ãƒ©ã‚­ã‚¹ãƒˆã‚¯ãƒ­ãƒ³æ›²ç·šï¼‰å•é¡Œã‚’è§£ã</li>
                <li>æ¸¬åœ°ç·šã¨æœ€çŸ­çµŒè·¯å•é¡Œã‚’ç†è§£ã™ã‚‹</li>
                <li>æœ€å°ä½œç”¨ã®åŸç†ã¨ç‰©ç†å­¦ã¸ã®å¿œç”¨ã‚’å­¦ã¶</li>
                <li>ç­‰å‘¨å•é¡Œã¨æ¡ä»¶ä»˜ãæ¥µå€¤å•é¡Œã‚’æ‰±ã†</li>
                <li>æœ‰é™è¦ç´ æ³•ã®åŸºç¤ã¨ã‚¬ãƒ©ãƒ¼ã‚­ãƒ³æ³•ã‚’å®Ÿè£…ã™ã‚‹</li>
                <li>ææ–™ç§‘å­¦ã¸ã®å¿œç”¨ï¼ˆå¼¾æ€§å¤‰å½¢ã€å½¢çŠ¶æœ€é©åŒ–ï¼‰ã‚’ç†è§£ã™ã‚‹</li>
            </ul>
        </div>

        <div class="content">
            <h2>ğŸ“– å¤‰åˆ†æ³•ã¨ã¯</h2>
            
            <div class="theory-box">
                <h3>æ±é–¢æ•°ã¨å¤‰åˆ†</h3>
                <p><strong>æ±é–¢æ•°ï¼ˆfunctionalï¼‰</strong>ã¯ã€é–¢æ•°ã‚’å…¥åŠ›ã¨ã—ã¦å®Ÿæ•°ã‚’å‡ºåŠ›ã™ã‚‹å†™åƒã§ã™ï¼š</p>
                <p>\[
                J[y] = \int_{x_1}^{x_2} F(x, y(x), y'(x)) dx
                \]</p>
                <p><strong>å¤‰åˆ†å•é¡Œ</strong>: æ±é–¢æ•° \(J[y]\) ã‚’æ¥µå€¤åŒ–ã™ã‚‹é–¢æ•° \(y(x)\) ã‚’æ±‚ã‚ã‚‹</p>
                <p><strong>å¤‰åˆ†ï¼ˆvariationï¼‰</strong> \(\delta y\): é–¢æ•° \(y(x)\) ã®å¾®å°å¤‰åŒ–</p>
                <p>\[
                y(x) \to y(x) + \epsilon \eta(x), \quad \eta(x_1) = \eta(x_2) = 0
                \]</p>
                <p>æ±é–¢æ•°ã®1æ¬¡å¤‰åˆ†ãŒã‚¼ãƒ­ã¨ãªã‚‹æ¡ä»¶ãŒæ¥µå€¤æ¡ä»¶ã§ã™ï¼š</p>
                <p>\[
                \delta J = \frac{d}{d\epsilon}J[y + \epsilon\eta]\bigg|_{\epsilon=0} = 0
                \]</p>
            </div>

            <div class="theory-box">
                <h3>ã‚ªã‚¤ãƒ©ãƒ¼-ãƒ©ã‚°ãƒ©ãƒ³ã‚¸ãƒ¥æ–¹ç¨‹å¼</h3>
                <p>æ±é–¢æ•° \(J[y] = \int F(x, y, y') dx\) ã‚’æ¥µå€¤åŒ–ã™ã‚‹é–¢æ•° \(y(x)\) ã¯ã€ä»¥ä¸‹ã®å¾®åˆ†æ–¹ç¨‹å¼ã‚’æº€ãŸã—ã¾ã™ï¼š</p>
                <p>\[
                \frac{\partial F}{\partial y} - \frac{d}{dx}\left(\frac{\partial F}{\partial y'}\right) = 0
                \]</p>
                <p>ã“ã‚Œã‚’<strong>ã‚ªã‚¤ãƒ©ãƒ¼-ãƒ©ã‚°ãƒ©ãƒ³ã‚¸ãƒ¥æ–¹ç¨‹å¼ï¼ˆEuler-Lagrange equationï¼‰</strong>ã¨å‘¼ã³ã¾ã™ã€‚</p>
            </div>

            <h3>ç‰©ç†çš„æ„ç¾©</h3>
            <ul>
                <li><strong>æœ€å°ä½œç”¨ã®åŸç†</strong>: ç‰©ç†ç³»ã®é‹å‹•ã¯ä½œç”¨ç©åˆ†ã‚’æ¥µå€¤åŒ–ã™ã‚‹çµŒè·¯ã«æ²¿ã£ã¦èµ·ã“ã‚‹</li>
                <li><strong>ã‚¨ãƒãƒ«ã‚®ãƒ¼æœ€å°åŒ–</strong>: å¹³è¡¡çŠ¶æ…‹ã¯ã‚¨ãƒãƒ«ã‚®ãƒ¼æ±é–¢æ•°ã‚’æœ€å°åŒ–ã™ã‚‹</li>
                <li><strong>å¼¾æ€§å¤‰å½¢</strong>: å¼¾æ€§ä½“ã®å¤‰å½¢ã¯ã²ãšã¿ã‚¨ãƒãƒ«ã‚®ãƒ¼ã‚’æœ€å°åŒ–ã™ã‚‹</li>
                <li><strong>å½¢çŠ¶æœ€é©åŒ–</strong>: æ§‹é€ ç‰©ã®å½¢çŠ¶è¨­è¨ˆã§æ€§èƒ½æ±é–¢æ•°ã‚’æœ€é©åŒ–</li>
            </ul>
        </div>

        <div class="content">
            <h2>ğŸ’» ä¾‹é¡Œ4.1: æœ€çŸ­çµŒè·¯å•é¡Œï¼ˆç›´ç·šã®å°å‡ºï¼‰</h2>
            
            <div class="theory-box">
                <h3>æœ€çŸ­çµŒè·¯å•é¡Œ</h3>
                <p>2ç‚¹ \((x_1, y_1)\) ã¨ \((x_2, y_2)\) ã‚’çµã¶æœ€çŸ­æ›²ç·šã‚’æ±‚ã‚ã¾ã™ã€‚</p>
                <p>æ›²ç·šã®é•·ã•ã®æ±é–¢æ•°ï¼š</p>
                <p>\[
                J[y] = \int_{x_1}^{x_2} \sqrt{1 + (y')^2} dx
                \]</p>
                <p>ã‚ªã‚¤ãƒ©ãƒ¼-ãƒ©ã‚°ãƒ©ãƒ³ã‚¸ãƒ¥æ–¹ç¨‹å¼ã‹ã‚‰ \(y'' = 0\) ãŒå¾—ã‚‰ã‚Œã€è§£ã¯ç›´ç·šã§ã™ã€‚</p>
            </div>

            <div class="code-title">Pythonå®Ÿè£…: æœ€çŸ­çµŒè·¯ã®æ•°å€¤è¨ˆç®—</div>
            <div class="code-example">import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import minimize

# 2ç‚¹é–“ã®æœ€çŸ­çµŒè·¯å•é¡Œ
x1, y1 = 0.0, 0.0
x2, y2 = 1.0, 1.0

def curve_length(y_values, x_values):
    """æ›²ç·šã®é•·ã•ã‚’è¨ˆç®—"""
    dy = np.diff(y_values)
    dx = np.diff(x_values)
    ds = np.sqrt(dx**2 + dy**2)
    return np.sum(ds)

def curve_length_functional(y_interior, x_values):
    """æ±é–¢æ•°ï¼ˆå¢ƒç•Œæ¡ä»¶ã‚’å«ã‚€ï¼‰"""
    y_values = np.concatenate([[y1], y_interior, [y2]])
    return curve_length(y_values, x_values)

# é›¢æ•£åŒ–
N = 20
x_values = np.linspace(x1, x2, N)

# åˆæœŸæ¨æ¸¬ï¼ˆæ”¾ç‰©ç·šï¼‰
y_initial = y1 + (y2 - y1) * (x_values - x1) / (x2 - x1) + \
            0.5 * np.sin(np.pi * (x_values - x1) / (x2 - x1))

# å¢ƒç•Œç‚¹ã‚’é™¤ã„ãŸå†…éƒ¨ç‚¹ã®ã¿ã‚’æœ€é©åŒ–
y_interior_initial = y_initial[1:-1]

# æœ€é©åŒ–
result = minimize(curve_length_functional, y_interior_initial, 
                  args=(x_values,), method='BFGS')

y_optimal = np.concatenate([[y1], result.x, [y2]])

# è§£æè§£ï¼ˆç›´ç·šï¼‰
y_analytical = y1 + (y2 - y1) * (x_values - x1) / (x2 - x1)

# å¯è¦–åŒ–
fig, axes = plt.subplots(1, 2, figsize=(14, 5))

# æ›²ç·šã®æ¯”è¼ƒ
ax1 = axes[0]
ax1.plot(x_values, y_initial, 'b--', label='åˆæœŸæ¨æ¸¬ï¼ˆæ”¾ç‰©ç·šï¼‰', linewidth=2, alpha=0.7)
ax1.plot(x_values, y_optimal, 'r-', label='æœ€é©åŒ–çµæœ', linewidth=2, marker='o', markersize=4)
ax1.plot(x_values, y_analytical, 'g:', label='è§£æè§£ï¼ˆç›´ç·šï¼‰', linewidth=3)
ax1.plot([x1, x2], [y1, y2], 'ko', markersize=8, label='å¢ƒç•Œç‚¹')
ax1.set_xlabel('x')
ax1.set_ylabel('y')
ax1.set_title('æœ€çŸ­çµŒè·¯å•é¡Œ')
ax1.legend()
ax1.grid(True, alpha=0.3)
ax1.axis('equal')

# æ›²ç·šé•·ã®æ¯”è¼ƒ
ax2 = axes[1]
lengths = {
    'åˆæœŸæ¨æ¸¬': curve_length(y_initial, x_values),
    'æœ€é©åŒ–çµæœ': curve_length(y_optimal, x_values),
    'è§£æè§£': curve_length(y_analytical, x_values)
}
colors = ['blue', 'red', 'green']
bars = ax2.bar(lengths.keys(), lengths.values(), color=colors, alpha=0.7)
ax2.set_ylabel('Curve length')
ax2.set_title('æ›²ç·šé•·ã®æ¯”è¼ƒ')
ax2.grid(True, axis='y', alpha=0.3)

for bar, (name, length) in zip(bars, lengths.items()):
    ax2.text(bar.get_x() + bar.get_width()/2, bar.get_height() + 0.01, 
             f'{length:.4f}', ha='center', fontweight='bold')

plt.tight_layout()
plt.savefig('variation_shortest_path.png', dpi=300, bbox_inches='tight')
plt.show()

print("=== æœ€çŸ­çµŒè·¯å•é¡Œ ===")
for name, length in lengths.items():
    print(f"{name}: {length:.6f}")
print(f"ç†è«–å€¤: {np.sqrt((x2-x1)**2 + (y2-y1)**2):.6f}")
</div>
        </div>

        <div class="content">
            <h2>ğŸ’» ä¾‹é¡Œ4.2: æœ€é€Ÿé™ä¸‹ç·šï¼ˆãƒ–ãƒ©ã‚­ã‚¹ãƒˆã‚¯ãƒ­ãƒ³æ›²ç·šï¼‰</h2>
            
            <div class="theory-box">
                <h3>æœ€é€Ÿé™ä¸‹ç·šå•é¡Œ</h3>
                <p>é‡åŠ›ä¸‹ã§2ç‚¹é–“ã‚’æœ€çŸ­æ™‚é–“ã§ç§»å‹•ã™ã‚‹æ›²ç·šï¼ˆãƒ–ãƒ©ã‚­ã‚¹ãƒˆã‚¯ãƒ­ãƒ³æ›²ç·šï¼‰ã‚’æ±‚ã‚ã¾ã™ã€‚</p>
                <p>ã‚¨ãƒãƒ«ã‚®ãƒ¼ä¿å­˜å‰‡ã‹ã‚‰é€Ÿåº¦ \(v = \sqrt{2gy}\)ã€é™ä¸‹æ™‚é–“ã®æ±é–¢æ•°ï¼š</p>
                <p>\[
                T[y] = \int_{x_1}^{x_2} \frac{\sqrt{1 + (y')^2}}{\sqrt{2gy}} dx
                \]</p>
                <p>è§£ã¯ã‚µã‚¤ã‚¯ãƒ­ã‚¤ãƒ‰æ›²ç·šã§ã™ï¼š</p>
                <p>\[
                x = a(\theta - \sin\theta), \quad y = a(1 - \cos\theta)
                \]</p>
            </div>

            <div class="code-title">Pythonå®Ÿè£…: ãƒ–ãƒ©ã‚­ã‚¹ãƒˆã‚¯ãƒ­ãƒ³æ›²ç·š</div>
            <div class="code-example">import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import minimize

# ãƒ–ãƒ©ã‚­ã‚¹ãƒˆã‚¯ãƒ­ãƒ³æ›²ç·š
g = 9.8  # é‡åŠ›åŠ é€Ÿåº¦ (m/sÂ²)
x_start, y_start = 0.0, 0.0
x_end, y_end = 2.0, -1.0  # yè»¸ä¸‹å‘ãã«è½ä¸‹

def descent_time(y_values, x_values):
    """é™ä¸‹æ™‚é–“ã‚’è¨ˆç®—"""
    time = 0.0
    for i in range(len(x_values) - 1):
        dx = x_values[i+1] - x_values[i]
        dy = y_values[i+1] - y_values[i]
        ds = np.sqrt(dx**2 + dy**2)
        
        # é€Ÿåº¦: v = sqrt(2g|y|) ï¼ˆy_start ã‹ã‚‰ã®è½ä¸‹è·é›¢ï¼‰
        y_avg = (y_values[i] + y_values[i+1]) / 2
        h = abs(y_avg - y_start)
        if h < 1e-10:
            h = 1e-10
        v = np.sqrt(2 * g * h)
        
        time += ds / v
    
    return time

def descent_time_functional(y_interior, x_values):
    """æ±é–¢æ•°ï¼ˆå¢ƒç•Œæ¡ä»¶ã‚’å«ã‚€ï¼‰"""
    y_values = np.concatenate([[y_start], y_interior, [y_end]])
    return descent_time(y_values, x_values)

# é›¢æ•£åŒ–
N = 50
x_values = np.linspace(x_start, x_end, N)

# åˆæœŸæ¨æ¸¬ï¼ˆç›´ç·šï¼‰
y_line = y_start + (y_end - y_start) * (x_values - x_start) / (x_end - x_start)

# æœ€é©åŒ–
y_interior_initial = y_line[1:-1]
result = minimize(descent_time_functional, y_interior_initial, 
                  args=(x_values,), method='BFGS', 
                  options={'maxiter': 1000})

y_optimal = np.concatenate([[y_start], result.x, [y_end]])

# è§£æè§£ï¼ˆã‚µã‚¤ã‚¯ãƒ­ã‚¤ãƒ‰ï¼‰
def cycloid(x, a):
    """ã‚µã‚¤ã‚¯ãƒ­ã‚¤ãƒ‰æ›²ç·šã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿è¡¨ç¾"""
    theta_max = 2 * np.pi
    theta = np.linspace(0, theta_max, 1000)
    x_cyc = a * (theta - np.sin(theta))
    y_cyc = -a * (1 - np.cos(theta))  # yè»¸ä¸‹å‘ã
    
    # x_end ã«åˆ°é”ã™ã‚‹ç‚¹ã‚’è¦‹ã¤ã‘ã‚‹
    idx_end = np.argmin(np.abs(x_cyc - x_end))
    scale = x_end / x_cyc[idx_end]
    
    return a * scale * (theta[:idx_end] - np.sin(theta[:idx_end])), \
           -a * scale * (1 - np.cos(theta[:idx_end]))

# ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ a ã‚’èª¿æ•´
a = 0.5
x_cycloid, y_cycloid = cycloid(x_values, a)

# é™ä¸‹æ™‚é–“ã®è¨ˆç®—
time_line = descent_time(y_line, x_values)
time_optimal = descent_time(y_optimal, x_values)
time_cycloid = descent_time(np.interp(x_values, x_cycloid, y_cycloid), x_values)

# å¯è¦–åŒ–
fig, axes = plt.subplots(1, 2, figsize=(14, 6))

# æ›²ç·šã®æ¯”è¼ƒ
ax1 = axes[0]
ax1.plot(x_values, y_line, 'b--', label=f'ç›´ç·š (t={time_line:.3f}s)', linewidth=2)
ax1.plot(x_values, y_optimal, 'r-', label=f'æœ€é©åŒ–çµæœ (t={time_optimal:.3f}s)', 
         linewidth=2, marker='o', markersize=3)
ax1.plot(x_cycloid, y_cycloid, 'g:', label=f'ã‚µã‚¤ã‚¯ãƒ­ã‚¤ãƒ‰ (t={time_cycloid:.3f}s)', 
         linewidth=3)
ax1.plot([x_start, x_end], [y_start, y_end], 'ko', markersize=8, label='å¢ƒç•Œç‚¹')
ax1.set_xlabel('x (m)')
ax1.set_ylabel('y (m)')
ax1.set_title('æœ€é€Ÿé™ä¸‹ç·šï¼ˆãƒ–ãƒ©ã‚­ã‚¹ãƒˆã‚¯ãƒ­ãƒ³æ›²ç·šï¼‰')
ax1.legend()
ax1.grid(True, alpha=0.3)
ax1.axis('equal')

# é™ä¸‹æ™‚é–“ã®æ¯”è¼ƒ
ax2 = axes[1]
times = {
    'ç›´ç·š': time_line,
    'æœ€é©åŒ–çµæœ': time_optimal,
    'ã‚µã‚¤ã‚¯ãƒ­ã‚¤ãƒ‰': time_cycloid
}
colors = ['blue', 'red', 'green']
bars = ax2.bar(times.keys(), times.values(), color=colors, alpha=0.7)
ax2.set_ylabel('Descent time (s)')
ax2.set_title('é™ä¸‹æ™‚é–“ã®æ¯”è¼ƒ')
ax2.grid(True, axis='y', alpha=0.3)

for bar, (name, time) in zip(bars, times.items()):
    ax2.text(bar.get_x() + bar.get_width()/2, bar.get_height() + 0.01, 
             f'{time:.3f}s', ha='center', fontweight='bold')

plt.tight_layout()
plt.savefig('variation_brachistochrone.png', dpi=300, bbox_inches='tight')
plt.show()

print("=== æœ€é€Ÿé™ä¸‹ç·šå•é¡Œ ===")
for name, time in times.items():
    print(f"{name}: {time:.4f} s")
print(f"æœ€é©åŒ–ã«ã‚ˆã‚‹æ™‚é–“çŸ­ç¸®: {(time_line - time_optimal)/time_line * 100:.2f}%")
</div>
        </div>

        <div class="content">
            <h2>ğŸ’» ä¾‹é¡Œ4.3: æ¸¬åœ°ç·šå•é¡Œï¼ˆçƒé¢ä¸Šã®æœ€çŸ­çµŒè·¯ï¼‰</h2>
            
            <div class="theory-box">
                <h3>æ¸¬åœ°ç·š</h3>
                <p><strong>æ¸¬åœ°ç·šï¼ˆgeodesicï¼‰</strong>ã¯ã€æ›²é¢ä¸Šã®2ç‚¹é–“ã®æœ€çŸ­æ›²ç·šã§ã™ã€‚</p>
                <p>çƒé¢ \((x^2 + y^2 + z^2 = R^2)\) ä¸Šã®æ¸¬åœ°ç·šã¯å¤§å††ï¼ˆçƒã®ä¸­å¿ƒã‚’é€šã‚‹å¹³é¢ã¨ã®äº¤ç·šï¼‰ã§ã™ã€‚</p>
                <p>çƒé¢åº§æ¨™ \((\theta, \phi)\) ã§ã®æ›²ç·šé•·ã®æ±é–¢æ•°ï¼š</p>
                <p>\[
                J[\phi] = \int_{\theta_1}^{\theta_2} R\sqrt{1 + \sin^2\theta \cdot (\phi')^2} d\theta
                \]</p>
            </div>

            <div class="code-title">Pythonå®Ÿè£…: çƒé¢ä¸Šã®æ¸¬åœ°ç·š</div>
            <div class="code-example">import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

# çƒé¢ä¸Šã®2ç‚¹é–“ã®æ¸¬åœ°ç·š
R = 1.0  # çƒã®åŠå¾„

# çƒé¢åº§æ¨™ â†’ ãƒ‡ã‚«ãƒ«ãƒˆåº§æ¨™
def spherical_to_cartesian(theta, phi, R=1.0):
    x = R * np.sin(theta) * np.cos(phi)
    y = R * np.sin(theta) * np.sin(phi)
    z = R * np.cos(theta)
    return x, y, z

# ãƒ‡ã‚«ãƒ«ãƒˆåº§æ¨™ â†’ çƒé¢åº§æ¨™
def cartesian_to_spherical(x, y, z):
    R = np.sqrt(x**2 + y**2 + z**2)
    theta = np.arccos(z / R)
    phi = np.arctan2(y, x)
    return theta, phi, R

# 2ç‚¹ã‚’è¨­å®šï¼ˆåŒ—æ¥µã¨èµ¤é“ä¸Šã®ç‚¹ï¼‰
theta1, phi1 = np.pi/6, 0.0  # 30åº¦, 0åº¦
theta2, phi2 = np.pi/2, np.pi/2  # 90åº¦, 90åº¦

x1, y1, z1 = spherical_to_cartesian(theta1, phi1, R)
x2, y2, z2 = spherical_to_cartesian(theta2, phi2, R)

# å¤§å††ï¼ˆæ¸¬åœ°ç·šï¼‰ã®è§£æè§£
# 2ç‚¹ã‚’é€šã‚‹å¹³é¢ã®æ³•ç·šãƒ™ã‚¯ãƒˆãƒ«
p1 = np.array([x1, y1, z1])
p2 = np.array([x2, y2, z2])
normal = np.cross(p1, p2)
normal = normal / np.linalg.norm(normal)

# å¤§å††ä¸Šã®ç‚¹ï¼ˆãƒ‘ãƒ©ãƒ¡ãƒˆãƒªãƒƒã‚¯è¡¨ç¾ï¼‰
t = np.linspace(0, 1, 100)
# p1 ã‹ã‚‰ p2 ã¸ã®çƒé¢è£œé–“ï¼ˆslerpï¼‰
angle = np.arccos(np.clip(np.dot(p1, p2) / (R**2), -1, 1))
geodesic_points = []
for ti in t:
    point = (np.sin((1-ti)*angle) * p1 + np.sin(ti*angle) * p2) / np.sin(angle)
    geodesic_points.append(point)
geodesic_points = np.array(geodesic_points)

# æ¯”è¼ƒ: å˜ç´”ãªç·šå½¢è£œé–“ï¼ˆçƒé¢ä¸Šã§ãªã„ï¼‰
linear_points = []
for ti in t:
    point = (1-ti) * p1 + ti * p2
    # çƒé¢ã«æŠ•å½±
    point = R * point / np.linalg.norm(point)
    linear_points.append(point)
linear_points = np.array(linear_points)

# å¯è¦–åŒ–
fig = plt.figure(figsize=(15, 5))

# 3Dçƒé¢ã¨æ¸¬åœ°ç·š
ax1 = fig.add_subplot(131, projection='3d')

# çƒé¢ã®æç”»
u = np.linspace(0, 2 * np.pi, 50)
v = np.linspace(0, np.pi, 50)
x_sphere = R * np.outer(np.cos(u), np.sin(v))
y_sphere = R * np.outer(np.sin(u), np.sin(v))
z_sphere = R * np.outer(np.ones(np.size(u)), np.cos(v))
ax1.plot_surface(x_sphere, y_sphere, z_sphere, alpha=0.2, color='cyan')

# æ¸¬åœ°ç·š
ax1.plot(geodesic_points[:, 0], geodesic_points[:, 1], geodesic_points[:, 2], 
         'r-', linewidth=3, label='æ¸¬åœ°ç·šï¼ˆå¤§å††ï¼‰')

# æ¯”è¼ƒ: ç·šå½¢è£œé–“
ax1.plot(linear_points[:, 0], linear_points[:, 1], linear_points[:, 2], 
         'b--', linewidth=2, label='ç·šå½¢è£œé–“')

# ç«¯ç‚¹
ax1.scatter([x1, x2], [y1, y2], [z1, z2], color='black', s=100, label='ç«¯ç‚¹')

ax1.set_xlabel('x')
ax1.set_ylabel('y')
ax1.set_zlabel('z')
ax1.set_title('çƒé¢ä¸Šã®æ¸¬åœ°ç·š')
ax1.legend()

# ä¸Šã‹ã‚‰è¦‹ãŸå›³
ax2 = fig.add_subplot(132)
theta_grid = np.linspace(0, np.pi, 100)
phi_grid = np.linspace(0, 2*np.pi, 100)
THETA, PHI = np.meshgrid(theta_grid, phi_grid)
X_grid = R * np.sin(THETA) * np.cos(PHI)
Y_grid = R * np.sin(THETA) * np.sin(PHI)
ax2.contour(X_grid, Y_grid, THETA, levels=10, colors='gray', alpha=0.3)
ax2.plot(geodesic_points[:, 0], geodesic_points[:, 1], 'r-', linewidth=3, label='æ¸¬åœ°ç·š')
ax2.plot(linear_points[:, 0], linear_points[:, 1], 'b--', linewidth=2, label='ç·šå½¢è£œé–“')
ax2.scatter([x1, x2], [y1, y2], color='black', s=100, zorder=5)
ax2.set_xlabel('x')
ax2.set_ylabel('y')
ax2.set_title('ä¸Šã‹ã‚‰è¦‹ãŸå›³ï¼ˆxyå¹³é¢ã¸ã®æŠ•å½±ï¼‰')
ax2.axis('equal')
ax2.legend()
ax2.grid(True, alpha=0.3)

# å¼§é•·ã®æ¯”è¼ƒ
def arc_length(points):
    diffs = np.diff(points, axis=0)
    distances = np.linalg.norm(diffs, axis=1)
    return np.sum(distances)

length_geodesic = arc_length(geodesic_points)
length_linear = arc_length(linear_points)
length_theoretical = R * angle

ax3 = fig.add_subplot(133)
lengths = {
    'æ¸¬åœ°ç·š': length_geodesic,
    'ç·šå½¢è£œé–“': length_linear,
    'ç†è«–å€¤': length_theoretical
}
colors = ['red', 'blue', 'green']
bars = ax3.bar(lengths.keys(), lengths.values(), color=colors, alpha=0.7)
ax3.set_ylabel('Arc length')
ax3.set_title('å¼§é•·ã®æ¯”è¼ƒ')
ax3.grid(True, axis='y', alpha=0.3)

for bar, (name, length) in zip(bars, lengths.items()):
    ax3.text(bar.get_x() + bar.get_width()/2, bar.get_height() + 0.01, 
             f'{length:.4f}', ha='center', fontweight='bold')

plt.tight_layout()
plt.savefig('variation_geodesic.png', dpi=300, bbox_inches='tight')
plt.show()

print("=== çƒé¢ä¸Šã®æ¸¬åœ°ç·š ===")
print(f"æ¸¬åœ°ç·šã®å¼§é•·: {length_geodesic:.6f}")
print(f"ç·šå½¢è£œé–“ã®å¼§é•·: {length_linear:.6f}")
print(f"ç†è«–å€¤: {length_theoretical:.6f}")
print(f"2ç‚¹é–“ã®è§’åº¦: {np.degrees(angle):.2f}Â°")
</div>
        </div>

        <div class="content">
            <h2>ğŸ’» ä¾‹é¡Œ4.4: æœ€å°ä½œç”¨ã®åŸç†ï¼ˆãƒ©ã‚°ãƒ©ãƒ³ã‚¸ãƒ¥åŠ›å­¦ï¼‰</h2>
            
            <div class="theory-box">
                <h3>æœ€å°ä½œç”¨ã®åŸç†</h3>
                <p>ç‰©ç†ç³»ã®é‹å‹•ã¯ã€ä½œç”¨ç©åˆ†ã‚’æ¥µå€¤åŒ–ã™ã‚‹çµŒè·¯ã«æ²¿ã£ã¦èµ·ã“ã‚Šã¾ã™ï¼š</p>
                <p>\[
                S = \int_{t_1}^{t_2} L(q, \dot{q}, t) dt
                \]</p>
                <p>ã“ã“ã§ \(L = T - V\) ã¯ãƒ©ã‚°ãƒ©ãƒ³ã‚¸ã‚¢ãƒ³ï¼ˆé‹å‹•ã‚¨ãƒãƒ«ã‚®ãƒ¼ - ãƒãƒ†ãƒ³ã‚·ãƒ£ãƒ«ã‚¨ãƒãƒ«ã‚®ãƒ¼ï¼‰ã€‚</p>
                <p>ã‚ªã‚¤ãƒ©ãƒ¼-ãƒ©ã‚°ãƒ©ãƒ³ã‚¸ãƒ¥æ–¹ç¨‹å¼ã¯é‹å‹•æ–¹ç¨‹å¼ã«å¸°ç€ã—ã¾ã™ï¼š</p>
                <p>\[
                \frac{d}{dt}\left(\frac{\partial L}{\partial \dot{q}}\right) - \frac{\partial L}{\partial q} = 0
                \]</p>
            </div>

            <div class="code-title">Pythonå®Ÿè£…: å˜æŒ¯ã‚Šå­ã®ãƒ©ã‚°ãƒ©ãƒ³ã‚¸ãƒ¥åŠ›å­¦</div>
            <div class="code-example">import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import odeint
from scipy.optimize import minimize

# å˜æŒ¯ã‚Šå­ã®ãƒ©ã‚°ãƒ©ãƒ³ã‚¸ãƒ¥åŠ›å­¦
m = 1.0  # è³ªé‡ (kg)
L = 1.0  # æŒ¯ã‚Šå­ã®é•·ã• (m)
g = 9.8  # é‡åŠ›åŠ é€Ÿåº¦ (m/sÂ²)

def lagrangian(theta, theta_dot):
    """ãƒ©ã‚°ãƒ©ãƒ³ã‚¸ã‚¢ãƒ³ L = T - V"""
    T = 0.5 * m * (L * theta_dot)**2  # é‹å‹•ã‚¨ãƒãƒ«ã‚®ãƒ¼
    V = -m * g * L * np.cos(theta)     # ãƒãƒ†ãƒ³ã‚·ãƒ£ãƒ«ã‚¨ãƒãƒ«ã‚®ãƒ¼ï¼ˆä¸‹å‘ãã‚’æ­£ï¼‰
    return T - V

def equations_of_motion(state, t):
    """ã‚ªã‚¤ãƒ©ãƒ¼-ãƒ©ã‚°ãƒ©ãƒ³ã‚¸ãƒ¥æ–¹ç¨‹å¼ã‹ã‚‰å°å‡ºã•ã‚ŒãŸé‹å‹•æ–¹ç¨‹å¼"""
    theta, theta_dot = state
    theta_ddot = -(g / L) * np.sin(theta)
    return [theta_dot, theta_ddot]

# åˆæœŸæ¡ä»¶
theta0 = np.pi / 4  # åˆæœŸè§’åº¦ (45åº¦)
theta_dot0 = 0.0     # åˆæœŸè§’é€Ÿåº¦

# æ™‚é–“ç©åˆ†
t = np.linspace(0, 5, 500)
state0 = [theta0, theta_dot0]
solution = odeint(equations_of_motion, state0, t)
theta_t = solution[:, 0]
theta_dot_t = solution[:, 1]

# ä½œç”¨ç©åˆ†ã®è¨ˆç®—
def action_integral(theta_values, t_values):
    """ä½œç”¨ç©åˆ† S = âˆ«L dt"""
    action = 0.0
    for i in range(len(t_values) - 1):
        dt = t_values[i+1] - t_values[i]
        theta_dot = (theta_values[i+1] - theta_values[i]) / dt
        theta_avg = (theta_values[i] + theta_values[i+1]) / 2
        L_val = lagrangian(theta_avg, theta_dot)
        action += L_val * dt
    return action

# çœŸã®è»Œé“ã®ä½œç”¨
action_true = action_integral(theta_t, t)

# æ¯”è¼ƒ: å˜ç´”ãªè»Œé“ï¼ˆèª¿å’ŒæŒ¯å‹•è¿‘ä¼¼ï¼‰
omega = np.sqrt(g / L)
theta_harmonic = theta0 * np.cos(omega * t)
action_harmonic = action_integral(theta_harmonic, t)

# æ¯”è¼ƒ: ç›´ç·šçš„ãªè»Œé“ï¼ˆéç‰©ç†çš„ï¼‰
theta_linear = theta0 * (1 - t / t[-1])
action_linear = action_integral(theta_linear, t)

# å¯è¦–åŒ–
fig, axes = plt.subplots(2, 2, figsize=(14, 10))

# è§’åº¦ã®æ™‚é–“å¤‰åŒ–
ax1 = axes[0, 0]
ax1.plot(t, theta_t, 'b-', label=f'çœŸã®è»Œé“ (S={action_true:.3f})', linewidth=2)
ax1.plot(t, theta_harmonic, 'r--', label=f'èª¿å’ŒæŒ¯å‹•è¿‘ä¼¼ (S={action_harmonic:.3f})', linewidth=2)
ax1.plot(t, theta_linear, 'g:', label=f'ç›´ç·šè»Œé“ (S={action_linear:.3f})', linewidth=2)
ax1.set_xlabel('Time (s)')
ax1.set_ylabel('Î¸ (rad)')
ax1.set_title('è§’åº¦ã®æ™‚é–“å¤‰åŒ–')
ax1.legend()
ax1.grid(True, alpha=0.3)

# ä½ç›¸ç©ºé–“ï¼ˆÎ¸-Î¸Ì‡å¹³é¢ï¼‰
ax2 = axes[0, 1]
ax2.plot(theta_t, theta_dot_t, 'b-', linewidth=2, label='çœŸã®è»Œé“')
ax2.set_xlabel('Î¸ (rad)')
ax2.set_ylabel('dÎ¸/dt (rad/s)')
ax2.set_title('ä½ç›¸ç©ºé–“')
ax2.legend()
ax2.grid(True, alpha=0.3)

# ã‚¨ãƒãƒ«ã‚®ãƒ¼ä¿å­˜
E_t = 0.5 * m * (L * theta_dot_t)**2 + m * g * L * (1 - np.cos(theta_t))
ax3 = axes[1, 0]
ax3.plot(t, E_t, 'b-', linewidth=2)
ax3.axhline(E_t[0], color='r', linestyle='--', label=f'åˆæœŸã‚¨ãƒãƒ«ã‚®ãƒ¼: {E_t[0]:.3f} J')
ax3.set_xlabel('Time (s)')
ax3.set_ylabel('Energy (J)')
ax3.set_title('ã‚¨ãƒãƒ«ã‚®ãƒ¼ä¿å­˜å‰‡')
ax3.legend()
ax3.grid(True, alpha=0.3)

# ä½œç”¨ç©åˆ†ã®æ¯”è¼ƒ
ax4 = axes[1, 1]
actions = {
    'çœŸã®è»Œé“': action_true,
    'èª¿å’ŒæŒ¯å‹•è¿‘ä¼¼': action_harmonic,
    'ç›´ç·šè»Œé“': action_linear
}
colors = ['blue', 'red', 'green']
bars = ax4.bar(actions.keys(), actions.values(), color=colors, alpha=0.7)
ax4.set_ylabel('Action S (JÂ·s)')
ax4.set_title('ä½œç”¨ç©åˆ†ã®æ¯”è¼ƒï¼ˆçœŸã®è»Œé“ã§æœ€å°ï¼‰')
ax4.grid(True, axis='y', alpha=0.3)

for bar, (name, action) in zip(bars, actions.items()):
    ax4.text(bar.get_x() + bar.get_width()/2, bar.get_height() + 0.5, 
             f'{action:.3f}', ha='center', fontweight='bold')

plt.tight_layout()
plt.savefig('variation_least_action.png', dpi=300, bbox_inches='tight')
plt.show()

print("=== æœ€å°ä½œç”¨ã®åŸç† ===")
for name, action in actions.items():
    print(f"{name}: S = {action:.6f} JÂ·s")
print(f"ã‚¨ãƒãƒ«ã‚®ãƒ¼ä¿å­˜èª¤å·®: {np.std(E_t) / np.mean(E_t) * 100:.2e}%")
</div>
        </div>

        <div class="content">
            <h2>ğŸ’» ä¾‹é¡Œ4.5: ç­‰å‘¨å•é¡Œï¼ˆé¢ç©æœ€å¤§åŒ–ï¼‰</h2>
            
            <div class="theory-box">
                <h3>ç­‰å‘¨å•é¡Œ</h3>
                <p>ä¸ãˆã‚‰ã‚ŒãŸå‘¨é•· \(L\) ã‚’æŒã¤é–‰æ›²ç·šã®ã†ã¡ã€é¢ç©ã‚’æœ€å¤§åŒ–ã™ã‚‹ã‚‚ã®ã‚’æ±‚ã‚ã¾ã™ã€‚</p>
                <p>ç­”ãˆã¯å††ã§ã™ã€‚ãƒ©ã‚°ãƒ©ãƒ³ã‚¸ãƒ¥ã®æœªå®šä¹—æ•°æ³•ã‚’ç”¨ã„ã¦è§£ãã¾ã™ï¼š</p>
                <p>\[
                \delta\left(A - \lambda P\right) = 0
                \]</p>
                <p>ã“ã“ã§ \(A\) ã¯é¢ç©ã€\(P\) ã¯å‘¨é•·ã€\(\lambda\) ã¯æœªå®šä¹—æ•°ã€‚</p>
            </div>

            <div class="code-title">Pythonå®Ÿè£…: ç­‰å‘¨å•é¡Œã®æ•°å€¤è§£</div>
            <div class="code-example">import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import minimize

def polar_curve_to_cartesian(r_values, theta_values):
    """æ¥µåº§æ¨™ã‹ã‚‰ç›´äº¤åº§æ¨™ã¸å¤‰æ›"""
    x = r_values * np.cos(theta_values)
    y = r_values * np.sin(theta_values)
    return x, y

def compute_perimeter(r_values, theta_values):
    """å‘¨é•·ã‚’è¨ˆç®—"""
    x, y = polar_curve_to_cartesian(r_values, theta_values)
    dx = np.diff(np.concatenate([x, [x[0]]]))
    dy = np.diff(np.concatenate([y, [y[0]]]))
    ds = np.sqrt(dx**2 + dy**2)
    return np.sum(ds)

def compute_area(r_values, theta_values):
    """é¢ç©ã‚’è¨ˆç®—ï¼ˆæ¥µåº§æ¨™ã®å…¬å¼ï¼‰"""
    dtheta = theta_values[1] - theta_values[0]
    area = 0.5 * np.sum(r_values**2) * dtheta
    return area

def objective_function(r_values, theta_values, target_perimeter, weight=1000):
    """ç›®çš„é–¢æ•°: é¢ç©ã‚’æœ€å¤§åŒ–ï¼ˆ= -é¢ç©ã‚’æœ€å°åŒ–ï¼‰+ å‘¨é•·åˆ¶ç´„"""
    area = compute_area(r_values, theta_values)
    perimeter = compute_perimeter(r_values, theta_values)
    
    # ãƒšãƒŠãƒ«ãƒ†ã‚£æ³•: å‘¨é•·åˆ¶ç´„ã‚’ç›®çš„é–¢æ•°ã«çµ„ã¿è¾¼ã‚€
    penalty = weight * (perimeter - target_perimeter)**2
    
    return -area + penalty

# é›¢æ•£åŒ–
N = 100
theta_values = np.linspace(0, 2*np.pi, N, endpoint=False)

# ç›®æ¨™å‘¨é•·
target_perimeter = 2 * np.pi

# åˆæœŸæ¨æ¸¬ï¼ˆæ­£æ–¹å½¢ã«è¿‘ã„å½¢ï¼‰
r_initial = np.ones(N) + 0.2 * np.sin(4 * theta_values)

# æœ€é©åŒ–
result = minimize(objective_function, r_initial, 
                  args=(theta_values, target_perimeter, 1000),
                  method='L-BFGS-B', bounds=[(0.1, 2.0)]*N,
                  options={'maxiter': 1000})

r_optimal = result.x

# ç†è«–è§£ï¼ˆå††ï¼‰
r_circle = target_perimeter / (2 * np.pi)
r_theoretical = np.full(N, r_circle)

# è¨ˆç®—
perimeter_initial = compute_perimeter(r_initial, theta_values)
area_initial = compute_area(r_initial, theta_values)

perimeter_optimal = compute_perimeter(r_optimal, theta_values)
area_optimal = compute_area(r_optimal, theta_values)

perimeter_circle = compute_perimeter(r_theoretical, theta_values)
area_circle = compute_area(r_theoretical, theta_values)

# å¯è¦–åŒ–
fig, axes = plt.subplots(1, 2, figsize=(14, 6))

# æ›²ç·šã®æ¯”è¼ƒ
ax1 = axes[0]
x_initial, y_initial = polar_curve_to_cartesian(r_initial, theta_values)
x_optimal, y_optimal = polar_curve_to_cartesian(r_optimal, theta_values)
x_circle, y_circle = polar_curve_to_cartesian(r_theoretical, theta_values)

ax1.plot(np.concatenate([x_initial, [x_initial[0]]]), 
         np.concatenate([y_initial, [y_initial[0]]]), 
         'b--', label=f'åˆæœŸ (A={area_initial:.3f}, P={perimeter_initial:.3f})', 
         linewidth=2, alpha=0.7)
ax1.plot(np.concatenate([x_optimal, [x_optimal[0]]]), 
         np.concatenate([y_optimal, [y_optimal[0]]]), 
         'r-', label=f'æœ€é©åŒ– (A={area_optimal:.3f}, P={perimeter_optimal:.3f})', 
         linewidth=2)
ax1.plot(np.concatenate([x_circle, [x_circle[0]]]), 
         np.concatenate([y_circle, [y_circle[0]]]), 
         'g:', label=f'å††ï¼ˆç†è«–è§£ï¼‰(A={area_circle:.3f}, P={perimeter_circle:.3f})', 
         linewidth=3)
ax1.set_xlabel('x')
ax1.set_ylabel('y')
ax1.set_title('ç­‰å‘¨å•é¡Œ: å‘¨é•·ä¸€å®šã§é¢ç©æœ€å¤§åŒ–')
ax1.legend()
ax1.grid(True, alpha=0.3)
ax1.axis('equal')

# é¢ç©ã¨å‘¨é•·ã®æ¯”è¼ƒ
ax2 = axes[1]
metrics = ['åˆæœŸ', 'æœ€é©åŒ–', 'å††ï¼ˆç†è«–ï¼‰']
areas = [area_initial, area_optimal, area_circle]
perimeters = [perimeter_initial, perimeter_optimal, perimeter_circle]

x_pos = np.arange(len(metrics))
width = 0.35

bars1 = ax2.bar(x_pos - width/2, areas, width, label='é¢ç©', color='blue', alpha=0.7)
bars2 = ax2.bar(x_pos + width/2, perimeters, width, label='å‘¨é•·', color='red', alpha=0.7)

ax2.set_ylabel('Value')
ax2.set_title('é¢ç©ã¨å‘¨é•·ã®æ¯”è¼ƒ')
ax2.set_xticks(x_pos)
ax2.set_xticklabels(metrics)
ax2.legend()
ax2.grid(True, axis='y', alpha=0.3)

# æ•°å€¤ãƒ©ãƒ™ãƒ«
for bar, value in zip(bars1, areas):
    ax2.text(bar.get_x() + bar.get_width()/2, bar.get_height() + 0.05, 
             f'{value:.2f}', ha='center', fontsize=9)
for bar, value in zip(bars2, perimeters):
    ax2.text(bar.get_x() + bar.get_width()/2, bar.get_height() + 0.05, 
             f'{value:.2f}', ha='center', fontsize=9)

plt.tight_layout()
plt.savefig('variation_isoperimetric.png', dpi=300, bbox_inches='tight')
plt.show()

print("=== ç­‰å‘¨å•é¡Œ ===")
print(f"åˆæœŸå½¢çŠ¶: é¢ç© = {area_initial:.6f}, å‘¨é•· = {perimeter_initial:.6f}")
print(f"æœ€é©åŒ–å½¢çŠ¶: é¢ç© = {area_optimal:.6f}, å‘¨é•· = {perimeter_optimal:.6f}")
print(f"å††ï¼ˆç†è«–ï¼‰: é¢ç© = {area_circle:.6f}, å‘¨é•· = {perimeter_circle:.6f}")
print(f"æœ€é©åŒ–ã«ã‚ˆã‚‹é¢ç©å¢—åŠ : {(area_optimal - area_initial) / area_initial * 100:.2f}%")
</div>
        </div>

        <div class="content">
            <h2>ğŸ’» ä¾‹é¡Œ4.6: ã‚¬ãƒ©ãƒ¼ã‚­ãƒ³æ³•ã®åŸºç¤</h2>
            
            <div class="theory-box">
                <h3>ã‚¬ãƒ©ãƒ¼ã‚­ãƒ³æ³•ï¼ˆGalerkin Methodï¼‰</h3>
                <p>å¼±å½¢å¼ã‚’ç”¨ã„ã¦åå¾®åˆ†æ–¹ç¨‹å¼ã‚’è¿‘ä¼¼çš„ã«è§£ãæ‰‹æ³•ã§ã™ã€‚</p>
                <p>å¼·å½¢å¼: \(\mathcal{L}u = f\) ã‚’æº€ãŸã™ \(u\) ã‚’æ±‚ã‚ã‚‹</p>
                <p>å¼±å½¢å¼: \(\int v \mathcal{L}u \, dx = \int v f \, dx\) for all test functions \(v\)</p>
                <p>è©¦è¡Œé–¢æ•°: \(u \approx \sum_{i=1}^N c_i \phi_i(x)\)</p>
                <p>ã‚¬ãƒ©ãƒ¼ã‚­ãƒ³æ³•ã§ã¯ã€ãƒ†ã‚¹ãƒˆé–¢æ•°ã«è©¦è¡Œé–¢æ•°ã¨åŒã˜åŸºåº• \(\phi_i\) ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚</p>
            </div>

            <div class="code-title">Pythonå®Ÿè£…: 1æ¬¡å…ƒãƒã‚¢ã‚½ãƒ³æ–¹ç¨‹å¼ã®ã‚¬ãƒ©ãƒ¼ã‚­ãƒ³æ³•</div>
            <div class="code-example">import numpy as np
import matplotlib.pyplot as plt
from scipy.sparse import diags
from scipy.sparse.linalg import spsolve

# 1æ¬¡å…ƒãƒã‚¢ã‚½ãƒ³æ–¹ç¨‹å¼: -u''(x) = f(x), x âˆˆ [0,1]
# å¢ƒç•Œæ¡ä»¶: u(0) = 0, u(1) = 0
# å³è¾º: f(x) = Ï€Â² sin(Ï€x)
# è§£æè§£: u(x) = sin(Ï€x)

def source_function(x):
    """å³è¾ºé–¢æ•°"""
    return np.pi**2 * np.sin(np.pi * x)

def analytical_solution(x):
    """è§£æè§£"""
    return np.sin(np.pi * x)

# ã‚¬ãƒ©ãƒ¼ã‚­ãƒ³æ³•ï¼ˆæœ‰é™è¦ç´ æ³•ï¼‰
N = 20  # è¦ç´ æ•°
x_nodes = np.linspace(0, 1, N+1)
h = x_nodes[1] - x_nodes[0]

# å‰›æ€§è¡Œåˆ—ï¼ˆstiffness matrixï¼‰ã¨è·é‡ãƒ™ã‚¯ãƒˆãƒ«ï¼ˆload vectorï¼‰
K = np.zeros((N+1, N+1))
F = np.zeros(N+1)

# ç·šå½¢è¦ç´ ã®çµ„ã¿ç«‹ã¦
for i in range(N):
    # è¦ç´  i: [x_i, x_{i+1}]
    x_left = x_nodes[i]
    x_right = x_nodes[i+1]
    x_mid = (x_left + x_right) / 2
    
    # è¦ç´ å‰›æ€§è¡Œåˆ—ï¼ˆç·šå½¢è¦ç´ ï¼‰
    K_elem = np.array([[1/h, -1/h],
                       [-1/h, 1/h]])
    
    # å…¨ä½“å‰›æ€§è¡Œåˆ—ã«çµ„ã¿è¾¼ã¿
    K[i:i+2, i:i+2] += K_elem
    
    # è¦ç´ è·é‡ãƒ™ã‚¯ãƒˆãƒ«ï¼ˆä¸­ç‚¹å‰‡ï¼‰
    f_mid = source_function(x_mid)
    F_elem = f_mid * h * np.array([0.5, 0.5])
    F[i:i+2] += F_elem

# å¢ƒç•Œæ¡ä»¶ã®é©ç”¨ï¼ˆu(0)=0, u(1)=0ï¼‰
K_interior = K[1:-1, 1:-1]
F_interior = F[1:-1]

# ç·šå½¢ã‚·ã‚¹ãƒ†ãƒ ã‚’è§£ã
u_interior = spsolve(K_interior, F_interior)

# å®Œå…¨ãªè§£ãƒ™ã‚¯ãƒˆãƒ«
u_galerkin = np.concatenate([[0], u_interior, [0]])

# è§£æè§£
u_analytical = analytical_solution(x_nodes)

# å¯è¦–åŒ–
fig, axes = plt.subplots(1, 2, figsize=(14, 5))

# è§£ã®æ¯”è¼ƒ
ax1 = axes[0]
ax1.plot(x_nodes, u_analytical, 'b-', label='è§£æè§£', linewidth=3, alpha=0.7)
ax1.plot(x_nodes, u_galerkin, 'ro-', label=f'ã‚¬ãƒ©ãƒ¼ã‚­ãƒ³æ³• (N={N})', 
         linewidth=2, markersize=5)
ax1.set_xlabel('x')
ax1.set_ylabel('u(x)')
ax1.set_title('ãƒã‚¢ã‚½ãƒ³æ–¹ç¨‹å¼ã®è§£')
ax1.legend()
ax1.grid(True, alpha=0.3)

# èª¤å·®ã®åˆ†å¸ƒ
ax2 = axes[1]
error = np.abs(u_galerkin - u_analytical)
ax2.semilogy(x_nodes, error, 'r-', linewidth=2, marker='o', markersize=5)
ax2.set_xlabel('x')
ax2.set_ylabel('Absolute error')
ax2.set_title('èª¤å·®åˆ†å¸ƒ')
ax2.grid(True, alpha=0.3)

plt.tight_layout()
plt.savefig('variation_galerkin_method.png', dpi=300, bbox_inches='tight')
plt.show()

print("=== ã‚¬ãƒ©ãƒ¼ã‚­ãƒ³æ³•ï¼ˆæœ‰é™è¦ç´ æ³•ï¼‰===")
print(f"è¦ç´ æ•°: {N}")
print(f"æœ€å¤§èª¤å·®: {np.max(error):.2e}")
print(f"L2ãƒãƒ«ãƒ èª¤å·®: {np.linalg.norm(error) / np.sqrt(N+1):.2e}")
</div>
        </div>

        <div class="content">
            <h2>ğŸ’» ä¾‹é¡Œ4.7: æœ‰é™è¦ç´ æ³•ï¼ˆ1æ¬¡å…ƒå¼¾æ€§æ£’ï¼‰</h2>
            
            <div class="code-title">Pythonå®Ÿè£…: å¼•å¼µè·é‡ã‚’å—ã‘ã‚‹å¼¾æ€§æ£’</div>
            <div class="code-example">import numpy as np
import matplotlib.pyplot as plt

# 1æ¬¡å…ƒå¼¾æ€§æ£’ã®å¤‰å½¢å•é¡Œ
# æ”¯é…æ–¹ç¨‹å¼: -EA u''(x) = f(x), x âˆˆ [0,L]
# å¢ƒç•Œæ¡ä»¶: u(0) = 0ï¼ˆå›ºå®šç«¯ï¼‰, EA u'(L) = Pï¼ˆè·é‡ç«¯ï¼‰
# E: ãƒ¤ãƒ³ã‚°ç‡, A: æ–­é¢ç©, f: åˆ†å¸ƒè·é‡, P: ç«¯éƒ¨è·é‡

E = 200e9  # ãƒ¤ãƒ³ã‚°ç‡ (Pa) - é‹¼
A = 0.01**2  # æ–­é¢ç© (mÂ²) - 1cm Ã— 1cm
L = 1.0  # æ£’ã®é•·ã• (m)
P = 10000  # ç«¯éƒ¨è·é‡ (N)
f = 0.0  # åˆ†å¸ƒè·é‡ãªã—

def fem_elastic_bar(N, E, A, L, P, f=0.0):
    """æœ‰é™è¦ç´ æ³•ã«ã‚ˆã‚‹å¼¾æ€§æ£’ã®è§£æ"""
    x_nodes = np.linspace(0, L, N+1)
    h = x_nodes[1] - x_nodes[0]
    
    # å‰›æ€§è¡Œåˆ—ã¨è·é‡ãƒ™ã‚¯ãƒˆãƒ«
    K = np.zeros((N+1, N+1))
    F = np.zeros(N+1)
    
    # è¦ç´ ã®çµ„ã¿ç«‹ã¦
    for i in range(N):
        K_elem = (E * A / h) * np.array([[1, -1],
                                          [-1, 1]])
        K[i:i+2, i:i+2] += K_elem
        
        # åˆ†å¸ƒè·é‡
        F[i:i+2] += f * h * np.array([0.5, 0.5])
    
    # ç«¯éƒ¨è·é‡ï¼ˆå³ç«¯ï¼‰
    F[-1] += P
    
    # å¢ƒç•Œæ¡ä»¶: u(0) = 0
    K_reduced = K[1:, 1:]
    F_reduced = F[1:]
    
    # è§£ã‚’æ±‚ã‚ã‚‹
    u_interior = np.linalg.solve(K_reduced, F_reduced)
    u = np.concatenate([[0], u_interior])
    
    return x_nodes, u

# è§£æè§£
def analytical_solution_elastic_bar(x, E, A, L, P):
    """è§£æè§£: u(x) = P*x / (E*A)"""
    return P * x / (E * A)

# ç•°ãªã‚‹è¦ç´ æ•°ã§è§£ã
N_values = [5, 10, 20]
fig, axes = plt.subplots(1, 3, figsize=(16, 5))

colors = ['blue', 'red', 'green']

# è§£ã®æ¯”è¼ƒ
ax1 = axes[0]
x_fine = np.linspace(0, L, 200)
u_analytical_fine = analytical_solution_elastic_bar(x_fine, E, A, L, P)
ax1.plot(x_fine, u_analytical_fine * 1000, 'k-', label='è§£æè§£', linewidth=3, alpha=0.5)

for N, color in zip(N_values, colors):
    x_nodes, u_fem = fem_elastic_bar(N, E, A, L, P, f)
    ax1.plot(x_nodes, u_fem * 1000, 'o-', color=color, label=f'FEM (N={N})', 
             linewidth=2, markersize=6)

ax1.set_xlabel('x (m)')
ax1.set_ylabel('Displacement u(x) (mm)')
ax1.set_title('å¼¾æ€§æ£’ã®å¤‰ä½åˆ†å¸ƒ')
ax1.legend()
ax1.grid(True, alpha=0.3)

# èª¤å·®è§£æ
ax2 = axes[1]
errors = []
for N in range(5, 51, 5):
    x_nodes, u_fem = fem_elastic_bar(N, E, A, L, P, f)
    u_analytical = analytical_solution_elastic_bar(x_nodes, E, A, L, P)
    error = np.linalg.norm(u_fem - u_analytical) / np.linalg.norm(u_analytical)
    errors.append(error)

N_range = range(5, 51, 5)
ax2.loglog(N_range, errors, 'bo-', linewidth=2, markersize=8)
ax2.set_xlabel('Number of elements N')
ax2.set_ylabel('Relative L2 error')
ax2.set_title('åæŸæ€§è§£æ')
ax2.grid(True, alpha=0.3, which='both')

# å¿œåŠ›åˆ†å¸ƒï¼ˆÏƒ = E * du/dxï¼‰
ax3 = axes[2]
N = 20
x_nodes, u_fem = fem_elastic_bar(N, E, A, L, P, f)

# æ•°å€¤å¾®åˆ†ã§å¿œåŠ›ã‚’è¨ˆç®—
strain = np.diff(u_fem) / (L / N)  # ã²ãšã¿ Îµ = du/dx
stress = E * strain  # å¿œåŠ› Ïƒ = E * Îµ
x_stress = (x_nodes[:-1] + x_nodes[1:]) / 2

# è§£æè§£ã®å¿œåŠ›ï¼ˆä¸€å®šï¼‰
stress_analytical = P / A

ax3.plot(x_stress, stress / 1e6, 'ro-', label='FEM', linewidth=2, markersize=6)
ax3.axhline(stress_analytical / 1e6, color='k', linestyle='--', linewidth=3, 
            label=f'è§£æè§£: {stress_analytical/1e6:.2f} MPa')
ax3.set_xlabel('x (m)')
ax3.set_ylabel('Stress Ïƒ (MPa)')
ax3.set_title('å¿œåŠ›åˆ†å¸ƒ')
ax3.legend()
ax3.grid(True, alpha=0.3)

plt.tight_layout()
plt.savefig('variation_fem_elastic_bar.png', dpi=300, bbox_inches='tight')
plt.show()

print("=== å¼¾æ€§æ£’ã®æœ‰é™è¦ç´ è§£æ ===")
print(f"ãƒ¤ãƒ³ã‚°ç‡: {E/1e9:.1f} GPa")
print(f"æ–­é¢ç©: {A*1e4:.2f} cmÂ²")
print(f"è·é‡: {P/1000:.1f} kN")
print(f"æœ€å¤§å¤‰ä½ï¼ˆè§£æè§£ï¼‰: {P*L/(E*A)*1000:.4f} mm")
print(f"å¿œåŠ›ï¼ˆè§£æè§£ï¼‰: {P/A/1e6:.2f} MPa")
</div>
        </div>

        <div class="content">
            <h2>ğŸ’» ä¾‹é¡Œ4.8: ææ–™ç§‘å­¦å¿œç”¨ - å½¢çŠ¶æœ€é©åŒ–å•é¡Œ</h2>
            
            <div class="code-title">Pythonå®Ÿè£…: æœ€å°é‡é‡è¨­è¨ˆ</div>
            <div class="code-example">import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import minimize

# ç‰‡æŒã¡æ¢ã®æ–­é¢ç©æœ€é©åŒ–
# ç›®çš„: å¿œåŠ›åˆ¶ç´„ã®ã‚‚ã¨ã§é‡é‡ã‚’æœ€å°åŒ–

L = 1.0  # æ¢ã®é•·ã• (m)
P = 10000  # ç«¯éƒ¨è·é‡ (N)
E = 200e9  # ãƒ¤ãƒ³ã‚°ç‡ (Pa)
sigma_max = 200e6  # è¨±å®¹å¿œåŠ› (Pa)
rho = 7850  # å¯†åº¦ (kg/mÂ³) - é‹¼

def fem_cantilever_beam(A_values, x_nodes, E, P):
    """ç‰‡æŒã¡æ¢ã®æœ‰é™è¦ç´ è§£æï¼ˆæ–­é¢ç©ãŒå¤‰åŒ–ï¼‰"""
    N = len(x_nodes) - 1
    h = x_nodes[1] - x_nodes[0]
    
    K = np.zeros((N+1, N+1))
    F = np.zeros(N+1)
    
    # è¦ç´ ã®çµ„ã¿ç«‹ã¦ï¼ˆæ–­é¢ç©ãŒè¦ç´ ã”ã¨ã«ç•°ãªã‚‹ï¼‰
    for i in range(N):
        A_elem = (A_values[i] + A_values[i+1]) / 2  # è¦ç´ ã®å¹³å‡æ–­é¢ç©
        K_elem = (E * A_elem / h) * np.array([[1, -1],
                                               [-1, 1]])
        K[i:i+2, i:i+2] += K_elem
    
    # ç«¯éƒ¨è·é‡
    F[-1] = P
    
    # å¢ƒç•Œæ¡ä»¶: u(0) = 0
    K_reduced = K[1:, 1:]
    F_reduced = F[1:]
    
    u_interior = np.linalg.solve(K_reduced, F_reduced)
    u = np.concatenate([[0], u_interior])
    
    # å¿œåŠ›è¨ˆç®—
    stress = np.zeros(N)
    for i in range(N):
        strain = (u[i+1] - u[i]) / h
        stress[i] = E * strain
    
    return u, stress

def objective_weight(A_values, x_nodes, rho):
    """ç›®çš„é–¢æ•°: ç·é‡é‡"""
    h = x_nodes[1] - x_nodes[0]
    weight = np.sum(A_values) * h * rho
    return weight

def constraint_stress(A_values, x_nodes, E, P, sigma_max):
    """åˆ¶ç´„é–¢æ•°: å¿œåŠ›ãŒè¨±å®¹å€¤ä»¥ä¸‹"""
    _, stress = fem_cantilever_beam(A_values, x_nodes, E, P)
    max_stress = np.max(np.abs(stress))
    return sigma_max - max_stress  # æ­£ãªã‚‰åˆ¶ç´„æº€è¶³

# é›¢æ•£åŒ–
N = 20
x_nodes = np.linspace(0, L, N+1)

# åˆæœŸè¨­è¨ˆï¼ˆä¸€å®šæ–­é¢ç©ï¼‰
A_initial = np.full(N+1, P * L / (E * sigma_max) * 2)  # å®‰å…¨ç‡2

# æœ€é©åŒ–
constraints = {'type': 'ineq', 'fun': constraint_stress, 
               'args': (x_nodes, E, P, sigma_max)}
bounds = [(1e-5, 1e-2)] * (N+1)  # æ–­é¢ç©ã®ç¯„å›²

result = minimize(objective_weight, A_initial, args=(x_nodes, rho),
                  method='SLSQP', bounds=bounds, constraints=constraints,
                  options={'maxiter': 1000})

A_optimal = result.x

# è§£æ
u_initial, stress_initial = fem_cantilever_beam(A_initial, x_nodes, E, P)
u_optimal, stress_optimal = fem_cantilever_beam(A_optimal, x_nodes, E, P)

weight_initial = objective_weight(A_initial, x_nodes, rho)
weight_optimal = objective_weight(A_optimal, x_nodes, rho)

# å¯è¦–åŒ–
fig, axes = plt.subplots(2, 2, figsize=(14, 10))

# æ–­é¢ç©åˆ†å¸ƒ
ax1 = axes[0, 0]
ax1.plot(x_nodes, A_initial * 1e4, 'b--', label=f'åˆæœŸè¨­è¨ˆ ({weight_initial:.2f} kg)', 
         linewidth=2)
ax1.plot(x_nodes, A_optimal * 1e4, 'r-', label=f'æœ€é©è¨­è¨ˆ ({weight_optimal:.2f} kg)', 
         linewidth=2, marker='o', markersize=4)
ax1.set_xlabel('x (m)')
ax1.set_ylabel('Cross-sectional area (cmÂ²)')
ax1.set_title('æ–­é¢ç©åˆ†å¸ƒ')
ax1.legend()
ax1.grid(True, alpha=0.3)

# å¤‰ä½åˆ†å¸ƒ
ax2 = axes[0, 1]
ax2.plot(x_nodes, u_initial * 1000, 'b--', label='åˆæœŸè¨­è¨ˆ', linewidth=2)
ax2.plot(x_nodes, u_optimal * 1000, 'r-', label='æœ€é©è¨­è¨ˆ', linewidth=2, marker='o', markersize=4)
ax2.set_xlabel('x (m)')
ax2.set_ylabel('Displacement (mm)')
ax2.set_title('å¤‰ä½åˆ†å¸ƒ')
ax2.legend()
ax2.grid(True, alpha=0.3)

# å¿œåŠ›åˆ†å¸ƒ
ax3 = axes[1, 0]
x_stress = (x_nodes[:-1] + x_nodes[1:]) / 2
ax3.plot(x_stress, stress_initial / 1e6, 'b--', label='åˆæœŸè¨­è¨ˆ', linewidth=2)
ax3.plot(x_stress, stress_optimal / 1e6, 'r-', label='æœ€é©è¨­è¨ˆ', linewidth=2, marker='o', markersize=4)
ax3.axhline(sigma_max / 1e6, color='k', linestyle=':', linewidth=2, label=f'è¨±å®¹å¿œåŠ› ({sigma_max/1e6:.0f} MPa)')
ax3.set_xlabel('x (m)')
ax3.set_ylabel('Stress (MPa)')
ax3.set_title('å¿œåŠ›åˆ†å¸ƒ')
ax3.legend()
ax3.grid(True, alpha=0.3)

# é‡é‡å‰Šæ¸›åŠ¹æœ
ax4 = axes[1, 1]
metrics = ['åˆæœŸè¨­è¨ˆ', 'æœ€é©è¨­è¨ˆ']
weights = [weight_initial, weight_optimal]
colors = ['blue', 'red']
bars = ax4.bar(metrics, weights, color=colors, alpha=0.7)
ax4.set_ylabel('Weight (kg)')
ax4.set_title(f'é‡é‡å‰Šæ¸›: {(weight_initial - weight_optimal)/weight_initial * 100:.1f}%')
ax4.grid(True, axis='y', alpha=0.3)

for bar, weight in zip(bars, weights):
    ax4.text(bar.get_x() + bar.get_width()/2, bar.get_height() + 0.05, 
             f'{weight:.2f} kg', ha='center', fontweight='bold')

plt.tight_layout()
plt.savefig('variation_shape_optimization.png', dpi=300, bbox_inches='tight')
plt.show()

print("=== å½¢çŠ¶æœ€é©åŒ–ï¼ˆæœ€å°é‡é‡è¨­è¨ˆï¼‰===")
print(f"åˆæœŸè¨­è¨ˆé‡é‡: {weight_initial:.4f} kg")
print(f"æœ€é©è¨­è¨ˆé‡é‡: {weight_optimal:.4f} kg")
print(f"é‡é‡å‰Šæ¸›ç‡: {(weight_initial - weight_optimal)/weight_initial * 100:.2f}%")
print(f"æœ€å¤§å¿œåŠ›ï¼ˆåˆæœŸï¼‰: {np.max(np.abs(stress_initial))/1e6:.2f} MPa")
print(f"æœ€å¤§å¿œåŠ›ï¼ˆæœ€é©ï¼‰: {np.max(np.abs(stress_optimal))/1e6:.2f} MPa")
print(f"è¨±å®¹å¿œåŠ›: {sigma_max/1e6:.2f} MPa")
</div>
        </div>

        <div class="content">
            <h2>ğŸ“š ã¾ã¨ã‚</h2>
            <ul>
                <li><strong>å¤‰åˆ†æ³•</strong>ã¯æ±é–¢æ•°ã‚’æ¥µå€¤åŒ–ã™ã‚‹é–¢æ•°ã‚’æ±‚ã‚ã‚‹æ‰‹æ³•ã§ã€ã‚ªã‚¤ãƒ©ãƒ¼-ãƒ©ã‚°ãƒ©ãƒ³ã‚¸ãƒ¥æ–¹ç¨‹å¼ãŒåŸºæœ¬</li>
                <li><strong>æœ€é€Ÿé™ä¸‹ç·š</strong>ï¼ˆãƒ–ãƒ©ã‚­ã‚¹ãƒˆã‚¯ãƒ­ãƒ³æ›²ç·šï¼‰ã¯ã‚µã‚¤ã‚¯ãƒ­ã‚¤ãƒ‰ã§ã‚ã‚Šã€å¤‰åˆ†æ³•ã®å¤å…¸çš„å¿œç”¨ä¾‹</li>
                <li><strong>æ¸¬åœ°ç·š</strong>ã¯æ›²é¢ä¸Šã®æœ€çŸ­çµŒè·¯ã§ã‚ã‚Šã€çƒé¢ã§ã¯å¤§å††ã¨ãªã‚‹</li>
                <li><strong>æœ€å°ä½œç”¨ã®åŸç†</strong>ã¯ç‰©ç†å­¦ã®åŸºæœ¬åŸç†ã§ã‚ã‚Šã€ãƒ©ã‚°ãƒ©ãƒ³ã‚¸ãƒ¥åŠ›å­¦ã®åŸºç¤</li>
                <li><strong>ç­‰å‘¨å•é¡Œ</strong>ã§ã¯ã€ä¸ãˆã‚‰ã‚ŒãŸå‘¨é•·ã§é¢ç©ã‚’æœ€å¤§åŒ–ã™ã‚‹å›³å½¢ã¯å††ã§ã‚ã‚‹</li>
                <li><strong>ã‚¬ãƒ©ãƒ¼ã‚­ãƒ³æ³•</strong>ã¯åå¾®åˆ†æ–¹ç¨‹å¼ã‚’å¼±å½¢å¼ã§è§£ãå¼·åŠ›ãªæ‰‹æ³•</li>
                <li><strong>æœ‰é™è¦ç´ æ³•</strong>ã¯å¤‰åˆ†åŸç†ã«åŸºã¥ãã€å¼¾æ€§ä½“ã®å¤‰å½¢ã‚„å½¢çŠ¶æœ€é©åŒ–ã«åºƒãå¿œç”¨ã•ã‚Œã‚‹</li>
                <li>ææ–™ç§‘å­¦ã§ã¯ã€ã‚¨ãƒãƒ«ã‚®ãƒ¼æœ€å°åŒ–åŸç†ã‚„å½¢çŠ¶æœ€é©åŒ–ãŒå®Ÿç”¨çš„ã«é‡è¦</li>
            </ul>
        </div>

        <div class="exercise">
            <h3>ğŸ’¡ æ¼”ç¿’å•é¡Œ</h3>
            <ol>
                <li><strong>å¤‰åˆ†å•é¡Œ</strong>: æ±é–¢æ•° \(J[y] = \int_0^1 (y'^2 + y^2) dx\) ã‚’æ¥µå€¤åŒ–ã™ã‚‹é–¢æ•° \(y(x)\) ã‚’ã€å¢ƒç•Œæ¡ä»¶ \(y(0)=0, y(1)=1\) ã®ã‚‚ã¨ã§æ±‚ã‚ã‚ˆã€‚</li>
                <li><strong>æœ€é€Ÿé™ä¸‹ç·š</strong>: ç•°ãªã‚‹2ç‚¹é–“ã§ã®ãƒ–ãƒ©ã‚­ã‚¹ãƒˆã‚¯ãƒ­ãƒ³æ›²ç·šã‚’æ•°å€¤çš„ã«æ±‚ã‚ã€ç›´ç·šã¨ã®é™ä¸‹æ™‚é–“ã‚’æ¯”è¼ƒã›ã‚ˆã€‚</li>
                <li><strong>çƒé¢æ¸¬åœ°ç·š</strong>: çƒé¢ä¸Šã®ä»»æ„ã®2ç‚¹é–“ã®æ¸¬åœ°ç·šã‚’æ±‚ã‚ã€å¤§å††ã§ã‚ã‚‹ã“ã¨ã‚’æ•°å€¤çš„ã«ç¢ºèªã›ã‚ˆã€‚</li>
                <li><strong>æŒ¯ã‚Šå­ã®è»Œé“</strong>: å˜æŒ¯ã‚Šå­ã®é‹å‹•ã‚’æœ€å°ä½œç”¨ã®åŸç†ã‹ã‚‰å°å‡ºã—ã€ã‚¨ãƒãƒ«ã‚®ãƒ¼ä¿å­˜å‰‡ã‚’æ¤œè¨¼ã›ã‚ˆã€‚</li>
                <li><strong>FEMã«ã‚ˆã‚‹æ¢ã®è§£æ</strong>: åˆ†å¸ƒè·é‡ã‚’å—ã‘ã‚‹æ¢ã®å¤‰å½¢ã‚’ã‚¬ãƒ©ãƒ¼ã‚­ãƒ³æ³•ã§è§£ãã€è§£æè§£ã¨æ¯”è¼ƒã›ã‚ˆã€‚</li>
            </ol>
        </div>

        <div class="navigation">
            <a href="chapter-3.html" class="nav-button">â† ç¬¬3ç« : ãƒ©ãƒ—ãƒ©ã‚¹æ–¹ç¨‹å¼ã¨ãƒãƒ†ãƒ³ã‚·ãƒ£ãƒ«ç†è«–</a>
            <a href="chapter-5.html" class="nav-button">ç¬¬5ç« : æ•°å€¤è§£æ³•ã¨æœ‰é™è¦ç´ æ³• â†’</a>
        </div>
    </div>

    <footer>
        <p>&copy; 2025 AI Terakoya - Fundamentals of Mathematics & Physics Dojo</p>
    </footer>
</body>
</html>
