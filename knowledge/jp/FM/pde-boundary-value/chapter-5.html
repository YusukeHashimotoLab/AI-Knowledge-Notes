<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç¬¬5ç« : æ•°å€¤è§£æ³•ã¨æœ‰é™è¦ç´ æ³• | åŸºç¤æ•°ç†é“å ´ - åå¾®åˆ†æ–¹ç¨‹å¼ã¨å¢ƒç•Œå€¤å•é¡Œ</title>
    <meta name="description" content="æ•°å€¤è§£æ³•ã¨æœ‰é™è¦ç´ æ³•ï¼šæœ‰é™å·®åˆ†æ³•ã€æœ‰é™è¦ç´ æ³•ã€æ™‚é–“ç©åˆ†ã‚¹ã‚­ãƒ¼ãƒ ã€å®‰å®šæ€§ã¨åæŸæ€§ã€ãƒ¡ãƒƒã‚·ãƒ¥ç”Ÿæˆã‚’å­¦ã³ã€ãƒ—ãƒ­ã‚»ã‚¹ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã¸ã®å¿œç”¨ã‚’å®Ÿè£…ã—ã¾ã™ã€‚">
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            line-height: 1.8;
            color: #333;
            background: #f5f5f5;
        }
        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 2rem 1rem;
            text-align: center;
        }
        .breadcrumb {
            max-width: 1200px;
            margin: 1rem auto;
            padding: 0 1rem;
            font-size: 0.9rem;
        }
        .breadcrumb a { color: #667eea; text-decoration: none; }
        .breadcrumb a:hover { text-decoration: underline; }
        .container {
            max-width: 1200px;
            margin: 2rem auto;
            padding: 0 1rem;
        }
        .content {
            background: white;
            padding: 2rem;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            margin-bottom: 2rem;
        }
        h1 { font-size: 2rem; margin-bottom: 1rem; }
        h2 {
            font-size: 1.5rem;
            margin: 2rem 0 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 3px solid #764ba2;
            color: #667eea;
        }
        h3 { font-size: 1.2rem; margin: 1.5rem 0 1rem; color: #555; }
        p { margin-bottom: 1rem; }
        ul, ol { margin: 1rem 0 1rem 2rem; }
        li { margin-bottom: 0.5rem; }
        .theory-box {
            background: linear-gradient(to right, #f0f4ff, #faf5ff);
            border-left: 4px solid #667eea;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-radius: 8px;
        }
        .code-example {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 1.5rem;
            border-radius: 8px;
            overflow-x: auto;
            margin: 1rem 0;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            line-height: 1.6;
        }
        .code-title {
            background: #667eea;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 6px 6px 0 0;
            font-weight: 600;
            margin-top: 1.5rem;
        }
        .exercise {
            background: #fff9e6;
            border-left: 4px solid #f59e0b;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-radius: 8px;
        }
        .navigation {
            display: flex;
            justify-content: space-between;
            margin-top: 3rem;
            gap: 1rem;
        }
        .nav-button {
            padding: 0.75rem 1.5rem;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            text-decoration: none;
            border-radius: 8px;
            font-weight: 600;
            transition: transform 0.3s;
        }
        .nav-button:hover { transform: translateY(-2px); }
        footer {
            background: #2c3e50;
            color: white;
            text-align: center;
            padding: 2rem 1rem;
            margin-top: 4rem;
        }
        @media (max-width: 768px) {
            .content { padding: 1.5rem; }
            h1 { font-size: 1.5rem; }
            h2 { font-size: 1.3rem; }
            .navigation { flex-direction: column; }
        }
    </style>
</head>
<body>
    <header>
        <h1>ğŸ“ ç¬¬5ç« : æ•°å€¤è§£æ³•ã¨æœ‰é™è¦ç´ æ³•</h1>
        <p>Numerical Methods and Finite Element Method</p>
    </header>

    <div class="breadcrumb">
        <a href="../../index.html">ãƒŠãƒ¬ãƒƒã‚¸ãƒ™ãƒ¼ã‚¹</a> &gt;
        <a href="../index.html">åŸºç¤æ•°ç†é“å ´</a> &gt;
        <a href="index.html">åå¾®åˆ†æ–¹ç¨‹å¼ã¨å¢ƒç•Œå€¤å•é¡Œ</a> &gt;
        ç¬¬5ç« 
    </div>

    <div class="container">
        <div class="content">
            <h2>ğŸ¯ å­¦ç¿’ç›®æ¨™</h2>
            <ul>
                <li>æœ‰é™å·®åˆ†æ³•ï¼ˆFDMï¼‰ã®åŸºç¤ã¨æ§˜ã€…ãªã‚¹ã‚­ãƒ¼ãƒ ã‚’ç†è§£ã™ã‚‹</li>
                <li>æœ‰é™è¦ç´ æ³•ï¼ˆFEMï¼‰ã®ç†è«–ã¨å®Ÿè£…ã‚’ç¿’å¾—ã™ã‚‹</li>
                <li>æ™‚é–“ç©åˆ†ã‚¹ã‚­ãƒ¼ãƒ ï¼ˆé™½è§£æ³•ãƒ»é™°è§£æ³•ï¼‰ã®ç‰¹æ€§ã‚’å­¦ã¶</li>
                <li>å®‰å®šæ€§è§£æã¨åæŸæ€§ã®ç†è«–çš„åŸºç¤ã‚’ç†è§£ã™ã‚‹</li>
                <li>ãƒ¡ãƒƒã‚·ãƒ¥ç”Ÿæˆã¨è¦ç´ ã®é¸æŠã‚’å­¦ã¶</li>
                <li>2æ¬¡å…ƒãƒ»3æ¬¡å…ƒå•é¡Œã¸ã®æ‹¡å¼µã‚’ç†è§£ã™ã‚‹</li>
                <li>ã‚¹ãƒ‘ãƒ¼ã‚¹è¡Œåˆ—ã®åŠ¹ç‡çš„ãªæ‰±ã„æ–¹ã‚’ç¿’å¾—ã™ã‚‹</li>
                <li>ãƒ—ãƒ­ã‚»ã‚¹ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆç†±å‡¦ç†ã€åå¿œæ‹¡æ•£ï¼‰ã¸ã®å¿œç”¨ã‚’å®Ÿè£…ã™ã‚‹</li>
            </ul>
        </div>

        <div class="content">
            <h2>ğŸ“– æ•°å€¤è§£æ³•ã®åŸºç¤</h2>
            
            <div class="theory-box">
                <h3>æ•°å€¤è§£æ³•ã®åˆ†é¡</h3>
                <p><strong>æœ‰é™å·®åˆ†æ³•ï¼ˆFinite Difference Method, FDMï¼‰</strong>:</p>
                <ul>
                    <li>å¾®åˆ†ã‚’å·®åˆ†è¿‘ä¼¼ã§ç½®ãæ›ãˆã‚‹</li>
                    <li>æ§‹é€ æ ¼å­ã§å®Ÿè£…ãŒå®¹æ˜“</li>
                    <li>è¤‡é›‘å½¢çŠ¶ã¸ã®é©ç”¨ãŒå›°é›£</li>
                </ul>
                <p><strong>æœ‰é™è¦ç´ æ³•ï¼ˆFinite Element Method, FEMï¼‰</strong>:</p>
                <ul>
                    <li>å¤‰åˆ†åŸç†ã«åŸºã¥ãå¼±å½¢å¼ã‚’åˆ©ç”¨</li>
                    <li>éæ§‹é€ æ ¼å­ã§è¤‡é›‘å½¢çŠ¶ã«å¯¾å¿œ</li>
                    <li>è¦ç´ å†…ã§ã®è£œé–“ãŒé«˜ç²¾åº¦</li>
                </ul>
                <p><strong>æœ‰é™ä½“ç©æ³•ï¼ˆFinite Volume Method, FVMï¼‰</strong>:</p>
                <ul>
                    <li>ä¿å­˜å‰‡ã‚’ç©åˆ†å½¢å¼ã§æ‰±ã†</li>
                    <li>æµä½“åŠ›å­¦ã§åºƒãä½¿ç”¨</li>
                    <li>è³ªé‡ãƒ»ã‚¨ãƒãƒ«ã‚®ãƒ¼ä¿å­˜ãŒå³å¯†</li>
                </ul>
            </div>

            <div class="theory-box">
                <h3>å®‰å®šæ€§ã¨åæŸæ€§</h3>
                <p><strong>å®‰å®šæ€§ï¼ˆStabilityï¼‰</strong>: æ•°å€¤èª¤å·®ãŒæ™‚é–“ç™ºå±•ã§ç™ºæ•£ã—ãªã„æ¡ä»¶</p>
                <p><strong>CFLæ¡ä»¶ï¼ˆCourant-Friedrichs-Lewyï¼‰</strong>: æ³¢å‹•æ–¹ç¨‹å¼ã®å®‰å®šæ€§æ¡ä»¶</p>
                <p>\[
                C = c \frac{\Delta t}{\Delta x} \leq C_{\text{max}}
                \]</p>
                <p><strong>åæŸæ€§ï¼ˆConvergenceï¼‰</strong>: ãƒ¡ãƒƒã‚·ãƒ¥å¹… \(\Delta x \to 0\) ã§çœŸã®è§£ã«è¿‘ã¥ãæ€§è³ª</p>
                <p><strong>ä¸€è²«æ€§ï¼ˆConsistencyï¼‰</strong>: å·®åˆ†å¼ãŒå¾®åˆ†æ–¹ç¨‹å¼ã«åæŸã™ã‚‹æ€§è³ª</p>
                <p><strong>Laxã®ç­‰ä¾¡å®šç†</strong>: ä¸€è²«æ€§ + å®‰å®šæ€§ â‡’ åæŸæ€§</p>
            </div>
        </div>

        <div class="content">
            <h2>ğŸ’» ä¾‹é¡Œ5.1: æœ‰é™å·®åˆ†æ³•ã®æ¯”è¼ƒï¼ˆFTCS, BTCS, Crank-Nicolsonï¼‰</h2>
            
            <div class="theory-box">
                <h3>ç†±æ–¹ç¨‹å¼ã®å·®åˆ†ã‚¹ã‚­ãƒ¼ãƒ </h3>
                <p>1æ¬¡å…ƒç†±æ–¹ç¨‹å¼: \(\frac{\partial u}{\partial t} = \alpha \frac{\partial^2 u}{\partial x^2}\)</p>
                <p><strong>FTCSï¼ˆForward Time, Centered Spaceï¼‰</strong>: é™½è§£æ³•ã€æ¡ä»¶ä»˜ãå®‰å®š</p>
                <p>\[
                \frac{u_i^{n+1} - u_i^n}{\Delta t} = \alpha \frac{u_{i+1}^n - 2u_i^n + u_{i-1}^n}{\Delta x^2}
                \]</p>
                <p>å®‰å®šæ¡ä»¶: \(r = \alpha \Delta t / \Delta x^2 \leq 0.5\)</p>
                <p><strong>BTCSï¼ˆBackward Time, Centered Spaceï¼‰</strong>: é™°è§£æ³•ã€ç„¡æ¡ä»¶å®‰å®š</p>
                <p>\[
                \frac{u_i^{n+1} - u_i^n}{\Delta t} = \alpha \frac{u_{i+1}^{n+1} - 2u_i^{n+1} + u_{i-1}^{n+1}}{\Delta x^2}
                \]</p>
                <p><strong>Crank-Nicolsonæ³•</strong>: é™°è§£æ³•ã€2æ¬¡ç²¾åº¦ã€ç„¡æ¡ä»¶å®‰å®š</p>
                <p>\[
                \frac{u_i^{n+1} - u_i^n}{\Delta t} = \frac{\alpha}{2}\left[\frac{u_{i+1}^{n+1} - 2u_i^{n+1} + u_{i-1}^{n+1}}{\Delta x^2} + \frac{u_{i+1}^n - 2u_i^n + u_{i-1}^n}{\Delta x^2}\right]
                \]</p>
            </div>

            <div class="code-title">Pythonå®Ÿè£…: 3ã¤ã®ã‚¹ã‚­ãƒ¼ãƒ ã®æ¯”è¼ƒ</div>
            <div class="code-example">import numpy as np
import matplotlib.pyplot as plt
from scipy.sparse import diags
from scipy.sparse.linalg import spsolve

# ç†±æ–¹ç¨‹å¼ã®åˆæœŸå€¤ãƒ»å¢ƒç•Œå€¤å•é¡Œ
alpha = 0.01  # ç†±æ‹¡æ•£ä¿‚æ•°
L = 1.0  # é ˜åŸŸã®é•·ã•
T_final = 0.5  # çµ‚äº†æ™‚åˆ»

# åˆæœŸæ¡ä»¶: u(x, 0) = sin(Ï€x)
def initial_condition(x):
    return np.sin(np.pi * x)

# è§£æè§£: u(x, t) = exp(-Ï€Â²Î±t) sin(Ï€x)
def analytical_solution(x, t, alpha):
    return np.exp(-np.pi**2 * alpha * t) * np.sin(np.pi * x)

# ç©ºé–“é›¢æ•£åŒ–
Nx = 50
x = np.linspace(0, L, Nx)
dx = x[1] - x[0]

# æ™‚é–“é›¢æ•£åŒ–ï¼ˆå®‰å®šæ¡ä»¶ã‚’è€ƒæ…®ï¼‰
r_stable = 0.4  # FTCSç”¨ï¼ˆr â‰¤ 0.5ï¼‰
dt_ftcs = r_stable * dx**2 / alpha
dt_implicit = 2 * dt_ftcs  # é™°è§£æ³•ã¯å®‰å®šæ¡ä»¶ãªã—
Nt_ftcs = int(T_final / dt_ftcs)
Nt_implicit = int(T_final / dt_implicit)

print(f"=== æ™‚é–“åˆ»ã¿ ===")
print(f"FTCS: dt = {dt_ftcs:.6f} s, Nt = {Nt_ftcs}")
print(f"é™°è§£æ³•: dt = {dt_implicit:.6f} s, Nt = {Nt_implicit}")

# FTCSæ³•ï¼ˆé™½è§£æ³•ï¼‰
def ftcs_method(x, dt, Nt, alpha):
    u = initial_condition(x)
    u_history = [u.copy()]
    
    r = alpha * dt / dx**2
    
    for n in range(Nt):
        u_new = u.copy()
        for i in range(1, len(x)-1):
            u_new[i] = u[i] + r * (u[i+1] - 2*u[i] + u[i-1])
        
        # å¢ƒç•Œæ¡ä»¶
        u_new[0] = 0
        u_new[-1] = 0
        
        u = u_new
        u_history.append(u.copy())
    
    return np.array(u_history), r

# BTCSæ³•ï¼ˆé™°è§£æ³•ï¼‰
def btcs_method(x, dt, Nt, alpha):
    u = initial_condition(x)
    u_history = [u.copy()]
    
    r = alpha * dt / dx**2
    
    # ä¿‚æ•°è¡Œåˆ—ï¼ˆå¢ƒç•Œæ¡ä»¶ã‚’çµ„ã¿è¾¼ã‚€ï¼‰
    main_diag = np.full(len(x)-2, 1 + 2*r)
    off_diag = np.full(len(x)-3, -r)
    A = diags([off_diag, main_diag, off_diag], [-1, 0, 1], format='csr')
    
    for n in range(Nt):
        # å³è¾ºãƒ™ã‚¯ãƒˆãƒ«
        b = u[1:-1].copy()
        
        # ã‚¹ãƒ‘ãƒ¼ã‚¹ç·šå½¢ã‚·ã‚¹ãƒ†ãƒ ã‚’è§£ã
        u[1:-1] = spsolve(A, b)
        
        u_history.append(u.copy())
    
    return np.array(u_history), r

# Crank-Nicolsonæ³•
def crank_nicolson_method(x, dt, Nt, alpha):
    u = initial_condition(x)
    u_history = [u.copy()]
    
    r = alpha * dt / dx**2
    
    # ä¿‚æ•°è¡Œåˆ—
    main_diag_L = np.full(len(x)-2, 1 + r)
    off_diag_L = np.full(len(x)-3, -r/2)
    A = diags([off_diag_L, main_diag_L, off_diag_L], [-1, 0, 1], format='csr')
    
    main_diag_R = np.full(len(x)-2, 1 - r)
    off_diag_R = np.full(len(x)-3, r/2)
    B = diags([off_diag_R, main_diag_R, off_diag_R], [-1, 0, 1], format='csr')
    
    for n in range(Nt):
        # å³è¾ºãƒ™ã‚¯ãƒˆãƒ«
        b = B @ u[1:-1]
        
        # ç·šå½¢ã‚·ã‚¹ãƒ†ãƒ ã‚’è§£ã
        u[1:-1] = spsolve(A, b)
        
        u_history.append(u.copy())
    
    return np.array(u_history), r

# å„æ‰‹æ³•ã§è§£ã
u_ftcs, r_ftcs = ftcs_method(x, dt_ftcs, Nt_ftcs, alpha)
u_btcs, r_btcs = btcs_method(x, dt_implicit, Nt_implicit, alpha)
u_cn, r_cn = crank_nicolson_method(x, dt_implicit, Nt_implicit, alpha)

# è§£æè§£
u_analytical = analytical_solution(x, T_final, alpha)

# å¯è¦–åŒ–
fig, axes = plt.subplots(2, 2, figsize=(14, 10))

# æœ€çµ‚æ™‚åˆ»ã§ã®è§£ã®æ¯”è¼ƒ
ax1 = axes[0, 0]
ax1.plot(x, u_analytical, 'k-', label='è§£æè§£', linewidth=3)
ax1.plot(x, u_ftcs[-1], 'b--', label=f'FTCS (r={r_ftcs:.3f})', linewidth=2)
ax1.plot(x, u_btcs[-1], 'r:', label=f'BTCS (r={r_btcs:.3f})', linewidth=2)
ax1.plot(x, u_cn[-1], 'g-.', label=f'Crank-Nicolson (r={r_cn:.3f})', linewidth=2)
ax1.set_xlabel('x')
ax1.set_ylabel('u(x, t)')
ax1.set_title(f'æœ€çµ‚æ™‚åˆ» t = {T_final} s ã§ã®è§£')
ax1.legend()
ax1.grid(True, alpha=0.3)

# èª¤å·®ã®æ¯”è¼ƒ
ax2 = axes[0, 1]
error_ftcs = np.abs(u_ftcs[-1] - u_analytical)
error_btcs = np.abs(u_btcs[-1] - u_analytical)
error_cn = np.abs(u_cn[-1] - u_analytical)
ax2.semilogy(x, error_ftcs, 'b--', label='FTCS', linewidth=2)
ax2.semilogy(x, error_btcs, 'r:', label='BTCS', linewidth=2)
ax2.semilogy(x, error_cn, 'g-.', label='Crank-Nicolson', linewidth=2)
ax2.set_xlabel('x')
ax2.set_ylabel('Absolute error')
ax2.set_title('èª¤å·®åˆ†å¸ƒ')
ax2.legend()
ax2.grid(True, alpha=0.3)

# æ™‚é–“ç™ºå±•ï¼ˆFTCSï¼‰
ax3 = axes[1, 0]
time_snapshots = np.linspace(0, Nt_ftcs, 6, dtype=int)
for nt in time_snapshots:
    t = nt * dt_ftcs
    ax3.plot(x, u_ftcs[nt], label=f't = {t:.3f} s')
ax3.set_xlabel('x')
ax3.set_ylabel('u(x, t)')
ax3.set_title('FTCSæ³•ã®æ™‚é–“ç™ºå±•')
ax3.legend()
ax3.grid(True, alpha=0.3)

# L2ãƒãƒ«ãƒ èª¤å·®ã®æ¯”è¼ƒ
ax4 = axes[1, 1]
methods = ['FTCS', 'BTCS', 'Crank-Nicolson']
errors_l2 = [
    np.linalg.norm(u_ftcs[-1] - u_analytical) / np.linalg.norm(u_analytical),
    np.linalg.norm(u_btcs[-1] - u_analytical) / np.linalg.norm(u_analytical),
    np.linalg.norm(u_cn[-1] - u_analytical) / np.linalg.norm(u_analytical)
]
colors = ['blue', 'red', 'green']
bars = ax4.bar(methods, errors_l2, color=colors, alpha=0.7)
ax4.set_ylabel('Relative L2 error')
ax4.set_title('L2ãƒãƒ«ãƒ èª¤å·®ã®æ¯”è¼ƒ')
ax4.grid(True, axis='y', alpha=0.3)

for bar, error in zip(bars, errors_l2):
    ax4.text(bar.get_x() + bar.get_width()/2, bar.get_height() + 0.001, 
             f'{error:.2e}', ha='center', fontweight='bold', fontsize=9)

plt.tight_layout()
plt.savefig('fem_fdm_comparison.png', dpi=300, bbox_inches='tight')
plt.show()

print(f"\n=== èª¤å·®æ¯”è¼ƒï¼ˆç›¸å¯¾L2ãƒãƒ«ãƒ ï¼‰===")
for method, error in zip(methods, errors_l2):
    print(f"{method}: {error:.6e}")
</div>
        </div>

        <div class="content">
            <h2>ğŸ’» ä¾‹é¡Œ5.2: 2æ¬¡å…ƒæœ‰é™è¦ç´ æ³•ï¼ˆä¸‰è§’å½¢è¦ç´ ï¼‰</h2>
            
            <div class="theory-box">
                <h3>2æ¬¡å…ƒFEMã®åŸºç¤</h3>
                <p>2æ¬¡å…ƒãƒã‚¢ã‚½ãƒ³æ–¹ç¨‹å¼: \(-\nabla^2 u = f\) ã‚’é ˜åŸŸ \(\Omega\) ã§è§£ã</p>
                <p>å¼±å½¢å¼: \(\int_\Omega \nabla u \cdot \nabla v \, dA = \int_\Omega f v \, dA\)</p>
                <p><strong>ç·šå½¢ä¸‰è§’å½¢è¦ç´ </strong>:</p>
                <ul>
                    <li>3ã¤ã®ç¯€ç‚¹ã‚’æŒã¤</li>
                    <li>è¦ç´ å†…ã§ç·šå½¢è£œé–“: \(u(x,y) = N_1(x,y) u_1 + N_2(x,y) u_2 + N_3(x,y) u_3\)</li>
                    <li>å½¢çŠ¶é–¢æ•° \(N_i\) ã¯é¢ç©åº§æ¨™ã§è¡¨ç¾</li>
                </ul>
            </div>

            <div class="code-title">Pythonå®Ÿè£…: 2æ¬¡å…ƒãƒã‚¢ã‚½ãƒ³æ–¹ç¨‹å¼ã®æœ‰é™è¦ç´ è§£</div>
            <div class="code-example">import numpy as np
import matplotlib.pyplot as plt
from scipy.spatial import Delaunay
from scipy.sparse import lil_matrix
from scipy.sparse.linalg import spsolve

def generate_mesh_2d(Lx, Ly, Nx, Ny):
    """2æ¬¡å…ƒçŸ©å½¢é ˜åŸŸã®ãƒ¡ãƒƒã‚·ãƒ¥ç”Ÿæˆï¼ˆDelaunayä¸‰è§’å½¢åˆ†å‰²ï¼‰"""
    x = np.linspace(0, Lx, Nx)
    y = np.linspace(0, Ly, Ny)
    X, Y = np.meshgrid(x, y)
    points = np.column_stack([X.ravel(), Y.ravel()])
    
    # Delaunayä¸‰è§’å½¢åˆ†å‰²
    tri = Delaunay(points)
    
    return points, tri

def compute_element_stiffness(nodes):
    """ä¸‰è§’å½¢è¦ç´ ã®å‰›æ€§è¡Œåˆ—ã‚’è¨ˆç®—"""
    # nodes: (3, 2) ã®é…åˆ—ï¼ˆ3ç¯€ç‚¹ã®åº§æ¨™ï¼‰
    x1, y1 = nodes[0]
    x2, y2 = nodes[1]
    x3, y3 = nodes[2]
    
    # è¦ç´ ã®é¢ç©
    A = 0.5 * abs((x2 - x1) * (y3 - y1) - (x3 - x1) * (y2 - y1))
    
    # å½¢çŠ¶é–¢æ•°ã®å‹¾é…
    b = np.array([y2 - y3, y3 - y1, y1 - y2])
    c = np.array([x3 - x2, x1 - x3, x2 - x1])
    
    # è¦ç´ å‰›æ€§è¡Œåˆ—
    K_elem = np.zeros((3, 3))
    for i in range(3):
        for j in range(3):
            K_elem[i, j] = (b[i] * b[j] + c[i] * c[j]) / (4 * A)
    
    return K_elem, A

def assemble_global_system(points, tri, source_func):
    """å…¨ä½“å‰›æ€§è¡Œåˆ—ã¨è·é‡ãƒ™ã‚¯ãƒˆãƒ«ã®çµ„ã¿ç«‹ã¦"""
    n_points = len(points)
    K = lil_matrix((n_points, n_points))
    F = np.zeros(n_points)
    
    # è¦ç´ ãƒ«ãƒ¼ãƒ—
    for elem in tri.simplices:
        nodes = points[elem]
        K_elem, A_elem = compute_element_stiffness(nodes)
        
        # å…¨ä½“è¡Œåˆ—ã¸ã®çµ„ã¿è¾¼ã¿
        for i in range(3):
            for j in range(3):
                K[elem[i], elem[j]] += K_elem[i, j]
            
            # è·é‡ãƒ™ã‚¯ãƒˆãƒ«ï¼ˆè¦ç´ é‡å¿ƒã§ã®è©•ä¾¡ï¼‰
            x_center = np.mean(nodes[:, 0])
            y_center = np.mean(nodes[:, 1])
            F[elem[i]] += source_func(x_center, y_center) * A_elem / 3
    
    return K.tocsr(), F

def apply_boundary_conditions(K, F, points, boundary_value=0.0):
    """ãƒ‡ã‚£ãƒªã‚¯ãƒ¬å¢ƒç•Œæ¡ä»¶ã®é©ç”¨"""
    Lx = np.max(points[:, 0])
    Ly = np.max(points[:, 1])
    
    # å¢ƒç•Œä¸Šã®ç¯€ç‚¹ã‚’ç‰¹å®š
    tol = 1e-10
    boundary_nodes = []
    for i, (x, y) in enumerate(points):
        if x < tol or x > Lx - tol or y < tol or y > Ly - tol:
            boundary_nodes.append(i)
    
    # å¢ƒç•Œæ¡ä»¶ã®é©ç”¨ï¼ˆè¡Œã¨åˆ—ã‚’ã‚¼ãƒ­ã«ã—ã€å¯¾è§’æˆåˆ†ã‚’1ã«ï¼‰
    for node in boundary_nodes:
        K[node, :] = 0
        K[:, node] = 0
        K[node, node] = 1
        F[node] = boundary_value
    
    return K, F, boundary_nodes

# å•é¡Œè¨­å®š
Lx, Ly = 1.0, 1.0  # é ˜åŸŸã‚µã‚¤ã‚º
Nx, Ny = 15, 15    # ãƒ¡ãƒƒã‚·ãƒ¥åˆ†å‰²æ•°

# å³è¾ºé–¢æ•°: f(x,y) = 2Ï€Â² sin(Ï€x) sin(Ï€y)
def source_function(x, y):
    return 2 * np.pi**2 * np.sin(np.pi * x) * np.sin(np.pi * y)

# è§£æè§£: u(x,y) = sin(Ï€x) sin(Ï€y)
def analytical_solution(x, y):
    return np.sin(np.pi * x) * np.sin(np.pi * y)

# ãƒ¡ãƒƒã‚·ãƒ¥ç”Ÿæˆ
points, tri = generate_mesh_2d(Lx, Ly, Nx, Ny)

# å…¨ä½“ç³»ã®çµ„ã¿ç«‹ã¦
K, F = assemble_global_system(points, tri, source_function)

# å¢ƒç•Œæ¡ä»¶ã®é©ç”¨
K, F, boundary_nodes = apply_boundary_conditions(K, F, points)

# ç·šå½¢ã‚·ã‚¹ãƒ†ãƒ ã‚’è§£ã
u_fem = spsolve(K, F)

# è§£æè§£
u_analytical = analytical_solution(points[:, 0], points[:, 1])

# å¯è¦–åŒ–
fig = plt.figure(figsize=(16, 5))

# ãƒ¡ãƒƒã‚·ãƒ¥
ax1 = fig.add_subplot(141)
ax1.triplot(points[:, 0], points[:, 1], tri.simplices, 'k-', linewidth=0.5)
ax1.plot(points[boundary_nodes, 0], points[boundary_nodes, 1], 'ro', 
         markersize=3, label='å¢ƒç•Œç¯€ç‚¹')
ax1.set_xlabel('x')
ax1.set_ylabel('y')
ax1.set_title(f'ãƒ¡ãƒƒã‚·ãƒ¥ ({len(points)} ç¯€ç‚¹, {len(tri.simplices)} è¦ç´ )')
ax1.legend()
ax1.axis('equal')
ax1.grid(True, alpha=0.3)

# FEMè§£
ax2 = fig.add_subplot(142)
contour_fem = ax2.tricontourf(points[:, 0], points[:, 1], u_fem, levels=20, cmap='viridis')
ax2.tricontour(points[:, 0], points[:, 1], u_fem, levels=10, colors='white', 
               linewidths=0.5, alpha=0.5)
ax2.set_xlabel('x')
ax2.set_ylabel('y')
ax2.set_title('FEMè§£')
ax2.axis('equal')
plt.colorbar(contour_fem, ax=ax2, label='u(x,y)')

# è§£æè§£
ax3 = fig.add_subplot(143)
contour_analytical = ax3.tricontourf(points[:, 0], points[:, 1], u_analytical, 
                                      levels=20, cmap='viridis')
ax3.tricontour(points[:, 0], points[:, 1], u_analytical, levels=10, colors='white', 
               linewidths=0.5, alpha=0.5)
ax3.set_xlabel('x')
ax3.set_ylabel('y')
ax3.set_title('è§£æè§£')
ax3.axis('equal')
plt.colorbar(contour_analytical, ax=ax3, label='u(x,y)')

# èª¤å·®åˆ†å¸ƒ
ax4 = fig.add_subplot(144)
error = np.abs(u_fem - u_analytical)
contour_error = ax4.tricontourf(points[:, 0], points[:, 1], error, 
                                 levels=20, cmap='Reds')
ax4.set_xlabel('x')
ax4.set_ylabel('y')
ax4.set_title('èª¤å·®åˆ†å¸ƒ')
ax4.axis('equal')
plt.colorbar(contour_error, ax=ax4, label='|error|')

plt.tight_layout()
plt.savefig('fem_2d_poisson.png', dpi=300, bbox_inches='tight')
plt.show()

print("=== 2æ¬¡å…ƒFEMè§£æ ===")
print(f"ç¯€ç‚¹æ•°: {len(points)}")
print(f"è¦ç´ æ•°: {len(tri.simplices)}")
print(f"å¢ƒç•Œç¯€ç‚¹æ•°: {len(boundary_nodes)}")
print(f"æœ€å¤§èª¤å·®: {np.max(error):.6e}")
print(f"ç›¸å¯¾L2ãƒãƒ«ãƒ èª¤å·®: {np.linalg.norm(error) / np.linalg.norm(u_analytical):.6e}")
</div>
        </div>

        <div class="content">
            <h2>ğŸ’» ä¾‹é¡Œ5.3: é©å¿œçš„ãƒ¡ãƒƒã‚·ãƒ¥ç´°åˆ†åŒ–</h2>
            
            <div class="code-title">Pythonå®Ÿè£…: èª¤å·®æ¨å®šã«åŸºã¥ããƒ¡ãƒƒã‚·ãƒ¥ç´°åˆ†åŒ–</div>
            <div class="code-example">import numpy as np
import matplotlib.pyplot as plt
from scipy.spatial import Delaunay

def refine_mesh_adaptive(points, tri, error, threshold, max_iterations=3):
    """èª¤å·®ã®å¤§ãã„è¦ç´ ã‚’ç´°åˆ†åŒ–"""
    for iteration in range(max_iterations):
        # å„è¦ç´ ã®èª¤å·®ã‚’è¨ˆç®—ï¼ˆç¯€ç‚¹å¹³å‡ï¼‰
        element_errors = np.array([np.mean(error[elem]) for elem in tri.simplices])
        
        # ç´°åˆ†åŒ–ã™ã‚‹è¦ç´ ã‚’é¸æŠ
        refine_mask = element_errors > threshold * np.max(element_errors)
        n_refine = np.sum(refine_mask)
        
        if n_refine == 0:
            print(f"åå¾© {iteration+1}: ç´°åˆ†åŒ–ä¸è¦")
            break
        
        print(f"åå¾© {iteration+1}: {n_refine} è¦ç´ ã‚’ç´°åˆ†åŒ–")
        
        # æ–°ã—ã„ç‚¹ã‚’è¿½åŠ ï¼ˆè¦ç´ ã®é‡å¿ƒï¼‰
        new_points = []
        for i, elem in enumerate(tri.simplices):
            if refine_mask[i]:
                center = np.mean(points[elem], axis=0)
                new_points.append(center)
        
        if len(new_points) > 0:
            points = np.vstack([points, new_points])
            tri = Delaunay(points)
    
    return points, tri

# åˆæœŸç²—ãƒ¡ãƒƒã‚·ãƒ¥
Nx_coarse, Ny_coarse = 7, 7
points_coarse, tri_coarse = generate_mesh_2d(Lx, Ly, Nx_coarse, Ny_coarse)

# ç²—ãƒ¡ãƒƒã‚·ãƒ¥ã§è§£ã
K_coarse, F_coarse = assemble_global_system(points_coarse, tri_coarse, source_function)
K_coarse, F_coarse, boundary_nodes_coarse = apply_boundary_conditions(K_coarse, F_coarse, points_coarse)
u_coarse = spsolve(K_coarse, F_coarse)

# èª¤å·®æ¨å®š
u_analytical_coarse = analytical_solution(points_coarse[:, 0], points_coarse[:, 1])
error_coarse = np.abs(u_coarse - u_analytical_coarse)

# é©å¿œçš„ç´°åˆ†åŒ–
threshold = 0.3  # ç´°åˆ†åŒ–ã®é–¾å€¤ï¼ˆæœ€å¤§èª¤å·®ã®30%ï¼‰
points_refined, tri_refined = refine_mesh_adaptive(points_coarse, tri_coarse, 
                                                     error_coarse, threshold, max_iterations=2)

# ç´°åˆ†åŒ–ãƒ¡ãƒƒã‚·ãƒ¥ã§è§£ã
K_refined, F_refined = assemble_global_system(points_refined, tri_refined, source_function)
K_refined, F_refined, boundary_nodes_refined = apply_boundary_conditions(K_refined, F_refined, points_refined)
u_refined = spsolve(K_refined, F_refined)

# èª¤å·®
u_analytical_refined = analytical_solution(points_refined[:, 0], points_refined[:, 1])
error_refined = np.abs(u_refined - u_analytical_refined)

# å¯è¦–åŒ–
fig, axes = plt.subplots(2, 3, figsize=(16, 10))

# ç²—ãƒ¡ãƒƒã‚·ãƒ¥
ax1 = axes[0, 0]
ax1.triplot(points_coarse[:, 0], points_coarse[:, 1], tri_coarse.simplices, 'k-', linewidth=0.5)
ax1.set_xlabel('x')
ax1.set_ylabel('y')
ax1.set_title(f'ç²—ãƒ¡ãƒƒã‚·ãƒ¥ ({len(points_coarse)} ç¯€ç‚¹)')
ax1.axis('equal')
ax1.grid(True, alpha=0.3)

# ç²—ãƒ¡ãƒƒã‚·ãƒ¥è§£
ax2 = axes[0, 1]
contour = ax2.tricontourf(points_coarse[:, 0], points_coarse[:, 1], u_coarse, 
                           levels=20, cmap='viridis')
ax2.set_xlabel('x')
ax2.set_ylabel('y')
ax2.set_title('ç²—ãƒ¡ãƒƒã‚·ãƒ¥è§£')
ax2.axis('equal')
plt.colorbar(contour, ax=ax2)

# ç²—ãƒ¡ãƒƒã‚·ãƒ¥èª¤å·®
ax3 = axes[0, 2]
contour_error = ax3.tricontourf(points_coarse[:, 0], points_coarse[:, 1], error_coarse, 
                                 levels=20, cmap='Reds')
ax3.set_xlabel('x')
ax3.set_ylabel('y')
ax3.set_title(f'ç²—ãƒ¡ãƒƒã‚·ãƒ¥èª¤å·®ï¼ˆæœ€å¤§: {np.max(error_coarse):.2e}ï¼‰')
ax3.axis('equal')
plt.colorbar(contour_error, ax=ax3)

# ç´°åˆ†åŒ–ãƒ¡ãƒƒã‚·ãƒ¥
ax4 = axes[1, 0]
ax4.triplot(points_refined[:, 0], points_refined[:, 1], tri_refined.simplices, 'k-', linewidth=0.5)
ax4.set_xlabel('x')
ax4.set_ylabel('y')
ax4.set_title(f'ç´°åˆ†åŒ–ãƒ¡ãƒƒã‚·ãƒ¥ ({len(points_refined)} ç¯€ç‚¹)')
ax4.axis('equal')
ax4.grid(True, alpha=0.3)

# ç´°åˆ†åŒ–ãƒ¡ãƒƒã‚·ãƒ¥è§£
ax5 = axes[1, 1]
contour_refined = ax5.tricontourf(points_refined[:, 0], points_refined[:, 1], u_refined, 
                                   levels=20, cmap='viridis')
ax5.set_xlabel('x')
ax5.set_ylabel('y')
ax5.set_title('ç´°åˆ†åŒ–ãƒ¡ãƒƒã‚·ãƒ¥è§£')
ax5.axis('equal')
plt.colorbar(contour_refined, ax=ax5)

# ç´°åˆ†åŒ–ãƒ¡ãƒƒã‚·ãƒ¥èª¤å·®
ax6 = axes[1, 2]
contour_error_refined = ax6.tricontourf(points_refined[:, 0], points_refined[:, 1], 
                                        error_refined, levels=20, cmap='Reds')
ax6.set_xlabel('x')
ax6.set_ylabel('y')
ax6.set_title(f'ç´°åˆ†åŒ–ãƒ¡ãƒƒã‚·ãƒ¥èª¤å·®ï¼ˆæœ€å¤§: {np.max(error_refined):.2e}ï¼‰')
ax6.axis('equal')
plt.colorbar(contour_error_refined, ax=ax6)

plt.tight_layout()
plt.savefig('fem_adaptive_refinement.png', dpi=300, bbox_inches='tight')
plt.show()

print("\n=== é©å¿œçš„ãƒ¡ãƒƒã‚·ãƒ¥ç´°åˆ†åŒ– ===")
print(f"ç²—ãƒ¡ãƒƒã‚·ãƒ¥: ç¯€ç‚¹æ•° {len(points_coarse)}, æœ€å¤§èª¤å·® {np.max(error_coarse):.6e}")
print(f"ç´°åˆ†åŒ–ãƒ¡ãƒƒã‚·ãƒ¥: ç¯€ç‚¹æ•° {len(points_refined)}, æœ€å¤§èª¤å·® {np.max(error_refined):.6e}")
print(f"èª¤å·®æ”¹å–„ç‡: {np.max(error_coarse) / np.max(error_refined):.2f}x")
</div>
        </div>

        <div class="content">
            <h2>ğŸ’» ä¾‹é¡Œ5.4: æ™‚é–“ä¾å­˜å•é¡Œï¼ˆåå¿œæ‹¡æ•£æ–¹ç¨‹å¼ï¼‰</h2>
            
            <div class="theory-box">
                <h3>åå¿œæ‹¡æ•£æ–¹ç¨‹å¼</h3>
                <p>æ™‚é–“ä¾å­˜ã®åå¿œæ‹¡æ•£æ–¹ç¨‹å¼:</p>
                <p>\[
                \frac{\partial u}{\partial t} = D \nabla^2 u + f(u)
                \]</p>
                <p>ã“ã“ã§ \(D\) ã¯æ‹¡æ•£ä¿‚æ•°ã€\(f(u)\) ã¯åå¿œé …ï¼ˆä¾‹: \(f(u) = ku(1-u)\)ï¼‰ã€‚</p>
                <p>åŠé›¢æ•£åŒ–ï¼ˆç©ºé–“ã®ã¿é›¢æ•£åŒ–ï¼‰å¾Œã€æ™‚é–“ç©åˆ†ã§è§£ãã¾ã™ã€‚</p>
            </div>

            <div class="code-title">Pythonå®Ÿè£…: Fisher-KPPæ–¹ç¨‹å¼</div>
            <div class="code-example">import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import odeint

# Fisher-KPPæ–¹ç¨‹å¼: âˆ‚u/âˆ‚t = D âˆ‚Â²u/âˆ‚xÂ² + ku(1-u)
# äººå£æˆé•·ãƒ¢ãƒ‡ãƒ«ã€è…«ç˜æˆé•·ã€åŒ–å­¦åå¿œãªã©ã«å¿œç”¨

D = 0.01  # æ‹¡æ•£ä¿‚æ•°
k = 1.0   # åå¿œé€Ÿåº¦å®šæ•°
L = 1.0   # é ˜åŸŸã®é•·ã•
T_final = 2.0  # çµ‚äº†æ™‚åˆ»

# ç©ºé–“é›¢æ•£åŒ–
Nx = 100
x = np.linspace(0, L, Nx)
dx = x[1] - x[0]

# åˆæœŸæ¡ä»¶: ã‚¹ãƒ†ãƒƒãƒ—é–¢æ•°
def initial_condition_fisher(x):
    u0 = np.zeros_like(x)
    u0[x < 0.2] = 1.0
    return u0

u0 = initial_condition_fisher(x)

# å³è¾ºé–¢æ•°ï¼ˆåŠé›¢æ•£åŒ–å¾Œã®ODEç³»ï¼‰
def rhs_fisher_kpp(u, t, D, k, dx):
    """Fisher-KPPæ–¹ç¨‹å¼ã®å³è¾º"""
    dudt = np.zeros_like(u)
    
    # å†…éƒ¨ç‚¹: æ‹¡æ•£ + åå¿œ
    for i in range(1, len(u)-1):
        diffusion = D * (u[i+1] - 2*u[i] + u[i-1]) / dx**2
        reaction = k * u[i] * (1 - u[i])
        dudt[i] = diffusion + reaction
    
    # å¢ƒç•Œæ¡ä»¶: ãƒã‚¤ãƒãƒ³æ¡ä»¶ï¼ˆå‹¾é…ã‚¼ãƒ­ï¼‰
    dudt[0] = dudt[1]
    dudt[-1] = dudt[-2]
    
    return dudt

# æ™‚é–“ç©åˆ†
t = np.linspace(0, T_final, 200)
solution = odeint(rhs_fisher_kpp, u0, t, args=(D, k, dx))

# å¯è¦–åŒ–
fig, axes = plt.subplots(1, 2, figsize=(14, 5))

# æ™‚ç©ºé–“ãƒ—ãƒ­ãƒƒãƒˆ
ax1 = axes[0]
X, T = np.meshgrid(x, t)
contour = ax1.contourf(X, T, solution, levels=20, cmap='viridis')
ax1.set_xlabel('x (ç©ºé–“)')
ax1.set_ylabel('t (æ™‚é–“)')
ax1.set_title('Fisher-KPPæ–¹ç¨‹å¼ã®è§£ï¼ˆæ™‚ç©ºé–“å›³ï¼‰')
plt.colorbar(contour, ax=ax1, label='u(x,t)')

# æ™‚é–“ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆ
ax2 = axes[1]
time_snapshots = [0, 0.5, 1.0, 1.5, 2.0]
colors = plt.cm.viridis(np.linspace(0, 1, len(time_snapshots)))

for t_snap, color in zip(time_snapshots, colors):
    idx = np.argmin(np.abs(t - t_snap))
    ax2.plot(x, solution[idx], label=f't = {t_snap:.1f} s', linewidth=2, color=color)

ax2.set_xlabel('x')
ax2.set_ylabel('u(x, t)')
ax2.set_title('æ™‚é–“ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆ')
ax2.legend()
ax2.grid(True, alpha=0.3)

plt.tight_layout()
plt.savefig('fem_fisher_kpp.png', dpi=300, bbox_inches='tight')
plt.show()

# é€²è¡Œæ³¢ã®é€Ÿåº¦ã‚’æ¨å®šï¼ˆu=0.5ã®ä½ç½®ã‚’è¿½è·¡ï¼‰
def find_wave_position(solution, x, threshold=0.5):
    """æ³¢é¢ã®ä½ç½®ã‚’å„æ™‚åˆ»ã§æ±‚ã‚ã‚‹"""
    positions = []
    for u_t in solution:
        # u = threshold ã¨ãªã‚‹ä½ç½®ã‚’ç·šå½¢è£œé–“ã§æ±‚ã‚ã‚‹
        idx = np.where(np.diff(u_t > threshold))[0]
        if len(idx) > 0:
            i = idx[0]
            # ç·šå½¢è£œé–“
            x_wave = x[i] + (threshold - u_t[i]) * (x[i+1] - x[i]) / (u_t[i+1] - u_t[i])
            positions.append(x_wave)
        else:
            positions.append(np.nan)
    return np.array(positions)

wave_positions = find_wave_position(solution, x)
valid_indices = ~np.isnan(wave_positions)
t_valid = t[valid_indices]
pos_valid = wave_positions[valid_indices]

# é€Ÿåº¦ã®æ¨å®šï¼ˆç·šå½¢å›å¸°ï¼‰
if len(t_valid) > 1:
    wave_speed = np.polyfit(t_valid, pos_valid, 1)[0]
    theoretical_speed = 2 * np.sqrt(D * k)
    
    print("=== Fisher-KPPæ–¹ç¨‹å¼ ===")
    print(f"æ‹¡æ•£ä¿‚æ•° D = {D}")
    print(f"åå¿œé€Ÿåº¦ k = {k}")
    print(f"æ¨å®šé€²è¡Œæ³¢é€Ÿåº¦: {wave_speed:.4f} m/s")
    print(f"ç†è«–é€²è¡Œæ³¢é€Ÿåº¦: {theoretical_speed:.4f} m/s")
    print(f"ç›¸å¯¾èª¤å·®: {abs(wave_speed - theoretical_speed) / theoretical_speed * 100:.2f}%")
</div>
        </div>

        <div class="content">
            <h2>ğŸ’» ä¾‹é¡Œ5.5: éç·šå½¢å•é¡Œï¼ˆNewton-Raphsonæ³•ï¼‰</h2>
            
            <div class="code-title">Pythonå®Ÿè£…: éç·šå½¢ãƒã‚¢ã‚½ãƒ³æ–¹ç¨‹å¼</div>
            <div class="code-example">import numpy as np
import matplotlib.pyplot as plt
from scipy.sparse import lil_matrix, diags
from scipy.sparse.linalg import spsolve

# éç·šå½¢ãƒã‚¢ã‚½ãƒ³æ–¹ç¨‹å¼: -âˆ‡Â²u + uÂ³ = f
# Newton-Raphsonæ³•ã§åå¾©çš„ã«è§£ã

def nonlinear_poisson_residual(u, K, M, F):
    """æ®‹å·®ãƒ™ã‚¯ãƒˆãƒ«: R(u) = K*u + M*(uÂ³) - F"""
    return K @ u + M @ (u**3) - F

def nonlinear_poisson_jacobian(u, K, M):
    """ãƒ¤ã‚³ãƒ“è¡Œåˆ—: J(u) = K + M*diag(3uÂ²)"""
    J = K.copy()
    # å¯¾è§’æˆåˆ†ã« 3uÂ² ã‚’åŠ ç®—
    diag_3u2 = 3 * u**2
    J += M.multiply(diags(diag_3u2, format='csr'))
    return J

def newton_raphson_solve(u0, K, M, F, boundary_nodes, max_iter=20, tol=1e-6):
    """Newton-Raphsonæ³•ã§éç·šå½¢ã‚·ã‚¹ãƒ†ãƒ ã‚’è§£ã"""
    u = u0.copy()
    residual_history = []
    
    for iteration in range(max_iter):
        # æ®‹å·®ã¨ãƒ¤ã‚³ãƒ“è¡Œåˆ—
        R = nonlinear_poisson_residual(u, K, M, F)
        J = nonlinear_poisson_jacobian(u, K, M)
        
        # å¢ƒç•Œæ¡ä»¶ã®é©ç”¨ï¼ˆæ®‹å·®ã¨ä¿®æ­£ã‚’ã‚¼ãƒ­ã«ï¼‰
        R[boundary_nodes] = 0
        for node in boundary_nodes:
            J[node, :] = 0
            J[:, node] = 0
            J[node, node] = 1
        
        # Newtonä¿®æ­£ã‚’è§£ã: J * delta_u = -R
        delta_u = spsolve(J, -R)
        
        # è§£ã®æ›´æ–°
        u += delta_u
        
        # åæŸåˆ¤å®š
        residual_norm = np.linalg.norm(R) / np.linalg.norm(F)
        residual_history.append(residual_norm)
        
        print(f"åå¾© {iteration+1}: æ®‹å·®ãƒãƒ«ãƒ  = {residual_norm:.6e}")
        
        if residual_norm < tol:
            print(f"åæŸ: {iteration+1} åå¾©")
            break
    
    return u, residual_history

# ãƒ¡ãƒƒã‚·ãƒ¥ç”Ÿæˆ
Nx, Ny = 20, 20
points, tri = generate_mesh_2d(1.0, 1.0, Nx, Ny)

# å³è¾ºé–¢æ•°: f(x,y) = 10 * sin(2Ï€x) * sin(2Ï€y)
def source_nonlinear(x, y):
    return 10 * np.sin(2 * np.pi * x) * np.sin(2 * np.pi * y)

# ç·šå½¢é …ã®å‰›æ€§è¡Œåˆ—ã¨è³ªé‡è¡Œåˆ—
K, _ = assemble_global_system(points, tri, lambda x, y: 0)  # f=0ã§å‰›æ€§è¡Œåˆ—ã®ã¿
M = lil_matrix((len(points), len(points)))

# è³ªé‡è¡Œåˆ—ã®çµ„ã¿ç«‹ã¦ï¼ˆuÂ³é …ç”¨ï¼‰
for elem in tri.simplices:
    nodes = points[elem]
    _, A_elem = compute_element_stiffness(nodes)
    
    # é›†ä¸­è³ªé‡è¡Œåˆ—ï¼ˆlumped mass matrixï¼‰
    for i in range(3):
        M[elem[i], elem[i]] += A_elem / 3

M = M.tocsr()

# è·é‡ãƒ™ã‚¯ãƒˆãƒ«
F = np.array([source_nonlinear(x, y) for x, y in points])

# å¢ƒç•Œæ¡ä»¶
K_bc, F_bc, boundary_nodes = apply_boundary_conditions(K.copy(), F.copy(), points)

# åˆæœŸæ¨æ¸¬ï¼ˆç·šå½¢å•é¡Œã®è§£ï¼‰
u0 = spsolve(K_bc, F_bc)

# Newton-Raphsonæ³•ã§è§£ã
u_nonlinear, residual_history = newton_raphson_solve(u0, K, M, F, boundary_nodes)

# å¯è¦–åŒ–
fig, axes = plt.subplots(1, 3, figsize=(16, 5))

# ç·šå½¢è§£ï¼ˆåˆæœŸæ¨æ¸¬ï¼‰
ax1 = axes[0]
contour1 = ax1.tricontourf(points[:, 0], points[:, 1], u0, levels=20, cmap='viridis')
ax1.tricontour(points[:, 0], points[:, 1], u0, levels=10, colors='white', 
               linewidths=0.5, alpha=0.5)
ax1.set_xlabel('x')
ax1.set_ylabel('y')
ax1.set_title('ç·šå½¢è§£ï¼ˆåˆæœŸæ¨æ¸¬ï¼‰')
ax1.axis('equal')
plt.colorbar(contour1, ax=ax1)

# éç·šå½¢è§£
ax2 = axes[1]
contour2 = ax2.tricontourf(points[:, 0], points[:, 1], u_nonlinear, levels=20, cmap='viridis')
ax2.tricontour(points[:, 0], points[:, 1], u_nonlinear, levels=10, colors='white', 
               linewidths=0.5, alpha=0.5)
ax2.set_xlabel('x')
ax2.set_ylabel('y')
ax2.set_title('éç·šå½¢è§£ï¼ˆNewton-Raphsonï¼‰')
ax2.axis('equal')
plt.colorbar(contour2, ax=ax2)

# åæŸå±¥æ­´
ax3 = axes[2]
ax3.semilogy(range(1, len(residual_history)+1), residual_history, 'bo-', linewidth=2, markersize=8)
ax3.set_xlabel('Iteration')
ax3.set_ylabel('Residual norm (relative)')
ax3.set_title('Newton-RaphsonåæŸå±¥æ­´')
ax3.grid(True, alpha=0.3)

plt.tight_layout()
plt.savefig('fem_nonlinear_newton.png', dpi=300, bbox_inches='tight')
plt.show()

print("\n=== éç·šå½¢ãƒã‚¢ã‚½ãƒ³æ–¹ç¨‹å¼ ===")
print(f"ç¯€ç‚¹æ•°: {len(points)}")
print(f"åæŸåå¾©æ•°: {len(residual_history)}")
print(f"ç·šå½¢è§£ã®æœ€å¤§å€¤: {np.max(np.abs(u0)):.6f}")
print(f"éç·šå½¢è§£ã®æœ€å¤§å€¤: {np.max(np.abs(u_nonlinear)):.6f}")
</div>
        </div>

        <div class="content">
            <h2>ğŸ’» ä¾‹é¡Œ5.6: ã‚¹ãƒ‘ãƒ¼ã‚¹è¡Œåˆ—ã®åŠ¹ç‡çš„æ‰±ã„</h2>
            
            <div class="code-title">Pythonå®Ÿè£…: ã‚¹ãƒ‘ãƒ¼ã‚¹è¡Œåˆ—ã®æ€§èƒ½æ¯”è¼ƒ</div>
            <div class="code-example">import numpy as np
import matplotlib.pyplot as plt
from scipy.sparse import lil_matrix, csr_matrix, coo_matrix, diags
from scipy.sparse.linalg import spsolve
import time

# å¤§è¦æ¨¡ã‚¹ãƒ‘ãƒ¼ã‚¹ç·šå½¢ã‚·ã‚¹ãƒ†ãƒ ã®æ€§èƒ½æ¯”è¼ƒ

def create_sparse_system(N):
    """NÃ—N ã®ä¸‰é‡å¯¾è§’è¡Œåˆ—ã‚’ç”Ÿæˆï¼ˆãƒ©ãƒ—ãƒ©ã‚·ã‚¢ãƒ³ï¼‰"""
    main_diag = 2 * np.ones(N)
    off_diag = -np.ones(N-1)
    K = diags([off_diag, main_diag, off_diag], [-1, 0, 1], format='csr')
    F = np.ones(N)
    return K, F

# ç•°ãªã‚‹ã‚µã‚¤ã‚ºã§ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯
sizes = [100, 500, 1000, 2000, 5000]
times_lil = []
times_csr = []
times_dense = []
memory_sparse = []
memory_dense = []

print("=== ã‚¹ãƒ‘ãƒ¼ã‚¹è¡Œåˆ—ã®æ€§èƒ½ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯ ===\n")

for N in sizes:
    print(f"ã‚µã‚¤ã‚º N = {N}")
    
    K, F = create_sparse_system(N)
    
    # LILå½¢å¼ï¼ˆæ§‹ç¯‰ï¼‰
    start = time.time()
    K_lil = lil_matrix(K)
    time_lil = time.time() - start
    times_lil.append(time_lil)
    
    # CSRå½¢å¼ï¼ˆæ¼”ç®—ï¼‰
    start = time.time()
    K_csr = csr_matrix(K)
    u_sparse = spsolve(K_csr, F)
    time_csr = time.time() - start
    times_csr.append(time_csr)
    
    # å¯†è¡Œåˆ—ï¼ˆæ¯”è¼ƒç”¨ã€Nâ‰¤2000ã¾ã§ï¼‰
    if N <= 2000:
        start = time.time()
        K_dense = K.toarray()
        u_dense = np.linalg.solve(K_dense, F)
        time_dense = time.time() - start
        times_dense.append(time_dense)
    else:
        times_dense.append(np.nan)
    
    # ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡
    nnz = K.nnz  # éã‚¼ãƒ­è¦ç´ æ•°
    memory_sparse.append(nnz * 8 / 1024)  # KBï¼ˆfloat64 = 8 bytesï¼‰
    memory_dense.append(N * N * 8 / 1024)  # KB
    
    print(f"  CSRè§£æ³•: {time_csr:.6f} s")
    print(f"  å¯†è¡Œåˆ—è§£æ³•: {time_dense[-1] if not np.isnan(time_dense[-1]) else 'N/A':.6f} s" if N <= 2000 else "  å¯†è¡Œåˆ—è§£æ³•: ã‚¹ã‚­ãƒƒãƒ—ï¼ˆå¤§ãã™ãã‚‹ï¼‰")
    print(f"  ã‚¹ãƒ‘ãƒ¼ã‚¹æ€§: {nnz / (N*N) * 100:.2f}%")
    print()

# å¯è¦–åŒ–
fig, axes = plt.subplots(1, 3, figsize=(16, 5))

# è¨ˆç®—æ™‚é–“ã®æ¯”è¼ƒ
ax1 = axes[0]
ax1.loglog(sizes, times_csr, 'b-o', label='CSR (ã‚¹ãƒ‘ãƒ¼ã‚¹)', linewidth=2, markersize=8)
valid_dense = ~np.isnan(times_dense)
ax1.loglog(np.array(sizes)[valid_dense], np.array(times_dense)[valid_dense], 
           'r-s', label='Dense (å¯†è¡Œåˆ—)', linewidth=2, markersize=8)
ax1.set_xlabel('System size N')
ax1.set_ylabel('Computation time (s)')
ax1.set_title('è¨ˆç®—æ™‚é–“ã®æ¯”è¼ƒ')
ax1.legend()
ax1.grid(True, alpha=0.3, which='both')

# ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ã®æ¯”è¼ƒ
ax2 = axes[1]
ax2.loglog(sizes, memory_sparse, 'b-o', label='Sparse', linewidth=2, markersize=8)
ax2.loglog(sizes, memory_dense, 'r-s', label='Dense', linewidth=2, markersize=8)
ax2.set_xlabel('System size N')
ax2.set_ylabel('Memory usage (KB)')
ax2.set_title('ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ã®æ¯”è¼ƒ')
ax2.legend()
ax2.grid(True, alpha=0.3, which='both')

# é«˜é€ŸåŒ–ç‡
ax3 = axes[2]
speedup = np.array(times_dense) / np.array(times_csr)
valid_speedup = ~np.isnan(speedup)
ax3.semilogy(np.array(sizes)[valid_speedup], speedup[valid_speedup], 
             'go-', linewidth=2, markersize=8)
ax3.set_xlabel('System size N')
ax3.set_ylabel('Speedup (Dense / Sparse)')
ax3.set_title('ã‚¹ãƒ‘ãƒ¼ã‚¹è¡Œåˆ—ã«ã‚ˆã‚‹é«˜é€ŸåŒ–ç‡')
ax3.grid(True, alpha=0.3, which='both')

plt.tight_layout()
plt.savefig('fem_sparse_performance.png', dpi=300, bbox_inches='tight')
plt.show()

print("=== ã¾ã¨ã‚ ===")
print(f"æœ€å¤§ã‚µã‚¤ã‚º N={sizes[-1]} ã§ã®æ€§èƒ½:")
print(f"  ã‚¹ãƒ‘ãƒ¼ã‚¹è§£æ³•: {times_csr[-1]:.4f} s")
print(f"  ãƒ¡ãƒ¢ãƒªå‰Šæ¸›ç‡: {(1 - memory_sparse[-1]/memory_dense[-1]) * 100:.2f}%")
</div>
        </div>

        <div class="content">
            <h2>ğŸ’» ä¾‹é¡Œ5.7: ãƒ—ãƒ­ã‚»ã‚¹ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ - ç†±å‡¦ç†éç¨‹</h2>
            
            <div class="code-title">Pythonå®Ÿè£…: é‹¼æã®ç„¼å…¥ã‚Œã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³</div>
            <div class="code-example">import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import odeint

# é‹¼æã®ç„¼å…¥ã‚Œéç¨‹ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
# 1æ¬¡å…ƒç†±ä¼å° + ç›¸å¤‰æ…‹ï¼ˆãƒãƒ«ãƒ†ãƒ³ã‚µã‚¤ãƒˆå¤‰æ…‹ï¼‰

# ææ–™ç‰©æ€§å€¤
rho = 7850  # å¯†åº¦ (kg/mÂ³)
c_p = 460   # æ¯”ç†± (J/(kgÂ·K))
k = 50      # ç†±ä¼å°ç‡ (W/(mÂ·K))
alpha = k / (rho * c_p)  # ç†±æ‹¡æ•£ä¿‚æ•°

# ç„¼å…¥ã‚Œæ¡ä»¶
T_initial = 900  # åˆæœŸæ¸©åº¦ï¼ˆã‚ªãƒ¼ã‚¹ãƒ†ãƒŠã‚¤ãƒˆåŒ–æ¸©åº¦ï¼‰(Â°C)
T_coolant = 20   # å†·å´æ¶²æ¸©åº¦ (Â°C)
h = 5000    # å¯¾æµç†±ä¼é”ä¿‚æ•° (W/(mÂ²Â·K))
L = 0.05    # è©¦é¨“ç‰‡ã®åšã•ï¼ˆåŠåˆ†ã€å¯¾ç§°æ€§ã‚ˆã‚Šï¼‰(m)

# ãƒãƒ«ãƒ†ãƒ³ã‚µã‚¤ãƒˆå¤‰æ…‹æ¸©åº¦
M_s = 350   # ãƒãƒ«ãƒ†ãƒ³ã‚µã‚¤ãƒˆå¤‰æ…‹é–‹å§‹æ¸©åº¦ (Â°C)
M_f = 200   # ãƒãƒ«ãƒ†ãƒ³ã‚µã‚¤ãƒˆå¤‰æ…‹çµ‚äº†æ¸©åº¦ (Â°C)

def quenching_rhs(u, t, alpha, dx, h, k, T_coolant, M_s, M_f):
    """ç„¼å…¥ã‚Œéç¨‹ã®å³è¾ºï¼ˆç†±ä¼å° + å¯¾æµå¢ƒç•Œæ¡ä»¶ + ç›¸å¤‰æ…‹æ½œç†±ï¼‰"""
    dudt = np.zeros_like(u)
    
    # å†…éƒ¨ç‚¹: æ‹¡æ•£
    for i in range(1, len(u)-1):
        dudt[i] = alpha * (u[i+1] - 2*u[i] + u[i-1]) / dx**2
    
    # å·¦ç«¯: å¯¾ç§°å¢ƒç•Œæ¡ä»¶ï¼ˆæ–­ç†±ï¼‰
    dudt[0] = alpha * (2*u[1] - 2*u[0]) / dx**2
    
    # å³ç«¯: å¯¾æµå¢ƒç•Œæ¡ä»¶
    dudt[-1] = alpha * (2*u[-2] - 2*u[-1]) / dx**2 + \
               (2 * h / (rho * c_p * dx)) * (T_coolant - u[-1])
    
    # ç›¸å¤‰æ…‹æ½œç†±ã®åŠ¹æœï¼ˆç°¡æ˜“ãƒ¢ãƒ‡ãƒ«ï¼‰
    for i in range(len(u)):
        if M_f < u[i] < M_s:
            # å¤‰æ…‹é€²è¡Œåº¦ã«å¿œã˜ãŸç™ºç†±ï¼ˆKoistinen-Marburgerå¼ã®ç°¡ç•¥ç‰ˆï¼‰
            transformation_rate = 0.01 * (M_s - u[i]) / (M_s - M_f)
            latent_heat = 200000  # æ½œç†± (J/kg)
            dudt[i] += transformation_rate * latent_heat / (rho * c_p)
    
    return dudt

# ç©ºé–“é›¢æ•£åŒ–
Nx = 50
x = np.linspace(0, L, Nx)
dx = x[1] - x[0]

# åˆæœŸæ¡ä»¶
u0 = np.full(Nx, T_initial)

# æ™‚é–“ç©åˆ†
t_end = 60  # ç„¼å…¥ã‚Œæ™‚é–“ (s)
t = np.linspace(0, t_end, 500)
solution = odeint(quenching_rhs, u0, t, args=(alpha, dx, h, k, T_coolant, M_s, M_f))

# ãƒãƒ«ãƒ†ãƒ³ã‚µã‚¤ãƒˆåˆ†ç‡ã®è¨ˆç®—ï¼ˆKoistinen-Marburgerå¼ï¼‰
def martensite_fraction(T):
    """ãƒãƒ«ãƒ†ãƒ³ã‚µã‚¤ãƒˆåˆ†ç‡"""
    f_M = np.zeros_like(T)
    mask = T < M_s
    f_M[mask] = 1 - np.exp(-0.011 * (M_s - T[mask]))
    f_M[T < M_f] = 1.0
    return f_M

martensite_final = martensite_fraction(solution[-1, :])

# å¯è¦–åŒ–
fig, axes = plt.subplots(2, 2, figsize=(14, 10))

# æ™‚ç©ºé–“æ¸©åº¦åˆ†å¸ƒ
ax1 = axes[0, 0]
X, T_grid = np.meshgrid(x * 1000, t)  # mmå˜ä½
contour = ax1.contourf(X, T_grid, solution, levels=20, cmap='hot')
ax1.contour(X, T_grid, solution, levels=[M_s, M_f], colors='cyan', linewidths=2, 
            linestyles=['--', ':'])
ax1.set_xlabel('Distance from center (mm)')
ax1.set_ylabel('Time (s)')
ax1.set_title('æ¸©åº¦åˆ†å¸ƒã®æ™‚é–“ç™ºå±•')
plt.colorbar(contour, ax=ax1, label='Temperature (Â°C)')

# è¡¨é¢ã¨ä¸­å¿ƒã®æ¸©åº¦å±¥æ­´
ax2 = axes[0, 1]
ax2.plot(t, solution[:, 0], 'b-', label='ä¸­å¿ƒ', linewidth=2)
ax2.plot(t, solution[:, -1], 'r-', label='è¡¨é¢', linewidth=2)
ax2.axhline(M_s, color='cyan', linestyle='--', linewidth=1.5, label=f'M_s = {M_s}Â°C')
ax2.axhline(M_f, color='cyan', linestyle=':', linewidth=1.5, label=f'M_f = {M_f}Â°C')
ax2.set_xlabel('Time (s)')
ax2.set_ylabel('Temperature (Â°C)')
ax2.set_title('æ¸©åº¦å±¥æ­´')
ax2.legend()
ax2.grid(True, alpha=0.3)

# æœ€çµ‚æ¸©åº¦åˆ†å¸ƒ
ax3 = axes[1, 0]
ax3.plot(x * 1000, solution[-1, :], 'k-', linewidth=2)
ax3.axhline(M_s, color='cyan', linestyle='--', linewidth=1.5, label=f'M_s = {M_s}Â°C')
ax3.axhline(M_f, color='cyan', linestyle=':', linewidth=1.5, label=f'M_f = {M_f}Â°C')
ax3.fill_between(x * 1000, 0, solution[-1, :], alpha=0.3, color='red')
ax3.set_xlabel('Distance from center (mm)')
ax3.set_ylabel('Temperature (Â°C)')
ax3.set_title(f'æœ€çµ‚æ¸©åº¦åˆ†å¸ƒ (t = {t_end} s)')
ax3.legend()
ax3.grid(True, alpha=0.3)

# ãƒãƒ«ãƒ†ãƒ³ã‚µã‚¤ãƒˆåˆ†ç‡åˆ†å¸ƒ
ax4 = axes[1, 1]
ax4.plot(x * 1000, martensite_final * 100, 'b-', linewidth=2)
ax4.fill_between(x * 1000, 0, martensite_final * 100, alpha=0.3, color='blue')
ax4.set_xlabel('Distance from center (mm)')
ax4.set_ylabel('Martensite fraction (%)')
ax4.set_title('æœ€çµ‚ãƒãƒ«ãƒ†ãƒ³ã‚µã‚¤ãƒˆåˆ†ç‡')
ax4.grid(True, alpha=0.3)
ax4.set_ylim([0, 105])

plt.tight_layout()
plt.savefig('fem_quenching_simulation.png', dpi=300, bbox_inches='tight')
plt.show()

print("=== ç„¼å…¥ã‚Œã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ ===")
print(f"åˆæœŸæ¸©åº¦: {T_initial}Â°C")
print(f"å†·å´æ¶²æ¸©åº¦: {T_coolant}Â°C")
print(f"å¯¾æµç†±ä¼é”ä¿‚æ•°: {h} W/(mÂ²Â·K)")
print(f"è©¦é¨“ç‰‡åšã•: {L*2*1000:.1f} mm")
print(f"\nç„¼å…¥ã‚Œå¾Œï¼ˆt={t_end}sï¼‰:")
print(f"  ä¸­å¿ƒæ¸©åº¦: {solution[-1, 0]:.1f}Â°C")
print(f"  è¡¨é¢æ¸©åº¦: {solution[-1, -1]:.1f}Â°C")
print(f"  å¹³å‡ãƒãƒ«ãƒ†ãƒ³ã‚µã‚¤ãƒˆåˆ†ç‡: {np.mean(martensite_final)*100:.1f}%")
print(f"  è¡¨é¢ãƒãƒ«ãƒ†ãƒ³ã‚µã‚¤ãƒˆåˆ†ç‡: {martensite_final[-1]*100:.1f}%")
</div>
        </div>

        <div class="content">
            <h2>ğŸ’» ä¾‹é¡Œ5.8: é€£æˆå•é¡Œï¼ˆç†±-æ©Ÿæ¢°é€£æˆï¼‰</h2>
            
            <div class="code-title">Pythonå®Ÿè£…: ç†±å¿œåŠ›ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³</div>
            <div class="code-example">import numpy as np
import matplotlib.pyplot as plt

# ç†±-æ©Ÿæ¢°é€£æˆå•é¡Œ: æ¸©åº¦å¤‰åŒ–ã«ã‚ˆã‚‹ç†±å¿œåŠ›
# 1æ¬¡å…ƒå¼¾æ€§æ£’ãŒåŠ ç†±ã•ã‚ŒãŸã¨ãã®å¤‰ä½ã¨å¿œåŠ›

# ææ–™ç‰©æ€§å€¤ï¼ˆé‹¼ï¼‰
E = 200e9  # ãƒ¤ãƒ³ã‚°ç‡ (Pa)
alpha_thermal = 12e-6  # ç·šè†¨å¼µä¿‚æ•° (1/K)
L = 1.0  # æ£’ã®é•·ã• (m)
A = 0.01**2  # æ–­é¢ç© (mÂ²)

# æ¸©åº¦åˆ†å¸ƒï¼ˆç·šå½¢å‹¾é…ï¼‰
def temperature_distribution(x, T_left, T_right):
    """å·¦ç«¯ã‹ã‚‰å³ç«¯ã¸ã®ç·šå½¢æ¸©åº¦å‹¾é…"""
    return T_left + (T_right - T_left) * x / L

T_ref = 20  # å‚ç…§æ¸©åº¦ (Â°C)
T_left = 100  # å·¦ç«¯æ¸©åº¦ (Â°C)
T_right = 20  # å³ç«¯æ¸©åº¦ (Â°C)

# æœ‰é™è¦ç´ è§£æ
Nx = 50
x_nodes = np.linspace(0, L, Nx)
h = x_nodes[1] - x_nodes[0]

# æ¸©åº¦å ´
T = temperature_distribution(x_nodes, T_left, T_right)
delta_T = T - T_ref

# ç†±ã²ãšã¿: Îµ_th = Î± * Î”T
epsilon_thermal = alpha_thermal * delta_T

# å‰›æ€§è¡Œåˆ—
K = np.zeros((Nx, Nx))
for i in range(Nx-1):
    K_elem = (E * A / h) * np.array([[1, -1],
                                      [-1, 1]])
    K[i:i+2, i:i+2] += K_elem

# ç†±è·é‡ãƒ™ã‚¯ãƒˆãƒ«
F_thermal = np.zeros(Nx)
for i in range(Nx-1):
    # ç†±ã²ãšã¿ã«ã‚ˆã‚‹ç­‰ä¾¡ç¯€ç‚¹åŠ›
    epsilon_th_avg = (epsilon_thermal[i] + epsilon_thermal[i+1]) / 2
    F_elem = E * A * epsilon_th_avg * np.array([1, -1])
    F_thermal[i:i+2] += F_elem

# å¢ƒç•Œæ¡ä»¶: ä¸¡ç«¯å›ºå®š
K_reduced = K[1:-1, 1:-1]
F_reduced = F_thermal[1:-1]

# å¤‰ä½ã‚’è§£ã
u_interior = np.linalg.solve(K_reduced, F_reduced)
u = np.concatenate([[0], u_interior, [0]])

# å…¨ã²ãšã¿ã¨å¿œåŠ›
epsilon_total = np.diff(u) / h
epsilon_mechanical = epsilon_total - epsilon_thermal[:-1]  # å¹³å‡å€¤ã‚’ä½¿ç”¨
stress = E * epsilon_mechanical

# å¯è¦–åŒ–
fig, axes = plt.subplots(2, 2, figsize=(14, 10))

# æ¸©åº¦åˆ†å¸ƒ
ax1 = axes[0, 0]
ax1.plot(x_nodes * 1000, T, 'r-', linewidth=2)
ax1.fill_between(x_nodes * 1000, T_ref, T, alpha=0.3, color='red')
ax1.axhline(T_ref, color='k', linestyle='--', linewidth=1, label=f'å‚ç…§æ¸©åº¦ ({T_ref}Â°C)')
ax1.set_xlabel('Position (mm)')
ax1.set_ylabel('Temperature (Â°C)')
ax1.set_title('æ¸©åº¦åˆ†å¸ƒ')
ax1.legend()
ax1.grid(True, alpha=0.3)

# å¤‰ä½åˆ†å¸ƒ
ax2 = axes[0, 1]
ax2.plot(x_nodes * 1000, u * 1e6, 'b-', linewidth=2)
ax2.fill_between(x_nodes * 1000, 0, u * 1e6, alpha=0.3, color='blue')
ax2.set_xlabel('Position (mm)')
ax2.set_ylabel('Displacement (Î¼m)')
ax2.set_title('å¤‰ä½åˆ†å¸ƒï¼ˆä¸¡ç«¯å›ºå®šï¼‰')
ax2.grid(True, alpha=0.3)

# ã²ãšã¿æˆåˆ†
ax3 = axes[1, 0]
x_strain = (x_nodes[:-1] + x_nodes[1:]) / 2 * 1000
ax3.plot(x_strain, epsilon_thermal[:-1] * 1e6, 'r--', label='ç†±ã²ãšã¿', linewidth=2)
ax3.plot(x_strain, epsilon_mechanical * 1e6, 'b:', label='æ©Ÿæ¢°ã²ãšã¿', linewidth=2)
ax3.plot(x_strain, epsilon_total * 1e6, 'k-', label='å…¨ã²ãšã¿', linewidth=2)
ax3.set_xlabel('Position (mm)')
ax3.set_ylabel('Strain (Î¼Îµ)')
ax3.set_title('ã²ãšã¿æˆåˆ†')
ax3.legend()
ax3.grid(True, alpha=0.3)
ax3.axhline(0, color='k', linestyle='-', linewidth=0.5)

# å¿œåŠ›åˆ†å¸ƒ
ax4 = axes[1, 1]
ax4.plot(x_strain, stress / 1e6, 'k-', linewidth=2)
ax4.fill_between(x_strain, 0, stress / 1e6, alpha=0.3, 
                  where=(stress > 0), color='red', label='å¼•å¼µ')
ax4.fill_between(x_strain, 0, stress / 1e6, alpha=0.3, 
                  where=(stress < 0), color='blue', label='åœ§ç¸®')
ax4.set_xlabel('Position (mm)')
ax4.set_ylabel('Stress (MPa)')
ax4.set_title('ç†±å¿œåŠ›åˆ†å¸ƒ')
ax4.legend()
ax4.grid(True, alpha=0.3)
ax4.axhline(0, color='k', linestyle='-', linewidth=0.5)

plt.tight_layout()
plt.savefig('fem_thermal_stress.png', dpi=300, bbox_inches='tight')
plt.show()

print("=== ç†±å¿œåŠ›è§£æ ===")
print(f"ææ–™: é‹¼")
print(f"ãƒ¤ãƒ³ã‚°ç‡: {E/1e9:.0f} GPa")
print(f"ç·šè†¨å¼µä¿‚æ•°: {alpha_thermal*1e6:.1f} Î¼Îµ/K")
print(f"æ¸©åº¦ç¯„å›²: {T_left}Â°C â†’ {T_right}Â°C")
print(f"\nçµæœ:")
print(f"  æœ€å¤§å¤‰ä½: {np.max(np.abs(u))*1e6:.2f} Î¼m")
print(f"  æœ€å¤§å¼•å¼µå¿œåŠ›: {np.max(stress)/1e6:.2f} MPa")
print(f"  æœ€å¤§åœ§ç¸®å¿œåŠ›: {np.min(stress)/1e6:.2f} MPa")
print(f"  æœ€å¤§ç†±ã²ãšã¿: {np.max(epsilon_thermal)*1e6:.2f} Î¼Îµ")
</div>
        </div>

        <div class="content">
            <h2>ğŸ“š ã¾ã¨ã‚</h2>
            <ul>
                <li><strong>æœ‰é™å·®åˆ†æ³•</strong>ã¯å®Ÿè£…ãŒå®¹æ˜“ã ãŒã€è¤‡é›‘å½¢çŠ¶ã¸ã®é©ç”¨ãŒå›°é›£ã€‚FTCS, BTCS, Crank-Nicolsonã®ç‰¹æ€§ã‚’ç†è§£ã™ã‚‹ã“ã¨ãŒé‡è¦</li>
                <li><strong>æœ‰é™è¦ç´ æ³•</strong>ã¯å¤‰åˆ†åŸç†ã«åŸºã¥ãã€éæ§‹é€ æ ¼å­ã§è¤‡é›‘å½¢çŠ¶ã«å¯¾å¿œã€‚ç·šå½¢ä¸‰è§’å½¢è¦ç´ ãŒåŸºæœ¬</li>
                <li><strong>å®‰å®šæ€§ã¨åæŸæ€§</strong>ã¯æ•°å€¤è§£æ³•ã®ä¿¡é ¼æ€§ã‚’ä¿è¨¼ã™ã‚‹åŸºæœ¬æ¦‚å¿µã€‚CFLæ¡ä»¶ã‚„Laxã®ç­‰ä¾¡å®šç†ãŒé‡è¦</li>
                <li><strong>é©å¿œçš„ãƒ¡ãƒƒã‚·ãƒ¥ç´°åˆ†åŒ–</strong>ã«ã‚ˆã‚Šã€åŠ¹ç‡çš„ã«é«˜ç²¾åº¦è§£ãŒå¾—ã‚‰ã‚Œã‚‹</li>
                <li><strong>æ™‚é–“ä¾å­˜å•é¡Œ</strong>ã¯åŠé›¢æ•£åŒ–å¾Œã€é™½è§£æ³•ã¾ãŸã¯é™°è§£æ³•ã§æ™‚é–“ç©åˆ†ã™ã‚‹</li>
                <li><strong>éç·šå½¢å•é¡Œ</strong>ã¯Newton-Raphsonæ³•ãªã©ã®åå¾©æ³•ã§è§£ã</li>
                <li><strong>ã‚¹ãƒ‘ãƒ¼ã‚¹è¡Œåˆ—</strong>ã®åŠ¹ç‡çš„ãªæ‰±ã„ãŒå¤§è¦æ¨¡å•é¡Œã®éµ</li>
                <li>ãƒ—ãƒ­ã‚»ã‚¹ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆç„¼å…¥ã‚Œã€ç†±å¿œåŠ›ï¼‰ãªã©ã€ææ–™ç§‘å­¦ã¸ã®å®Ÿç”¨çš„å¿œç”¨ãŒè±Šå¯Œ</li>
            </ul>
        </div>

        <div class="exercise">
            <h3>ğŸ’¡ æ¼”ç¿’å•é¡Œ</h3>
            <ol>
                <li><strong>å®‰å®šæ€§è§£æ</strong>: FTCSæ³•ã§ç†±æ–¹ç¨‹å¼ã‚’è§£ãéš›ã€\(r > 0.5\) ã¨ã—ãŸå ´åˆã®ä¸å®‰å®šæ€§ã‚’æ•°å€¤çš„ã«ç¢ºèªã›ã‚ˆã€‚</li>
                <li><strong>2æ¬¡è¦ç´ FEM</strong>: ç·šå½¢ä¸‰è§’å½¢è¦ç´ ã‚’2æ¬¡è¦ç´ ã«æ‹¡å¼µã—ã€ç²¾åº¦å‘ä¸Šã‚’æ¤œè¨¼ã›ã‚ˆã€‚</li>
                <li><strong>3æ¬¡å…ƒå•é¡Œ</strong>: 2æ¬¡å…ƒFEMã‚’3æ¬¡å…ƒã«æ‹¡å¼µã—ã€å››é¢ä½“è¦ç´ ã§ãƒã‚¢ã‚½ãƒ³æ–¹ç¨‹å¼ã‚’è§£ã‘ã€‚</li>
                <li><strong>åå¿œæ‹¡æ•£ç³»</strong>: Gray-Scottåå¿œæ‹¡æ•£ç³»ã‚’2æ¬¡å…ƒã§è§£ãã€ãƒ‘ã‚¿ãƒ¼ãƒ³å½¢æˆã‚’è¦³å¯Ÿã›ã‚ˆã€‚</li>
                <li><strong>é€£æˆå•é¡Œ</strong>: ç†±-æ©Ÿæ¢°é€£æˆã«å‹•çš„åŠ¹æœã‚’åŠ ãˆã€ç†±è¡æ’ƒå•é¡Œã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã›ã‚ˆã€‚</li>
            </ol>
        </div>

        <div class="navigation">
            <a href="chapter-4.html" class="nav-button">â† ç¬¬4ç« : å¤‰åˆ†æ³•ã¨æœ€é©åŒ–</a>
            <a href="index.html" class="nav-button">ã‚·ãƒªãƒ¼ã‚ºTOPã¸</a>
        </div>
    </div>

    <footer>
        <p>&copy; 2025 AI Terakoya - Fundamentals of Mathematics & Physics Dojo</p>
    </footer>
</body>
</html>
