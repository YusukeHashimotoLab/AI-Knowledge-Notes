<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç¬¬3ç« : Laurentå±•é–‹ã¨ç•™æ•°å®šç† | è¤‡ç´ é–¢æ•°è«–ã¨ç‰¹æ®Šé–¢æ•° - FMé“å ´</title>
    <link rel="stylesheet" href="../../../assets/css/style.css">
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>MathJax = {tex: {inlineMath: [['$', '$'], ['\\(', '\\)']], displayMath: [['$$', '$$'], ['\\[', '\\]']]}};</script>
</head>
<body>
    <header class="site-header">
        <div class="container">
            <div class="header-content">
                <div class="site-logo"><a href="../../../index.html">ğŸ›ï¸ AIå¯ºå­å±‹</a></div>
                <nav class="main-nav">
                    <a href="../../../index.html">ãƒ›ãƒ¼ãƒ </a>
                    <a href="../../index.html">çŸ¥è­˜ãƒ™ãƒ¼ã‚¹</a>
                    <a href="../index.html" class="active">FMé“å ´</a>
                </nav>
            </div>
        </div>
    </header>

    <main class="chapter-page">
        <div class="container">
            <nav class="breadcrumb">
                <a href="../../../index.html">ãƒ›ãƒ¼ãƒ </a> &gt;
                <a href="../index.html">FMé“å ´</a> &gt;
                <a href="index.html">è¤‡ç´ é–¢æ•°è«–ã¨ç‰¹æ®Šé–¢æ•°</a> &gt;
                <span>ç¬¬3ç« </span>
            </nav>

            <article class="chapter-content">
                <div class="chapter-header">
                    <span class="chapter-label">ç¬¬3ç« </span>
                    <h1>Laurentå±•é–‹ã¨ç•™æ•°å®šç†</h1>
                    <p class="chapter-subtitle">Laurent Series and Residue Theorem</p>
                    <div class="chapter-meta">
                        <span class="meta-item">â±ï¸ 24-28åˆ†</span>
                        <span class="meta-item">ğŸ’» 9ã‚³ãƒ¼ãƒ‰ä¾‹</span>
                        <span class="meta-item">ğŸ“Š ä¸­ç´š</span>
                    </div>
                </div>

                <section class="chapter-section">
                    <h2>3.1 Taylorç´šæ•°ã¨Maclaurinå±•é–‹</h2>
                    <p>
                        æ­£å‰‡é–¢æ•°ã¯åæŸå††å†…ã§Taylorç´šæ•°ã«å±•é–‹ã§ãã¾ã™ã€‚
                    </p>

                    <div class="theory-box">
                        <h4>ğŸ“ ç†è«–</h4>
                        <p><strong>Taylorç´šæ•°å±•é–‹:</strong></p>
                        $$f(z) = \sum_{n=0}^{\infty} \frac{f^{(n)}(z_0)}{n!} (z - z_0)^n$$
                        <p><strong>Maclaurinå±•é–‹ ($z_0 = 0$):</strong></p>
                        $$f(z) = \sum_{n=0}^{\infty} \frac{f^{(n)}(0)}{n!} z^n$$
                    </div>

                    <div class="code-example">
                        <h4>ğŸ’» ã‚³ãƒ¼ãƒ‰ä¾‹ 1: Taylorç´šæ•°å±•é–‹ã®è¨ˆç®—</h4>
                        <pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
from scipy.special import factorial
import sympy as sp

# SymPyã§è¨˜å·è¨ˆç®—
z = sp.Symbol('z')
z0 = sp.Symbol('z0')

# é–¢æ•°ã®å®šç¾©
functions_sym = {
    'e^z': sp.exp(z),
    'sin(z)': sp.sin(z),
    'cos(z)': sp.cos(z),
    '1/(1-z)': 1/(1-z),
}

print("=== Taylorç´šæ•°å±•é–‹ (Maclaurinå±•é–‹, z0=0) ===\n")

for name, f_sym in functions_sym.items():
    print(f"f(z) = {name}")
    # Taylorå±•é–‹ï¼ˆ10æ¬¡ã¾ã§ï¼‰
    taylor_series = sp.series(f_sym, z, 0, n=6).removeO()
    print(f"Taylor series: {taylor_series}")
    print()

# æ•°å€¤è¨ˆç®—ã«ã‚ˆã‚‹è¿‘ä¼¼ã®æ¤œè¨¼
def taylor_approx(f, z_val, n_terms, z0=0):
    """Taylorç´šæ•°ã«ã‚ˆã‚‹è¿‘ä¼¼ï¼ˆæ•°å€¤å¾®åˆ†ï¼‰"""
    h = 1e-5
    approx = 0
    
    for n in range(n_terms):
        # néšå¾®åˆ†ã‚’æ•°å€¤çš„ã«è¨ˆç®—ï¼ˆä¸­å¿ƒå·®åˆ†ï¼‰
        if n == 0:
            deriv = f(z0)
        elif n == 1:
            deriv = (f(z0 + h) - f(z0 - h)) / (2*h)
        elif n == 2:
            deriv = (f(z0 + h) - 2*f(z0) + f(z0 - h)) / h**2
        else:
            # é«˜éšå¾®åˆ†ã¯å†å¸°çš„ã«è¨ˆç®—ï¼ˆç°¡ç•¥åŒ–ã®ãŸã‚ç†è«–å€¤ã‚’ä½¿ç”¨ï¼‰
            if hasattr(f, '__name__') and f.__name__ == 'exp_func':
                deriv = np.exp(z0)
            elif hasattr(f, '__name__') and f.__name__ == 'sin_func':
                deriv = [np.sin, np.cos, lambda x: -np.sin(x), lambda x: -np.cos(x)][n % 4](z0)
            else:
                deriv = 0
        
        term = deriv * (z_val - z0)**n / factorial(n)
        approx += term
    
    return approx

# å¯è¦–åŒ–
x = np.linspace(-2, 2, 200)
z_vals = x + 0j

functions_num = {
    'e^z': np.exp,
    'sin(z)': np.sin,
    'cos(z)': np.cos,
}

fig, axes = plt.subplots(1, 3, figsize=(16, 5))

for idx, (name, f) in enumerate(functions_num.items()):
    ax = axes[idx]
    
    # çœŸã®é–¢æ•°å€¤
    y_true = f(z_vals).real
    ax.plot(x, y_true, 'b-', linewidth=2, label='True function')
    
    # Taylorè¿‘ä¼¼ï¼ˆç•°ãªã‚‹æ¬¡æ•°ï¼‰
    colors = ['red', 'green', 'orange', 'purple']
    for n_terms, color in zip([3, 5, 7, 10], colors):
        y_approx = []
        for z_val in z_vals:
            # SymPyã§æ­£ç¢ºãªTaylorå±•é–‹ã‚’è¨ˆç®—
            if name == 'e^z':
                f_sym = sp.exp(z)
            elif name == 'sin(z)':
                f_sym = sp.sin(z)
            else:
                f_sym = sp.cos(z)
            
            taylor = sp.series(f_sym, z, 0, n=n_terms).removeO()
            y_val = complex(taylor.subs(z, z_val))
            y_approx.append(y_val.real)
        
        ax.plot(x, y_approx, color=color, linewidth=1.5, alpha=0.7, 
                linestyle='--', label=f'Taylor (n={n_terms})')
    
    ax.grid(True, alpha=0.3)
    ax.set_xlabel('x', fontsize=12)
    ax.set_ylabel('f(x)', fontsize=12)
    ax.set_title(f'$f(z) = {name}$', fontsize=12)
    ax.legend()
    ax.set_ylim(-2, 3)

plt.suptitle('Taylorç´šæ•°è¿‘ä¼¼ï¼ˆç•°ãªã‚‹æ¬¡æ•°ï¼‰', fontsize=14)
plt.tight_layout()
plt.show()

# åæŸåŠå¾„ã®è¨ˆç®—
print("\n=== åæŸåŠå¾„ ===")
print("e^z: R = âˆ (å…¨å¹³é¢ã§åæŸ)")
print("sin(z), cos(z): R = âˆ (å…¨å¹³é¢ã§åæŸ)")
print("1/(1-z): R = 1 (|z| < 1 ã§åæŸ)")
print("log(1+z): R = 1 (|z| < 1 ã§åæŸ)")</code></pre>
                    </div>
                </section>

                <section class="chapter-section">
                    <h2>3.2 Laurentç´šæ•°å±•é–‹</h2>
                    <p>
                        ç‰¹ç•°ç‚¹ã‚’å«ã‚€é ˜åŸŸã§ã¯ã€è² ã®ã¹ãã‚’å«ã‚€Laurentç´šæ•°ã§å±•é–‹ã•ã‚Œã¾ã™ã€‚
                    </p>

                    <div class="theory-box">
                        <h4>ğŸ“ ç†è«–</h4>
                        <p><strong>Laurentç´šæ•°å±•é–‹:</strong></p>
                        $$f(z) = \sum_{n=-\infty}^{\infty} a_n (z - z_0)^n$$
                        <p>æ­£éƒ¨ï¼ˆæ­£å‰‡éƒ¨ï¼‰ã¨è² éƒ¨ï¼ˆä¸»è¦éƒ¨ï¼‰ã«åˆ†ã‘ã‚‹ã¨:</p>
                        $$f(z) = \underbrace{\sum_{n=0}^{\infty} a_n (z - z_0)^n}_{\text{æ­£å‰‡éƒ¨}} + \underbrace{\sum_{n=1}^{\infty} \frac{a_{-n}}{(z - z_0)^n}}_{\text{ä¸»è¦éƒ¨}}$$
                    </div>

                    <div class="code-example">
                        <h4>ğŸ’» ã‚³ãƒ¼ãƒ‰ä¾‹ 2: Laurentç´šæ•°å±•é–‹ã®è¨ˆç®—</h4>
                        <pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
import sympy as sp

z = sp.Symbol('z')

# Laurentå±•é–‹ã®ä¾‹
functions_laurent = {
    '1/z': 1/z,
    'e^(1/z)': sp.exp(1/z),
    '1/(z^2)': 1/z**2,
    'sin(z)/z': sp.sin(z)/z,
    '1/(z(z-1))': 1/(z*(z-1)),
}

print("=== Laurentç´šæ•°å±•é–‹ ===\n")

for name, f in functions_laurent.items():
    print(f"f(z) = {name}")
    
    # z=0 ã®å‘¨ã‚Šã§Laurentå±•é–‹
    try:
        laurent = sp.series(f, z, 0, n=6)
        print(f"Laurent series around z=0: {laurent}")
    except:
        print("Cannot expand around z=0")
    
    print()

# å¯è¦–åŒ–: Laurentç´šæ•°ã®éƒ¨åˆ†å’Œ
z_sym = sp.Symbol('z')
f = sp.exp(1/z_sym)

print("\n=== e^(1/z) ã®Laurentå±•é–‹ ===")
laurent_exp = sp.series(f, z_sym, 0, n=10)
print(laurent_exp)

# æ•°å€¤è¨ˆç®—
theta = np.linspace(0, 2*np.pi, 1000)
r_values = [0.5, 1.0, 2.0]

fig, axes = plt.subplots(1, 3, figsize=(15, 5))

for idx, r in enumerate(r_values):
    ax = axes[idx]
    
    # çµŒè·¯: z = r * e^(iÎ¸)
    z_path = r * np.exp(1j * theta)
    
    # çœŸã®é–¢æ•°å€¤
    f_true = np.exp(1/z_path)
    
    # Laurentç´šæ•°ã«ã‚ˆã‚‹è¿‘ä¼¼ï¼ˆç•°ãªã‚‹æ¬¡æ•°ï¼‰
    ax.plot(f_true.real, f_true.imag, 'b-', linewidth=2, label='True: $e^{1/z}$')
    
    # éƒ¨åˆ†å’Œã«ã‚ˆã‚‹è¿‘ä¼¼
    for n_terms in [5, 10, 15]:
        f_approx = np.zeros_like(z_path, dtype=complex)
        for n in range(-n_terms, n_terms+1):
            if n >= 0:
                continue  # e^(1/z) ã¯è² ã®ã¹ãã®ã¿
            coeff = 1 / sp.factorial(-n)
            f_approx += coeff * z_path**n
        
        ax.plot(f_approx.real, f_approx.imag, linewidth=1.5, alpha=0.7, 
                linestyle='--', label=f'Laurent (N={n_terms})')
    
    ax.grid(True, alpha=0.3)
    ax.set_xlabel('Re(f)', fontsize=12)
    ax.set_ylabel('Im(f)', fontsize=12)
    ax.set_title(f'$|z| = {r}$', fontsize=12)
    ax.axis('equal')
    ax.legend()

plt.suptitle('Laurentç´šæ•°è¿‘ä¼¼: $f(z) = e^{1/z}$', fontsize=14)
plt.tight_layout()
plt.show()</code></pre>
                    </div>
                </section>

                <section class="chapter-section">
                    <h2>3.3 ç‰¹ç•°ç‚¹ã®åˆ†é¡</h2>
                    <p>
                        ç‰¹ç•°ç‚¹ã¯é™¤å»å¯èƒ½ç‰¹ç•°ç‚¹ã€æ¥µã€çœŸæ€§ç‰¹ç•°ç‚¹ã®3ã¤ã«åˆ†é¡ã•ã‚Œã¾ã™ã€‚
                    </p>

                    <div class="theory-box">
                        <h4>ğŸ“ ç†è«–</h4>
                        <p><strong>ç‰¹ç•°ç‚¹ã®åˆ†é¡:</strong></p>
                        <ul>
                            <li><strong>é™¤å»å¯èƒ½ç‰¹ç•°ç‚¹:</strong> ä¸»è¦éƒ¨ãŒ0 â†’ $\lim_{z \to z_0} f(z)$ ãŒæœ‰é™</li>
                            <li><strong>$m$ ä½ã®æ¥µ:</strong> ä¸»è¦éƒ¨ãŒæœ‰é™é … $(z-z_0)^{-m}$ ã¾ã§</li>
                            <li><strong>çœŸæ€§ç‰¹ç•°ç‚¹:</strong> ä¸»è¦éƒ¨ãŒç„¡é™é …</li>
                        </ul>
                    </div>

                    <div class="code-example">
                        <h4>ğŸ’» ã‚³ãƒ¼ãƒ‰ä¾‹ 3: ç‰¹ç•°ç‚¹ã®åˆ†é¡</h4>
                        <pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
import sympy as sp

z = sp.Symbol('z')

# æ§˜ã€…ãªç‰¹ç•°ç‚¹ã‚’æŒã¤é–¢æ•°
singular_functions = {
    'sin(z)/z (z=0)': {
        'function': sp.sin(z)/z,
        'singularity': 0,
        'type': 'é™¤å»å¯èƒ½',
    },
    '1/z (z=0)': {
        'function': 1/z,
        'singularity': 0,
        'type': '1ä½ã®æ¥µ',
    },
    '1/z^2 (z=0)': {
        'function': 1/z**2,
        'singularity': 0,
        'type': '2ä½ã®æ¥µ',
    },
    'e^(1/z) (z=0)': {
        'function': sp.exp(1/z),
        'singularity': 0,
        'type': 'çœŸæ€§ç‰¹ç•°ç‚¹',
    },
    '1/((z-1)(z-2)) (z=1,2)': {
        'function': 1/((z-1)*(z-2)),
        'singularity': 1,
        'type': '1ä½ã®æ¥µ (at z=1)',
    },
}

print("=== ç‰¹ç•°ç‚¹ã®åˆ†é¡ ===\n")

for name, info in singular_functions.items():
    f = info['function']
    z0 = info['singularity']
    sing_type = info['type']
    
    print(f"{name}: {sing_type}")
    
    # Laurentå±•é–‹
    try:
        laurent = sp.series(f, z, z0, n=6)
        print(f"  Laurent series: {laurent}")
        
        # ä¸»è¦éƒ¨ã®é …æ•°ã‚’æ•°ãˆã‚‹
        laurent_dict = laurent.removeO().as_coefficients_dict()
        negative_powers = [key for key in laurent_dict.keys() if z in key.free_symbols and sp.degree(key, z) < 0]
        
        if len(negative_powers) == 0:
            print(f"  â†’ é™¤å»å¯èƒ½ç‰¹ç•°ç‚¹")
        elif len(negative_powers) < 10:
            max_neg = max([-sp.degree(key, z) for key in negative_powers])
            print(f"  â†’ {max_neg}ä½ã®æ¥µ")
        else:
            print(f"  â†’ çœŸæ€§ç‰¹ç•°ç‚¹")
    except:
        print(f"  Cannot expand")
    
    print()

# å¯è¦–åŒ–: ç‰¹ç•°ç‚¹è¿‘å‚ã§ã®æŒ™å‹•
fig, axes = plt.subplots(2, 2, figsize=(12, 12))
axes = axes.flatten()

cases = [
    ('sin(z)/z', lambda z: np.sin(z)/z, 'é™¤å»å¯èƒ½ç‰¹ç•°ç‚¹'),
    ('1/z', lambda z: 1/z, '1ä½ã®æ¥µ'),
    ('1/z^2', lambda z: 1/z**2, '2ä½ã®æ¥µ'),
    ('e^(1/z)', lambda z: np.exp(1/z), 'çœŸæ€§ç‰¹ç•°ç‚¹'),
]

for idx, (name, f, sing_type) in enumerate(cases):
    ax = axes[idx]
    
    # æ¥µåº§æ¨™ã‚°ãƒªãƒƒãƒ‰
    r = np.linspace(0.1, 2, 100)
    theta = np.linspace(0, 2*np.pi, 100)
    R, Theta = np.meshgrid(r, theta)
    Z = R * np.exp(1j * Theta)
    
    # é–¢æ•°å€¤
    try:
        W = f(Z)
        magnitude = np.abs(W)
        magnitude = np.clip(magnitude, 0, 10)  # ã‚¯ãƒªãƒƒãƒ—ã—ã¦å¯è¦–åŒ–
        
        im = ax.contourf(Z.real, Z.imag, magnitude, levels=20, cmap='viridis')
        ax.plot(0, 0, 'r*', markersize=15, label='ç‰¹ç•°ç‚¹ z=0')
        plt.colorbar(im, ax=ax, label='|f(z)|')
    except:
        pass
    
    ax.set_xlabel('Re(z)', fontsize=12)
    ax.set_ylabel('Im(z)', fontsize=12)
    ax.set_title(f'$f(z) = {name}$\n({sing_type})', fontsize=12)
    ax.axis('equal')
    ax.grid(True, alpha=0.3)
    ax.legend()

plt.suptitle('ç‰¹ç•°ç‚¹è¿‘å‚ã§ã®é–¢æ•°ã®æŒ™å‹•', fontsize=14)
plt.tight_layout()
plt.show()</code></pre>
                    </div>
                </section>

                <section class="chapter-section">
                    <h2>3.4 ç•™æ•°ã®è¨ˆç®—</h2>
                    <p>
                        ç•™æ•°ã¯ Laurentå±•é–‹ã® $(z-z_0)^{-1}$ ã®ä¿‚æ•°ã§ã€è¤‡ç´ ç©åˆ†ã®è¨ˆç®—ã«é‡è¦ã§ã™ã€‚
                    </p>

                    <div class="theory-box">
                        <h4>ğŸ“ ç†è«–</h4>
                        <p><strong>ç•™æ•°ï¼ˆResidueï¼‰:</strong></p>
                        $$\text{Res}(f, z_0) = a_{-1}$$
                        <p>ãŸã ã— $a_{-1}$ ã¯Laurentå±•é–‹ $f(z) = \sum a_n (z-z_0)^n$ ã® $(z-z_0)^{-1}$ ã®ä¿‚æ•°</p>
                        <p><strong>$m$ ä½ã®æ¥µã®å ´åˆ:</strong></p>
                        $$\text{Res}(f, z_0) = \frac{1}{(m-1)!} \lim_{z \to z_0} \frac{d^{m-1}}{dz^{m-1}} [(z-z_0)^m f(z)]$$
                    </div>

                    <div class="code-example">
                        <h4>ğŸ’» ã‚³ãƒ¼ãƒ‰ä¾‹ 4: ç•™æ•°ã®è¨ˆç®—ï¼ˆSymPyï¼‰</h4>
                        <pre><code class="language-python">import sympy as sp
import numpy as np

z = sp.Symbol('z')

# æ§˜ã€…ãªé–¢æ•°ã®ç•™æ•°è¨ˆç®—
functions_residue = [
    (1/z, 0, "1/z at z=0"),
    (1/z**2, 0, "1/z^2 at z=0"),
    (sp.exp(z)/z, 0, "e^z/z at z=0"),
    (sp.sin(z)/z**2, 0, "sin(z)/z^2 at z=0"),
    (1/(z-1), 1, "1/(z-1) at z=1"),
    (z/(z**2 + 1), sp.I, "z/(z^2+1) at z=i"),
    (sp.exp(1/z), 0, "e^(1/z) at z=0"),
]

print("=== ç•™æ•°ã®è¨ˆç®— ===\n")

for f, z0, description in functions_residue:
    print(f"{description}:")
    
    # SymPyã§ç•™æ•°ã‚’è¨ˆç®—
    residue = sp.residue(f, z, z0)
    print(f"  Residue: {residue}")
    
    # Laurentå±•é–‹ã‚‚è¡¨ç¤º
    try:
        laurent = sp.series(f, z, z0, n=5)
        print(f"  Laurent series: {laurent}")
    except:
        print(f"  Laurent series: Cannot expand")
    
    print()

# ç•™æ•°ã®å…¬å¼ã‚’ä½¿ã£ãŸè¨ˆç®—ä¾‹
print("\n=== ç•™æ•°å…¬å¼ã«ã‚ˆã‚‹è¨ˆç®— ===\n")

# 1ä½ã®æ¥µã®å ´åˆ
print("ã€1ä½ã®æ¥µã€‘")
f1 = (z**2 + 1) / (z - 1)
z0_1 = 1
numerator = (z**2 + 1)
denominator = (z - 1)

# å…¬å¼: Res(f, z0) = lim (z-z0) * f(z)
residue_manual = sp.limit((z - z0_1) * f1, z, z0_1)
residue_auto = sp.residue(f1, z, z0_1)

print(f"f(z) = {f1}")
print(f"Res(f, {z0_1}) by formula: {residue_manual}")
print(f"Res(f, {z0_1}) by SymPy: {residue_auto}")

# 2ä½ã®æ¥µã®å ´åˆ
print("\nã€2ä½ã®æ¥µã€‘")
f2 = sp.sin(z) / z**2
z0_2 = 0

# å…¬å¼: Res(f, z0) = lim d/dz [(z-z0)^m * f(z)]
residue_manual2 = sp.limit(sp.diff(z**2 * f2, z), z, z0_2)
residue_auto2 = sp.residue(f2, z, z0_2)

print(f"f(z) = {f2}")
print(f"Res(f, {z0_2}) by formula: {residue_manual2}")
print(f"Res(f, {z0_2}) by SymPy: {residue_auto2}")

print("\nã€éƒ¨åˆ†åˆ†æ•°åˆ†è§£ã¨ç•™æ•°ã€‘")
f3 = 1 / ((z-1)*(z-2))
print(f"f(z) = {f3}")

# éƒ¨åˆ†åˆ†æ•°åˆ†è§£
partial_fractions = sp.apart(f3, z)
print(f"Partial fractions: {partial_fractions}")

# å„æ¥µã§ã®ç•™æ•°
for pole in [1, 2]:
    res = sp.residue(f3, z, pole)
    print(f"Res(f, z={pole}) = {res}")</code></pre>
                    </div>
                </section>

                <section class="chapter-section">
                    <h2>3.5 ç•™æ•°å®šç†</h2>
                    <p>
                        ç•™æ•°å®šç†ã«ã‚ˆã‚Šã€è¤‡ç´ ç©åˆ†ãŒç•™æ•°ã®å’Œã§è¨ˆç®—ã§ãã¾ã™ã€‚
                    </p>

                    <div class="theory-box">
                        <h4>ğŸ“ ç†è«–</h4>
                        <p><strong>ç•™æ•°å®šç†:</strong></p>
                        $$\oint_C f(z) dz = 2\pi i \sum_{k} \text{Res}(f, z_k)$$
                        <p>ãŸã ã— $z_k$ ã¯ $C$ å†…éƒ¨ã®ç‰¹ç•°ç‚¹</p>
                    </div>

                    <div class="code-example">
                        <h4>ğŸ’» ã‚³ãƒ¼ãƒ‰ä¾‹ 5: ç•™æ•°å®šç†ã®æ¤œè¨¼</h4>
                        <pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
import sympy as sp

# è¤‡ç´ ç©åˆ†ã®æ•°å€¤è¨ˆç®—
def complex_contour_integral_numerical(f, path, t_range, n_points=1000):
    """æ•°å€¤ç©åˆ†"""
    t = np.linspace(t_range[0], t_range[1], n_points)
    dt = t[1] - t[0]
    z = path(t)
    dz_dt = np.gradient(z, dt)
    f_z = f(z)
    integral = np.trapz(f_z * dz_dt, dx=dt)
    return integral, z

# ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹
z_sym = sp.Symbol('z')

test_cases = [
    {
        'name': '1/z',
        'function_sym': 1/z_sym,
        'function_num': lambda z: 1/z,
        'poles': [0],
        'path': lambda t: 2*np.exp(1j*t),
        't_range': (0, 2*np.pi),
    },
    {
        'name': '1/(z^2+1)',
        'function_sym': 1/(z_sym**2 + 1),
        'function_num': lambda z: 1/(z**2 + 1),
        'poles': [1j, -1j],
        'path': lambda t: 2*np.exp(1j*t),
        't_range': (0, 2*np.pi),
    },
    {
        'name': 'z/(z-1)/(z-2)',
        'function_sym': z_sym/((z_sym-1)*(z_sym-2)),
        'function_num': lambda z: z/((z-1)*(z-2)),
        'poles': [1, 2],
        'path': lambda t: 3*np.exp(1j*t),
        't_range': (0, 2*np.pi),
    },
]

print("=== ç•™æ•°å®šç†ã®æ¤œè¨¼ ===\n")

fig, axes = plt.subplots(1, 3, figsize=(15, 5))

for idx, case in enumerate(test_cases):
    ax = axes[idx]
    
    # æ•°å€¤ç©åˆ†
    integral_num, z_path = complex_contour_integral_numerical(
        case['function_num'], case['path'], case['t_range']
    )
    
    # ç•™æ•°å®šç†ã«ã‚ˆã‚‹è¨ˆç®—
    residue_sum = 0
    for pole in case['poles']:
        res = sp.residue(case['function_sym'], z_sym, pole)
        residue_sum += complex(res)
    
    integral_residue = 2 * np.pi * 1j * residue_sum
    
    # çµæœè¡¨ç¤º
    print(f"f(z) = {case['name']}")
    print(f"  Poles inside contour: {case['poles']}")
    print(f"  Numerical integral: {integral_num:.8f}")
    print(f"  Residue theorem: 2Ï€i Ã— Î£ Res = {integral_residue:.8f}")
    print(f"  Error: {np.abs(integral_num - integral_residue):.2e}\n")
    
    # å¯è¦–åŒ–
    ax.plot(z_path.real, z_path.imag, 'b-', linewidth=2, label='Contour')
    
    # æ¥µã®ä½ç½®
    for pole in case['poles']:
        if isinstance(pole, complex) or np.abs(np.imag(pole)) > 1e-10:
            pole_complex = complex(pole)
        else:
            pole_complex = complex(float(pole), 0)
        
        # çµŒè·¯å†…ã‹ãƒã‚§ãƒƒã‚¯
        if np.abs(pole_complex) < np.abs(case['path'](0)):
            ax.plot(pole_complex.real, pole_complex.imag, 'r*', 
                   markersize=15, label=f'Pole at {pole}')
    
    ax.grid(True, alpha=0.3)
    ax.axhline(0, color='gray', linewidth=0.5)
    ax.axvline(0, color='gray', linewidth=0.5)
    ax.set_xlabel('Re(z)', fontsize=12)
    ax.set_ylabel('Im(z)', fontsize=12)
    ax.set_title(f'$f(z) = {case["name"]}$', fontsize=11)
    ax.axis('equal')
    ax.legend(fontsize=9)

plt.suptitle('ç•™æ•°å®šç†ã®æ¤œè¨¼', fontsize=14)
plt.tight_layout()
plt.show()</code></pre>
                    </div>
                </section>

                <section class="chapter-section">
                    <h2>3.6 å®Ÿç©åˆ†ã¸ã®å¿œç”¨ (1): æœ‰ç†é–¢æ•°</h2>
                    <p>
                        ç•™æ•°å®šç†ã‚’ä½¿ã†ã¨ã€è¤‡é›‘ãªå®Ÿç©åˆ†ã‚’è¤‡ç´ ç©åˆ†ã«å¤‰æ›ã—ã¦è¨ˆç®—ã§ãã¾ã™ã€‚
                    </p>

                    <div class="theory-box">
                        <h4>ğŸ“ ç†è«–</h4>
                        <p><strong>å®Ÿç©åˆ†ã®è¨ˆç®—:</strong></p>
                        $$\int_{-\infty}^{\infty} \frac{P(x)}{Q(x)} dx = 2\pi i \sum_{\text{ä¸ŠåŠå¹³é¢}} \text{Res}(f, z_k)$$
                        <p>ãŸã ã— $\deg Q \geq \deg P + 2$ ã®ã¨ãåæŸ</p>
                    </div>

                    <div class="code-example">
                        <h4>ğŸ’» ã‚³ãƒ¼ãƒ‰ä¾‹ 6: æœ‰ç†é–¢æ•°ã®å®Ÿç©åˆ†</h4>
                        <pre><code class="language-python">import numpy as np
from scipy import integrate
import sympy as sp
import matplotlib.pyplot as plt

z = sp.Symbol('z', complex=True)
x = sp.Symbol('x', real=True)

# å®Ÿç©åˆ†ã®ä¾‹
real_integrals = [
    {
        'name': '1/(1+x^2)',
        'integrand': 1/(1 + x**2),
        'complex_func': 1/(1 + z**2),
        'poles_upper': [sp.I],
    },
    {
        'name': '1/(1+x^4)',
        'integrand': 1/(1 + x**4),
        'complex_func': 1/(1 + z**4),
        'poles_upper': [sp.exp(sp.I*sp.pi/4), sp.exp(sp.I*3*sp.pi/4)],
    },
    {
        'name': 'x^2/(1+x^4)',
        'integrand': x**2/(1 + x**4),
        'complex_func': z**2/(1 + z**4),
        'poles_upper': [sp.exp(sp.I*sp.pi/4), sp.exp(sp.I*3*sp.pi/4)],
    },
]

print("=== ç•™æ•°å®šç†ã«ã‚ˆã‚‹å®Ÿç©åˆ†ã®è¨ˆç®— ===\n")

for case in real_integrals:
    print(f"âˆ«[-âˆ,âˆ] {case['name']} dx")
    
    # æ•°å€¤ç©åˆ†ï¼ˆæ¤œè¨¼ç”¨ï¼‰
    integrand_lambda = sp.lambdify(x, case['integrand'], 'numpy')
    integral_numerical, error = integrate.quad(integrand_lambda, -np.inf, np.inf)
    
    # ç•™æ•°å®šç†
    residue_sum = 0
    for pole in case['poles_upper']:
        res = sp.residue(case['complex_func'], z, pole)
        residue_sum += res
    
    integral_residue = 2 * sp.pi * sp.I * residue_sum
    integral_residue_val = complex(integral_residue)
    
    print(f"  Numerical integration: {integral_numerical:.10f}")
    print(f"  Residue theorem: {integral_residue} = {integral_residue_val.real:.10f}")
    print(f"  Error: {abs(integral_numerical - integral_residue_val.real):.2e}")
    print(f"  Poles in upper half-plane: {case['poles_upper']}")
    print()

# å¯è¦–åŒ–: è¤‡ç´ å¹³é¢ã§ã®ç©åˆ†çµŒè·¯
fig, axes = plt.subplots(1, 3, figsize=(15, 5))

R_values = [5, 10, 20]
f_test = lambda z: 1/(1 + z**2)
pole_test = 1j

for idx, R in enumerate(R_values):
    ax = axes[idx]
    
    # å®Ÿè»¸ä¸Šã®çµŒè·¯
    x_line = np.linspace(-R, R, 100)
    ax.plot(x_line, np.zeros_like(x_line), 'b-', linewidth=2, label='å®Ÿè»¸')
    
    # ä¸ŠåŠå††
    theta = np.linspace(0, np.pi, 100)
    semicircle = R * np.exp(1j * theta)
    ax.plot(semicircle.real, semicircle.imag, 'r--', linewidth=2, label='ä¸ŠåŠå††')
    
    # æ¥µ
    ax.plot(0, 1, 'g*', markersize=15, label='Pole at i')
    
    # é–‰æ›²ç·šã‚’å¼·èª¿
    ax.arrow(-R, 0, R/5, 0, head_width=0.3, head_length=0.5, fc='blue', ec='blue')
    ax.arrow(R*np.cos(np.pi/4), R*np.sin(np.pi/4), 
             -R/5*np.sin(np.pi/4), R/5*np.cos(np.pi/4),
             head_width=0.3, head_length=0.5, fc='red', ec='red')
    
    ax.grid(True, alpha=0.3)
    ax.axhline(0, color='gray', linewidth=0.5)
    ax.axvline(0, color='gray', linewidth=0.5)
    ax.set_xlabel('Re(z)', fontsize=12)
    ax.set_ylabel('Im(z)', fontsize=12)
    ax.set_title(f'ç©åˆ†çµŒè·¯ (R={R})', fontsize=12)
    ax.axis('equal')
    ax.set_xlim(-R-1, R+1)
    ax.set_ylim(-1, R+1)
    ax.legend()

plt.suptitle('ç•™æ•°å®šç†ã«ã‚ˆã‚‹å®Ÿç©åˆ†: ä¸ŠåŠå††ã®çµŒè·¯', fontsize=14)
plt.tight_layout()
plt.show()

# R â†’ âˆ ã§ã®ä¸ŠåŠå††ã®å¯„ä¸
print("\n=== ä¸ŠåŠå††ã®å¯„ä¸ (Râ†’âˆ) ===")
print("âˆ«[semicircle] f(z)dz â†’ 0 as Râ†’âˆ (if deg(Q) â‰¥ deg(P)+2)")
for R in [10, 50, 100, 500]:
    theta = np.linspace(0, np.pi, 1000)
    z_semi = R * np.exp(1j * theta)
    dz = 1j * R * np.exp(1j * theta) * (theta[1] - theta[0])
    
    f_semi = f_test(z_semi)
    integral_semi = np.sum(f_semi * dz)
    
    print(f"R = {R:4d}: |âˆ«[semicircle]| = {np.abs(integral_semi):.6e}")</code></pre>
                    </div>
                </section>

                <section class="chapter-section">
                    <h2>3.7 å®Ÿç©åˆ†ã¸ã®å¿œç”¨ (2): ä¸‰è§’é–¢æ•°ã‚’å«ã‚€ç©åˆ†</h2>
                    <p>
                        $z = e^{i\theta}$ ã®ç½®æ›ã«ã‚ˆã‚Šã€ä¸‰è§’é–¢æ•°ã‚’å«ã‚€ç©åˆ†ã‚’è¤‡ç´ ç©åˆ†ã«å¤‰æ›ã§ãã¾ã™ã€‚
                    </p>

                    <div class="theory-box">
                        <h4>ğŸ“ ç†è«–</h4>
                        <p><strong>ä¸‰è§’é–¢æ•°ç©åˆ†ã®å¤‰æ›:</strong></p>
                        $$z = e^{i\theta}, \quad \cos\theta = \frac{z + z^{-1}}{2}, \quad \sin\theta = \frac{z - z^{-1}}{2i}$$
                        $$\int_0^{2\pi} R(\cos\theta, \sin\theta) d\theta = \oint_{|z|=1} R\left(\frac{z+z^{-1}}{2}, \frac{z-z^{-1}}{2i}\right) \frac{dz}{iz}$$
                    </div>

                    <div class="code-example">
                        <h4>ğŸ’» ã‚³ãƒ¼ãƒ‰ä¾‹ 7: ä¸‰è§’é–¢æ•°ç©åˆ†ã®è¨ˆç®—</h4>
                        <pre><code class="language-python">import numpy as np
from scipy import integrate
import sympy as sp
import matplotlib.pyplot as plt

theta_sym = sp.Symbol('theta', real=True)
z_sym = sp.Symbol('z', complex=True)

# ä¸‰è§’é–¢æ•°ç©åˆ†ã®ä¾‹
trig_integrals = [
    {
        'name': '1/(2+cos(Î¸))',
        'integrand': 1/(2 + sp.cos(theta_sym)),
        'description': 'âˆ«[0,2Ï€] 1/(2+cos(Î¸)) dÎ¸',
    },
    {
        'name': '1/(5+4*cos(Î¸))',
        'integrand': 1/(5 + 4*sp.cos(theta_sym)),
        'description': 'âˆ«[0,2Ï€] 1/(5+4cos(Î¸)) dÎ¸',
    },
    {
        'name': 'cos(Î¸)/(5+4*cos(Î¸))',
        'integrand': sp.cos(theta_sym)/(5 + 4*sp.cos(theta_sym)),
        'description': 'âˆ«[0,2Ï€] cos(Î¸)/(5+4cos(Î¸)) dÎ¸',
    },
]

print("=== ä¸‰è§’é–¢æ•°ç©åˆ†ã®è¨ˆç®— ===\n")

for case in trig_integrals:
    print(case['description'])
    
    # æ•°å€¤ç©åˆ†
    integrand_func = sp.lambdify(theta_sym, case['integrand'], 'numpy')
    integral_numerical, _ = integrate.quad(integrand_func, 0, 2*np.pi)
    
    # z = e^(iÎ¸) ã®ç½®æ›
    # cos(Î¸) = (z + 1/z)/2
    integrand_original = case['integrand']
    integrand_z = integrand_original.subs(sp.cos(theta_sym), (z_sym + 1/z_sym)/2)
    integrand_z = integrand_z.subs(sp.sin(theta_sym), (z_sym - 1/z_sym)/(2*sp.I))
    
    # dÎ¸ = dz/(iz)
    integrand_complex = integrand_z / (sp.I * z_sym)
    integrand_complex = sp.simplify(integrand_complex)
    
    print(f"  Complex integrand: {integrand_complex}")
    
    # å˜ä½å††å†…ã®æ¥µã‚’è¦‹ã¤ã‘ã‚‹
    denominator = sp.denom(integrand_complex)
    poles_all = sp.solve(denominator, z_sym)
    poles_inside = [p for p in poles_all if sp.Abs(p) < 1]
    
    print(f"  All poles: {poles_all}")
    print(f"  Poles inside |z|=1: {poles_inside}")
    
    # ç•™æ•°ã®è¨ˆç®—
    residue_sum = 0
    for pole in poles_inside:
        res = sp.residue(integrand_complex, z_sym, pole)
        residue_sum += res
        print(f"    Res at z={pole}: {res}")
    
    integral_residue = 2 * sp.pi * sp.I * residue_sum
    integral_residue_val = complex(integral_residue)
    
    print(f"\n  Numerical: {integral_numerical:.10f}")
    print(f"  Residue theorem: {integral_residue} = {integral_residue_val.real:.10f}")
    print(f"  Error: {abs(integral_numerical - integral_residue_val.real):.2e}\n")
    print("-" * 60)
    print()

# å¯è¦–åŒ–
theta = np.linspace(0, 2*np.pi, 1000)

fig, axes = plt.subplots(1, 3, figsize=(15, 5))

for idx, case in enumerate(trig_integrals):
    ax = axes[idx]
    
    # è¢«ç©åˆ†é–¢æ•°
    integrand_func = sp.lambdify(theta_sym, case['integrand'], 'numpy')
    y = integrand_func(theta)
    
    ax.plot(theta, y, 'b-', linewidth=2)
    ax.fill_between(theta, 0, y, alpha=0.3)
    ax.grid(True, alpha=0.3)
    ax.set_xlabel('Î¸ (rad)', fontsize=12)
    ax.set_ylabel('f(Î¸)', fontsize=12)
    ax.set_title(f'${case["name"]}$', fontsize=11)
    ax.set_xlim(0, 2*np.pi)
    ax.set_xticks([0, np.pi/2, np.pi, 3*np.pi/2, 2*np.pi])
    ax.set_xticklabels(['0', 'Ï€/2', 'Ï€', '3Ï€/2', '2Ï€'])

plt.suptitle('ä¸‰è§’é–¢æ•°ç©åˆ†ã®è¢«ç©åˆ†é–¢æ•°', fontsize=14)
plt.tight_layout()
plt.show()</code></pre>
                    </div>
                </section>

                <section class="chapter-section">
                    <h2>3.8 å®Ÿç©åˆ†ã¸ã®å¿œç”¨ (3): ãƒ•ãƒ¼ãƒªã‚¨å‹ç©åˆ†</h2>
                    <p>
                        $e^{iax}$ ã‚’å«ã‚€ç©åˆ†ã«ã‚‚ç•™æ•°å®šç†ãŒæœ‰åŠ¹ã§ã™ã€‚
                    </p>

                    <div class="theory-box">
                        <h4>ğŸ“ ç†è«–</h4>
                        <p><strong>ãƒ•ãƒ¼ãƒªã‚¨å‹ç©åˆ†:</strong></p>
                        $$\int_{-\infty}^{\infty} f(x) e^{iax} dx = 2\pi i \sum_{\text{Im}(z_k)>0} \text{Res}(f(z)e^{iaz}, z_k) \quad (a > 0)$$
                    </div>

                    <div class="code-example">
                        <h4>ğŸ’» ã‚³ãƒ¼ãƒ‰ä¾‹ 8: ãƒ•ãƒ¼ãƒªã‚¨å‹ç©åˆ†</h4>
                        <pre><code class="language-python">import numpy as np
from scipy import integrate
import sympy as sp

x = sp.Symbol('x', real=True)
z = sp.Symbol('z', complex=True)
a = sp.Symbol('a', positive=True, real=True)

# ãƒ•ãƒ¼ãƒªã‚¨å‹ç©åˆ†ã®ä¾‹
fourier_integrals = [
    {
        'name': 'e^(iax)/(1+x^2)',
        'a_val': 1,
        'f_x': 1/(1 + x**2),
        'f_z': 1/(1 + z**2),
        'poles_upper': [sp.I],
    },
    {
        'name': 'e^(iax)/(x^2+4)',
        'a_val': 2,
        'f_x': 1/(x**2 + 4),
        'f_z': 1/(z**2 + 4),
        'poles_upper': [2*sp.I],
    },
]

print("=== ãƒ•ãƒ¼ãƒªã‚¨å‹ç©åˆ† ===\n")

for case in fourier_integrals:
    a_val = case['a_val']
    print(f"âˆ«[-âˆ,âˆ] {case['name']} dx (a={a_val})")
    
    # æ•°å€¤ç©åˆ†ï¼ˆå®Ÿéƒ¨ã¨è™šéƒ¨ã‚’åˆ¥ã€…ã«ï¼‰
    integrand_real = sp.lambdify(x, case['f_x'] * sp.cos(a_val * x), 'numpy')
    integrand_imag = sp.lambdify(x, case['f_x'] * sp.sin(a_val * x), 'numpy')
    
    integral_real, _ = integrate.quad(integrand_real, -np.inf, np.inf)
    integral_imag, _ = integrate.quad(integrand_imag, -np.inf, np.inf)
    integral_numerical = integral_real + 1j * integral_imag
    
    # ç•™æ•°å®šç†
    f_z_exp = case['f_z'] * sp.exp(sp.I * a_val * z)
    
    residue_sum = 0
    for pole in case['poles_upper']:
        res = sp.residue(f_z_exp, z, pole)
        residue_sum += res
        print(f"  Pole at z={pole}: Res = {res}")
    
    integral_residue = 2 * sp.pi * sp.I * residue_sum
    integral_residue_complex = complex(integral_residue)
    
    print(f"\n  Numerical: {integral_numerical}")
    print(f"  Residue theorem: {integral_residue} = {integral_residue_complex}")
    print(f"  Error: {abs(integral_numerical - integral_residue_complex):.2e}\n")
    print("-" * 60)
    print()

# å¯è¦–åŒ–: a ã®ä¾å­˜æ€§
a_values = np.linspace(0.1, 5, 50)
integrals_vs_a = []

for a_val in a_values:
    # âˆ«[-âˆ,âˆ] e^(iax)/(1+x^2) dx = Ï€ e^(-a) (a>0)
    integral_theory = np.pi * np.exp(-a_val)
    integrals_vs_a.append(integral_theory.real)

plt.figure(figsize=(10, 6))
plt.plot(a_values, integrals_vs_a, 'b-', linewidth=2)
plt.grid(True, alpha=0.3)
plt.xlabel('a', fontsize=12)
plt.ylabel('âˆ« e^(iax)/(1+xÂ²) dx', fontsize=12)
plt.title('ãƒ•ãƒ¼ãƒªã‚¨å‹ç©åˆ†ã® a ä¾å­˜æ€§\nç†è«–å€¤: Ï€ e^(-a)', fontsize=14)
plt.tight_layout()
plt.show()

print("\nç†è«–å€¤ã®ç¢ºèª:")
print("âˆ«[-âˆ,âˆ] e^(iax)/(1+xÂ²) dx = Ï€ e^(-a) (a>0)")
for a_test in [0.5, 1.0, 2.0, 5.0]:
    theory = np.pi * np.exp(-a_test)
    print(f"  a={a_test}: Ï€ e^(-a) = {theory:.6f}")</code></pre>
                    </div>
                </section>

                <section class="chapter-section">
                    <h2>3.9 ææ–™ç§‘å­¦ã¸ã®å¿œç”¨: æ ¼å­æŒ¯å‹•ã¨ãƒ•ã‚©ãƒãƒ³åˆ†æ•£</h2>
                    <p>
                        å›ºä½“ç‰©ç†å­¦ã§ã¯ã€æ ¼å­æŒ¯å‹•ã®åˆ†æ•£é–¢ä¿‚ã‚’è§£æã™ã‚‹éš›ã«è¤‡ç´ é–¢æ•°è«–ãŒä½¿ã‚ã‚Œã¾ã™ã€‚
                    </p>

                    <div class="code-example">
                        <h4>ğŸ’» ã‚³ãƒ¼ãƒ‰ä¾‹ 9: 1æ¬¡å…ƒæ ¼å­æŒ¯å‹•ã®ã‚°ãƒªãƒ¼ãƒ³é–¢æ•°</h4>
                        <pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
from scipy import integrate

# 1æ¬¡å…ƒå˜åŸå­æ ¼å­ã®ã‚°ãƒªãƒ¼ãƒ³é–¢æ•°
# G(Ï‰) = 1/(Ï‰Â² - Ï‰â‚€Â² - Î£(Ï‰))
# Ï‰â‚€: æ ¼å­æŒ¯å‹•ã®å›ºæœ‰è§’å‘¨æ³¢æ•°
# Î£(Ï‰): è‡ªå·±ã‚¨ãƒãƒ«ã‚®ãƒ¼

omega_0 = 1.0  # å›ºæœ‰è§’å‘¨æ³¢æ•°
gamma = 0.1    # æ¸›è¡°å®šæ•°ï¼ˆè™šéƒ¨ï¼‰

def green_function(omega):
    """æ ¼å­æŒ¯å‹•ã®ã‚°ãƒªãƒ¼ãƒ³é–¢æ•°"""
    return 1 / (omega**2 - omega_0**2 + 1j*gamma*omega)

def spectral_function(omega):
    """ã‚¹ãƒšã‚¯ãƒˆãƒ«é–¢æ•° A(Ï‰) = -2 Im[G(Ï‰)]"""
    G = green_function(omega)
    return -2 * G.imag

# å‘¨æ³¢æ•°ç¯„å›²
omega = np.linspace(0, 3, 1000)

# ã‚°ãƒªãƒ¼ãƒ³é–¢æ•°ã¨ã‚¹ãƒšã‚¯ãƒˆãƒ«é–¢æ•°
G = green_function(omega)
A = spectral_function(omega)

# å¯è¦–åŒ–
fig, axes = plt.subplots(2, 2, figsize=(14, 10))

# ã‚°ãƒªãƒ¼ãƒ³é–¢æ•°ã®å®Ÿéƒ¨
axes[0, 0].plot(omega, G.real, 'b-', linewidth=2)
axes[0, 0].axvline(omega_0, color='red', linestyle='--', label=f'Ï‰â‚€={omega_0}')
axes[0, 0].axhline(0, color='gray', linewidth=0.5)
axes[0, 0].grid(True, alpha=0.3)
axes[0, 0].set_xlabel('Ï‰', fontsize=12)
axes[0, 0].set_ylabel('Re[G(Ï‰)]', fontsize=12)
axes[0, 0].set_title('ã‚°ãƒªãƒ¼ãƒ³é–¢æ•°ã®å®Ÿéƒ¨', fontsize=12)
axes[0, 0].legend()

# ã‚°ãƒªãƒ¼ãƒ³é–¢æ•°ã®è™šéƒ¨
axes[0, 1].plot(omega, G.imag, 'r-', linewidth=2)
axes[0, 1].axvline(omega_0, color='red', linestyle='--', label=f'Ï‰â‚€={omega_0}')
axes[0, 1].axhline(0, color='gray', linewidth=0.5)
axes[0, 1].grid(True, alpha=0.3)
axes[0, 1].set_xlabel('Ï‰', fontsize=12)
axes[0, 1].set_ylabel('Im[G(Ï‰)]', fontsize=12)
axes[0, 1].set_title('ã‚°ãƒªãƒ¼ãƒ³é–¢æ•°ã®è™šéƒ¨', fontsize=12)
axes[0, 1].legend()

# ã‚¹ãƒšã‚¯ãƒˆãƒ«é–¢æ•°
axes[1, 0].plot(omega, A, 'g-', linewidth=2)
axes[1, 0].fill_between(omega, 0, A, alpha=0.3)
axes[1, 0].axvline(omega_0, color='red', linestyle='--', label=f'Ï‰â‚€={omega_0}')
axes[1, 0].grid(True, alpha=0.3)
axes[1, 0].set_xlabel('Ï‰', fontsize=12)
axes[1, 0].set_ylabel('A(Ï‰) = -2Im[G(Ï‰)]', fontsize=12)
axes[1, 0].set_title('ã‚¹ãƒšã‚¯ãƒˆãƒ«é–¢æ•°ï¼ˆçŠ¶æ…‹å¯†åº¦ï¼‰', fontsize=12)
axes[1, 0].legend()

# è¤‡ç´ å¹³é¢ã§ã®ã‚°ãƒªãƒ¼ãƒ³é–¢æ•°
omega_complex = np.linspace(-2, 2, 100) + 1j * np.linspace(-2, 2, 100)[:, np.newaxis]
G_complex = 1 / (omega_complex**2 - omega_0**2 + 1j*gamma*omega_complex)
G_abs = np.abs(G_complex)
G_abs = np.clip(G_abs, 0, 10)

im = axes[1, 1].contourf(omega_complex.real, omega_complex.imag, G_abs, 
                         levels=20, cmap='viridis')
# æ¥µã®ä½ç½®
pole1 = np.sqrt(omega_0**2 - 1j*gamma*omega_0)
pole2 = -pole1
axes[1, 1].plot([pole1.real, pole2.real], [pole1.imag, pole2.imag], 
               'r*', markersize=15, label='Poles')
axes[1, 1].axhline(0, color='white', linewidth=1, linestyle='--', alpha=0.5)
axes[1, 1].axvline(0, color='white', linewidth=1, linestyle='--', alpha=0.5)
axes[1, 1].set_xlabel('Re(Ï‰)', fontsize=12)
axes[1, 1].set_ylabel('Im(Ï‰)', fontsize=12)
axes[1, 1].set_title('|G(Ï‰)| in complex plane', fontsize=12)
axes[1, 1].legend()
plt.colorbar(im, ax=axes[1, 1])

plt.suptitle('æ ¼å­æŒ¯å‹•ã®ã‚°ãƒªãƒ¼ãƒ³é–¢æ•°è§£æ', fontsize=14)
plt.tight_layout()
plt.show()

# å’Œå‰‡ã®æ¤œè¨¼ï¼ˆKramers-Kronigé–¢ä¿‚ï¼‰
print("=== å’Œå‰‡ã®æ¤œè¨¼ ===")
# âˆ« A(Ï‰) dÏ‰ = -2
integral_A, _ = integrate.quad(spectral_function, 0, np.inf)
print(f"âˆ«[0,âˆ] A(Ï‰) dÏ‰ = {integral_A:.6f}")
print(f"ç†è«–å€¤: -2")
print(f"(ç¬¦å·ã¯å®šç¾©ã«ã‚ˆã‚‹)")

print("\næ ¼å­æŒ¯å‹•ã®ç‰©ç†:")
print("- ã‚°ãƒªãƒ¼ãƒ³é–¢æ•°ã®æ¥µ â†’ æ ¼å­æŒ¯å‹•ãƒ¢ãƒ¼ãƒ‰ï¼ˆãƒ•ã‚©ãƒãƒ³ï¼‰")
print("- ã‚¹ãƒšã‚¯ãƒˆãƒ«é–¢æ•° â†’ çŠ¶æ…‹å¯†åº¦")
print("- è¤‡ç´ å‘¨æ³¢æ•° â†’ æŒ¯å‹•ã®æ¸›è¡°")</code></pre>
                    </div>
                </section>

                <section class="chapter-section">
                    <h2>ğŸ“ ç« æœ«å•é¡Œ</h2>
                    <div class="exercise-box">
                        <h4>æ¼”ç¿’å•é¡Œ</h4>
                        <ol>
                            <li>$f(z) = \frac{e^z}{z^3}$ ã® $z=0$ å‘¨ã‚Šã®Laurentå±•é–‹ã‚’æ±‚ã‚ã‚ˆã€‚</li>
                            <li>$f(z) = \frac{1}{z(z-1)(z-2)}$ ã®ç•™æ•°ã‚’å…¨ã¦ã®ç‰¹ç•°ç‚¹ã§è¨ˆç®—ã›ã‚ˆã€‚</li>
                            <li>ç•™æ•°å®šç†ã‚’ä½¿ã£ã¦ $\int_{-\infty}^{\infty} \frac{dx}{1+x^4}$ ã‚’è¨ˆç®—ã›ã‚ˆã€‚</li>
                            <li>$\int_0^{2\pi} \frac{d\theta}{3 + 2\cos\theta}$ ã‚’ç•™æ•°å®šç†ã§è¨ˆç®—ã›ã‚ˆã€‚</li>
                        </ol>
                    </div>
                </section>

                <section class="chapter-section">
                    <h2>ğŸ”— å‚è€ƒæ–‡çŒ®</h2>
                    <ul class="reference-list">
                        <li>Churchill, R. V., & Brown, J. W. (2013). <em>Complex Variables and Applications</em>. McGraw-Hill.</li>
                        <li>Arfken, G. B., & Weber, H. J. (2005). <em>Mathematical Methods for Physicists</em>. Academic Press.</li>
                    </ul>
                </section>
            </article>

            <nav class="chapter-navigation">
                <a href="chapter-2.html" class="btn btn-secondary">â† ç¬¬2ç« ã¸</a>
                <a href="chapter-4.html" class="btn btn-primary">ç¬¬4ç« ã¸ â†’</a>
            </nav>
        </div>
    </main>

    <footer class="site-footer">
        <div class="container">
            <p>&copy; 2025 AI Terakoya. All rights reserved.</p>
        </div>
    </footer>
</body>
</html>
