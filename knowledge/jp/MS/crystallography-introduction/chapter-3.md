---
title: ç¬¬3ç« ï¼šãƒŸãƒ©ãƒ¼æŒ‡æ•°ã¨çµæ™¶é¢ãƒ»æ–¹å‘
chapter_title: ç¬¬3ç« ï¼šãƒŸãƒ©ãƒ¼æŒ‡æ•°ã¨çµæ™¶é¢ãƒ»æ–¹å‘
subtitle: çµæ™¶æ§‹é€ ã‚’è¨˜è¿°ã™ã‚‹æ™®éçš„ãªè¨˜æ³•ã‚’å­¦ã¶
reading_time: 28åˆ†
code_examples: 8
---

ğŸŒ JP | [ğŸ‡¬ğŸ‡§ EN](<../../../en/MS/crystallography-introduction/chapter-3.html>) | Last sync: 2025-11-16

[AIå¯ºå­å±‹ãƒˆãƒƒãƒ—](<../../index.html>) > [MS Dojo](<../index.html>) > [çµæ™¶å­¦å…¥é–€](<index.html>) > ç¬¬3ç«  

## å­¦ç¿’ç›®æ¨™

ã“ã®ç« ã‚’å­¦ã¶ã“ã¨ã§ã€ä»¥ä¸‹ã®çŸ¥è­˜ã¨ã‚¹ã‚­ãƒ«ã‚’ç¿’å¾—ã§ãã¾ã™ï¼š

  * **ãƒŸãƒ©ãƒ¼æŒ‡æ•° (hkl) ã®å®šç¾©** ã‚’ç†è§£ã—ã€çµæ™¶é¢ã‚’æ­£ç¢ºã«è¡¨è¨˜ã§ãã‚‹
  * **çµæ™¶æ–¹å‘ [uvw] ã®è¡¨è¨˜æ³•** ã‚’ç†è§£ã—ã€çµæ™¶å†…ã®ãƒ™ã‚¯ãƒˆãƒ«ã‚’è¨˜è¿°ã§ãã‚‹
  * **é¢é–“éš” d hkl ã®è¨ˆç®—**ã‚’å„çµæ™¶ç³»ã§å®Ÿè¡Œã§ãã‚‹
  * **å¯¾ç§°æ€§ã«ã‚ˆã‚‹ç­‰ä¾¡ãªé¢ãƒ»æ–¹å‘** ã‚’è­˜åˆ¥ã§ãã‚‹
  * **å®Ÿææ–™ã§ã®å¿œç”¨ä¾‹** ã‚’é€šã˜ã¦å®Ÿè·µçš„ç†è§£ã‚’æ·±ã‚ã‚‹

## 1\. ãƒŸãƒ©ãƒ¼æŒ‡æ•°ã¨ã¯ä½•ã‹

çµæ™¶å­¦ã«ãŠã„ã¦ã€**ãƒŸãƒ©ãƒ¼æŒ‡æ•°ï¼ˆMiller indicesï¼‰** ã¯çµæ™¶å†…ã®**é¢ã‚„æ–¹å‘ã‚’è¡¨ã™æ¨™æº–çš„ãªè¨˜æ³•** ã§ã™ã€‚ 1839å¹´ã«ã‚¤ã‚®ãƒªã‚¹ã®é‰±ç‰©å­¦è€…ã‚¦ã‚£ãƒªã‚¢ãƒ ãƒ»ãƒãƒ­ã‚¦ã‚ºãƒ»ãƒŸãƒ©ãƒ¼ï¼ˆWilliam Hallowes Millerï¼‰ã«ã‚ˆã£ã¦ææ¡ˆã•ã‚Œã¾ã—ãŸã€‚ 

### 1.1 ãªãœãƒŸãƒ©ãƒ¼æŒ‡æ•°ãŒå¿…è¦ã‹

çµæ™¶ä¸­ã«ã¯ç„¡é™ã®å¹³é¢ã¨æ–¹å‘ãŒå­˜åœ¨ã—ã¾ã™ã€‚ã“ã‚Œã‚‰ã‚’ä¸€æ„ã«ã€ã‹ã¤ç°¡æ½”ã«è¡¨ç¾ã™ã‚‹æ–¹æ³•ãŒå¿…è¦ã§ã™ï¼š

  * **æ™®éæ€§** ï¼šã©ã®çµæ™¶ç³»ã§ã‚‚å…±é€šã®è¨˜æ³•ã§æ‰±ãˆã‚‹
  * **ç°¡æ½”æ€§** ï¼š3ã¤ã®æ•´æ•° (h, k, l) ã§é¢ã‚’æŒ‡å®šã§ãã‚‹
  * **å¯¾ç§°æ€§ã®è¡¨ç¾** ï¼šçµæ™¶ã®å¯¾ç§°æ€§ã‚’åæ˜ ã—ãŸç­‰ä¾¡ãªé¢ã‚’è­˜åˆ¥ã§ãã‚‹
  * **Xç·šå›æŠ˜ã¨ã®å¯¾å¿œ** ï¼šå›æŠ˜ãƒ‘ã‚¿ãƒ¼ãƒ³ã®ãƒ”ãƒ¼ã‚¯ã¨ç›´æ¥å¯¾å¿œã™ã‚‹

#### è¨˜æ³•ã®ç´„æŸ

  * **(hkl)** ï¼šç‰¹å®šã®1ã¤ã®çµæ™¶é¢ã‚’è¡¨ã™
  * **{hkl}** ï¼šå¯¾ç§°æ€§ã«ã‚ˆã‚Šç­‰ä¾¡ãªã™ã¹ã¦ã®é¢ã®é›†åˆ
  * **[uvw]** ï¼šç‰¹å®šã®1ã¤ã®çµæ™¶æ–¹å‘ã‚’è¡¨ã™
  * **< uvw>**ï¼šå¯¾ç§°æ€§ã«ã‚ˆã‚Šç­‰ä¾¡ãªã™ã¹ã¦ã®æ–¹å‘ã®é›†åˆ
  * **è² ã®å€¤** ï¼šæ•°å­—ã®ä¸Šã«ãƒãƒ¼ã‚’å¼•ãï¼ˆä¾‹ï¼š\\(\bar{1}\\) ã¯ -1ï¼‰

### 1.2 ãƒŸãƒ©ãƒ¼æŒ‡æ•°ã®å®šç¾©

ãƒŸãƒ©ãƒ¼æŒ‡æ•° (hkl) ã¯ä»¥ä¸‹ã®æ‰‹é †ã§æ±‚ã‚ã‚‰ã‚Œã¾ã™ï¼š
    
    
    ```mermaid
    flowchart TD
                    A[çµæ™¶é¢ã¨3ã¤ã®çµæ™¶è»¸ã®äº¤ç‚¹ã‚’æ±‚ã‚ã‚‹] --> B[å„è»¸ã§ã®åˆ‡ç‰‡ã‚’æ ¼å­å®šæ•°ã§å‰²ã‚‹]
                    B --> C[å„å€¤ã®é€†æ•°ã‚’ã¨ã‚‹]
                    C --> D[æœ€å°å…¬å€æ•°ã‚’æ›ã‘ã¦æ•´æ•°åŒ–]
                    D --> E[ãƒŸãƒ©ãƒ¼æŒ‡æ•° hkl ã‚’å¾—ã‚‹]
    
                    style A fill:#e3f2fd
                    style B fill:#e3f2fd
                    style C fill:#fff3e0
                    style D fill:#fff3e0
                    style E fill:#e8f5e9
    ```

#### ä¾‹ï¼š(111)é¢ã®æ±‚ã‚æ–¹

  1. **åˆ‡ç‰‡** ï¼šaè»¸ã€bè»¸ã€cè»¸ã™ã¹ã¦ã§åˆ‡ç‰‡ãŒ1æ ¼å­å®šæ•°
  2. **æ ¼å­å®šæ•°ã§å‰²ã‚‹** ï¼š1/a, 1/b, 1/c = 1, 1, 1
  3. **é€†æ•°** ï¼š1/1, 1/1, 1/1 = 1, 1, 1
  4. **æ•´æ•°åŒ–** ï¼šã™ã§ã«æ•´æ•°ãªã®ã§ãã®ã¾ã¾
  5. **çµæœ** ï¼šãƒŸãƒ©ãƒ¼æŒ‡æ•°ã¯ **(111)**

#### ä¾‹ï¼š(200)é¢ã®æ±‚ã‚æ–¹

  1. **åˆ‡ç‰‡** ï¼šaè»¸ã§1/2ã€bè»¸ã¨cè»¸ã§ç„¡é™é ï¼ˆå¹³è¡Œï¼‰
  2. **æ ¼å­å®šæ•°ã§å‰²ã‚‹** ï¼š1/2, âˆ, âˆ
  3. **é€†æ•°** ï¼š2, 0, 0
  4. **çµæœ** ï¼šãƒŸãƒ©ãƒ¼æŒ‡æ•°ã¯ **(200)**

ã“ã‚Œã¯(100)é¢ã®2å€ã®å¯†åº¦ã§ä¸¦ã¶å¹³é¢ã§ã‚ã‚‹ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚

## 2\. Pythonã§ãƒŸãƒ©ãƒ¼æŒ‡æ•°ã‚’è¨ˆç®—ã™ã‚‹

### 2.1 åˆ‡ç‰‡ã‹ã‚‰ãƒŸãƒ©ãƒ¼æŒ‡æ•°ã‚’æ±‚ã‚ã‚‹

#### ã‚³ãƒ¼ãƒ‰ä¾‹1ï¼šãƒŸãƒ©ãƒ¼æŒ‡æ•°ã®è¨ˆç®—

çµæ™¶è»¸ã¨ã®åˆ‡ç‰‡ã‹ã‚‰ãƒŸãƒ©ãƒ¼æŒ‡æ•°ã‚’è‡ªå‹•è¨ˆç®—ã™ã‚‹ãƒ—ãƒ­ã‚°ãƒ©ãƒ ï¼š
    
    
    import numpy as np
    from fractions import Fraction
    
    def calculate_miller_indices(intercepts):
        """
        åˆ‡ç‰‡ã‹ã‚‰ãƒŸãƒ©ãƒ¼æŒ‡æ•°ã‚’è¨ˆç®—ã™ã‚‹
    
        Parameters:
        -----------
        intercepts : tuple of float
            (aè»¸åˆ‡ç‰‡, bè»¸åˆ‡ç‰‡, cè»¸åˆ‡ç‰‡)
            ç„¡é™å¤§ã®å ´åˆã¯ np.inf ã‚’ä½¿ç”¨
    
        Returns:
        --------
        tuple : ãƒŸãƒ©ãƒ¼æŒ‡æ•° (h, k, l)
        """
        # é€†æ•°ã‚’è¨ˆç®—ï¼ˆç„¡é™å¤§ã®é€†æ•°ã¯0ï¼‰
        reciprocals = []
        for intercept in intercepts:
            if np.isinf(intercept):
                reciprocals.append(0)
            else:
                reciprocals.append(1 / intercept)
    
        # åˆ†æ•°ã¨ã—ã¦æ‰±ã„ã€æœ€å°å…¬å€æ•°ã‚’è¦‹ã¤ã‘ã‚‹
        fractions = [Fraction(r).limit_denominator(100) for r in reciprocals]
    
        # åˆ†æ¯ã®æœ€å°å…¬å€æ•°ã‚’è¨ˆç®—
        denominators = [f.denominator for f in fractions]
        lcm = np.lcm.reduce(denominators)
    
        # æ•´æ•°åŒ–
        h, k, l = [int(f * lcm) for f in fractions]
    
        # æœ€å¤§å…¬ç´„æ•°ã§ç°¡ç´„åŒ–
        gcd = np.gcd.reduce([abs(h), abs(k), abs(l)])
        if gcd > 0:
            h, k, l = h // gcd, k // gcd, l // gcd
    
        return (h, k, l)
    
    # ãƒ†ã‚¹ãƒˆä¾‹
    print("=== ãƒŸãƒ©ãƒ¼æŒ‡æ•°ã®è¨ˆç®— ===\n")
    
    # (111)é¢ï¼šã™ã¹ã¦ã®è»¸ã§åˆ‡ç‰‡ãŒ1
    intercepts_111 = (1, 1, 1)
    hkl = calculate_miller_indices(intercepts_111)
    print(f"åˆ‡ç‰‡ {intercepts_111} â†’ ãƒŸãƒ©ãƒ¼æŒ‡æ•° {hkl}")
    
    # (100)é¢ï¼šaè»¸ã®ã¿ã§åˆ‡ç‰‡ã€ä»–ã¯å¹³è¡Œ
    intercepts_100 = (1, np.inf, np.inf)
    hkl = calculate_miller_indices(intercepts_100)
    print(f"åˆ‡ç‰‡ {intercepts_100} â†’ ãƒŸãƒ©ãƒ¼æŒ‡æ•° {hkl}")
    
    # (110)é¢ï¼šaè»¸ã¨bè»¸ã§åˆ‡ç‰‡ã€cè»¸ã«å¹³è¡Œ
    intercepts_110 = (1, 1, np.inf)
    hkl = calculate_miller_indices(intercepts_110)
    print(f"åˆ‡ç‰‡ {intercepts_110} â†’ ãƒŸãƒ©ãƒ¼æŒ‡æ•° {hkl}")
    
    # (210)é¢ï¼šaè»¸ã§1/2ã€bè»¸ã§1ã®åˆ‡ç‰‡
    intercepts_210 = (0.5, 1, np.inf)
    hkl = calculate_miller_indices(intercepts_210)
    print(f"åˆ‡ç‰‡ {intercepts_210} â†’ ãƒŸãƒ©ãƒ¼æŒ‡æ•° {hkl}")
    
    # (123)é¢ï¼šç•°ãªã‚‹åˆ‡ç‰‡
    intercepts_123 = (1, 0.5, 0.333333)
    hkl = calculate_miller_indices(intercepts_123)
    print(f"åˆ‡ç‰‡ {intercepts_123} â†’ ãƒŸãƒ©ãƒ¼æŒ‡æ•° {hkl}")
    

#### å®Ÿè¡Œçµæœ
    
    
    === ãƒŸãƒ©ãƒ¼æŒ‡æ•°ã®è¨ˆç®— ===
    
    åˆ‡ç‰‡ (1, 1, 1) â†’ ãƒŸãƒ©ãƒ¼æŒ‡æ•° (1, 1, 1)
    åˆ‡ç‰‡ (1, inf, inf) â†’ ãƒŸãƒ©ãƒ¼æŒ‡æ•° (1, 0, 0)
    åˆ‡ç‰‡ (1, 1, inf) â†’ ãƒŸãƒ©ãƒ¼æŒ‡æ•° (1, 1, 0)
    åˆ‡ç‰‡ (0.5, 1, inf) â†’ ãƒŸãƒ©ãƒ¼æŒ‡æ•° (2, 1, 0)
    åˆ‡ç‰‡ (1, 0.5, 0.333333) â†’ ãƒŸãƒ©ãƒ¼æŒ‡æ•° (1, 2, 3)

### 2.2 ä¸»è¦ãªä½æŒ‡æ•°é¢ã®å¯è¦–åŒ–

#### ã‚³ãƒ¼ãƒ‰ä¾‹2ï¼šç«‹æ–¹æ™¶ã®ä¸»è¦é¢ã‚’3Dè¡¨ç¤º

ä»£è¡¨çš„ãªçµæ™¶é¢ã‚’å¯è¦–åŒ–ã—ã¦ã€ãƒŸãƒ©ãƒ¼æŒ‡æ•°ã®æ„å‘³ã‚’ç†è§£ã—ã¾ã™ï¼š
    
    
    import numpy as np
    import matplotlib.pyplot as plt
    from mpl_toolkits.mplot3d import Axes3D
    from mpl_toolkits.mplot3d.art3d import Poly3DCollection
    
    def plot_lattice_plane(hkl, ax, color='cyan', alpha=0.6):
        """
        ãƒŸãƒ©ãƒ¼æŒ‡æ•°ã§æŒ‡å®šã•ã‚ŒãŸçµæ™¶é¢ã‚’æç”»
    
        Parameters:
        -----------
        hkl : tuple
            ãƒŸãƒ©ãƒ¼æŒ‡æ•° (h, k, l)
        ax : Axes3D
            matplotlib ã®3Dè»¸
        color : str
            é¢ã®è‰²
        alpha : float
            é€æ˜åº¦
        """
        h, k, l = hkl
    
        # åˆ‡ç‰‡ã‚’è¨ˆç®—ï¼ˆ0ã®å ´åˆã¯å¤§ããªå€¤ã«è¨­å®šï¼‰
        intercepts = []
        for index in [h, k, l]:
            if index == 0:
                intercepts.append(10)  # ç„¡é™å¤§ã®ä»£ã‚ã‚Šã«å¤§ããªå€¤
            else:
                intercepts.append(1 / index)
    
        # é¢ã‚’æ§‹æˆã™ã‚‹é ‚ç‚¹ã‚’è¨ˆç®—
        vertices = []
    
        # ã‚±ãƒ¼ã‚¹ã”ã¨ã«é ‚ç‚¹ã‚’è¨­å®š
        if h != 0 and k != 0 and l != 0:
            # (111)ã‚¿ã‚¤ãƒ—ï¼š3ã¤ã®åˆ‡ç‰‡ã‚’æŒã¤
            vertices = [
                [intercepts[0], 0, 0],
                [0, intercepts[1], 0],
                [0, 0, intercepts[2]]
            ]
        elif h != 0 and k != 0 and l == 0:
            # (110)ã‚¿ã‚¤ãƒ—ï¼š2ã¤ã®åˆ‡ç‰‡ã€cè»¸ã«å¹³è¡Œ
            vertices = [
                [intercepts[0], 0, 0],
                [intercepts[0], 0, 2],
                [0, intercepts[1], 2],
                [0, intercepts[1], 0]
            ]
        elif h != 0 and k == 0 and l == 0:
            # (100)ã‚¿ã‚¤ãƒ—ï¼š1ã¤ã®åˆ‡ç‰‡ã€ä»–ã®è»¸ã«å¹³è¡Œ
            vertices = [
                [intercepts[0], 0, 0],
                [intercepts[0], 2, 0],
                [intercepts[0], 2, 2],
                [intercepts[0], 0, 2]
            ]
    
        # é¢ã‚’æç”»
        if len(vertices) > 0:
            poly = Poly3DCollection([vertices], alpha=alpha, facecolor=color, edgecolor='black', linewidth=2)
            ax.add_collection3d(poly)
    
    def plot_crystal_axes():
        """ç«‹æ–¹æ™¶ã®çµæ™¶è»¸ã¨ä¸»è¦é¢ã‚’è¡¨ç¤º"""
        fig = plt.figure(figsize=(15, 5))
    
        planes = [
            ((1, 0, 0), 'cyan', '(100)é¢'),
            ((1, 1, 0), 'yellow', '(110)é¢'),
            ((1, 1, 1), 'magenta', '(111)é¢')
        ]
    
        for idx, (hkl, color, title) in enumerate(planes):
            ax = fig.add_subplot(1, 3, idx + 1, projection='3d')
    
            # çµæ™¶è»¸ã‚’æç”»
            ax.quiver(0, 0, 0, 1.5, 0, 0, color='red', arrow_length_ratio=0.1, linewidth=2, label='aè»¸')
            ax.quiver(0, 0, 0, 0, 1.5, 0, color='green', arrow_length_ratio=0.1, linewidth=2, label='bè»¸')
            ax.quiver(0, 0, 0, 0, 0, 1.5, color='blue', arrow_length_ratio=0.1, linewidth=2, label='cè»¸')
    
            # çµæ™¶é¢ã‚’æç”»
            plot_lattice_plane(hkl, ax, color=color, alpha=0.6)
    
            # è»¸ãƒ©ãƒ™ãƒ«
            ax.set_xlabel('a', fontsize=12, fontweight='bold')
            ax.set_ylabel('b', fontsize=12, fontweight='bold')
            ax.set_zlabel('c', fontsize=12, fontweight='bold')
    
            ax.set_xlim([0, 1.5])
            ax.set_ylim([0, 1.5])
            ax.set_zlim([0, 1.5])
    
            ax.set_title(title, fontsize=14, fontweight='bold')
            ax.legend(loc='upper left', fontsize=8)
    
            # ã‚°ãƒªãƒƒãƒ‰ã‚’è¿½åŠ 
            ax.grid(True, alpha=0.3)
    
        plt.tight_layout()
        plt.savefig('miller_indices_planes.png', dpi=150, bbox_inches='tight')
        plt.show()
        print("ä¸»è¦ãªçµæ™¶é¢ã®å¯è¦–åŒ–ã‚’ä¿å­˜ã—ã¾ã—ãŸ: miller_indices_planes.png")
    
    # å®Ÿè¡Œ
    plot_crystal_axes()
    

## 3\. é¢é–“éš” dhkl ã®è¨ˆç®—

ãƒŸãƒ©ãƒ¼æŒ‡æ•° (hkl) ã§æŒ‡å®šã•ã‚Œã‚‹çµæ™¶é¢ã®**é¢é–“éš” d hkl**ã¯ã€ Xç·šå›æŠ˜å®Ÿé¨“ã§è¦³æ¸¬ã•ã‚Œã‚‹ãƒ–ãƒ©ãƒƒã‚°ãƒ”ãƒ¼ã‚¯ã®ä½ç½®ã‚’æ±ºå®šã™ã‚‹é‡è¦ãªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã§ã™ã€‚ 

### 3.1 ç«‹æ–¹æ™¶ç³»ã§ã®é¢é–“éš”

ç«‹æ–¹æ™¶ï¼ˆa = b = cã€Î± = Î² = Î³ = 90Â°ï¼‰ã§ã¯ã€é¢é–“éš”ã¯éå¸¸ã«ç°¡æ½”ãªå¼ã§è¡¨ã•ã‚Œã¾ã™ï¼š

$$ d_{hkl} = \frac{a}{\sqrt{h^2 + k^2 + l^2}} $$ 

ã“ã“ã§ã€aã¯æ ¼å­å®šæ•°ã€h, k, lã¯ãƒŸãƒ©ãƒ¼æŒ‡æ•°ã§ã™ã€‚

#### ã‚³ãƒ¼ãƒ‰ä¾‹3ï¼šç«‹æ–¹æ™¶ã®é¢é–“éš”è¨ˆç®—
    
    
    import numpy as np
    import matplotlib.pyplot as plt
    
    def cubic_d_spacing(a, h, k, l):
        """
        ç«‹æ–¹æ™¶ç³»ã®é¢é–“éš”ã‚’è¨ˆç®—
    
        Parameters:
        -----------
        a : float
            æ ¼å­å®šæ•° (Ã…)
        h, k, l : int
            ãƒŸãƒ©ãƒ¼æŒ‡æ•°
    
        Returns:
        --------
        float : é¢é–“éš” d_hkl (Ã…)
        """
        return a / np.sqrt(h**2 + k**2 + l**2)
    
    # ã‚·ãƒªã‚³ãƒ³ï¼ˆç«‹æ–¹æ™¶ã€a = 5.431 Ã…ï¼‰ã§ã®è¨ˆç®—
    a_Si = 5.431
    
    print("=== ã‚·ãƒªã‚³ãƒ³ï¼ˆSiï¼‰ã®é¢é–“éš” ===")
    print(f"æ ¼å­å®šæ•° a = {a_Si} Ã…\n")
    
    # ä¸»è¦ãªé¢ã®é¢é–“éš”ã‚’è¨ˆç®—
    planes = [
        (1, 0, 0), (1, 1, 0), (1, 1, 1),
        (2, 0, 0), (2, 2, 0), (3, 1, 1),
        (2, 2, 2), (4, 0, 0), (3, 3, 1)
    ]
    
    results = []
    for hkl in planes:
        h, k, l = hkl
        d = cubic_d_spacing(a_Si, h, k, l)
        results.append((hkl, d))
        print(f"({h}{k}{l})é¢: d = {d:.4f} Ã…")
    
    # ã‚°ãƒ©ãƒ•ã§å¯è¦–åŒ–
    fig, ax = plt.subplots(figsize=(12, 6))
    
    hkl_labels = [f"({h}{k}{l})" for (h, k, l), d in results]
    d_values = [d for hkl, d in results]
    
    bars = ax.bar(range(len(results)), d_values, color='skyblue', edgecolor='navy', linewidth=1.5)
    ax.set_xticks(range(len(results)))
    ax.set_xticklabels(hkl_labels, rotation=45, ha='right')
    ax.set_ylabel('é¢é–“éš” d (Ã…)', fontsize=12, fontweight='bold')
    ax.set_xlabel('ãƒŸãƒ©ãƒ¼æŒ‡æ•°', fontsize=12, fontweight='bold')
    ax.set_title('ã‚·ãƒªã‚³ãƒ³ï¼ˆSiï¼‰ã®çµæ™¶é¢ã”ã¨ã®é¢é–“éš”', fontsize=14, fontweight='bold')
    ax.grid(axis='y', alpha=0.3)
    
    # å€¤ã‚’ãƒãƒ¼ã®ä¸Šã«è¡¨ç¤º
    for i, (bar, d) in enumerate(zip(bars, d_values)):
        ax.text(bar.get_x() + bar.get_width()/2, bar.get_height() + 0.05,
                f'{d:.3f}', ha='center', va='bottom', fontsize=9)
    
    plt.tight_layout()
    plt.savefig('si_d_spacing.png', dpi=150, bbox_inches='tight')
    plt.show()
    print("\nã‚°ãƒ©ãƒ•ã‚’ä¿å­˜ã—ã¾ã—ãŸ: si_d_spacing.png")
    

### 3.2 æ­£æ–¹æ™¶ç³»ã§ã®é¢é–“éš”

æ­£æ–¹æ™¶ï¼ˆa = b â‰  cã€Î± = Î² = Î³ = 90Â°ï¼‰ã§ã¯ã€cè»¸æ–¹å‘ã®æ ¼å­å®šæ•°ãŒç•°ãªã‚‹ãŸã‚å¼ãŒå¤‰ã‚ã‚Šã¾ã™ï¼š

$$ d_{hkl} = \frac{1}{\sqrt{\frac{h^2 + k^2}{a^2} + \frac{l^2}{c^2}}} $$ 

#### ã‚³ãƒ¼ãƒ‰ä¾‹4ï¼šæ­£æ–¹æ™¶ã®é¢é–“éš”è¨ˆç®—
    
    
    def tetragonal_d_spacing(a, c, h, k, l):
        """
        æ­£æ–¹æ™¶ç³»ã®é¢é–“éš”ã‚’è¨ˆç®—
    
        Parameters:
        -----------
        a : float
            aè»¸ï¼ˆ= bè»¸ï¼‰ã®æ ¼å­å®šæ•° (Ã…)
        c : float
            cè»¸ã®æ ¼å­å®šæ•° (Ã…)
        h, k, l : int
            ãƒŸãƒ©ãƒ¼æŒ‡æ•°
    
        Returns:
        --------
        float : é¢é–“éš” d_hkl (Ã…)
        """
        return 1 / np.sqrt((h**2 + k**2) / a**2 + l**2 / c**2)
    
    # TiO2 ãƒ«ãƒãƒ«ï¼ˆæ­£æ–¹æ™¶ã€a = 4.594 Ã…, c = 2.958 Ã…ï¼‰
    a_TiO2 = 4.594
    c_TiO2 = 2.958
    
    print("=== TiO2ï¼ˆãƒ«ãƒãƒ«ï¼‰ã®é¢é–“éš” ===")
    print(f"æ ¼å­å®šæ•° a = {a_TiO2} Ã…, c = {c_TiO2} Ã…")
    print(f"c/a æ¯” = {c_TiO2/a_TiO2:.3f}\n")
    
    planes_tetragonal = [
        (1, 0, 0), (0, 0, 1), (1, 1, 0),
        (1, 0, 1), (1, 1, 1), (2, 0, 0),
        (2, 1, 0), (2, 1, 1), (2, 2, 0)
    ]
    
    # æ¯”è¼ƒï¼šç«‹æ–¹æ™¶ã¨ä»®å®šã—ãŸå ´åˆï¼ˆèª¤ã£ãŸè¨ˆç®—ï¼‰
    print("æ­£æ–¹æ™¶ã¨ã—ã¦æ­£ã—ãè¨ˆç®—ã—ãŸå ´åˆ vs ç«‹æ–¹æ™¶ã¨èª¤ã£ã¦ä»®å®šã—ãŸå ´åˆ:\n")
    for hkl in planes_tetragonal[:5]:
        h, k, l = hkl
        d_correct = tetragonal_d_spacing(a_TiO2, c_TiO2, h, k, l)
        d_wrong = cubic_d_spacing(a_TiO2, h, k, l)  # èª¤ã£ãŸä»®å®š
        error = abs(d_correct - d_wrong) / d_correct * 100
    
        print(f"({h}{k}{l})é¢:")
        print(f"  æ­£ã—ã„ d = {d_correct:.4f} Ã…")
        print(f"  èª¤ã£ãŸ d = {d_wrong:.4f} Ã… (èª¤å·®: {error:.2f}%)\n")
    

#### é‡è¦ãªæ³¨æ„ç‚¹

çµæ™¶ç³»ã‚’èª¤ã£ã¦ä»®å®šã™ã‚‹ã¨ã€é¢é–“éš”ã®è¨ˆç®—ãŒå¤§ããé–“é•ã„ã¾ã™ã€‚ ç‰¹ã«cè»¸ãŒå¤§ããç•°ãªã‚‹æ­£æ–¹æ™¶ã‚’ç«‹æ–¹æ™¶ã¨æ‰±ã†ã¨ã€(001)é¢ãªã©ã®cè»¸ã«é–¢ã‚ã‚‹é¢ã§é¡•è‘—ãªèª¤å·®ãŒç”Ÿã˜ã¾ã™ã€‚ 

### 3.3 å…­æ–¹æ™¶ç³»ã§ã®é¢é–“éš”

å…­æ–¹æ™¶ï¼ˆa = b â‰  cã€Î± = Î² = 90Â°ã€Î³ = 120Â°ï¼‰ã¯ã€ã—ã°ã—ã°**4è»¸æŒ‡æ•° (hkil)** ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚ ã“ã“ã§ã€i = -(h+k) ã¨ã„ã†é–¢ä¿‚ãŒã‚ã‚Šã¾ã™ã€‚ 

$$ d_{hkl} = \frac{1}{\sqrt{\frac{4}{3}\frac{h^2 + hk + k^2}{a^2} + \frac{l^2}{c^2}}} $$ 

#### ã‚³ãƒ¼ãƒ‰ä¾‹5ï¼šå…­æ–¹æ™¶ã®é¢é–“éš”è¨ˆç®—
    
    
    def hexagonal_d_spacing(a, c, h, k, l):
        """
        å…­æ–¹æ™¶ç³»ã®é¢é–“éš”ã‚’è¨ˆç®—
    
        Parameters:
        -----------
        a : float
            aè»¸ï¼ˆ= bè»¸ï¼‰ã®æ ¼å­å®šæ•° (Ã…)
        c : float
            cè»¸ã®æ ¼å­å®šæ•° (Ã…)
        h, k, l : int
            ãƒŸãƒ©ãƒ¼æŒ‡æ•°ï¼ˆ3è»¸è¡¨è¨˜ï¼‰
    
        Returns:
        --------
        float : é¢é–“éš” d_hkl (Ã…)
        """
        return 1 / np.sqrt((4/3) * (h**2 + h*k + k**2) / a**2 + l**2 / c**2)
    
    def miller_to_miller_bravais(h, k, l):
        """
        3è»¸ãƒŸãƒ©ãƒ¼æŒ‡æ•°ã‚’4è»¸ãƒŸãƒ©ãƒ¼ãƒ»ãƒ–ãƒ©ãƒ™ãƒ¼æŒ‡æ•°ã«å¤‰æ›
    
        Parameters:
        -----------
        h, k, l : int
            3è»¸ãƒŸãƒ©ãƒ¼æŒ‡æ•°
    
        Returns:
        --------
        tuple : 4è»¸æŒ‡æ•° (h, k, i, l) ãŸã ã— i = -(h+k)
        """
        i = -(h + k)
        return (h, k, i, l)
    
    # Î±-Al2O3ï¼ˆã‚³ãƒ©ãƒ³ãƒ€ãƒ ã€å…­æ–¹æ™¶ã€a = 4.759 Ã…, c = 12.991 Ã…ï¼‰
    a_Al2O3 = 4.759
    c_Al2O3 = 12.991
    
    print("=== Î±-Al2O3ï¼ˆã‚³ãƒ©ãƒ³ãƒ€ãƒ ï¼‰ã®é¢é–“éš” ===")
    print(f"æ ¼å­å®šæ•° a = {a_Al2O3} Ã…, c = {c_Al2O3} Ã…")
    print(f"c/a æ¯” = {c_Al2O3/a_Al2O3:.3f}\n")
    
    planes_hexagonal = [
        (1, 0, 0), (0, 0, 1), (1, 1, 0),
        (1, 0, 1), (1, 1, 2), (2, 0, 0),
        (1, 0, 4), (2, 1, 0), (0, 0, 6)
    ]
    
    print(f"{'3è»¸ (hkl)':<15} {'4è»¸ (hkil)':<20} {'d (Ã…)':<10}")
    print("-" * 50)
    
    for hkl in planes_hexagonal:
        h, k, l = hkl
        d = hexagonal_d_spacing(a_Al2O3, c_Al2O3, h, k, l)
        hkil = miller_to_miller_bravais(h, k, l)
    
        # è² ã®å€¤ã‚’è¡¨ç¤º
        hkil_str = "("
        for idx in hkil:
            if idx < 0:
                hkil_str += f"{idx}"
            else:
                hkil_str += f"{idx}"
        hkil_str += ")"
    
        print(f"({h}{k}{l}){'':<12} {hkil_str:<20} {d:.4f}")
    

#### 4è»¸æŒ‡æ•°ã®åˆ©ç‚¹

å…­æ–¹æ™¶ã§ã¯4è»¸æŒ‡æ•° (hkil) ã‚’ä½¿ã†ã¨ã€çµæ™¶ã®6å›å¯¾ç§°æ€§ãŒè¨˜æ³•ã«åæ˜ ã•ã‚Œã¾ã™ã€‚ ä¾‹ãˆã°ã€{10\\(\bar{1}\\)0}ã¯6ã¤ã®ç­‰ä¾¡ãªé¢ã‚’è¡¨ã—ã€ã“ã‚ŒãŒ4è»¸è¡¨è¨˜ã§æ˜ç¢ºã«ãªã‚Šã¾ã™ã€‚ 

## 4\. ç­‰ä¾¡ãªé¢ã¨æ–¹å‘ï¼ˆå¯¾ç§°æ€§ï¼‰

çµæ™¶ã®å¯¾ç§°æ€§ã«ã‚ˆã‚Šã€çµæ™¶å­¦çš„ã«**ç­‰ä¾¡ãªé¢ã‚„æ–¹å‘** ãŒå­˜åœ¨ã—ã¾ã™ã€‚ ã“ã‚Œã‚‰ã‚’ã¾ã¨ã‚ã¦è¡¨è¨˜ã™ã‚‹ãŸã‚ã«ã€æ³¢æ‹¬å¼§ {hkl} ã‚„å±±æ‹¬å¼§ <uvw> ã‚’ä½¿ã„ã¾ã™ã€‚ 

### 4.1 ç«‹æ–¹æ™¶ã®ç­‰ä¾¡ãªé¢

ç«‹æ–¹æ™¶ã§ã¯ã€ä»¥ä¸‹ã®ã‚ˆã†ãªç­‰ä¾¡é–¢ä¿‚ãŒã‚ã‚Šã¾ã™ï¼š

è¡¨è¨˜ | æ„å‘³ | ä¾‹ï¼š{100}ã®ç­‰ä¾¡ãªé¢  
---|---|---  
**{100}** | ç­‰ä¾¡ãªé¢ã®é›†åˆ | (100), (010), (001), (\\(\bar{1}\\)00), (0\\(\bar{1}\\)0), (00\\(\bar{1}\\))  
**{110}** | ç­‰ä¾¡ãªé¢ã®é›†åˆ | (110), (101), (011), (\\(\bar{1}\\)10), (\\(\bar{1}\\)0\\(\bar{1}\\)), ãªã©12é¢  
**{111}** | ç­‰ä¾¡ãªé¢ã®é›†åˆ | (111), (\\(\bar{1}\\)11), (1\\(\bar{1}\\)1), ãªã©8é¢  
  
#### ã‚³ãƒ¼ãƒ‰ä¾‹6ï¼šç­‰ä¾¡ãªé¢ã®ç”Ÿæˆ
    
    
    from itertools import permutations, product
    
    def generate_equivalent_planes(h, k, l, crystal_system='cubic'):
        """
        å¯¾ç§°æ€§ã‚’è€ƒæ…®ã—ã¦ç­‰ä¾¡ãªé¢ã‚’ã™ã¹ã¦ç”Ÿæˆ
    
        Parameters:
        -----------
        h, k, l : int
            åŸºæº–ã¨ãªã‚‹ãƒŸãƒ©ãƒ¼æŒ‡æ•°
        crystal_system : str
            çµæ™¶ç³» ('cubic', 'tetragonal', 'hexagonal')
    
        Returns:
        --------
        set : ç­‰ä¾¡ãªé¢ã®é›†åˆ
        """
        planes = set()
    
        if crystal_system == 'cubic':
            # ç«‹æ–¹æ™¶ï¼šç¬¦å·ã¨ç½®æ›ã®å…¨çµ„ã¿åˆã‚ã›
            for perm in permutations([abs(h), abs(k), abs(l)]):
                for signs in product([1, -1], repeat=3):
                    plane = tuple(s * p for s, p in zip(signs, perm))
                    if plane != (0, 0, 0):  # (000)ã¯é™¤å¤–
                        planes.add(plane)
    
        elif crystal_system == 'tetragonal':
            # æ­£æ–¹æ™¶ï¼ša, bè»¸ã¯ç­‰ä¾¡ã€cè»¸ã¯ç‹¬ç«‹
            # h, k ã®ç½®æ›ã¨ç¬¦å·å¤‰æ›´ã®ã¿
            for h_sign, k_sign, l_sign in product([1, -1], repeat=3):
                planes.add((h_sign * h, k_sign * k, l_sign * l))
                planes.add((k_sign * k, h_sign * h, l_sign * l))  # h, k ã®ç½®æ›
    
        elif crystal_system == 'hexagonal':
            # å…­æ–¹æ™¶ï¼šã‚ˆã‚Šè¤‡é›‘ãªå¯¾ç§°æ€§ï¼ˆç°¡ç•¥ç‰ˆï¼‰
            # 6å›å›è»¢å¯¾ç§°æ€§ã‚’è€ƒæ…®
            for l_sign in [1, -1]:
                planes.add((h, k, l_sign * l))
                planes.add((k, -(h+k), l_sign * l))
                planes.add((-(h+k), h, l_sign * l))
    
        return sorted(planes)
    
    # ç«‹æ–¹æ™¶ã§ã®ç­‰ä¾¡ãªé¢
    print("=== ç«‹æ–¹æ™¶ã®ç­‰ä¾¡ãªé¢ ===\n")
    
    for base_plane in [(1, 0, 0), (1, 1, 0), (1, 1, 1)]:
        h, k, l = base_plane
        equiv = generate_equivalent_planes(h, k, l, 'cubic')
        print(f"{{{h}{k}{l}}} ã®ç­‰ä¾¡ãªé¢ ({len(equiv)} å€‹):")
    
        # è¦‹ã‚„ã™ãæ•´å½¢ã—ã¦è¡¨ç¤º
        for i in range(0, len(equiv), 6):
            planes_str = ', '.join([f"({p[0]:2}{p[1]:2}{p[2]:2})" for p in equiv[i:i+6]])
            print(f"  {planes_str}")
        print()
    
    # æ­£æ–¹æ™¶ã§ã®ç­‰ä¾¡ãªé¢
    print("=== æ­£æ–¹æ™¶ã®ç­‰ä¾¡ãªé¢ ===\n")
    base_plane = (1, 1, 0)
    equiv_tetra = generate_equivalent_planes(*base_plane, 'tetragonal')
    print(f"{{{base_plane[0]}{base_plane[1]}{base_plane[2]}}} ã®ç­‰ä¾¡ãªé¢ï¼ˆæ­£æ–¹æ™¶ï¼‰({len(equiv_tetra)} å€‹):")
    for plane in equiv_tetra:
        print(f"  ({plane[0]:2}{plane[1]:2}{plane[2]:2})")
    

### 4.2 çµæ™¶æ–¹å‘ [uvw] ã®è¡¨è¨˜

çµæ™¶æ–¹å‘ã¯**[uvw]** ã§è¡¨ã•ã‚Œã€åŸç‚¹ã‹ã‚‰åº§æ¨™ (uÂ·a, vÂ·b, wÂ·c) ã¸ã®**ãƒ™ã‚¯ãƒˆãƒ«** ã‚’æ„å‘³ã—ã¾ã™ã€‚ 

  * **[100]** ï¼šaè»¸æ–¹å‘
  * **[110]** ï¼šaè»¸ã¨bè»¸ã®å¯¾è§’ç·šæ–¹å‘
  * **[111]** ï¼šä½“å¯¾è§’ç·šæ–¹å‘
  * **< 100>**ï¼šç­‰ä¾¡ãªæ–¹å‘ã™ã¹ã¦ï¼ˆ[100], [010], [001], ãªã©ï¼‰

#### é¢ã¨æ–¹å‘ã®é–¢ä¿‚

**ç«‹æ–¹æ™¶** ã§ã¯ã€(hkl)é¢ã«å‚ç›´ãªæ–¹å‘ã¯[hkl]ã«ãªã‚Šã¾ã™ã€‚ ãŸã ã—ã€ã“ã‚Œã¯ç«‹æ–¹æ™¶ç‰¹æœ‰ã®æ€§è³ªã§ã€ä»–ã®çµæ™¶ç³»ã§ã¯ä¸€èˆ¬ã«æˆã‚Šç«‹ã¡ã¾ã›ã‚“ã€‚ 

#### ã‚³ãƒ¼ãƒ‰ä¾‹7ï¼šçµæ™¶æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«ã®å¯è¦–åŒ–
    
    
    def plot_crystal_directions():
        """ç«‹æ–¹æ™¶ã®ä¸»è¦ãªçµæ™¶æ–¹å‘ã‚’å¯è¦–åŒ–"""
        fig = plt.figure(figsize=(15, 5))
    
        directions = [
            ([1, 0, 0], 'red', '[100]'),
            ([1, 1, 0], 'green', '[110]'),
            ([1, 1, 1], 'blue', '[111]')
        ]
    
        for idx, (uvw, color, title) in enumerate(directions):
            ax = fig.add_subplot(1, 3, idx + 1, projection='3d')
    
            # ç«‹æ–¹ä½“ã®æ ã‚’æç”»
            r = [0, 1]
            for s, e in combinations(np.array(list(product(r, r, r))), 2):
                if np.sum(np.abs(s - e)) == 1:
                    ax.plot3D(*zip(s, e), color='gray', alpha=0.3, linewidth=1)
    
            # æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«ã‚’æç”»
            ax.quiver(0, 0, 0, uvw[0], uvw[1], uvw[2],
                     color=color, arrow_length_ratio=0.15, linewidth=3,
                     label=f'{title} æ–¹å‘')
    
            # è»¸ãƒ©ãƒ™ãƒ«
            ax.set_xlabel('a', fontsize=12, fontweight='bold')
            ax.set_ylabel('b', fontsize=12, fontweight='bold')
            ax.set_zlabel('c', fontsize=12, fontweight='bold')
    
            ax.set_xlim([0, 1.5])
            ax.set_ylim([0, 1.5])
            ax.set_zlim([0, 1.5])
    
            ax.set_title(title + ' çµæ™¶æ–¹å‘', fontsize=14, fontweight='bold')
            ax.legend(loc='upper left')
            ax.grid(True, alpha=0.3)
    
        plt.tight_layout()
        plt.savefig('crystal_directions.png', dpi=150, bbox_inches='tight')
        plt.show()
        print("çµæ™¶æ–¹å‘ã®å¯è¦–åŒ–ã‚’ä¿å­˜ã—ã¾ã—ãŸ: crystal_directions.png")
    
    from itertools import combinations, product
    
    # å®Ÿè¡Œ
    plot_crystal_directions()
    

## 5\. å®Ÿææ–™ã§ã®å¿œç”¨

ãƒŸãƒ©ãƒ¼æŒ‡æ•°ã¯ææ–™ç§‘å­¦ã®ã‚ã‚‰ã‚†ã‚‹åˆ†é‡ã§ä½¿ã‚ã‚Œã¾ã™ã€‚ ã“ã“ã§ã¯ã€å®Ÿéš›ã®ææ–™ã‚’ä¾‹ã«é¢é–“éš”ã®è¨ˆç®—ã¨å¿œç”¨ã‚’å­¦ã³ã¾ã™ã€‚ 

### 5.1 Xç·šå›æŠ˜ãƒ‘ã‚¿ãƒ¼ãƒ³ã®è§£é‡ˆ

Xç·šå›æŠ˜ï¼ˆXRDï¼‰ã§ã¯ã€ãƒ–ãƒ©ãƒƒã‚°ã®æ³•å‰‡ã«ã‚ˆã‚Šç‰¹å®šã®è§’åº¦ã§ãƒ”ãƒ¼ã‚¯ãŒè¦³æ¸¬ã•ã‚Œã¾ã™ï¼š 

$$ n\lambda = 2d_{hkl}\sin\theta $$ 

ã“ã“ã§ã€Î»ã¯Xç·šã®æ³¢é•·ã€Î¸ã¯ãƒ–ãƒ©ãƒƒã‚°è§’ã€nã¯åå°„ã®æ¬¡æ•°ï¼ˆé€šå¸¸1ï¼‰ã§ã™ã€‚ é¢é–“éš” dhkl ã‚’çŸ¥ã‚‹ã“ã¨ã§ã€è¦³æ¸¬ã•ã‚ŒãŸãƒ”ãƒ¼ã‚¯ãŒã©ã®çµæ™¶é¢ã‹ã‚‰ã®åå°„ã‹ã‚’ç‰¹å®šã§ãã¾ã™ã€‚ 

#### ã‚³ãƒ¼ãƒ‰ä¾‹8ï¼šå®Ÿææ–™ã§ã®XRDãƒ”ãƒ¼ã‚¯äºˆæ¸¬
    
    
    def bragg_angle(d_hkl, wavelength, n=1):
        """
        ãƒ–ãƒ©ãƒƒã‚°ã®æ³•å‰‡ã‹ã‚‰å›æŠ˜è§’ã‚’è¨ˆç®—
    
        Parameters:
        -----------
        d_hkl : float
            é¢é–“éš” (Ã…)
        wavelength : float
            Xç·šæ³¢é•· (Ã…)
        n : int
            åå°„ã®æ¬¡æ•°ï¼ˆé€šå¸¸1ï¼‰
    
        Returns:
        --------
        float : ãƒ–ãƒ©ãƒƒã‚°è§’ Î¸ (åº¦)ã€Noneã®å ´åˆã¯å›æŠ˜ä¸å¯
        """
        sin_theta = n * wavelength / (2 * d_hkl)
        if abs(sin_theta) > 1:
            return None  # å›æŠ˜æ¡ä»¶ã‚’æº€ãŸã•ãªã„
        return np.degrees(np.arcsin(sin_theta))
    
    def predict_xrd_pattern(material_name, a, c=None, crystal_system='cubic',
                           wavelength=1.5406, max_hkl=3):
        """
        ææ–™ã®XRDå›æŠ˜ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’äºˆæ¸¬
    
        Parameters:
        -----------
        material_name : str
            ææ–™å
        a : float
            æ ¼å­å®šæ•° a (Ã…)
        c : float, optional
            æ ¼å­å®šæ•° c (Ã…)ï¼ˆæ­£æ–¹æ™¶ãƒ»å…­æ–¹æ™¶ã®å ´åˆï¼‰
        crystal_system : str
            çµæ™¶ç³»
        wavelength : float
            Xç·šæ³¢é•· (Ã…)ã€Cu KÎ±ç·šãŒãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
        max_hkl : int
            è¨ˆç®—ã™ã‚‹æœ€å¤§ã®ãƒŸãƒ©ãƒ¼æŒ‡æ•°
        """
        print(f"\n=== {material_name} ã®XRDå›æŠ˜ãƒ‘ã‚¿ãƒ¼ãƒ³äºˆæ¸¬ ===")
        print(f"çµæ™¶ç³»: {crystal_system}")
        print(f"æ ¼å­å®šæ•°: a = {a:.4f} Ã…" + (f", c = {c:.4f} Ã…" if c else ""))
        print(f"Xç·šæ³¢é•·: {wavelength:.4f} Ã… (Cu KÎ±)\n")
    
        print(f"{'(hkl)':<10} {'d (Ã…)':<12} {'2Î¸ (åº¦)':<12} {'å¼·åº¦ç›®å®‰':<10}")
        print("-" * 55)
    
        results = []
    
        # ãƒŸãƒ©ãƒ¼æŒ‡æ•°ã®çµ„ã¿åˆã‚ã›ã‚’ç”Ÿæˆ
        for h in range(max_hkl + 1):
            for k in range(h, max_hkl + 1):
                for l in range(k, max_hkl + 1):
                    if h == 0 and k == 0 and l == 0:
                        continue
    
                    # é¢é–“éš”ã‚’è¨ˆç®—
                    if crystal_system == 'cubic':
                        d = cubic_d_spacing(a, h, k, l)
                    elif crystal_system == 'tetragonal':
                        d = tetragonal_d_spacing(a, c, h, k, l)
                    elif crystal_system == 'hexagonal':
                        d = hexagonal_d_spacing(a, c, h, k, l)
    
                    # ãƒ–ãƒ©ãƒƒã‚°è§’ã‚’è¨ˆç®—
                    theta = bragg_angle(d, wavelength)
    
                    if theta is not None and theta < 90:
                        # å¤šé‡åº¦ï¼ˆç­‰ä¾¡ãªé¢ã®æ•°ï¼‰ã‚’è€ƒæ…®ã—ãŸç›¸å¯¾å¼·åº¦ã®ç°¡æ˜“æ¨å®š
                        multiplicity = len(generate_equivalent_planes(h, k, l, crystal_system))
                        intensity = multiplicity / (h**2 + k**2 + l**2)  # ç°¡æ˜“çš„ãªæ§‹é€ å› å­
    
                        results.append(((h, k, l), d, 2 * theta, intensity))
    
        # 2Î¸ ã®å°ã•ã„é †ã«ã‚½ãƒ¼ãƒˆ
        results.sort(key=lambda x: x[2])
    
        # ä¸Šä½10ãƒ”ãƒ¼ã‚¯ã‚’è¡¨ç¤º
        for i, ((h, k, l), d, two_theta, intensity) in enumerate(results[:10]):
            # å¼·åº¦ã‚’è¦–è¦šåŒ–
            intensity_bar = 'â–ˆ' * int(intensity * 10)
            print(f"({h}{k}{l}){'':<8} {d:8.4f}    {two_theta:8.2f}    {intensity_bar}")
    
    # å®Ÿè¡Œï¼šä»£è¡¨çš„ãªææ–™ã®XRDãƒ‘ã‚¿ãƒ¼ãƒ³äºˆæ¸¬
    
    # 1. ã‚·ãƒªã‚³ãƒ³ï¼ˆSiã€ç«‹æ–¹æ™¶ï¼‰
    predict_xrd_pattern('Silicon (Si)', a=5.4310, crystal_system='cubic', max_hkl=3)
    
    # 2. é‡‘ï¼ˆAuã€ç«‹æ–¹æ™¶ï¼‰
    predict_xrd_pattern('Gold (Au)', a=4.0782, crystal_system='cubic', max_hkl=2)
    
    # 3. TiO2 ãƒ«ãƒãƒ«ï¼ˆæ­£æ–¹æ™¶ï¼‰
    predict_xrd_pattern('TiO2 (Rutile)', a=4.594, c=2.958,
                       crystal_system='tetragonal', max_hkl=2)
    
    # 4. Î±-Al2O3ï¼ˆå…­æ–¹æ™¶ï¼‰
    predict_xrd_pattern('Î±-Al2O3 (Corundum)', a=4.759, c=12.991,
                       crystal_system='hexagonal', max_hkl=2)
    

#### XRDè§£æã¸ã®å¿œç”¨

ã“ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ã€å®Ÿé¨“ã§å¾—ã‚‰ã‚ŒãŸXRDãƒ‘ã‚¿ãƒ¼ãƒ³ã¨ç†è«–è¨ˆç®—ã‚’æ¯”è¼ƒã™ã‚‹ãŸã‚ã®åŸºç¤ãƒ„ãƒ¼ãƒ«ã§ã™ã€‚ å®Ÿéš›ã®è§£æã§ã¯ã€åŸå­ã®é…ç½®ã«ã‚ˆã‚‹æ§‹é€ å› å­ã‚„æ¸©åº¦å› å­ã‚‚è€ƒæ…®ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ãŒã€ ãƒŸãƒ©ãƒ¼æŒ‡æ•°ã¨é¢é–“éš”ã®ç†è§£ã¯å…¨ã¦ã®åŸºç¤ã¨ãªã‚Šã¾ã™ã€‚ 

### 5.2 ææ–™ã®ç•°æ–¹æ€§ã¨çµæ™¶é¢

ææ–™ã®ç‰©æ€§ã¯çµæ™¶é¢ã«ã‚ˆã‚Šå¤§ããç•°ãªã‚Šã¾ã™ã€‚ä¾‹ãˆã°ï¼š 

  * **è¡¨é¢ã‚¨ãƒãƒ«ã‚®ãƒ¼** ï¼š{111}é¢ã¯{100}é¢ã‚ˆã‚Šã‚‚ä½ã„è¡¨é¢ã‚¨ãƒãƒ«ã‚®ãƒ¼ã‚’æŒã¤ï¼ˆfccé‡‘å±ï¼‰
  * **æˆé•·é€Ÿåº¦** ï¼šç‰¹å®šã®é¢ãŒå„ªå…ˆçš„ã«æˆé•·ã—ã€çµæ™¶å½¢çŠ¶ã‚’æ±ºå®š
  * **è§¦åª’æ´»æ€§** ï¼šç‰¹å®šã®é¢ãŒé«˜ã„åå¿œæ€§ã‚’ç¤ºã™
  * **æ©Ÿæ¢°çš„æ€§è³ª** ï¼šã™ã¹ã‚Šç³»ã¯ç‰¹å®šã®é¢ã¨æ–¹å‘ã®çµ„ã¿åˆã‚ã›ã§æ±ºã¾ã‚‹

## 6\. æ¼”ç¿’å•é¡Œ

### æ¼”ç¿’1ï¼šãƒŸãƒ©ãƒ¼æŒ‡æ•°ã®æ±ºå®š

ç«‹æ–¹æ™¶ã®çµæ™¶ã§ã€ä»¥ä¸‹ã®åˆ‡ç‰‡ã‚’æŒã¤çµæ™¶é¢ã®ãƒŸãƒ©ãƒ¼æŒ‡æ•°ã‚’æ±‚ã‚ãªã•ã„ï¼š 

  1. aè»¸ã§2ã€bè»¸ã§1ã€cè»¸ã§ç„¡é™é ï¼ˆå¹³è¡Œï¼‰
  2. aè»¸ã§1ã€bè»¸ã§1ã€cè»¸ã§2
  3. aè»¸ã§-1ã€bè»¸ã§1ã€cè»¸ã§1

è§£ç­”ã‚’è¦‹ã‚‹

  1. åˆ‡ç‰‡ (2, 1, âˆ) â†’ é€†æ•° (1/2, 1, 0) â†’ æ•´æ•°åŒ– (1, 2, 0) â†’ **(120)**
  2. åˆ‡ç‰‡ (1, 1, 2) â†’ é€†æ•° (1, 1, 1/2) â†’ æ•´æ•°åŒ– (2, 2, 1) â†’ **(221)**
  3. åˆ‡ç‰‡ (-1, 1, 1) â†’ é€†æ•° (-1, 1, 1) â†’ **(\\(\bar{1}\\)11)**

### æ¼”ç¿’2ï¼šé¢é–“éš”ã®è¨ˆç®—

éŠ…ï¼ˆCuï¼‰ã¯é¢å¿ƒç«‹æ–¹æ§‹é€ ï¼ˆfccï¼‰ã§ã€æ ¼å­å®šæ•° a = 3.615 Ã… ã§ã™ã€‚ ä»¥ä¸‹ã®é¢ã®é¢é–“éš”ã‚’è¨ˆç®—ã—ãªã•ã„ï¼š 

  1. (111)é¢
  2. (200)é¢
  3. (220)é¢

ã¾ãŸã€Cu KÎ±ç·šï¼ˆÎ» = 1.5406 Ã…ï¼‰ã‚’ç”¨ã„ãŸXRDæ¸¬å®šã§ã€ã“ã‚Œã‚‰ã®é¢ã‹ã‚‰ã®å›æŠ˜ãƒ”ãƒ¼ã‚¯ã¯ ä½•åº¦ï¼ˆ2Î¸ï¼‰ã«ç¾ã‚Œã‚‹ã‹è¨ˆç®—ã—ãªã•ã„ã€‚ 

è§£ç­”ã‚’è¦‹ã‚‹

**é¢é–“éš”ï¼š**

  1. d111 = 3.615 / âˆš3 = 2.087 Ã…
  2. d200 = 3.615 / âˆš4 = 1.808 Ã…
  3. d220 = 3.615 / âˆš8 = 1.278 Ã…

**ãƒ–ãƒ©ãƒƒã‚°è§’ï¼š** ï¼ˆÎ» = 2d sinÎ¸ ã‚ˆã‚Šï¼‰

  1. 2Î¸111 = 2 Ã— arcsin(1.5406/(2Ã—2.087)) â‰ˆ 43.3Â°
  2. 2Î¸200 = 2 Ã— arcsin(1.5406/(2Ã—1.808)) â‰ˆ 50.4Â°
  3. 2Î¸220 = 2 Ã— arcsin(1.5406/(2Ã—1.278)) â‰ˆ 74.1Â°

### æ¼”ç¿’3ï¼šç­‰ä¾¡ãªé¢ã®ç†è§£

ç«‹æ–¹æ™¶ã«ãŠã„ã¦ã€{110} ã«å«ã¾ã‚Œã‚‹ç­‰ä¾¡ãªé¢ã‚’ã™ã¹ã¦åˆ—æŒ™ã—ãªã•ã„ã€‚ ã¾ãŸã€ã“ã‚Œã‚‰ã®é¢ãŒä½•å€‹ã‚ã‚‹ã‹ç­”ãˆãªã•ã„ã€‚ 

è§£ç­”ã‚’è¦‹ã‚‹

**ç­”ãˆï¼š12å€‹**

ç­‰ä¾¡ãªé¢ï¼š

  * (110), (101), (011)
  * (\\(\bar{1}\\)10), (\\(\bar{1}\\)0\\(\bar{1}\\)), (0\\(\bar{1}\\)\\(\bar{1}\\))
  * (1\\(\bar{1}\\)0), (10\\(\bar{1}\\)), (01\\(\bar{1}\\))
  * (\\(\bar{1}\\)\\(\bar{1}\\)0), (\\(\bar{1}\\)0\\(\bar{1}\\)), (0\\(\bar{1}\\)1)

ã“ã‚Œã‚‰ã¯ç«‹æ–¹æ™¶ã®å¯¾ç§°æ€§ï¼ˆ24å€‹ã®å¯¾ç§°æ“ä½œï¼‰ã«ã‚ˆã‚Šç­‰ä¾¡ã¨ãªã‚Šã€ åŒã˜ç‰©ç†çš„æ€§è³ªã‚’æŒã¡ã¾ã™ã€‚ 

### æ¼”ç¿’4ï¼šãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°èª²é¡Œ

æ­£æ–¹æ™¶ã®ææ–™ï¼ˆä¾‹ï¼šZrO2ã€a = 3.64 Ã…ã€c = 5.27 Ã…ï¼‰ã«ã¤ã„ã¦ã€ ä»¥ä¸‹ã‚’å®Ÿè¡Œã™ã‚‹Pythonãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ä½œæˆã—ãªã•ã„ï¼š 

  1. (100)ã‹ã‚‰(333)ã¾ã§ã®ã™ã¹ã¦ã®é¢ã®é¢é–“éš”ã‚’è¨ˆç®—ã™ã‚‹
  2. é¢é–“éš”ãŒ2.0 Ã…ä»¥ä¸Šã®é¢ã®ã¿ã‚’æŠ½å‡ºã™ã‚‹
  3. çµæœã‚’é¢é–“éš”ã®é™é †ã§ã‚½ãƒ¼ãƒˆã—ã¦è¡¨ç¤ºã™ã‚‹

ãƒ’ãƒ³ãƒˆ

ã‚³ãƒ¼ãƒ‰ä¾‹4ã®`tetragonal_d_spacing`é–¢æ•°ã‚’ä½¿ç”¨ã—ã€ 3é‡ãƒ«ãƒ¼ãƒ—ã§h, k, lã‚’1ã‹ã‚‰3ã¾ã§å¤‰åŒ–ã•ã›ã¦è¨ˆç®—ã—ã¾ã™ã€‚ çµæœã¯ãƒªã‚¹ãƒˆã«ä¿å­˜ã—ã€`sorted()`é–¢æ•°ã§ã‚½ãƒ¼ãƒˆã§ãã¾ã™ã€‚ 

## ã¾ã¨ã‚

ã“ã®ç« ã§ã¯ã€çµæ™¶å­¦ã«ãŠã‘ã‚‹æœ€ã‚‚é‡è¦ãªè¨˜æ³•ã§ã‚ã‚‹**ãƒŸãƒ©ãƒ¼æŒ‡æ•°** ã«ã¤ã„ã¦å­¦ã³ã¾ã—ãŸï¼š

#### é‡è¦ãƒã‚¤ãƒ³ãƒˆ

  * **ãƒŸãƒ©ãƒ¼æŒ‡æ•° (hkl)** ã¯çµæ™¶é¢ã‚’3ã¤ã®æ•´æ•°ã§è¡¨ã™æ¨™æº–è¨˜æ³•
  * **é¢é–“éš” d hkl**ã¯çµæ™¶ç³»ã”ã¨ã«ç•°ãªã‚‹å¼ã§è¨ˆç®—ã•ã‚Œã‚‹
  * **ç«‹æ–¹æ™¶** ï¼šd = a / âˆš(hÂ² + kÂ² + lÂ²)
  * **æ­£æ–¹æ™¶ãƒ»å…­æ–¹æ™¶** ï¼šcè»¸ã®å¯„ä¸ã‚’åˆ¥é€”è€ƒæ…®ã™ã‚‹å¿…è¦ãŒã‚ã‚‹
  * **çµæ™¶æ–¹å‘ [uvw]** ã¯é¢ã¨ã¯ç•°ãªã‚‹è¨˜æ³•ã§è¡¨ç¾ã•ã‚Œã‚‹
  * **å¯¾ç§°æ€§** ã«ã‚ˆã‚Šå¤šæ•°ã®ç­‰ä¾¡ãªé¢ãƒ»æ–¹å‘ãŒå­˜åœ¨ã™ã‚‹
  * **Xç·šå›æŠ˜** ã§ã®å¿œç”¨ãŒææ–™åŒå®šã¨æ§‹é€ è§£æã®åŸºç¤ã¨ãªã‚‹

æ¬¡ç« ã§ã¯ã€**Xç·šå›æŠ˜ã®åŸç†ã¨ãƒ–ãƒ©ãƒƒã‚°ã®æ³•å‰‡** ã‚’è©³ã—ãå­¦ã³ã€ ãƒŸãƒ©ãƒ¼æŒ‡æ•°ã¨é¢é–“éš”ã®çŸ¥è­˜ã‚’å®Ÿéš›ã®æ§‹é€ è§£æã«å¿œç”¨ã—ã¾ã™ã€‚ 

### å…è²¬äº‹é …

  * æœ¬ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã¯æ•™è‚²ãƒ»ç ”ç©¶ãƒ»æƒ…å ±æä¾›ã®ã¿ã‚’ç›®çš„ã¨ã—ã¦ãŠã‚Šã€å°‚é–€çš„ãªåŠ©è¨€(æ³•å¾‹ãƒ»ä¼šè¨ˆãƒ»æŠ€è¡“çš„ä¿è¨¼ãªã©)ã‚’æä¾›ã™ã‚‹ã‚‚ã®ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚
  * æœ¬ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãŠã‚ˆã³ä»˜éšã™ã‚‹Code examplesã¯ã€Œç¾çŠ¶æœ‰å§¿(AS IS)ã€ã§æä¾›ã•ã‚Œã€æ˜ç¤ºã¾ãŸã¯é»™ç¤ºã‚’å•ã‚ãšã€å•†å“æ€§ã€ç‰¹å®šç›®çš„é©åˆæ€§ã€æ¨©åˆ©éä¾µå®³ã€æ­£ç¢ºæ€§ãƒ»å®Œå…¨æ€§ã€å‹•ä½œãƒ»å®‰å…¨æ€§ç­‰ã„ã‹ãªã‚‹ä¿è¨¼ã‚‚ã—ã¾ã›ã‚“ã€‚
  * å¤–éƒ¨ãƒªãƒ³ã‚¯ã€ç¬¬ä¸‰è€…ãŒæä¾›ã™ã‚‹ãƒ‡ãƒ¼ã‚¿ãƒ»ãƒ„ãƒ¼ãƒ«ãƒ»ãƒ©ã‚¤ãƒ–ãƒ©ãƒªç­‰ã®å†…å®¹ãƒ»å¯ç”¨æ€§ãƒ»å®‰å…¨æ€§ã«ã¤ã„ã¦ã€ä½œæˆè€…ãŠã‚ˆã³æ±åŒ—å¤§å­¦ã¯ä¸€åˆ‡ã®è²¬ä»»ã‚’è² ã„ã¾ã›ã‚“ã€‚
  * æœ¬ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®åˆ©ç”¨ãƒ»å®Ÿè¡Œãƒ»è§£é‡ˆã«ã‚ˆã‚Šç›´æ¥çš„ãƒ»é–“æ¥çš„ãƒ»ä»˜éšçš„ãƒ»ç‰¹åˆ¥ãƒ»çµæœçš„ãƒ»æ‡²ç½°çš„æå®³ãŒç”Ÿã˜ãŸå ´åˆã§ã‚‚ã€é©ç”¨æ³•ã§è¨±å®¹ã•ã‚Œã‚‹æœ€å¤§é™ã®ç¯„å›²ã§ã€ä½œæˆè€…ãŠã‚ˆã³æ±åŒ—å¤§å­¦ã¯è²¬ä»»ã‚’è² ã„ã¾ã›ã‚“ã€‚
  * æœ¬ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®å†…å®¹ã¯ã€äºˆå‘Šãªãå¤‰æ›´ãƒ»æ›´æ–°ãƒ»æä¾›åœæ­¢ã•ã‚Œã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚
  * æœ¬ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®è‘—ä½œæ¨©ãƒ»ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã¯æ˜è¨˜ã•ã‚ŒãŸæ¡ä»¶(ä¾‹: CC BY 4.0)ã«å¾“ã„ã¾ã™ã€‚å½“è©²ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã¯é€šå¸¸ã€ç„¡ä¿è¨¼æ¡é …ã‚’å«ã¿ã¾ã™ã€‚
