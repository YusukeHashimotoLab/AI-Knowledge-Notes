<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç¬¬2ç« :ç²‰æœ«Xç·šå›æŠ˜æ¸¬å®šã¨è§£æ - MS Terakoya</title>

    <style>
        :root {
            --color-primary: #2c3e50;
            --color-primary-dark: #1a252f;
            --color-accent: #f093fb;
            --color-accent-light: #f5576c;
            --color-text: #2d3748;
            --color-text-light: #4a5568;
            --color-bg: #ffffff;
            --color-bg-alt: #f7fafc;
            --color-border: #e2e8f0;
            --color-code-bg: #f8f9fa;
            --color-link: #f093fb;
            --color-link-hover: #d07be8;

            --spacing-xs: 0.5rem;
            --spacing-sm: 1rem;
            --spacing-md: 1.5rem;
            --spacing-lg: 2rem;
            --spacing-xl: 3rem;

            --font-body: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            --font-mono: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;

            --border-radius: 8px;
            --box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-body);
            line-height: 1.7;
            color: var(--color-text);
            background-color: var(--color-bg);
            font-size: 16px;
        }

        header {
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            color: white;
            padding: var(--spacing-xl) var(--spacing-md);
            margin-bottom: var(--spacing-xl);
            box-shadow: var(--box-shadow);
        }

        .header-content {
            max-width: 900px;
            margin: 0 auto;
        }

        h1 {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: var(--spacing-sm);
            line-height: 1.2;
        }

        .subtitle {
            font-size: 1.1rem;
            opacity: 0.95;
            font-weight: 400;
            margin-bottom: var(--spacing-md);
        }

        .meta {
            display: flex;
            flex-wrap: wrap;
            gap: var(--spacing-md);
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .meta-item {
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 0 var(--spacing-md) var(--spacing-xl);
        }

        h2 {
            font-size: 1.75rem;
            color: var(--color-primary);
            margin-top: var(--spacing-xl);
            margin-bottom: var(--spacing-md);
            padding-bottom: var(--spacing-xs);
            border-bottom: 3px solid var(--color-accent);
        }

        h3 {
            font-size: 1.4rem;
            color: var(--color-primary);
            margin-top: var(--spacing-lg);
            margin-bottom: var(--spacing-sm);
        }

        h4 {
            font-size: 1.1rem;
            color: var(--color-primary-dark);
            margin-top: var(--spacing-md);
            margin-bottom: var(--spacing-sm);
        }

        p {
            margin-bottom: var(--spacing-md);
            color: var(--color-text);
        }

        a {
            color: var(--color-link);
            text-decoration: none;
            transition: color 0.2s;
        }

        a:hover {
            color: var(--color-link-hover);
            text-decoration: underline;
        }

        ul, ol {
            margin-left: var(--spacing-lg);
            margin-bottom: var(--spacing-md);
        }

        li {
            margin-bottom: var(--spacing-xs);
            color: var(--color-text);
        }

        pre {
            background-color: var(--color-code-bg);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            overflow-x: auto;
            margin-bottom: var(--spacing-md);
            font-family: var(--font-mono);
            font-size: 0.9rem;
            line-height: 1.5;
        }

        code {
            font-family: var(--font-mono);
            font-size: 0.9em;
            background-color: var(--color-code-bg);
            padding: 0.2em 0.4em;
            border-radius: 3px;
        }

        pre code {
            background-color: transparent;
            padding: 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: var(--spacing-md);
            font-size: 0.95rem;
        }

        th, td {
            border: 1px solid var(--color-border);
            padding: var(--spacing-sm);
            text-align: left;
        }

        th {
            background-color: var(--color-bg-alt);
            font-weight: 600;
            color: var(--color-primary);
        }

        blockquote {
            border-left: 4px solid var(--color-accent);
            padding-left: var(--spacing-md);
            margin: var(--spacing-md) 0;
            color: var(--color-text-light);
            font-style: italic;
            background-color: var(--color-bg-alt);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        .mermaid {
            text-align: center;
            margin: var(--spacing-lg) 0;
            background-color: var(--color-bg-alt);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        details {
            background-color: var(--color-bg-alt);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            margin-bottom: var(--spacing-md);
        }

        summary {
            cursor: pointer;
            font-weight: 600;
            color: var(--color-primary);
            user-select: none;
            padding: var(--spacing-xs);
            margin: calc(-1 * var(--spacing-md));
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        summary:hover {
            background-color: rgba(240, 147, 251, 0.1);
        }

        details[open] summary {
            margin-bottom: var(--spacing-md);
            border-bottom: 1px solid var(--color-border);
        }

        .learning-objectives {
            background: linear-gradient(135deg, #fce7f3 0%, #fbcfe8 100%);
            padding: var(--spacing-lg);
            border-radius: var(--border-radius);
            border-left: 4px solid var(--color-accent);
            margin-bottom: var(--spacing-xl);
        }

        .learning-objectives h2 {
            margin-top: 0;
            border-bottom: none;
        }

        .breadcrumb {
            max-width: 900px;
            margin: 0 auto;
            padding: var(--spacing-sm) var(--spacing-md);
            font-size: 0.9rem;
            color: var(--color-text-light);
        }

        .breadcrumb a {
            color: var(--color-link);
            text-decoration: none;
        }

        .breadcrumb a:hover {
            text-decoration: underline;
        }

        .navigation {
            display: flex;
            justify-content: space-between;
            gap: var(--spacing-md);
            margin: var(--spacing-xl) 0;
            padding-top: var(--spacing-lg);
            border-top: 2px solid var(--color-border);
        }

        .nav-button {
            flex: 1;
            padding: var(--spacing-md);
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            color: white;
            border-radius: var(--border-radius);
            text-align: center;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: var(--box-shadow);
        }

        .nav-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            text-decoration: none;
        }

        footer {
            margin-top: var(--spacing-xl);
            padding: var(--spacing-lg) var(--spacing-md);
            background-color: var(--color-bg-alt);
            border-top: 1px solid var(--color-border);
            text-align: center;
            font-size: 0.9rem;
            color: var(--color-text-light);
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.6rem;
            }

            h2 {
                font-size: 1.4rem;
            }

            h3 {
                font-size: 1.2rem;
            }

            .navigation {
                flex-direction: column;
            }

            pre {
                font-size: 0.85rem;
            }
        }
    </style>

    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ startOnLoad: true, theme: 'neutral' });
    </script>
</head>
<body>
    <nav class="breadcrumb">
        <a href="../index.html">Materials Scienceå…¥é–€</a> &gt;
        <a href="./index.html">Xç·šå›æŠ˜åˆ†æå…¥é–€</a> &gt;
        ç¬¬2ç« 
    </nav>

    <header>
        <div class="header-content">
            <h1>ç¬¬2ç« : ç²‰æœ«Xç·šå›æŠ˜æ¸¬å®šã¨è§£æ</h1>
            <p class="subtitle">XRDè£…ç½®ã®åŸç†ã‹ã‚‰å®Ÿãƒ‡ãƒ¼ã‚¿è§£æã¾ã§ - ãƒ”ãƒ¼ã‚¯åŒå®šã¨ãƒ•ã‚£ãƒƒãƒ†ã‚£ãƒ³ã‚°ã®å®Ÿè·µ</p>
            <div class="meta">
                <span class="meta-item">ğŸ“– èª­äº†æ™‚é–“: 28-32åˆ†</span>
                <span class="meta-item">ğŸ¯ é›£æ˜“åº¦: ä¸­ç´š</span>
                <span class="meta-item">ğŸ’» ã‚³ãƒ¼ãƒ‰ä¾‹: 8å€‹</span>
            </div>
        </div>
    </header>

    <main class="container">
        <div class="learning-objectives">
            <h2>å­¦ç¿’ç›®æ¨™</h2>
            <p>ã“ã®ç« ã‚’å®Œäº†ã™ã‚‹ã¨ã€ä»¥ä¸‹ãŒã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™:</p>
            <ul>
                <li>XRDè£…ç½®ã®å„æ§‹æˆè¦ç´ ã®å½¹å‰²ã‚’ç†è§£ã—ã€æ¸¬å®šæ¡ä»¶ã‚’æœ€é©åŒ–ã§ãã‚‹</li>
                <li>å®Ÿæ¸¬XRDãƒ‘ã‚¿ãƒ¼ãƒ³ã‹ã‚‰ãƒ”ãƒ¼ã‚¯ã‚’åŒå®šã—ã€MilleræŒ‡æ•°ã‚’å‰²ã‚Šå½“ã¦ã‚‰ã‚Œã‚‹</li>
                <li>ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰é™¤å»ã¨ãƒ‡ãƒ¼ã‚¿å¹³æ»‘åŒ–ã‚’å®Ÿè£…ã§ãã‚‹</li>
                <li>Gaussã€Lorentzã€Voigté–¢æ•°ã§ãƒ”ãƒ¼ã‚¯ãƒ•ã‚£ãƒƒãƒ†ã‚£ãƒ³ã‚°ã‚’å®Ÿè¡Œã§ãã‚‹</li>
                <li>scipy.optimizeã‚’ç”¨ã„ãŸé«˜åº¦ãªãƒ”ãƒ¼ã‚¯è§£æãŒã§ãã‚‹</li>
            </ul>
        </div>

        <h2>2.1 XRDè£…ç½®ã®æ§‹æˆ</h2>

        <h3>2.1.1 Xç·šæº</h3>

        <p>ç²‰æœ«Xç·šå›æŠ˜è¨ˆã®æœ€ã‚‚é‡è¦ãªæ§‹æˆè¦ç´ ã¯Xç·šæºã§ã™ã€‚å®Ÿé¨“å®¤ç³»XRDã§ã¯ã€ä¸»ã«ä»¥ä¸‹ã®ç‰¹æ€§Xç·šãŒä½¿ç”¨ã•ã‚Œã¾ã™:</p>

        <table>
            <thead>
                <tr>
                    <th>Xç·šæº</th>
                    <th>KÎ±1æ³¢é•· [Ã…]</th>
                    <th>KÎ±2æ³¢é•· [Ã…]</th>
                    <th>ç‰¹å¾´</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Cu KÎ±</td>
                    <td>1.54056</td>
                    <td>1.54439</td>
                    <td>æœ€ã‚‚ä¸€èˆ¬çš„ã€æ±ç”¨æ€§ãŒé«˜ã„</td>
                </tr>
                <tr>
                    <td>Mo KÎ±</td>
                    <td>0.71073</td>
                    <td>0.71359</td>
                    <td>é«˜ã‚¨ãƒãƒ«ã‚®ãƒ¼ã€é€éåŠ›å¼·ã„</td>
                </tr>
                <tr>
                    <td>Co KÎ±</td>
                    <td>1.78897</td>
                    <td>1.79285</td>
                    <td>Feå«æœ‰è©¦æ–™ã«æœ‰åˆ©(è›å…‰å›é¿)</td>
                </tr>
                <tr>
                    <td>Cr KÎ±</td>
                    <td>2.28970</td>
                    <td>2.29361</td>
                    <td>é•·æ³¢é•·ã€ä½è§’åˆ†è§£èƒ½å‘ä¸Š</td>
                </tr>
            </tbody>
        </table>

        <h3>2.1.2 å…‰å­¦ç³»ã¨æ¤œå‡ºå™¨</h3>

        <div class="mermaid">
graph LR
    A[Xç·šç®¡<br/>Cué™½æ¥µ] --> B[å…¥å°„ã‚¹ãƒªãƒƒãƒˆ<br/>ãƒ“ãƒ¼ãƒ æ•´å½¢]
    B --> C[è©¦æ–™<br/>ç²‰æœ«]
    C --> D[å—å…‰ã‚¹ãƒªãƒƒãƒˆ<br/>æ•£ä¹±é™¤å»]
    D --> E[å˜è‰²åŒ–<br/>Ni filter]
    E --> F[æ¤œå‡ºå™¨<br/>ã‚·ãƒ³ãƒãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³]
    F --> G[ãƒ‡ãƒ¼ã‚¿å‡¦ç†<br/>PC]

    style A fill:#ffe7e7
    style C fill:#fce7f3
    style F fill:#e7f3ff
    style G fill:#e7ffe7
        </div>

        <p><strong>Bragg-Brentanoé…ç½®</strong>:</p>
        <ul>
            <li>Î¸-2Î¸æ–¹å¼: Xç·šæºã¨æ¤œå‡ºå™¨ãŒè©¦æ–™ã‚’ä¸­å¿ƒã«å¯¾ç§°ç§»å‹•</li>
            <li>ãƒ•ã‚©ãƒ¼ã‚«ã‚·ãƒ³ã‚°ã‚¸ã‚ªãƒ¡ãƒˆãƒª: è©¦æ–™è¡¨é¢ã®ç•°ãªã‚‹ç‚¹ã‹ã‚‰ã®å›æŠ˜Xç·šãŒæ¤œå‡ºå™¨ã§åæŸ</li>
            <li>é«˜åˆ†è§£èƒ½ã¨é«˜å¼·åº¦ã‚’ä¸¡ç«‹</li>
        </ul>

        <h3>2.1.3 æ¸¬å®šæ¡ä»¶ã®æœ€é©åŒ–</h3>

        <pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt

class XRDMeasurementConditions:
    """XRDæ¸¬å®šæ¡ä»¶ã®æœ€é©åŒ–ã‚¯ãƒ©ã‚¹"""

    def __init__(self, wavelength=1.54056):
        """
        Args:
            wavelength (float): Xç·šæ³¢é•· [Ã…]
        """
        self.wavelength = wavelength

    def calculate_two_theta_range(self, d_min=1.0, d_max=10.0):
        """æ¸¬å®šã™ã¹ã2Î¸ç¯„å›²ã‚’è¨ˆç®—

        Args:
            d_min (float): æœ€å°é¢é–“éš” [Ã…]
            d_max (float): æœ€å¤§é¢é–“éš” [Ã…]

        Returns:
            tuple: (two_theta_min, two_theta_max) [åº¦]
        """
        # Braggã®æ³•å‰‡: Î» = 2d sinÎ¸
        # sin(Î¸) = Î» / (2d)

        sin_theta_max = self.wavelength / (2 * d_min)
        sin_theta_min = self.wavelength / (2 * d_max)

        if sin_theta_max > 1.0:
            sin_theta_max = 1.0  # ç‰©ç†çš„ä¸Šé™

        theta_max = np.degrees(np.arcsin(sin_theta_max))
        theta_min = np.degrees(np.arcsin(sin_theta_min))

        return 2 * theta_min, 2 * theta_max

    def optimize_step_size(self, two_theta_range, fwhm=0.1):
        """æœ€é©ãªã‚¹ãƒ†ãƒƒãƒ—ã‚µã‚¤ã‚ºã‚’è¨ˆç®—

        Args:
            two_theta_range (tuple): (start, end) æ¸¬å®šç¯„å›² [åº¦]
            fwhm (float): ãƒ”ãƒ¼ã‚¯ã®åŠå€¤å…¨å¹… [åº¦]

        Returns:
            float: æ¨å¥¨ã‚¹ãƒ†ãƒƒãƒ—ã‚µã‚¤ã‚º [åº¦]
        """
        # ãƒ«ãƒ¼ãƒ«: FWHM ã® 1/5 ã€œ 1/10
        step_size_recommended = fwhm / 7.0
        return step_size_recommended

    def calculate_measurement_time(self, two_theta_range, step_size, time_per_step=1.0):
        """ç·æ¸¬å®šæ™‚é–“ã‚’è¦‹ç©ã‚‚ã‚‹

        Args:
            two_theta_range (tuple): (start, end) [åº¦]
            step_size (float): ã‚¹ãƒ†ãƒƒãƒ—ã‚µã‚¤ã‚º [åº¦]
            time_per_step (float): 1ã‚¹ãƒ†ãƒƒãƒ—ã‚ãŸã‚Šã®æ¸¬å®šæ™‚é–“ [ç§’]

        Returns:
            float: ç·æ¸¬å®šæ™‚é–“ [åˆ†]
        """
        start, end = two_theta_range
        n_steps = int((end - start) / step_size)
        total_seconds = n_steps * time_per_step
        return total_seconds / 60.0  # åˆ†ã«å¤‰æ›

    def generate_measurement_plan(self, d_min=1.2, d_max=5.0, fwhm=0.1, time_per_step=2.0):
        """å®Œå…¨ãªæ¸¬å®šè¨ˆç”»ã‚’ç”Ÿæˆ

        Returns:
            dict: æ¸¬å®šãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
        """
        two_theta_range = self.calculate_two_theta_range(d_min, d_max)
        step_size = self.optimize_step_size(two_theta_range, fwhm)
        total_time = self.calculate_measurement_time(two_theta_range, step_size, time_per_step)

        plan = {
            'two_theta_start': two_theta_range[0],
            'two_theta_end': two_theta_range[1],
            'step_size': step_size,
            'time_per_step': time_per_step,
            'total_time_minutes': total_time,
            'estimated_points': int((two_theta_range[1] - two_theta_range[0]) / step_size)
        }

        return plan


# ä½¿ç”¨ä¾‹
conditions = XRDMeasurementConditions(wavelength=1.54056)  # Cu KÎ±
plan = conditions.generate_measurement_plan(d_min=1.2, d_max=5.0, fwhm=0.1, time_per_step=2.0)

print("=== XRDæ¸¬å®šè¨ˆç”» ===")
print(f"æ¸¬å®šç¯„å›²: {plan['two_theta_start']:.2f}Â° - {plan['two_theta_end']:.2f}Â°")
print(f"ã‚¹ãƒ†ãƒƒãƒ—ã‚µã‚¤ã‚º: {plan['step_size']:.4f}Â°")
print(f"1ç‚¹ã‚ãŸã‚Šæ¸¬å®šæ™‚é–“: {plan['time_per_step']:.1f}ç§’")
print(f"ç·ãƒ‡ãƒ¼ã‚¿ãƒã‚¤ãƒ³ãƒˆæ•°: {plan['estimated_points']}")
print(f"æ¨å®šç·æ¸¬å®šæ™‚é–“: {plan['total_time_minutes']:.1f}åˆ† ({plan['total_time_minutes']/60:.2f}æ™‚é–“)")

# æœŸå¾…ã•ã‚Œã‚‹å‡ºåŠ›:
# æ¸¬å®šç¯„å›²: 9.14Â° - 40.33Â°
# ã‚¹ãƒ†ãƒƒãƒ—ã‚µã‚¤ã‚º: 0.0143Â°
# ç·æ¸¬å®šæ™‚é–“: ç´„73åˆ†</code></pre>

        <h2>2.2 æ¸¬å®šæ¡ä»¶ã®æœ€é©åŒ–</h2>

        <h3>2.2.1 2Î¸ç¯„å›²ã®æ±ºå®š</h3>

        <p>é©åˆ‡ãª2Î¸ç¯„å›²ã¯ã€è§£æç›®çš„ã¨è©¦æ–™ã®çµæ™¶æ§‹é€ ã«ä¾å­˜ã—ã¾ã™:</p>

        <ul>
            <li><strong>ç›¸åŒå®š</strong>: 10Â° - 80Â° (ä¸»è¦ãƒ”ãƒ¼ã‚¯ã‚’ã‚«ãƒãƒ¼)</li>
            <li><strong>æ ¼å­å®šæ•°ç²¾å¯†åŒ–</strong>: 20Â° - 120Â° (é«˜è§’ãƒ‡ãƒ¼ã‚¿ãŒé‡è¦)</li>
            <li><strong>å®šé‡åˆ†æ</strong>: 5Â° - 90Â° (ä½è§’ãƒ”ãƒ¼ã‚¯ã‚‚å«ã‚€)</li>
            <li><strong>è–„è†œè§£æ</strong>: 20Â° - 90Â° (ä½è§’ã¯åŸºæ¿ã®å½±éŸ¿)</li>
        </ul>

        <h3>2.2.2 ã‚¹ãƒ†ãƒƒãƒ—ã‚µã‚¤ã‚ºã¨ã‚«ã‚¦ãƒ³ãƒˆæ™‚é–“ã®ãƒˆãƒ¬ãƒ¼ãƒ‰ã‚ªãƒ•</h3>

        <pre><code class="language-python">def compare_measurement_strategies(two_theta_range=(10, 80)):
    """ç•°ãªã‚‹æ¸¬å®šæˆ¦ç•¥ã®æ¯”è¼ƒ

    Args:
        two_theta_range (tuple): æ¸¬å®šç¯„å›² [åº¦]
    """
    strategies = [
        {'name': 'é«˜é€Ÿã‚¹ã‚­ãƒ£ãƒ³', 'step': 0.04, 'time': 0.5},
        {'name': 'æ¨™æº–ã‚¹ã‚­ãƒ£ãƒ³', 'step': 0.02, 'time': 1.0},
        {'name': 'é«˜åˆ†è§£èƒ½ã‚¹ã‚­ãƒ£ãƒ³', 'step': 0.01, 'time': 2.0},
        {'name': 'è¶…é«˜ç²¾åº¦ã‚¹ã‚­ãƒ£ãƒ³', 'step': 0.005, 'time': 5.0},
    ]

    print("æ¸¬å®šæˆ¦ç•¥æ¯”è¼ƒ:")
    print("-" * 70)
    print(f"{'æˆ¦ç•¥':<15} | ã‚¹ãƒ†ãƒƒãƒ—[Â°] | æ™‚é–“/ç‚¹[ç§’] | ç·ç‚¹æ•° | ç·æ™‚é–“[åˆ†]")
    print("-" * 70)

    for strategy in strategies:
        step = strategy['step']
        time_per_step = strategy['time']
        n_points = int((two_theta_range[1] - two_theta_range[0]) / step)
        total_time = n_points * time_per_step / 60.0

        print(f"{strategy['name']:<15} | {step:^11.3f} | {time_per_step:^11.1f} | {n_points:^6} | {total_time:^9.1f}")

    print("\næ¨å¥¨:")
    print("- ãƒ«ãƒ¼ãƒãƒ³åˆ†æ: é«˜é€Ÿã€œæ¨™æº–ã‚¹ã‚­ãƒ£ãƒ³")
    print("- ç²¾å¯†æ§‹é€ è§£æ: é«˜åˆ†è§£èƒ½ã‚¹ã‚­ãƒ£ãƒ³")
    print("- è«–æ–‡ç™ºè¡¨ç”¨: è¶…é«˜ç²¾åº¦ã‚¹ã‚­ãƒ£ãƒ³")

compare_measurement_strategies()

# æœŸå¾…ã•ã‚Œã‚‹å‡ºåŠ›:
# é«˜é€Ÿã‚¹ã‚­ãƒ£ãƒ³:     ç·æ™‚é–“ ~15åˆ†
# æ¨™æº–ã‚¹ã‚­ãƒ£ãƒ³:     ç·æ™‚é–“ ~58åˆ†
# é«˜åˆ†è§£èƒ½ã‚¹ã‚­ãƒ£ãƒ³:  ç·æ™‚é–“ ~233åˆ†
# è¶…é«˜ç²¾åº¦ã‚¹ã‚­ãƒ£ãƒ³:  ç·æ™‚é–“ ~1167åˆ† (19.4æ™‚é–“)</code></pre>

        <h2>2.3 ãƒ”ãƒ¼ã‚¯åŒå®šã¨ã‚¤ãƒ³ãƒ‡ã‚­ã‚·ãƒ³ã‚°</h2>

        <h3>2.3.1 ãƒ”ãƒ¼ã‚¯æ¤œå‡ºã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ </h3>

        <pre><code class="language-python">from scipy.signal import find_peaks, peak_widths
import numpy as np

def detect_peaks(two_theta, intensity, prominence=100, width=2, distance=5):
    """XRDãƒ‘ã‚¿ãƒ¼ãƒ³ã‹ã‚‰ãƒ”ãƒ¼ã‚¯ã‚’è‡ªå‹•æ¤œå‡º

    Args:
        two_theta (np.ndarray): 2Î¸è§’åº¦ [åº¦]
        intensity (np.ndarray): å›æŠ˜å¼·åº¦
        prominence (float): ãƒ”ãƒ¼ã‚¯ã®çªå‡ºåº¦é–¾å€¤
        width (float): æœ€å°ãƒ”ãƒ¼ã‚¯å¹… [ãƒ‡ãƒ¼ã‚¿ãƒã‚¤ãƒ³ãƒˆ]
        distance (int): ãƒ”ãƒ¼ã‚¯é–“ã®æœ€å°è·é›¢ [ãƒ‡ãƒ¼ã‚¿ãƒã‚¤ãƒ³ãƒˆ]

    Returns:
        dict: ãƒ”ãƒ¼ã‚¯æƒ…å ± {positions, heights, widths, prominences}
    """
    # ãƒ”ãƒ¼ã‚¯æ¤œå‡º
    peaks, properties = find_peaks(
        intensity,
        prominence=prominence,
        width=width,
        distance=distance
    )

    # ãƒ”ãƒ¼ã‚¯å¹…ã®è¨ˆç®—
    widths_result = peak_widths(intensity, peaks, rel_height=0.5)

    peak_info = {
        'indices': peaks,
        'two_theta': two_theta[peaks],
        'intensity': intensity[peaks],
        'prominence': properties['prominences'],
        'fwhm': widths_result[0] * np.mean(np.diff(two_theta)),  # ãƒ‡ãƒ¼ã‚¿ãƒã‚¤ãƒ³ãƒˆ â†’ è§’åº¦
        'left_bases': two_theta[properties['left_bases'].astype(int)],
        'right_bases': two_theta[properties['right_bases'].astype(int)]
    }

    return peak_info


# æ¨¡æ“¬XRDãƒ‡ãƒ¼ã‚¿ã®ç”Ÿæˆ
def generate_synthetic_xrd(two_theta_range=(10, 80), n_points=3500):
    """æ¨¡æ“¬XRDãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ç”Ÿæˆ (Î±-Fe BCC)

    Returns:
        tuple: (two_theta, intensity)
    """
    two_theta = np.linspace(two_theta_range[0], two_theta_range[1], n_points)
    intensity = np.zeros_like(two_theta)

    # Î±-Fe (BCC) ã®ä¸»è¦ãƒ”ãƒ¼ã‚¯
    # (hkl): (ä½ç½®[Â°], å¼·åº¦, FWHM[Â°])
    fe_peaks = [
        (44.67, 1000, 0.15),  # (110)
        (65.02, 300, 0.18),   # (200)
        (82.33, 450, 0.22),   # (211)
    ]

    # Gaussianãƒ”ãƒ¼ã‚¯ã®è¿½åŠ 
    for pos, height, fwhm in fe_peaks:
        sigma = fwhm / (2 * np.sqrt(2 * np.log(2)))
        intensity += height * np.exp(-0.5 * ((two_theta - pos) / sigma) ** 2)

    # ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ãƒã‚¤ã‚º
    background = 50 + 20 * np.exp(-two_theta / 30)
    noise = np.random.normal(0, 5, len(two_theta))

    intensity_total = intensity + background + noise

    return two_theta, intensity_total


# å®Ÿè¡Œä¾‹
two_theta, intensity = generate_synthetic_xrd()
peaks = detect_peaks(two_theta, intensity, prominence=100, width=2, distance=10)

print("=== æ¤œå‡ºã•ã‚ŒãŸãƒ”ãƒ¼ã‚¯ ===")
print(f"{'2Î¸ [Â°]':<10} | {'å¼·åº¦':<10} | {'FWHM [Â°]':<10} | {'ç›¸å¯¾å¼·åº¦ [%]':<12}")
print("-" * 50)

# å¼·åº¦ã‚’æ­£è¦åŒ–
I_max = np.max(peaks['intensity'])
for i in range(len(peaks['two_theta'])):
    rel_intensity = 100 * peaks['intensity'][i] / I_max
    print(f"{peaks['two_theta'][i]:8.2f}   | {peaks['intensity'][i]:8.0f}   | {peaks['fwhm'][i]:8.3f}   | {rel_intensity:8.1f}")

# æœŸå¾…ã•ã‚Œã‚‹å‡ºåŠ›:
#   44.67   |    1000   |    0.150   |    100.0
#   65.02   |     300   |    0.180   |     30.0
#   82.33   |     450   |    0.220   |     45.0</code></pre>

        <h3>2.3.2 MilleræŒ‡æ•°ã®å‰²ã‚Šå½“ã¦ (ç«‹æ–¹æ™¶ã®å ´åˆ)</h3>

        <pre><code class="language-python">def index_cubic_pattern(two_theta_obs, wavelength=1.54056, lattice_type='I', a_initial=3.0):
    """ç«‹æ–¹æ™¶ã®XRDãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ã‚¤ãƒ³ãƒ‡ã‚­ã‚·ãƒ³ã‚°

    Args:
        two_theta_obs (np.ndarray): è¦³æ¸¬ã•ã‚ŒãŸå›æŠ˜è§’ [åº¦]
        wavelength (float): Xç·šæ³¢é•· [Ã…]
        lattice_type (str): æ ¼å­å‹ ('P', 'I', 'F')
        a_initial (float): åˆæœŸæ ¼å­å®šæ•°æ¨å®šå€¤ [Ã…]

    Returns:
        list: ã‚¤ãƒ³ãƒ‡ã‚­ã‚·ãƒ³ã‚°çµæœ [(h, k, l, d_calc, two_theta_calc, delta), ...]
    """
    # ç«‹æ–¹æ™¶ã®då€¤: d = a / sqrt(h^2 + k^2 + l^2)
    # è¨±å®¹ã•ã‚Œã‚‹MilleræŒ‡æ•°ã‚’ç”Ÿæˆ
    hkl_list = []
    for h in range(0, 6):
        for k in range(0, 6):
            for l in range(0, 6):
                if h == 0 and k == 0 and l == 0:
                    continue
                # æ¶ˆæ»…å‰‡ãƒã‚§ãƒƒã‚¯
                if lattice_type == 'I' and (h + k + l) % 2 != 0:
                    continue
                if lattice_type == 'F':
                    parity = [h % 2, k % 2, l % 2]
                    if len(set(parity)) != 1:
                        continue
                hkl_list.append((h, k, l, h**2 + k**2 + l**2))

    # h^2 + k^2 + l^2 ã§ã‚½ãƒ¼ãƒˆ
    hkl_list.sort(key=lambda x: x[3])

    # å„è¦³æ¸¬ãƒ”ãƒ¼ã‚¯ã«æœ€ã‚‚è¿‘ã„MilleræŒ‡æ•°ã‚’å‰²ã‚Šå½“ã¦
    indexing_results = []

    for two_theta in two_theta_obs:
        theta_rad = np.radians(two_theta / 2)
        d_obs = wavelength / (2 * np.sin(theta_rad))

        # å…¨ã¦ã®MilleræŒ‡æ•°å€™è£œã‚’è©¦ã™
        best_match = None
        min_error = float('inf')

        for h, k, l, h2k2l2 in hkl_list:
            d_calc = a_initial / np.sqrt(h2k2l2)
            error = abs(d_calc - d_obs)

            if error < min_error:
                min_error = error
                theta_calc = np.degrees(np.arcsin(wavelength / (2 * d_calc)))
                two_theta_calc = 2 * theta_calc
                best_match = (h, k, l, d_calc, two_theta_calc, two_theta_calc - two_theta)

        if best_match and abs(best_match[5]) < 0.5:  # è¨±å®¹èª¤å·® 0.5åº¦
            indexing_results.append(best_match)

    return indexing_results


# ä½¿ç”¨ä¾‹
two_theta_obs = np.array([44.67, 65.02, 82.33])  # Î±-Fe BCCã®ä¸»è¦ãƒ”ãƒ¼ã‚¯
indexed = index_cubic_pattern(two_theta_obs, wavelength=1.54056, lattice_type='I', a_initial=2.87)

print("=== MilleræŒ‡æ•°ã®å‰²ã‚Šå½“ã¦ (Î±-Fe BCC) ===")
print(f"{'(hkl)':<10} | {'dè¨ˆç®—[Ã…]':<10} | {'2Î¸è¨ˆç®—[Â°]':<12} | {'2Î¸è¦³æ¸¬[Â°]':<12} | {'èª¤å·®[Â°]':<8}")
print("-" * 65)

for h, k, l, d_calc, two_theta_calc, delta in indexed:
    two_theta_obs_match = two_theta_calc - delta
    print(f"({h} {k} {l}){' '*(6-len(f'{h} {k} {l}'))} | {d_calc:8.4f}   | {two_theta_calc:10.2f}   | {two_theta_obs_match:10.2f}   | {delta:6.2f}")

# æœŸå¾…ã•ã‚Œã‚‹å‡ºåŠ›:
# (1 1 0)  |   2.0293   |      44.67   |      44.67   |   0.00
# (2 0 0)  |   1.4350   |      65.02   |      65.02   |   0.00
# (2 1 1)  |   1.1707   |      82.33   |      82.33   |   0.00</code></pre>

        <h2>2.4 ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰é™¤å»ã¨ãƒ‡ãƒ¼ã‚¿å¹³æ»‘åŒ–</h2>

        <h3>2.4.1 å¤šé …å¼ãƒ•ã‚£ãƒƒãƒ†ã‚£ãƒ³ã‚°ã«ã‚ˆã‚‹ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰é™¤å»</h3>

        <pre><code class="language-python">from scipy.signal import savgol_filter

def remove_background_polynomial(two_theta, intensity, degree=3, exclude_peaks=True):
    """å¤šé …å¼ãƒ•ã‚£ãƒƒãƒ†ã‚£ãƒ³ã‚°ã§ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã‚’é™¤å»

    Args:
        two_theta (np.ndarray): 2Î¸è§’åº¦
        intensity (np.ndarray): å›æŠ˜å¼·åº¦
        degree (int): å¤šé …å¼ã®æ¬¡æ•°
        exclude_peaks (bool): ãƒ”ãƒ¼ã‚¯é ˜åŸŸã‚’é™¤å¤–ã—ã¦ãƒ•ã‚£ãƒƒãƒˆ

    Returns:
        tuple: (background, intensity_corrected)
    """
    if exclude_peaks:
        # ãƒ”ãƒ¼ã‚¯æ¤œå‡º
        peaks_info = detect_peaks(two_theta, intensity, prominence=50)
        peak_indices = peaks_info['indices']

        # ãƒ”ãƒ¼ã‚¯è¿‘å‚ã‚’é™¤å¤–ã—ãŸãƒã‚¹ã‚¯ä½œæˆ
        mask = np.ones(len(two_theta), dtype=bool)
        for peak_idx in peak_indices:
            # ãƒ”ãƒ¼ã‚¯ã®å‰å¾Œ Â±20ç‚¹ã‚’é™¤å¤–
            mask[max(0, peak_idx-20):min(len(two_theta), peak_idx+20)] = False

        # ãƒã‚¹ã‚¯ã•ã‚ŒãŸé ˜åŸŸã®ã¿ã§ãƒ•ã‚£ãƒƒãƒˆ
        coeffs = np.polyfit(two_theta[mask], intensity[mask], degree)
    else:
        coeffs = np.polyfit(two_theta, intensity, degree)

    # ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰è¨ˆç®—
    background = np.polyval(coeffs, two_theta)

    # è£œæ­£å¾Œã®å¼·åº¦
    intensity_corrected = intensity - background

    # è² ã®å€¤ã‚’ã‚¼ãƒ­ã«ã‚¯ãƒªãƒƒãƒ—
    intensity_corrected = np.maximum(intensity_corrected, 0)

    return background, intensity_corrected


def smooth_data_savitzky_golay(intensity, window_length=11, polyorder=3):
    """Savitzky-Golayãƒ•ã‚£ãƒ«ã‚¿ã§ãƒ‡ãƒ¼ã‚¿ã‚’å¹³æ»‘åŒ–

    Args:
        intensity (np.ndarray): å›æŠ˜å¼·åº¦
        window_length (int): ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦é•· (å¥‡æ•°)
        polyorder (int): å¤šé …å¼æ¬¡æ•°

    Returns:
        np.ndarray: å¹³æ»‘åŒ–ã•ã‚ŒãŸå¼·åº¦
    """
    if window_length % 2 == 0:
        window_length += 1  # å¥‡æ•°ã«èª¿æ•´

    smoothed = savgol_filter(intensity, window_length=window_length, polyorder=polyorder)
    return smoothed


# é©ç”¨ä¾‹
two_theta, intensity_raw = generate_synthetic_xrd()

# ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰é™¤å»
background, intensity_corrected = remove_background_polynomial(
    two_theta, intensity_raw, degree=3, exclude_peaks=True
)

# å¹³æ»‘åŒ–
intensity_smoothed = smooth_data_savitzky_golay(intensity_corrected, window_length=11, polyorder=3)

# ãƒ—ãƒ­ãƒƒãƒˆ
plt.figure(figsize=(12, 8))

plt.subplot(3, 1, 1)
plt.plot(two_theta, intensity_raw, 'gray', alpha=0.5, label='ç”Ÿãƒ‡ãƒ¼ã‚¿')
plt.plot(two_theta, background, 'r--', linewidth=2, label='ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰')
plt.xlabel('2Î¸ [åº¦]')
plt.ylabel('å¼·åº¦ [counts]')
plt.legend()
plt.title('ã‚¹ãƒ†ãƒƒãƒ—1: ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰æ¨å®š')
plt.grid(alpha=0.3)

plt.subplot(3, 1, 2)
plt.plot(two_theta, intensity_corrected, 'b', alpha=0.7, label='BGé™¤å»å¾Œ')
plt.xlabel('2Î¸ [åº¦]')
plt.ylabel('å¼·åº¦ [counts]')
plt.legend()
plt.title('ã‚¹ãƒ†ãƒƒãƒ—2: ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰é™¤å»')
plt.grid(alpha=0.3)

plt.subplot(3, 1, 3)
plt.plot(two_theta, intensity_smoothed, color='#f093fb', linewidth=2, label='å¹³æ»‘åŒ–å¾Œ')
plt.xlabel('2Î¸ [åº¦]')
plt.ylabel('å¼·åº¦ [counts]')
plt.legend()
plt.title('ã‚¹ãƒ†ãƒƒãƒ—3: Savitzky-Golayå¹³æ»‘åŒ–')
plt.grid(alpha=0.3)

plt.tight_layout()
plt.show()</code></pre>

        <h2>2.5 ãƒ”ãƒ¼ã‚¯ãƒ•ã‚£ãƒƒãƒ†ã‚£ãƒ³ã‚°</h2>

        <h3>2.5.1 ãƒ”ãƒ¼ã‚¯å½¢çŠ¶é–¢æ•°</h3>

        <p>XRDãƒ”ãƒ¼ã‚¯ã¯ã€è£…ç½®ã®åˆ†è§£èƒ½ã¨è©¦æ–™ã®çµæ™¶æ€§ã«ã‚ˆã‚Šã€æ§˜ã€…ãªå½¢çŠ¶ã‚’ç¤ºã—ã¾ã™:</p>

        <p><strong>Gaussiané–¢æ•°</strong> (è£…ç½®èµ·å› ã®åºƒãŒã‚Š):</p>
        <p style="text-align: center; font-size: 1.05em; margin: 1.5em 0;">
            \[ G(x) = I_0 \exp\left[-\frac{(x - x_0)^2}{2\sigma^2}\right] \]
        </p>

        <p><strong>Lorentziané–¢æ•°</strong> (è©¦æ–™èµ·å› ã®åºƒãŒã‚Šã€çµæ™¶ã‚µã‚¤ã‚º):</p>
        <p style="text-align: center; font-size: 1.05em; margin: 1.5em 0;">
            \[ L(x) = I_0 \left[1 + \left(\frac{x - x_0}{\gamma}\right)^2\right]^{-1} \]
        </p>

        <p><strong>Pseudo-Voigté–¢æ•°</strong> (Gaussã¨Lorentzã®ç·šå½¢çµåˆ):</p>
        <p style="text-align: center; font-size: 1.05em; margin: 1.5em 0;">
            \[ PV(x) = \eta L(x) + (1-\eta) G(x) \]
        </p>

        <pre><code class="language-python">def gaussian(x, amplitude, center, sigma):
    """Gaussiané–¢æ•°

    Args:
        x (np.ndarray): ç‹¬ç«‹å¤‰æ•°
        amplitude (float): ãƒ”ãƒ¼ã‚¯é«˜ã•
        center (float): ãƒ”ãƒ¼ã‚¯ä¸­å¿ƒä½ç½®
        sigma (float): æ¨™æº–åå·®

    Returns:
        np.ndarray: Gaussianæ›²ç·š
    """
    return amplitude * np.exp(-0.5 * ((x - center) / sigma) ** 2)


def lorentzian(x, amplitude, center, gamma):
    """Lorentziané–¢æ•°

    Args:
        x (np.ndarray): ç‹¬ç«‹å¤‰æ•°
        amplitude (float): ãƒ”ãƒ¼ã‚¯é«˜ã•
        center (float): ãƒ”ãƒ¼ã‚¯ä¸­å¿ƒä½ç½®
        gamma (float): åŠå€¤åŠå¹…

    Returns:
        np.ndarray: Lorentzianæ›²ç·š
    """
    return amplitude / (1 + ((x - center) / gamma) ** 2)


def pseudo_voigt(x, amplitude, center, sigma, gamma, eta):
    """Pseudo-Voigté–¢æ•°

    Args:
        x (np.ndarray): ç‹¬ç«‹å¤‰æ•°
        amplitude (float): ãƒ”ãƒ¼ã‚¯é«˜ã•
        center (float): ãƒ”ãƒ¼ã‚¯ä¸­å¿ƒä½ç½®
        sigma (float): Gaussianæˆåˆ†ã®æ¨™æº–åå·®
        gamma (float): Lorentzianæˆåˆ†ã®åŠå€¤åŠå¹…
        eta (float): Lorentzianæˆåˆ†ã®æ··åˆæ¯” (0-1)

    Returns:
        np.ndarray: Pseudo-Voigtæ›²ç·š
    """
    G = gaussian(x, amplitude, center, sigma)
    L = lorentzian(x, amplitude, center, gamma)
    return eta * L + (1 - eta) * G


# ãƒ”ãƒ¼ã‚¯å½¢çŠ¶ã®æ¯”è¼ƒãƒ—ãƒ­ãƒƒãƒˆ
x = np.linspace(40, 50, 500)
amplitude = 1000
center = 45
sigma = 0.1
gamma = 0.1
eta = 0.5

y_gauss = gaussian(x, amplitude, center, sigma)
y_lorentz = lorentzian(x, amplitude, center, gamma)
y_voigt = pseudo_voigt(x, amplitude, center, sigma, gamma, eta)

plt.figure(figsize=(10, 6))
plt.plot(x, y_gauss, label='Gaussian', color='#3498db', linewidth=2)
plt.plot(x, y_lorentz, label='Lorentzian', color='#e74c3c', linewidth=2)
plt.plot(x, y_voigt, label='Pseudo-Voigt (Î·=0.5)', color='#f093fb', linewidth=2, linestyle='--')
plt.xlabel('2Î¸ [åº¦]', fontsize=12)
plt.ylabel('å¼·åº¦ [counts]', fontsize=12)
plt.title('XRDãƒ”ãƒ¼ã‚¯å½¢çŠ¶é–¢æ•°ã®æ¯”è¼ƒ', fontsize=14)
plt.legend(fontsize=11)
plt.grid(alpha=0.3)
plt.tight_layout()
plt.show()</code></pre>

        <h3>2.5.2 scipy.optimizeã‚’ç”¨ã„ãŸãƒ•ã‚£ãƒƒãƒ†ã‚£ãƒ³ã‚°</h3>

        <pre><code class="language-python">from scipy.optimize import curve_fit

def fit_single_peak(two_theta, intensity, peak_center_guess, fit_func='voigt'):
    """å˜ä¸€ãƒ”ãƒ¼ã‚¯ã‚’ãƒ•ã‚£ãƒƒãƒ†ã‚£ãƒ³ã‚°

    Args:
        two_theta (np.ndarray): 2Î¸è§’åº¦
        intensity (np.ndarray): å›æŠ˜å¼·åº¦
        peak_center_guess (float): ãƒ”ãƒ¼ã‚¯ä¸­å¿ƒä½ç½®ã®åˆæœŸæ¨å®š
        fit_func (str): ãƒ•ã‚£ãƒƒãƒˆé–¢æ•° ('gaussian', 'lorentzian', 'voigt')

    Returns:
        dict: ãƒ•ã‚£ãƒƒãƒˆçµæœ {params, covariance, fitted_curve}
    """
    # ãƒ•ã‚£ãƒƒãƒˆç¯„å›²ã‚’åˆ¶é™ (ãƒ”ãƒ¼ã‚¯ä¸­å¿ƒ Â±2åº¦)
    mask = (two_theta >= peak_center_guess - 2) & (two_theta <= peak_center_guess + 2)
    x_fit = two_theta[mask]
    y_fit = intensity[mask]

    # åˆæœŸãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿æ¨å®š
    amplitude_guess = np.max(y_fit)
    sigma_guess = 0.1
    gamma_guess = 0.1

    try:
        if fit_func == 'gaussian':
            popt, pcov = curve_fit(
                gaussian,
                x_fit, y_fit,
                p0=[amplitude_guess, peak_center_guess, sigma_guess],
                bounds=([0, peak_center_guess-1, 0.01], [np.inf, peak_center_guess+1, 1.0])
            )
            fitted_curve = gaussian(two_theta, *popt)
            param_names = ['amplitude', 'center', 'sigma']

        elif fit_func == 'lorentzian':
            popt, pcov = curve_fit(
                lorentzian,
                x_fit, y_fit,
                p0=[amplitude_guess, peak_center_guess, gamma_guess],
                bounds=([0, peak_center_guess-1, 0.01], [np.inf, peak_center_guess+1, 1.0])
            )
            fitted_curve = lorentzian(two_theta, *popt)
            param_names = ['amplitude', 'center', 'gamma']

        elif fit_func == 'voigt':
            popt, pcov = curve_fit(
                pseudo_voigt,
                x_fit, y_fit,
                p0=[amplitude_guess, peak_center_guess, sigma_guess, gamma_guess, 0.5],
                bounds=([0, peak_center_guess-1, 0.01, 0.01, 0], [np.inf, peak_center_guess+1, 1.0, 1.0, 1])
            )
            fitted_curve = pseudo_voigt(two_theta, *popt)
            param_names = ['amplitude', 'center', 'sigma', 'gamma', 'eta']

        else:
            raise ValueError(f"Unknown fit function: {fit_func}")

        # ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®æ¨™æº–èª¤å·®
        perr = np.sqrt(np.diag(pcov))

        result = {
            'function': fit_func,
            'params': dict(zip(param_names, popt)),
            'errors': dict(zip(param_names, perr)),
            'covariance': pcov,
            'fitted_curve': fitted_curve,
            'x_fit': x_fit,
            'y_fit': y_fit
        }

        return result

    except Exception as e:
        print(f"ãƒ•ã‚£ãƒƒãƒ†ã‚£ãƒ³ã‚°ã‚¨ãƒ©ãƒ¼: {e}")
        return None


# å®Ÿè¡Œä¾‹
two_theta, intensity = generate_synthetic_xrd()
background, intensity_corrected = remove_background_polynomial(two_theta, intensity)

# (110)ãƒ”ãƒ¼ã‚¯ã‚’ãƒ•ã‚£ãƒƒãƒˆ
fit_result = fit_single_peak(two_theta, intensity_corrected, peak_center_guess=44.7, fit_func='voigt')

if fit_result:
    print("=== ãƒ”ãƒ¼ã‚¯ãƒ•ã‚£ãƒƒãƒ†ã‚£ãƒ³ã‚°çµæœ (Pseudo-Voigt) ===")
    for param, value in fit_result['params'].items():
        error = fit_result['errors'][param]
        print(f"{param:<12}: {value:10.5f} Â± {error:8.5f}")

    # FWHMè¨ˆç®— (Voigtã®å ´åˆã¯è¿‘ä¼¼)
    sigma = fit_result['params']['sigma']
    fwhm_gauss = 2.355 * sigma  # Gaussianå¯„ä¸
    print(f"\nFWHM (æ¦‚ç®—): {fwhm_gauss:.4f}Â°")

    # ãƒ—ãƒ­ãƒƒãƒˆ
    plt.figure(figsize=(10, 6))
    plt.plot(two_theta, intensity_corrected, 'gray', alpha=0.5, label='å®Ÿæ¸¬ãƒ‡ãƒ¼ã‚¿')
    plt.plot(two_theta, fit_result['fitted_curve'], color='#f093fb', linewidth=2, label='ãƒ•ã‚£ãƒƒãƒˆæ›²ç·š')
    plt.scatter(fit_result['x_fit'], fit_result['y_fit'], color='#f5576c', s=20, alpha=0.7, label='ãƒ•ã‚£ãƒƒãƒˆç¯„å›²')
    plt.xlabel('2Î¸ [åº¦]', fontsize=12)
    plt.ylabel('å¼·åº¦ [counts]', fontsize=12)
    plt.title(f"ãƒ”ãƒ¼ã‚¯ãƒ•ã‚£ãƒƒãƒ†ã‚£ãƒ³ã‚°: {fit_result['params']['center']:.2f}Â°", fontsize=14)
    plt.legend(fontsize=11)
    plt.grid(alpha=0.3)
    plt.tight_layout()
    plt.show()</code></pre>

        <h2>å­¦ç¿’ç›®æ¨™ã®ç¢ºèª</h2>

        <div class="learning-objectives">
            <h3>åŸºæœ¬ç†è§£</h3>
            <ul>
                <li>âœ… XRDè£…ç½®ã®å„æ§‹æˆè¦ç´ (Xç·šæºã€å…‰å­¦ç³»ã€æ¤œå‡ºå™¨)ã®å½¹å‰²</li>
                <li>âœ… æ¸¬å®šæ¡ä»¶(2Î¸ç¯„å›²ã€ã‚¹ãƒ†ãƒƒãƒ—ã‚µã‚¤ã‚ºã€ã‚«ã‚¦ãƒ³ãƒˆæ™‚é–“)ã®æœ€é©åŒ–åŸç†</li>
                <li>âœ… Gaussianã€Lorentzianã€Voigté–¢æ•°ã®ç‰©ç†çš„æ„å‘³</li>
            </ul>

            <h3>å®Ÿè·µã‚¹ã‚­ãƒ«</h3>
            <ul>
                <li>âœ… scipy.signalã§ãƒ”ãƒ¼ã‚¯è‡ªå‹•æ¤œå‡ºã‚’å®Ÿè£…</li>
                <li>âœ… MilleræŒ‡æ•°ã‚’å®Ÿæ¸¬ãƒ”ãƒ¼ã‚¯ã«å‰²ã‚Šå½“ã¦(ç«‹æ–¹æ™¶)</li>
                <li>âœ… å¤šé …å¼ãƒ•ã‚£ãƒƒãƒ†ã‚£ãƒ³ã‚°ã§ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰é™¤å»</li>
                <li>âœ… curve_fitã§å˜ä¸€ãƒ”ãƒ¼ã‚¯ã‚’ãƒ•ã‚£ãƒƒãƒ†ã‚£ãƒ³ã‚°</li>
            </ul>

            <h3>å¿œç”¨åŠ›</h3>
            <ul>
                <li>âœ… æ¸¬å®šæ¡ä»¶ã‚’æœ€é©åŒ–ã—ã€ç·æ¸¬å®šæ™‚é–“ã‚’è¦‹ç©ã‚‚ã‚‹</li>
                <li>âœ… å®Ÿãƒ‡ãƒ¼ã‚¿ã«å¯¾ã—ã¦ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰é™¤å»â†’å¹³æ»‘åŒ–â†’ãƒ”ãƒ¼ã‚¯ãƒ•ã‚£ãƒƒãƒˆã®å®Œå…¨ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã‚’å®Ÿè¡Œ</li>
                <li>âœ… ãƒ•ã‚£ãƒƒãƒˆçµæœã‹ã‚‰FWHMã€ãƒ”ãƒ¼ã‚¯ä½ç½®ã®æ¨™æº–èª¤å·®ã‚’ç®—å‡º</li>
            </ul>
        </div>

        <h2>æ¼”ç¿’å•é¡Œ</h2>

        <h3>Easy (åŸºç¤ç¢ºèª)</h3>

        <details>
            <summary><strong>Q1</strong>: Cu KÎ±ç·š(Î»=1.54Ã…)ã§ã€d=1.2Ã…ã‹ã‚‰5.0Ã…ã®ç¯„å›²ã‚’ã‚«ãƒãƒ¼ã™ã‚‹ã®ã«å¿…è¦ãª2Î¸ç¯„å›²ã‚’è¨ˆç®—ã—ã¦ãã ã•ã„ã€‚</summary>

            <p><strong>è§£ç­”</strong>:</p>
            <pre><code class="language-python">cond = XRDMeasurementConditions(wavelength=1.54056)
two_theta_range = cond.calculate_two_theta_range(d_min=1.2, d_max=5.0)
print(f"å¿…è¦ãª2Î¸ç¯„å›²: {two_theta_range[0]:.2f}Â° - {two_theta_range[1]:.2f}Â°")
# å‡ºåŠ›: å¿…è¦ãª2Î¸ç¯„å›²: 9.14Â° - 40.33Â°</code></pre>
        </details>

        <details>
            <summary><strong>Q2</strong>: ãƒ”ãƒ¼ã‚¯ã®FWHMãŒ0.1Â°ã®å ´åˆã€æ¨å¥¨ã•ã‚Œã‚‹ã‚¹ãƒ†ãƒƒãƒ—ã‚µã‚¤ã‚ºã¯ã„ãã¤ã§ã™ã‹?</summary>

            <p><strong>è§£ç­”</strong>:</p>
            <pre><code class="language-python">cond = XRDMeasurementConditions()
step = cond.optimize_step_size((10, 80), fwhm=0.1)
print(f"æ¨å¥¨ã‚¹ãƒ†ãƒƒãƒ—ã‚µã‚¤ã‚º: {step:.4f}Â°")
# å‡ºåŠ›: æ¨å¥¨ã‚¹ãƒ†ãƒƒãƒ—ã‚µã‚¤ã‚º: 0.0143Â° (FWHM/7)</code></pre>
        </details>

        <h3>Medium (å¿œç”¨)</h3>

        <details>
            <summary><strong>Q3</strong>: Gaussiané–¢æ•°ã¨Lorentziané–¢æ•°ã§ã€åŒã˜FWHM (0.2Â°) ã‚’æŒã¤ãƒ”ãƒ¼ã‚¯ã®å½¢çŠ¶ã®é•ã„ã‚’èª¬æ˜ã—ã¦ãã ã•ã„ã€‚</summary>

            <p><strong>è§£ç­”</strong>:</p>
            <p><strong>FWHM = 0.2Â°ã®å ´åˆ</strong>:</p>
            <ul>
                <li><strong>Gaussian</strong>: Ïƒ = FWHM / (2âˆš(2ln2)) â‰ˆ 0.085Â°</li>
                <li><strong>Lorentzian</strong>: Î³ = FWHM / 2 = 0.1Â°</li>
            </ul>
            <p><strong>å½¢çŠ¶ã®é•ã„</strong>:</p>
            <ul>
                <li>Gaussian: è£¾é‡ãŒæ€¥é€Ÿã«æ¸›è¡° (expæ¸›è¡°)</li>
                <li>Lorentzian: è£¾é‡ãŒåºƒã„ (ã¹ãä¹—æ¸›è¡°)</li>
                <li>Lorentzianã®æ–¹ãŒãƒ”ãƒ¼ã‚¯ã®ã™ããŒé•·ãå¼•ã â†’ çµæ™¶ã‚µã‚¤ã‚ºãŒå°ã•ã„è©¦æ–™ã«é¡•è‘—</li>
            </ul>
        </details>

        <details>
            <summary><strong>Q4</strong>: Î±-Fe (BCC, a=2.87Ã…) ã§è¦³æ¸¬ã•ã‚Œã‚‹æœ€åˆã®3ã¤ã®ãƒ”ãƒ¼ã‚¯ã®MilleræŒ‡æ•°ã¨2Î¸ä½ç½®ã‚’è¨ˆç®—ã—ã¦ãã ã•ã„ã€‚</summary>

            <p><strong>è§£ç­”</strong>:</p>
            <pre><code class="language-python"># BCCã®æ¶ˆæ»…å‰‡: h+k+l = å¶æ•°
# æœ€å°ã®h^2+k^2+l^2: (110)â†’2, (200)â†’4, (211)â†’6
from scipy.constants import physical_constants

wavelength = 1.54056
a = 2.87

peaks = [
    (1, 1, 0, 2),
    (2, 0, 0, 4),
    (2, 1, 1, 6)
]

for h, k, l, h2k2l2 in peaks:
    d = a / np.sqrt(h2k2l2)
    theta = np.degrees(np.arcsin(wavelength / (2 * d)))
    two_theta = 2 * theta
    print(f"({h}{k}{l}): d={d:.4f}Ã…, 2Î¸={two_theta:.2f}Â°")

# æœŸå¾…ã•ã‚Œã‚‹å‡ºåŠ›:
# (110): d=2.0293Ã…, 2Î¸=44.67Â°
# (200): d=1.4350Ã…, 2Î¸=65.02Â°
# (211): d=1.1707Ã…, 2Î¸=82.33Â°</code></pre>
        </details>

        <h3>Hard (ç™ºå±•)</h3>

        <details>
            <summary><strong>Q5</strong>: å¤šé …å¼æ¬¡æ•°(1æ¬¡ã€3æ¬¡ã€5æ¬¡)ã‚’å¤‰ãˆã¦ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰é™¤å»ã‚’è¡Œã„ã€æœ€é©ãªæ¬¡æ•°ã‚’é¸æŠã™ã‚‹åŸºæº–ã‚’èª¬æ˜ã—ã¦ãã ã•ã„ã€‚</summary>

            <p><strong>è§£ç­”</strong>:</p>
            <pre><code class="language-python"># ç•°ãªã‚‹æ¬¡æ•°ã§ãƒ•ã‚£ãƒƒãƒˆ
degrees = [1, 3, 5]
for deg in degrees:
    bg, corrected = remove_background_polynomial(two_theta, intensity, degree=deg)
    residual = intensity - bg
    rms = np.sqrt(np.mean((residual - np.mean(residual))**2))
    print(f"æ¬¡æ•°{deg}: RMSæ®‹å·® = {rms:.2f}")

# åˆ¤æ–­åŸºæº–:
# 1. è¦–è¦šçš„è©•ä¾¡: BGãŒãƒ”ãƒ¼ã‚¯ã‚’é€šéã—ã¦ã„ãªã„ã‹
# 2. æ®‹å·®ã®å¤§ãã•: å°ã•ã™ãã‚‹ã¨overfitting
# 3. ãƒ”ãƒ¼ã‚¯é ˜åŸŸã®ä¿å­˜: å¼·åº¦ãŒè² ã«ãªã‚‰ãªã„ã‹
# æ¨å¥¨: 3æ¬¡å¤šé …å¼ (æŸ”è»Ÿæ€§ã¨å®‰å®šæ€§ã®ãƒãƒ©ãƒ³ã‚¹)</code></pre>
            <p><strong>æœ€é©æ¬¡æ•°ã®é¸æŠåŸºæº–</strong>:</p>
            <ol>
                <li><strong>æ¬¡æ•°ãŒä½ã™ãã‚‹(1æ¬¡)</strong>: BGã®æ›²ç·šã‚’æ‰ãˆã‚‰ã‚Œãªã„ â†’ ãƒ”ãƒ¼ã‚¯å¼·åº¦ãŒéå¤§è©•ä¾¡</li>
                <li><strong>é©åˆ‡(3æ¬¡)</strong>: BGã‚’æ»‘ã‚‰ã‹ã«ãƒ•ã‚£ãƒƒãƒˆã€ãƒ”ãƒ¼ã‚¯ã‚’é¿ã‘ã‚‹</li>
                <li><strong>æ¬¡æ•°ãŒé«˜ã™ãã‚‹(5æ¬¡ä»¥ä¸Š)</strong>: ãƒ”ãƒ¼ã‚¯ã«ãƒ•ã‚£ãƒƒãƒˆã—ã¦ã—ã¾ã† â†’ å¼·åº¦ãŒéå°è©•ä¾¡</li>
            </ol>
            <p>å®Ÿç”¨çš„ã«ã¯<strong>3æ¬¡å¤šé …å¼</strong>ãŒæœ€ã‚‚ä¸€èˆ¬çš„ã§ã™ã€‚</p>
        </details>

        <h2>å­¦ç¿’ç›®æ¨™ã®ç¢ºèª</h2>

        <p>ã“ã®ç« ã‚’å®Œäº†ã™ã‚‹ã¨ã€ä»¥ä¸‹ã‚’èª¬æ˜ãƒ»å®Ÿè£…ã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ï¼š</p>

        <h3>åŸºæœ¬ç†è§£</h3>
        <ul>
            <li>âœ… XRDè£…ç½®ã®æ§‹æˆè¦ç´ ï¼ˆXç·šæºã€ã‚´ãƒ‹ã‚ªãƒ¡ãƒ¼ã‚¿ã€æ¤œå‡ºå™¨ï¼‰ã®å½¹å‰²ã‚’èª¬æ˜ã§ãã‚‹</li>
            <li>âœ… æ¸¬å®šæ¡ä»¶ï¼ˆ2Î¸ç¯„å›²ã€ã‚¹ãƒ†ãƒƒãƒ—ã‚µã‚¤ã‚ºã€ç©ç®—æ™‚é–“ï¼‰ãŒçµæœã«ä¸ãˆã‚‹å½±éŸ¿ã‚’ç†è§£ã—ã¦ã„ã‚‹</li>
            <li>âœ… ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã®ç™ºç”Ÿæºï¼ˆéå¼¾æ€§æ•£ä¹±ã€è›å…‰Xç·šï¼‰ã‚’èª¬æ˜ã§ãã‚‹</li>
            <li>âœ… ãƒ”ãƒ¼ã‚¯ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«é–¢æ•°ï¼ˆGaussian, Lorentz, Voigtï¼‰ã®ç‰¹å¾´ã‚’ç†è§£ã—ã¦ã„ã‚‹</li>
        </ul>

        <h3>å®Ÿè·µã‚¹ã‚­ãƒ«</h3>
        <ul>
            <li>âœ… Pythonã§ç”ŸXRDãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿ã€ãƒ—ãƒ­ãƒƒãƒˆã§ãã‚‹</li>
            <li>âœ… ãƒ”ãƒ¼ã‚¯æ¤œå‡ºã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ï¼ˆscipy.signal.find_peaksï¼‰ã‚’é©ç”¨ã§ãã‚‹</li>
            <li>âœ… å¤šé …å¼ãƒ•ã‚£ãƒƒãƒ†ã‚£ãƒ³ã‚°ã§ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã‚’é™¤å»ã§ãã‚‹</li>
            <li>âœ… Voigté–¢æ•°ã§ãƒ”ãƒ¼ã‚¯ãƒ•ã‚£ãƒƒãƒ†ã‚£ãƒ³ã‚°ã‚’å®Ÿè¡Œã—ã€ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’æŠ½å‡ºã§ãã‚‹</li>
            <li>âœ… æ ¼å­å®šæ•°ã‹ã‚‰ãƒ”ãƒ¼ã‚¯ã‚’ã‚¤ãƒ³ãƒ‡ã‚­ã‚·ãƒ³ã‚°ã§ãã‚‹</li>
        </ul>

        <h3>å¿œç”¨åŠ›</h3>
        <ul>
            <li>âœ… å®Ÿæ¸¬XRDãƒ‡ãƒ¼ã‚¿ã®å“è³ªã‚’è©•ä¾¡ã—ã€æ¸¬å®šæ¡ä»¶ã‚’æœ€é©åŒ–ã§ãã‚‹</li>
            <li>âœ… å¤šç›¸æ··åˆç‰©ã®ãƒ”ãƒ¼ã‚¯ã‚’åŒºåˆ¥ã—ã€ä¸»è¦ç›¸ã‚’åŒå®šã§ãã‚‹</li>
            <li>âœ… ãƒ”ãƒ¼ã‚¯å¹…ã‹ã‚‰çµæ™¶å­ã‚µã‚¤ã‚ºã‚’æ¦‚ç®—ã§ãã‚‹ï¼ˆScherrerå¼ï¼‰</li>
            <li>âœ… XRDè§£æã®å®Œå…¨ãªãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã‚’æ§‹ç¯‰ã§ãã‚‹</li>
        </ul>

        <h2>å‚è€ƒæ–‡çŒ®</h2>

        <ol>
            <li>Jenkins, R., & Snyder, R. L. (1996). <em>Introduction to X-Ray Powder Diffractometry</em>. Wiley. - XRDè£…ç½®ã®åŸç†ã¨æ¸¬å®šæŠ€è¡“ã‚’è©³ç´°ã«è§£èª¬ã—ãŸå®Ÿè·µçš„æ•™ç§‘æ›¸</li>
            <li>Dinnebier, R. E., & Billinge, S. J. L. (Eds.). (2008). <em>Powder Diffraction: Theory and Practice</em>. Royal Society of Chemistry. - ç²‰æœ«XRDã®ç†è«–ã¨å®Ÿè·µã‚’ç¶²ç¾…ã—ãŸæ±ºå®šç‰ˆ</li>
            <li>Langford, J. I., & LouÃ«r, D. (1996). "Powder diffraction". <em>Reports on Progress in Physics</em>, 59(2), 131-234. - ãƒ”ãƒ¼ã‚¯ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«è§£æã®ç†è«–çš„åŸºç¤ã‚’æä¾›ã™ã‚‹é‡è¦ãƒ¬ãƒ“ãƒ¥ãƒ¼</li>
            <li>ICDD PDF-4+ Database (2024). International Centre for Diffraction Data. - 40ä¸‡ä»¥ä¸Šã®å‚ç…§ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’åéŒ²ã—ãŸä¸–ç•Œæ¨™æº–XRDãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹</li>
            <li>Scherrer, P. (1918). "Bestimmung der GrÃ¶ÃŸe und der inneren Struktur von Kolloidteilchen mittels RÃ¶ntgenstrahlen". <em>Nachrichten von der Gesellschaft der Wissenschaften zu GÃ¶ttingen</em>, 2, 98-100. - çµæ™¶å­ã‚µã‚¤ã‚ºè§£æã®å…ƒç¥–è«–æ–‡</li>
            <li>Klug, H. P., & Alexander, L. E. (1974). <em>X-Ray Diffraction Procedures for Polycrystalline and Amorphous Materials</em> (2nd ed.). Wiley. - ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰é™¤å»ã¨ãƒ”ãƒ¼ã‚¯åˆ†é›¢æŠ€è¡“ã®å¤å…¸çš„è§£èª¬</li>
            <li>scipy.signal documentation (2024). "Signal processing (scipy.signal)". SciPy project. - find_peaksé–¢æ•°ã®è©³ç´°ä»•æ§˜ã¨ãƒ”ãƒ¼ã‚¯æ¤œå‡ºã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ </li>
        </ol>

        <h2>æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—</h2>

        <p>ç¬¬2ç« ã§ã¯ã€å®Ÿéš›ã®XRDæ¸¬å®šãƒ‡ãƒ¼ã‚¿ã®å–å¾—ã‹ã‚‰åŸºæœ¬çš„ãªè§£æã¾ã§ã‚’å­¦ã³ã¾ã—ãŸã€‚ãƒ”ãƒ¼ã‚¯æ¤œå‡ºã€ã‚¤ãƒ³ãƒ‡ã‚­ã‚·ãƒ³ã‚°ã€ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰å‡¦ç†ã€ãã—ã¦ãƒ”ãƒ¼ã‚¯ãƒ•ã‚£ãƒƒãƒ†ã‚£ãƒ³ã‚°ã¨ã„ã†ä¸€é€£ã®ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã‚’ç¿’å¾—ã—ã¾ã—ãŸã€‚</p>

        <p><strong>ç¬¬3ç« </strong>ã§ã¯ã€ã“ã‚Œã‚‰ã®æŠ€è¡“ã‚’çµ±åˆã—ã€ãƒªãƒ¼ãƒˆãƒ™ãƒ«ãƒˆæ³•ã«ã‚ˆã‚‹ç²¾å¯†è§£æã«é€²ã¿ã¾ã™ã€‚å…¨ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒ•ã‚£ãƒƒãƒ†ã‚£ãƒ³ã‚°ã«ã‚ˆã‚Šã€æ ¼å­å®šæ•°ã€åŸå­åº§æ¨™ã€çµæ™¶å­ã‚µã‚¤ã‚ºãªã©ã€ã‚ˆã‚Šè©³ç´°ãªæ§‹é€ æƒ…å ±ã‚’æŠ½å‡ºã—ã¾ã™ã€‚</p>

        <div class="navigation">
            <a href="./chapter-1.html" class="nav-button">â† ç¬¬1ç« : Xç·šå›æŠ˜ã®åŸºç¤</a>
            <a href="./chapter-3.html" class="nav-button">ç¬¬3ç« : ãƒªãƒ¼ãƒˆãƒ™ãƒ«ãƒˆè§£æå…¥é–€ â†’</a>
        </div>
    </main>

    <footer>
        <p>&copy; 2025 MS Terakoya - Materials Science Learning Platform</p>
        <p><a href="../../index.html">ãƒˆãƒƒãƒ—ãƒšãƒ¼ã‚¸ã«æˆ»ã‚‹</a></p>
    </footer>
</body>
</html>