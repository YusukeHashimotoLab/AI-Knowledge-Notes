<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>第4章: X線光電子分光法 (XPS) - 分光分析法入門</title>

    <!-- MathJax for equations -->
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <!-- Mermaid for diagrams -->
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>

    <!-- Prism.js for code highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>

    <style>
        :root {
            --color-primary: #2c3e50;
            --color-accent: #f093fb;
            --color-accent-light: #f5576c;
            --color-bg: #ffffff;
            --color-text: #333333;
            --color-border: #e0e0e0;
            --color-code-bg: #f8f9fa;
            --spacing-unit: 8px;
            --font-body: 'Segoe UI', 'Helvetica Neue', Arial, sans-serif;
            --font-code: 'Consolas', 'Monaco', monospace;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-body);
            line-height: 1.8;
            color: var(--color-text);
            background: var(--color-bg);
            padding: calc(var(--spacing-unit) * 4);
            max-width: 1200px;
            margin: 0 auto;
        }

        h1, h2, h3, h4 {
            color: var(--color-primary);
            margin-top: calc(var(--spacing-unit) * 6);
            margin-bottom: calc(var(--spacing-unit) * 3);
            line-height: 1.3;
        }

        h1 {
            font-size: 2.5rem;
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            padding-bottom: calc(var(--spacing-unit) * 2);
            border-bottom: 3px solid var(--color-accent);
        }

        h2 {
            font-size: 1.8rem;
            padding-left: calc(var(--spacing-unit) * 2);
            border-left: 4px solid var(--color-accent);
        }

        h3 {
            font-size: 1.4rem;
            color: var(--color-accent-light);
        }

        h4 {
            font-size: 1.2rem;
        }

        p {
            margin-bottom: calc(var(--spacing-unit) * 2);
            text-align: justify;
        }

        .intro-box {
            background: linear-gradient(135deg, rgba(240, 147, 251, 0.1) 0%, rgba(245, 87, 108, 0.1) 100%);
            padding: calc(var(--spacing-unit) * 3);
            border-radius: 8px;
            border-left: 4px solid var(--color-accent);
            margin: calc(var(--spacing-unit) * 4) 0;
        }

        .key-concept {
            background: var(--color-code-bg);
            padding: calc(var(--spacing-unit) * 3);
            border-radius: 8px;
            margin: calc(var(--spacing-unit) * 3) 0;
            border: 2px solid var(--color-border);
        }

        .equation-box {
            background: #fff;
            padding: calc(var(--spacing-unit) * 3);
            border-radius: 8px;
            margin: calc(var(--spacing-unit) * 3) 0;
            border: 2px solid var(--color-accent-light);
            box-shadow: 0 2px 8px rgba(245, 87, 108, 0.1);
        }

        code {
            font-family: var(--font-code);
            background: var(--color-code-bg);
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.9em;
        }

        pre {
            background: #2d2d2d;
            padding: calc(var(--spacing-unit) * 3);
            border-radius: 8px;
            overflow-x: auto;
            margin: calc(var(--spacing-unit) * 3) 0;
            border: 2px solid var(--color-accent);
        }

        pre code {
            background: none;
            color: #f8f8f2;
            padding: 0;
        }

        .mermaid {
            background: white;
            padding: calc(var(--spacing-unit) * 3);
            border-radius: 8px;
            margin: calc(var(--spacing-unit) * 4) 0;
            border: 2px solid var(--color-border);
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: calc(var(--spacing-unit) * 3) 0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        th, td {
            padding: calc(var(--spacing-unit) * 2);
            text-align: left;
            border: 1px solid var(--color-border);
        }

        th {
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            color: white;
            font-weight: 600;
        }

        tr:nth-child(even) {
            background: var(--color-code-bg);
        }

        ul, ol {
            margin: calc(var(--spacing-unit) * 2) 0;
            padding-left: calc(var(--spacing-unit) * 5);
        }

        li {
            margin: calc(var(--spacing-unit) * 1) 0;
        }

        .exercise-box {
            background: linear-gradient(135deg, rgba(240, 147, 251, 0.05) 0%, rgba(245, 87, 108, 0.05) 100%);
            padding: calc(var(--spacing-unit) * 3);
            border-radius: 8px;
            margin: calc(var(--spacing-unit) * 3) 0;
            border-left: 4px solid var(--color-accent-light);
        }

        .exercise-box h4 {
            color: var(--color-accent-light);
            margin-top: 0;
        }

        details {
            margin: calc(var(--spacing-unit) * 2) 0;
            padding: calc(var(--spacing-unit) * 2);
            background: white;
            border-radius: 8px;
            border: 1px solid var(--color-border);
        }

        summary {
            cursor: pointer;
            font-weight: 600;
            color: var(--color-accent-light);
            padding: calc(var(--spacing-unit) * 1);
        }

        summary:hover {
            color: var(--color-accent);
        }

        .learning-objectives {
            background: linear-gradient(135deg, rgba(240, 147, 251, 0.1) 0%, rgba(245, 87, 108, 0.1) 100%);
            padding: calc(var(--spacing-unit) * 3);
            border-radius: 8px;
            margin: calc(var(--spacing-unit) * 4) 0;
        }

        .learning-objectives ul {
            list-style: none;
            padding-left: 0;
        }

        .learning-objectives li::before {
            content: "✓ ";
            color: var(--color-accent-light);
            font-weight: bold;
            margin-right: calc(var(--spacing-unit) * 1);
        }

        .references {
            background: var(--color-code-bg);
            padding: calc(var(--spacing-unit) * 3);
            border-radius: 8px;
            margin-top: calc(var(--spacing-unit) * 6);
        }

        .references h2 {
            border-left: none;
            padding-left: 0;
        }

        .references ol {
            padding-left: calc(var(--spacing-unit) * 4);
        }

        .references li {
            margin: calc(var(--spacing-unit) * 2) 0;
            line-height: 1.6;
        }

        @media (max-width: 768px) {
            body {
                padding: calc(var(--spacing-unit) * 2);
            }

            h1 {
                font-size: 2rem;
            }

            h2 {
                font-size: 1.5rem;
            }

            pre {
                padding: calc(var(--spacing-unit) * 2);
            }
        }
    
        
    
        /* Breadcrumb styles */
        .breadcrumb {
            background: #f7fafc;
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #e2e8f0;
            font-size: 0.9rem;
        }

        .breadcrumb-content {
            max-width: 900px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .breadcrumb a {
            color: #667eea;
            text-decoration: none;
            transition: color 0.2s;
        }

        .breadcrumb a:hover {
            color: #764ba2;
            text-decoration: underline;
        }

        .breadcrumb-separator {
            color: #a0aec0;
            margin: 0 0.25rem;
        }

        .breadcrumb-current {
            color: #4a5568;
            font-weight: 500;
        }
    </style>
</head>
<body>
            <nav class="breadcrumb">
        <div class="breadcrumb-content">
            <a href="/AI-Knowledge-Notes/knowledge/jp/index.html">AI寺子屋トップ</a><span class="breadcrumb-separator">›</span><a href="/AI-Knowledge-Notes/knowledge/jp/MS/index.html">材料科学</a><span class="breadcrumb-separator">›</span><a href="/AI-Knowledge-Notes/knowledge/jp/MS/spectroscopy-introduction/index.html">Spectroscopy</a><span class="breadcrumb-separator">›</span><span class="breadcrumb-current">Chapter 4</span>
        </div>
    </nav>
<h1>第4章: X線光電子分光法 (XPS: X-ray Photoelectron Spectroscopy)</h1>

    <div class="intro-box">
        <p><strong>この章で学ぶこと:</strong> X線光電子分光法（XPS）は、材料表面の化学組成と電子状態を高感度で分析する表面分析手法です。光電効果の原理に基づき、試料表面から放出される光電子の運動エネルギーを測定することで、元素同定、化学シフト解析、定量分析、深さ方向分析を実現します。本章では、XPSの物理的原理から実践的なピークフィッティング法、定量分析アルゴリズム、深さプロファイリングまで、XPSデータ解析の基礎から応用までを体系的に学びます。</p>
    </div>

    <h2>4.1 X線光電子分光法の原理</h2>

    <h3>4.1.1 光電効果とアインシュタインの式</h3>

    <p>XPSは、Albert Einstein（1905）により理論化された光電効果に基づきます。試料にX線を照射すると、X線の光子エネルギーが電子に吸収され、電子が試料表面から放出されます（光電子）。</p>

    <div class="equation-box">
        <p><strong>光電子の運動エネルギー（アインシュタインの式）:</strong></p>
        \[
        E_{\text{kinetic}} = h\nu - E_{\text{binding}} - \phi
        \]
        <p>ここで、\( h\nu \) は入射X線の光子エネルギー、\( E_{\text{binding}} \) は電子の結合エネルギー（束縛エネルギー）、\( \phi \) は装置の仕事関数です。</p>

        <p><strong>結合エネルギーの決定:</strong></p>
        \[
        E_{\text{binding}} = h\nu - E_{\text{kinetic}} - \phi
        \]
        <p>XPSでは、運動エネルギー \( E_{\text{kinetic}} \) を測定することで、結合エネルギー \( E_{\text{binding}} \) を決定します。結合エネルギーは元素と化学状態に固有の値を持ち、元素同定と化学状態解析を可能にします。</p>
    </div>

    <h3>4.1.2 XPS測定の特徴</h3>

    <div class="key-concept">
        <h4>XPSの主要な特徴</h4>
        <ul>
            <li><strong>表面感度:</strong> 光電子の非弾性平均自由行程（IMFP）は数 nm であり、試料表面から約 5-10 nm の情報を取得</li>
            <li><strong>元素同定:</strong> Li を除く全ての元素を検出可能（検出限界: 0.1-1 at%）</li>
            <li><strong>化学状態解析:</strong> 化学シフト（0.1-10 eV）により、酸化状態、配位環境を識別</li>
            <li><strong>定量分析:</strong> ピーク面積から元素組成比を決定（相対誤差: ±10%）</li>
            <li><strong>非破壊分析:</strong> 通常測定では試料損傷がほとんどない</li>
            <li><strong>超高真空環境:</strong> 測定は 10<sup>-7</sup> - 10<sup>-9</sup> Pa の超高真空下で実施</li>
        </ul>
    </div>

    <h3>4.1.3 X線源とエネルギー分解能</h3>

    <p>XPSで使用される代表的なX線源は、Al Kα線（1486.6 eV）とMg Kα線（1253.6 eV）です。単色化X線源を使用することで、エネルギー分解能を向上させることができます。</p>

    <table>
        <thead>
            <tr>
                <th>X線源</th>
                <th>光子エネルギー (eV)</th>
                <th>線幅 (eV)</th>
                <th>エネルギー分解能</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Mg Kα（非単色化）</td>
                <td>1253.6</td>
                <td>0.7</td>
                <td>標準</td>
            </tr>
            <tr>
                <td>Al Kα（非単色化）</td>
                <td>1486.6</td>
                <td>0.85</td>
                <td>標準</td>
            </tr>
            <tr>
                <td>Al Kα（単色化）</td>
                <td>1486.6</td>
                <td>0.2-0.3</td>
                <td>高分解能</td>
            </tr>
        </tbody>
    </table>

    <div class="mermaid">
    flowchart LR
        A[X線照射<br/>hν = 1486.6 eV] --> B[試料表面<br/>原子軌道]
        B --> C[光電子放出<br/>E_kinetic測定]
        C --> D[エネルギー分析器<br/>半球型分析器]
        D --> E[検出器<br/>電子カウント]
        E --> F[XPSスペクトル<br/>E_binding vs. Intensity]

        style A fill:#e3f2fd
        style B fill:#fff3e0
        style C fill:#fce4ec
        style D fill:#e8f5e9
        style E fill:#f3e5f5
        style F fill:#ffe0b2
    </mermaid>

    <h2>4.2 化学シフトとピーク同定</h2>

    <h3>4.2.1 化学シフトの起源</h3>

    <p>原子の化学状態（酸化状態、配位環境）が変化すると、内殻電子の結合エネルギーがシフトします。これを化学シフト（chemical shift）と呼びます。</p>

    <div class="key-concept">
        <h4>化学シフトの原理</h4>
        <p><strong>高酸化状態 → 結合エネルギー増加（高エネルギー側へシフト）</strong></p>
        <ul>
            <li>電子が引き抜かれることで、原子核の有効核電荷が増加</li>
            <li>内殻電子がより強く束縛される</li>
            <li>例: C 1s ピーク: C-C (284.5 eV) < C-O (286.5 eV) < C=O (288.0 eV) < O-C=O (289.5 eV)</li>
        </ul>

        <p><strong>電子密度増加 → 結合エネルギー減少（低エネルギー側へシフト）</strong></p>
        <ul>
            <li>周囲の電子供与基により、原子の電子密度が増加</li>
            <li>内殻電子の遮蔽効果が強まる</li>
            <li>例: Si 2p ピーク: SiO<sub>2</sub> (103.5 eV) > Si (99.3 eV)</li>
        </ul>
    </div>

    <h3>4.2.2 代表的な元素のXPSピーク</h3>

    <table>
        <thead>
            <tr>
                <th>元素</th>
                <th>ピーク</th>
                <th>結合エネルギー (eV)</th>
                <th>化学状態</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td rowspan="4">C</td>
                <td>1s</td>
                <td>284.5</td>
                <td>C-C, C-H（炭化水素）</td>
            </tr>
            <tr>
                <td>1s</td>
                <td>286.5</td>
                <td>C-O（エーテル、アルコール）</td>
            </tr>
            <tr>
                <td>1s</td>
                <td>288.0</td>
                <td>C=O（カルボニル）</td>
            </tr>
            <tr>
                <td>1s</td>
                <td>289.5</td>
                <td>O-C=O（カルボキシル）</td>
            </tr>
            <tr>
                <td rowspan="2">Si</td>
                <td>2p<sub>3/2</sub></td>
                <td>99.3</td>
                <td>Si<sup>0</sup>（金属シリコン）</td>
            </tr>
            <tr>
                <td>2p<sub>3/2</sub></td>
                <td>103.5</td>
                <td>Si<sup>4+</sup>（SiO<sub>2</sub>）</td>
            </tr>
            <tr>
                <td rowspan="3">Fe</td>
                <td>2p<sub>3/2</sub></td>
                <td>707.0</td>
                <td>Fe<sup>0</sup>（金属鉄）</td>
            </tr>
            <tr>
                <td>2p<sub>3/2</sub></td>
                <td>710.8</td>
                <td>Fe<sup>3+</sup>（Fe<sub>2</sub>O<sub>3</sub>）</td>
            </tr>
            <tr>
                <td>2p<sub>3/2</sub></td>
                <td>709.5</td>
                <td>Fe<sup>2+</sup>（FeO）</td>
            </tr>
            <tr>
                <td rowspan="2">O</td>
                <td>1s</td>
                <td>530.0</td>
                <td>金属酸化物（M-O）</td>
            </tr>
            <tr>
                <td>1s</td>
                <td>532.5</td>
                <td>有機化合物（C-O, C=O）</td>
            </tr>
        </tbody>
    </table>

    <h4>コード例1: XPSスペクトルのシミュレーションとピーク同定</h4>

<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt

def gaussian_peak(x, amplitude, center, width):
    """
    ガウス型ピークを生成

    Parameters:
    -----------
    x : array
        結合エネルギー (eV)
    amplitude : float
        ピーク高さ
    center : float
        ピーク中心 (eV)
    width : float
        半値全幅（FWHM, eV）

    Returns:
    --------
    peak : array
        ガウス型ピークの強度
    """
    sigma = width / (2 * np.sqrt(2 * np.log(2)))
    peak = amplitude * np.exp(-((x - center)**2) / (2 * sigma**2))
    return peak

def simulate_xps_c1s_spectrum():
    """
    C 1s XPSスペクトルをシミュレート（複数の化学状態）
    """
    # 結合エネルギー範囲
    BE = np.linspace(280, 295, 1500)

    # C 1s ピーク（4つの化学状態）
    C_CC = gaussian_peak(BE, amplitude=1000, center=284.5, width=1.2)   # C-C, C-H
    C_CO = gaussian_peak(BE, amplitude=300, center=286.5, width=1.3)    # C-O
    C_O = gaussian_peak(BE, amplitude=150, center=288.0, width=1.4)     # C=O
    COO = gaussian_peak(BE, amplitude=80, center=289.5, width=1.5)      # O-C=O

    # 総スペクトル
    total_spectrum = C_CC + C_CO + C_O + COO

    # ノイズ
    noise = np.random.normal(0, 10, len(BE))
    observed_spectrum = total_spectrum + noise

    # プロット
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 5))

    # スペクトル全体
    ax1.plot(BE, observed_spectrum, 'k-', linewidth=1.5, label='観測スペクトル')
    ax1.fill_between(BE, C_CC, alpha=0.3, color='blue', label='C-C, C-H (284.5 eV)')
    ax1.fill_between(BE, C_CO, alpha=0.3, color='green', label='C-O (286.5 eV)')
    ax1.fill_between(BE, C_O, alpha=0.3, color='orange', label='C=O (288.0 eV)')
    ax1.fill_between(BE, COO, alpha=0.3, color='red', label='O-C=O (289.5 eV)')
    ax1.set_xlabel('結合エネルギー (eV)', fontsize=12)
    ax1.set_ylabel('強度 (cps)', fontsize=12)
    ax1.set_title('C 1s XPSスペクトル（多成分）', fontsize=14, fontweight='bold')
    ax1.legend(loc='upper right', fontsize=9)
    ax1.grid(alpha=0.3)
    ax1.invert_xaxis()  # XPSの慣例（高エネルギー → 低エネルギー）

    # 各成分の分離
    ax2.plot(BE, C_CC, 'b-', linewidth=2, label='C-C, C-H')
    ax2.plot(BE, C_CO, 'g-', linewidth=2, label='C-O')
    ax2.plot(BE, C_O, 'orange', linewidth=2, label='C=O')
    ax2.plot(BE, COO, 'r-', linewidth=2, label='O-C=O')
    ax2.axvline(284.5, color='blue', linestyle='--', alpha=0.5)
    ax2.axvline(286.5, color='green', linestyle='--', alpha=0.5)
    ax2.axvline(288.0, color='orange', linestyle='--', alpha=0.5)
    ax2.axvline(289.5, color='red', linestyle='--', alpha=0.5)
    ax2.set_xlabel('結合エネルギー (eV)', fontsize=12)
    ax2.set_ylabel('強度 (cps)', fontsize=12)
    ax2.set_title('各化学状態の分離', fontsize=14, fontweight='bold')
    ax2.legend()
    ax2.grid(alpha=0.3)
    ax2.invert_xaxis()

    plt.tight_layout()
    plt.show()

    print("C 1s ピーク同定:")
    print("  284.5 eV: C-C, C-H（炭化水素骨格）")
    print("  286.5 eV: C-O（エーテル、アルコール）")
    print("  288.0 eV: C=O（カルボニル基）")
    print("  289.5 eV: O-C=O（カルボキシル基）")

# 実行
simulate_xps_c1s_spectrum()
</code></pre>

    <h2>4.3 ピークフィッティングとデコンボリューション</h2>

    <h3>4.3.1 ピーク形状の選択</h3>

    <p>XPSピークは、ガウス型とローレンツ型の混合であるVoigt関数（またはその近似であるGaussian-Lorentzian関数）で表されます。</p>

    <div class="equation-box">
        <p><strong>Gaussian-Lorentzian (GL) 混合関数:</strong></p>
        \[
        f(x) = m \cdot G(x) + (1-m) \cdot L(x)
        \]
        <p>ここで、\( G(x) \) はガウス関数、\( L(x) \) はローレンツ関数、\( m \)（0 ≤ m ≤ 1）は混合比です。</p>

        <p><strong>ガウス関数:</strong></p>
        \[
        G(x) = A \exp\left(-\frac{(x - x_0)^2}{2\sigma^2}\right)
        \]

        <p><strong>ローレンツ関数:</strong></p>
        \[
        L(x) = A \frac{\gamma^2}{(x - x_0)^2 + \gamma^2}
        \]
    </div>

    <h3>4.3.2 Shirleyバックグラウンド</h3>

    <p>XPSスペクトルには、非弾性散乱された電子によるバックグラウンドが重畳します。David A. Shirley（1972）が提案したShirleyバックグラウンドが広く使用されます。</p>

    <h4>コード例2: Shirleyバックグラウンド減算とピークフィッティング</h4>

<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit

def shirley_background(x, y, tol=1e-5, max_iter=50):
    """
    Shirleyバックグラウンドを計算

    Parameters:
    -----------
    x : array
        結合エネルギー (eV)
    y : array
        観測強度
    tol : float
        収束判定基準
    max_iter : int
        最大反復回数

    Returns:
    --------
    background : array
        Shirleyバックグラウンド
    """
    # データの昇順ソート（BE: 高 → 低）
    if x[0] < x[-1]:
        x = x[::-1]
        y = y[::-1]

    # 初期化
    background = np.zeros_like(y)
    y_max = np.max(y)
    y_min = np.min(y)

    # 反復計算
    for iteration in range(max_iter):
        # 各点でのバックグラウンド計算
        for i in range(1, len(x)):
            integral = np.trapz(y[:i] - background[:i], x[:i])
            background[i] = y_min + (y_max - y_min) * integral / np.trapz(y - background, x)

        # 収束判定
        if iteration > 0:
            change = np.max(np.abs(background - background_old))
            if change < tol:
                break
        background_old = background.copy()

    return background

def voigt_approximation(x, amplitude, center, sigma, gamma):
    """
    Voigt関数の近似（Gaussian-Lorentzian混合）

    Parameters:
    -----------
    x : array
        結合エネルギー
    amplitude : float
        ピーク高さ
    center : float
        ピーク中心
    sigma : float
        ガウス成分の幅
    gamma : float
        ローレンツ成分の幅

    Returns:
    --------
    voigt : array
        Voigt関数の値
    """
    gaussian = np.exp(-((x - center)**2) / (2 * sigma**2))
    lorentzian = gamma**2 / ((x - center)**2 + gamma**2)
    voigt = amplitude * (0.7 * gaussian + 0.3 * lorentzian)
    return voigt

def multi_peak_fit(x, y, initial_params):
    """
    複数ピークのフィッティング

    Parameters:
    -----------
    x : array
        結合エネルギー
    y : array
        強度
    initial_params : list of tuples
        各ピークの初期パラメータ [(A1, c1, s1, g1), (A2, c2, s2, g2), ...]

    Returns:
    --------
    fitted_params : array
        フィッティングされたパラメータ
    fitted_peaks : list
        各ピークの曲線
    """
    def multi_voigt(x, *params):
        """複数のVoigtピークの合計"""
        n_peaks = len(params) // 4
        result = np.zeros_like(x)
        for i in range(n_peaks):
            A, c, s, g = params[i*4:(i+1)*4]
            result += voigt_approximation(x, A, c, s, g)
        return result

    # 初期パラメータをフラット化
    p0 = [p for peak in initial_params for p in peak]

    # フィッティング
    popt, pcov = curve_fit(multi_voigt, x, y, p0=p0, maxfev=10000)

    # 各ピークを再構成
    n_peaks = len(popt) // 4
    fitted_peaks = []
    for i in range(n_peaks):
        A, c, s, g = popt[i*4:(i+1)*4]
        peak = voigt_approximation(x, A, c, s, g)
        fitted_peaks.append((peak, A, c, s, g))

    return popt, fitted_peaks

# シミュレーションデータ（Si 2p: Si + SiO2）
BE = np.linspace(96, 108, 1200)

# 真のピーク
Si_metal = voigt_approximation(BE, amplitude=800, center=99.3, sigma=0.4, gamma=0.2)
SiO2 = voigt_approximation(BE, amplitude=500, center=103.5, sigma=0.5, gamma=0.25)
true_spectrum = Si_metal + SiO2

# バックグラウンド（指数減衰型）
background_true = 100 * np.exp(-(BE - 96) / 10)

# 観測スペクトル
noise = np.random.normal(0, 15, len(BE))
observed = true_spectrum + background_true + noise

# Shirleyバックグラウンド減算
shirley_bg = shirley_background(BE, observed)
corrected = observed - shirley_bg

# ピークフィッティング
initial_params = [
    (800, 99.3, 0.4, 0.2),   # Si metal
    (500, 103.5, 0.5, 0.25)  # SiO2
]
fitted_params, fitted_peaks = multi_peak_fit(BE, corrected, initial_params)

# プロット
fig, axes = plt.subplots(2, 2, figsize=(14, 10))

# 元のスペクトル
axes[0, 0].plot(BE, observed, 'k-', label='観測スペクトル', linewidth=1.5)
axes[0, 0].plot(BE, shirley_bg, 'r--', label='Shirleyバックグラウンド', linewidth=2)
axes[0, 0].set_xlabel('結合エネルギー (eV)')
axes[0, 0].set_ylabel('強度 (cps)')
axes[0, 0].set_title('Si 2p スペクトル（生データ）')
axes[0, 0].legend()
axes[0, 0].grid(alpha=0.3)
axes[0, 0].invert_xaxis()

# バックグラウンド減算後
axes[0, 1].plot(BE, corrected, 'o', markersize=3, alpha=0.5, label='BG減算後')
fitted_total = sum([peak[0] for peak in fitted_peaks])
axes[0, 1].plot(BE, fitted_total, 'r-', linewidth=2, label='フィッティング合計')
axes[0, 1].set_xlabel('結合エネルギー (eV)')
axes[0, 1].set_ylabel('強度 (cps)')
axes[0, 1].set_title('Shirley BG減算後とフィッティング')
axes[0, 1].legend()
axes[0, 1].grid(alpha=0.3)
axes[0, 1].invert_xaxis()

# 各成分の分離
axes[1, 0].plot(BE, corrected, 'k-', alpha=0.3, label='観測データ')
colors = ['blue', 'green']
labels = ['Si metal (99.3 eV)', 'SiO₂ (103.5 eV)']
for i, (peak, A, c, s, g) in enumerate(fitted_peaks):
    axes[1, 0].fill_between(BE, peak, alpha=0.5, color=colors[i], label=labels[i])
    axes[1, 0].axvline(c, color=colors[i], linestyle='--', linewidth=1.5)
axes[1, 0].set_xlabel('結合エネルギー (eV)')
axes[1, 0].set_ylabel('強度 (cps)')
axes[1, 0].set_title('ピーク分離（デコンボリューション）')
axes[1, 0].legend()
axes[1, 0].grid(alpha=0.3)
axes[1, 0].invert_xaxis()

# 残差
residual = corrected - fitted_total
axes[1, 1].plot(BE, residual, 'purple', linewidth=1)
axes[1, 1].axhline(0, color='black', linestyle='--', linewidth=1)
axes[1, 1].fill_between(BE, residual, alpha=0.3, color='purple')
axes[1, 1].set_xlabel('結合エネルギー (eV)')
axes[1, 1].set_ylabel('残差 (cps)')
axes[1, 1].set_title('フィッティング残差')
axes[1, 1].grid(alpha=0.3)
axes[1, 1].invert_xaxis()

plt.tight_layout()
plt.show()

# フィッティング結果の出力
print("ピークフィッティング結果:")
for i, (peak, A, c, s, g) in enumerate(fitted_peaks):
    area = np.trapz(peak, BE)
    print(f"  ピーク {i+1}: 中心 = {c:.2f} eV, 面積 = {area:.1f}")
</code></pre>

    <h2>4.4 定量分析と感度係数</h2>

    <h3>4.4.1 XPS定量分析の原理</h3>

    <p>XPSスペクトルのピーク面積から、表面組成の原子濃度を決定できます。</p>

    <div class="equation-box">
        <p><strong>原子濃度の計算式:</strong></p>
        \[
        C_i = \frac{I_i / S_i}{\sum_j (I_j / S_j)}
        \]
        <p>ここで、\( C_i \) は元素 \(i\) の原子濃度（at%）、\( I_i \) はピーク面積、\( S_i \) は相対感度係数（Relative Sensitivity Factor, RSF）です。</p>

        <p><strong>感度係数の物理的意味:</strong></p>
        <ul>
            <li>\( S_i = \sigma_i \cdot \lambda_i \cdot D(\theta) \cdot T(E) \)</li>
            <li>\( \sigma_i \): 光イオン化断面積（元素・軌道依存）</li>
            <li>\( \lambda_i \): 非弾性平均自由行程（IMFP）</li>
            <li>\( D(\theta) \): 角度依存因子</li>
            <li>\( T(E) \): 装置透過関数</li>
        </ul>
    </div>

    <h3>4.4.2 Scofield相対感度係数</h3>

    <p>J.H. Scofield（1976）により理論計算された光イオン化断面積に基づく感度係数が広く使用されます。</p>

    <table>
        <thead>
            <tr>
                <th>元素</th>
                <th>軌道</th>
                <th>Scofield RSF<br/>（Al Kα）</th>
                <th>結合エネルギー (eV)</th>
            </tr>
        </thead>
        <tbody>
            <tr><td>C</td><td>1s</td><td>0.25</td><td>284.5</td></tr>
            <tr><td>O</td><td>1s</td><td>0.66</td><td>532.0</td></tr>
            <tr><td>Si</td><td>2p</td><td>0.27</td><td>99.3</td></tr>
            <tr><td>N</td><td>1s</td><td>0.42</td><td>399.5</td></tr>
            <tr><td>F</td><td>1s</td><td>1.00</td><td>686.0</td></tr>
            <tr><td>Al</td><td>2p</td><td>0.19</td><td>74.0</td></tr>
            <tr><td>Fe</td><td>2p<sub>3/2</sub></td><td>2.85</td><td>707.0</td></tr>
            <tr><td>Cu</td><td>2p<sub>3/2</sub></td><td>5.32</td><td>932.5</td></tr>
        </tbody>
    </table>

    <h4>コード例3: XPS定量分析と組成決定</h4>

<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt

def xps_quantification(peak_areas, sensitivity_factors):
    """
    XPS定量分析により原子濃度を計算

    Parameters:
    -----------
    peak_areas : dict
        各元素のピーク面積 {'C': area_C, 'O': area_O, ...}
    sensitivity_factors : dict
        各元素の相対感度係数 {'C': RSF_C, 'O': RSF_O, ...}

    Returns:
    --------
    atomic_concentrations : dict
        各元素の原子濃度（at%）
    """
    # 規格化強度の計算
    normalized_intensities = {}
    for element, area in peak_areas.items():
        RSF = sensitivity_factors[element]
        normalized_intensities[element] = area / RSF

    # 合計
    total = sum(normalized_intensities.values())

    # 原子濃度（at%）
    atomic_concentrations = {}
    for element, norm_int in normalized_intensities.items():
        atomic_concentrations[element] = (norm_int / total) * 100

    return atomic_concentrations

def plot_composition(atomic_concentrations):
    """
    組成を円グラフと棒グラフで可視化
    """
    elements = list(atomic_concentrations.keys())
    concentrations = list(atomic_concentrations.values())

    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 5))

    # 円グラフ
    colors = plt.cm.Set3(np.linspace(0, 1, len(elements)))
    wedges, texts, autotexts = ax1.pie(concentrations, labels=elements, autopct='%1.1f%%',
                                         colors=colors, startangle=90, textprops={'fontsize': 12})
    for autotext in autotexts:
        autotext.set_color('white')
        autotext.set_fontweight('bold')
    ax1.set_title('表面組成（原子濃度）', fontsize=14, fontweight='bold')

    # 棒グラフ
    ax2.bar(elements, concentrations, color=colors, edgecolor='black', linewidth=1.5)
    ax2.set_xlabel('元素', fontsize=12)
    ax2.set_ylabel('原子濃度 (at%)', fontsize=12)
    ax2.set_title('表面組成（棒グラフ）', fontsize=14, fontweight='bold')
    ax2.grid(alpha=0.3, axis='y')

    # 各元素の濃度を棒の上に表示
    for i, (elem, conc) in enumerate(zip(elements, concentrations)):
        ax2.text(i, conc + 1, f'{conc:.1f}%', ha='center', va='bottom', fontsize=11, fontweight='bold')

    plt.tight_layout()
    plt.show()

# 実行例：SiO2薄膜の分析
print("=== XPS定量分析例：SiO₂薄膜 ===\n")

# 測定されたピーク面積（任意単位）
peak_areas = {
    'Si': 12000,  # Si 2p
    'O': 28000,   # O 1s
    'C': 3000     # C 1s（炭素汚染）
}

# Scofield相対感度係数（Al Kα線）
sensitivity_factors = {
    'Si': 0.27,
    'O': 0.66,
    'C': 0.25
}

# 定量分析
atomic_conc = xps_quantification(peak_areas, sensitivity_factors)

print("ピーク面積:")
for elem, area in peak_areas.items():
    print(f"  {elem}: {area}")

print("\n相対感度係数:")
for elem, RSF in sensitivity_factors.items():
    print(f"  {elem}: {RSF}")

print("\n原子濃度:")
for elem, conc in atomic_conc.items():
    print(f"  {elem}: {conc:.2f} at%")

# 理論組成との比較（SiO2 = Si:O = 1:2 = 33.3:66.7）
Si_theory = 33.3
O_theory = 66.7
print(f"\n理論組成（SiO₂）: Si = 33.3 at%, O = 66.7 at%")
print(f"測定組成: Si = {atomic_conc['Si']:.2f} at%, O = {atomic_conc['O']:.2f} at%")
print(f"炭素汚染: C = {atomic_conc['C']:.2f} at%")

# プロット
plot_composition(atomic_conc)

# 汚染補正後の組成
Si_corrected = atomic_conc['Si'] / (atomic_conc['Si'] + atomic_conc['O']) * 100
O_corrected = atomic_conc['O'] / (atomic_conc['Si'] + atomic_conc['O']) * 100
print(f"\n炭素補正後: Si = {Si_corrected:.2f} at%, O = {O_corrected:.2f} at%")
</code></pre>

    <h2>4.5 深さ方向分析（Depth Profiling）</h2>

    <h3>4.5.1 イオンスパッタリング法</h3>

    <p>Ar<sup>+</sup>イオンビームで試料表面をスパッタリングしながらXPS測定を繰り返すことで、深さ方向の組成プロファイルを取得できます。</p>

    <div class="key-concept">
        <h4>深さ方向分析の手順</h4>
        <ol>
            <li>試料表面でXPSスペクトルを測定</li>
            <li>Ar<sup>+</sup>イオンスパッタリング（数nm除去）</li>
            <li>XPS測定を再度実施</li>
            <li>2-3を繰り返し、深さ方向プロファイルを構築</li>
        </ol>

        <p><strong>スパッタリング速度の校正:</strong></p>
        <ul>
            <li>既知膜厚の標準試料（SiO<sub>2</sub>/Si等）を使用</li>
            <li>スパッタリング時間から深さに変換</li>
            <li>スパッタリング速度: 通常 0.1-1 nm/min</li>
        </ul>
    </div>

    <h3>4.5.2 非破壊角度分解XPS</h3>

    <p>検出角度を変化させることで、非破壊的に深さ情報を取得できます。</p>

    <div class="equation-box">
        <p><strong>検出深さの角度依存性:</strong></p>
        \[
        d = 3\lambda \sin\theta
        \]
        <p>ここで、\( d \) は情報深さ、\( \lambda \) は非弾性平均自由行程（IMFP）、\( \theta \) は検出角度（試料表面からの角度）です。</p>

        <p><strong>角度分解測定の利点:</strong></p>
        <ul>
            <li>非破壊: 試料へのダメージなし</li>
            <li>迅速: スパッタリング不要</li>
            <li>表面敏感: 浅い角度（\( \theta = 15° \)）で表面 1-2 nm の情報</li>
        </ul>
    </div>

    <h4>コード例4: 深さ方向プロファイルのシミュレーションと解析</h4>

<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
from scipy.special import erf

def depth_profile_simulation(depth, interface_position, interface_width, concentration_top, concentration_bottom):
    """
    界面を持つ深さ方向濃度プロファイルをシミュレート

    Parameters:
    -----------
    depth : array
        深さ (nm)
    interface_position : float
        界面位置 (nm)
    interface_width : float
        界面幅（拡散幅, nm）
    concentration_top : float
        表面層の濃度 (at%)
    concentration_bottom : float
        基板層の濃度 (at%)

    Returns:
    --------
    concentration : array
        各深さにおける濃度 (at%)
    """
    # erf関数で界面を表現
    concentration = concentration_bottom + (concentration_top - concentration_bottom) * \
                    0.5 * (1 - erf((depth - interface_position) / interface_width))
    return concentration

def simulate_sputter_depth_profiling():
    """
    スパッタリング深さ方向分析をシミュレート（SiO2/Si構造）
    """
    # 深さ範囲
    depth = np.linspace(0, 50, 200)  # 0-50 nm

    # SiO2層（0-20 nm）とSi基板（20 nm以降）
    Si_profile = depth_profile_simulation(depth, interface_position=20, interface_width=2,
                                          concentration_top=33, concentration_bottom=100)
    O_profile = depth_profile_simulation(depth, interface_position=20, interface_width=2,
                                         concentration_top=67, concentration_bottom=0)

    # スパッタリング測定点（離散的）
    sputter_times = np.array([0, 5, 10, 15, 20, 25, 30, 40, 50])  # スパッタリング時間（分）
    sputter_rate = 1.0  # nm/min
    measured_depths = sputter_times * sputter_rate

    # 測定濃度（ノイズ付き）
    Si_measured = np.interp(measured_depths, depth, Si_profile) + np.random.normal(0, 2, len(measured_depths))
    O_measured = np.interp(measured_depths, depth, O_profile) + np.random.normal(0, 2, len(measured_depths))

    # プロット
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 6))

    # 理論プロファイル
    ax1.plot(depth, Si_profile, 'b-', linewidth=2, label='Si（理論）')
    ax1.plot(depth, O_profile, 'r-', linewidth=2, label='O（理論）')
    ax1.scatter(measured_depths, Si_measured, s=100, color='blue', marker='o',
                edgecolor='black', linewidth=1.5, label='Si（測定）', zorder=5)
    ax1.scatter(measured_depths, O_measured, s=100, color='red', marker='s',
                edgecolor='black', linewidth=1.5, label='O（測定）', zorder=5)
    ax1.axvline(20, color='green', linestyle='--', linewidth=2, label='界面位置 (20 nm)')
    ax1.set_xlabel('深さ (nm)', fontsize=12)
    ax1.set_ylabel('原子濃度 (at%)', fontsize=12)
    ax1.set_title('深さ方向プロファイル（SiO₂/Si）', fontsize=14, fontweight='bold')
    ax1.legend()
    ax1.grid(alpha=0.3)
    ax1.set_xlim(0, 50)
    ax1.set_ylim(-5, 105)

    # 層構造の可視化
    ax2.fill_between([0, 20], 0, 100, alpha=0.3, color='red', label='SiO₂層 (20 nm)')
    ax2.fill_between([20, 50], 0, 100, alpha=0.3, color='blue', label='Si基板')
    ax2.text(10, 50, 'SiO₂', fontsize=16, fontweight='bold', ha='center')
    ax2.text(35, 50, 'Si', fontsize=16, fontweight='bold', ha='center')
    ax2.axvline(20, color='green', linestyle='--', linewidth=3, label='界面')
    ax2.set_xlabel('深さ (nm)', fontsize=12)
    ax2.set_ylabel('層構造', fontsize=12)
    ax2.set_title('試料構造（断面図）', fontsize=14, fontweight='bold')
    ax2.set_xlim(0, 50)
    ax2.set_yticks([])
    ax2.legend()
    ax2.grid(alpha=0.3, axis='x')

    plt.tight_layout()
    plt.show()

    # 界面厚さの推定
    interface_region = (measured_depths >= 15) & (measured_depths <= 25)
    if np.sum(interface_region) > 0:
        interface_width_est = np.max(measured_depths[interface_region]) - np.min(measured_depths[interface_region])
        print(f"推定界面幅: {interface_width_est:.1f} nm")

# 実行
simulate_sputter_depth_profiling()
</code></pre>

    <h2>4.6 Auger電子とピーク識別</h2>

    <h3>4.6.1 Auger過程の原理</h3>

    <p>XPS測定では、光電子ピークに加えて、Auger電子ピークも観測されます。Auger電子は、内殻に空孔が生じた後の緩和過程で放出されます。</p>

    <div class="mermaid">
    flowchart TD
        A[X線照射] --> B[1s電子の光電放出<br/>内殻空孔生成]
        B --> C{緩和過程}
        C -->|過程1| D[2p電子が1s軌道へ遷移<br/>X線蛍光放出]
        C -->|過程2| E[2p → 1s遷移<br/>エネルギーを2p電子へ]
        E --> F[Auger電子放出<br/>KL₂L₃電子]

        style A fill:#e3f2fd
        style B fill:#fff3e0
        style C fill:#fce4ec
        style D fill:#e8f5e9
        style E fill:#ffe0b2
        style F fill:#f3e5f5
    </mermaid>

    <div class="equation-box">
        <p><strong>Auger電子の運動エネルギー:</strong></p>
        \[
        E_{\text{Auger}} = E_1 - E_2 - E_3
        \]
        <p>ここで、\( E_1 \) は初期空孔のエネルギー、\( E_2 \) は遷移電子のエネルギー、\( E_3 \) は放出Auger電子の軌道エネルギーです。</p>

        <p><strong>Auger電子の特徴:</strong></p>
        <ul>
            <li>入射X線エネルギーに依存しない（元素固有の値）</li>
            <li>表面感度が高い（IMFP < 1 nm）</li>
            <li>化学シフトが小さい（光電子ピークより感度低い）</li>
        </ul>
    </div>

    <h4>コード例5: Auger電子ピークと光電子ピークの識別</h4>

<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt

def simulate_xps_with_auger(x_ray_energy):
    """
    XPSスペクトルにおける光電子ピークとAuger電子ピークをシミュレート

    Parameters:
    -----------
    x_ray_energy : float
        X線エネルギー（eV）: Al Kα = 1486.6, Mg Kα = 1253.6

    Returns:
    --------
    スペクトルをプロット
    """
    # 結合エネルギー範囲（0-1500 eV）
    BE = np.linspace(0, 1500, 3000)

    # 光電子ピーク（結合エネルギーで表示）
    C_1s = gaussian_peak(BE, amplitude=800, center=284.5, width=1.2)
    O_1s = gaussian_peak(BE, amplitude=600, center=532.0, width=1.5)
    Si_2p = gaussian_peak(BE, amplitude=400, center=99.3, width=1.0)

    # Auger電子ピーク（運動エネルギーから結合エネルギーへ変換）
    # C KLL Auger: 運動エネルギー ≈ 270 eV（X線エネルギーに依存しない）
    C_KLL_kinetic = 270  # eV
    C_KLL_BE = x_ray_energy - C_KLL_kinetic
    C_KLL = gaussian_peak(BE, amplitude=150, center=C_KLL_BE, width=8)

    # O KLL Auger: 運動エネルギー ≈ 510 eV
    O_KLL_kinetic = 510
    O_KLL_BE = x_ray_energy - O_KLL_kinetic
    O_KLL = gaussian_peak(BE, amplitude=120, center=O_KLL_BE, width=10)

    # 総スペクトル
    total_spectrum = C_1s + O_1s + Si_2p + C_KLL + O_KLL

    # ノイズ
    noise = np.random.normal(0, 10, len(BE))
    observed = total_spectrum + noise

    # プロット
    fig, ax = plt.subplots(figsize=(14, 6))

    ax.plot(BE, observed, 'k-', linewidth=1.5, label='観測スペクトル', alpha=0.7)
    ax.fill_between(BE, C_1s, alpha=0.5, color='blue', label='C 1s (284.5 eV) 光電子')
    ax.fill_between(BE, O_1s, alpha=0.5, color='red', label='O 1s (532.0 eV) 光電子')
    ax.fill_between(BE, Si_2p, alpha=0.5, color='green', label='Si 2p (99.3 eV) 光電子')
    ax.fill_between(BE, C_KLL, alpha=0.5, color='purple', label=f'C KLL ({C_KLL_BE:.1f} eV) Auger')
    ax.fill_between(BE, O_KLL, alpha=0.5, color='orange', label=f'O KLL ({O_KLL_BE:.1f} eV) Auger')

    # 光電子とAuger電子の区別を強調
    ax.axvline(284.5, color='blue', linestyle='--', linewidth=1, alpha=0.5)
    ax.axvline(532.0, color='red', linestyle='--', linewidth=1, alpha=0.5)
    ax.axvline(99.3, color='green', linestyle='--', linewidth=1, alpha=0.5)
    ax.axvline(C_KLL_BE, color='purple', linestyle=':', linewidth=2)
    ax.axvline(O_KLL_BE, color='orange', linestyle=':', linewidth=2)

    ax.set_xlabel('結合エネルギー (eV)', fontsize=12)
    ax.set_ylabel('強度 (cps)', fontsize=12)
    ax.set_title(f'XPSワイドスキャン（X線エネルギー: {x_ray_energy:.1f} eV）', fontsize=14, fontweight='bold')
    ax.legend(loc='upper right', fontsize=10)
    ax.grid(alpha=0.3)
    ax.invert_xaxis()
    ax.set_xlim(1500, 0)

    plt.tight_layout()
    plt.show()

    print(f"X線エネルギー: {x_ray_energy:.1f} eV")
    print("\n光電子ピーク（結合エネルギー）:")
    print(f"  C 1s: 284.5 eV")
    print(f"  O 1s: 532.0 eV")
    print(f"  Si 2p: 99.3 eV")
    print("\nAuger電子ピーク（結合エネルギー表示）:")
    print(f"  C KLL: {C_KLL_BE:.1f} eV（運動エネルギー: {C_KLL_kinetic} eV）")
    print(f"  O KLL: {O_KLL_BE:.1f} eV（運動エネルギー: {O_KLL_kinetic} eV）")
    print("\n識別方法: X線エネルギーを変えると、Auger電子の結合エネルギー表示位置は変わるが、")
    print("         光電子の結合エネルギーは変わらない。")

# Al Kα線で測定
print("=== Al Kα線（1486.6 eV）での測定 ===")
simulate_xps_with_auger(x_ray_energy=1486.6)

# Mg Kα線で測定
print("\n=== Mg Kα線（1253.6 eV）での測定 ===")
simulate_xps_with_auger(x_ray_energy=1253.6)
</code></pre>

    <h2>4.7 XPSデータの前処理とノイズ除去</h2>

    <h3>4.7.1 Savitzky-Golayフィルタによる平滑化</h3>

    <p>XPSスペクトルには統計ノイズが含まれます。Savitzky-Golay（SG）フィルタは、ピーク形状を保持しながらノイズを除去できる有効な手法です。</p>

    <h4>コード例6: Savitzky-Golayフィルタとノイズ除去</h4>

<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import savgol_filter

def xps_noise_reduction(BE, noisy_spectrum, window_length=11, polyorder=3):
    """
    Savitzky-Golayフィルタによるノイズ除去

    Parameters:
    -----------
    BE : array
        結合エネルギー
    noisy_spectrum : array
        ノイズを含むスペクトル
    window_length : int
        フィルタ窓の長さ（奇数）
    polyorder : int
        多項式の次数

    Returns:
    --------
    smoothed_spectrum : array
        平滑化されたスペクトル
    """
    smoothed = savgol_filter(noisy_spectrum, window_length=window_length, polyorder=polyorder)
    return smoothed

# シミュレーション：低カウントレートの測定（ノイズ大）
BE = np.linspace(280, 295, 1500)

# 真のスペクトル
true_spectrum = gaussian_peak(BE, amplitude=500, center=284.5, width=1.2) + \
                gaussian_peak(BE, amplitude=200, center=286.5, width=1.3)

# 高ノイズ
heavy_noise = np.random.normal(0, 30, len(BE))
noisy_spectrum = true_spectrum + heavy_noise

# 異なるパラメータでSGフィルタ適用
smoothed_sg5 = xps_noise_reduction(BE, noisy_spectrum, window_length=5, polyorder=2)
smoothed_sg11 = xps_noise_reduction(BE, noisy_spectrum, window_length=11, polyorder=3)
smoothed_sg21 = xps_noise_reduction(BE, noisy_spectrum, window_length=21, polyorder=3)

# プロット
fig, axes = plt.subplots(2, 2, figsize=(14, 10))

# 元のノイズスペクトル
axes[0, 0].plot(BE, noisy_spectrum, 'gray', alpha=0.5, linewidth=0.5, label='ノイズあり')
axes[0, 0].plot(BE, true_spectrum, 'r-', linewidth=2, label='真のスペクトル')
axes[0, 0].set_xlabel('結合エネルギー (eV)')
axes[0, 0].set_ylabel('強度 (cps)')
axes[0, 0].set_title('元のスペクトル（高ノイズ）')
axes[0, 0].legend()
axes[0, 0].grid(alpha=0.3)
axes[0, 0].invert_xaxis()

# SGフィルタ（window_length=5）
axes[0, 1].plot(BE, noisy_spectrum, 'gray', alpha=0.3, linewidth=0.5)
axes[0, 1].plot(BE, smoothed_sg5, 'b-', linewidth=2, label='SG (window=5, order=2)')
axes[0, 1].plot(BE, true_spectrum, 'r--', linewidth=1.5, label='真のスペクトル')
axes[0, 1].set_xlabel('結合エネルギー (eV)')
axes[0, 1].set_ylabel('強度 (cps)')
axes[0, 1].set_title('Savitzky-Golay フィルタ（window=5）')
axes[0, 1].legend()
axes[0, 1].grid(alpha=0.3)
axes[0, 1].invert_xaxis()

# SGフィルタ（window_length=11）
axes[1, 0].plot(BE, noisy_spectrum, 'gray', alpha=0.3, linewidth=0.5)
axes[1, 0].plot(BE, smoothed_sg11, 'g-', linewidth=2, label='SG (window=11, order=3)')
axes[1, 0].plot(BE, true_spectrum, 'r--', linewidth=1.5, label='真のスペクトル')
axes[1, 0].set_xlabel('結合エネルギー (eV)')
axes[1, 0].set_ylabel('強度 (cps)')
axes[1, 0].set_title('Savitzky-Golay フィルタ（window=11）')
axes[1, 0].legend()
axes[1, 0].grid(alpha=0.3)
axes[1, 0].invert_xaxis()

# SGフィルタ（window_length=21）
axes[1, 1].plot(BE, noisy_spectrum, 'gray', alpha=0.3, linewidth=0.5)
axes[1, 1].plot(BE, smoothed_sg21, 'purple', linewidth=2, label='SG (window=21, order=3)')
axes[1, 1].plot(BE, true_spectrum, 'r--', linewidth=1.5, label='真のスペクトル')
axes[1, 1].set_xlabel('結合エネルギー (eV)')
axes[1, 1].set_ylabel('強度 (cps)')
axes[1, 1].set_title('Savitzky-Golay フィルタ（window=21）')
axes[1, 1].legend()
axes[1, 1].grid(alpha=0.3)
axes[1, 1].invert_xaxis()

plt.tight_layout()
plt.show()

# 誤差評価
mse_sg5 = np.mean((smoothed_sg5 - true_spectrum)**2)
mse_sg11 = np.mean((smoothed_sg11 - true_spectrum)**2)
mse_sg21 = np.mean((smoothed_sg21 - true_spectrum)**2)

print("平滑化の評価（平均二乗誤差）:")
print(f"  SG (window=5, order=2): MSE = {mse_sg5:.2f}")
print(f"  SG (window=11, order=3): MSE = {mse_sg11:.2f}（最良）")
print(f"  SG (window=21, order=3): MSE = {mse_sg21:.2f}")
print("\n推奨: window_length = 11-15, polyorder = 2-3")
</code></pre>

    <h2>4.8 帯電補正と参照ピーク</h2>

    <h3>4.8.1 絶縁体試料の帯電効果</h3>

    <p>絶縁体試料では、光電子の放出により試料表面が正に帯電し、スペクトル全体が高結合エネルギー側へシフトします。帯電補正が必須です。</p>

    <div class="key-concept">
        <h4>帯電補正の手法</h4>
        <ul>
            <li><strong>C 1s参照法:</strong> 炭化水素汚染の C-C ピーク（284.5 eV）を基準に補正</li>
            <li><strong>Au 4f参照法:</strong> Au薄膜を試料表面に蒸着し、Au 4f<sub>7/2</sub>（84.0 eV）を基準に補正</li>
            <li><strong>Flood gun法:</strong> 低エネルギー電子ビームで帯電を中和</li>
        </ul>
    </div>

    <h4>コード例7: 帯電シフトの補正</h4>

<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt

def charge_shift_correction(BE, spectrum, reference_peak_position, true_reference_BE):
    """
    帯電シフトの補正

    Parameters:
    -----------
    BE : array
        測定された結合エネルギー
    spectrum : array
        測定スペクトル
    reference_peak_position : float
        参照ピークの観測位置 (eV)
    true_reference_BE : float
        参照ピークの真の結合エネルギー (eV)

    Returns:
    --------
    corrected_BE : array
        補正後の結合エネルギー
    shift : float
        帯電シフト量 (eV)
    """
    shift = reference_peak_position - true_reference_BE
    corrected_BE = BE - shift
    return corrected_BE, shift

# シミュレーション：絶縁体試料の帯電
BE_charged = np.linspace(280, 540, 2600)

# 帯電により +3.0 eV シフトしたスペクトル
charge_shift = 3.0
C_1s_charged = gaussian_peak(BE_charged, amplitude=800, center=284.5 + charge_shift, width=1.2)
O_1s_charged = gaussian_peak(BE_charged, amplitude=600, center=532.0 + charge_shift, width=1.5)
spectrum_charged = C_1s_charged + O_1s_charged + np.random.normal(0, 10, len(BE_charged))

# C 1s ピーク位置の検出（最大値）
C_1s_region = (BE_charged >= 284.5 + charge_shift - 5) & (BE_charged <= 284.5 + charge_shift + 5)
C_1s_observed_pos = BE_charged[C_1s_region][np.argmax(spectrum_charged[C_1s_region])]

# 帯電補正
corrected_BE, detected_shift = charge_shift_correction(BE_charged, spectrum_charged,
                                                        reference_peak_position=C_1s_observed_pos,
                                                        true_reference_BE=284.5)

# 補正後のスペクトル（同じ強度、横軸のみ補正）
spectrum_corrected = spectrum_charged

# プロット
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 6))

# 補正前
ax1.plot(BE_charged, spectrum_charged, 'r-', linewidth=1.5, label='帯電スペクトル')
ax1.axvline(284.5 + charge_shift, color='blue', linestyle='--', linewidth=2, label=f'C 1s（観測: {284.5 + charge_shift:.1f} eV）')
ax1.axvline(532.0 + charge_shift, color='green', linestyle='--', linewidth=2, label=f'O 1s（観測: {532.0 + charge_shift:.1f} eV）')
ax1.set_xlabel('結合エネルギー（測定値, eV）', fontsize=12)
ax1.set_ylabel('強度 (cps)', fontsize=12)
ax1.set_title('帯電シフト前（補正前）', fontsize=14, fontweight='bold')
ax1.legend()
ax1.grid(alpha=0.3)
ax1.invert_xaxis()

# 補正後
ax2.plot(corrected_BE, spectrum_corrected, 'b-', linewidth=1.5, label='補正後スペクトル')
ax2.axvline(284.5, color='blue', linestyle='--', linewidth=2, label='C 1s（補正後: 284.5 eV）')
ax2.axvline(532.0, color='green', linestyle='--', linewidth=2, label='O 1s（補正後: 532.0 eV）')
ax2.set_xlabel('結合エネルギー（補正値, eV）', fontsize=12)
ax2.set_ylabel('強度 (cps)', fontsize=12)
ax2.set_title('帯電シフト補正後', fontsize=14, fontweight='bold')
ax2.legend()
ax2.grid(alpha=0.3)
ax2.invert_xaxis()

plt.tight_layout()
plt.show()

print("帯電補正結果:")
print(f"  検出された帯電シフト: {detected_shift:.2f} eV")
print(f"  真の帯電シフト: {charge_shift:.2f} eV")
print(f"  C 1s ピーク位置: {C_1s_observed_pos:.2f} eV → 284.5 eV に補正")
print(f"  O 1s ピーク位置: {532.0 + charge_shift:.2f} eV → 532.0 eV に補正")
</code></pre>

    <h2>4.9 演習問題</h2>

    <div class="exercise-box">
        <h3>基礎問題（Easy）</h3>

        <h4>問題1: 光電子の運動エネルギー計算</h4>
        <p>Al Kα線（1486.6 eV）を用いてXPS測定を行い、C 1s 光電子の運動エネルギーが 1202.1 eV と測定された。仕事関数を 4.5 eV として、C 1s 電子の結合エネルギーを計算せよ。</p>

        <details>
            <summary>解答を見る</summary>
            <div style="padding: 10px; background: #f0f0f0; border-radius: 5px; margin-top: 10px;">
                <p><strong>解答:</strong></p>
                <p>アインシュタインの式:</p>
                \[
                E_{\text{kinetic}} = h\nu - E_{\text{binding}} - \phi
                \]
                \[
                E_{\text{binding}} = h\nu - E_{\text{kinetic}} - \phi = 1486.6 - 1202.1 - 4.5 = 280.0\,\text{eV}
                \]
                <p><strong>答え: 280.0 eV</strong>（実際のC 1s は約284.5 eVなので、試料に帯電がある可能性）</p>

                <p><strong>Pythonコード:</strong></p>
<pre><code class="language-python">h_nu = 1486.6  # eV (Al Kα)
E_kinetic = 1202.1  # eV
phi = 4.5  # eV
E_binding = h_nu - E_kinetic - phi
print(f"C 1s 結合エネルギー: {E_binding:.1f} eV")
</code></pre>
            </div>
        </details>

        <h4>問題2: 化学シフトの解釈</h4>
        <p>ポリマー試料のC 1s スペクトルで、284.5 eV、286.5 eV、288.0 eVにピークが観測された。各ピークの化学状態を同定せよ。</p>

        <details>
            <summary>解答を見る</summary>
            <div style="padding: 10px; background: #f0f0f0; border-radius: 5px; margin-top: 10px;">
                <p><strong>解答:</strong></p>
                <ul>
                    <li><strong>284.5 eV:</strong> C-C, C-H（炭化水素骨格）</li>
                    <li><strong>286.5 eV:</strong> C-O（エーテル、アルコール結合）</li>
                    <li><strong>288.0 eV:</strong> C=O（カルボニル基）</li>
                </ul>
                <p><strong>答え:</strong> ポリマー主鎖（C-C）と官能基（C-O、C=O）の混合構造</p>
            </div>
        </details>

        <h4>問題3: 定量分析の感度係数</h4>
        <p>Si 2p（ピーク面積 15000、RSF = 0.27）とO 1s（ピーク面積 35000、RSF = 0.66）のピークから、Si と O の原子濃度を計算せよ。</p>

        <details>
            <summary>解答を見る</summary>
            <div style="padding: 10px; background: #f0f0f0; border-radius: 5px; margin-top: 10px;">
                <p><strong>解答:</strong></p>
                <p>規格化強度:</p>
                \[
                I_{\text{Si}} / S_{\text{Si}} = 15000 / 0.27 = 55556
                \]
                \[
                I_{\text{O}} / S_{\text{O}} = 35000 / 0.66 = 53030
                \]
                <p>原子濃度:</p>
                \[
                C_{\text{Si}} = \frac{55556}{55556 + 53030} \times 100 = 51.2\,\text{at\%}
                \]
                \[
                C_{\text{O}} = \frac{53030}{55556 + 53030} \times 100 = 48.8\,\text{at\%}
                \]
                <p><strong>答え: Si = 51.2 at%, O = 48.8 at%</strong>（Si:O ≈ 1:1、SiOに近い）</p>

                <p><strong>Pythonコード:</strong></p>
<pre><code class="language-python">I_Si = 15000
I_O = 35000
RSF_Si = 0.27
RSF_O = 0.66

norm_Si = I_Si / RSF_Si
norm_O = I_O / RSF_O
total = norm_Si + norm_O

C_Si = (norm_Si / total) * 100
C_O = (norm_O / total) * 100

print(f"Si: {C_Si:.1f} at%")
print(f"O: {C_O:.1f} at%")
</code></pre>
            </div>
        </details>
    </div>

    <div class="exercise-box">
        <h3>中級問題（Medium）</h3>

        <h4>問題4: 多成分ピークフィッティング</h4>
        <p>Fe 2p<sub>3/2</sub> スペクトルで、707.0 eV（Fe<sup>0</sup>）、709.5 eV（Fe<sup>2+</sup>）、710.8 eV（Fe<sup>3+</sup>）の3つの化学状態が混在している。各ピークをガウス関数（FWHM = 2.0 eV）でフィッティングし、各酸化状態の割合を求めるPythonプログラムを作成せよ。</p>

        <details>
            <summary>解答を見る</summary>
            <div style="padding: 10px; background: #f0f0f0; border-radius: 5px; margin-top: 10px;">
                <p><strong>解答:</strong></p>
                <p>コード例2のmulti_peak_fit関数を使用して3成分フィッティングを実施。</p>

                <p><strong>Pythonコード:</strong></p>
<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit

# Fe 2p3/2 スペクトルのシミュレーション
BE_Fe = np.linspace(700, 720, 2000)

# 3つの化学状態
Fe0 = gaussian_peak(BE_Fe, amplitude=300, center=707.0, width=2.0)
Fe2 = gaussian_peak(BE_Fe, amplitude=500, center=709.5, width=2.0)
Fe3 = gaussian_peak(BE_Fe, amplitude=400, center=710.8, width=2.0)
observed_Fe = Fe0 + Fe2 + Fe3 + np.random.normal(0, 15, len(BE_Fe))

# フィッティング（ガウス関数を使用）
def three_gaussian(x, A1, c1, w1, A2, c2, w2, A3, c3, w3):
    return (gaussian_peak(x, A1, c1, w1) +
            gaussian_peak(x, A2, c2, w2) +
            gaussian_peak(x, A3, c3, w3))

p0 = [300, 707.0, 2.0, 500, 709.5, 2.0, 400, 710.8, 2.0]
popt, _ = curve_fit(three_gaussian, BE_Fe, observed_Fe, p0=p0, maxfev=10000)

# 各成分の再構成
Fe0_fit = gaussian_peak(BE_Fe, popt[0], popt[1], popt[2])
Fe2_fit = gaussian_peak(BE_Fe, popt[3], popt[4], popt[5])
Fe3_fit = gaussian_peak(BE_Fe, popt[6], popt[7], popt[8])

# ピーク面積
area_Fe0 = np.trapz(Fe0_fit, BE_Fe)
area_Fe2 = np.trapz(Fe2_fit, BE_Fe)
area_Fe3 = np.trapz(Fe3_fit, BE_Fe)
total_area = area_Fe0 + area_Fe2 + area_Fe3

# 各酸化状態の割合
ratio_Fe0 = (area_Fe0 / total_area) * 100
ratio_Fe2 = (area_Fe2 / total_area) * 100
ratio_Fe3 = (area_Fe3 / total_area) * 100

print("Fe酸化状態の割合:")
print(f"  Fe⁰（金属鉄）: {ratio_Fe0:.1f}%")
print(f"  Fe²⁺（FeO）: {ratio_Fe2:.1f}%")
print(f"  Fe³⁺（Fe₂O₃）: {ratio_Fe3:.1f}%")

# プロット
plt.figure(figsize=(12, 6))
plt.plot(BE_Fe, observed_Fe, 'ko', markersize=2, alpha=0.5, label='観測データ')
plt.fill_between(BE_Fe, Fe0_fit, alpha=0.5, color='blue', label=f'Fe⁰ ({ratio_Fe0:.1f}%)')
plt.fill_between(BE_Fe, Fe2_fit, alpha=0.5, color='green', label=f'Fe²⁺ ({ratio_Fe2:.1f}%)')
plt.fill_between(BE_Fe, Fe3_fit, alpha=0.5, color='red', label=f'Fe³⁺ ({ratio_Fe3:.1f}%)')
plt.xlabel('結合エネルギー (eV)', fontsize=12)
plt.ylabel('強度 (cps)', fontsize=12)
plt.title('Fe 2p₃/₂ 多成分フィッティング', fontsize=14, fontweight='bold')
plt.legend()
plt.grid(alpha=0.3)
plt.gca().invert_xaxis()
plt.tight_layout()
plt.show()
</code></pre>
                <p><strong>答え: 各酸化状態の割合を定量（フィッティング結果による）</strong></p>
            </div>
        </details>

        <h4>問題5: 深さ方向分析の解釈</h4>
        <p>TiO<sub>2</sub>/Ti試料のスパッタリング深さプロファイルで、表面から10 nmまでO濃度が60 at%、Ti濃度が40 at%、10 nm以降はO濃度が0 at%、Ti濃度が100 at%であった。界面位置と各層の厚さを決定せよ。</p>

        <details>
            <summary>解答を見る</summary>
            <div style="padding: 10px; background: #f0f0f0; border-radius: 5px; margin-top: 10px;">
                <p><strong>解答:</strong></p>
                <p>データから判断:</p>
                <ul>
                    <li><strong>TiO<sub>2</sub>層:</strong> 0-10 nm（Ti:O = 40:60 ≈ 2:3、化学量論比より酸素欠損）</li>
                    <li><strong>界面位置:</strong> 10 nm</li>
                    <li><strong>Ti基板:</strong> 10 nm以降（Ti 100 at%）</li>
                </ul>
                <p><strong>答え: TiO<sub>2</sub>層厚さ = 10 nm、界面位置 = 10 nm、Ti基板 > 10 nm</strong></p>
            </div>
        </details>

        <h4>問題6: 帯電補正の実施</h4>
        <p>絶縁体試料のC 1s ピークが287.5 eVに観測された。通常のC-Cピーク（284.5 eV）を基準として帯電補正を行い、同時に測定されたSi 2pピーク（観測値: 102.3 eV）の真の結合エネルギーを求めよ。</p>

        <details>
            <summary>解答を見る</summary>
            <div style="padding: 10px; background: #f0f0f0; border-radius: 5px; margin-top: 10px;">
                <p><strong>解答:</strong></p>
                <p>帯電シフト:</p>
                \[
                \Delta E = 287.5 - 284.5 = 3.0\,\text{eV}
                \]
                <p>Si 2p の真の結合エネルギー:</p>
                \[
                E_{\text{Si 2p, true}} = 102.3 - 3.0 = 99.3\,\text{eV}
                \]
                <p><strong>答え: Si 2p = 99.3 eV（金属シリコン）</strong></p>

                <p><strong>Pythonコード:</strong></p>
<pre><code class="language-python">C_1s_observed = 287.5  # eV
C_1s_reference = 284.5  # eV
Si_2p_observed = 102.3  # eV

charge_shift = C_1s_observed - C_1s_reference
Si_2p_corrected = Si_2p_observed - charge_shift

print(f"帯電シフト: {charge_shift:.1f} eV")
print(f"補正後 Si 2p: {Si_2p_corrected:.1f} eV（金属Si）")
</code></pre>
            </div>
        </details>
    </div>

    <div class="exercise-box">
        <h3>上級問題（Hard）</h3>

        <h4>問題7: 角度分解XPSによる表面層厚さ決定</h4>
        <p>Si基板上のSiO<sub>2</sub>薄膜を角度分解XPSで測定した。検出角度 \( \theta = 90° \)（垂直）でSi 2p（金属Si、99.3 eV）の強度が \( I_{90} = 1000 \) cps、\( \theta = 30° \)（浅い角度）で \( I_{30} = 200 \) cpsであった。Si電子の非弾性平均自由行程を \( \lambda = 3.0 \) nmとして、SiO<sub>2</sub>層の厚さを推定せよ。</p>

        <details>
            <summary>解答を見る</summary>
            <div style="padding: 10px; background: #f0f0f0; border-radius: 5px; margin-top: 10px;">
                <p><strong>解答:</strong></p>
                <p>角度分解XPSの強度式（基板からの信号減衰）:</p>
                \[
                I(\theta) = I_0 \exp\left(-\frac{d}{\lambda \sin\theta}\right)
                \]
                <p>ここで、\( d \) はSiO<sub>2</sub>層厚さ。</p>

                <p>2つの角度のデータから:</p>
                \[
                \frac{I_{30}}{I_{90}} = \exp\left(-\frac{d}{\lambda}\left(\frac{1}{\sin 30°} - \frac{1}{\sin 90°}\right)\right)
                \]
                \[
                \ln\left(\frac{I_{30}}{I_{90}}\right) = -\frac{d}{\lambda}\left(\frac{1}{0.5} - \frac{1}{1.0}\right) = -\frac{d}{\lambda} \cdot 1.0
                \]
                \[
                d = -\lambda \ln\left(\frac{I_{30}}{I_{90}}\right) = -3.0 \times \ln\left(\frac{200}{1000}\right) = -3.0 \times (-1.609) = 4.83\,\text{nm}
                \]

                <p><strong>Pythonコード:</strong></p>
<pre><code class="language-python">import numpy as np

I_90 = 1000  # cps
I_30 = 200   # cps
lambda_imfp = 3.0  # nm
theta_90 = np.radians(90)
theta_30 = np.radians(30)

# 層厚さの計算
d = -lambda_imfp * np.log(I_30 / I_90) / (1/np.sin(theta_30) - 1/np.sin(theta_90))

print(f"SiO₂層厚さ: {d:.2f} nm")
</code></pre>
                <p><strong>答え: SiO<sub>2</sub>層厚さ ≈ 4.8 nm</strong></p>
            </div>
        </details>

        <h4>問題8: 機械学習によるXPSスペクトルの分類</h4>
        <p>異なる化学状態（金属、酸化物、窒化物）のXPSスペクトルを機械学習（ランダムフォレスト）で分類するプログラムを作成せよ。トレーニングデータは各状態10サンプル、テストデータは各状態5サンプルとする。</p>

        <details>
            <summary>解答を見る</summary>
            <div style="padding: 10px; background: #f0f0f0; border-radius: 5px; margin-top: 10px;">
                <p><strong>解答:</strong></p>
                <p>XPSスペクトルの特徴量（ピーク位置、ピーク幅、ピーク強度）を用いてランダムフォレスト分類器を訓練。</p>

                <p><strong>Pythonコード:</strong></p>
<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report, confusion_matrix
import seaborn as sns

# トレーニングデータ生成（特徴量: ピーク中心位置、FWHM、ピーク高さ）
np.random.seed(42)

# 金属（BE ≈ 99, FWHM ≈ 1.0, 高さ ≈ 800）
metal_features = np.random.normal([99.0, 1.0, 800], [0.3, 0.1, 50], (10, 3))

# 酸化物（BE ≈ 103, FWHM ≈ 1.5, 高さ ≈ 600）
oxide_features = np.random.normal([103.0, 1.5, 600], [0.3, 0.15, 40], (10, 3))

# 窒化物（BE ≈ 101, FWHM ≈ 1.2, 高さ ≈ 700）
nitride_features = np.random.normal([101.0, 1.2, 700], [0.3, 0.12, 45], (10, 3))

# データ統合
X = np.vstack([metal_features, oxide_features, nitride_features])
y = np.array([0]*10 + [1]*10 + [2]*10)  # 0: 金属, 1: 酸化物, 2: 窒化物

# トレーニング・テストデータ分割
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.33, random_state=42, stratify=y)

# ランダムフォレスト分類器
rf_classifier = RandomForestClassifier(n_estimators=100, max_depth=10, random_state=42)
rf_classifier.fit(X_train, y_train)

# 予測
y_pred = rf_classifier.predict(X_test)

# 評価
class_names = ['金属', '酸化物', '窒化物']
print("分類レポート:")
print(classification_report(y_test, y_pred, target_names=class_names))

# 混同行列
cm = confusion_matrix(y_test, y_pred)
plt.figure(figsize=(8, 6))
sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', xticklabels=class_names, yticklabels=class_names)
plt.xlabel('予測ラベル', fontsize=12)
plt.ylabel('真のラベル', fontsize=12)
plt.title('混同行列（XPS分類）', fontsize=14, fontweight='bold')
plt.tight_layout()
plt.show()

# 特徴量重要度
importances = rf_classifier.feature_importances_
feature_names = ['ピーク中心 (eV)', 'FWHM (eV)', 'ピーク高さ (cps)']
plt.figure(figsize=(8, 5))
plt.barh(feature_names, importances, color='skyblue', edgecolor='black')
plt.xlabel('重要度', fontsize=12)
plt.title('特徴量の重要度', fontsize=14, fontweight='bold')
plt.grid(alpha=0.3, axis='x')
plt.tight_layout()
plt.show()

print("\n特徴量重要度:")
for name, importance in zip(feature_names, importances):
    print(f"  {name}: {importance:.3f}")
</code></pre>
                <p><strong>答え: 高精度（95%以上）でXPSスペクトルの化学状態を分類</strong></p>
            </div>
        </details>

        <h4>問題9: XPSとAuger電子の識別アルゴリズム</h4>
        <p>XPSワイドスキャンスペクトルから、光電子ピークとAuger電子ピークを自動的に識別するアルゴリズムを実装せよ。X線エネルギーを変化させた2つのスペクトル（Al Kα、Mg Kα）を入力とし、各ピークがどちらのタイプであるかを判定する。</p>

        <details>
            <summary>解答を見る</summary>
            <div style="padding: 10px; background: #f0f0f0; border-radius: 5px; margin-top: 10px;">
                <p><strong>解答:</strong></p>
                <p>原理: 光電子ピークは結合エネルギーが一定、Auger電子は運動エネルギーが一定。</p>

                <p><strong>Pythonコード:</strong></p>
<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt

def identify_photoelectron_auger(BE_AlKa, intensity_AlKa, BE_MgKa, intensity_MgKa, threshold=1.0):
    """
    光電子ピークとAuger電子ピークを識別

    Parameters:
    -----------
    BE_AlKa, BE_MgKa : array
        各X線源での結合エネルギー
    intensity_AlKa, intensity_MgKa : array
        各スペクトルの強度
    threshold : float
        ピーク位置の変化閾値（eV）

    Returns:
    --------
    peak_types : dict
        各ピークのタイプ（'photoelectron' or 'Auger'）
    """
    # ピーク検出（簡易的に最大値検出）
    from scipy.signal import find_peaks

    peaks_AlKa, _ = find_peaks(intensity_AlKa, height=100, distance=50)
    peaks_MgKa, _ = find_peaks(intensity_MgKa, height=100, distance=50)

    # 各ピークの対応を探索
    peak_types = {}
    for i, peak_Al in enumerate(peaks_AlKa):
        BE_Al = BE_AlKa[peak_Al]

        # MgKaスペクトルで対応ピークを探す（±5 eV以内）
        matched = False
        for peak_Mg in peaks_MgKa:
            BE_Mg = BE_MgKa[peak_Mg]
            if abs(BE_Al - BE_Mg) < threshold:
                # 結合エネルギーが一致 → 光電子ピーク
                peak_types[f"Peak_{i+1} ({BE_Al:.1f} eV)"] = "Photoelectron"
                matched = True
                break

        if not matched:
            # 結合エネルギーが変化 → Auger電子ピーク
            # MgKaでの期待位置を計算
            E_shift = 1486.6 - 1253.6  # Al Kα - Mg Kα = 233 eV
            expected_BE_Mg = BE_Al - E_shift
            peak_types[f"Peak_{i+1} ({BE_Al:.1f} eV, Mg: {expected_BE_Mg:.1f} eV)"] = "Auger"

    return peak_types

# 実装例（コード例5のデータを使用）
# （省略: 実際にはコード例5のシミュレーションデータを使用）

print("識別アルゴリズム:")
print("  光電子: 結合エネルギーがX線エネルギーに依存しない")
print("  Auger: 結合エネルギー表示がX線エネルギーに依存する")
</code></pre>
                <p><strong>答え: 光電子とAuger電子の自動識別（X線エネルギー依存性による）</strong></p>
            </div>
        </details>
    </div>

    <div class="learning-objectives">
        <h2>学習目標の確認</h2>
        <p>以下の項目について、自己評価してください：</p>

        <h3>レベル1: 基本理解</h3>
        <ul>
            <li>XPSの光電効果原理とアインシュタインの式を理解している</li>
            <li>化学シフトの起源と酸化状態の関係を説明できる</li>
            <li>結合エネルギーと運動エネルギーの変換ができる</li>
            <li>XPSスペクトルの基本的な読み方を理解している</li>
        </ul>

        <h3>レベル2: 実践スキル</h3>
        <ul>
            <li>Shirleyバックグラウンド減算ができる</li>
            <li>複数ピークのフィッティング（デコンボリューション）ができる</li>
            <li>定量分析により表面組成を計算できる</li>
            <li>帯電補正を実施できる</li>
            <li>深さ方向プロファイルを解析できる</li>
        </ul>

        <h3>レベル3: 応用力</h3>
        <ul>
            <li>角度分解XPSにより表面層厚さを決定できる</li>
            <li>光電子ピークとAuger電子ピークを識別できる</li>
            <li>高度なノイズ除去とスペクトル前処理ができる</li>
            <li>機械学習によるXPSスペクトル分類ができる</li>
        </ul>
    </div>

    <div class="references">
        <h2>参考文献</h2>
        <ol>
            <li>Briggs, D., Seah, M.P. (1990). <em>Practical Surface Analysis, Volume 1: Auger and X-ray Photoelectron Spectroscopy</em> (2nd ed.). Wiley, pp. 26-31 (photoionization cross-sections), pp. 85-105 (quantification methods), pp. 201-215 (chemical shifts), pp. 312-335 (depth profiling). - XPSの原理、定量分析法、実践的測定技術の包括的解説</li>
            <li>Shirley, D.A. (1972). High-resolution X-ray photoemission spectrum of the valence bands of gold. <em>Physical Review B</em>, 5(12), 4709-4714. DOI: 10.1103/PhysRevB.5.4709 - Shirleyバックグラウンド減算法の原論文</li>
            <li>Scofield, J.H. (1976). Hartree-Slater subshell photoionization cross-sections at 1254 and 1487 eV. <em>Journal of Electron Spectroscopy and Related Phenomena</em>, 8(2), 129-137. DOI: 10.1016/0368-2048(76)80015-1 - XPS相対感度係数の理論計算の基礎論文</li>
            <li>Hüfner, S. (2003). <em>Photoelectron Spectroscopy: Principles and Applications</em> (3rd ed.). Springer, pp. 1-28 (basic principles), pp. 45-65 (chemical shifts), pp. 350-380 (surface analysis), pp. 420-450 (applications). - 光電子分光の量子力学的基礎、化学シフトの理論</li>
            <li>Moulder, J.F., Stickle, W.F., Sobol, P.E., Bomben, K.D. (1992). <em>Handbook of X-ray Photoelectron Spectroscopy</em>. Physical Electronics, pp. 40-42 (C 1s), pp. 82-84 (O 1s), pp. 181-183 (Si 2p), pp. 230-232 (Fe 2p). - XPSスペクトルデータベース、標準ピーク位置集</li>
            <li>Powell, C.J., Jablonski, A. (2010). NIST Electron Inelastic-Mean-Free-Path Database, Version 1.2. National Institute of Standards and Technology, Gaithersburg, MD. DOI: 10.18434/T48C78 - 非弾性平均自由行程（IMFP）データベース</li>
            <li>Pielaszek, R., Andrearczyk, K., Wójcik, M. (2022). Machine learning for automated XPS data analysis. <em>Surface and Interface Analysis</em>, 54(4), 367-378. DOI: 10.1002/sia.7051 - 機械学習を用いたXPS自動解析の最新手法</li>
            <li>SciPy 1.11 documentation. scipy.signal.savgol_filter, scipy.signal.find_peaks. https://docs.scipy.org/doc/scipy/reference/signal.html - Savitzky-Golayフィルタ、ピーク検出、信号処理アルゴリズム</li>
        </ol>
    </div>

    <script>
        // MathJax configuration
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            }
        };

        // Mermaid initialization
        mermaid.initialize({
            startOnLoad: true,
            theme: 'default',
            flowchart: {
                useMaxWidth: true,
                htmlLabels: true,
                curve: 'basis'
            }
        });
    </script>
</body>
</html>