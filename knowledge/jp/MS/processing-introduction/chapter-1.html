<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
<meta content="ç¬¬1ç« ï¼šãƒ—ãƒ­ã‚»ã‚¹åˆ¶å¾¡ã®åŸºç¤ - MS Terakoya. PIDåˆ¶å¾¡ï¼ˆæ¯”ä¾‹ãƒ»ç©åˆ†ãƒ»å¾®åˆ†ï¼‰ã®å‹•ä½œåŸç†ã¨ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒãƒ¥ãƒ¼ãƒ‹ãƒ³ã‚°æ‰‹æ³•ã‚’ç†è§£ã™ã‚‹" name="description"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç¬¬1ç« ï¼šãƒ—ãƒ­ã‚»ã‚¹åˆ¶å¾¡ã®åŸºç¤ - MS Terakoya</title>

    <style>
        :root {
            --color-primary: #2c3e50;
            --color-primary-dark: #1a252f;
            --color-accent: #f093fb;
            --color-accent-light: #f5576c;
            --color-text: #2d3748;
            --color-text-light: #4a5568;
            --color-bg: #ffffff;
            --color-bg-alt: #f7fafc;
            --color-border: #e2e8f0;
            --color-code-bg: #f8f9fa;
            --color-link: #f093fb;
            --color-link-hover: #d07be8;

            --spacing-xs: 0.5rem;
            --spacing-sm: 1rem;
            --spacing-md: 1.5rem;
            --spacing-lg: 2rem;
            --spacing-xl: 3rem;

            --font-body: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            --font-mono: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;

            --border-radius: 8px;
            --box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-body);
            line-height: 1.7;
            color: var(--color-text);
            background-color: var(--color-bg);
            font-size: 16px;
        }

        header {
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            color: white;
            padding: var(--spacing-xl) var(--spacing-md);
            margin-bottom: var(--spacing-xl);
            box-shadow: var(--box-shadow);
        }

        .header-content {
            max-width: 900px;
            margin: 0 auto;
        }

        h1 {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: var(--spacing-sm);
            line-height: 1.2;
        }

        .subtitle {
            font-size: 1.1rem;
            opacity: 0.95;
            font-weight: 400;
            margin-bottom: var(--spacing-md);
        }

        .meta {
            display: flex;
            flex-wrap: wrap;
            gap: var(--spacing-md);
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .meta-item {
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 0 var(--spacing-md) var(--spacing-xl);
        }

        h2 {
            font-size: 1.75rem;
            color: var(--color-primary);
            margin-top: var(--spacing-xl);
            margin-bottom: var(--spacing-md);
            padding-bottom: var(--spacing-xs);
            border-bottom: 3px solid var(--color-accent);
        }

        h3 {
            font-size: 1.4rem;
            color: var(--color-primary);
            margin-top: var(--spacing-lg);
            margin-bottom: var(--spacing-sm);
        }

        h4 {
            font-size: 1.1rem;
            color: var(--color-primary-dark);
            margin-top: var(--spacing-md);
            margin-bottom: var(--spacing-sm);
        }

        p {
            margin-bottom: var(--spacing-md);
            color: var(--color-text);
        }

        a {
            color: var(--color-link);
            text-decoration: none;
            transition: color 0.2s;
        }

        a:hover {
            color: var(--color-link-hover);
            text-decoration: underline;
        }

        ul, ol {
            margin-left: var(--spacing-lg);
            margin-bottom: var(--spacing-md);
        }

        li {
            margin-bottom: var(--spacing-xs);
            color: var(--color-text);
        }

        pre {
            background-color: var(--color-code-bg);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            overflow-x: auto;
            margin-bottom: var(--spacing-md);
            font-family: var(--font-mono);
            font-size: 0.9rem;
            line-height: 1.5;
        }

        code {
            font-family: var(--font-mono);
            font-size: 0.9em;
            background-color: var(--color-code-bg);
            padding: 0.2em 0.4em;
            border-radius: 3px;
        }

        pre code {
            background-color: transparent;
            padding: 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: var(--spacing-md);
            font-size: 0.95rem;
        }

        th, td {
            border: 1px solid var(--color-border);
            padding: var(--spacing-sm);
            text-align: left;
        }

        th {
            background-color: var(--color-bg-alt);
            font-weight: 600;
            color: var(--color-primary);
        }

        blockquote {
            border-left: 4px solid var(--color-accent);
            padding-left: var(--spacing-md);
            margin: var(--spacing-md) 0;
            color: var(--color-text-light);
            font-style: italic;
            background-color: var(--color-bg-alt);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        .mermaid {
            text-align: center;
            margin: var(--spacing-lg) 0;
            background-color: var(--color-bg-alt);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        .learning-objectives {
            background: linear-gradient(135deg, #fce7f3 0%, #fbcfe8 100%);
            padding: var(--spacing-lg);
            border-radius: var(--border-radius);
            border-left: 4px solid var(--color-accent);
            margin-bottom: var(--spacing-xl);
        }

        .learning-objectives h2 {
            margin-top: 0;
            border-bottom: none;
        }

        .exercise-box {
            background-color: #fff7ed;
            border-left: 4px solid #fb923c;
            padding: var(--spacing-md);
            margin-bottom: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        .exercise-box h4 {
            color: #c2410c;
            margin-top: 0;
        }

        .solution-box {
            background-color: #f0fdf4;
            border-left: 4px solid #22c55e;
            padding: var(--spacing-md);
            margin-top: var(--spacing-sm);
            border-radius: var(--border-radius);
        }

        .solution-box summary {
            cursor: pointer;
            font-weight: 600;
            color: #15803d;
            margin-bottom: var(--spacing-sm);
        }

        .breadcrumb {
            max-width: 900px;
            margin: 0 auto;
            padding: var(--spacing-sm) var(--spacing-md);
            font-size: 0.9rem;
            color: var(--color-text-light);
        }

        .breadcrumb a {
            color: var(--color-link);
            text-decoration: none;
        }

        .breadcrumb a:hover {
            text-decoration: underline;
        }

        .navigation {
            display: flex;
            justify-content: space-between;
            gap: var(--spacing-md);
            margin: var(--spacing-xl) 0;
            padding-top: var(--spacing-lg);
            border-top: 2px solid var(--color-border);
        }

        .nav-button {
            flex: 1;
            padding: var(--spacing-md);
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            color: white;
            border-radius: var(--border-radius);
            text-align: center;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: var(--box-shadow);
        }

        .nav-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            text-decoration: none;
        }

        footer {
            margin-top: var(--spacing-xl);
            padding: var(--spacing-lg) var(--spacing-md);
            background-color: var(--color-bg-alt);
            border-top: 1px solid var(--color-border);
            text-align: center;
            font-size: 0.9rem;
            color: var(--color-text-light);
        }

        .disclaimer {
            max-width: 900px;
            margin: 2rem auto;
            padding: 1.5rem;
            background: #f8f9fa;
            border-left: 4px solid #6c757d;
            border-radius: 4px;
        }

        .disclaimer h3 {
            color: #495057;
            margin-bottom: 1rem;
            font-size: 1.1rem;
        }

        .disclaimer ul {
            list-style: none;
            padding-left: 0;
        }

        .disclaimer li {
            padding: 0.5rem 0;
            padding-left: 1.5rem;
            position: relative;
            font-size: 0.9rem;
            color: #6c757d;
            line-height: 1.6;
        }

        .disclaimer li::before {
            content: "âš ï¸";
            position: absolute;
            left: 0;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.5rem;
            }

            h2 {
                font-size: 1.4rem;
            }

            h3 {
                font-size: 1.2rem;
            }

            .meta {
                font-size: 0.85rem;
            }

            .navigation {
                flex-direction: column;
            }

            table {
                font-size: 0.85rem;
            }

            th, td {
                padding: var(--spacing-xs);
            }
        }
    </style>

    <!-- Prism.js for syntax highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <script>
        mermaid.initialize({ startOnLoad: true, theme: 'default', securityLevel: 'strict' });
    </script>

    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true,
                processEnvironments: true
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
                ignoreHtmlClass: 'mermaid'
            }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" id="MathJax-script" async></script>

    <style>
        /* Locale Switcher Styles */
        .locale-switcher {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 6px;
            font-size: 0.9rem;
            margin-bottom: 1rem;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .current-locale {
            font-weight: 600;
            color: #7b2cbf;
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .locale-separator {
            color: #adb5bd;
            font-weight: 300;
        }

        .locale-link {
            color: #f093fb;
            text-decoration: none;
            font-weight: 500;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 0.25rem;
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
        }

        .locale-link:hover {
            background: rgba(240, 147, 251, 0.1);
            color: #d07be8;
            transform: translateY(-1px);
        }

        .locale-meta {
            color: #868e96;
            font-size: 0.85rem;
            font-style: italic;
            margin-left: auto;
        }

        @media (max-width: 768px) {
            .locale-switcher {
                font-size: 0.85rem;
                padding: 0.4rem 0.8rem;
            }
            .locale-meta {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div class="locale-switcher">
<span class="current-locale">ğŸŒ JP</span>
<span class="locale-separator">|</span>
<a href="../../../en/MS/processing-introduction/chapter-1.html" class="locale-link">ğŸ‡¬ğŸ‡§ EN</a>
<span class="locale-separator">|</span>
<span class="locale-meta">Last sync: 2025-11-16</span>
</div>
<header>
        <div class="header-content">
            <h1>ç¬¬1ç« ï¼šãƒ—ãƒ­ã‚»ã‚¹åˆ¶å¾¡ã®åŸºç¤</h1>
            <p class="subtitle">PID Control, Temperature Control, Vacuum Systems, Atmosphere Control</p>
            <div class="meta">
                <span class="meta-item">ğŸ“– èª­äº†æ™‚é–“: 35-45åˆ†</span>
                <span class="meta-item">ğŸ“Š é›£æ˜“åº¦: ä¸­ç´š</span>
                <span class="meta-item">ğŸ’» ã‚³ãƒ¼ãƒ‰ä¾‹: 7å€‹</span>
            </div>
        </div>
    </header>

    <div class="breadcrumb">
        <a href="../../index.html">AIå¯ºå­å±‹ãƒˆãƒƒãƒ—</a> &gt;
        <a href="../index.html">MS Dojo</a> &gt;
        <a href="index.html">ãƒ—ãƒ­ã‚»ã‚¹æŠ€è¡“å…¥é–€</a> &gt;
        ç¬¬1ç« 
    </div>

    <main class="container">
        <p class="chapter-description" style="margin: 1.5rem 0; padding: 1rem; background: linear-gradient(135deg, #fce7f3 0%, #fbcfe8 100%); border-left: 4px solid #f093fb; border-radius: 8px; font-size: 1.05rem; line-height: 1.8; color: #2d3748;">
            ãƒ—ãƒ­ã‚»ã‚¹åˆ¶å¾¡ã¯ã€ã™ã¹ã¦ã®ææ–™è£½é€ ãƒ—ãƒ­ã‚»ã‚¹ã®åŸºç›¤ã§ã™ã€‚æ¸©åº¦ã€åœ§åŠ›ã€é›°å›²æ°—ã¨ã„ã£ãŸåˆ¶å¾¡å¤‰æ•°ã‚’æ­£ç¢ºã«ç®¡ç†ã™ã‚‹ã“ã¨ã§ã€ç›®æ¨™ã¨ã™ã‚‹ææ–™ç‰¹æ€§ã‚’å®‰å®šçš„ã«é”æˆã§ãã¾ã™ã€‚ã“ã®ç« ã§ã¯ã€PIDåˆ¶å¾¡ã®åŸç†ã‹ã‚‰å®Ÿè£…ã€çœŸç©ºãƒ»ã‚¬ã‚¹ãƒ•ãƒ­ãƒ¼åˆ¶å¾¡ã€ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°ã¾ã§ã‚’ã€Pythonã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’é€šã˜ã¦å®Ÿè·µçš„ã«å­¦ã³ã¾ã™ã€‚
        </p>

        <div class="learning-objectives">
            <h2>å­¦ç¿’ç›®æ¨™</h2>
            <p>ã“ã®ç« ã‚’èª­ã‚€ã“ã¨ã§ã€ä»¥ä¸‹ã‚’ç¿’å¾—ã§ãã¾ã™ï¼š</p>
            <ul>
                <li>âœ… PIDåˆ¶å¾¡ï¼ˆæ¯”ä¾‹ãƒ»ç©åˆ†ãƒ»å¾®åˆ†ï¼‰ã®å‹•ä½œåŸç†ã¨ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒãƒ¥ãƒ¼ãƒ‹ãƒ³ã‚°æ‰‹æ³•ã‚’ç†è§£ã™ã‚‹</li>
                <li>âœ… æ¸©åº¦åˆ¶å¾¡ç³»ï¼ˆãƒ’ãƒ¼ã‚¿ãƒ¼ã€ã‚»ãƒ³ã‚µãƒ¼ã€ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ãƒ«ãƒ¼ãƒ—ï¼‰ã‚’è¨­è¨ˆãƒ»ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã§ãã‚‹</li>
                <li>âœ… çœŸç©ºãƒãƒ³ãƒ—ãƒ€ã‚¦ãƒ³æ™‚é–“ã‚’è¨ˆç®—ã—ã€ãƒªãƒ¼ã‚¯æ¤œå‡ºæ–¹æ³•ã‚’ç†è§£ã™ã‚‹</li>
                <li>âœ… ã‚¬ã‚¹ãƒ•ãƒ­ãƒ¼ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ï¼ˆMFCï¼‰ã®åŸç†ã¨åˆ†åœ§è¨ˆç®—ï¼ˆDaltonã®æ³•å‰‡ï¼‰ã‚’å®Ÿè·µã§ãã‚‹</li>
                <li>âœ… é›°å›²æ°—åˆ¶å¾¡ï¼ˆArã€Nâ‚‚ã€Hâ‚‚ï¼‰ã«ãŠã‘ã‚‹é…¸ç´ åˆ†åœ§ã¨éœ²ç‚¹ç®¡ç†ã‚’ç†è§£ã™ã‚‹</li>
                <li>âœ… ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ‡ãƒ¼ã‚¿åé›†ã¨ãƒ—ãƒ­ã‚»ã‚¹ç•°å¸¸æ¤œçŸ¥ã‚·ã‚¹ãƒ†ãƒ ã‚’æ§‹ç¯‰ã§ãã‚‹</li>
                <li>âœ… Pythonã§ãƒ—ãƒ­ã‚»ã‚¹åˆ¶å¾¡ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼ã¨ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ã‚’å®Ÿè£…ã§ãã‚‹</li>
            </ul>
        </div>

        <h2>1.1 PIDåˆ¶å¾¡ã®åŸç†ã¨ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³</h2>

        <h3>1.1.1 ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯åˆ¶å¾¡ã®åŸºç¤</h3>
        <p>ãƒ—ãƒ­ã‚»ã‚¹åˆ¶å¾¡ã®ç›®çš„ã¯ã€**ç›®æ¨™å€¤ï¼ˆSet Pointï¼‰** ã«å¯¾ã—ã¦ **åˆ¶å¾¡å¤‰æ•°ï¼ˆProcess Variable, PVï¼‰** ã‚’ç¶­æŒã™ã‚‹ã“ã¨ã§ã™ã€‚æœ€ã‚‚åºƒãä½¿ã‚ã‚Œã‚‹åˆ¶å¾¡æ‰‹æ³•ãŒ<strong>PIDåˆ¶å¾¡</strong>ï¼ˆProportional-Integral-Derivative Controlï¼‰ã§ã™ã€‚</p>

        <p><strong>PIDåˆ¶å¾¡ã®æ§‹æˆè¦ç´ </strong>ï¼š</p>
        <ul>
            <li><strong>Pï¼ˆæ¯”ä¾‹ï¼‰</strong>ï¼šåå·®ï¼ˆèª¤å·® $e = SP - PV$ï¼‰ã«æ¯”ä¾‹ã—ãŸåˆ¶å¾¡å‡ºåŠ›</li>
            <li><strong>Iï¼ˆç©åˆ†ï¼‰</strong>ï¼šåå·®ã®ç´¯ç©ï¼ˆå®šå¸¸åå·®ã‚’é™¤å»ï¼‰</li>
            <li><strong>Dï¼ˆå¾®åˆ†ï¼‰</strong>ï¼šåå·®ã®å¤‰åŒ–ç‡ï¼ˆã‚ªãƒ¼ãƒãƒ¼ã‚·ãƒ¥ãƒ¼ãƒˆã‚’æŠ‘åˆ¶ï¼‰</li>
        </ul>

        <p><strong>PIDåˆ¶å¾¡å¼</strong>ï¼š</p>
        $$
        u(t) = K_p e(t) + K_i \int_0^t e(\tau) d\tau + K_d \frac{de(t)}{dt}
        $$

        <ul>
            <li>$u(t)$ï¼šåˆ¶å¾¡å‡ºåŠ›ï¼ˆä¾‹ï¼šãƒ’ãƒ¼ã‚¿ãƒ¼é›»åŠ› %ï¼‰</li>
            <li>$e(t) = SP - PV(t)$ï¼šåå·®</li>
            <li>$K_p$ï¼šæ¯”ä¾‹ã‚²ã‚¤ãƒ³</li>
            <li>$K_i$ï¼šç©åˆ†ã‚²ã‚¤ãƒ³</li>
            <li>$K_d$ï¼šå¾®åˆ†ã‚²ã‚¤ãƒ³</li>
        </ul>

        <p><strong>é›¢æ•£æ™‚é–“PIDå¼</strong>ï¼ˆãƒ‡ã‚¸ã‚¿ãƒ«åˆ¶å¾¡ç³»ï¼‰ï¼š</p>
        $$
        u_n = K_p e_n + K_i \Delta t \sum_{k=0}^{n} e_k + K_d \frac{e_n - e_{n-1}}{\Delta t}
        $$

        <div class="mermaid">
flowchart LR
    A[ç›®æ¨™å€¤ SP] --> B[æ¯”è¼ƒå™¨]
    F[ã‚»ãƒ³ã‚µãƒ¼<br/>æ¸¬å®šå€¤ PV] --> B
    B --> C[èª¤å·® e]
    C --> D[PIDã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼]
    D --> E[åˆ¶å¾¡å‡ºåŠ› u]
    E --> G[ãƒ—ãƒ­ã‚»ã‚¹<br/>ãƒ’ãƒ¼ã‚¿ãƒ¼ç­‰]
    G --> F

    style A fill:#f093fb,stroke:#f5576c,stroke-width:2px,color:#fff
    style D fill:#f093fb,stroke:#f5576c,stroke-width:2px,color:#fff
    style G fill:#fce7f3,stroke:#f093fb,stroke-width:2px
        </div>

        <h4>ã‚³ãƒ¼ãƒ‰ä¾‹1-1: PIDåˆ¶å¾¡ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼</h4>
        <pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt

class PIDController:
    """
    PIDåˆ¶å¾¡ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼

    æ¸©åº¦åˆ¶å¾¡ãªã©ã®ãƒ—ãƒ­ã‚»ã‚¹åˆ¶å¾¡ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã™ã‚‹
    """

    def __init__(self, Kp, Ki, Kd, setpoint, dt=1.0):
        """
        Parameters
        ----------
        Kp : float
            æ¯”ä¾‹ã‚²ã‚¤ãƒ³
        Ki : float
            ç©åˆ†ã‚²ã‚¤ãƒ³
        Kd : float
            å¾®åˆ†ã‚²ã‚¤ãƒ³
        setpoint : float
            ç›®æ¨™å€¤ï¼ˆSet Pointï¼‰
        dt : float
            ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°æ™‚é–“ï¼ˆç§’ï¼‰
        """
        self.Kp = Kp
        self.Ki = Ki
        self.Kd = Kd
        self.setpoint = setpoint
        self.dt = dt

        self.integral = 0.0
        self.prev_error = 0.0

    def update(self, measured_value):
        """
        åˆ¶å¾¡å‡ºåŠ›ã®è¨ˆç®—ï¼ˆPIDæ¼”ç®—ï¼‰

        Parameters
        ----------
        measured_value : float
            æ¸¬å®šå€¤ï¼ˆãƒ—ãƒ­ã‚»ã‚¹å¤‰æ•° PVï¼‰

        Returns
        -------
        output : float
            åˆ¶å¾¡å‡ºåŠ› u(t)
        """
        error = self.setpoint - measured_value

        # Pé …ï¼ˆæ¯”ä¾‹ï¼‰
        P = self.Kp * error

        # Ié …ï¼ˆç©åˆ†ï¼‰
        self.integral += error * self.dt
        I = self.Ki * self.integral

        # Dé …ï¼ˆå¾®åˆ†ï¼‰
        derivative = (error - self.prev_error) / self.dt
        D = self.Kd * derivative

        # PIDå‡ºåŠ›
        output = P + I + D

        # çŠ¶æ…‹æ›´æ–°
        self.prev_error = error

        return output


def simulate_temperature_control(Kp=2.0, Ki=0.5, Kd=0.1,
                                  target_temp=800, duration=200):
    """
    æ¸©åº¦åˆ¶å¾¡ãƒ—ãƒ­ã‚»ã‚¹ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³

    Parameters
    ----------
    Kp, Ki, Kd : float
        PIDã‚²ã‚¤ãƒ³
    target_temp : float
        ç›®æ¨™æ¸©åº¦ï¼ˆâ„ƒï¼‰
    duration : float
        ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³æ™‚é–“ï¼ˆç§’ï¼‰

    Returns
    -------
    time, temp, output : ndarray
        æ™‚é–“ã€æ¸©åº¦å±¥æ­´ã€åˆ¶å¾¡å‡ºåŠ›
    """
    dt = 1.0  # ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°æ™‚é–“ï¼ˆç§’ï¼‰
    n_steps = int(duration / dt)

    # PIDã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼åˆæœŸåŒ–
    pid = PIDController(Kp, Ki, Kd, target_temp, dt)

    # åˆæœŸåŒ–
    time = np.arange(0, duration, dt)
    temp = np.zeros(n_steps)
    output = np.zeros(n_steps)
    temp[0] = 25.0  # å®¤æ¸©ã‹ã‚‰ã‚¹ã‚¿ãƒ¼ãƒˆ

    # ç°¡æ˜“ç†±ãƒ—ãƒ­ã‚»ã‚¹ãƒ¢ãƒ‡ãƒ«ï¼ˆ1æ¬¡é…ã‚Œç³»ï¼‰
    # dT/dt = (output - heat_loss) / thermal_mass
    thermal_mass = 50.0
    heat_loss_coeff = 0.05

    for i in range(1, n_steps):
        # PIDåˆ¶å¾¡å‡ºåŠ›è¨ˆç®—
        output[i] = pid.update(temp[i-1])

        # åˆ¶å¾¡å‡ºåŠ›ã®åˆ¶é™ï¼ˆ0-100%ï¼‰
        output[i] = np.clip(output[i], 0, 100)

        # æ¸©åº¦å¤‰åŒ–ã®è¨ˆç®—
        heat_input = output[i]
        heat_loss = heat_loss_coeff * (temp[i-1] - 25.0)
        dT = (heat_input - heat_loss) / thermal_mass

        temp[i] = temp[i-1] + dT * dt

    return time, temp, output


# ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å®Ÿè¡Œ
time, temp, output = simulate_temperature_control()

# çµæœãƒ—ãƒ­ãƒƒãƒˆ
fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(10, 8))

# æ¸©åº¦ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«
ax1.plot(time, temp, 'b-', linewidth=2, label='Temperature')
ax1.axhline(y=800, color='r', linestyle='--', label='Setpoint')
ax1.set_xlabel('Time (s)')
ax1.set_ylabel('Temperature (Â°C)')
ax1.set_title('PID Temperature Control Simulation')
ax1.legend()
ax1.grid(True, alpha=0.3)

# åˆ¶å¾¡å‡ºåŠ›
ax2.plot(time, output, 'g-', linewidth=2)
ax2.set_xlabel('Time (s)')
ax2.set_ylabel('Heater Output (%)')
ax2.set_title('PID Control Output')
ax2.grid(True, alpha=0.3)

plt.tight_layout()
plt.savefig('pid_simulation.png', dpi=150, bbox_inches='tight')
plt.show()

# æ€§èƒ½æŒ‡æ¨™ã®è¨ˆç®—
settling_time = time[np.where(np.abs(temp - 800) < 5)[0][0]]
overshoot = np.max(temp) - 800
print(f"Settling Time (Â±5Â°C): {settling_time:.1f} s")
print(f"Overshoot: {overshoot:.1f} Â°C")
print(f"Steady-State Error: {np.abs(temp[-1] - 800):.2f} Â°C")</code></pre>

        <h3>1.1.2 PIDãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒãƒ¥ãƒ¼ãƒ‹ãƒ³ã‚°</h3>
        <p>PIDåˆ¶å¾¡ã®æ€§èƒ½ã¯ã€3ã¤ã®ã‚²ã‚¤ãƒ³ï¼ˆ$K_p$, $K_i$, $K_d$ï¼‰ã®èª¿æ•´ã«ä¾å­˜ã—ã¾ã™ã€‚</p>

        <table>
            <thead>
                <tr>
                    <th>ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿</th>
                    <th>åŠ¹æœ</th>
                    <th>å¢—åŠ æ™‚ã®å½±éŸ¿</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>$K_p$ï¼ˆæ¯”ä¾‹ï¼‰</strong></td>
                    <td>å¿œç­”é€Ÿåº¦ã‚’ä¸Šã’ã‚‹</td>
                    <td>ã‚ªãƒ¼ãƒãƒ¼ã‚·ãƒ¥ãƒ¼ãƒˆå¢—åŠ ã€æŒ¯å‹•ã—ã‚„ã™ã„</td>
                </tr>
                <tr>
                    <td><strong>$K_i$ï¼ˆç©åˆ†ï¼‰</strong></td>
                    <td>å®šå¸¸åå·®ã‚’é™¤å»</td>
                    <td>æŒ¯å‹•ã€æ•´å®šæ™‚é–“å¢—åŠ </td>
                </tr>
                <tr>
                    <td><strong>$K_d$ï¼ˆå¾®åˆ†ï¼‰</strong></td>
                    <td>ã‚ªãƒ¼ãƒãƒ¼ã‚·ãƒ¥ãƒ¼ãƒˆæŠ‘åˆ¶</td>
                    <td>ãƒã‚¤ã‚ºã«æ•æ„Ÿã€å®‰å®šåŒ–</td>
                </tr>
            </tbody>
        </table>

        <p><strong>Ziegler-Nicholsãƒãƒ¥ãƒ¼ãƒ‹ãƒ³ã‚°æ³•ï¼ˆå®Ÿé¨“çš„æ‰‹æ³•ï¼‰</strong>ï¼š</p>
        <ol>
            <li>$K_i = 0$, $K_d = 0$ ã¨ã—ã€$K_p$ ã®ã¿ã§åˆ¶å¾¡</li>
            <li>$K_p$ ã‚’å¢—åŠ ã•ã›ã€æŒç¶šæŒ¯å‹•ãŒç™ºç”Ÿã™ã‚‹è‡¨ç•Œã‚²ã‚¤ãƒ³ $K_u$ ã‚’è¦‹ã¤ã‘ã‚‹</li>
            <li>æŒ¯å‹•å‘¨æœŸ $T_u$ ã‚’æ¸¬å®š</li>
            <li>ä»¥ä¸‹ã®å¼ã§PIDã‚²ã‚¤ãƒ³ã‚’è¨ˆç®—ï¼š
                $$
                K_p = 0.6 K_u, \quad K_i = \frac{2K_p}{T_u}, \quad K_d = \frac{K_p T_u}{8}
                $$
            </li>
        </ol>

        <h4>ã‚³ãƒ¼ãƒ‰ä¾‹1-2: PIDãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®è‡ªå‹•æœ€é©åŒ–</h4>
        <pre><code class="language-python">from scipy.optimize import differential_evolution

def evaluate_pid_performance(params, target_temp=800, duration=200):
    """
    PIDãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®æ€§èƒ½è©•ä¾¡é–¢æ•°

    IAEï¼ˆIntegral of Absolute Errorï¼‰ã‚’æœ€å°åŒ–

    Parameters
    ----------
    params : tuple
        (Kp, Ki, Kd)

    Returns
    -------
    cost : float
        è©•ä¾¡ã‚³ã‚¹ãƒˆï¼ˆå°ã•ã„ã»ã©è‰¯ã„ï¼‰
    """
    Kp, Ki, Kd = params

    # ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å®Ÿè¡Œ
    time, temp, output = simulate_temperature_control(Kp, Ki, Kd,
                                                       target_temp, duration)

    # è©•ä¾¡æŒ‡æ¨™ï¼šIAE + ã‚ªãƒ¼ãƒãƒ¼ã‚·ãƒ¥ãƒ¼ãƒˆãƒšãƒŠãƒ«ãƒ†ã‚£
    error = np.abs(temp - target_temp)
    IAE = np.sum(error)

    overshoot = np.max(temp) - target_temp
    overshoot_penalty = 100 * max(0, overshoot)

    cost = IAE + overshoot_penalty

    return cost


# æœ€é©åŒ–å®Ÿè¡Œï¼ˆå·®åˆ†é€²åŒ–ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ï¼‰
bounds = [(0.1, 10.0),  # Kp
          (0.01, 2.0),  # Ki
          (0.0, 1.0)]   # Kd

result = differential_evolution(
    evaluate_pid_performance,
    bounds,
    maxiter=50,
    seed=42,
    disp=True
)

Kp_opt, Ki_opt, Kd_opt = result.x
print(f"Optimal PID gains:")
print(f"  Kp = {Kp_opt:.3f}")
print(f"  Ki = {Ki_opt:.3f}")
print(f"  Kd = {Kd_opt:.3f}")

# æœ€é©åŒ–å¾Œã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
time, temp_opt, output_opt = simulate_temperature_control(
    Kp_opt, Ki_opt, Kd_opt
)

# æ¯”è¼ƒãƒ—ãƒ­ãƒƒãƒˆ
time, temp_default, _ = simulate_temperature_control(2.0, 0.5, 0.1)

plt.figure(figsize=(10, 6))
plt.plot(time, temp_default, 'b--', linewidth=2, label='Default PID')
plt.plot(time, temp_opt, 'r-', linewidth=2, label='Optimized PID')
plt.axhline(y=800, color='k', linestyle=':', label='Setpoint')
plt.xlabel('Time (s)')
plt.ylabel('Temperature (Â°C)')
plt.title('PID Optimization Comparison')
plt.legend()
plt.grid(True, alpha=0.3)
plt.savefig('pid_optimization.png', dpi=150, bbox_inches='tight')
plt.show()</code></pre>

        <h2>1.2 æ¸©åº¦åˆ¶å¾¡ç³»ã®è¨­è¨ˆ</h2>

        <h3>1.2.1 æ¸©åº¦ãƒ©ãƒ³ãƒ—ã¨å¤šæ®µãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«</h3>
        <p>ç†±å‡¦ç†ãƒ—ãƒ­ã‚»ã‚¹ã§ã¯ã€å˜ç´”ãªä¸€å®šæ¸©åº¦ä¿æŒã ã‘ã§ãªãã€<strong>æ˜‡æ¸©é€Ÿåº¦åˆ¶å¾¡</strong>ã‚„<strong>å¤šæ®µéšãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«</strong>ãŒå¿…è¦ã§ã™ã€‚</p>

        <p><strong>æ¸©åº¦ãƒ©ãƒ³ãƒ—ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ã®è¨­è¨ˆ</strong>ï¼š</p>
        <ul>
            <li><strong>æ˜‡æ¸©é€Ÿåº¦</strong>ï¼š$R_{\text{heat}} = 1-20$ â„ƒ/minï¼ˆææ–™ãƒ»ãƒ—ãƒ­ã‚»ã‚¹ã«ã‚ˆã‚Šç•°ãªã‚‹ï¼‰</li>
            <li><strong>ä¿æŒæ™‚é–“</strong>ï¼š$t_{\text{hold}} = 10-180$ minï¼ˆæ‹¡æ•£ãƒ»åå¿œæ™‚é–“ã®ç¢ºä¿ï¼‰</li>
            <li><strong>å†·å´é€Ÿåº¦</strong>ï¼š$R_{\text{cool}} = 0.5-50$ â„ƒ/minï¼ˆæ€¥å†· or å¾å†·ï¼‰</li>
        </ul>

        <h4>ã‚³ãƒ¼ãƒ‰ä¾‹1-3: å¤šæ®µéšæ¸©åº¦ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ç”Ÿæˆå™¨</h4>
        <pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt

def generate_temperature_profile(segments, dt=1.0):
    """
    å¤šæ®µéšæ¸©åº¦ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ã®ç”Ÿæˆ

    Parameters
    ----------
    segments : list of dict
        å„ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã®ä»•æ§˜
        ä¾‹: [{'type': 'ramp', 'start': 25, 'end': 800, 'rate': 10},
             {'type': 'hold', 'temp': 800, 'duration': 3600}]
    dt : float
        ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°æ™‚é–“ï¼ˆç§’ï¼‰

    Returns
    -------
    time, temperature : ndarray
        æ™‚é–“ã¨æ¸©åº¦ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«
    """
    time_profile = []
    temp_profile = []
    current_time = 0.0
    current_temp = segments[0].get('start', 25.0)

    for seg in segments:
        if seg['type'] == 'ramp':
            # æ˜‡æ¸©/é™æ¸©ã‚»ã‚°ãƒ¡ãƒ³ãƒˆ
            start_temp = seg['start']
            end_temp = seg['end']
            rate = seg['rate']  # â„ƒ/min

            duration = abs(end_temp - start_temp) / rate * 60  # ç§’
            n_steps = int(duration / dt)

            seg_time = np.linspace(current_time, current_time + duration, n_steps)
            seg_temp = np.linspace(start_temp, end_temp, n_steps)

            time_profile.append(seg_time)
            temp_profile.append(seg_temp)

            current_time += duration
            current_temp = end_temp

        elif seg['type'] == 'hold':
            # ä¿æŒã‚»ã‚°ãƒ¡ãƒ³ãƒˆ
            hold_temp = seg['temp']
            duration = seg['duration']  # ç§’
            n_steps = int(duration / dt)

            seg_time = np.linspace(current_time, current_time + duration, n_steps)
            seg_temp = np.ones(n_steps) * hold_temp

            time_profile.append(seg_time)
            temp_profile.append(seg_temp)

            current_time += duration
            current_temp = hold_temp

    time_profile = np.concatenate(time_profile)
    temp_profile = np.concatenate(temp_profile)

    return time_profile, temp_profile


# å…¸å‹çš„ãªç„¼éˆãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«
annealing_segments = [
    {'type': 'ramp', 'start': 25, 'end': 800, 'rate': 10},    # æ˜‡æ¸© 10â„ƒ/min
    {'type': 'hold', 'temp': 800, 'duration': 3600},          # ä¿æŒ 1æ™‚é–“
    {'type': 'ramp', 'start': 800, 'end': 25, 'rate': 5}      # å¾å†· 5â„ƒ/min
]

time, temp = generate_temperature_profile(annealing_segments)

# ãƒ—ãƒ­ãƒƒãƒˆã¨è§£æ
plt.figure(figsize=(12, 6))
plt.plot(time/60, temp, 'b-', linewidth=2)
plt.xlabel('Time (min)')
plt.ylabel('Temperature (Â°C)')
plt.title('Multi-Segment Temperature Profile (Annealing)')
plt.grid(True, alpha=0.3)
plt.savefig('temperature_profile.png', dpi=150, bbox_inches='tight')
plt.show()

# ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«çµ±è¨ˆ
total_time = time[-1] / 3600
max_temp = np.max(temp)
print(f"Total Process Time: {total_time:.2f} hours")
print(f"Maximum Temperature: {max_temp:.0f} Â°C")
print(f"Average Heating Rate: {(max_temp - 25) / (time[np.argmax(temp)] / 60):.2f} Â°C/min")</code></pre>

        <h2>1.3 çœŸç©ºã‚·ã‚¹ãƒ†ãƒ ã¨åœ§åŠ›åˆ¶å¾¡</h2>

        <h3>1.3.1 çœŸç©ºãƒãƒ³ãƒ—ãƒ€ã‚¦ãƒ³æ™‚é–“ã®è¨ˆç®—</h3>
        <p>çœŸç©ºãƒ—ãƒ­ã‚»ã‚¹ï¼ˆã‚¹ãƒ‘ãƒƒã‚¿ãƒªãƒ³ã‚°ã€CVDã€ç„¼éˆï¼‰ã§ã¯ã€ãƒãƒ£ãƒ³ãƒãƒ¼å†…ã‚’ç›®æ¨™åœ§åŠ›ã¾ã§æ’æ°—ã™ã‚‹<strong>ãƒãƒ³ãƒ—ãƒ€ã‚¦ãƒ³æ™‚é–“</strong>ãŒé‡è¦ã§ã™ã€‚</p>

        <p><strong>ãƒãƒ³ãƒ—ãƒ€ã‚¦ãƒ³æ–¹ç¨‹å¼</strong>ï¼š</p>
        $$
        P(t) = P_0 \exp\left(-\frac{S}{V} t\right) + P_{\text{ultimate}}
        $$

        <ul>
            <li>$P(t)$ï¼šæ™‚åˆ» $t$ ã§ã®åœ§åŠ›</li>
            <li>$P_0$ï¼šåˆæœŸåœ§åŠ›ï¼ˆé€šå¸¸ã¯å¤§æ°—åœ§ 101325 Paï¼‰</li>
            <li>$S$ï¼šå®ŸåŠ¹æ’æ°—é€Ÿåº¦ï¼ˆmÂ³/sï¼‰</li>
            <li>$V$ï¼šãƒãƒ£ãƒ³ãƒãƒ¼å®¹ç©ï¼ˆmÂ³ï¼‰</li>
            <li>$P_{\text{ultimate}}$ï¼šåˆ°é”åœ§åŠ›ï¼ˆãƒãƒ³ãƒ—æ€§èƒ½é™ç•Œï¼‰</li>
        </ul>

        <p><strong>å®ŸåŠ¹æ’æ°—é€Ÿåº¦</strong>ï¼ˆé…ç®¡æŠµæŠ—ã‚’è€ƒæ…®ï¼‰ï¼š</p>
        $$
        \frac{1}{S} = \frac{1}{S_{\text{pump}}} + \frac{1}{C_{\text{pipe}}}
        $$

        <ul>
            <li>$S_{\text{pump}}$ï¼šãƒãƒ³ãƒ—å…¬ç§°æ’æ°—é€Ÿåº¦</li>
            <li>$C_{\text{pipe}}$ï¼šé…ç®¡ã‚³ãƒ³ãƒ€ã‚¯ã‚¿ãƒ³ã‚¹</li>
        </ul>

        <h4>ã‚³ãƒ¼ãƒ‰ä¾‹1-4: çœŸç©ºãƒãƒ³ãƒ—ãƒ€ã‚¦ãƒ³ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼</h4>
        <pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt

def pumpdown_curve(V, S_pump, C_pipe, P0=101325, P_ultimate=1e-3,
                   t_max=600):
    """
    çœŸç©ºãƒãƒ³ãƒ—ãƒ€ã‚¦ãƒ³ã‚«ãƒ¼ãƒ–ã®è¨ˆç®—

    Parameters
    ----------
    V : float
        ãƒãƒ£ãƒ³ãƒãƒ¼å®¹ç©ï¼ˆmÂ³ï¼‰
    S_pump : float
        ãƒãƒ³ãƒ—æ’æ°—é€Ÿåº¦ï¼ˆmÂ³/sï¼‰
    C_pipe : float
        é…ç®¡ã‚³ãƒ³ãƒ€ã‚¯ã‚¿ãƒ³ã‚¹ï¼ˆmÂ³/sï¼‰
    P0 : float
        åˆæœŸåœ§åŠ›ï¼ˆPaï¼‰
    P_ultimate : float
        åˆ°é”åœ§åŠ›ï¼ˆPaï¼‰
    t_max : float
        æœ€å¤§æ™‚é–“ï¼ˆç§’ï¼‰

    Returns
    -------
    time, pressure : ndarray
        æ™‚é–“ã¨åœ§åŠ›å±¥æ­´
    """
    # å®ŸåŠ¹æ’æ°—é€Ÿåº¦
    S_eff = 1 / (1/S_pump + 1/C_pipe)

    time = np.linspace(0, t_max, 1000)
    pressure = P0 * np.exp(-S_eff / V * time) + P_ultimate

    return time, pressure


def calculate_pumpdown_time(V, S_pump, C_pipe, P_target, P0=101325):
    """
    ç›®æ¨™åœ§åŠ›åˆ°é”æ™‚é–“ã®è¨ˆç®—

    Returns
    -------
    t_pumpdown : float
        ãƒãƒ³ãƒ—ãƒ€ã‚¦ãƒ³æ™‚é–“ï¼ˆç§’ï¼‰
    """
    S_eff = 1 / (1/S_pump + 1/C_pipe)
    t_pumpdown = -(V / S_eff) * np.log(P_target / P0)

    return t_pumpdown


# å…¸å‹çš„ãªã‚¹ãƒ‘ãƒƒã‚¿ãƒªãƒ³ã‚°è£…ç½®ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
V_chamber = 0.5  # mÂ³ï¼ˆ500 Lï¼‰
S_pump = 0.25    # mÂ³/sï¼ˆ250 L/s ã‚¿ãƒ¼ãƒœãƒãƒ³ãƒ—ï¼‰
C_pipe = 0.5     # mÂ³/sï¼ˆé…ç®¡ã‚³ãƒ³ãƒ€ã‚¯ã‚¿ãƒ³ã‚¹ï¼‰

# ãƒãƒ³ãƒ—ãƒ€ã‚¦ãƒ³ã‚«ãƒ¼ãƒ–
time, pressure = pumpdown_curve(V_chamber, S_pump, C_pipe)

# ãƒ—ãƒ­ãƒƒãƒˆ
plt.figure(figsize=(10, 6))
plt.semilogy(time/60, pressure, 'b-', linewidth=2)
plt.axhline(y=1.0, color='r', linestyle='--', label='Target: 1 Pa')
plt.axhline(y=1e-3, color='g', linestyle='--', label='Ultimate: 1 mPa')
plt.xlabel('Time (min)')
plt.ylabel('Pressure (Pa)')
plt.title('Vacuum Pumpdown Curve')
plt.legend()
plt.grid(True, alpha=0.3, which='both')
plt.savefig('pumpdown_curve.png', dpi=150, bbox_inches='tight')
plt.show()

# åˆ°é”æ™‚é–“è¨ˆç®—
P_target = 1.0  # Pa
t_pumpdown = calculate_pumpdown_time(V_chamber, S_pump, C_pipe, P_target)
print(f"Pumpdown time to {P_target} Pa: {t_pumpdown/60:.2f} min")

# å®ŸåŠ¹æ’æ°—é€Ÿåº¦
S_eff = 1 / (1/S_pump + 1/C_pipe)
print(f"Effective pumping speed: {S_eff:.3f} mÂ³/s ({S_eff*1000:.0f} L/s)")</code></pre>

        <h3>1.3.2 Daltonã®æ³•å‰‡ã¨ã‚¬ã‚¹åˆ†åœ§åˆ¶å¾¡</h3>
        <p>ãƒ—ãƒ­ã‚»ã‚¹é›°å›²æ°—ã®åˆ¶å¾¡ã§ã¯ã€è¤‡æ•°ã‚¬ã‚¹ã®æ··åˆæ¯”ãŒé‡è¦ã§ã™ã€‚<strong>Daltonã®æ³•å‰‡</strong>ã«ã‚ˆã‚Šã€å…¨åœ§ã¯å„æˆåˆ†ã‚¬ã‚¹ã®åˆ†åœ§ã®å’Œã§ã™ã€‚</p>

        <p><strong>Daltonã®æ³•å‰‡</strong>ï¼š</p>
        $$
        P_{\text{total}} = \sum_{i} P_i = P_{\text{Ar}} + P_{\text{N}_2} + P_{\text{O}_2} + \cdots
        $$

        <p><strong>åˆ†åœ§ã¨ãƒ¢ãƒ«åˆ†ç‡ã®é–¢ä¿‚</strong>ï¼š</p>
        $$
        P_i = x_i P_{\text{total}}, \quad x_i = \frac{n_i}{\sum_j n_j}
        $$

        <h4>ã‚³ãƒ¼ãƒ‰ä¾‹1-5: ã‚¬ã‚¹åˆ†åœ§è¨ˆç®—ã¨MFCåˆ¶å¾¡</h4>
        <pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt

def calculate_partial_pressures(flow_rates, total_pressure):
    """
    Daltonã®æ³•å‰‡ã«ã‚ˆã‚‹åˆ†åœ§è¨ˆç®—

    Parameters
    ----------
    flow_rates : dict
        ã‚¬ã‚¹ãƒ•ãƒ­ãƒ¼ãƒ¬ãƒ¼ãƒˆï¼ˆsccmï¼‰
        ä¾‹: {'Ar': 100, 'N2': 50, 'O2': 10}
    total_pressure : float
        å…¨åœ§ï¼ˆPaï¼‰

    Returns
    -------
    partial_pressures : dict
        å„ã‚¬ã‚¹ã®åˆ†åœ§ï¼ˆPaï¼‰
    """
    total_flow = sum(flow_rates.values())

    partial_pressures = {}
    for gas, flow in flow_rates.items():
        mole_fraction = flow / total_flow
        partial_pressures[gas] = mole_fraction * total_pressure

    return partial_pressures


def oxygen_partial_pressure_control(target_pO2, total_pressure,
                                      total_flow=200):
    """
    é…¸ç´ åˆ†åœ§åˆ¶å¾¡ã®ãŸã‚ã®Ar/O2æ··åˆæ¯”è¨ˆç®—

    Parameters
    ----------
    target_pO2 : float
        ç›®æ¨™é…¸ç´ åˆ†åœ§ï¼ˆPaï¼‰
    total_pressure : float
        å…¨åœ§ï¼ˆPaï¼‰
    total_flow : float
        ç·æµé‡ï¼ˆsccmï¼‰

    Returns
    -------
    flow_Ar, flow_O2 : float
        Arã¨o2ã®ãƒ•ãƒ­ãƒ¼ãƒ¬ãƒ¼ãƒˆï¼ˆsccmï¼‰
    """
    # é…¸ç´ ãƒ¢ãƒ«åˆ†ç‡
    x_O2 = target_pO2 / total_pressure

    # ãƒ•ãƒ­ãƒ¼ãƒ¬ãƒ¼ãƒˆè¨ˆç®—
    flow_O2 = x_O2 * total_flow
    flow_Ar = (1 - x_O2) * total_flow

    return flow_Ar, flow_O2


# ã‚±ãƒ¼ã‚¹ã‚¹ã‚¿ãƒ‡ã‚£ï¼šåå¿œæ€§ã‚¹ãƒ‘ãƒƒã‚¿ãƒªãƒ³ã‚°
# ç›®æ¨™ï¼šé…¸ç´ åˆ†åœ§ 0.1 Paã€å…¨åœ§ 1.0 Pa

total_pressure = 1.0  # Pa
target_pO2 = 0.1      # Pa
total_flow = 200      # sccm

flow_Ar, flow_O2 = oxygen_partial_pressure_control(target_pO2, total_pressure,
                                                     total_flow)

print(f"Gas Flow Control Settings:")
print(f"  Ar: {flow_Ar:.1f} sccm")
print(f"  O2: {flow_O2:.1f} sccm")
print(f"  Total: {total_flow:.1f} sccm")

# åˆ†åœ§è¨ˆç®—
flow_rates = {'Ar': flow_Ar, 'O2': flow_O2}
partial_pressures = calculate_partial_pressures(flow_rates, total_pressure)

print(f"\nPartial Pressures:")
for gas, pressure in partial_pressures.items():
    print(f"  {gas}: {pressure:.3f} Pa")

# å¯è¦–åŒ–ï¼šé…¸ç´ åˆ†åœ§ vs Arãƒ•ãƒ­ãƒ¼
pO2_range = np.linspace(0.01, 0.5, 50)
Ar_flows = []
O2_flows = []

for pO2 in pO2_range:
    Ar, O2 = oxygen_partial_pressure_control(pO2, total_pressure, total_flow)
    Ar_flows.append(Ar)
    O2_flows.append(O2)

plt.figure(figsize=(10, 6))
plt.plot(pO2_range, Ar_flows, 'b-', linewidth=2, label='Ar')
plt.plot(pO2_range, O2_flows, 'r-', linewidth=2, label='Oâ‚‚')
plt.xlabel('Target Oâ‚‚ Partial Pressure (Pa)')
plt.ylabel('Flow Rate (sccm)')
plt.title('Gas Flow Control for Reactive Sputtering')
plt.legend()
plt.grid(True, alpha=0.3)
plt.savefig('gas_flow_control.png', dpi=150, bbox_inches='tight')
plt.show()</code></pre>

        <h2>1.4 ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ—ãƒ­ã‚»ã‚¹ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°</h2>

        <h3>1.4.1 ãƒ‡ãƒ¼ã‚¿åé›†ã¨ãƒ­ã‚®ãƒ³ã‚°</h3>
        <p>ãƒ—ãƒ­ã‚»ã‚¹åˆ¶å¾¡ã§ã¯ã€æ¸©åº¦ã€åœ§åŠ›ã€ã‚¬ã‚¹ãƒ•ãƒ­ãƒ¼ãªã©ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’<strong>ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã§è¨˜éŒ²</strong>ã—ã€ç•°å¸¸æ¤œçŸ¥ã‚„ãƒˆãƒ¬ãƒ¼ã‚µãƒ“ãƒªãƒ†ã‚£ã«æ´»ç”¨ã—ã¾ã™ã€‚</p>

        <h4>ã‚³ãƒ¼ãƒ‰ä¾‹1-6: ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ‡ãƒ¼ã‚¿åé›†ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼</h4>
        <pre><code class="language-python">import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from datetime import datetime, timedelta

class ProcessDataLogger:
    """
    ãƒ—ãƒ­ã‚»ã‚¹ãƒ‡ãƒ¼ã‚¿ã®ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ­ã‚®ãƒ³ã‚°

    æ¸©åº¦ã€åœ§åŠ›ã€ãƒ•ãƒ­ãƒ¼ãƒ¬ãƒ¼ãƒˆãªã©ã‚’è¨˜éŒ²
    """

    def __init__(self, parameters, sampling_rate=1.0):
        """
        Parameters
        ----------
        parameters : list of str
            è¨˜éŒ²ã™ã‚‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å
        sampling_rate : float
            ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ãƒ¬ãƒ¼ãƒˆï¼ˆHzï¼‰
        """
        self.parameters = parameters
        self.sampling_rate = sampling_rate
        self.data = {param: [] for param in parameters}
        self.timestamps = []

    def log_data(self, timestamp, values):
        """
        ãƒ‡ãƒ¼ã‚¿ã®è¨˜éŒ²

        Parameters
        ----------
        timestamp : datetime
            ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—
        values : dict
            ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å€¤ã®è¾æ›¸
        """
        self.timestamps.append(timestamp)
        for param in self.parameters:
            self.data[param].append(values.get(param, np.nan))

    def to_dataframe(self):
        """
        pandasDataFrameã¸ã®å¤‰æ›

        Returns
        -------
        df : pd.DataFrame
            è¨˜éŒ²ãƒ‡ãƒ¼ã‚¿
        """
        df = pd.DataFrame(self.data)
        df['timestamp'] = self.timestamps
        return df

    def save_to_csv(self, filename):
        """
        CSVãƒ•ã‚¡ã‚¤ãƒ«ã¸ã®ä¿å­˜
        """
        df = self.to_dataframe()
        df.to_csv(filename, index=False)
        print(f"Data saved to {filename}")


def simulate_process_with_logging(duration=600, dt=1.0):
    """
    ãƒ—ãƒ­ã‚»ã‚¹ãƒ‡ãƒ¼ã‚¿ãƒ­ã‚®ãƒ³ã‚°ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³

    Parameters
    ----------
    duration : float
        ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³æ™‚é–“ï¼ˆç§’ï¼‰
    dt : float
        ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°é–“éš”ï¼ˆç§’ï¼‰

    Returns
    -------
    df : pd.DataFrame
        è¨˜éŒ²ã•ã‚ŒãŸãƒ—ãƒ­ã‚»ã‚¹ãƒ‡ãƒ¼ã‚¿
    """
    # ãƒ‡ãƒ¼ã‚¿ãƒ­ã‚¬ãƒ¼åˆæœŸåŒ–
    logger = ProcessDataLogger(
        parameters=['temperature', 'pressure', 'ar_flow', 'o2_flow'],
        sampling_rate=1/dt
    )

    # ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³åˆæœŸå€¤
    temp = 25.0
    pressure = 101325.0
    ar_flow = 100.0
    o2_flow = 10.0

    start_time = datetime.now()
    n_steps = int(duration / dt)

    for i in range(n_steps):
        # ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—
        timestamp = start_time + timedelta(seconds=i*dt)

        # ãƒ—ãƒ­ã‚»ã‚¹å¤‰åŒ–ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
        # æ˜‡æ¸©ãƒ•ã‚§ãƒ¼ã‚ºï¼ˆ0-300ç§’ï¼‰
        if i * dt < 300:
            temp += 2.5 * dt  # 2.5â„ƒ/sæ˜‡æ¸©
            pressure = max(1.0, pressure - 100 * dt)  # æ¸›åœ§
        # ä¿æŒãƒ•ã‚§ãƒ¼ã‚ºï¼ˆ300-600ç§’ï¼‰
        else:
            temp += np.random.normal(0, 0.5)  # ãƒã‚¤ã‚º
            pressure += np.random.normal(0, 0.01)

        # ãƒ©ãƒ³ãƒ€ãƒ å¤‰å‹•ï¼ˆæ¸¬å®šãƒã‚¤ã‚ºï¼‰
        ar_flow += np.random.normal(0, 0.5)
        o2_flow += np.random.normal(0, 0.1)

        # ãƒ‡ãƒ¼ã‚¿è¨˜éŒ²
        values = {
            'temperature': temp,
            'pressure': pressure,
            'ar_flow': ar_flow,
            'o2_flow': o2_flow
        }
        logger.log_data(timestamp, values)

    # DataFrameåŒ–
    df = logger.to_dataframe()

    return df, logger


# ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å®Ÿè¡Œ
df, logger = simulate_process_with_logging(duration=600, dt=1.0)

# ãƒ‡ãƒ¼ã‚¿ä¿å­˜
logger.save_to_csv('process_log.csv')

# å¯è¦–åŒ–
fig, axes = plt.subplots(2, 2, figsize=(14, 10))

# æ¸©åº¦
axes[0, 0].plot(df.index, df['temperature'], 'b-', linewidth=1.5)
axes[0, 0].set_xlabel('Time (s)')
axes[0, 0].set_ylabel('Temperature (Â°C)')
axes[0, 0].set_title('Temperature Profile')
axes[0, 0].grid(True, alpha=0.3)

# åœ§åŠ›
axes[0, 1].semilogy(df.index, df['pressure'], 'r-', linewidth=1.5)
axes[0, 1].set_xlabel('Time (s)')
axes[0, 1].set_ylabel('Pressure (Pa)')
axes[0, 1].set_title('Pressure Profile')
axes[0, 1].grid(True, alpha=0.3)

# Arãƒ•ãƒ­ãƒ¼
axes[1, 0].plot(df.index, df['ar_flow'], 'g-', linewidth=1.5)
axes[1, 0].set_xlabel('Time (s)')
axes[1, 0].set_ylabel('Ar Flow (sccm)')
axes[1, 0].set_title('Argon Flow Rate')
axes[1, 0].grid(True, alpha=0.3)

# O2ãƒ•ãƒ­ãƒ¼
axes[1, 1].plot(df.index, df['o2_flow'], 'm-', linewidth=1.5)
axes[1, 1].set_xlabel('Time (s)')
axes[1, 1].set_ylabel('Oâ‚‚ Flow (sccm)')
axes[1, 1].set_title('Oxygen Flow Rate')
axes[1, 1].grid(True, alpha=0.3)

plt.tight_layout()
plt.savefig('process_monitoring.png', dpi=150, bbox_inches='tight')
plt.show()

# çµ±è¨ˆã‚µãƒãƒªãƒ¼
print("\nProcess Data Summary:")
print(df.describe())</code></pre>

        <h4>ã‚³ãƒ¼ãƒ‰ä¾‹1-7: ãƒ—ãƒ­ã‚»ã‚¹ç•°å¸¸æ¤œçŸ¥ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰</h4>
        <pre><code class="language-python">import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

class ProcessAnomalyDetector:
    """
    ãƒ—ãƒ­ã‚»ã‚¹ç•°å¸¸æ¤œçŸ¥ã‚·ã‚¹ãƒ†ãƒ 

    ç§»å‹•å¹³å‡ã¨æ¨™æº–åå·®ã«ã‚ˆã‚‹ã—ãã„å€¤ãƒ™ãƒ¼ã‚¹æ¤œçŸ¥
    """

    def __init__(self, window_size=30, threshold_sigma=3.0):
        """
        Parameters
        ----------
        window_size : int
            ç§»å‹•å¹³å‡ã®ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚µã‚¤ã‚º
        threshold_sigma : float
            ç•°å¸¸åˆ¤å®šã—ãã„å€¤ï¼ˆÏƒã®å€æ•°ï¼‰
        """
        self.window_size = window_size
        self.threshold_sigma = threshold_sigma

    def detect_anomalies(self, data):
        """
        ç•°å¸¸æ¤œçŸ¥ã®å®Ÿè¡Œ

        Parameters
        ----------
        data : pd.Series
            ãƒ—ãƒ­ã‚»ã‚¹ãƒ‡ãƒ¼ã‚¿ç³»åˆ—

        Returns
        -------
        anomalies : pd.Series (bool)
            ç•°å¸¸ãƒ•ãƒ©ã‚°
        """
        # ç§»å‹•å¹³å‡ã¨æ¨™æº–åå·®
        rolling_mean = data.rolling(window=self.window_size).mean()
        rolling_std = data.rolling(window=self.window_size).std()

        # ä¸Šä¸‹é™ã—ãã„å€¤
        upper_bound = rolling_mean + self.threshold_sigma * rolling_std
        lower_bound = rolling_mean - self.threshold_sigma * rolling_std

        # ç•°å¸¸æ¤œçŸ¥
        anomalies = (data > upper_bound) | (data < lower_bound)

        return anomalies, upper_bound, lower_bound


# ç•°å¸¸ãƒ‡ãƒ¼ã‚¿ã®ç”Ÿæˆï¼ˆæ„å›³çš„ãªç•°å¸¸ã‚’å«ã‚€ï¼‰
np.random.seed(42)
time = np.arange(0, 600, 1)
temperature = 800 + np.random.normal(0, 2, len(time))

# ç•°å¸¸æ³¨å…¥ï¼ˆ400-420ç§’ã§æ¸©åº¦ã‚¹ãƒ‘ã‚¤ã‚¯ï¼‰
temperature[400:420] += 50

df_anomaly = pd.DataFrame({'time': time, 'temperature': temperature})

# ç•°å¸¸æ¤œçŸ¥
detector = ProcessAnomalyDetector(window_size=30, threshold_sigma=3.0)
anomalies, upper, lower = detector.detect_anomalies(df_anomaly['temperature'])

# å¯è¦–åŒ–
plt.figure(figsize=(14, 6))
plt.plot(df_anomaly['time'], df_anomaly['temperature'],
         'b-', linewidth=1.5, label='Temperature', alpha=0.7)
plt.plot(df_anomaly['time'], upper, 'r--', linewidth=2, label='Upper Threshold')
plt.plot(df_anomaly['time'], lower, 'g--', linewidth=2, label='Lower Threshold')

# ç•°å¸¸ãƒã‚¤ãƒ³ãƒˆã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆ
anomaly_points = df_anomaly[anomalies]
plt.scatter(anomaly_points['time'], anomaly_points['temperature'],
            color='red', s=50, label='Anomaly', zorder=5)

plt.xlabel('Time (s)')
plt.ylabel('Temperature (Â°C)')
plt.title('Process Anomaly Detection Dashboard')
plt.legend()
plt.grid(True, alpha=0.3)
plt.savefig('anomaly_detection.png', dpi=150, bbox_inches='tight')
plt.show()

# ç•°å¸¸ã‚µãƒãƒªãƒ¼
n_anomalies = anomalies.sum()
print(f"\nAnomaly Detection Results:")
print(f"  Total data points: {len(df_anomaly)}")
print(f"  Anomalies detected: {n_anomalies}")
print(f"  Anomaly rate: {n_anomalies/len(df_anomaly)*100:.2f}%")

if n_anomalies > 0:
    anomaly_times = df_anomaly[anomalies]['time'].values
    print(f"  Anomaly time ranges: {anomaly_times[0]:.0f}-{anomaly_times[-1]:.0f} s")</code></pre>

        <h2>æ¼”ç¿’å•é¡Œ</h2>

        <div class="exercise-box">
            <h4>æ¼”ç¿’1-1: PIDåˆ¶å¾¡ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®å½±éŸ¿ç†è§£ï¼ˆEasyï¼‰</h4>
            <p>PIDã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã§ã€ä»¥ä¸‹ã®3ã¤ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆã‚’è©¦ã—ã€æ¸©åº¦å¿œç­”ã®é•ã„ã‚’æ¯”è¼ƒã›ã‚ˆï¼š</p>
            <ul>
                <li>(a) $K_p = 5.0$, $K_i = 0$, $K_d = 0$ ï¼ˆPåˆ¶å¾¡ã®ã¿ï¼‰</li>
                <li>(b) $K_p = 2.0$, $K_i = 0.5$, $K_d = 0$ ï¼ˆPIåˆ¶å¾¡ï¼‰</li>
                <li>(c) $K_p = 2.0$, $K_i = 0.5$, $K_d = 0.1$ ï¼ˆPIDåˆ¶å¾¡ï¼‰</li>
            </ul>
            <p>ç›®æ¨™æ¸©åº¦800â„ƒã€åˆæœŸæ¸©åº¦25â„ƒã€ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³æ™‚é–“200ç§’ã€‚å„ã‚±ãƒ¼ã‚¹ã§å®šå¸¸åå·®ã€ã‚ªãƒ¼ãƒãƒ¼ã‚·ãƒ¥ãƒ¼ãƒˆã€æ•´å®šæ™‚é–“ã‚’æ¯”è¼ƒã›ã‚ˆã€‚</p>

            <details class="solution-box">
                <summary>è§£ç­”ä¾‹</summary>
                <pre><code class="language-python"># 3ã¤ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆã§ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
cases = [
    {'name': 'P-only', 'Kp': 5.0, 'Ki': 0.0, 'Kd': 0.0},
    {'name': 'PI', 'Kp': 2.0, 'Ki': 0.5, 'Kd': 0.0},
    {'name': 'PID', 'Kp': 2.0, 'Ki': 0.5, 'Kd': 0.1}
]

plt.figure(figsize=(12, 8))

for case in cases:
    time, temp, output = simulate_temperature_control(
        case['Kp'], case['Ki'], case['Kd'],
        target_temp=800, duration=200
    )

    plt.plot(time, temp, linewidth=2, label=case['name'])

    # æ€§èƒ½æŒ‡æ¨™
    steady_error = abs(temp[-1] - 800)
    overshoot = max(0, np.max(temp) - 800)
    settling_idx = np.where(np.abs(temp - 800) < 5)[0]
    settling_time = time[settling_idx[0]] if len(settling_idx) > 0 else np.inf

    print(f"{case['name']} Control:")
    print(f"  Steady-State Error: {steady_error:.2f} Â°C")
    print(f"  Overshoot: {overshoot:.2f} Â°C")
    print(f"  Settling Time (Â±5Â°C): {settling_time:.1f} s\n")

plt.axhline(y=800, color='k', linestyle='--', label='Setpoint')
plt.xlabel('Time (s)')
plt.ylabel('Temperature (Â°C)')
plt.title('PID Parameter Comparison')
plt.legend()
plt.grid(True, alpha=0.3)
plt.show()

# çµæœè§£é‡ˆï¼š
# - Påˆ¶å¾¡ã®ã¿ï¼šå®šå¸¸åå·®ãŒæ®‹ã‚‹ï¼ˆç©åˆ†é …ãŒãªã„ãŸã‚ï¼‰
# - PIåˆ¶å¾¡ï¼šå®šå¸¸åå·®ã¯è§£æ¶ˆã•ã‚Œã‚‹ãŒã€ã‚ªãƒ¼ãƒãƒ¼ã‚·ãƒ¥ãƒ¼ãƒˆãŒå¤§ãã„
# - PIDåˆ¶å¾¡ï¼šå¾®åˆ†é …ã«ã‚ˆã‚Šã€ã‚ªãƒ¼ãƒãƒ¼ã‚·ãƒ¥ãƒ¼ãƒˆãŒæŠ‘åˆ¶ã•ã‚Œæœ€é©</code></pre>
            </details>
        </div>

        <div class="exercise-box">
            <h4>æ¼”ç¿’1-2: çœŸç©ºãƒªãƒ¼ã‚¯æ¤œå‡ºï¼ˆMediumï¼‰</h4>
            <p>çœŸç©ºãƒãƒ£ãƒ³ãƒãƒ¼ï¼ˆå®¹ç©0.5 mÂ³ï¼‰ã‚’ã‚¿ãƒ¼ãƒœãƒãƒ³ãƒ—ï¼ˆæ’æ°—é€Ÿåº¦250 L/sï¼‰ã§1 Paã¾ã§æ’æ°—ã—ãŸå¾Œã€ãƒãƒ«ãƒ–ã‚’é–‰ã˜ã¦åœ§åŠ›ä¸Šæ˜‡ã‚’æ¸¬å®šã—ãŸã¨ã“ã‚ã€10åˆ†å¾Œã«1.5 Paã«ãªã£ãŸã€‚ãƒªãƒ¼ã‚¯ãƒ¬ãƒ¼ãƒˆï¼ˆPaÂ·L/sï¼‰ã‚’è¨ˆç®—ã—ã€ã“ã®ãƒªãƒ¼ã‚¯ãŒè¨±å®¹ç¯„å›²ã‹åˆ¤å®šã›ã‚ˆã€‚ï¼ˆè¨±å®¹ãƒªãƒ¼ã‚¯ãƒ¬ãƒ¼ãƒˆ: < 1Ã—10â»Â³ PaÂ·mÂ³/sï¼‰</p>

            <details class="solution-box">
                <summary>è§£ç­”ä¾‹</summary>
                <pre><code class="language-python">import numpy as np

# ä¸ãˆã‚‰ã‚ŒãŸãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
V_chamber = 0.5  # mÂ³ï¼ˆ500 Lï¼‰
P_initial = 1.0  # Pa
P_final = 1.5    # Pa
delta_t = 10 * 60  # ç§’ï¼ˆ10åˆ†ï¼‰

# ãƒªãƒ¼ã‚¯ãƒ¬ãƒ¼ãƒˆã®è¨ˆç®—
# dP/dt = Q_leak / V
# Q_leak = V * (P_final - P_initial) / delta_t

Q_leak = V_chamber * (P_final - P_initial) / delta_t

print(f"Leak Rate Calculation:")
print(f"  Initial Pressure: {P_initial} Pa")
print(f"  Final Pressure: {P_final} Pa")
print(f"  Time Interval: {delta_t/60:.1f} min")
print(f"  Leak Rate: {Q_leak:.3e} PaÂ·mÂ³/s")
print(f"  Leak Rate: {Q_leak*1000:.3e} PaÂ·L/s")

# è¨±å®¹ç¯„å›²åˆ¤å®š
Q_leak_threshold = 1e-3  # PaÂ·mÂ³/s
if Q_leak < Q_leak_threshold:
    print(f"\nâœ“ Leak rate is ACCEPTABLE (< {Q_leak_threshold:.1e} PaÂ·mÂ³/s)")
else:
    print(f"\nâœ— Leak rate is UNACCEPTABLE (â‰¥ {Q_leak_threshold:.1e} PaÂ·mÂ³/s)")
    print(f"  Action required: Leak detection and repair")

# ãƒªãƒ¼ã‚¯ç®‡æ‰€ã®æ¨å®šï¼ˆä½“ç©æµé‡ï¼‰
# at 1 Pa: Q_volume = Q_leak / P = 4.17e-4 / 1.0 = 4.17e-4 mÂ³/s
Q_volume = Q_leak / P_initial
print(f"\nEquivalent Volume Flow (at 1 Pa): {Q_volume*1000:.3f} L/s")
print(f"  â†’ Suggests a significant leak (e.g., loose flange, damaged O-ring)")

# çµæœï¼š
# Leak Rate: 4.17Ã—10â»â´ PaÂ·mÂ³/s
# ã“ã‚Œã¯è¨±å®¹å€¤ï¼ˆ1Ã—10â»Â³ï¼‰ã‚ˆã‚Šå°ã•ã„ã®ã§ã€ŒACCEPTABLEã€
# ãŸã ã—ã€UHVï¼ˆè¶…é«˜çœŸç©ºï¼‰ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã§ã¯è¦æ”¹å–„</code></pre>
            </details>
        </div>

        <div class="exercise-box">
            <h4>æ¼”ç¿’1-3: åå¿œæ€§ã‚¹ãƒ‘ãƒƒã‚¿ãƒªãƒ³ã‚°ã®ã‚¬ã‚¹åˆ¶å¾¡ï¼ˆMediumï¼‰</h4>
            <p>ITOï¼ˆIndium Tin Oxideï¼‰è–„è†œã®åå¿œæ€§ã‚¹ãƒ‘ãƒƒã‚¿ãƒªãƒ³ã‚°ã§ã€é…¸ç´ åˆ†åœ§ã‚’0.15 Paã«åˆ¶å¾¡ã—ãŸã„ã€‚å…¨åœ§1.2 Paã€ç·ã‚¬ã‚¹æµé‡250 sccmã¨ã™ã‚‹ã€‚Arã¨Oâ‚‚ã®ãƒ•ãƒ­ãƒ¼ãƒ¬ãƒ¼ãƒˆï¼ˆsccmï¼‰ã‚’è¨ˆç®—ã›ã‚ˆã€‚ã¾ãŸã€é…¸ç´ æµé‡ãŒÂ±5%å¤‰å‹•ã—ãŸå ´åˆã®é…¸ç´ åˆ†åœ§å¤‰åŒ–ã‚’è©•ä¾¡ã›ã‚ˆã€‚</p>

            <details class="solution-box">
                <summary>è§£ç­”ä¾‹</summary>
                <pre><code class="language-python"># ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
total_pressure = 1.2  # Pa
target_pO2 = 0.15     # Pa
total_flow = 250      # sccm

# é…¸ç´ ãƒ¢ãƒ«åˆ†ç‡
x_O2 = target_pO2 / total_pressure

# ãƒ•ãƒ­ãƒ¼ãƒ¬ãƒ¼ãƒˆè¨ˆç®—
flow_O2 = x_O2 * total_flow
flow_Ar = (1 - x_O2) * total_flow

print(f"ITO Reactive Sputtering Gas Control:")
print(f"  Target Oâ‚‚ Partial Pressure: {target_pO2} Pa")
print(f"  Total Pressure: {total_pressure} Pa")
print(f"  Ar Flow: {flow_Ar:.2f} sccm")
print(f"  Oâ‚‚ Flow: {flow_O2:.2f} sccm")

# é…¸ç´ æµé‡å¤‰å‹•ã®å½±éŸ¿è©•ä¾¡
flow_O2_variation = 0.05  # Â±5%
flow_O2_min = flow_O2 * (1 - flow_O2_variation)
flow_O2_max = flow_O2 * (1 + flow_O2_variation)

# å¤‰å‹•å¾Œã®åˆ†åœ§
pO2_min = (flow_O2_min / total_flow) * total_pressure
pO2_max = (flow_O2_max / total_flow) * total_pressure

print(f"\nSensitivity Analysis (Â±5% Oâ‚‚ flow variation):")
print(f"  Oâ‚‚ Flow Range: {flow_O2_min:.2f} - {flow_O2_max:.2f} sccm")
print(f"  Oâ‚‚ Partial Pressure Range: {pO2_min:.3f} - {pO2_max:.3f} Pa")
print(f"  Deviation from Target: {(pO2_max - target_pO2)/target_pO2*100:.1f}%")

# å®‰å®šæ€§è©•ä¾¡
pO2_tolerance = 0.01  # Paï¼ˆè¨±å®¹èª¤å·®ï¼‰
if abs(pO2_max - target_pO2) < pO2_tolerance and abs(pO2_min - target_pO2) < pO2_tolerance:
    print(f"\nâœ“ Gas control is STABLE (variation < {pO2_tolerance} Pa)")
else:
    print(f"\nâš  Gas control may be UNSTABLE")
    print(f"  â†’ Consider using closed-loop pO2 feedback control")

# çµæœï¼š
# Ar: 218.75 sccm, Oâ‚‚: 31.25 sccm
# Â±5% Oâ‚‚å¤‰å‹• â†’ pO2å¤‰å‹• Â±0.0075 Paï¼ˆÂ±5%ï¼‰
# MFCã®ç²¾åº¦ãŒÂ±1%ãªã‚‰ã€ååˆ†å®‰å®šã—ãŸåˆ¶å¾¡ãŒå¯èƒ½</code></pre>
            </details>
        </div>

        <div class="exercise-box">
            <h4>æ¼”ç¿’1-4: æ¸©åº¦ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«æœ€é©åŒ–ï¼ˆMediumï¼‰</h4>
            <p>Alåˆé‡‘ã®æº¶ä½“åŒ–å‡¦ç†ï¼ˆ550â„ƒã€2æ™‚é–“ä¿æŒï¼‰ã«ãŠã„ã¦ã€æ˜‡æ¸©é€Ÿåº¦ãŒé€Ÿã™ãã‚‹ã¨ç†±å¿œåŠ›ã§ã‚¯ãƒ©ãƒƒã‚¯ãŒç™ºç”Ÿã—ã€é…ã™ãã‚‹ã¨æå‡ºç‰©ãŒç²—å¤§åŒ–ã™ã‚‹ã€‚è¨±å®¹æ˜‡æ¸©é€Ÿåº¦ç¯„å›²5-15â„ƒ/minã€å†·å´é€Ÿåº¦â‰¥50â„ƒ/minã§ã€ç·ãƒ—ãƒ­ã‚»ã‚¹æ™‚é–“ãŒæœ€çŸ­ã¨ãªã‚‹æ¸©åº¦ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ã‚’è¨­è¨ˆã›ã‚ˆã€‚</p>

            <details class="solution-box">
                <summary>è§£ç­”ä¾‹</summary>
                <pre><code class="language-python"># æœ€é©åŒ–ï¼šæœ€é€Ÿæ˜‡æ¸©ã€å¿…é ˆä¿æŒã€æœ€é€Ÿå†·å´
heat_rate_max = 15    # â„ƒ/minï¼ˆæœ€é€Ÿæ˜‡æ¸©ï¼‰
hold_temp = 550       # â„ƒ
hold_time = 120       # minï¼ˆ2æ™‚é–“ï¼‰
cool_rate = 50        # â„ƒ/minï¼ˆæ€¥å†·ï¼‰

# ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«è¨­è¨ˆ
segments_optimized = [
    {'type': 'ramp', 'start': 25, 'end': hold_temp, 'rate': heat_rate_max},
    {'type': 'hold', 'temp': hold_temp, 'duration': hold_time * 60},
    {'type': 'ramp', 'start': hold_temp, 'end': 100, 'rate': cool_rate}  # 100â„ƒã¾ã§æ€¥å†·
]

time_opt, temp_opt = generate_temperature_profile(segments_optimized)

# ç·ãƒ—ãƒ­ã‚»ã‚¹æ™‚é–“
total_time_opt = time_opt[-1] / 60  # åˆ†

print(f"Optimized Temperature Profile for Al Alloy:")
print(f"  Heating Rate: {heat_rate_max} â„ƒ/min")
print(f"  Hold Temperature: {hold_temp} â„ƒ")
print(f"  Hold Time: {hold_time} min")
print(f"  Cooling Rate: {cool_rate} â„ƒ/min")
print(f"  Total Process Time: {total_time_opt:.1f} min")

# å„ãƒ•ã‚§ãƒ¼ã‚ºã®æ™‚é–“
heat_time = (hold_temp - 25) / heat_rate_max
cool_time = (hold_temp - 100) / cool_rate

print(f"\nPhase Breakdown:")
print(f"  Heating: {heat_time:.1f} min")
print(f"  Hold: {hold_time:.1f} min")
print(f"  Cooling: {cool_time:.1f} min")

# ãƒ—ãƒ­ãƒƒãƒˆ
plt.figure(figsize=(12, 6))
plt.plot(time_opt/60, temp_opt, 'b-', linewidth=2)
plt.xlabel('Time (min)')
plt.ylabel('Temperature (Â°C)')
plt.title('Optimized Solution Treatment Profile for Al Alloy')
plt.grid(True, alpha=0.3)
plt.savefig('solution_treatment_profile.png', dpi=150, bbox_inches='tight')
plt.show()

# çµæœï¼š
# ç·ãƒ—ãƒ­ã‚»ã‚¹æ™‚é–“ = 35 + 120 + 9 = 164åˆ†ï¼ˆç´„2.7æ™‚é–“ï¼‰
# æ˜‡æ¸©ã‚’æœ€é€Ÿï¼ˆ15â„ƒ/minï¼‰ã€å†·å´ã‚’æ€¥å†·ï¼ˆ50â„ƒ/minï¼‰ã«ã™ã‚‹ã“ã¨ã§
# ãƒ—ãƒ­ã‚»ã‚¹æ™‚é–“ã‚’æœ€å°åŒ–</code></pre>
            </details>
        </div>

        <div class="exercise-box">
            <h4>æ¼”ç¿’1-5: ãƒ—ãƒ­ã‚»ã‚¹ç•°å¸¸ã®æ ¹æœ¬åŸå› åˆ†æï¼ˆHardï¼‰</h4>
            <p>ã‚¹ãƒ‘ãƒƒã‚¿ãƒªãƒ³ã‚°è£…ç½®ã§è†œåšã®ç•°å¸¸å¤‰å‹•ï¼ˆç›®æ¨™å€¤Â±10%ã‚’è¶…ãˆã‚‹ï¼‰ãŒç™ºç”Ÿã—ãŸã€‚ä»¥ä¸‹ã®ãƒ—ãƒ­ã‚»ã‚¹ãƒ­ã‚°ã‹ã‚‰ã€ç•°å¸¸ã®æ ¹æœ¬åŸå› ã‚’ç‰¹å®šã—ã€å¯¾ç­–ã‚’ææ¡ˆã›ã‚ˆï¼š</p>
            <ul>
                <li>æ¸©åº¦ï¼š800Â±3â„ƒï¼ˆæ­£å¸¸ç¯„å›²å†…ï¼‰</li>
                <li>åœ§åŠ›ï¼š0.8-1.5 Paï¼ˆå¤‰å‹•å¤§ã€ç›®æ¨™1.0 Paï¼‰</li>
                <li>Arãƒ•ãƒ­ãƒ¼ï¼š98-102 sccmï¼ˆæ­£å¸¸ç¯„å›²å†…ï¼‰</li>
                <li>RFé›»åŠ›ï¼šå¤‰å‹•ãªã—ï¼ˆ300 Wå›ºå®šï¼‰</li>
            </ul>

            <details class="solution-box">
                <summary>è§£ç­”ä¾‹</summary>
                <pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt

# ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆï¼ˆåœ§åŠ›å¤‰å‹•ã‚ã‚Šï¼‰
np.random.seed(42)
time = np.arange(0, 300, 1)
temperature = 800 + np.random.normal(0, 1.5, len(time))
pressure = 1.0 + 0.3 * np.sin(2*np.pi*time/50) + np.random.normal(0, 0.05, len(time))
ar_flow = 100 + np.random.normal(0, 1.0, len(time))
rf_power = 300 * np.ones(len(time))

# è†œåšã¯åœ§åŠ›ã«åæ¯”ä¾‹ï¼ˆã‚¹ãƒ‘ãƒƒã‚¿ãƒªãƒ³ã‚°åç‡ã¸ã®å½±éŸ¿ï¼‰
film_thickness = 500 / pressure  # nmï¼ˆç°¡æ˜“ãƒ¢ãƒ‡ãƒ«ï¼‰

# å¯è¦–åŒ–
fig, axes = plt.subplots(3, 1, figsize=(12, 10))

# åœ§åŠ›å¤‰å‹•
axes[0].plot(time, pressure, 'r-', linewidth=1.5)
axes[0].axhline(y=1.0, color='k', linestyle='--', label='Target')
axes[0].fill_between(time, 0.9, 1.1, alpha=0.2, color='green', label='Tolerance')
axes[0].set_ylabel('Pressure (Pa)')
axes[0].set_title('Process Parameter Monitoring')
axes[0].legend()
axes[0].grid(True, alpha=0.3)

# è†œåšå¤‰å‹•
axes[1].plot(time, film_thickness, 'b-', linewidth=1.5)
axes[1].axhline(y=500, color='k', linestyle='--', label='Target')
axes[1].fill_between(time, 450, 550, alpha=0.2, color='green', label='Tolerance (Â±10%)')
axes[1].set_ylabel('Film Thickness (nm)')
axes[1].legend()
axes[1].grid(True, alpha=0.3)

# ç›¸é–¢åˆ†æ
axes[2].scatter(pressure, film_thickness, alpha=0.5)
axes[2].set_xlabel('Pressure (Pa)')
axes[2].set_ylabel('Film Thickness (nm)')
axes[2].set_title('Correlation: Pressure vs Film Thickness')
axes[2].grid(True, alpha=0.3)

# å›å¸°ç›´ç·š
from scipy.stats import linregress
slope, intercept, r_value, p_value, std_err = linregress(pressure, film_thickness)
pressure_fit = np.linspace(pressure.min(), pressure.max(), 100)
thickness_fit = slope * pressure_fit + intercept
axes[2].plot(pressure_fit, thickness_fit, 'r-', linewidth=2,
             label=f'Fit: RÂ²={r_value**2:.3f}')
axes[2].legend()

plt.tight_layout()
plt.savefig('root_cause_analysis.png', dpi=150, bbox_inches='tight')
plt.show()

# çµ±è¨ˆåˆ†æ
pressure_std = np.std(pressure)
thickness_std = np.std(film_thickness)
thickness_cv = thickness_std / np.mean(film_thickness) * 100

print(f"Root Cause Analysis:")
print(f"  Pressure Std Dev: {pressure_std:.3f} Pa")
print(f"  Film Thickness CV: {thickness_cv:.2f}%")
print(f"  Correlation (RÂ²): {r_value**2:.3f}")

print(f"\nConclusion:")
print(f"  âœ— Primary cause: PRESSURE INSTABILITY")
print(f"  â†’ Pressure variation (Â±30%) causes thickness variation (Â±15%)")
print(f"  â†’ Exceeds tolerance (Â±10%)")

print(f"\nRecommended Actions:")
print(f"  1. Check MFC (Mass Flow Controller) calibration")
print(f"  2. Inspect vacuum pump performance (oil level, belt tension)")
print(f"  3. Verify APC (Automatic Pressure Controller) PID tuning")
print(f"  4. Check for micro-leaks (leak rate test)")
print(f"  5. Implement closed-loop pressure feedback control")

# çµæœè§£é‡ˆï¼š
# - åœ§åŠ›å¤‰å‹•ï¼ˆ0.8-1.5 Paã€Â±50%ï¼‰ãŒè†œåšå¤‰å‹•ã®ä¸»å› 
# - æ¸©åº¦ãƒ»ãƒ•ãƒ­ãƒ¼ã¯å®‰å®š â†’ ãƒ’ãƒ¼ã‚¿ãƒ¼ãƒ»MFCã¯æ­£å¸¸
# - å¯¾ç­–ï¼šAPCã®PIDå†èª¿æ•´ã€ã¾ãŸã¯ã‚¿ãƒ¼ãƒœãƒãƒ³ãƒ—ã®ãƒ¡ãƒ³ãƒ†ãƒŠãƒ³ã‚¹</code></pre>
            </details>
        </div>

        <div class="exercise-box">
            <h4>æ¼”ç¿’1-6: å¤šå¤‰æ•°æœ€é©åŒ–å•é¡Œï¼ˆHardï¼‰</h4>
            <p>CVDãƒ—ãƒ­ã‚»ã‚¹ã§ã€æˆè†œé€Ÿåº¦ï¼ˆæœ€å¤§åŒ–ï¼‰ã¨è†œè³ªï¼ˆãƒ”ãƒ³ãƒ›ãƒ¼ãƒ«å¯†åº¦æœ€å°åŒ–ï¼‰ã‚’åŒæ™‚æœ€é©åŒ–ã—ãŸã„ã€‚ç›®çš„é–¢æ•°ï¼š$F = w_1 \cdot R - w_2 \cdot D$ï¼ˆ$R$: æˆè†œé€Ÿåº¦ nm/minã€$D$: ãƒ”ãƒ³ãƒ›ãƒ¼ãƒ«å¯†åº¦ å€‹/cmÂ²ï¼‰ã€‚åˆ¶ç´„æ¡ä»¶ï¼šæ¸©åº¦500-700â„ƒã€åœ§åŠ›10-100 Paã€ã‚¬ã‚¹æµé‡50-200 sccmã€‚Pythonã§æœ€é©ãƒ—ãƒ­ã‚»ã‚¹æ¡ä»¶ã‚’æ±‚ã‚ã‚ˆã€‚</p>

            <details class="solution-box">
                <summary>è§£ç­”ä¾‹</summary>
                <pre><code class="language-python">from scipy.optimize import differential_evolution
import numpy as np

def cvd_process_model(params):
    """
    CVDãƒ—ãƒ­ã‚»ã‚¹ã®ç°¡æ˜“ãƒ¢ãƒ‡ãƒ«

    Parameters
    ----------
    params : tuple
        (temperature, pressure, flow_rate)

    Returns
    -------
    deposition_rate, pinhole_density : float
        æˆè†œé€Ÿåº¦ï¼ˆnm/minï¼‰ã€ãƒ”ãƒ³ãƒ›ãƒ¼ãƒ«å¯†åº¦ï¼ˆå€‹/cmÂ²ï¼‰
    """
    temp, pressure, flow = params

    # æˆè†œé€Ÿåº¦ãƒ¢ãƒ‡ãƒ«ï¼ˆArrheniuså‹ + åœ§åŠ›ä¾å­˜ï¼‰
    # R = A * exp(-Ea/RT) * P^0.5 * flow^0.3
    A = 1e6
    Ea = 50000  # J/mol
    R_gas = 8.314

    deposition_rate = A * np.exp(-Ea/(R_gas * (temp + 273))) * \
                      np.sqrt(pressure) * (flow ** 0.3)

    # ãƒ”ãƒ³ãƒ›ãƒ¼ãƒ«å¯†åº¦ãƒ¢ãƒ‡ãƒ«ï¼ˆä½æ¸©ãƒ»é«˜åœ§ã§å¢—åŠ ï¼‰
    # D = D0 * exp(-T/T0) * (P/P0)^2
    D0 = 100
    T0 = 500
    P0 = 50

    pinhole_density = D0 * np.exp(-(temp-500)/T0) * (pressure/P0)**2

    return deposition_rate, pinhole_density


def objective_function(params, w1=1.0, w2=10.0):
    """
    æœ€é©åŒ–ç›®çš„é–¢æ•°ï¼ˆæœ€å¤§åŒ–ï¼‰

    F = w1 * R - w2 * D

    Returns
    -------
    -F : float
        è² ã®ç›®çš„é–¢æ•°å€¤ï¼ˆæœ€å°åŒ–å•é¡Œã«å¤‰æ›ï¼‰
    """
    deposition_rate, pinhole_density = cvd_process_model(params)

    F = w1 * deposition_rate - w2 * pinhole_density

    return -F  # æœ€å°åŒ–å•é¡Œã«å¤‰æ›


# æœ€é©åŒ–å®Ÿè¡Œ
bounds = [
    (500, 700),   # Temperature (â„ƒ)
    (10, 100),    # Pressure (Pa)
    (50, 200)     # Flow rate (sccm)
]

result = differential_evolution(
    objective_function,
    bounds,
    args=(1.0, 10.0),  # w1, w2
    maxiter=100,
    seed=42,
    disp=True
)

temp_opt, pressure_opt, flow_opt = result.x
rate_opt, density_opt = cvd_process_model(result.x)

print(f"Multi-Objective Optimization Results:")
print(f"  Optimal Temperature: {temp_opt:.1f} Â°C")
print(f"  Optimal Pressure: {pressure_opt:.1f} Pa")
print(f"  Optimal Flow Rate: {flow_opt:.1f} sccm")
print(f"\nPerformance:")
print(f"  Deposition Rate: {rate_opt:.2f} nm/min")
print(f"  Pinhole Density: {density_opt:.2f} /cmÂ²")
print(f"  Objective Function F: {-result.fun:.2f}")

# ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚¹ã‚¤ãƒ¼ãƒ—ï¼ˆå¯è¦–åŒ–ï¼‰
temps = np.linspace(500, 700, 50)
rates = []
densities = []

for temp in temps:
    rate, density = cvd_process_model((temp, pressure_opt, flow_opt))
    rates.append(rate)
    densities.append(density)

fig, ax1 = plt.subplots(figsize=(10, 6))

color = 'tab:blue'
ax1.set_xlabel('Temperature (Â°C)')
ax1.set_ylabel('Deposition Rate (nm/min)', color=color)
ax1.plot(temps, rates, color=color, linewidth=2)
ax1.tick_params(axis='y', labelcolor=color)
ax1.axvline(x=temp_opt, color='k', linestyle='--', alpha=0.5)

ax2 = ax1.twinx()
color = 'tab:red'
ax2.set_ylabel('Pinhole Density (/cmÂ²)', color=color)
ax2.plot(temps, densities, color=color, linewidth=2)
ax2.tick_params(axis='y', labelcolor=color)

plt.title('CVD Process Multi-Objective Optimization')
fig.tight_layout()
plt.savefig('cvd_optimization.png', dpi=150, bbox_inches='tight')
plt.show()

# çµæœè§£é‡ˆï¼š
# - æœ€é©æ¸©åº¦ã¯ç´„650â„ƒï¼ˆé«˜ã™ãã‚‹ã¨æˆè†œé€Ÿåº¦â†‘ã ãŒãƒ”ãƒ³ãƒ›ãƒ¼ãƒ«â†“ã€ãƒˆãƒ¬ãƒ¼ãƒ‰ã‚ªãƒ•ï¼‰
# - é‡ã¿ w2 ã‚’å¤§ããã™ã‚‹ã¨ã€è†œè³ªï¼ˆãƒ”ãƒ³ãƒ›ãƒ¼ãƒ«ä½æ¸›ï¼‰ã‚’é‡è¦–
# - å®Ÿãƒ—ãƒ­ã‚»ã‚¹ã§ã¯ã€ã•ã‚‰ã«è†œåšå‡ä¸€æ€§ã€ä»˜ç€æ€§ã‚‚è€ƒæ…®ãŒå¿…è¦</code></pre>
            </details>
        </div>

        <div class="exercise-box">
            <h4>æ¼”ç¿’1-7: ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯åˆ¶å¾¡ã‚·ã‚¹ãƒ†ãƒ è¨­è¨ˆï¼ˆHardï¼‰</h4>
            <p>é…¸åŒ–é›°å›²æ°—ã§ã®ã‚¢ãƒ‹ãƒ¼ãƒªãƒ³ã‚°ãƒ—ãƒ­ã‚»ã‚¹ã«ãŠã„ã¦ã€é…¸ç´ åˆ†åœ§ã‚’ç›®æ¨™å€¤ï¼ˆ0.1 Paï¼‰ã«ç¶­æŒã™ã‚‹PIDåˆ¶å¾¡ã‚·ã‚¹ãƒ†ãƒ ã‚’è¨­è¨ˆã›ã‚ˆã€‚ã‚»ãƒ³ã‚µãƒ¼ï¼ˆé…¸ç´ åˆ†åœ§è¨ˆï¼‰ã®æ¸¬å®šé…å»¶10ç§’ã€MFCã®å¿œç­”æ™‚é–“5ç§’ã‚’è€ƒæ…®ã—ã€å®‰å®šã—ãŸåˆ¶å¾¡ãŒå¯èƒ½ãªPIDã‚²ã‚¤ãƒ³ã‚’æ±ºå®šã›ã‚ˆã€‚</p>

            <details class="solution-box">
                <summary>è§£ç­”ä¾‹</summary>
                <pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt

class OxygenPartialPressureController:
    """
    é…¸ç´ åˆ†åœ§ã®PIDãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯åˆ¶å¾¡

    æ¸¬å®šé…å»¶ã¨MFCå¿œç­”æ™‚é–“ã‚’è€ƒæ…®
    """

    def __init__(self, Kp, Ki, Kd, setpoint, dt=1.0,
                 sensor_delay=10, mfc_response_time=5):
        """
        Parameters
        ----------
        sensor_delay : float
            ã‚»ãƒ³ã‚µãƒ¼æ¸¬å®šé…å»¶ï¼ˆç§’ï¼‰
        mfc_response_time : float
            MFCå¿œç­”æ™‚é–“ï¼ˆç§’ï¼‰
        """
        self.Kp = Kp
        self.Ki = Ki
        self.Kd = Kd
        self.setpoint = setpoint
        self.dt = dt

        self.sensor_delay_steps = int(sensor_delay / dt)
        self.mfc_tau = mfc_response_time

        self.integral = 0.0
        self.prev_error = 0.0
        self.measurement_buffer = []
        self.mfc_output = 0.0

    def update(self, actual_pO2):
        """
        åˆ¶å¾¡å‡ºåŠ›ã®æ›´æ–°

        Returns
        -------
        mfc_flow : float
            MFCã¸ã®æŒ‡ä»¤æµé‡ï¼ˆsccmï¼‰
        """
        # ã‚»ãƒ³ã‚µãƒ¼é…å»¶ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
        self.measurement_buffer.append(actual_pO2)
        if len(self.measurement_buffer) > self.sensor_delay_steps:
            measured_pO2 = self.measurement_buffer.pop(0)
        else:
            measured_pO2 = self.measurement_buffer[0]

        # PIDæ¼”ç®—
        error = self.setpoint - measured_pO2

        self.integral += error * self.dt
        derivative = (error - self.prev_error) / self.dt

        pid_output = self.Kp * error + self.Ki * self.integral + self.Kd * derivative

        # MFCå¿œç­”ï¼ˆ1æ¬¡é…ã‚Œï¼‰
        self.mfc_output += (pid_output - self.mfc_output) / self.mfc_tau * self.dt

        self.prev_error = error

        return self.mfc_output


def simulate_oxygen_pressure_control(Kp, Ki, Kd, duration=300):
    """
    é…¸ç´ åˆ†åœ§åˆ¶å¾¡ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
    """
    dt = 1.0
    n_steps = int(duration / dt)

    # ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼åˆæœŸåŒ–
    controller = OxygenPartialPressureController(
        Kp, Ki, Kd, setpoint=0.1, dt=dt,
        sensor_delay=10, mfc_response_time=5
    )

    # åˆæœŸåŒ–
    time = np.arange(0, duration, dt)
    pO2 = np.zeros(n_steps)
    mfc_flow = np.zeros(n_steps)
    pO2[0] = 0.05  # åˆæœŸå€¤

    # ãƒ—ãƒ­ã‚»ã‚¹ãƒ¢ãƒ‡ãƒ«ï¼ˆç°¡æ˜“ï¼‰
    # dpO2/dt = k1 * mfc_flow - k2 * pO2
    k1 = 0.002  # ä¾›çµ¦ä¿‚æ•°
    k2 = 0.01   # æ¶ˆè²»/ãƒªãƒ¼ã‚¯ä¿‚æ•°

    for i in range(1, n_steps):
        # åˆ¶å¾¡å‡ºåŠ›
        mfc_flow[i] = controller.update(pO2[i-1])
        mfc_flow[i] = np.clip(mfc_flow[i], 0, 50)  # 0-50 sccm

        # ãƒ—ãƒ­ã‚»ã‚¹ãƒ€ã‚¤ãƒŠãƒŸã‚¯ã‚¹
        dpO2 = (k1 * mfc_flow[i] - k2 * pO2[i-1]) * dt
        pO2[i] = pO2[i-1] + dpO2

    return time, pO2, mfc_flow


# æœ€é©PIDã‚²ã‚¤ãƒ³ã®æ¢ç´¢
pid_candidates = [
    {'name': 'Conservative', 'Kp': 50, 'Ki': 2, 'Kd': 5},
    {'name': 'Moderate', 'Kp': 100, 'Ki': 5, 'Kd': 10},
    {'name': 'Aggressive', 'Kp': 200, 'Ki': 10, 'Kd': 20}
]

plt.figure(figsize=(14, 10))

for idx, pid in enumerate(pid_candidates):
    time, pO2, mfc_flow = simulate_oxygen_pressure_control(
        pid['Kp'], pid['Ki'], pid['Kd']
    )

    plt.subplot(2, 1, 1)
    plt.plot(time, pO2, linewidth=2, label=pid['name'])

    plt.subplot(2, 1, 2)
    plt.plot(time, mfc_flow, linewidth=2, label=pid['name'])

    # æ€§èƒ½è©•ä¾¡
    settling_idx = np.where(np.abs(pO2 - 0.1) < 0.005)[0]
    settling_time = time[settling_idx[0]] if len(settling_idx) > 0 else np.inf
    overshoot = max(0, np.max(pO2) - 0.1)

    print(f"{pid['name']} PID:")
    print(f"  Kp={pid['Kp']}, Ki={pid['Ki']}, Kd={pid['Kd']}")
    print(f"  Settling Time: {settling_time:.1f} s")
    print(f"  Overshoot: {overshoot:.4f} Pa\n")

plt.subplot(2, 1, 1)
plt.axhline(y=0.1, color='k', linestyle='--', label='Setpoint')
plt.ylabel('Oâ‚‚ Partial Pressure (Pa)')
plt.title('Oxygen Pressure Control with Measurement Delay')
plt.legend()
plt.grid(True, alpha=0.3)

plt.subplot(2, 1, 2)
plt.xlabel('Time (s)')
plt.ylabel('MFC Flow (sccm)')
plt.title('MFC Control Output')
plt.legend()
plt.grid(True, alpha=0.3)

plt.tight_layout()
plt.savefig('oxygen_pressure_control.png', dpi=150, bbox_inches='tight')
plt.show()

print(f"Recommendation:")
print(f"  Choose 'Moderate' PID for balance between speed and stability")
print(f"  Measurement delay requires careful tuning to avoid oscillation")</code></pre>
            </details>
        </div>

        <div class="exercise-box">
            <h4>æ¼”ç¿’1-8: ãƒ—ãƒ­ã‚»ã‚¹ãƒ‡ã‚¸ã‚¿ãƒ«ãƒ„ã‚¤ãƒ³æ§‹ç¯‰ï¼ˆHardï¼‰</h4>
            <p>æ¸©åº¦åˆ¶å¾¡ã‚·ã‚¹ãƒ†ãƒ ã®<strong>ãƒ‡ã‚¸ã‚¿ãƒ«ãƒ„ã‚¤ãƒ³</strong>ï¼ˆå®Ÿãƒ—ãƒ­ã‚»ã‚¹ã‚’æ¨¡å€£ã™ã‚‹ä»®æƒ³ãƒ¢ãƒ‡ãƒ«ï¼‰ã‚’æ§‹ç¯‰ã›ã‚ˆã€‚å®Ÿæ¸¬ãƒ‡ãƒ¼ã‚¿ï¼ˆæ¸©åº¦ã€ãƒ’ãƒ¼ã‚¿ãƒ¼å‡ºåŠ›ï¼‰ã‹ã‚‰ã‚·ã‚¹ãƒ†ãƒ åŒå®šã‚’è¡Œã„ã€äºˆæ¸¬ç²¾åº¦Â±2â„ƒä»¥å†…ã‚’é”æˆã›ã‚ˆã€‚ãƒ¢ãƒ‡ãƒ«ãƒ™ãƒ¼ã‚¹åˆ¶å¾¡ï¼ˆMPCï¼‰ã¸ã®å¿œç”¨ã‚‚æ¤œè¨ã›ã‚ˆã€‚</p>

            <details class="solution-box">
                <summary>è§£ç­”ä¾‹</summary>
                <pre><code class="language-python">import numpy as np
from scipy.optimize import curve_fit
import matplotlib.pyplot as plt

# å®Ÿæ¸¬ãƒ‡ãƒ¼ã‚¿ã®ç”Ÿæˆï¼ˆç°¡æ˜“ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰
np.random.seed(42)
time_real = np.arange(0, 200, 1)
heater_real = 50 + 30 * (1 - np.exp(-time_real/30))  # ã‚¹ãƒ†ãƒƒãƒ—å¿œç­”
temp_real = 25 + 300 * (1 - np.exp(-time_real/40)) + np.random.normal(0, 2, len(time_real))

def first_order_model(t, K, tau, delay):
    """
    1æ¬¡é…ã‚Œ+ã‚€ã æ™‚é–“ãƒ¢ãƒ‡ãƒ«

    Parameters
    ----------
    K : float
        ã‚²ã‚¤ãƒ³
    tau : float
        æ™‚å®šæ•°ï¼ˆç§’ï¼‰
    delay : float
        ã‚€ã æ™‚é–“ï¼ˆç§’ï¼‰
    """
    response = np.zeros_like(t)
    for i, ti in enumerate(t):
        if ti > delay:
            response[i] = K * (1 - np.exp(-(ti - delay) / tau))
    return response + 25  # ã‚ªãƒ•ã‚»ãƒƒãƒˆ

# ã‚·ã‚¹ãƒ†ãƒ åŒå®šï¼ˆã‚«ãƒ¼ãƒ–ãƒ•ã‚£ãƒƒãƒ†ã‚£ãƒ³ã‚°ï¼‰
popt, pcov = curve_fit(
    lambda t, K, tau, delay: first_order_model(t, K, tau, delay),
    time_real,
    temp_real,
    p0=[300, 40, 0],
    bounds=([100, 10, 0], [500, 100, 10])
)

K_id, tau_id, delay_id = popt
print(f"System Identification Results:")
print(f"  Gain K: {K_id:.2f}")
print(f"  Time Constant Ï„: {tau_id:.2f} s")
print(f"  Delay: {delay_id:.2f} s")

# ãƒ‡ã‚¸ã‚¿ãƒ«ãƒ„ã‚¤ãƒ³ãƒ¢ãƒ‡ãƒ«ã«ã‚ˆã‚‹äºˆæ¸¬
temp_model = first_order_model(time_real, K_id, tau_id, delay_id)

# äºˆæ¸¬èª¤å·®è©•ä¾¡
prediction_error = temp_real - temp_model
rmse = np.sqrt(np.mean(prediction_error**2))
max_error = np.max(np.abs(prediction_error))

print(f"\nModel Accuracy:")
print(f"  RMSE: {rmse:.2f} Â°C")
print(f"  Max Error: {max_error:.2f} Â°C")

if max_error < 2.0:
    print(f"  âœ“ Accuracy target (Â±2Â°C) ACHIEVED")
else:
    print(f"  âœ— Accuracy target (Â±2Â°C) NOT MET")
    print(f"  â†’ Consider higher-order model or nonlinear effects")

# å¯è¦–åŒ–
fig, axes = plt.subplots(2, 1, figsize=(12, 10))

# æ¸©åº¦æ¯”è¼ƒ
axes[0].plot(time_real, temp_real, 'b-', linewidth=2, label='Real Process', alpha=0.7)
axes[0].plot(time_real, temp_model, 'r--', linewidth=2, label='Digital Twin')
axes[0].set_ylabel('Temperature (Â°C)')
axes[0].set_title('Digital Twin: Real vs Model')
axes[0].legend()
axes[0].grid(True, alpha=0.3)

# äºˆæ¸¬èª¤å·®
axes[1].plot(time_real, prediction_error, 'g-', linewidth=1.5)
axes[1].axhline(y=2, color='r', linestyle='--', label='Target Â±2Â°C')
axes[1].axhline(y=-2, color='r', linestyle='--')
axes[1].fill_between(time_real, -2, 2, alpha=0.2, color='green')
axes[1].set_xlabel('Time (s)')
axes[1].set_ylabel('Prediction Error (Â°C)')
axes[1].set_title('Model Prediction Error')
axes[1].legend()
axes[1].grid(True, alpha=0.3)

plt.tight_layout()
plt.savefig('digital_twin.png', dpi=150, bbox_inches='tight')
plt.show()

# MPCï¼ˆModel Predictive Controlï¼‰ã¸ã®å¿œç”¨ã‚³ãƒ³ã‚»ãƒ—ãƒˆ
print(f"\nMPC Application Concept:")
print(f"  1. Use digital twin to predict future temperature trajectory")
print(f"  2. Optimize heater input sequence over prediction horizon (e.g., 60s)")
print(f"  3. Apply first control action, then re-optimize at next timestep")
print(f"  4. Benefits: Handles constraints, anticipates disturbances")

# çµæœï¼š
# RMSEãŒ2â„ƒæœªæº€ãªã‚‰ã€ãƒ‡ã‚¸ã‚¿ãƒ«ãƒ„ã‚¤ãƒ³ã¯ååˆ†ãªç²¾åº¦
# MPCã§ã¯ã€ã“ã®ãƒ¢ãƒ‡ãƒ«ã‚’ä½¿ã£ã¦æœ€é©åˆ¶å¾¡å…¥åŠ›ã‚’è¨ˆç®—
# å®Ÿè£…ã«ã¯ scipy.optimize.minimize ã‚„å°‚ç”¨MPCãƒ©ã‚¤ãƒ–ãƒ©ãƒªï¼ˆdo-mpcï¼‰ã‚’ä½¿ç”¨</code></pre>
            </details>
        </div>

        <h2>å­¦ç¿’é”æˆåº¦ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ</h2>

        <h3>åŸºæœ¬ç†è§£ãƒ¬ãƒ™ãƒ«</h3>
        <ul>
            <li>â˜ PIDåˆ¶å¾¡ã®3ã¤ã®è¦ç´ ï¼ˆPã€Iã€Dï¼‰ã®å½¹å‰²ã‚’èª¬æ˜ã§ãã‚‹</li>
            <li>â˜ ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯åˆ¶å¾¡ã®åŸºæœ¬æ§‹æˆã‚’ç†è§£ã—ã¦ã„ã‚‹</li>
            <li>â˜ æ¸©åº¦ãƒ©ãƒ³ãƒ—ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ã®è¨­è¨ˆãŒã§ãã‚‹</li>
            <li>â˜ çœŸç©ºãƒãƒ³ãƒ—ãƒ€ã‚¦ãƒ³æ–¹ç¨‹å¼ã‚’ä½¿ãˆã‚‹</li>
            <li>â˜ Daltonã®æ³•å‰‡ã§åˆ†åœ§è¨ˆç®—ãŒã§ãã‚‹</li>
        </ul>

        <h3>å®Ÿè·µã‚¹ã‚­ãƒ«ãƒ¬ãƒ™ãƒ«</h3>
        <ul>
            <li>â˜ Pythonã§PIDã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã‚’å®Ÿè£…ã—ã€ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿èª¿æ•´ãŒã§ãã‚‹</li>
            <li>â˜ å¤šæ®µéšæ¸©åº¦ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç”Ÿæˆã—ã€ãƒ—ãƒ­ãƒƒãƒˆã§ãã‚‹</li>
            <li>â˜ çœŸç©ºç³»ã®åˆ°é”æ™‚é–“ã¨ãƒªãƒ¼ã‚¯ãƒ¬ãƒ¼ãƒˆã‚’è¨ˆç®—ã§ãã‚‹</li>
            <li>â˜ ã‚¬ã‚¹æ··åˆæ¯”ã‹ã‚‰åˆ†åœ§ã‚’è¨ˆç®—ã—ã€MFCè¨­å®šå€¤ã‚’æ±ºå®šã§ãã‚‹</li>
            <li>â˜ ãƒ—ãƒ­ã‚»ã‚¹ãƒ‡ãƒ¼ã‚¿ã‚’ãƒ­ã‚°ã—ã€ç•°å¸¸æ¤œçŸ¥ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚’å®Ÿè£…ã§ãã‚‹</li>
        </ul>

        <h3>å¿œç”¨åŠ›ãƒ¬ãƒ™ãƒ«</h3>
        <ul>
            <li>â˜ PIDã‚²ã‚¤ãƒ³ã®è‡ªå‹•æœ€é©åŒ–ï¼ˆå·®åˆ†é€²åŒ–ãªã©ï¼‰ãŒã§ãã‚‹</li>
            <li>â˜ æ¸¬å®šé…å»¶ã‚’è€ƒæ…®ã—ãŸãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯åˆ¶å¾¡ç³»ã‚’è¨­è¨ˆã§ãã‚‹</li>
            <li>â˜ ãƒ—ãƒ­ã‚»ã‚¹ç•°å¸¸ã®æ ¹æœ¬åŸå› åˆ†æï¼ˆç›¸é–¢è§£æã€çµ±è¨ˆæ¤œå®šï¼‰ãŒã§ãã‚‹</li>
            <li>â˜ å¤šç›®çš„æœ€é©åŒ–å•é¡Œï¼ˆæˆè†œé€Ÿåº¦ vs è†œè³ªï¼‰ã‚’è§£ã‘ã‚‹</li>
            <li>â˜ ãƒ‡ã‚¸ã‚¿ãƒ«ãƒ„ã‚¤ãƒ³ï¼ˆã‚·ã‚¹ãƒ†ãƒ åŒå®šã€äºˆæ¸¬ãƒ¢ãƒ‡ãƒ«ï¼‰ã‚’æ§‹ç¯‰ã§ãã‚‹</li>
            <li>â˜ ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ã‚’è¨­è¨ˆã—ã€ãƒ—ãƒ­ã‚»ã‚¹ç›£è¦–ã‚·ã‚¹ãƒ†ãƒ ã‚’ææ¡ˆã§ãã‚‹</li>
        </ul>

        <h2>å‚è€ƒæ–‡çŒ®</h2>
        <ol>
            <li>Ã…strÃ¶m, K.J., HÃ¤gglund, T. (2006). <em>Advanced PID Control</em>. ISA - The Instrumentation, Systems, and Automation Society, pp. 45-78, 123-145.</li>
            <li>Ogata, K. (2010). <em>Modern Control Engineering</em> (5th ed.). Prentice Hall, pp. 156-189, 234-267.</li>
            <li>Bunshah, R.F. (Ed.). (2001). <em>Handbook of Deposition Technologies for Films and Coatings: Science, Applications and Technology</em> (3rd ed.). Elsevier, pp. 120-156, 201-245.</li>
            <li>O'Hanlon, J.F. (2003). <em>A User's Guide to Vacuum Technology</em> (3rd ed.). Wiley-Interscience, pp. 234-267, 345-378.</li>
            <li>Seborg, D.E., Edgar, T.F., Mellichamp, D.A., Doyle III, F.J. (2016). <em>Process Dynamics and Control</em> (4th ed.). Wiley, pp. 89-124, 267-302.</li>
            <li>Python control systems library: <code>scipy.signal</code>, <code>control</code> package. Documentation: https://python-control.readthedocs.io</li>
            <li>Glover, A.R., Smith, D.L. (2015). "Real-time process monitoring in semiconductor manufacturing," <em>Journal of Vacuum Science & Technology A</em>, 33(4), 041501. DOI: 10.1116/1.4916239, pp. 1-12.</li>
        </ol>

        <div class="navigation">
            <a href="index.html" class="nav-button">â† ç›®æ¬¡ã«æˆ»ã‚‹</a>
            <a href="chapter-2.html" class="nav-button">ç¬¬2ç« ï¼šç†±å‡¦ç†ãƒ—ãƒ­ã‚»ã‚¹ â†’</a>
        </div>
    </main>

    <section class="disclaimer">
        <h3>å…è²¬äº‹é …</h3>
        <ul>
            <li>æœ¬ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã¯æ•™è‚²ãƒ»ç ”ç©¶ãƒ»æƒ…å ±æä¾›ã®ã¿ã‚’ç›®çš„ã¨ã—ã¦ãŠã‚Šã€å°‚é–€çš„ãªåŠ©è¨€ï¼ˆæ³•å¾‹ãƒ»ä¼šè¨ˆãƒ»æŠ€è¡“çš„ä¿è¨¼ãªã©ï¼‰ã‚’æä¾›ã™ã‚‹ã‚‚ã®ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚</li>
            <li>æœ¬ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãŠã‚ˆã³ä»˜éšã™ã‚‹ã‚³ãƒ¼ãƒ‰ä¾‹ã¯ã€Œç¾çŠ¶æœ‰å§¿ï¼ˆAS ISï¼‰ã€ã§æä¾›ã•ã‚Œã€æ˜ç¤ºã¾ãŸã¯é»™ç¤ºã‚’å•ã‚ãšã€å•†å“æ€§ã€ç‰¹å®šç›®çš„é©åˆæ€§ã€æ¨©åˆ©éä¾µå®³ã€æ­£ç¢ºæ€§ãƒ»å®Œå…¨æ€§ã€å‹•ä½œãƒ»å®‰å…¨æ€§ç­‰ã„ã‹ãªã‚‹ä¿è¨¼ã‚‚ã—ã¾ã›ã‚“ã€‚</li>
            <li>å¤–éƒ¨ãƒªãƒ³ã‚¯ã€ç¬¬ä¸‰è€…ãŒæä¾›ã™ã‚‹ãƒ‡ãƒ¼ã‚¿ãƒ»ãƒ„ãƒ¼ãƒ«ãƒ»ãƒ©ã‚¤ãƒ–ãƒ©ãƒªç­‰ã®å†…å®¹ãƒ»å¯ç”¨æ€§ãƒ»å®‰å…¨æ€§ã«ã¤ã„ã¦ã€ä½œæˆè€…ãŠã‚ˆã³æ±åŒ—å¤§å­¦ã¯ä¸€åˆ‡ã®è²¬ä»»ã‚’è² ã„ã¾ã›ã‚“ã€‚</li>
            <li>æœ¬ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®åˆ©ç”¨ãƒ»å®Ÿè¡Œãƒ»è§£é‡ˆã«ã‚ˆã‚Šç›´æ¥çš„ãƒ»é–“æ¥çš„ãƒ»ä»˜éšçš„ãƒ»ç‰¹åˆ¥ãƒ»çµæœçš„ãƒ»æ‡²ç½°çš„æå®³ãŒç”Ÿã˜ãŸå ´åˆã§ã‚‚ã€é©ç”¨æ³•ã§è¨±å®¹ã•ã‚Œã‚‹æœ€å¤§é™ã®ç¯„å›²ã§ã€ä½œæˆè€…ãŠã‚ˆã³æ±åŒ—å¤§å­¦ã¯è²¬ä»»ã‚’è² ã„ã¾ã›ã‚“ã€‚</li>
            <li>æœ¬ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®å†…å®¹ã¯ã€äºˆå‘Šãªãå¤‰æ›´ãƒ»æ›´æ–°ãƒ»æä¾›åœæ­¢ã•ã‚Œã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚</li>
            <li>æœ¬ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®è‘—ä½œæ¨©ãƒ»ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã¯æ˜è¨˜ã•ã‚ŒãŸæ¡ä»¶ï¼ˆä¾‹: CC BY 4.0ï¼‰ã«å¾“ã„ã¾ã™ã€‚å½“è©²ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã¯é€šå¸¸ã€ç„¡ä¿è¨¼æ¡é …ã‚’å«ã¿ã¾ã™ã€‚</li>
        </ul>
    </section>

    <footer>
        <p><strong>ä½œæˆè€…</strong>: MS Knowledge Hub Content Team</p>
        <p><strong>ãƒãƒ¼ã‚¸ãƒ§ãƒ³</strong>: 1.0 | <strong>ä½œæˆæ—¥</strong>: 2025-10-28</p>
        <p><strong>ãƒ©ã‚¤ã‚»ãƒ³ã‚¹</strong>: Creative Commons BY 4.0</p>
        <p>&copy; 2025 MS Terakoya. All rights reserved.</p>
    </footer>
</body>
</html>