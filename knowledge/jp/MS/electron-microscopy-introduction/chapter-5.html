<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
<meta content="ç¬¬5ç« ï¼šEDSãƒ»EELSãƒ»EBSDåˆ†æå®Ÿè·µ - MS Terakoya. HyperSpyã®åŸºæœ¬æ“ä½œï¼ˆãƒ‡ãƒ¼ã‚¿èª­è¾¼ã€å¯è¦–åŒ–ã€å‰å‡¦ç†ï¼‰ãŒã§ãã‚‹" name="description"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç¬¬5ç« ï¼šEDSãƒ»EELSãƒ»EBSDåˆ†æå®Ÿè·µ - MS Terakoya</title>

    <style>
        :root {
            --color-primary: #2c3e50;
            --color-primary-dark: #1a252f;
            --color-accent: #f093fb;
            --color-accent-light: #f5576c;
            --color-text: #2d3748;
            --color-text-light: #4a5568;
            --color-bg: #ffffff;
            --color-bg-alt: #f7fafc;
            --color-border: #e2e8f0;
            --color-code-bg: #f8f9fa;
            --color-link: #f093fb;
            --color-link-hover: #d07be8;

            --spacing-xs: 0.5rem;
            --spacing-sm: 1rem;
            --spacing-md: 1.5rem;
            --spacing-lg: 2rem;
            --spacing-xl: 3rem;

            --font-body: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            --font-mono: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;

            --border-radius: 8px;
            --box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-body);
            line-height: 1.7;
            color: var(--color-text);
            background-color: var(--color-bg);
            font-size: 16px;
        }

        header {
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            color: white;
            padding: var(--spacing-xl) var(--spacing-md);
            margin-bottom: var(--spacing-xl);
            box-shadow: var(--box-shadow);
        }

        .header-content {
            max-width: 900px;
            margin: 0 auto;
        }

        h1 {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: var(--spacing-sm);
            line-height: 1.2;
        }

        .subtitle {
            font-size: 1.1rem;
            opacity: 0.95;
            font-weight: 400;
            margin-bottom: var(--spacing-md);
        }

        .meta {
            display: flex;
            flex-wrap: wrap;
            gap: var(--spacing-md);
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .meta-item {
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 0 var(--spacing-md) var(--spacing-xl);
        }

        h2 {
            font-size: 1.75rem;
            color: var(--color-primary);
            margin-top: var(--spacing-xl);
            margin-bottom: var(--spacing-md);
            padding-bottom: var(--spacing-xs);
            border-bottom: 3px solid var(--color-accent);
        }

        h3 {
            font-size: 1.4rem;
            color: var(--color-primary);
            margin-top: var(--spacing-lg);
            margin-bottom: var(--spacing-sm);
        }

        h4 {
            font-size: 1.1rem;
            color: var(--color-primary-dark);
            margin-top: var(--spacing-md);
            margin-bottom: var(--spacing-sm);
        }

        p {
            margin-bottom: var(--spacing-md);
            color: var(--color-text);
        }

        a {
            color: var(--color-link);
            text-decoration: none;
            transition: color 0.2s;
        }

        a:hover {
            color: var(--color-link-hover);
            text-decoration: underline;
        }

        ul, ol {
            margin-left: var(--spacing-lg);
            margin-bottom: var(--spacing-md);
        }

        li {
            margin-bottom: var(--spacing-xs);
            color: var(--color-text);
        }

        pre {
            background-color: var(--color-code-bg);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            overflow-x: auto;
            margin-bottom: var(--spacing-md);
            font-family: var(--font-mono);
            font-size: 0.9rem;
            line-height: 1.5;
        }

        code {
            font-family: var(--font-mono);
            font-size: 0.9em;
            background-color: var(--color-code-bg);
            padding: 0.2em 0.4em;
            border-radius: 3px;
        }

        pre code {
            background-color: transparent;
            padding: 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: var(--spacing-md);
            font-size: 0.95rem;
        }

        th, td {
            border: 1px solid var(--color-border);
            padding: var(--spacing-sm);
            text-align: left;
        }

        th {
            background-color: var(--color-bg-alt);
            font-weight: 600;
            color: var(--color-primary);
        }

        blockquote {
            border-left: 4px solid var(--color-accent);
            padding-left: var(--spacing-md);
            margin: var(--spacing-md) 0;
            color: var(--color-text-light);
            font-style: italic;
            background-color: var(--color-bg-alt);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        .mermaid {
            text-align: center;
            margin: var(--spacing-lg) 0;
            background-color: var(--color-bg-alt);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        .learning-objectives {
            background: linear-gradient(135deg, #fce7f3 0%, #fbcfe8 100%);
            padding: var(--spacing-lg);
            border-radius: var(--border-radius);
            border-left: 4px solid var(--color-accent);
            margin-bottom: var(--spacing-xl);
        }

        .learning-objectives h2 {
            margin-top: 0;
            border-bottom: none;
        }

        .breadcrumb {
            max-width: 900px;
            margin: 0 auto;
            padding: var(--spacing-sm) var(--spacing-md);
            font-size: 0.9rem;
            color: var(--color-text-light);
        }

        .breadcrumb a {
            color: var(--color-link);
            text-decoration: none;
        }

        .breadcrumb a:hover {
            text-decoration: underline;
        }

        .navigation {
            display: flex;
            justify-content: space-between;
            gap: var(--spacing-md);
            margin: var(--spacing-xl) 0;
            padding-top: var(--spacing-lg);
            border-top: 2px solid var(--color-border);
        }

        .nav-button {
            flex: 1;
            padding: var(--spacing-md);
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            color: white;
            border-radius: var(--border-radius);
            text-align: center;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: var(--box-shadow);
        }

        .nav-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            text-decoration: none;
        }

        footer {
            margin-top: var(--spacing-xl);
            padding: var(--spacing-lg) var(--spacing-md);
            background-color: var(--color-bg-alt);
            border-top: 1px solid var(--color-border);
            text-align: center;
            font-size: 0.9rem;
            color: var(--color-text-light);
        }
        .disclaimer {
            max-width: 900px;
            margin: 2rem auto;
            padding: 1.5rem;
            background: #f8f9fa;
            border-left: 4px solid #6c757d;
            border-radius: 4px;
        }

        .disclaimer h3 {
            color: #495057;
            margin-bottom: 1rem;
            font-size: 1.1rem;
        }

        .disclaimer ul {
            list-style: none;
            padding-left: 0;
        }

        .disclaimer li {
            padding: 0.5rem 0;
            padding-left: 1.5rem;
            position: relative;
            font-size: 0.9rem;
            color: #6c757d;
            line-height: 1.6;
        }

        .disclaimer li::before {
            content: "âš ï¸";
            position: absolute;
            left: 0;
        }


        @media (max-width: 768px) {
            h1 {
                font-size: 1.5rem;
            }

            h2 {
                font-size: 1.4rem;
            }

            h3 {
                font-size: 1.2rem;
            }

            .meta {
                font-size: 0.85rem;
            }

            .navigation {
                flex-direction: column;
            }

            table {
                font-size: 0.85rem;
            }

            th, td {
                padding: var(--spacing-xs);
            }
        }
    </style>

    <!-- Prism.js for syntax highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <script>
        mermaid.initialize({ startOnLoad: true, theme: 'default', securityLevel: 'strict' });
    </script>

    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true,
                processEnvironments: true
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
                ignoreHtmlClass: 'mermaid'
            }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" id="MathJax-script" async></script>

    <style>
        /* Locale Switcher Styles */
        .locale-switcher {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 6px;
            font-size: 0.9rem;
            margin-bottom: 1rem;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .current-locale {
            font-weight: 600;
            color: #7b2cbf;
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .locale-separator {
            color: #adb5bd;
            font-weight: 300;
        }

        .locale-link {
            color: #f093fb;
            text-decoration: none;
            font-weight: 500;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 0.25rem;
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
        }

        .locale-link:hover {
            background: rgba(240, 147, 251, 0.1);
            color: #d07be8;
            transform: translateY(-1px);
        }

        .locale-meta {
            color: #868e96;
            font-size: 0.85rem;
            font-style: italic;
            margin-left: auto;
        }

        @media (max-width: 768px) {
            .locale-switcher {
                font-size: 0.85rem;
                padding: 0.4rem 0.8rem;
            }
            .locale-meta {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div class="locale-switcher">
<span class="current-locale">ğŸŒ JP</span>
<span class="locale-separator">|</span>
<a href="../../../en/MS/electron-microscopy-introduction/chapter-5.html" class="locale-link">ğŸ‡¬ğŸ‡§ EN</a>
<span class="locale-separator">|</span>
<span class="locale-meta">Last sync: 2025-11-16</span>
</div>
<header>
        <div class="header-content">
            <h1>ç¬¬5ç« ï¼šEDSãƒ»EELSãƒ»EBSDåˆ†æå®Ÿè·µ</h1>
            <p class="subtitle">HyperSpyãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã€PCA/ICAã€æ©Ÿæ¢°å­¦ç¿’åˆ†é¡ã€EBSDæ–¹ä½è§£æ</p>
            <div class="meta">
                <span class="meta-item">ğŸ“– èª­äº†æ™‚é–“: 30-40åˆ†</span>
                <span class="meta-item">ğŸ“Š é›£æ˜“åº¦: ä¸­ç´šã€œä¸Šç´š</span>
                <span class="meta-item">ğŸ’» ã‚³ãƒ¼ãƒ‰ä¾‹: 7å€‹</span>
            </div>
        </div>
    </header>

    <div class="breadcrumb">
        <a href="../../index.html">AIå¯ºå­å±‹ãƒˆãƒƒãƒ—</a> &gt;
        <a href="../index.html">MS Dojo</a> &gt;
        <a href="index.html">é›»å­é¡•å¾®é¡å…¥é–€</a> &gt;
        ç¬¬5ç« 
    </div>

    <main class="container">
        <p class="chapter-description" style="margin: 1.5rem 0; padding: 1rem; background: linear-gradient(135deg, #fce7f3 0%, #fbcfe8 100%); border-left: 4px solid #f093fb; border-radius: 8px; font-size: 1.05rem; line-height: 1.8; color: #2d3748;">
            æœ¬ç« ã§ã¯ã€EDSãƒ»EELSãƒ»EBSDãƒ‡ãƒ¼ã‚¿ã‚’Pythonã§çµ±åˆçš„ã«è§£æã™ã‚‹å®Ÿè·µçš„ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã‚’å­¦ã³ã¾ã™ã€‚HyperSpyã«ã‚ˆã‚‹ã‚¹ãƒšã‚¯ãƒˆãƒ«å‡¦ç†ã€PCA/ICAã«ã‚ˆã‚‹æ¬¡å…ƒå‰Šæ¸›ã€æ©Ÿæ¢°å­¦ç¿’ã«ã‚ˆã‚‹ç›¸åˆ†é¡ã€EELSãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰å‡¦ç†ã€EBSDæ–¹ä½è§£æï¼ˆKAMã€GNDãƒãƒƒãƒ—ï¼‰ã‚’ç¿’å¾—ã—ã€å®Ÿéš›ã®ææ–™è§£æã«å¿œç”¨ã§ãã‚‹åŠ›ã‚’èº«ã«ã¤ã‘ã¾ã™ã€‚
        </p>

        <div class="learning-objectives">
            <h2>å­¦ç¿’ç›®æ¨™</h2>
            <p>ã“ã®ç« ã‚’èª­ã‚€ã“ã¨ã§ã€ä»¥ä¸‹ã‚’ç¿’å¾—ã§ãã¾ã™ï¼š</p>
            <ul>
                <li>âœ… HyperSpyã®åŸºæœ¬æ“ä½œï¼ˆãƒ‡ãƒ¼ã‚¿èª­è¾¼ã€å¯è¦–åŒ–ã€å‰å‡¦ç†ï¼‰ãŒã§ãã‚‹</li>
                <li>âœ… EELSã‚¹ãƒšã‚¯ãƒˆãƒ«ã®ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰é™¤å»ã¨ãƒ”ãƒ¼ã‚¯ãƒ•ã‚£ãƒƒãƒ†ã‚£ãƒ³ã‚°ãŒã§ãã‚‹</li>
                <li>âœ… PCA/ICAã§é«˜æ¬¡å…ƒã‚¹ãƒšã‚¯ãƒˆãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’æ¬¡å…ƒå‰Šæ¸›ã§ãã‚‹</li>
                <li>âœ… æ©Ÿæ¢°å­¦ç¿’ï¼ˆk-means, GMM, SVMï¼‰ã§ç›¸è‡ªå‹•åˆ†é¡ãŒã§ãã‚‹</li>
                <li>âœ… EBSDæ–¹ä½ãƒ‡ãƒ¼ã‚¿ã‚’orixã§èª­è¾¼ã¿ã€æ–¹ä½ãƒãƒƒãƒ—ã‚’ä½œæˆã§ãã‚‹</li>
                <li>âœ… KAMï¼ˆå±€æ‰€æ–¹ä½å·®ï¼‰ã€GNDï¼ˆå¹¾ä½•å­¦çš„å¿…è¦è»¢ä½å¯†åº¦ï¼‰ã‚’è¨ˆç®—ã§ãã‚‹</li>
                <li>âœ… çµ±åˆè§£æãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã‚’æ§‹ç¯‰ã—ã€å®Ÿãƒ‡ãƒ¼ã‚¿ã«é©ç”¨ã§ãã‚‹</li>
            </ul>
        </div>

        <h2>5.1 HyperSpyã«ã‚ˆã‚‹ã‚¹ãƒšã‚¯ãƒˆãƒ«è§£æåŸºç¤</h2>

        <h3>5.1.1 HyperSpyã¨ã¯</h3>
        <p><strong>HyperSpy</strong>ã¯ã€é›»å­é¡•å¾®é¡ã‚¹ãƒšã‚¯ãƒˆãƒ«ãƒ‡ãƒ¼ã‚¿ï¼ˆEELS, EDS, CL, XRFç­‰ï¼‰ã®è§£æã«ç‰¹åŒ–ã—ãŸPythonãƒ©ã‚¤ãƒ–ãƒ©ãƒªã§ã™ã€‚</p>

        <p><strong>ä¸»ãªæ©Ÿèƒ½</strong>ï¼š</p>
        <ul>
            <li>å¤šæ¬¡å…ƒã‚¹ãƒšã‚¯ãƒˆãƒ«ãƒ‡ãƒ¼ã‚¿ï¼ˆSpectrum Imageï¼‰ã®èª­è¾¼ãƒ»å¯è¦–åŒ–</li>
            <li>ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰é™¤å»ã€ãƒ”ãƒ¼ã‚¯ãƒ•ã‚£ãƒƒãƒ†ã‚£ãƒ³ã‚°ã€å®šé‡åˆ†æ</li>
            <li>å¤šå¤‰é‡çµ±è¨ˆè§£æï¼ˆPCA, ICA, NMFï¼‰</li>
            <li>æ©Ÿæ¢°å­¦ç¿’çµ±åˆï¼ˆscikit-learné€£æºï¼‰</li>
            <li>ãƒãƒƒãƒå‡¦ç†ã¨ã‚¹ã‚¯ãƒªãƒ—ãƒˆåŒ–</li>
        </ul>

        <div class="mermaid">
flowchart LR
    A[Raw Data<br/>dm3, hspy, msa] --> B[HyperSpy<br/>Load & Visualize]
    B --> C[Preprocessing<br/>Align, Crop, Bin]
    C --> D[Background<br/>Removal]
    D --> E{Analysis Type}
    E -->|Quantification| F[Element Maps]
    E -->|Dimensionality| G[PCA/ICA]
    E -->|Machine Learning| H[Classification]
    G --> I[Component Maps]
    H --> I
    F --> I
    I --> J[Integrated<br/>Interpretation]

    style A fill:#f093fb,stroke:#f5576c,stroke-width:2px,color:#fff
    style J fill:#f5576c,stroke:#f093fb,stroke-width:2px,color:#fff
        </div>

        <h3>5.1.2 HyperSpyåŸºæœ¬ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼</h3>

        <h4>ã‚³ãƒ¼ãƒ‰ä¾‹5-1: HyperSpyåŸºæœ¬æ“ä½œã¨EELSã‚¹ãƒšã‚¯ãƒˆãƒ«å¯è¦–åŒ–</h4>
        <pre><code class="language-python">import hyperspy.api as hs
import numpy as np
import matplotlib.pyplot as plt

# ãƒ€ãƒŸãƒ¼EELSã‚¹ãƒšã‚¯ãƒˆãƒ©ãƒ ã‚¤ãƒ¡ãƒ¼ã‚¸ç”Ÿæˆï¼ˆå®Ÿéš›ã®ãƒ‡ãƒ¼ã‚¿ã¯hs.load()ã§èª­è¾¼ï¼‰
def create_dummy_eels_si(size=64, energy_range=(400, 1000)):
    """
    ãƒ€ãƒŸãƒ¼EELS Spectrum Imageã‚’ç”Ÿæˆ

    Parameters
    ----------
    size : int
        ç©ºé–“ã‚µã‚¤ã‚º [pixels]
    energy_range : tuple
        ã‚¨ãƒãƒ«ã‚®ãƒ¼ç¯„å›² [eV]

    Returns
    -------
    s : hyperspy Signal1D
        EELS Spectrum Image
    """
    # ã‚¨ãƒãƒ«ã‚®ãƒ¼è»¸
    energy = np.linspace(energy_range[0], energy_range[1], 500)

    # ç©ºé–“ä¾å­˜ã®æ¨¡æ“¬ã‚¹ãƒšã‚¯ãƒˆãƒ«
    # é ˜åŸŸ1: Fe-L2,3 edge (708 eV)
    # é ˜åŸŸ2: O-K edge (532 eV)

    data = np.zeros((size, size, len(energy)))

    for i in range(size):
        for j in range(size):
            # ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰
            bg = 1000 * (energy / energy[0])**(-3)

            # é ˜åŸŸä¾å­˜ã®ã‚¨ãƒƒã‚¸è¿½åŠ 
            if i < size // 2:  # å·¦åŠåˆ†: Fe rich
                fe_edge = energy >= 708
                bg[fe_edge] += 200 * np.exp(-(energy[fe_edge] - 708) / 50)
            else:  # å³åŠåˆ†: O rich
                o_edge = energy >= 532
                bg[o_edge] += 150 * np.exp(-(energy[o_edge] - 532) / 40)

            # ãƒã‚¤ã‚º
            data[i, j, :] = bg + np.random.poisson(lam=10, size=len(energy))

    # HyperSpy Signal1Dä½œæˆ
    s = hs.signals.Signal1D(data)
    s.axes_manager[0].name = 'x'
    s.axes_manager[0].units = 'pixels'
    s.axes_manager[1].name = 'y'
    s.axes_manager[1].units = 'pixels'
    s.axes_manager[2].name = 'Energy'
    s.axes_manager[2].units = 'eV'
    s.axes_manager[2].offset = energy_range[0]
    s.axes_manager[2].scale = (energy_range[1] - energy_range[0]) / len(energy)

    s.metadata.General.title = 'EELS Spectrum Image (Dummy)'
    s.metadata.Signal.signal_type = 'EELS'

    return s

# ãƒ€ãƒŸãƒ¼ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆ
s = create_dummy_eels_si(size=64, energy_range=(400, 1000))

print("HyperSpy Signalæƒ…å ±:")
print(s)
print(f"\nãƒ‡ãƒ¼ã‚¿å½¢çŠ¶: {s.data.shape}")
print(f"ç©ºé–“ã‚µã‚¤ã‚º: {s.axes_manager[0].size} Ã— {s.axes_manager[1].size}")
print(f"ã‚¨ãƒãƒ«ã‚®ãƒ¼ç‚¹æ•°: {s.axes_manager[2].size}")

# åŸºæœ¬å¯è¦–åŒ–
fig, axes = plt.subplots(1, 3, figsize=(16, 5))

# å·¦å›³: å¹³å‡ã‚¹ãƒšã‚¯ãƒˆãƒ«
s_mean = s.mean()
axes[0].plot(s_mean.axes_manager[0].axis, s_mean.data, linewidth=2)
axes[0].set_xlabel('Energy Loss [eV]', fontsize=12)
axes[0].set_ylabel('Intensity [counts]', fontsize=12)
axes[0].set_title('Mean EELS Spectrum', fontsize=13, fontweight='bold')
axes[0].set_yscale('log')
axes[0].grid(alpha=0.3)

# ä¸­å›³: ç‰¹å®šã‚¨ãƒãƒ«ã‚®ãƒ¼ã§ã®ç©ºé–“ãƒãƒƒãƒ—ï¼ˆ532 eV: O-Kï¼‰
idx_o = int((532 - 400) / (1000 - 400) * s.axes_manager[2].size)
im1 = axes[1].imshow(s.data[:, :, idx_o], cmap='viridis')
axes[1].set_title('Spatial Map at 532 eV\n(O-K edge)', fontsize=13, fontweight='bold')
axes[1].axis('off')
plt.colorbar(im1, ax=axes[1], fraction=0.046)

# å³å›³: ç‰¹å®šä½ç½®ã§ã®ã‚¹ãƒšã‚¯ãƒˆãƒ«æ¯”è¼ƒ
pos1 = (10, 32)  # Fe rich
pos2 = (50, 32)  # O rich

s1 = s.inav[pos1[0], pos1[1]]
s2 = s.inav[pos2[0], pos2[1]]

axes[2].plot(s1.axes_manager[0].axis, s1.data, label=f'Position {pos1} (Fe rich)', linewidth=2)
axes[2].plot(s2.axes_manager[0].axis, s2.data, label=f'Position {pos2} (O rich)', linewidth=2, alpha=0.7)
axes[2].set_xlabel('Energy Loss [eV]', fontsize=12)
axes[2].set_ylabel('Intensity [counts]', fontsize=12)
axes[2].set_title('Spectra at Different Positions', fontsize=13, fontweight='bold')
axes[2].legend(fontsize=10)
axes[2].set_yscale('log')
axes[2].grid(alpha=0.3)

plt.tight_layout()
plt.show()

# ä¿å­˜ä¾‹ï¼ˆå®Ÿéš›ã®ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã§ä½¿ç”¨ï¼‰
# s.save('my_eels_data.hspy')  # HyperSpyå½¢å¼
# s.save('my_eels_data.msa')   # MSAå½¢å¼ï¼ˆDigital Micrographäº’æ›ï¼‰
</code></pre>

        <h3>5.1.3 EELSãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰é™¤å»</h3>
        <p>EELSã‚¹ãƒšã‚¯ãƒˆãƒ«ã®ã‚³ã‚¢ãƒ­ã‚¹ã‚¨ãƒƒã‚¸ã‚’å®šé‡ã™ã‚‹ã«ã¯ã€ã‚¨ãƒƒã‚¸å‰ã®ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã‚’é™¤å»ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚HyperSpyã§ã¯ã¹ãä¹—å‰‡ãƒ•ã‚£ãƒƒãƒ†ã‚£ãƒ³ã‚°ãŒæ¨™æº–çš„ã§ã™ï¼š</p>

        $$
        I_{\text{BG}}(E) = A \cdot E^{-r}
        $$

        <h4>ã‚³ãƒ¼ãƒ‰ä¾‹5-2: EELSãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰é™¤å»ã¨ãƒ”ãƒ¼ã‚¯ç©åˆ†</h4>
        <pre><code class="language-python">import hyperspy.api as hs
import numpy as np
import matplotlib.pyplot as plt

# å‰ä¾‹ã®ãƒ€ãƒŸãƒ¼ãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ç”¨
s = create_dummy_eels_si(size=64, energy_range=(400, 1000))

# ç‰¹å®šä½ç½®ã®ã‚¹ãƒšã‚¯ãƒˆãƒ«æŠ½å‡º
pos = (10, 32)  # Fe riché ˜åŸŸ
s_point = s.inav[pos[0], pos[1]]

# ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰é™¤å»ï¼ˆFe-L2,3 edgeç”¨ï¼‰
# ã‚¨ãƒƒã‚¸å‰é ˜åŸŸã§ãƒ•ã‚£ãƒƒãƒˆ
edge_onset = 708  # Fe-L2,3 edge [eV]
fit_range = (650, 700)  # ãƒ•ã‚£ãƒƒãƒˆç¯„å›² [eV]

# HyperSpyã®ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰é™¤å»æ©Ÿèƒ½
s_point_bg_removed = s_point.remove_background(
    signal_range=fit_range,
    background_type='PowerLaw',
    fast=False
)

# ç©åˆ†çª“è¨­å®šï¼ˆã‚¨ãƒƒã‚¸å¾Œ50 eVï¼‰
integration_window = (edge_onset, edge_onset + 50)

# ç©åˆ†å¼·åº¦è¨ˆç®—ï¼ˆå°å½¢å‰‡ï¼‰
energy_axis = s_point_bg_removed.axes_manager[0].axis
mask = (energy_axis >= integration_window[0]) & (energy_axis <= integration_window[1])
integrated_intensity = np.trapz(s_point_bg_removed.data[mask], energy_axis[mask])

# å¯è¦–åŒ–
fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 10))

# ä¸Šå›³: ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰é™¤å»å‰å¾Œ
ax1.plot(s_point.axes_manager[0].axis, s_point.data, 'b-', linewidth=2, label='Raw Spectrum')

# ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰æ›²ç·šã‚’å†è¨ˆç®—ã—ã¦è¡¨ç¤º
from hyperspy.components1d import PowerLaw
bg_model = PowerLaw()
bg_model.fit(s_point, fit_range[0], fit_range[1])
bg_curve = bg_model.function(s_point.axes_manager[0].axis)

ax1.plot(s_point.axes_manager[0].axis, bg_curve, 'r--', linewidth=2, label='Background Fit')
ax1.axvspan(fit_range[0], fit_range[1], alpha=0.2, color='yellow', label='Fit Region')
ax1.axvline(edge_onset, color='green', linestyle=':', linewidth=2, label=f'Fe-L edge ({edge_onset} eV)')

ax1.set_xlabel('Energy Loss [eV]', fontsize=12)
ax1.set_ylabel('Intensity [counts]', fontsize=12)
ax1.set_title('EELS Spectrum: Raw + Background Fit', fontsize=14, fontweight='bold')
ax1.set_yscale('log')
ax1.legend(fontsize=10)
ax1.grid(alpha=0.3)
ax1.set_xlim(500, 900)

# ä¸‹å›³: ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰é™¤å»å¾Œ
ax2.plot(s_point_bg_removed.axes_manager[0].axis, s_point_bg_removed.data, 'g-', linewidth=2, label='Background Removed')
ax2.axvline(edge_onset, color='green', linestyle=':', linewidth=2, label=f'Fe-L edge')
ax2.axvspan(integration_window[0], integration_window[1], alpha=0.3, color='lightgreen', label='Integration Window')

ax2.set_xlabel('Energy Loss [eV]', fontsize=12)
ax2.set_ylabel('Intensity [counts]', fontsize=12)
ax2.set_title(f'Background-Removed Spectrum (Integrated Intensity: {integrated_intensity:.0f})',
              fontsize=14, fontweight='bold')
ax2.legend(fontsize=10)
ax2.grid(alpha=0.3)
ax2.set_xlim(500, 900)
ax2.set_ylim(bottom=0)

plt.tight_layout()
plt.show()

print(f"ç©åˆ†å¼·åº¦ï¼ˆFe-L edgeï¼‰: {integrated_intensity:.1f} counts")
print(f"ã“ã®å€¤ã‚’æ–­é¢ç©ã§è£œæ­£ã—ã¦å…ƒç´ æ¿ƒåº¦ã‚’ç®—å‡º")
</code></pre>

        <h2>5.2 å¤šå¤‰é‡çµ±è¨ˆè§£æï¼ˆPCA/ICAï¼‰</h2>

        <h3>5.2.1 ä¸»æˆåˆ†åˆ†æï¼ˆPCAï¼‰ã®åŸç†</h3>
        <p>é«˜æ¬¡å…ƒã‚¹ãƒšã‚¯ãƒˆãƒ«ãƒ‡ãƒ¼ã‚¿ï¼ˆä¾‹ï¼š64Ã—64ç©ºé–“ Ã— 500ã‚¨ãƒãƒ«ã‚®ãƒ¼ç‚¹ï¼‰ã‚’å°‘æ•°ã®ä¸»æˆåˆ†ã«æ¬¡å…ƒå‰Šæ¸›ã™ã‚‹ã“ã¨ã§ã€ãƒã‚¤ã‚ºé™¤å»ã¨ç›¸åˆ†é›¢ãŒå¯èƒ½ã«ãªã‚Šã¾ã™ã€‚</p>

        <p><strong>PCAã®åˆ©ç‚¹</strong>ï¼š</p>
        <ul>
            <li>ãƒ‡ãƒ¼ã‚¿ã®åˆ†æ•£ã‚’æœ€å¤§åŒ–ã™ã‚‹æ–¹å‘ã‚’æŠ½å‡ºï¼ˆä¸»æˆåˆ†ï¼‰</li>
            <li>ä¸Šä½æ•°æˆåˆ†ã§å…ƒãƒ‡ãƒ¼ã‚¿ã®90%ä»¥ä¸Šã®æƒ…å ±ã‚’ä¿æŒå¯èƒ½</li>
            <li>ãƒã‚¤ã‚ºã¯ä½æ¬¡æˆåˆ†ã«åˆ†é›¢ã•ã‚Œã‚‹ãŸã‚ã€S/Næ¯”å‘ä¸Š</li>
            <li>æˆåˆ†ãƒãƒƒãƒ—ã§ç›¸ã®ç©ºé–“åˆ†å¸ƒã‚’å¯è¦–åŒ–</li>
        </ul>

        <h4>ã‚³ãƒ¼ãƒ‰ä¾‹5-3: PCA/ICAã«ã‚ˆã‚‹ã‚¹ãƒšã‚¯ãƒˆãƒ«åˆ†é›¢</h4>
        <pre><code class="language-python">import hyperspy.api as hs
import numpy as np
import matplotlib.pyplot as plt
from sklearn.decomposition import PCA, FastICA

# ãƒ€ãƒŸãƒ¼ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆï¼ˆ2ç›¸æ··åˆï¼‰
s = create_dummy_eels_si(size=64, energy_range=(400, 1000))

# PCAå®Ÿè¡Œ
s.decomposition(algorithm='PCA', output_dimension=10)

# ã‚¹ã‚¯ãƒªãƒ¼ãƒ—ãƒ­ãƒƒãƒˆï¼ˆä¸»æˆåˆ†ã®å¯„ä¸ç‡ï¼‰
s.plot_explained_variance_ratio(n=10)

# ä¸Šä½3ä¸»æˆåˆ†ã®ãƒ­ãƒ¼ãƒ‰ã‚¹ãƒšã‚¯ãƒˆãƒ«ã¨ã‚¹ã‚³ã‚¢ãƒãƒƒãƒ—
fig, axes = plt.subplots(3, 3, figsize=(15, 12))

for i in range(3):
    # ãƒ­ãƒ¼ãƒ‰ã‚¹ãƒšã‚¯ãƒˆãƒ«ï¼ˆä¸»æˆåˆ†ã®ã‚¹ãƒšã‚¯ãƒˆãƒ«å½¢çŠ¶ï¼‰
    loading = s.get_decomposition_loadings().inav[i]

    axes[i, 0].plot(loading.axes_manager[0].axis, loading.data, linewidth=2)
    axes[i, 0].set_xlabel('Energy Loss [eV]', fontsize=11)
    axes[i, 0].set_ylabel('Loading', fontsize=11)
    axes[i, 0].set_title(f'PC{i+1} Loading Spectrum', fontsize=12, fontweight='bold')
    axes[i, 0].grid(alpha=0.3)

    # ã‚¹ã‚³ã‚¢ãƒãƒƒãƒ—ï¼ˆä¸»æˆåˆ†ã®ç©ºé–“åˆ†å¸ƒï¼‰
    factor = s.get_decomposition_factors().inav[i]

    im = axes[i, 1].imshow(factor.data, cmap='RdBu_r')
    axes[i, 1].set_title(f'PC{i+1} Score Map', fontsize=12, fontweight='bold')
    axes[i, 1].axis('off')
    plt.colorbar(im, ax=axes[i, 1], fraction=0.046)

    # ç´¯ç©å¯„ä¸ç‡
    if i == 0:
        variance_ratio = s.get_explained_variance_ratio().data
        cumsum = np.cumsum(variance_ratio[:10])

        axes[i, 2].bar(range(1, 11), variance_ratio[:10], alpha=0.7, label='Individual')
        axes[i, 2].plot(range(1, 11), cumsum, 'ro-', linewidth=2, markersize=6, label='Cumulative')
        axes[i, 2].set_xlabel('Principal Component', fontsize=11)
        axes[i, 2].set_ylabel('Explained Variance Ratio', fontsize=11)
        axes[i, 2].set_title('Scree Plot', fontsize=12, fontweight='bold')
        axes[i, 2].legend(fontsize=10)
        axes[i, 2].grid(alpha=0.3)
    else:
        axes[i, 2].axis('off')

plt.tight_layout()
plt.show()

# ä¸Šä½3æˆåˆ†ã§å†æ§‹æˆ
s_reconstructed = s.get_decomposition_model(components=3)

print(f"å…ƒãƒ‡ãƒ¼ã‚¿ã‚µã‚¤ã‚º: {s.data.nbytes / 1e6:.1f} MB")
print(f"PCA3æˆåˆ†ã®ã‚µã‚¤ã‚º: {s_reconstructed.data.nbytes / 1e6:.1f} MB")
print(f"åœ§ç¸®ç‡: {s.data.nbytes / s_reconstructed.data.nbytes:.1f}å€")

# ICAå®Ÿè¡Œï¼ˆç‹¬ç«‹æˆåˆ†åˆ†æï¼‰
# ICAã¯PCAã‚ˆã‚Šç‰©ç†çš„ã«æ„å‘³ã®ã‚ã‚‹æˆåˆ†ã‚’æŠ½å‡ºã—ã‚„ã™ã„
s.decomposition(algorithm='PCA', output_dimension=5)  # å‰å‡¦ç†
s.blind_source_separation(number_of_components=3, algorithm='FastICA')

# ICAæˆåˆ†ã®ãƒ—ãƒ­ãƒƒãƒˆ
fig2, axes2 = plt.subplots(3, 2, figsize=(12, 10))

for i in range(3):
    # ICAãƒ­ãƒ¼ãƒ‰ã‚¹ãƒšã‚¯ãƒˆãƒ«
    loading_ica = s.get_bss_loadings().inav[i]
    axes2[i, 0].plot(loading_ica.axes_manager[0].axis, loading_ica.data, linewidth=2, color='purple')
    axes2[i, 0].set_xlabel('Energy Loss [eV]', fontsize=11)
    axes2[i, 0].set_ylabel('IC Loading', fontsize=11)
    axes2[i, 0].set_title(f'ICA Component {i+1} Spectrum', fontsize=12, fontweight='bold')
    axes2[i, 0].grid(alpha=0.3)

    # ICAã‚¹ã‚³ã‚¢ãƒãƒƒãƒ—
    factor_ica = s.get_bss_factors().inav[i]
    im2 = axes2[i, 1].imshow(factor_ica.data, cmap='viridis')
    axes2[i, 1].set_title(f'ICA Component {i+1} Map', fontsize=12, fontweight='bold')
    axes2[i, 1].axis('off')
    plt.colorbar(im2, ax=axes2[i, 1], fraction=0.046)

plt.tight_layout()
plt.show()

print("\nPCA: ãƒ‡ãƒ¼ã‚¿ã®åˆ†æ•£ã‚’æœ€å¤§åŒ–ï¼ˆæ•°å­¦çš„æœ€é©ï¼‰")
print("ICA: çµ±è¨ˆçš„ã«ç‹¬ç«‹ãªæˆåˆ†ã‚’æŠ½å‡ºï¼ˆç‰©ç†çš„è§£é‡ˆãŒå®¹æ˜“ï¼‰")
</code></pre>

        <h2>5.3 æ©Ÿæ¢°å­¦ç¿’ã«ã‚ˆã‚‹ç›¸è‡ªå‹•åˆ†é¡</h2>

        <h3>5.3.1 æ•™å¸«ãªã—å­¦ç¿’ï¼ˆk-means, GMMï¼‰</h3>
        <p>ã‚¹ãƒšã‚¯ãƒˆãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’ç‰¹å¾´ç©ºé–“ã§ã‚¯ãƒ©ã‚¹ã‚¿ãƒªãƒ³ã‚°ã—ã€ç•°ãªã‚‹ç›¸ã‚„é ˜åŸŸã‚’è‡ªå‹•åˆ†é¡ã—ã¾ã™ã€‚</p>

        <table>
            <thead>
                <tr>
                    <th>æ‰‹æ³•</th>
                    <th>åŸç†</th>
                    <th>åˆ©ç‚¹</th>
                    <th>æ¬ ç‚¹</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>k-means</strong></td>
                    <td>ãƒ¦ãƒ¼ã‚¯ãƒªãƒƒãƒ‰è·é›¢ã§kå€‹ã®ã‚¯ãƒ©ã‚¹ã‚¿ã«åˆ†å‰²</td>
                    <td>é«˜é€Ÿã€å®Ÿè£…ãŒç°¡å˜</td>
                    <td>çƒçŠ¶ã‚¯ãƒ©ã‚¹ã‚¿ä»®å®šã€ã‚¯ãƒ©ã‚¹ã‚¿æ•°ã‚’äº‹å‰æŒ‡å®š</td>
                </tr>
                <tr>
                    <td><strong>GMM</strong></td>
                    <td>ã‚¬ã‚¦ã‚¹æ··åˆãƒ¢ãƒ‡ãƒ«ã§ç¢ºç‡çš„åˆ†é¡</td>
                    <td>æ¥•å††ã‚¯ãƒ©ã‚¹ã‚¿å¯¾å¿œã€æ‰€å±ç¢ºç‡ã‚’å‡ºåŠ›</td>
                    <td>è¨ˆç®—ã‚³ã‚¹ãƒˆãŒã‚„ã‚„é«˜ã„</td>
                </tr>
                <tr>
                    <td><strong>éšå±¤çš„</strong></td>
                    <td>ãƒ‡ãƒ³ãƒ‰ãƒ­ã‚°ãƒ©ãƒ ã§é¡ä¼¼åº¦ã‚’éšå±¤åŒ–</td>
                    <td>ã‚¯ãƒ©ã‚¹ã‚¿æ•°è‡ªå‹•æ±ºå®šã€è¦–è¦šçš„ç†è§£å®¹æ˜“</td>
                    <td>å¤§è¦æ¨¡ãƒ‡ãƒ¼ã‚¿ã«ä¸å‘ã</td>
                </tr>
            </tbody>
        </table>

        <h4>ã‚³ãƒ¼ãƒ‰ä¾‹5-4: k-meansã¨GMMã«ã‚ˆã‚‹ç›¸åˆ†é¡</h4>
        <pre><code class="language-python">import hyperspy.api as hs
import numpy as np
import matplotlib.pyplot as plt
from sklearn.cluster import KMeans
from sklearn.mixture import GaussianMixture
from sklearn.preprocessing import StandardScaler

# ãƒ€ãƒŸãƒ¼ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆ
s = create_dummy_eels_si(size=64, energy_range=(400, 1000))

# ãƒ‡ãƒ¼ã‚¿æ•´å½¢ï¼ˆç©ºé–“æ¬¡å…ƒã‚’å¹³å¦åŒ–ï¼‰
data_reshaped = s.data.reshape(-1, s.data.shape[2])  # (N_pixels, N_energy)

# æ¨™æº–åŒ–ï¼ˆç‰¹å¾´é‡ã®ã‚¹ã‚±ãƒ¼ãƒ«ã‚’æƒãˆã‚‹ï¼‰
scaler = StandardScaler()
data_scaled = scaler.fit_transform(data_reshaped)

# k-meansã‚¯ãƒ©ã‚¹ã‚¿ãƒªãƒ³ã‚°
n_clusters = 3
kmeans = KMeans(n_clusters=n_clusters, random_state=42, n_init=10)
labels_kmeans = kmeans.fit_predict(data_scaled)
labels_kmeans_map = labels_kmeans.reshape(s.data.shape[0], s.data.shape[1])

# ã‚¯ãƒ©ã‚¹ã‚¿ä¸­å¿ƒã®ã‚¹ãƒšã‚¯ãƒˆãƒ«
cluster_centers = scaler.inverse_transform(kmeans.cluster_centers_)

# GMMã‚¯ãƒ©ã‚¹ã‚¿ãƒªãƒ³ã‚°
gmm = GaussianMixture(n_components=n_clusters, random_state=42, covariance_type='full')
gmm.fit(data_scaled)
labels_gmm = gmm.predict(data_scaled)
labels_gmm_map = labels_gmm.reshape(s.data.shape[0], s.data.shape[1])

# æ‰€å±ç¢ºç‡ãƒãƒƒãƒ—
proba_gmm = gmm.predict_proba(data_scaled)
proba_gmm_maps = proba_gmm.reshape(s.data.shape[0], s.data.shape[1], n_clusters)

# å¯è¦–åŒ–
fig, axes = plt.subplots(2, 4, figsize=(18, 10))

# k-meansã‚¯ãƒ©ã‚¹ã‚¿ãƒãƒƒãƒ—
im0 = axes[0, 0].imshow(labels_kmeans_map, cmap='tab10', vmin=0, vmax=n_clusters-1)
axes[0, 0].set_title('k-means Cluster Map', fontsize=13, fontweight='bold')
axes[0, 0].axis('off')
plt.colorbar(im0, ax=axes[0, 0], ticks=range(n_clusters), fraction=0.046)

# k-meansã‚¯ãƒ©ã‚¹ã‚¿ä¸­å¿ƒã‚¹ãƒšã‚¯ãƒˆãƒ«
for i in range(n_clusters):
    axes[0, 1].plot(s.axes_manager[2].axis, cluster_centers[i], linewidth=2, label=f'Cluster {i}')
axes[0, 1].set_xlabel('Energy Loss [eV]', fontsize=11)
axes[0, 1].set_ylabel('Intensity [a.u.]', fontsize=11)
axes[0, 1].set_title('k-means Cluster Centers', fontsize=13, fontweight='bold')
axes[0, 1].legend(fontsize=10)
axes[0, 1].grid(alpha=0.3)
axes[0, 1].set_yscale('log')

# GMMã‚¯ãƒ©ã‚¹ã‚¿ãƒãƒƒãƒ—
im1 = axes[0, 2].imshow(labels_gmm_map, cmap='tab10', vmin=0, vmax=n_clusters-1)
axes[0, 2].set_title('GMM Cluster Map', fontsize=13, fontweight='bold')
axes[0, 2].axis('off')
plt.colorbar(im1, ax=axes[0, 2], ticks=range(n_clusters), fraction=0.046)

# GMMå¹³å‡ã‚¹ãƒšã‚¯ãƒˆãƒ«
gmm_means = scaler.inverse_transform(gmm.means_)
for i in range(n_clusters):
    axes[0, 3].plot(s.axes_manager[2].axis, gmm_means[i], linewidth=2, label=f'Component {i}')
axes[0, 3].set_xlabel('Energy Loss [eV]', fontsize=11)
axes[0, 3].set_ylabel('Intensity [a.u.]', fontsize=11)
axes[0, 3].set_title('GMM Component Means', fontsize=13, fontweight='bold')
axes[0, 3].legend(fontsize=10)
axes[0, 3].grid(alpha=0.3)
axes[0, 3].set_yscale('log')

# GMMæ‰€å±ç¢ºç‡ãƒãƒƒãƒ—ï¼ˆå„æˆåˆ†ï¼‰
for i in range(n_clusters):
    im = axes[1, i].imshow(proba_gmm_maps[:, :, i], cmap='viridis', vmin=0, vmax=1)
    axes[1, i].set_title(f'GMM Component {i}\nProbability Map', fontsize=12, fontweight='bold')
    axes[1, i].axis('off')
    plt.colorbar(im, ax=axes[1, i], fraction=0.046)

# æœ€å¾Œã®è»¸ã‚’ç©ºç™½ã«
axes[1, 3].axis('off')

plt.tight_layout()
plt.show()

# ã‚¯ãƒ©ã‚¹ã‚¿ãƒªãƒ³ã‚°å“è³ªè©•ä¾¡ï¼ˆã‚·ãƒ«ã‚¨ãƒƒãƒˆã‚¹ã‚³ã‚¢ï¼‰
from sklearn.metrics import silhouette_score

silhouette_kmeans = silhouette_score(data_scaled, labels_kmeans)
silhouette_gmm = silhouette_score(data_scaled, labels_gmm)

print(f"k-meansã‚·ãƒ«ã‚¨ãƒƒãƒˆã‚¹ã‚³ã‚¢: {silhouette_kmeans:.3f} (1ã«è¿‘ã„ã»ã©è‰¯å¥½)")
print(f"GMMã‚·ãƒ«ã‚¨ãƒƒãƒˆã‚¹ã‚³ã‚¢: {silhouette_gmm:.3f}")
print("\nGMMã®åˆ©ç‚¹: æ‰€å±ç¢ºç‡ã‚’å‡ºåŠ›ã™ã‚‹ãŸã‚ã€å¢ƒç•Œé ˜åŸŸã®è§£é‡ˆãŒå®¹æ˜“")
</code></pre>

        <h3>5.3.2 æ•™å¸«ã‚ã‚Šå­¦ç¿’ï¼ˆSVM, Random Forestï¼‰</h3>
        <p>æ—¢çŸ¥ã®ç›¸ã®ã‚¹ãƒšã‚¯ãƒˆãƒ«ã§å­¦ç¿’ã—ã€æœªçŸ¥é ˜åŸŸã‚’åˆ†é¡ã™ã‚‹æ‰‹æ³•ã€‚EDS/EELSã§å…ƒç´ æ¯”ãŒæ—¢çŸ¥ã®é ˜åŸŸã‚’ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°ãƒ‡ãƒ¼ã‚¿ã¨ã—ã¦ä½¿ç”¨ã—ã¾ã™ã€‚</p>

        <h4>ã‚³ãƒ¼ãƒ‰ä¾‹5-5: SVMã«ã‚ˆã‚‹ç›¸åˆ†é¡ï¼ˆæ•™å¸«ã‚ã‚Šï¼‰</h4>
        <pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
from sklearn.svm import SVC
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report, confusion_matrix
from sklearn.preprocessing import StandardScaler

# ãƒ€ãƒŸãƒ¼ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆï¼ˆæ˜ç¢ºãª2ç›¸ï¼‰
s = create_dummy_eels_si(size=64, energy_range=(400, 1000))

# æ‰‹å‹•ãƒ©ãƒ™ãƒªãƒ³ã‚°ï¼ˆå®Ÿéš›ã¯æ—¢çŸ¥é ˜åŸŸã‹ã‚‰ä½œæˆï¼‰
labels_true = np.zeros((64, 64), dtype=int)
labels_true[:, :32] = 0  # Phase A (Fe-rich)
labels_true[:, 32:] = 1  # Phase B (O-rich)

# ãƒ‡ãƒ¼ã‚¿æ•´å½¢
data_reshaped = s.data.reshape(-1, s.data.shape[2])
labels_flat = labels_true.flatten()

# ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°ãƒ‡ãƒ¼ã‚¿ã¨ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ã«åˆ†å‰²
X_train, X_test, y_train, y_test = train_test_split(
    data_reshaped, labels_flat, test_size=0.3, random_state=42, stratify=labels_flat
)

# æ¨™æº–åŒ–
scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)

# SVMå­¦ç¿’
svm = SVC(kernel='rbf', C=10, gamma='scale', random_state=42)
svm.fit(X_train_scaled, y_train)

# ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ã§è©•ä¾¡
y_pred = svm.predict(X_test_scaled)

# å…¨ãƒ‡ãƒ¼ã‚¿ã§äºˆæ¸¬
y_pred_all = svm.predict(scaler.transform(data_reshaped))
pred_map = y_pred_all.reshape(64, 64)

# å¯è¦–åŒ–
fig, axes = plt.subplots(2, 2, figsize=(12, 12))

# çœŸã®ãƒ©ãƒ™ãƒ«
im0 = axes[0, 0].imshow(labels_true, cmap='coolwarm', vmin=0, vmax=1)
axes[0, 0].set_title('True Labels\n(Ground Truth)', fontsize=13, fontweight='bold')
axes[0, 0].axis('off')
cbar0 = plt.colorbar(im0, ax=axes[0, 0], ticks=[0, 1], fraction=0.046)
cbar0.set_ticklabels(['Phase A', 'Phase B'])

# SVMäºˆæ¸¬ãƒ©ãƒ™ãƒ«
im1 = axes[0, 1].imshow(pred_map, cmap='coolwarm', vmin=0, vmax=1)
axes[0, 1].set_title('SVM Predicted Labels\n(RBF kernel)', fontsize=13, fontweight='bold')
axes[0, 1].axis('off')
cbar1 = plt.colorbar(im1, ax=axes[0, 1], ticks=[0, 1], fraction=0.046)
cbar1.set_ticklabels(['Phase A', 'Phase B'])

# æ··åŒè¡Œåˆ—
cm = confusion_matrix(y_test, y_pred)
im2 = axes[1, 0].imshow(cm, cmap='Blues', interpolation='nearest')
axes[1, 0].set_title('Confusion Matrix\n(Test Data)', fontsize=13, fontweight='bold')
axes[1, 0].set_xlabel('Predicted Label', fontsize=11)
axes[1, 0].set_ylabel('True Label', fontsize=11)
axes[1, 0].set_xticks([0, 1])
axes[1, 0].set_yticks([0, 1])
axes[1, 0].set_xticklabels(['Phase A', 'Phase B'])
axes[1, 0].set_yticklabels(['Phase A', 'Phase B'])

# æ··åŒè¡Œåˆ—ã®å€¤ã‚’è¡¨ç¤º
for i in range(2):
    for j in range(2):
        axes[1, 0].text(j, i, str(cm[i, j]), ha='center', va='center', fontsize=20, color='white' if cm[i, j] > cm.max()/2 else 'black')

plt.colorbar(im2, ax=axes[1, 0], fraction=0.046)

# åˆ†é¡ãƒ¬ãƒãƒ¼ãƒˆ
report = classification_report(y_test, y_pred, target_names=['Phase A', 'Phase B'], output_dict=True)

metrics = ['precision', 'recall', 'f1-score']
phase_a = [report['Phase A'][m] for m in metrics]
phase_b = [report['Phase B'][m] for m in metrics]

x = np.arange(len(metrics))
width = 0.35

axes[1, 1].bar(x - width/2, phase_a, width, label='Phase A', alpha=0.8)
axes[1, 1].bar(x + width/2, phase_b, width, label='Phase B', alpha=0.8)

axes[1, 1].set_xlabel('Metric', fontsize=11)
axes[1, 1].set_ylabel('Score', fontsize=11)
axes[1, 1].set_title('Classification Performance\n(Test Data)', fontsize=13, fontweight='bold')
axes[1, 1].set_xticks(x)
axes[1, 1].set_xticklabels(metrics)
axes[1, 1].legend(fontsize=10)
axes[1, 1].set_ylim(0, 1.1)
axes[1, 1].grid(alpha=0.3, axis='y')

plt.tight_layout()
plt.show()

print("åˆ†é¡ãƒ¬ãƒãƒ¼ãƒˆ:")
print(classification_report(y_test, y_pred, target_names=['Phase A', 'Phase B']))
print(f"ãƒ†ã‚¹ãƒˆç²¾åº¦: {svm.score(X_test_scaled, y_test):.3f}")
</code></pre>

        <h2>5.4 EBSDæ–¹ä½ãƒ‡ãƒ¼ã‚¿è§£æ</h2>

        <h3>5.4.1 orix/pyxemã«ã‚ˆã‚‹EBSDãƒ‡ãƒ¼ã‚¿å‡¦ç†</h3>
        <p><strong>orix</strong>ã¯ã€çµæ™¶æ–¹ä½ãƒ‡ãƒ¼ã‚¿ï¼ˆã‚ªã‚¤ãƒ©ãƒ¼è§’ã€å››å…ƒæ•°ã€å›è»¢è¡Œåˆ—ï¼‰ã‚’æ‰±ã†Pythonãƒ©ã‚¤ãƒ–ãƒ©ãƒªã§ã™ã€‚EBSDãƒ‡ãƒ¼ã‚¿ã®èª­è¾¼ã€æ–¹ä½è§£æã€çµæ™¶å­¦çš„çµ±è¨ˆå‡¦ç†ãŒå¯èƒ½ã§ã™ã€‚</p>

        <p><strong>ä¸»ãªæ©Ÿèƒ½</strong>ï¼š</p>
        <ul>
            <li>EBSDæ–¹ä½ãƒ‡ãƒ¼ã‚¿ã®èª­è¾¼ï¼ˆEDAX, Oxford, Brukerå½¢å¼ï¼‰</li>
            <li>æ–¹ä½è¡¨ç¾ã®å¤‰æ›ï¼ˆã‚ªã‚¤ãƒ©ãƒ¼è§’ã€å››å…ƒæ•°ã€å›è»¢è¡Œåˆ—ï¼‰</li>
            <li>å±€æ‰€æ–¹ä½å·®ï¼ˆKAM: Kernel Average Misorientationï¼‰è¨ˆç®—</li>
            <li>å¹¾ä½•å­¦çš„å¿…è¦è»¢ä½å¯†åº¦ï¼ˆGND: Geometrically Necessary Dislocationï¼‰æ¨å®š</li>
            <li>æ¥µç‚¹å›³ã€é€†æ¥µç‚¹å›³ã®ä½œæˆ</li>
        </ul>

        <h4>ã‚³ãƒ¼ãƒ‰ä¾‹5-6: KAMï¼ˆå±€æ‰€æ–¹ä½å·®ï¼‰ãƒãƒƒãƒ—ã®ä½œæˆ</h4>
        <pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
from scipy.ndimage import convolve

def generate_dummy_ebsd_data(size=128, num_grains=20):
    """
    ãƒ€ãƒŸãƒ¼EBSDãƒ‡ãƒ¼ã‚¿ç”Ÿæˆï¼ˆæ–¹ä½ãƒãƒƒãƒ—ï¼‰

    Parameters
    ----------
    size : int
        ãƒãƒƒãƒ—ã‚µã‚¤ã‚º [pixels]
    num_grains : int
        çµæ™¶ç²’æ•°

    Returns
    -------
    euler_map : ndarray
        ã‚ªã‚¤ãƒ©ãƒ¼è§’ãƒãƒƒãƒ— (size, size, 3) [degrees]
    grain_map : ndarray
        çµæ™¶ç²’IDãƒãƒƒãƒ— (size, size)
    """
    from scipy.spatial import Voronoi
    from scipy.spatial.distance import cdist

    # ãƒœãƒ­ãƒã‚¤åˆ†å‰²ã§çµæ™¶ç²’ç”Ÿæˆ
    np.random.seed(42)
    points = np.random.rand(num_grains, 2) * size

    x, y = np.meshgrid(np.arange(size), np.arange(size))
    pixels = np.stack([x.ravel(), y.ravel()], axis=1)

    distances = cdist(pixels, points)
    grain_map = np.argmin(distances, axis=1).reshape(size, size)

    # å„çµæ™¶ç²’ã«ãƒ©ãƒ³ãƒ€ãƒ ãªæ–¹ä½ã‚’å‰²ã‚Šå½“ã¦
    euler_angles_grains = np.random.rand(num_grains, 3) * [360, 180, 360]

    euler_map = np.zeros((size, size, 3))
    for grain_id in range(num_grains):
        mask = grain_map == grain_id
        euler_map[mask] = euler_angles_grains[grain_id]

    # ç²’ç•Œè¿‘å‚ã«æ ¼å­å›è»¢å‹¾é…ã‚’è¿½åŠ ï¼ˆè»¢ä½è“„ç©ï¼‰
    from scipy.ndimage import distance_transform_edt, binary_erosion

    for grain_id in range(num_grains):
        mask = grain_map == grain_id
        # ç²’ç•Œã¾ã§ã®è·é›¢
        dist = distance_transform_edt(mask)
        # ç²’ç•Œè¿‘å‚ï¼ˆ3ãƒ”ã‚¯ã‚»ãƒ«ä»¥å†…ï¼‰ã§å›è»¢ã‚’è¿½åŠ 
        boundary_zone = (dist > 0) & (dist < 3)
        if np.sum(boundary_zone) > 0:
            rotation_gradient = np.random.rand() * 5  # æœ€å¤§5åº¦ã®å›è»¢
            euler_map[boundary_zone, 0] += rotation_gradient * (3 - dist[boundary_zone]) / 3

    return euler_map, grain_map

def calculate_kam(euler_map, max_misorientation=5):
    """
    KAM (Kernel Average Misorientation) ã‚’è¨ˆç®—

    Parameters
    ----------
    euler_map : ndarray
        ã‚ªã‚¤ãƒ©ãƒ¼è§’ãƒãƒƒãƒ— (H, W, 3) [degrees]
    max_misorientation : float
        KAMè¨ˆç®—ã«å«ã‚ã‚‹æœ€å¤§æ–¹ä½å·® [degrees]

    Returns
    -------
    kam_map : ndarray
        KAMãƒãƒƒãƒ— (H, W) [degrees]
    """
    h, w = euler_map.shape[:2]
    kam_map = np.zeros((h, w))

    # æœ€è¿‘å‚8ãƒ”ã‚¯ã‚»ãƒ«ã¨ã®æ–¹ä½å·®ã‚’è¨ˆç®—ï¼ˆç°¡ç•¥ç‰ˆï¼‰
    for i in range(1, h-1):
        for j in range(1, w-1):
            center_euler = euler_map[i, j]

            # æœ€è¿‘å‚ã®ã‚ªã‚¤ãƒ©ãƒ¼è§’
            neighbors = [
                euler_map[i-1, j], euler_map[i+1, j],
                euler_map[i, j-1], euler_map[i, j+1],
                euler_map[i-1, j-1], euler_map[i-1, j+1],
                euler_map[i+1, j-1], euler_map[i+1, j+1]
            ]

            misorientations = []
            for neighbor in neighbors:
                # ç°¡ç•¥çš„ãªæ–¹ä½å·®è¨ˆç®—ï¼ˆå®Ÿéš›ã¯ãƒ­ãƒ‰ãƒªã‚²ã‚¹ãƒ™ã‚¯ãƒˆãƒ«ã§è¨ˆç®—ï¼‰
                diff = np.abs(neighbor - center_euler)
                # ã‚ªã‚¤ãƒ©ãƒ¼è§’ã®å‘¨æœŸæ€§ã‚’è€ƒæ…®
                diff[0] = min(diff[0], 360 - diff[0])
                diff[1] = min(diff[1], 180 - diff[1])
                diff[2] = min(diff[2], 360 - diff[2])

                # ãƒãƒ«ãƒ ï¼ˆç°¡ç•¥ç‰ˆï¼‰
                misorientation = np.linalg.norm(diff)

                if misorientation < max_misorientation:
                    misorientations.append(misorientation)

            if len(misorientations) > 0:
                kam_map[i, j] = np.mean(misorientations)

    return kam_map

# ãƒ€ãƒŸãƒ¼ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆ
euler_map, grain_map = generate_dummy_ebsd_data(size=128, num_grains=20)

# KAMè¨ˆç®—
kam_map = calculate_kam(euler_map, max_misorientation=5)

# å¯è¦–åŒ–
fig, axes = plt.subplots(2, 2, figsize=(14, 14))

# çµæ™¶ç²’ãƒãƒƒãƒ—
im0 = axes[0, 0].imshow(grain_map, cmap='tab20')
axes[0, 0].set_title('Grain Map\n(Voronoi tessellation)', fontsize=13, fontweight='bold')
axes[0, 0].axis('off')

# ã‚ªã‚¤ãƒ©ãƒ¼è§’ãƒãƒƒãƒ—ï¼ˆÏ†1ã®ã¿è¡¨ç¤ºï¼‰
im1 = axes[0, 1].imshow(euler_map[:, :, 0], cmap='hsv', vmin=0, vmax=360)
axes[0, 1].set_title('Euler Angle Ï†1 Map\n(Crystal Orientation)', fontsize=13, fontweight='bold')
axes[0, 1].axis('off')
cbar1 = plt.colorbar(im1, ax=axes[0, 1], fraction=0.046)
cbar1.set_label('Ï†1 [degrees]', fontsize=10)

# KAMãƒãƒƒãƒ—
im2 = axes[1, 0].imshow(kam_map, cmap='jet', vmin=0, vmax=3)
axes[1, 0].set_title('KAM Map\n(Local Misorientation)', fontsize=13, fontweight='bold')
axes[1, 0].axis('off')
cbar2 = plt.colorbar(im2, ax=axes[1, 0], fraction=0.046)
cbar2.set_label('KAM [degrees]', fontsize=10)

# KAMãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ 
kam_flat = kam_map[kam_map > 0].flatten()

axes[1, 1].hist(kam_flat, bins=50, alpha=0.7, edgecolor='black')
axes[1, 1].axvline(np.mean(kam_flat), color='red', linestyle='--', linewidth=2, label=f'Mean: {np.mean(kam_flat):.2f}Â°')
axes[1, 1].axvline(np.median(kam_flat), color='blue', linestyle='--', linewidth=2, label=f'Median: {np.median(kam_flat):.2f}Â°')
axes[1, 1].set_xlabel('KAM [degrees]', fontsize=12)
axes[1, 1].set_ylabel('Frequency', fontsize=12)
axes[1, 1].set_title('KAM Distribution', fontsize=13, fontweight='bold')
axes[1, 1].legend(fontsize=11)
axes[1, 1].grid(alpha=0.3, axis='y')

plt.tight_layout()
plt.show()

print("KAMè§£é‡ˆ:")
print(f"  å¹³å‡KAM: {np.mean(kam_flat):.3f}Â°")
print(f"  é«˜KAMé ˜åŸŸï¼ˆ>2Â°ï¼‰: è»¢ä½å¯†åº¦ãŒé«˜ã„ã€å¤‰å½¢é ˜åŸŸ")
print(f"  ä½KAMé ˜åŸŸï¼ˆ<1Â°ï¼‰: å†çµæ™¶ç²’ã€å›å¾©çµ„ç¹”")
</code></pre>

        <h3>5.4.2 GNDï¼ˆå¹¾ä½•å­¦çš„å¿…è¦è»¢ä½ï¼‰å¯†åº¦æ¨å®š</h3>
        <p>å±€æ‰€çš„ãªæ ¼å­æ›²ç‡ã‹ã‚‰ã€å¹¾ä½•å­¦çš„ã«å¿…è¦ãªè»¢ä½å¯†åº¦ã‚’æ¨å®šã—ã¾ã™ã€‚Nye tensorã‹ã‚‰è¨ˆç®—ã•ã‚Œã¾ã™ã€‚</p>

        <h4>ã‚³ãƒ¼ãƒ‰ä¾‹5-7: GNDå¯†åº¦ãƒãƒƒãƒ—ã®ç°¡æ˜“è¨ˆç®—</h4>
        <pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
from scipy.ndimage import sobel

def estimate_gnd_density(euler_map, step_size=0.1):
    """
    GND (Geometrically Necessary Dislocation) å¯†åº¦ã‚’æ¨å®š

    Parameters
    ----------
    euler_map : ndarray
        ã‚ªã‚¤ãƒ©ãƒ¼è§’ãƒãƒƒãƒ— (H, W, 3) [degrees]
    step_size : float
        ãƒ”ã‚¯ã‚»ãƒ«é–“ã®ç‰©ç†è·é›¢ [Î¼m]

    Returns
    -------
    gnd_density : ndarray
        GNDå¯†åº¦ãƒãƒƒãƒ— (H, W) [m^-2]
    """
    # ç°¡ç•¥ç‰ˆ: æ–¹ä½å‹¾é…ã‹ã‚‰Nye tensorã®å¯¾è§’æˆåˆ†ã‚’æ¨å®š

    # ã‚ªã‚¤ãƒ©ãƒ¼è§’ã‚’ãƒ©ã‚¸ã‚¢ãƒ³ã«å¤‰æ›
    euler_rad = np.deg2rad(euler_map)

    # Ï†1ã®å‹¾é…ï¼ˆå›è»¢å‹¾é…ã®ä»£ç†æŒ‡æ¨™ï¼‰
    grad_x = sobel(euler_rad[:, :, 0], axis=1, mode='reflect')
    grad_y = sobel(euler_rad[:, :, 0], axis=0, mode='reflect')

    # æ›²ç‡ã®å¤§ãã•
    curvature = np.sqrt(grad_x**2 + grad_y**2)

    # Burger's vectorã®å¤§ãã•ï¼ˆAl FCC: b â‰ˆ 0.286 nmï¼‰
    b = 0.286e-9  # [m]

    # GNDå¯†åº¦ Ï = Îº / b ï¼ˆç°¡ç•¥å¼ï¼‰
    # æ›²ç‡ã‚’ç‰©ç†å˜ä½ã«å¤‰æ›ï¼ˆrad/pixel â†’ rad/Î¼mï¼‰
    curvature_per_um = curvature / (step_size * 1e-6)  # [rad/m]

    gnd_density = curvature_per_um / b  # [m^-2]

    return gnd_density

# å‰ä¾‹ã®EBSDãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ç”¨
euler_map, grain_map = generate_dummy_ebsd_data(size=128, num_grains=20)

# GNDå¯†åº¦æ¨å®š
gnd_density = estimate_gnd_density(euler_map, step_size=0.1)  # 0.1 Î¼m/pixel

# å¯è¦–åŒ–
fig, axes = plt.subplots(2, 2, figsize=(14, 14))

# çµæ™¶ç²’ãƒãƒƒãƒ—
im0 = axes[0, 0].imshow(grain_map, cmap='tab20')
axes[0, 0].set_title('Grain Map', fontsize=13, fontweight='bold')
axes[0, 0].axis('off')

# KAMãƒãƒƒãƒ—
kam_map = calculate_kam(euler_map, max_misorientation=5)
im1 = axes[0, 1].imshow(kam_map, cmap='jet', vmin=0, vmax=3)
axes[0, 1].set_title('KAM Map\n(Local Misorientation)', fontsize=13, fontweight='bold')
axes[0, 1].axis('off')
cbar1 = plt.colorbar(im1, ax=axes[0, 1], fraction=0.046)
cbar1.set_label('KAM [degrees]', fontsize=10)

# GNDå¯†åº¦ãƒãƒƒãƒ—
gnd_log = np.log10(gnd_density + 1e12)  # å¯¾æ•°ã‚¹ã‚±ãƒ¼ãƒ«ï¼ˆã‚¼ãƒ­é™¤ç®—å›é¿ï¼‰
im2 = axes[1, 0].imshow(gnd_log, cmap='viridis', vmin=12, vmax=15)
axes[1, 0].set_title('GND Density Map\n(Log scale)', fontsize=13, fontweight='bold')
axes[1, 0].axis('off')
cbar2 = plt.colorbar(im2, ax=axes[1, 0], fraction=0.046)
cbar2.set_label('logâ‚â‚€(Ï [mâ»Â²])', fontsize=10)

# KAM vs GNDæ•£å¸ƒå›³
kam_flat = kam_map[kam_map > 0].flatten()
gnd_flat = gnd_density[kam_map > 0].flatten()

axes[1, 1].scatter(kam_flat, gnd_flat, alpha=0.3, s=10)
axes[1, 1].set_xlabel('KAM [degrees]', fontsize=12)
axes[1, 1].set_ylabel('GND Density [mâ»Â²]', fontsize=12)
axes[1, 1].set_title('KAM vs GND Correlation', fontsize=13, fontweight='bold')
axes[1, 1].set_yscale('log')
axes[1, 1].grid(alpha=0.3)

# ç›¸é–¢ä¿‚æ•°
correlation = np.corrcoef(kam_flat, np.log10(gnd_flat + 1e12))[0, 1]
axes[1, 1].text(0.05, 0.95, f'Correlation: {correlation:.3f}',
                transform=axes[1, 1].transAxes, fontsize=11,
                verticalalignment='top', bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.5))

plt.tight_layout()
plt.show()

print("GNDå¯†åº¦ã®è§£é‡ˆ:")
print(f"  å…¸å‹çš„ç¯„å›²: 10^12 ã€œ 10^15 m^-2")
print(f"  10^12-10^13 m^-2: ç„¼éˆæã€ä½å¤‰å½¢")
print(f"  10^14-10^15 m^-2: å†·é–“åŠ å·¥æã€é«˜å¤‰å½¢")
print(f"  ç²’ç•Œè¿‘å‚ã§GNDå¯†åº¦ãŒé«˜ã„: æ ¼å­æ›²ç‡ãŒå¤§ãã„")
</code></pre>

        <h2>5.5 æ¼”ç¿’å•é¡Œ</h2>

        <h3>æ¼”ç¿’5-1: HyperSpyåŸºæœ¬æ“ä½œï¼ˆæ˜“ï¼‰</h3>
        <p><strong>å•é¡Œ</strong>ï¼šHyperSpyã§èª­ã¿è¾¼ã‚“ã EELSãƒ‡ãƒ¼ã‚¿ã®å¹³å‡ã‚¹ãƒšã‚¯ãƒˆãƒ«ã‚’è¨ˆç®—ã—ã€700 eVä»˜è¿‘ã®ãƒ”ãƒ¼ã‚¯å¼·åº¦ã‚’æŠ½å‡ºã›ã‚ˆã€‚</p>

        <details>
            <summary><strong>è§£ç­”ä¾‹ã‚’è¡¨ç¤º</strong></summary>
            <pre><code class="language-python">import hyperspy.api as hs
import numpy as np

# ãƒ‡ãƒ¼ã‚¿èª­è¾¼ï¼ˆå®Ÿéš›ã®ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã«ç½®ãæ›ãˆï¼‰
# s = hs.load('my_eels_data.hspy')

# ãƒ€ãƒŸãƒ¼ãƒ‡ãƒ¼ã‚¿ã§ä»£æ›¿
s = create_dummy_eels_si(size=64, energy_range=(400, 1000))

# å¹³å‡ã‚¹ãƒšã‚¯ãƒˆãƒ«
s_mean = s.mean()

# 700 eVä»˜è¿‘ã®å¼·åº¦æŠ½å‡º
energy_axis = s_mean.axes_manager[0].axis
idx_700 = np.argmin(np.abs(energy_axis - 700))
intensity_700 = s_mean.data[idx_700]

print(f"700 eVä»˜è¿‘ã®å¼·åº¦: {intensity_700:.1f} counts")
print(f"æ­£ç¢ºãªã‚¨ãƒãƒ«ã‚®ãƒ¼: {energy_axis[idx_700]:.1f} eV")
</code></pre>
        </details>

        <h3>æ¼”ç¿’5-2: PCAæˆåˆ†æ•°ã®æ±ºå®šï¼ˆæ˜“ï¼‰</h3>
        <p><strong>å•é¡Œ</strong>ï¼šPCAã§ç´¯ç©å¯„ä¸ç‡ãŒ95%ã‚’è¶…ãˆã‚‹ãŸã‚ã«å¿…è¦ãªä¸»æˆåˆ†æ•°ã‚’æ±‚ã‚ã‚ˆã€‚</p>

        <details>
            <summary><strong>è§£ç­”ä¾‹ã‚’è¡¨ç¤º</strong></summary>
            <pre><code class="language-python">import numpy as np

# PCAå®Ÿè¡Œ
s = create_dummy_eels_si(size=64, energy_range=(400, 1000))
s.decomposition(algorithm='PCA', output_dimension=20)

# ç´¯ç©å¯„ä¸ç‡
variance_ratio = s.get_explained_variance_ratio().data
cumsum = np.cumsum(variance_ratio)

# 95%ã‚’è¶…ãˆã‚‹æœ€å°æˆåˆ†æ•°
n_components_95 = np.argmax(cumsum >= 0.95) + 1

print(f"ç´¯ç©å¯„ä¸ç‡95%ã«å¿…è¦ãªä¸»æˆåˆ†æ•°: {n_components_95}")
print(f"ä¸Šä½{n_components_95}æˆåˆ†ã®ç´¯ç©å¯„ä¸ç‡: {cumsum[n_components_95-1]:.3f}")
</code></pre>
        </details>

        <h3>æ¼”ç¿’5-3: ã‚¯ãƒ©ã‚¹ã‚¿æ•°ã®æœ€é©åŒ–ï¼ˆä¸­ï¼‰</h3>
        <p><strong>å•é¡Œ</strong>ï¼šk-meansã§ã‚¯ãƒ©ã‚¹ã‚¿æ•°ã‚’2ã€œ10ã«å¤‰åŒ–ã•ã›ã€ã‚¨ãƒ«ãƒœãƒ¼æ³•ï¼ˆæ…£æ€§ï¼‰ã¨ã‚·ãƒ«ã‚¨ãƒƒãƒˆã‚¹ã‚³ã‚¢ã§æœ€é©ãªã‚¯ãƒ©ã‚¹ã‚¿æ•°ã‚’æ±ºå®šã›ã‚ˆã€‚</p>

        <details>
            <summary><strong>è§£ç­”ä¾‹ã‚’è¡¨ç¤º</strong></summary>
            <pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
from sklearn.cluster import KMeans
from sklearn.metrics import silhouette_score
from sklearn.preprocessing import StandardScaler

s = create_dummy_eels_si(size=64, energy_range=(400, 1000))
data_reshaped = s.data.reshape(-1, s.data.shape[2])

scaler = StandardScaler()
data_scaled = scaler.fit_transform(data_reshaped)

# ã‚¯ãƒ©ã‚¹ã‚¿æ•°ã‚’å¤‰åŒ–ã•ã›ã¦è©•ä¾¡
K_range = range(2, 11)
inertias = []
silhouettes = []

for k in K_range:
    kmeans = KMeans(n_clusters=k, random_state=42, n_init=10)
    labels = kmeans.fit_predict(data_scaled)

    inertias.append(kmeans.inertia_)
    silhouettes.append(silhouette_score(data_scaled, labels))

# å¯è¦–åŒ–
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 5))

# ã‚¨ãƒ«ãƒœãƒ¼ãƒ—ãƒ­ãƒƒãƒˆ
ax1.plot(K_range, inertias, 'bo-', linewidth=2, markersize=8)
ax1.set_xlabel('Number of Clusters', fontsize=12)
ax1.set_ylabel('Inertia (Within-cluster sum of squares)', fontsize=12)
ax1.set_title('Elbow Method', fontsize=14, fontweight='bold')
ax1.grid(alpha=0.3)

# ã‚·ãƒ«ã‚¨ãƒƒãƒˆã‚¹ã‚³ã‚¢
ax2.plot(K_range, silhouettes, 'go-', linewidth=2, markersize=8)
ax2.set_xlabel('Number of Clusters', fontsize=12)
ax2.set_ylabel('Silhouette Score', fontsize=12)
ax2.set_title('Silhouette Analysis', fontsize=14, fontweight='bold')
ax2.grid(alpha=0.3)

optimal_k = K_range[np.argmax(silhouettes)]
ax2.axvline(optimal_k, color='red', linestyle='--', linewidth=2,
            label=f'Optimal k={optimal_k}')
ax2.legend(fontsize=11)

plt.tight_layout()
plt.show()

print(f"ã‚·ãƒ«ã‚¨ãƒƒãƒˆã‚¹ã‚³ã‚¢ãŒæœ€å¤§ã¨ãªã‚‹ã‚¯ãƒ©ã‚¹ã‚¿æ•°: {optimal_k}")
</code></pre>
        </details>

        <h3>æ¼”ç¿’5-4: EELSãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰é™¤å»ï¼ˆä¸­ï¼‰</h3>
        <p><strong>å•é¡Œ</strong>ï¼šO-K edgeï¼ˆ532 eVï¼‰ã®EELSã‚¹ãƒšã‚¯ãƒˆãƒ«ã§ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰é™¤å»ã‚’è¡Œã„ã€ç©åˆ†å¼·åº¦ã‚’è¨ˆç®—ã›ã‚ˆã€‚ãƒ•ã‚£ãƒƒãƒˆç¯„å›²ã¯480-520 eVã€ç©åˆ†çª“ã¯532-582 eVã¨ã™ã‚‹ã€‚</p>

        <details>
            <summary><strong>è§£ç­”ä¾‹ã‚’è¡¨ç¤º</strong></summary>
            <pre><code class="language-python">import hyperspy.api as hs
import numpy as np

s = create_dummy_eels_si(size=64, energy_range=(400, 1000))
s_point = s.inav[50, 32]  # O-riché ˜åŸŸ

# ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰é™¤å»
edge_onset = 532
fit_range = (480, 520)
s_bg_removed = s_point.remove_background(
    signal_range=fit_range,
    background_type='PowerLaw',
    fast=False
)

# ç©åˆ†
integration_window = (532, 582)
energy_axis = s_bg_removed.axes_manager[0].axis
mask = (energy_axis >= integration_window[0]) & (energy_axis <= integration_window[1])
integrated_intensity = np.trapz(s_bg_removed.data[mask], energy_axis[mask])

print(f"O-K edgeç©åˆ†å¼·åº¦: {integrated_intensity:.1f} counts")
</code></pre>
        </details>

        <h3>æ¼”ç¿’5-5: ICA vs PCAï¼ˆä¸­ï¼‰</h3>
        <p><strong>å•é¡Œ</strong>ï¼šPCAã¨ICAã§ä¸Šä½3æˆåˆ†ã®ã‚¹ãƒšã‚¯ãƒˆãƒ«ã‚’æŠ½å‡ºã—ã€ã©ã¡ã‚‰ãŒç‰©ç†çš„ã«è§£é‡ˆã—ã‚„ã™ã„ã‹ã€ç†ç”±ã¨ã¨ã‚‚ã«ç­”ãˆã‚ˆã€‚</p>

        <details>
            <summary><strong>è§£ç­”ä¾‹ã‚’è¡¨ç¤º</strong></summary>
            <p><strong>å®Ÿè£…</strong>ï¼šã‚³ãƒ¼ãƒ‰ä¾‹5-3å‚ç…§ã€‚</p>
            <p><strong>æ¯”è¼ƒ</strong>ï¼š</p>
            <ul>
                <li><strong>PCA</strong>ï¼šç¬¬1ä¸»æˆåˆ†ã¯å¹³å‡ã‚¹ãƒšã‚¯ãƒˆãƒ«ã«è¿‘ãã€ç¬¬2æˆåˆ†ä»¥é™ã¯å·®åˆ†ï¼ˆæ®‹å·®ï¼‰ã‚’è¡¨ç¾ã€‚æ•°å­¦çš„ã«æœ€é©ã ãŒã€ç‰©ç†çš„æ„å‘³ãŒä¸æ˜ç­</li>
                <li><strong>ICA</strong>ï¼šçµ±è¨ˆçš„ã«ç‹¬ç«‹ãªæˆåˆ†ã‚’æŠ½å‡ºã€‚å„æˆåˆ†ãŒç‰¹å®šã®ç›¸ã‚„ã‚¨ãƒƒã‚¸ã«å¯¾å¿œã—ã‚„ã™ãã€ç‰©ç†çš„è§£é‡ˆãŒå®¹æ˜“</li>
                <li><strong>çµè«–</strong>ï¼šç›¸åˆ†é›¢ã‚„ã‚¨ãƒƒã‚¸åˆ†é›¢ã«ã¯ICAãŒæœ‰åŠ¹ã€‚ãŸã ã—PCAã‚’å‰å‡¦ç†ã¨ã—ã¦ä½¿ç”¨ã™ã‚‹ã®ãŒä¸€èˆ¬çš„</li>
            </ul>
        </details>

        <h3>æ¼”ç¿’5-6: SVM vs Random Forestï¼ˆä¸­ï¼‰</h3>
        <p><strong>å•é¡Œ</strong>ï¼šSVMã¨Random Forestã§åŒã˜EELSãƒ‡ãƒ¼ã‚¿ã‚’åˆ†é¡ã—ã€ç²¾åº¦ã€è¨ˆç®—æ™‚é–“ã€éå­¦ç¿’ã®ãƒªã‚¹ã‚¯ã‚’æ¯”è¼ƒã›ã‚ˆã€‚</p>

        <details>
            <summary><strong>è§£ç­”ä¾‹ã‚’è¡¨ç¤º</strong></summary>
            <pre><code class="language-python">import time
from sklearn.svm import SVC
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import cross_val_score

s = create_dummy_eels_si(size=64, energy_range=(400, 1000))
data_reshaped = s.data.reshape(-1, s.data.shape[2])

labels_true = np.zeros(64*64, dtype=int)
labels_true[32*64:] = 1

from sklearn.preprocessing import StandardScaler
scaler = StandardScaler()
data_scaled = scaler.fit_transform(data_reshaped)

# SVM
start = time.time()
svm = SVC(kernel='rbf', C=10, gamma='scale')
scores_svm = cross_val_score(svm, data_scaled, labels_true, cv=5)
time_svm = time.time() - start

# Random Forest
start = time.time()
rf = RandomForestClassifier(n_estimators=100, random_state=42)
scores_rf = cross_val_score(rf, data_scaled, labels_true, cv=5)
time_rf = time.time() - start

print(f"SVM ç²¾åº¦: {scores_svm.mean():.3f} Â± {scores_svm.std():.3f}, æ™‚é–“: {time_svm:.2f}ç§’")
print(f"Random Forest ç²¾åº¦: {scores_rf.mean():.3f} Â± {scores_rf.std():.3f}, æ™‚é–“: {time_rf:.2f}ç§’")
print("\næ¯”è¼ƒ:")
print("  SVM: é«˜ç²¾åº¦ã€ä¸­ã€œé«˜è¨ˆç®—ã‚³ã‚¹ãƒˆã€éå­¦ç¿’ãƒªã‚¹ã‚¯ä¸­")
print("  Random Forest: é«˜ç²¾åº¦ã€ä¸¦åˆ—åŒ–å¯èƒ½ã€éå­¦ç¿’ã«é ‘å¥ã€ç‰¹å¾´é‡é‡è¦åº¦ãŒå¾—ã‚‰ã‚Œã‚‹")
</code></pre>
        </details>

        <h3>æ¼”ç¿’5-7: KAMã®ç‰©ç†çš„æ„å‘³ï¼ˆæ˜“ï¼‰</h3>
        <p><strong>å•é¡Œ</strong>ï¼šKAMå€¤ãŒé«˜ã„é ˜åŸŸã¯ä½•ã‚’ç¤ºå”†ã™ã‚‹ã‹ã€è»¢ä½å¯†åº¦ã¨ã®é–¢ä¿‚ã‚’å«ã‚ã¦èª¬æ˜ã›ã‚ˆã€‚</p>

        <details>
            <summary><strong>è§£ç­”ä¾‹ã‚’è¡¨ç¤º</strong></summary>
            <p><strong>é«˜KAMé ˜åŸŸã®ç‰©ç†çš„æ„å‘³</strong>ï¼š</p>
            <ul>
                <li>å±€æ‰€çš„ãªæ ¼å­å›è»¢ãŒå¤§ãã„ â†’ è»¢ä½ãŒè“„ç©ã—ã¦ã„ã‚‹</li>
                <li>KAM > 2Â°ï¼šå†·é–“åŠ å·¥ã€å¡‘æ€§å¤‰å½¢ã€ç²’ç•Œè¿‘å‚</li>
                <li>KAM < 1Â°ï¼šå†çµæ™¶ç²’ã€å›å¾©çµ„ç¹”ã€ä½æ­ªé ˜åŸŸ</li>
                <li><strong>è»¢ä½å¯†åº¦ã¨ã®é–¢ä¿‚</strong>ï¼šKAMã¯æ ¼å­æ›²ç‡ã‚’åæ˜ ã—ã€æ›²ç‡ã¯å¹¾ä½•å­¦çš„å¿…è¦è»¢ä½ï¼ˆGNDï¼‰å¯†åº¦ã«æ¯”ä¾‹ã™ã‚‹ã€‚ã—ãŸãŒã£ã¦ã€é«˜KAM = é«˜GNDå¯†åº¦ = é«˜è»¢ä½å¯†åº¦</li>
            </ul>
        </details>

        <h3>æ¼”ç¿’5-8: çµ±åˆè§£æãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ï¼ˆé›£ï¼‰</h3>
        <p><strong>å•é¡Œ</strong>ï¼šFe-Cråˆé‡‘ã®STEM-EELSã¨EBSDãƒ‡ãƒ¼ã‚¿ã‚’çµ±åˆè§£æã™ã‚‹è¨ˆç”»ã‚’ç«‹æ¡ˆã›ã‚ˆã€‚æ‰‹é †ã€æœŸå¾…ã•ã‚Œã‚‹çµæœã€æŠ€è¡“çš„èª²é¡Œã‚’å«ã‚ã‚‹ã“ã¨ã€‚</p>

        <details>
            <summary><strong>è§£ç­”ä¾‹ã‚’è¡¨ç¤º</strong></summary>
            <p><strong>çµ±åˆè§£æãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼</strong>ï¼š</p>
            <ol>
                <li><strong>STEM-EELSå–å¾—</strong>ï¼š
                    <ul>
                        <li>åŒä¸€è©¦æ–™ã§STEM-HAADFã¨EELSãƒãƒƒãƒ”ãƒ³ã‚°</li>
                        <li>Fe-L2,3ã€Cr-L2,3ã‚¨ãƒƒã‚¸ã®ãƒãƒƒãƒ”ãƒ³ã‚°ï¼ˆç©ºé–“åˆ†è§£èƒ½<10 nmï¼‰</li>
                        <li>HyperSpyã§PCA/ICAåˆ†æ â†’ ç›¸åˆ†é›¢</li>
                    </ul>
                </li>
                <li><strong>EBSDå–å¾—</strong>ï¼š
                    <ul>
                        <li>SEMã§EBSDãƒãƒƒãƒ”ãƒ³ã‚°ï¼ˆåŒä¸€é ˜åŸŸã€ã‚¹ãƒ†ãƒƒãƒ—ã‚µã‚¤ã‚º<0.5 Î¼mï¼‰</li>
                        <li>orixã§æ–¹ä½è§£æã€KAMã€GNDå¯†åº¦è¨ˆç®—</li>
                    </ul>
                </li>
                <li><strong>ç©ºé–“ç›¸é–¢è§£æ</strong>ï¼š
                    <ul>
                        <li>ç”»åƒãƒ¬ã‚¸ã‚¹ãƒˆãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆSIFT/ORBã§ç‰¹å¾´ç‚¹ãƒãƒƒãƒãƒ³ã‚°ï¼‰</li>
                        <li>å…ƒç´ æ¿ƒåº¦ã¨KAMã®ç©ºé–“çš„ç›¸é–¢ã‚’è©•ä¾¡</li>
                        <li>Cræ¿ƒåŒ–é ˜åŸŸã¨é«˜KAMé ˜åŸŸã®é‡ãªã‚Šã‚’çµ±è¨ˆçš„ã«æ¤œè¨¼</li>
                    </ul>
                </li>
                <li><strong>æ©Ÿæ¢°å­¦ç¿’çµ±åˆ</strong>ï¼š
                    <ul>
                        <li>EELSã‚¹ãƒšã‚¯ãƒˆãƒ«ï¼ˆç‰¹å¾´é‡ï¼šFe/Cræ¯”ï¼‰ã¨EBSDæ–¹ä½ï¼ˆç‰¹å¾´é‡ï¼šKAMã€GNDï¼‰ã‚’çµ±åˆç‰¹å¾´ãƒ™ã‚¯ãƒˆãƒ«ã«</li>
                        <li>Random Forestã§ç›¸åˆ†é¡ï¼ˆÎ±ç›¸ã€Ïƒç›¸ã€Ï‡ç›¸ãªã©ï¼‰</li>
                        <li>ç›¸åˆ†é¡ãƒãƒƒãƒ—ã¨è»¢ä½æ§‹é€ ã®é–¢ä¿‚ã‚’è§£æ˜</li>
                    </ul>
                </li>
            </ol>
            <p><strong>æŠ€è¡“çš„èª²é¡Œ</strong>ï¼š</p>
            <ul>
                <li><strong>ç©ºé–“åˆ†è§£èƒ½ã®ãƒŸã‚¹ãƒãƒƒãƒ</strong>ï¼šSTEMï¼ˆ<10 nmï¼‰ã¨EBSDï¼ˆ>100 nmï¼‰ã®åˆ†è§£èƒ½å·® â†’ å¯¾ç­–ï¼šå¤šé‡ã‚¹ã‚±ãƒ¼ãƒ«è§£æã€éšå±¤çš„ãƒ¢ãƒ‡ãƒªãƒ³ã‚°</li>
                <li><strong>è©¦æ–™ãƒ€ãƒ¡ãƒ¼ã‚¸</strong>ï¼šEELSæ¸¬å®šã§ãƒ“ãƒ¼ãƒ æå‚· â†’ å¯¾ç­–ï¼šä½ãƒ‰ãƒ¼ã‚ºæ¸¬å®šã€ã‚¯ãƒ©ã‚¤ã‚ªå†·å´</li>
                <li><strong>ãƒ‡ãƒ¼ã‚¿ãƒ¬ã‚¸ã‚¹ãƒˆãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³</strong>ï¼šç•°ãªã‚‹è£…ç½®ã§ã®ä½ç½®åˆã‚ã› â†’ å¯¾ç­–ï¼šé‡‘ãƒãƒ¼ã‚«ãƒ¼ã€è‡ªå‹•ç‰¹å¾´ç‚¹æŠ½å‡º</li>
            </ul>
        </details>

        <h3>æ¼”ç¿’5-9: GNDå¯†åº¦ã®å¦¥å½“æ€§æ¤œè¨¼ï¼ˆé›£ï¼‰</h3>
        <p><strong>å•é¡Œ</strong>ï¼šè¨ˆç®—ã—ãŸGNDå¯†åº¦ãŒç‰©ç†çš„ã«å¦¥å½“ã‹æ¤œè¨¼ã™ã‚‹æ–¹æ³•ã‚’3ã¤ææ¡ˆã›ã‚ˆã€‚</p>

        <details>
            <summary><strong>è§£ç­”ä¾‹ã‚’è¡¨ç¤º</strong></summary>
            <p><strong>GNDå¯†åº¦ã®æ¤œè¨¼æ–¹æ³•</strong>ï¼š</p>
            <ol>
                <li><strong>æ–‡çŒ®å€¤ã¨ã®æ¯”è¼ƒ</strong>ï¼š
                    <ul>
                        <li>åŒä¸€ææ–™ãƒ»åŒä¸€åŠ å·¥æ¡ä»¶ã®TEMç›´æ¥è¦³å¯Ÿã«ã‚ˆã‚‹Ïæ¸¬å®šå€¤ã¨æ¯”è¼ƒ</li>
                        <li>å…¸å‹çš„ç¯„å›²ï¼šç„¼éˆæ 10^12-10^13 m^-2ã€å†·é–“åŠ å·¥æ 10^14-10^15 m^-2</li>
                    </ul>
                </li>
                <li><strong>ç¡¬åº¦ã¨ã®ç›¸é–¢</strong>ï¼š
                    <ul>
                        <li>Taylorå¼·åŒ–å¼ï¼šÎ”Ïƒ âˆ âˆšÏï¼ˆè»¢ä½å¯†åº¦ã¨å¼·åº¦ã®é–¢ä¿‚ï¼‰</li>
                        <li>ãƒŠãƒã‚¤ãƒ³ãƒ‡ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ç¡¬åº¦ã¨GNDå¯†åº¦ã®ç©ºé–“åˆ†å¸ƒã‚’æ¯”è¼ƒ</li>
                        <li>é«˜GNDé ˜åŸŸã§ç¡¬åº¦ãŒé«˜ã‘ã‚Œã°å¦¥å½“</li>
                    </ul>
                </li>
                <li><strong>TEMè¦³å¯Ÿã¨ã®æ•´åˆæ€§</strong>ï¼š
                    <ul>
                        <li>åŒä¸€è©¦æ–™ã‚’TEMã§è¦³å¯Ÿã—ã€è»¢ä½å¯†åº¦ã‚’ç›´æ¥ã‚«ã‚¦ãƒ³ãƒˆ</li>
                        <li>EBSDã‹ã‚‰æ¨å®šã—ãŸGNDå¯†åº¦ã¨æ¯”è¼ƒï¼ˆé€šå¸¸EBSDã¯GNDã®ã¿æ¤œå‡ºã€çµ±è¨ˆçš„è»¢ä½ã¯æ¤œå‡ºã—ãªã„ï¼‰</li>
                        <li>EBSDå€¤ãŒTEMå€¤ã‚ˆã‚Š1æ¡ç¨‹åº¦ä½ã‘ã‚Œã°å¦¥å½“</li>
                    </ul>
                </li>
            </ol>
        </details>

        <h3>æ¼”ç¿’5-10: ãƒãƒƒãƒå‡¦ç†ã‚¹ã‚¯ãƒªãƒ—ãƒˆä½œæˆï¼ˆé›£ï¼‰</h3>
        <p><strong>å•é¡Œ</strong>ï¼šè¤‡æ•°ã®EELSãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆ100å€‹ï¼‰ã‚’è‡ªå‹•ã§ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰é™¤å»ã—ã€Fe-Lç©åˆ†å¼·åº¦ãƒãƒƒãƒ—ã‚’ç”Ÿæˆã™ã‚‹Pythonã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’è¨­è¨ˆã›ã‚ˆã€‚</p>

        <details>
            <summary><strong>è§£ç­”ä¾‹ã‚’è¡¨ç¤º</strong></summary>
            <pre><code class="language-python">import hyperspy.api as hs
import numpy as np
from pathlib import Path
import matplotlib.pyplot as plt

def batch_process_eels(file_list, output_dir, edge_onset=708,
                        fit_range=(650, 700), integration_window=(708, 758)):
    """
    è¤‡æ•°EELSãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒãƒƒãƒå‡¦ç†

    Parameters
    ----------
    file_list : list
        EELSãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã®ãƒªã‚¹ãƒˆ
    output_dir : Path
        å‡ºåŠ›ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª
    edge_onset : float
        ã‚¨ãƒƒã‚¸é–‹å§‹ã‚¨ãƒãƒ«ã‚®ãƒ¼ [eV]
    fit_range : tuple
        ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ãƒ•ã‚£ãƒƒãƒˆç¯„å›² [eV]
    integration_window : tuple
        ç©åˆ†çª“ [eV]
    """
    output_dir = Path(output_dir)
    output_dir.mkdir(exist_ok=True)

    for i, file_path in enumerate(file_list):
        print(f"Processing {i+1}/{len(file_list)}: {file_path.name}")

        try:
            # ãƒ‡ãƒ¼ã‚¿èª­è¾¼
            s = hs.load(file_path)

            # ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰é™¤å»ï¼ˆå…¨ãƒ”ã‚¯ã‚»ãƒ«ï¼‰
            s_bg_removed = s.remove_background(
                signal_range=fit_range,
                background_type='PowerLaw',
                fast=True  # é«˜é€Ÿãƒ¢ãƒ¼ãƒ‰
            )

            # ç©åˆ†å¼·åº¦ãƒãƒƒãƒ—ç”Ÿæˆ
            energy_axis = s_bg_removed.axes_manager[-1].axis
            mask = (energy_axis >= integration_window[0]) & (energy_axis <= integration_window[1])

            # å„ãƒ”ã‚¯ã‚»ãƒ«ã§ç©åˆ†
            intensity_map = np.trapz(s_bg_removed.isig[mask].data,
                                      energy_axis[mask], axis=-1)

            # ãƒãƒƒãƒ—ã‚’ä¿å­˜
            output_file = output_dir / f"{file_path.stem}_FeL_map.npy"
            np.save(output_file, intensity_map)

            # PNGå¯è¦–åŒ–ã‚‚ä¿å­˜
            plt.figure(figsize=(8, 6))
            plt.imshow(intensity_map, cmap='hot')
            plt.colorbar(label='Integrated Intensity [counts]')
            plt.title(f'Fe-L Intensity Map: {file_path.stem}')
            plt.axis('off')
            plt.tight_layout()
            plt.savefig(output_dir / f"{file_path.stem}_FeL_map.png", dpi=150)
            plt.close()

        except Exception as e:
            print(f"  Error: {e}")
            continue

    print(f"\nBatch processing complete. Results saved to {output_dir}")

# ä½¿ç”¨ä¾‹
# file_list = list(Path('eels_data/').glob('*.hspy'))
# batch_process_eels(file_list, output_dir='processed_maps/')
</code></pre>
        </details>

        <h2>5.6 å­¦ç¿’ãƒã‚§ãƒƒã‚¯</h2>
        <p>ä»¥ä¸‹ã®è³ªå•ã«ç­”ãˆã¦ã€ç†è§£åº¦ã‚’ç¢ºèªã—ã¾ã—ã‚‡ã†ï¼š</p>

        <ol>
            <li>HyperSpyã®Signal1Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æ§‹é€ ï¼ˆdata, axes_manager, metadataï¼‰ã‚’ç†è§£ã—ã¦ã„ã¾ã™ã‹ï¼Ÿ</li>
            <li>EELSãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰é™¤å»ã§ã¹ãä¹—å‰‡ãƒ•ã‚£ãƒƒãƒˆã‚’ä½¿ã†ç†ç”±ã‚’èª¬æ˜ã§ãã¾ã™ã‹ï¼Ÿ</li>
            <li>PCAã¨ICAã®é•ã„ã¨ã€ãã‚Œãã‚Œã®åˆ©ç‚¹ãƒ»æ¬ ç‚¹ã‚’ç†è§£ã—ã¦ã„ã¾ã™ã‹ï¼Ÿ</li>
            <li>k-meansã¨GMMã®ã‚¯ãƒ©ã‚¹ã‚¿ãƒªãƒ³ã‚°åŸç†ã®é•ã„ã‚’èª¬æ˜ã§ãã¾ã™ã‹ï¼Ÿ</li>
            <li>æ•™å¸«ã‚ã‚Šå­¦ç¿’ã¨æ•™å¸«ãªã—å­¦ç¿’ã®ä½¿ã„åˆ†ã‘ã‚’åˆ¤æ–­ã§ãã¾ã™ã‹ï¼Ÿ</li>
            <li>KAMï¼ˆå±€æ‰€æ–¹ä½å·®ï¼‰ãŒé«˜ã„é ˜åŸŸã®ç‰©ç†çš„æ„å‘³ã‚’ç†è§£ã—ã¦ã„ã¾ã™ã‹ï¼Ÿ</li>
            <li>GNDï¼ˆå¹¾ä½•å­¦çš„å¿…è¦è»¢ä½ï¼‰å¯†åº¦ã®è¨ˆç®—åŸç†ï¼ˆNye tensorï¼‰ã‚’ç†è§£ã—ã¦ã„ã¾ã™ã‹ï¼Ÿ</li>
            <li>EELSã€EDSã€EBSDãƒ‡ãƒ¼ã‚¿ã‚’çµ±åˆè§£æã™ã‚‹ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã‚’è¨­è¨ˆã§ãã¾ã™ã‹ï¼Ÿ</li>
            <li>å¤§è¦æ¨¡ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆã«å¯¾ã™ã‚‹ãƒãƒƒãƒå‡¦ç†ã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’å®Ÿè£…ã§ãã¾ã™ã‹ï¼Ÿ</li>
            <li>æ©Ÿæ¢°å­¦ç¿’ãƒ¢ãƒ‡ãƒ«ã®ç²¾åº¦è©•ä¾¡ï¼ˆæ··åŒè¡Œåˆ—ã€ã‚·ãƒ«ã‚¨ãƒƒãƒˆã‚¹ã‚³ã‚¢ï¼‰ãŒã§ãã¾ã™ã‹ï¼Ÿ</li>
            <li>EELSã‚¹ãƒšã‚¯ãƒˆãƒ«ã®ä¸»æˆåˆ†åˆ†æã§å¾—ã‚‰ã‚ŒãŸæˆåˆ†ã‚’ç‰©ç†çš„ã«è§£é‡ˆã§ãã¾ã™ã‹ï¼Ÿ</li>
            <li>ã‚ªã‚¤ãƒ©ãƒ¼è§’ã¨å››å…ƒæ•°ã®é•ã„ã‚’ç†è§£ã—ã€æ–¹ä½ãƒ‡ãƒ¼ã‚¿ã‚’é©åˆ‡ã«æ‰±ãˆã¾ã™ã‹ï¼Ÿ</li>
            <li>KAMãƒãƒƒãƒ—ã¨GNDå¯†åº¦ãƒãƒƒãƒ—ã®ç›¸é–¢ã‚’å®šé‡çš„ã«è©•ä¾¡ã§ãã¾ã™ã‹ï¼Ÿ</li>
            <li>SVMã®ã‚«ãƒ¼ãƒãƒ«ï¼ˆRBF, linear, polyï¼‰ã®é¸æŠåŸºæº–ã‚’ç†è§£ã—ã¦ã„ã¾ã™ã‹ï¼Ÿ</li>
            <li>ã‚¯ãƒ­ã‚¹ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã§éå­¦ç¿’ã‚’æ¤œå‡ºã—ã€å¯¾ç­–ã‚’è¬›ã˜ã‚‹ã“ã¨ãŒã§ãã¾ã™ã‹ï¼Ÿ</li>
        </ol>

        <h2>5.7 å‚è€ƒæ–‡çŒ®</h2>
        <ol>
            <li>de la PeÃ±a, F., et al. (2023). <em>HyperSpy: Multidimensional Data Analysis Toolbox</em>. <a href="https://hyperspy.org">https://hyperspy.org</a> - HyperSpyå…¬å¼ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ</li>
            <li>Johnstone, D. N., et al. (2020). "pyxem: Multidimensional diffraction microscopy in Python." <em>Journal of Open Source Software</em>, 5(51), 2496. - å›æŠ˜ãƒ‡ãƒ¼ã‚¿è§£æãƒ©ã‚¤ãƒ–ãƒ©ãƒª</li>
            <li>Langenhorst, M., et al. (2023). "orix: A Python library for crystallographic orientation data analysis." <em>Journal of Open Research Software</em>. - EBSDæ–¹ä½è§£æãƒ©ã‚¤ãƒ–ãƒ©ãƒª</li>
            <li>Pedregosa, F., et al. (2011). "Scikit-learn: Machine Learning in Python." <em>Journal of Machine Learning Research</em>, 12, 2825-2830. - scikit-learnå…¬å¼è«–æ–‡</li>
            <li>Britton, T. B., et al. (2016). "Tutorial: Crystal orientations and EBSDâ€”Or which way is up?" <em>Materials Characterization</em>, 117, 113-126. - EBSDè§£æã®æ•™è‚²çš„ç·èª¬</li>
            <li>Pantelic, R. S., et al. (2010). "The discriminative bilateral filter: An enhanced denoising filter for electron microscopy." <em>Journal of Structural Biology</em>, 171(3), 289-295. - ãƒã‚¤ã‚ºé™¤å»æ‰‹æ³•</li>
            <li>Shiga, M., et al. (2016). "Sparse modeling of EELS and EDX spectral imaging data by nonnegative matrix factorization." <em>Ultramicroscopy</em>, 170, 43-59. - ã‚¹ãƒšã‚¯ãƒˆãƒ«åˆ†è§£ã®æ©Ÿæ¢°å­¦ç¿’å¿œç”¨</li>
        </ol>

        <h2>5.8 ã¾ã¨ã‚ã¨æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—</h2>
        <p>æœ¬ç« ã§ã¯ã€é›»å­é¡•å¾®é¡åˆ†æã®çµ±åˆçš„Pythonãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã‚’å­¦ã³ã¾ã—ãŸã€‚HyperSpyã«ã‚ˆã‚‹ã‚¹ãƒšã‚¯ãƒˆãƒ«å‡¦ç†ã€PCA/ICAã«ã‚ˆã‚‹æ¬¡å…ƒå‰Šæ¸›ã€æ©Ÿæ¢°å­¦ç¿’ã«ã‚ˆã‚‹ç›¸åˆ†é¡ã€EBSDæ–¹ä½è§£æã®å®Ÿè·µçš„æ‰‹æ³•ã‚’ç¿’å¾—ã—ã¾ã—ãŸã€‚</p>

        <p><strong>å®Ÿè·µã¸ã®å¿œç”¨</strong>ï¼š</p>
        <ul>
            <li>å®Ÿãƒ‡ãƒ¼ã‚¿ã§HyperSpyãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã‚’æ§‹ç¯‰ã—ã€ãƒãƒƒãƒå‡¦ç†ã‚’è‡ªå‹•åŒ–</li>
            <li>PCA/ICAã§å¾—ã‚‰ã‚ŒãŸæˆåˆ†ã‚’ç‰©ç†ãƒ¢ãƒ‡ãƒ«ï¼ˆç›¸å›³ã€çŠ¶æ…‹å›³ï¼‰ã¨å¯¾å¿œä»˜ã‘</li>
            <li>æ©Ÿæ¢°å­¦ç¿’ãƒ¢ãƒ‡ãƒ«ã‚’ç¶™ç¶šçš„ã«æ”¹å–„ï¼ˆæ–°ãƒ‡ãƒ¼ã‚¿ã§å†å­¦ç¿’ï¼‰</li>
            <li>EBSDã¨STEMãƒ‡ãƒ¼ã‚¿ã‚’ç©ºé–“çš„ã«çµ±åˆã—ã€å¤šé‡ã‚¹ã‚±ãƒ¼ãƒ«è§£æã‚’å®Ÿæ–½</li>
        </ul>

        <p><strong>ç™ºå±•çš„å­¦ç¿’</strong>ï¼š</p>
        <ul>
            <li>æ·±å±¤å­¦ç¿’ï¼ˆCNN, U-Netï¼‰ã«ã‚ˆã‚‹ç”»åƒã‚»ã‚°ãƒ¡ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³</li>
            <li>ã‚°ãƒ©ãƒ•ãƒ‹ãƒ¥ãƒ¼ãƒ©ãƒ«ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã«ã‚ˆã‚‹çµæ™¶ç²’ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯è§£æ</li>
            <li>4D-STEMãƒ‡ãƒ¼ã‚¿ã®ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ è§£æï¼ˆpyxemåˆ©ç”¨ï¼‰</li>
            <li>ãƒˆãƒ¢ã‚°ãƒ©ãƒ•ã‚£ãƒ¼3Då†æ§‹æˆã¨FEMã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã®çµ±åˆ</li>
        </ul>

        <div class="navigation">
            <a href="chapter-4.html" class="nav-button">â† ç¬¬4ç« ï¼šSTEMã¨åˆ†ææŠ€è¡“</a>
            <a href="index.html" class="nav-button">ç›®æ¬¡ã«æˆ»ã‚‹</a>
        </div>
    </main>

    <section class="disclaimer">
        <h3>å…è²¬äº‹é …</h3>
        <ul>
            <li>æœ¬ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã¯æ•™è‚²ãƒ»ç ”ç©¶ãƒ»æƒ…å ±æä¾›ã®ã¿ã‚’ç›®çš„ã¨ã—ã¦ãŠã‚Šã€å°‚é–€çš„ãªåŠ©è¨€ï¼ˆæ³•å¾‹ãƒ»ä¼šè¨ˆãƒ»æŠ€è¡“çš„ä¿è¨¼ãªã©ï¼‰ã‚’æä¾›ã™ã‚‹ã‚‚ã®ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚</li>
            <li>æœ¬ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãŠã‚ˆã³ä»˜éšã™ã‚‹ã‚³ãƒ¼ãƒ‰ä¾‹ã¯ã€Œç¾çŠ¶æœ‰å§¿ï¼ˆAS ISï¼‰ã€ã§æä¾›ã•ã‚Œã€æ˜ç¤ºã¾ãŸã¯é»™ç¤ºã‚’å•ã‚ãšã€å•†å“æ€§ã€ç‰¹å®šç›®çš„é©åˆæ€§ã€æ¨©åˆ©éä¾µå®³ã€æ­£ç¢ºæ€§ãƒ»å®Œå…¨æ€§ã€å‹•ä½œãƒ»å®‰å…¨æ€§ç­‰ã„ã‹ãªã‚‹ä¿è¨¼ã‚‚ã—ã¾ã›ã‚“ã€‚</li>
            <li>å¤–éƒ¨ãƒªãƒ³ã‚¯ã€ç¬¬ä¸‰è€…ãŒæä¾›ã™ã‚‹ãƒ‡ãƒ¼ã‚¿ãƒ»ãƒ„ãƒ¼ãƒ«ãƒ»ãƒ©ã‚¤ãƒ–ãƒ©ãƒªç­‰ã®å†…å®¹ãƒ»å¯ç”¨æ€§ãƒ»å®‰å…¨æ€§ã«ã¤ã„ã¦ã€ä½œæˆè€…ãŠã‚ˆã³æ±åŒ—å¤§å­¦ã¯ä¸€åˆ‡ã®è²¬ä»»ã‚’è² ã„ã¾ã›ã‚“ã€‚</li>
            <li>æœ¬ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®åˆ©ç”¨ãƒ»å®Ÿè¡Œãƒ»è§£é‡ˆã«ã‚ˆã‚Šç›´æ¥çš„ãƒ»é–“æ¥çš„ãƒ»ä»˜éšçš„ãƒ»ç‰¹åˆ¥ãƒ»çµæœçš„ãƒ»æ‡²ç½°çš„æå®³ãŒç”Ÿã˜ãŸå ´åˆã§ã‚‚ã€é©ç”¨æ³•ã§è¨±å®¹ã•ã‚Œã‚‹æœ€å¤§é™ã®ç¯„å›²ã§ã€ä½œæˆè€…ãŠã‚ˆã³æ±åŒ—å¤§å­¦ã¯è²¬ä»»ã‚’è² ã„ã¾ã›ã‚“ã€‚</li>
            <li>æœ¬ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®å†…å®¹ã¯ã€äºˆå‘Šãªãå¤‰æ›´ãƒ»æ›´æ–°ãƒ»æä¾›åœæ­¢ã•ã‚Œã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚</li>
            <li>æœ¬ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®è‘—ä½œæ¨©ãƒ»ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã¯æ˜è¨˜ã•ã‚ŒãŸæ¡ä»¶ï¼ˆä¾‹: CC BY 4.0ï¼‰ã«å¾“ã„ã¾ã™ã€‚å½“è©²ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã¯é€šå¸¸ã€ç„¡ä¿è¨¼æ¡é …ã‚’å«ã¿ã¾ã™ã€‚</li>
        </ul>
    </section>

    <footer>
        <p><strong>ä½œæˆè€…</strong>: MS Knowledge Hub Content Team</p>
        <p><strong>ãƒãƒ¼ã‚¸ãƒ§ãƒ³</strong>: 1.0 | <strong>ä½œæˆæ—¥</strong>: 2025-10-28</p>
        <p><strong>ãƒ©ã‚¤ã‚»ãƒ³ã‚¹</strong>: Creative Commons BY 4.0</p>
        <p>&copy; 2025 MS Terakoya. All rights reserved.</p>
    </footer>
</body>
</html>
