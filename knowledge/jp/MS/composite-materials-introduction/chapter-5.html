<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç¬¬5ç«  Pythonå®Ÿè·µ - è¤‡åˆææ–™å…¥é–€</title>
    <meta name="description" content="å¤å…¸ç©å±¤ç†è«–ã®å®Ÿè£…ã€æœ€é©ç©å±¤è¨­è¨ˆã€æœ‰é™è¦ç´ æ³•å‰å‡¦ç†ã‚’Pythonã§å®Ÿè·µã—ã¾ã™ã€‚">
    <link rel="stylesheet" href="../../../../assets/css/knowledge.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">

    <style>
        /* Locale Switcher Styles */
        .locale-switcher {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 6px;
            font-size: 0.9rem;
            margin-bottom: 1rem;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .current-locale {
            font-weight: 600;
            color: #7b2cbf;
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .locale-separator {
            color: #adb5bd;
            font-weight: 300;
        }

        .locale-link {
            color: #f093fb;
            text-decoration: none;
            font-weight: 500;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 0.25rem;
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
        }

        .locale-link:hover {
            background: rgba(240, 147, 251, 0.1);
            color: #d07be8;
            transform: translateY(-1px);
        }

        .locale-meta {
            color: #868e96;
            font-size: 0.85rem;
            font-style: italic;
            margin-left: auto;
        }

        @media (max-width: 768px) {
            .locale-switcher {
                font-size: 0.85rem;
                padding: 0.4rem 0.8rem;
            }
            .locale-meta {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div class="locale-switcher">
<span class="current-locale">ğŸŒ JP</span>
<span class="locale-separator">|</span>
<a href="../../../en/MS/composite-materials-introduction/chapter-5.html" class="locale-link">ğŸ‡¬ğŸ‡§ EN</a>
<span class="locale-separator">|</span>
<span class="locale-meta">Last sync: 2025-11-16</span>
</div>
<div class="container">
        <nav class="sidebar">
            <h3>è¤‡åˆææ–™å…¥é–€</h3>
            <ul>
                <li><a href="index.html">ç›®æ¬¡</a></li>
                <li><a href="chapter-1.html">ç¬¬1ç«  è¤‡åˆææ–™ã®åŸºç¤</a></li>
                <li><a href="chapter-2.html">ç¬¬2ç«  ç¹Šç¶­å¼·åŒ–è¤‡åˆææ–™</a></li>
                <li><a href="chapter-3.html">ç¬¬3ç«  ç²’å­ãƒ»ç©å±¤è¤‡åˆææ–™</a></li>
                <li><a href="chapter-4.html">ç¬¬4ç«  è¤‡åˆææ–™ã®è©•ä¾¡</a></li>
                <li class="active"><a href="chapter-5.html">ç¬¬5ç«  Pythonå®Ÿè·µ</a></li>
            </ul>
            <div class="series-nav">
                <h4>Materials Science ã‚·ãƒªãƒ¼ã‚º</h4>
                <ul>
                    <li><a href="../polymer-materials-introduction/index.html">é«˜åˆ†å­ææ–™å…¥é–€</a></li>
                    <li><a href="../thin-film-nano-introduction/index.html">è–„è†œãƒ»ãƒŠãƒææ–™å…¥é–€</a></li>
                    <li class="current-series"><a href="index.html">è¤‡åˆææ–™å…¥é–€</a></li>
                </ul>
            </div>
        </nav>

        <main class="content">
            <article>
                <h1>ç¬¬5ç«  Pythonå®Ÿè·µ</h1>

                <div class="learning-objectives">
                    <h3>å­¦ç¿’ç›®æ¨™</h3>
                    <ul>
                        <li><strong>åŸºç¤ãƒ¬ãƒ™ãƒ«:</strong> å¤å…¸ç©å±¤ç†è«–(CLT)ã‚’Pythonã§å®Ÿè£…ã—ã€A-B-Dè¡Œåˆ—ã‚’è¨ˆç®—ã§ãã‚‹</li>
                        <li><strong>å¿œç”¨ãƒ¬ãƒ™ãƒ«:</strong> æœ€é©åŒ–ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚’ç”¨ã„ã¦ç©å±¤æ§‹æˆã‚’è¨­è¨ˆã—ã€æ€§èƒ½äºˆæ¸¬ãŒã§ãã‚‹</li>
                        <li><strong>ç™ºå±•ãƒ¬ãƒ™ãƒ«:</strong> æœ‰é™è¦ç´ æ³•ã®å‰å‡¦ç†ã‚’å®Ÿè£…ã—ã€å¤§è¦æ¨¡è§£æã¸ã®å±•é–‹ãŒã§ãã‚‹</li>
                    </ul>
                </div>

                <section>
                    <h2>5.1 å¤å…¸ç©å±¤ç†è«–ã®å®Œå…¨å®Ÿè£…</h2>

                    <h3>5.1.1 ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæŒ‡å‘è¨­è¨ˆ</h3>
                    <p>
                        è¤‡åˆææ–™è§£æãƒ„ãƒ¼ãƒ«ã‚’ã‚¯ãƒ©ã‚¹ãƒ™ãƒ¼ã‚¹ã§è¨­è¨ˆã—ã€å†åˆ©ç”¨æ€§ã¨æ‹¡å¼µæ€§ã‚’ç¢ºä¿ã—ã¾ã™ã€‚
                    </p>

                    <div class="example">
                        <h4>ä¾‹é¡Œ 5.1: CLT è§£æãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®å®Ÿè£…</h4>
                        <pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
from dataclasses import dataclass
from typing import List, Tuple, Optional

@dataclass
class Material:
    """å˜å±¤ææ–™ã®ç‰¹æ€§ã‚’ä¿æŒã™ã‚‹ã‚¯ãƒ©ã‚¹"""
    name: str
    E1: float  # ç¸¦å¼¾æ€§ç‡ [GPa]
    E2: float  # æ¨ªå¼¾æ€§ç‡ [GPa]
    nu12: float  # ä¸»ãƒã‚¢ã‚½ãƒ³æ¯”
    G12: float  # ã›ã‚“æ–­å¼¾æ€§ç‡ [GPa]
    Xt: float  # ç¸¦å¼•å¼µå¼·åº¦ [MPa]
    Xc: float  # ç¸¦åœ§ç¸®å¼·åº¦ [MPa]
    Yt: float  # æ¨ªå¼•å¼µå¼·åº¦ [MPa]
    Yc: float  # æ¨ªåœ§ç¸®å¼·åº¦ [MPa]
    S: float   # ã›ã‚“æ–­å¼·åº¦ [MPa]

    def __post_init__(self):
        """ç›¸åå®šç†ã®ç¢ºèª"""
        self.nu21 = self.nu12 * self.E2 / self.E1

    def Q_matrix(self) -> np.ndarray:
        """ç¸®ç´„å‰›æ€§ãƒãƒˆãƒªã‚¯ã‚¹ [Q] ã‚’è¨ˆç®—"""
        denom = 1 - self.nu12 * self.nu21
        Q11 = self.E1 / denom
        Q22 = self.E2 / denom
        Q12 = self.nu12 * self.E2 / denom
        Q66 = self.G12

        return np.array([
            [Q11, Q12, 0],
            [Q12, Q22, 0],
            [0, 0, Q66]
        ]) * 1000  # GPa â†’ MPa

class Laminate:
    """ç©å±¤æ¿ã®è§£æã‚¯ãƒ©ã‚¹"""

    def __init__(self, material: Material, layup: List[float], t_ply: float):
        """
        Parameters:
        -----------
        material : Material
            å˜å±¤ææ–™
        layup : List[float]
            ç©å±¤æ§‹æˆ [Î¸1, Î¸2, ..., Î¸n] (åº¦)
        t_ply : float
            å˜å±¤åšã• [mm]
        """
        self.material = material
        self.layup = np.array(layup)
        self.t_ply = t_ply
        self.n_plies = len(layup)
        self.total_thickness = self.n_plies * t_ply

        # zåº§æ¨™ã®è¨ˆç®—(ä¸­å¤®é¢ã‚’åŸºæº–)
        self.z = np.linspace(
            -self.total_thickness / 2,
            self.total_thickness / 2,
            self.n_plies + 1
        )

        # A, B, D ãƒãƒˆãƒªã‚¯ã‚¹ã®è¨ˆç®—
        self.A, self.B, self.D = self._compute_ABD()

    @staticmethod
    def transformation_matrix(theta: float) -> np.ndarray:
        """åº§æ¨™å¤‰æ›ãƒãƒˆãƒªã‚¯ã‚¹ [T]"""
        theta_rad = np.radians(theta)
        c = np.cos(theta_rad)
        s = np.sin(theta_rad)

        return np.array([
            [c**2, s**2, 2*s*c],
            [s**2, c**2, -2*s*c],
            [-s*c, s*c, c**2 - s**2]
        ])

    def Q_bar(self, theta: float) -> np.ndarray:
        """Off-axis å‰›æ€§ãƒãƒˆãƒªã‚¯ã‚¹ [QÌ„]"""
        Q = self.material.Q_matrix()
        T = self.transformation_matrix(theta)
        T_inv = np.linalg.inv(T)

        return T_inv @ Q @ T_inv.T

    def _compute_ABD(self) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
        """A-B-D ãƒãƒˆãƒªã‚¯ã‚¹ã‚’è¨ˆç®—"""
        A = np.zeros((3, 3))
        B = np.zeros((3, 3))
        D = np.zeros((3, 3))

        for k in range(self.n_plies):
            Q_bar = self.Q_bar(self.layup[k])
            z_k = self.z[k]
            z_k1 = self.z[k + 1]

            A += Q_bar * (z_k1 - z_k)
            B += 0.5 * Q_bar * (z_k1**2 - z_k**2)
            D += (1/3) * Q_bar * (z_k1**3 - z_k**3)

        return A, B, D

    def ABD_matrix(self) -> np.ndarray:
        """å®Œå…¨ãª6Ã—6 ABDãƒãƒˆãƒªã‚¯ã‚¹"""
        return np.block([
            [self.A, self.B],
            [self.B, self.D]
        ])

    def is_symmetric(self) -> bool:
        """ç©å±¤æ§‹æˆãŒå¯¾ç§°ã‹ã©ã†ã‹åˆ¤å®š"""
        n = len(self.layup)
        for i in range(n // 2):
            if self.layup[i] != self.layup[n - 1 - i]:
                return False
        return True

    def effective_properties(self) -> dict:
        """ç­‰ä¾¡é¢å†…ç‰¹æ€§ã‚’è¨ˆç®—"""
        # ã‚³ãƒ³ãƒ—ãƒ©ã‚¤ã‚¢ãƒ³ã‚¹ãƒãƒˆãƒªã‚¯ã‚¹
        a = np.linalg.inv(self.A)

        # ç­‰ä¾¡ãƒ¤ãƒ³ã‚°ç‡
        Ex = 1 / (a[0, 0] * self.total_thickness)
        Ey = 1 / (a[1, 1] * self.total_thickness)

        # ç­‰ä¾¡ãƒã‚¢ã‚½ãƒ³æ¯”
        nu_xy = -a[0, 1] / a[0, 0]
        nu_yx = -a[1, 0] / a[1, 1]

        # ç­‰ä¾¡ã›ã‚“æ–­å¼¾æ€§ç‡
        Gxy = 1 / (a[2, 2] * self.total_thickness)

        return {
            'Ex': Ex / 1000,  # MPa â†’ GPa
            'Ey': Ey / 1000,
            'nu_xy': nu_xy,
            'nu_yx': nu_yx,
            'Gxy': Gxy / 1000
        }

    def print_summary(self):
        """ç©å±¤æ¿ã®æƒ…å ±ã‚’å‡ºåŠ›"""
        print("="*70)
        print(f"ç©å±¤æ¿ã‚µãƒãƒª: {self.material.name}")
        print("="*70)
        print(f"ç©å±¤æ§‹æˆ: {self.layup}")
        print(f"å±¤æ•°: {self.n_plies}")
        print(f"å˜å±¤åšã•: {self.t_ply} mm")
        print(f"ç·æ¿åš: {self.total_thickness} mm")
        print(f"å¯¾ç§°ç©å±¤: {self.is_symmetric()}")

        print("\n[A] ãƒãƒˆãƒªã‚¯ã‚¹ (N/mm):")
        print(self.A)

        print("\n[B] ãƒãƒˆãƒªã‚¯ã‚¹ (N):")
        print(self.B)
        print(f"Bãƒãƒˆãƒªã‚¯ã‚¹ã®ãƒãƒ«ãƒ : {np.linalg.norm(self.B):.2e}")

        print("\n[D] ãƒãƒˆãƒªã‚¯ã‚¹ (NÂ·mm):")
        print(self.D)

        props = self.effective_properties()
        print("\nç­‰ä¾¡é¢å†…ç‰¹æ€§:")
        print(f"  Ex = {props['Ex']:.1f} GPa")
        print(f"  Ey = {props['Ey']:.1f} GPa")
        print(f"  Î½xy = {props['nu_xy']:.3f}")
        print(f"  Gxy = {props['Gxy']:.1f} GPa")
        print("="*70)

# ä½¿ç”¨ä¾‹
# CFRPææ–™ã®å®šç¾©
cfrp = Material(
    name="T300/Epoxy",
    E1=140.0, E2=10.0, nu12=0.30, G12=5.0,
    Xt=1500, Xc=1200, Yt=50, Yc=200, S=70
)

# ç©å±¤æ§‹æˆ
layup_symmetric = [0, 45, -45, 90, 90, -45, 45, 0]
layup_quasi_iso = [0, 45, -45, 90]

# ç©å±¤æ¿ã®ä½œæˆ
lam_sym = Laminate(cfrp, layup_symmetric, t_ply=0.125)
lam_qi = Laminate(cfrp, layup_quasi_iso, t_ply=0.125)

# ã‚µãƒãƒªè¡¨ç¤º
lam_sym.print_summary()
print("\n")
lam_qi.print_summary()</code></pre>
                    </div>

                    <h3>5.1.2 å¿œåŠ›ãƒ»ã²ãšã¿è§£æ</h3>
                    <p>
                        å°åŠ è·é‡ã‹ã‚‰å„å±¤ã®å¿œåŠ›ã‚’è¨ˆç®—ã—ã€ç ´å£Šè¦æº–ã¨ç…§åˆã—ã¾ã™ã€‚
                    </p>

                    <div class="example">
                        <h4>ä¾‹é¡Œ 5.2: ç©å±¤æ¿ã®å¿œåŠ›è§£æã¨ First Ply Failure</h4>
                        <pre><code class="language-python">class FailureCriterion:
    """ç ´å£Šè¦æº–ã®åŸºåº•ã‚¯ãƒ©ã‚¹"""

    def __init__(self, material: Material):
        self.material = material

    def failure_index(self, sigma1: float, sigma2: float, tau12: float) -> float:
        """ç ´å£ŠæŒ‡æ•°ã‚’è¨ˆç®—(å®Ÿè£…ã¯æ´¾ç”Ÿã‚¯ãƒ©ã‚¹)"""
        raise NotImplementedError

class TsaiWuCriterion(FailureCriterion):
    """Tsai-Wu ç ´å£Šè¦æº–"""

    def __init__(self, material: Material):
        super().__init__(material)

        # Tsai-Wu ä¿‚æ•°
        self.F1 = 1/material.Xt - 1/material.Xc
        self.F2 = 1/material.Yt - 1/material.Yc
        self.F11 = 1/(material.Xt * material.Xc)
        self.F22 = 1/(material.Yt * material.Yc)
        self.F66 = 1/material.S**2
        self.F12 = -0.5 * np.sqrt(self.F11 * self.F22)

    def failure_index(self, sigma1: float, sigma2: float, tau12: float) -> float:
        """Tsai-Wu ç ´å£ŠæŒ‡æ•°"""
        FI = (self.F1 * sigma1 + self.F2 * sigma2 +
              self.F11 * sigma1**2 + self.F22 * sigma2**2 +
              self.F66 * tau12**2 + 2 * self.F12 * sigma1 * sigma2)
        return FI

class LaminateAnalysis:
    """ç©å±¤æ¿ã®è·é‡è§£æã‚¯ãƒ©ã‚¹"""

    def __init__(self, laminate: Laminate, criterion: FailureCriterion):
        self.laminate = laminate
        self.criterion = criterion

    def analyze_loading(self, Nx: float, Ny: float, Nxy: float,
                        Mx: float = 0, My: float = 0, Mxy: float = 0) -> List[dict]:
        """
        è·é‡æ¡ä»¶ä¸‹ã§ã®å„å±¤ã®å¿œåŠ›è§£æ

        Parameters:
        -----------
        Nx, Ny, Nxy : float
            åˆå¿œåŠ› [N/mm]
        Mx, My, Mxy : float
            åˆãƒ¢ãƒ¼ãƒ¡ãƒ³ãƒˆ [NÂ·mm/mm]

        Returns:
        --------
        results : List[dict]
            å„å±¤ã®å¿œåŠ›ã¨ç ´å£ŠæŒ‡æ•°
        """
        # ABD ãƒãƒˆãƒªã‚¯ã‚¹ã®é€†è¡Œåˆ—
        ABD_inv = np.linalg.inv(self.laminate.ABD_matrix())

        # è·é‡ãƒ™ã‚¯ãƒˆãƒ«
        load = np.array([Nx, Ny, Nxy, Mx, My, Mxy])

        # ä¸­å¤®é¢ã®ã²ãšã¿ã¨æ›²ç‡
        strain_curvature = ABD_inv @ load
        epsilon0 = strain_curvature[:3]
        kappa = strain_curvature[3:]

        results = []

        for k in range(self.laminate.n_plies):
            # å±¤ã®ä¸­å¤®ä½ç½®
            z_mid = (self.laminate.z[k] + self.laminate.z[k + 1]) / 2

            # å…¨ä½“åº§æ¨™ç³»ã§ã®ã²ãšã¿
            epsilon_global = epsilon0 + z_mid * kappa

            # å…¨ä½“åº§æ¨™ç³»ã§ã®å¿œåŠ›
            Q_bar = self.laminate.Q_bar(self.laminate.layup[k])
            stress_global = Q_bar @ epsilon_global

            # ä¸»è»¸åº§æ¨™ç³»ã¸å¤‰æ›
            T = self.laminate.transformation_matrix(self.laminate.layup[k])
            stress_local = T @ stress_global

            sigma1, sigma2, tau12 = stress_local

            # ç ´å£ŠæŒ‡æ•°
            FI = self.criterion.failure_index(sigma1, sigma2, tau12)
            SF = 1 / np.sqrt(FI) if FI > 0 else np.inf

            results.append({
                'ply': k + 1,
                'angle': self.laminate.layup[k],
                'z': z_mid,
                'strain_global': epsilon_global,
                'stress_global': stress_global,
                'stress_local': stress_local,
                'FI': FI,
                'SF': SF
            })

        return results

    def first_ply_failure(self, Nx: float, Ny: float, Nxy: float) -> Tuple[int, float]:
        """
        First Ply Failure è·é‡ã‚’æ±‚ã‚ã‚‹

        Returns:
        --------
        fpf_ply : int
            æœ€åˆã«ç ´å£Šã™ã‚‹å±¤ç•ªå·
        fpf_load : float
            FPFè·é‡å€ç‡
        """
        # å˜ä½è·é‡ã§ã®è§£æ
        results = self.analyze_loading(Nx, Ny, Nxy)

        # æœ€å°å®‰å…¨ç‡ã‚’è¦‹ã¤ã‘ã‚‹
        min_sf = min(r['SF'] for r in results)
        fpf_ply = min((r for r in results), key=lambda r: r['SF'])['ply']

        return fpf_ply, min_sf

# ä½¿ç”¨ä¾‹
cfrp = Material(
    name="T300/Epoxy",
    E1=140.0, E2=10.0, nu12=0.30, G12=5.0,
    Xt=1500, Xc=1200, Yt=50, Yc=200, S=70
)

layup = [0, 45, -45, 90]
lam = Laminate(cfrp, layup, t_ply=0.125)

# Tsai-Wu è¦æº–
criterion = TsaiWuCriterion(cfrp)

# è§£æã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
analysis = LaminateAnalysis(lam, criterion)

# è·é‡æ¡ä»¶(ä¸€è»¸å¼•å¼µ)
Nx = 100  # N/mm
Ny = 0
Nxy = 0

# å¿œåŠ›è§£æ
results = analysis.analyze_loading(Nx, Ny, Nxy)

# çµæœè¡¨ç¤º
print("ç©å±¤æ¿ã®å¿œåŠ›è§£æçµæœ:")
print("="*80)
print(f"è·é‡: Nx = {Nx} N/mm, Ny = {Ny} N/mm, Nxy = {Nxy} N/mm")
print("-"*80)
print(f"{'å±¤':>3} {'è§’åº¦':>6} {'Ïƒ1':>10} {'Ïƒ2':>10} {'Ï„12':>10} {'FI':>8} {'SF':>8}")
print("-"*80)

for r in results:
    print(f"{r['ply']:3d} {r['angle']:6.0f}Â° {r['stress_local'][0]:10.1f} "
          f"{r['stress_local'][1]:10.1f} {r['stress_local'][2]:10.1f} "
          f"{r['FI']:8.3f} {r['SF']:8.2f}")

# FPF
fpf_ply, fpf_sf = analysis.first_ply_failure(Nx, Ny, Nxy)
print("-"*80)
print(f"First Ply Failure: å±¤ {fpf_ply} (è§’åº¦ {layup[fpf_ply-1]}Â°)")
print(f"å®‰å…¨ç‡: {fpf_sf:.2f}")
print(f"ç ´å£Šè·é‡: Nx = {Nx * fpf_sf:.1f} N/mm")</code></pre>
                    </div>
                </section>

                <section>
                    <h2>5.2 æœ€é©ç©å±¤è¨­è¨ˆ</h2>

                    <h3>5.2.1 éºä¼çš„ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ  (GA)</h3>
                    <p>
                        é›¢æ•£å¤‰æ•°(ç¹Šç¶­é…å‘è§’åº¦)ã®æœ€é©åŒ–ã«ã¯ã€éºä¼çš„ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ãŒæœ‰åŠ¹ã§ã™ã€‚
                    </p>

                    <div class="example">
                        <h4>ä¾‹é¡Œ 5.3: GA ã«ã‚ˆã‚‹ç©å±¤æ§‹æˆæœ€é©åŒ–</h4>
                        <pre><code class="language-python">import random
from typing import List, Callable
import numpy as np

class GeneticAlgorithm:
    """éºä¼çš„ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã«ã‚ˆã‚‹ç©å±¤è¨­è¨ˆæœ€é©åŒ–"""

    def __init__(self, n_plies: int, angle_options: List[float],
                 objective_func: Callable, symmetric: bool = True,
                 pop_size: int = 50, generations: int = 100):
        """
        Parameters:
        -----------
        n_plies : int
            å±¤æ•°
        angle_options : List[float]
            ä½¿ç”¨å¯èƒ½ãªè§’åº¦ [åº¦]
        objective_func : Callable
            ç›®çš„é–¢æ•°(layup â†’ score, å°ã•ã„ã»ã©è‰¯ã„)
        symmetric : bool
            å¯¾ç§°ç©å±¤ã‚’å¼·åˆ¶ã™ã‚‹ã‹
        """
        self.n_plies = n_plies
        self.angle_options = angle_options
        self.objective_func = objective_func
        self.symmetric = symmetric
        self.pop_size = pop_size
        self.generations = generations

        # å¯¾ç§°ç©å±¤ã®å ´åˆã¯åŠåˆ†ã ã‘éºä¼å­ã¨ã—ã¦æ‰±ã†
        self.gene_length = n_plies // 2 if symmetric else n_plies

    def create_individual(self) -> List[float]:
        """å€‹ä½“(ç©å±¤æ§‹æˆ)ã‚’ãƒ©ãƒ³ãƒ€ãƒ ç”Ÿæˆ"""
        genes = [random.choice(self.angle_options) for _ in range(self.gene_length)]

        if self.symmetric:
            # å¯¾ç§°ç©å±¤åŒ–
            return genes + genes[::-1]
        else:
            return genes

    def fitness(self, individual: List[float]) -> float:
        """é©å¿œåº¦(ç›®çš„é–¢æ•°ã®é€†æ•°)"""
        score = self.objective_func(individual)
        return 1 / (1 + score)  # ã‚¹ã‚³ã‚¢ãŒå°ã•ã„ã»ã©é©å¿œåº¦ãŒé«˜ã„

    def selection(self, population: List[List[float]]) -> List[List[float]]:
        """ãƒˆãƒ¼ãƒŠãƒ¡ãƒ³ãƒˆé¸æŠ"""
        tournament_size = 3
        selected = []

        for _ in range(len(population)):
            tournament = random.sample(population, tournament_size)
            winner = max(tournament, key=self.fitness)
            selected.append(winner)

        return selected

    def crossover(self, parent1: List[float], parent2: List[float]) -> List[float]:
        """ä¸€ç‚¹äº¤å‰"""
        point = random.randint(1, self.gene_length - 1)

        if self.symmetric:
            # åŠåˆ†ã®éºä¼å­ã§äº¤å‰
            genes1 = parent1[:self.gene_length]
            genes2 = parent2[:self.gene_length]
            child_genes = genes1[:point] + genes2[point:]
            return child_genes + child_genes[::-1]
        else:
            return parent1[:point] + parent2[point:]

    def mutate(self, individual: List[float], mutation_rate: float = 0.1) -> List[float]:
        """çªç„¶å¤‰ç•°"""
        if self.symmetric:
            genes = individual[:self.gene_length]
            mutated_genes = []

            for gene in genes:
                if random.random() < mutation_rate:
                    mutated_genes.append(random.choice(self.angle_options))
                else:
                    mutated_genes.append(gene)

            return mutated_genes + mutated_genes[::-1]
        else:
            return [
                random.choice(self.angle_options) if random.random() < mutation_rate else gene
                for gene in individual
            ]

    def optimize(self) -> Tuple[List[float], float]:
        """æœ€é©åŒ–å®Ÿè¡Œ"""
        # åˆæœŸé›†å›£
        population = [self.create_individual() for _ in range(self.pop_size)]

        best_history = []

        for gen in range(self.generations):
            # é©å¿œåº¦è©•ä¾¡
            fitnesses = [self.fitness(ind) for ind in population]
            best_idx = np.argmax(fitnesses)
            best_individual = population[best_idx]
            best_score = self.objective_func(best_individual)

            best_history.append(best_score)

            if gen % 10 == 0:
                print(f"ä¸–ä»£ {gen}: æœ€è‰¯ã‚¹ã‚³ã‚¢ = {best_score:.4f}, "
                      f"ç©å±¤ = {best_individual}")

            # é¸æŠ
            selected = self.selection(population)

            # æ¬¡ä¸–ä»£ç”Ÿæˆ
            next_population = [best_individual]  # ã‚¨ãƒªãƒ¼ãƒˆä¿å­˜

            while len(next_population) < self.pop_size:
                parent1, parent2 = random.sample(selected, 2)
                child = self.crossover(parent1, parent2)
                child = self.mutate(child)
                next_population.append(child)

            population = next_population

        # æœ€çµ‚ä¸–ä»£ã®æœ€è‰¯å€‹ä½“
        fitnesses = [self.fitness(ind) for ind in population]
        best_idx = np.argmax(fitnesses)
        best_individual = population[best_idx]
        best_score = self.objective_func(best_individual)

        return best_individual, best_score

# æœ€é©åŒ–å•é¡Œã®å®šç¾©
cfrp = Material(
    name="T300/Epoxy",
    E1=140.0, E2=10.0, nu12=0.30, G12=5.0,
    Xt=1500, Xc=1200, Yt=50, Yc=200, S=70
)

t_ply = 0.125

# ç›®çš„é–¢æ•°: Ex ã¨ Ey ã®å·®ã‚’æœ€å°åŒ–(æº–ç­‰æ–¹æ€§ã«è¿‘ã¥ã‘ã‚‹)
def objective_quasi_isotropic(layup):
    lam = Laminate(cfrp, layup, t_ply)
    props = lam.effective_properties()
    # Ex ã¨ Ey ã®ç›¸å¯¾å·®
    diff = abs(props['Ex'] - props['Ey']) / props['Ex']
    return diff

# GAå®Ÿè¡Œ
angle_options = [0, 45, -45, 90]
n_plies = 8

ga = GeneticAlgorithm(
    n_plies=n_plies,
    angle_options=angle_options,
    objective_func=objective_quasi_isotropic,
    symmetric=True,
    pop_size=50,
    generations=100
)

best_layup, best_score = ga.optimize()

print("\n" + "="*70)
print("æœ€é©ç©å±¤è¨­è¨ˆçµæœ:")
print("="*70)
print(f"æœ€é©ç©å±¤: {best_layup}")
print(f"ç›®çš„é–¢æ•°å€¤(Ex-Eyå·®): {best_score:.4f}")

# æœ€é©ç©å±¤ã®è©³ç´°è§£æ
lam_opt = Laminate(cfrp, best_layup, t_ply)
lam_opt.print_summary()</code></pre>
                    </div>

                    <h3>5.2.2 å¤šç›®çš„æœ€é©åŒ–</h3>
                    <p>
                        å¼·åº¦ã€å‰›æ€§ã€é‡é‡ãªã©è¤‡æ•°ã®ç›®çš„ã‚’åŒæ™‚ã«æœ€é©åŒ–ã—ã¾ã™ã€‚
                    </p>

                    <div class="example">
                        <h4>ä¾‹é¡Œ 5.4: NSGA-II ã«ã‚ˆã‚‹å¤šç›®çš„æœ€é©åŒ–</h4>
                        <pre><code class="language-python">from scipy.optimize import differential_evolution
import matplotlib.pyplot as plt

def multi_objective_function(layup_continuous, material, t_ply,
                              target_Nx, target_Ny):
    """
    å¤šç›®çš„é–¢æ•°: è³ªé‡æœ€å°åŒ– & å¼·åº¦ç¢ºä¿

    Parameters:
    -----------
    layup_continuous : array
        é€£ç¶šå¤‰æ•°åŒ–ã—ãŸç©å±¤æ§‹æˆ [0-3] â†’ [0, 45, -45, 90]

    Returns:
    --------
    objectives : tuple
        (è³ªé‡, é€†å®‰å…¨ç‡)
    """
    # é€£ç¶šå¤‰æ•°ã‚’é›¢æ•£è§’åº¦ã«å¤‰æ›
    angle_map = {0: 0, 1: 45, 2: -45, 3: 90}
    layup = [angle_map[int(round(x))] for x in layup_continuous]

    # ç©å±¤æ¿ä½œæˆ
    lam = Laminate(material, layup, t_ply)

    # è³ªé‡(æ¿åšã«æ¯”ä¾‹)
    mass = lam.total_thickness

    # å®‰å…¨ç‡(Tsai-Wu)
    criterion = TsaiWuCriterion(material)
    analysis = LaminateAnalysis(lam, criterion)

    try:
        results = analysis.analyze_loading(target_Nx, target_Ny, 0)
        min_sf = min(r['SF'] for r in results)
    except:
        min_sf = 0.1  # ã‚¨ãƒ©ãƒ¼æ™‚ã¯ãƒšãƒŠãƒ«ãƒ†ã‚£

    # ç›®çš„: è³ªé‡æœ€å°åŒ–ã€å®‰å…¨ç‡æœ€å¤§åŒ–(é€†æ•°æœ€å°åŒ–)
    return mass, 1 / min_sf

# Pareto ãƒ•ãƒ­ãƒ³ãƒ†ã‚£ã‚¢ã®æ¢ç´¢(ç°¡æ˜“ç‰ˆ: ã‚¹ã‚«ãƒ©ãƒ¼åŒ–æ³•)
cfrp = Material(
    name="T300/Epoxy",
    E1=140.0, E2=10.0, nu12=0.30, G12=5.0,
    Xt=1500, Xc=1200, Yt=50, Yc=200, S=70
)

t_ply = 0.125
target_Nx = 150  # N/mm
target_Ny = 50   # N/mm
n_plies = 12

# é‡ã¿ä»˜ã‘ã‚¹ã‚«ãƒ©ãƒ¼åŒ–æ³•
weights = np.linspace(0, 1, 11)
pareto_solutions = []

for w in weights:
    def scalarized_objective(x):
        mass, inv_sf = multi_objective_function(x, cfrp, t_ply, target_Nx, target_Ny)
        # æ­£è¦åŒ–ã—ã¦é‡ã¿ä»˜ã‘å’Œ
        return w * mass / 2.0 + (1 - w) * inv_sf * 10

    # æœ€é©åŒ–(differential_evolution)
    bounds = [(0, 3)] * n_plies  # 0-3ã®é€£ç¶šå€¤
    result = differential_evolution(
        scalarized_objective,
        bounds,
        maxiter=50,
        seed=123,
        atol=0.1,
        tol=0.1
    )

    # æœ€é©è§£
    angle_map = {0: 0, 1: 45, 2: -45, 3: 90}
    best_layup = [angle_map[int(round(x))] for x in result.x]
    mass, inv_sf = multi_objective_function(result.x, cfrp, t_ply, target_Nx, target_Ny)

    pareto_solutions.append({
        'weight': w,
        'layup': best_layup,
        'mass': mass,
        'safety_factor': 1 / inv_sf
    })

    print(f"é‡ã¿ w={w:.1f}: è³ªé‡={mass:.3f} mm, SF={1/inv_sf:.2f}, ç©å±¤={best_layup}")

# Paretoãƒ•ãƒ­ãƒ³ãƒˆå¯è¦–åŒ–
masses = [sol['mass'] for sol in pareto_solutions]
sfs = [sol['safety_factor'] for sol in pareto_solutions]

plt.figure(figsize=(10, 6))
plt.plot(masses, sfs, 'bo-', linewidth=2, markersize=8)
plt.xlabel('æ¿åš [mm]')
plt.ylabel('å®‰å…¨ç‡')
plt.title('Pareto ãƒ•ãƒ­ãƒ³ãƒ†ã‚£ã‚¢ (è³ªé‡ vs å®‰å…¨ç‡)')
plt.grid(True, alpha=0.3)

# å„ç‚¹ã«ãƒ©ãƒ™ãƒ«
for i, sol in enumerate(pareto_solutions[::2]):  # é–“å¼•ã„ã¦è¡¨ç¤º
    plt.annotate(f"w={sol['weight']:.1f}",
                 (sol['mass'], sol['safety_factor']),
                 textcoords="offset points", xytext=(5,5), fontsize=8)

plt.tight_layout()
plt.savefig('pareto_front.png', dpi=300, bbox_inches='tight')
plt.close()</code></pre>
                    </div>
                </section>

                <section>
                    <h2>5.3 æœ‰é™è¦ç´ æ³•ã®å‰å‡¦ç†</h2>

                    <h3>5.3.1 ãƒ¡ãƒƒã‚·ãƒ¥ç”Ÿæˆ</h3>
                    <p>
                        è¤‡åˆææ–™ã®æœ‰é™è¦ç´ è§£æã§ã¯ã€å„å±¤ã‚’åˆ¥è¦ç´ ã¾ãŸã¯
                        ã‚·ã‚§ãƒ«è¦ç´ ã®ç©åˆ†ç‚¹ã¨ã—ã¦æ‰±ã„ã¾ã™ã€‚
                    </p>

                    <div class="example">
                        <h4>ä¾‹é¡Œ 5.5: çŸ©å½¢æ¿ã®ãƒ¡ãƒƒã‚·ãƒ¥ç”Ÿæˆã¨Abaquså…¥åŠ›ãƒ•ã‚¡ã‚¤ãƒ«ä½œæˆ</h4>
                        <pre><code class="language-python">import numpy as np

class CompositeMesh:
    """è¤‡åˆææ–™æ¿ã®ãƒ¡ãƒƒã‚·ãƒ¥ç”Ÿæˆ"""

    def __init__(self, length: float, width: float,
                 nx: int, ny: int, laminate: Laminate):
        """
        Parameters:
        -----------
        length, width : float
            æ¿ã®å¯¸æ³• [mm]
        nx, ny : int
            è¦ç´ åˆ†å‰²æ•°
        laminate : Laminate
            ç©å±¤æ¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
        """
        self.length = length
        self.width = width
        self.nx = nx
        self.ny = ny
        self.laminate = laminate

        self.nodes = []
        self.elements = []

        self._generate_mesh()

    def _generate_mesh(self):
        """ç¯€ç‚¹ã¨è¦ç´ ã®ç”Ÿæˆ"""
        # ç¯€ç‚¹ç”Ÿæˆ
        dx = self.length / self.nx
        dy = self.width / self.ny

        node_id = 1
        for j in range(self.ny + 1):
            for i in range(self.nx + 1):
                x = i * dx
                y = j * dy
                self.nodes.append({
                    'id': node_id,
                    'x': x,
                    'y': y,
                    'z': 0
                })
                node_id += 1

        # è¦ç´ ç”Ÿæˆ(4ç¯€ç‚¹ã‚·ã‚§ãƒ«è¦ç´ )
        elem_id = 1
        for j in range(self.ny):
            for i in range(self.nx):
                n1 = j * (self.nx + 1) + i + 1
                n2 = n1 + 1
                n3 = n1 + (self.nx + 1) + 1
                n4 = n1 + (self.nx + 1)

                self.elements.append({
                    'id': elem_id,
                    'nodes': [n1, n2, n3, n4]
                })
                elem_id += 1

    def export_abaqus_inp(self, filename: str):
        """Abaquså…¥åŠ›ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å‡ºåŠ›"""
        with open(filename, 'w') as f:
            f.write("*HEADING\n")
            f.write("Composite Laminate Mesh\n")

            # ç¯€ç‚¹
            f.write("*NODE\n")
            for node in self.nodes:
                f.write(f"{node['id']}, {node['x']:.4f}, {node['y']:.4f}, {node['z']:.4f}\n")

            # è¦ç´ 
            f.write("*ELEMENT, TYPE=S4R, ELSET=PLATE\n")
            for elem in self.elements:
                nodes_str = ", ".join(map(str, elem['nodes']))
                f.write(f"{elem['id']}, {nodes_str}\n")

            # ã‚·ã‚§ãƒ«æ–­é¢
            f.write("*SHELL SECTION, ELSET=PLATE, COMPOSITE\n")
            for k, angle in enumerate(self.laminate.layup):
                # åšã•, ç©åˆ†ç‚¹æ•°, ææ–™å, è§’åº¦
                f.write(f"{self.laminate.t_ply}, 3, MAT1, {angle}\n")

            # ææ–™ç‰¹æ€§
            mat = self.laminate.material
            f.write("*MATERIAL, NAME=MAT1\n")
            f.write("*ELASTIC, TYPE=LAMINA\n")
            f.write(f"{mat.E1*1000}, {mat.E2*1000}, {mat.nu12}, "
                    f"{mat.G12*1000}, {mat.G12*1000}, {mat.G12*1000}\n")

            # å¢ƒç•Œæ¡ä»¶(å˜ç´”æ”¯æŒ)
            f.write("*BOUNDARY\n")
            # å·¦è¾º(x=0): UX=0
            for node in self.nodes:
                if abs(node['x']) < 1e-6:
                    f.write(f"{node['id']}, 1\n")

            # ä¸‹è¾º(y=0): UY=0
            for node in self.nodes:
                if abs(node['y']) < 1e-6:
                    f.write(f"{node['id']}, 2\n")

            # è·é‡ã‚¹ãƒ†ãƒƒãƒ—
            f.write("*STEP\n")
            f.write("*STATIC\n")

            # åˆ†å¸ƒè·é‡(ä¸Šé¢ã«åœ§åŠ›)
            f.write("*DLOAD\n")
            for elem in self.elements:
                f.write(f"{elem['id']}, P, 0.1\n")  # 0.1 MPa

            f.write("*OUTPUT, FIELD\n")
            f.write("*NODE OUTPUT\n")
            f.write("U, RF\n")
            f.write("*ELEMENT OUTPUT\n")
            f.write("S, E\n")
            f.write("*END STEP\n")

        print(f"Abaqus å…¥åŠ›ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å‡ºåŠ›ã—ã¾ã—ãŸ: {filename}")

# ãƒ¡ãƒƒã‚·ãƒ¥ç”Ÿæˆä¾‹
cfrp = Material(
    name="T300/Epoxy",
    E1=140.0, E2=10.0, nu12=0.30, G12=5.0,
    Xt=1500, Xc=1200, Yt=50, Yc=200, S=70
)

layup = [0, 45, -45, 90, 90, -45, 45, 0]
lam = Laminate(cfrp, layup, t_ply=0.125)

# çŸ©å½¢æ¿ãƒ¡ãƒƒã‚·ãƒ¥
mesh = CompositeMesh(length=100, width=100, nx=10, ny=10, laminate=lam)

# Abaquså…¥åŠ›ãƒ•ã‚¡ã‚¤ãƒ«å‡ºåŠ›
mesh.export_abaqus_inp("composite_plate.inp")

print(f"ç”Ÿæˆãƒ¡ãƒƒã‚·ãƒ¥æƒ…å ±:")
print(f"  ç¯€ç‚¹æ•°: {len(mesh.nodes)}")
print(f"  è¦ç´ æ•°: {len(mesh.elements)}")
print(f"  ç©å±¤æ§‹æˆ: {layup}")
print(f"  ç·æ¿åš: {lam.total_thickness} mm")</code></pre>
                    </div>

                    <h3>5.3.2 å¾Œå‡¦ç†ã¨ãƒ‡ãƒ¼ã‚¿å¯è¦–åŒ–</h3>
                    <p>
                        FEAçµæœã®èª­ã¿è¾¼ã¿ã¨å¯è¦–åŒ–ã‚’è‡ªå‹•åŒ–ã—ã¾ã™ã€‚
                    </p>

                    <div class="example">
                        <h4>ä¾‹é¡Œ 5.6: å¿œåŠ›åˆ†å¸ƒã®å¯è¦–åŒ–</h4>
                        <pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
from matplotlib.patches import Rectangle
from matplotlib.collections import PatchCollection

def visualize_stress_distribution(mesh: CompositeMesh, stress_values: np.ndarray,
                                    component: str = 'Sxx', cmap: str = 'jet'):
    """
    ãƒ¡ãƒƒã‚·ãƒ¥ä¸Šã®å¿œåŠ›åˆ†å¸ƒã‚’å¯è¦–åŒ–

    Parameters:
    -----------
    mesh : CompositeMesh
        ãƒ¡ãƒƒã‚·ãƒ¥ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
    stress_values : ndarray
        å„è¦ç´ ã®å¿œåŠ›å€¤ [MPa]
    component : str
        å¿œåŠ›æˆåˆ†å
    cmap : str
        ã‚«ãƒ©ãƒ¼ãƒãƒƒãƒ—
    """
    fig, ax = plt.subplots(figsize=(10, 8))

    patches = []
    colors = []

    for elem, stress in zip(mesh.elements, stress_values):
        # è¦ç´ ã®4ç¯€ç‚¹åº§æ¨™ã‚’å–å¾—
        node_ids = elem['nodes']
        coords = np.array([[mesh.nodes[nid-1]['x'], mesh.nodes[nid-1]['y']]
                           for nid in node_ids])

        # çŸ©å½¢ãƒ‘ãƒƒãƒä½œæˆ
        x_min, y_min = coords.min(axis=0)
        width = coords[:, 0].max() - x_min
        height = coords[:, 1].max() - y_min

        rect = Rectangle((x_min, y_min), width, height)
        patches.append(rect)
        colors.append(stress)

    # ãƒ‘ãƒƒãƒã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³
    p = PatchCollection(patches, cmap=cmap, edgecolors='black', linewidths=0.5)
    p.set_array(np.array(colors))

    ax.add_collection(p)

    # ã‚«ãƒ©ãƒ¼ãƒãƒ¼
    cbar = plt.colorbar(p, ax=ax)
    cbar.set_label(f'{component} [MPa]', fontsize=12)

    ax.set_xlim(0, mesh.length)
    ax.set_ylim(0, mesh.width)
    ax.set_aspect('equal')
    ax.set_xlabel('X [mm]', fontsize=12)
    ax.set_ylabel('Y [mm]', fontsize=12)
    ax.set_title(f'å¿œåŠ›åˆ†å¸ƒ: {component}', fontsize=14, weight='bold')

    plt.tight_layout()
    plt.savefig(f'stress_{component}.png', dpi=300, bbox_inches='tight')
    plt.close()

# æ¨¡æ“¬å¿œåŠ›ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆ
n_elements = len(mesh.elements)

# æ¿ä¸­å¤®ã§å¿œåŠ›ãŒé«˜ã„åˆ†å¸ƒã‚’æ¨¡æ“¬
stress_Sxx = []
for elem in mesh.elements:
    node_ids = elem['nodes']
    x_center = np.mean([mesh.nodes[nid-1]['x'] for nid in node_ids])
    y_center = np.mean([mesh.nodes[nid-1]['y'] for nid in node_ids])

    # æ¿ä¸­å¤®(50, 50)ã‹ã‚‰ã®è·é›¢ã«å¿œã˜ãŸå¿œåŠ›
    dist = np.sqrt((x_center - 50)**2 + (y_center - 50)**2)
    stress = 100 * np.exp(-dist / 30)  # ã‚¬ã‚¦ã‚·ã‚¢ãƒ³åˆ†å¸ƒ

    stress_Sxx.append(stress)

stress_Sxx = np.array(stress_Sxx)

# å¯è¦–åŒ–
visualize_stress_distribution(mesh, stress_Sxx, component='Sxx', cmap='jet')
print("å¿œåŠ›åˆ†å¸ƒå›³ã‚’å‡ºåŠ›ã—ã¾ã—ãŸ: stress_Sxx.png")</code></pre>
                    </div>
                </section>

                <section>
                    <h2>5.4 ã¾ã¨ã‚</h2>
                    <p>æœ¬ç« ã§ã¯ã€Pythonã‚’ç”¨ã„ãŸè¤‡åˆææ–™è§£æã®å®Ÿè·µçš„ãªå®Ÿè£…ã‚’å­¦ã³ã¾ã—ãŸï¼š</p>
                    <ul>
                        <li>å¤å…¸ç©å±¤ç†è«–(CLT)ã®å®Œå…¨å®Ÿè£…(ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæŒ‡å‘è¨­è¨ˆ)</li>
                        <li>å¿œåŠ›è§£æã¨First Ply Failureäºˆæ¸¬</li>
                        <li>éºä¼çš„ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã«ã‚ˆã‚‹æœ€é©ç©å±¤è¨­è¨ˆ</li>
                        <li>å¤šç›®çš„æœ€é©åŒ–ã¨Paretoãƒ•ãƒ­ãƒ³ãƒ†ã‚£ã‚¢</li>
                        <li>æœ‰é™è¦ç´ æ³•ã®å‰å‡¦ç†(ãƒ¡ãƒƒã‚·ãƒ¥ç”Ÿæˆã€Abaquså…¥åŠ›)</li>
                        <li>çµæœã®å¯è¦–åŒ–ã¨å¾Œå‡¦ç†</li>
                    </ul>

                    <p>
                        ã“ã‚Œã‚‰ã®æŠ€è¡“ã‚’çµ„ã¿åˆã‚ã›ã‚‹ã“ã¨ã§ã€å®Ÿå‹™ãƒ¬ãƒ™ãƒ«ã®è¤‡åˆææ–™è¨­è¨ˆãƒ»è§£æãŒ
                        å¯èƒ½ã«ãªã‚Šã¾ã™ã€‚ã•ã‚‰ã«ç™ºå±•çš„ãªå­¦ç¿’ã¨ã—ã¦ã€æå‚·åŠ›å­¦ã€
                        ç¢ºç‡è«–çš„è¨­è¨ˆã€ãƒãƒ«ãƒã‚¹ã‚±ãƒ¼ãƒ«è§£æãªã©ã«å–ã‚Šçµ„ã‚€ã“ã¨ã‚’æ¨å¥¨ã—ã¾ã™ã€‚
                    </p>
                </section>

                <section>
                    <h2>æ¼”ç¿’å•é¡Œ</h2>

                    <div class="exercise">
                        <h3>åŸºç¤ãƒ¬ãƒ™ãƒ«</h3>

                        <h4>å•é¡Œ 5.1: CLT ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®æ‹¡å¼µ</h4>
                        <p>
                            Laminate ã‚¯ãƒ©ã‚¹ã«ä»¥ä¸‹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’è¿½åŠ ã›ã‚ˆï¼š
                        </p>
                        <ul>
                            <li>æ›²ã’å‰›æ€§(æ¿åšã‚ãŸã‚Š)ã‚’è¨ˆç®—ã™ã‚‹ effective_bending_stiffness()</li>
                            <li>ç†±è†¨å¼µä¿‚æ•°ã‚’è€ƒæ…®ã—ãŸ thermal_stress() ãƒ¡ã‚½ãƒƒãƒ‰</li>
                        </ul>

                        <h4>å•é¡Œ 5.2: ãƒ—ãƒ­ãƒƒãƒˆæ©Ÿèƒ½ã®å®Ÿè£…</h4>
                        <p>
                            Laminate ã‚¯ãƒ©ã‚¹ã«ã€å„å±¤ã®å¿œåŠ›åˆ†å¸ƒã‚’æ¿åšæ–¹å‘ã«ãƒ—ãƒ­ãƒƒãƒˆã™ã‚‹
                            plot_through_thickness_stress() ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã›ã‚ˆã€‚
                        </p>

                        <h4>å•é¡Œ 5.3: ãƒ‡ãƒ¼ã‚¿å‡ºåŠ›</h4>
                        <p>
                            è§£æçµæœã‚’CSVãƒ•ã‚¡ã‚¤ãƒ«ã«å‡ºåŠ›ã™ã‚‹ export_to_csv() ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã›ã‚ˆã€‚
                            å‡ºåŠ›é …ç›®: å±¤ç•ªå·ã€è§’åº¦ã€zåº§æ¨™ã€Ïƒ1, Ïƒ2, Ï„12, FI, SF
                        </p>
                    </div>

                    <div class="exercise">
                        <h3>å¿œç”¨ãƒ¬ãƒ™ãƒ«</h3>

                        <h4>å•é¡Œ 5.4: åº§å±ˆè§£æ</h4>
                        <p>
                            ç©å±¤æ¿ã®åº§å±ˆè·é‡ã‚’è¨ˆç®—ã™ã‚‹ buckling_load() ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã›ã‚ˆã€‚
                            å˜ç´”æ”¯æŒçŸ©å½¢æ¿ã®åº§å±ˆå›ºæœ‰å€¤å•é¡Œã‚’è§£ã‘ã€‚
                        </p>

                        <h4>å•é¡Œ 5.5: æœ€é©åŒ–ã®æ‹¡å¼µ</h4>
                        <p>
                            éºä¼çš„ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã«ä»¥ä¸‹ã®åˆ¶ç´„ã‚’è¿½åŠ ã›ã‚ˆï¼š
                        </p>
                        <ul>
                            <li>é€£ç¶šã™ã‚‹åŒã˜è§’åº¦ã¯2å±¤ã¾ã§</li>
                            <li>0Â°å±¤ã‚’å°‘ãªãã¨ã‚‚20%å«ã‚€</li>
                            <li>å¯¾ç§°ç©å±¤ã‚’ç¶­æŒ</li>
                        </ul>

                        <h4>å•é¡Œ 5.6: ãƒ‘ãƒ©ãƒ¡ãƒˆãƒªãƒƒã‚¯ã‚¹ã‚¿ãƒ‡ã‚£</h4>
                        <p>
                            ç¹Šç¶­ä½“ç©åˆ†ç‡ V_f = 0.4-0.7 ã®ç¯„å›²ã§ã€ç©å±¤æ¿ã®é¢å†…å‰›æ€§ã¨
                            é‡é‡ã®ãƒˆãƒ¬ãƒ¼ãƒ‰ã‚ªãƒ•ã‚’å¯è¦–åŒ–ã™ã‚‹ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ä½œæˆã›ã‚ˆã€‚
                        </p>

                        <h4>å•é¡Œ 5.7: ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹</h4>
                        <p>
                            å¯¾è©±çš„ã«ç©å±¤æ§‹æˆã‚’å…¥åŠ›ã—ã€å³åº§ã«ç‰¹æ€§ã‚’è¡¨ç¤ºã™ã‚‹
                            ç°¡æ˜“GUIã‚’tkinterã§ä½œæˆã›ã‚ˆã€‚
                        </p>
                    </div>

                    <div class="exercise">
                        <h3>ç™ºå±•ãƒ¬ãƒ™ãƒ«</h3>

                        <h4>å•é¡Œ 5.8: æå‚·é€²å±•ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³</h4>
                        <p>
                            Progressive Failure Analysisã‚’å®Ÿè£…ã›ã‚ˆï¼š
                        </p>
                        <ul>
                            <li>First Ply Failure æ¤œå‡º</li>
                            <li>ç ´æå±¤ã®å‰›æ€§ä½ä¸‹(Degradation Model)</li>
                            <li>è·é‡ã®å†åˆ†é…ã¨å†è§£æ</li>
                            <li>Last Ply Failure ã¾ã§ã®ãƒ«ãƒ¼ãƒ—</li>
                        </ul>

                        <h4>å•é¡Œ 5.9: ãƒãƒ«ãƒã‚¹ã‚±ãƒ¼ãƒ«è§£æ</h4>
                        <p>
                            ãƒŸã‚¯ãƒ­ã‚¹ã‚±ãƒ¼ãƒ«(ç¹Šç¶­-æ¯æ)ã‹ã‚‰ãƒã‚¯ãƒ­ã‚¹ã‚±ãƒ¼ãƒ«(ç©å±¤æ¿)ã¸ã®
                            å‡è³ªåŒ–æ‰‹æ³•ã‚’å®Ÿè£…ã›ã‚ˆã€‚æœ‰é™è¦ç´ æ³•ã§RVEè§£æã‚’è¡Œã„ã€
                            ç­‰ä¾¡å˜å±¤ç‰¹æ€§ã‚’æŠ½å‡ºã›ã‚ˆã€‚
                        </p>

                        <h4>å•é¡Œ 5.10: æ©Ÿæ¢°å­¦ç¿’ã¨ã®çµ±åˆ</h4>
                        <p>
                            ä»¥ä¸‹ã®æ©Ÿæ¢°å­¦ç¿’ãƒ¢ãƒ‡ãƒ«ã‚’æ§‹ç¯‰ã›ã‚ˆï¼š
                        </p>
                        <ul>
                            <li>å…¥åŠ›: ç©å±¤æ§‹æˆ(ãƒ¯ãƒ³ãƒ›ãƒƒãƒˆã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°)</li>
                            <li>å‡ºåŠ›: Ex, Ey, Gxy, First Ply Failureè·é‡</li>
                            <li>å­¦ç¿’ãƒ‡ãƒ¼ã‚¿: CLTè§£æã§1000ã‚µãƒ³ãƒ—ãƒ«ç”Ÿæˆ</li>
                            <li>ãƒ¢ãƒ‡ãƒ«: ãƒ‹ãƒ¥ãƒ¼ãƒ©ãƒ«ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯(scikit-learn/TensorFlow)</li>
                            <li>è©•ä¾¡: RÂ²ã‚¹ã‚³ã‚¢ã€äºˆæ¸¬èª¤å·®ã®å¯è¦–åŒ–</li>
                        </ul>
                    </div>
                </section>

                <section>
                    <h2>å‚è€ƒæ–‡çŒ®</h2>
                    <ol class="references">
                        <li>Reddy, J. N., "Mechanics of Laminated Composite Plates and Shells: Theory and Analysis", 2nd ed., CRC Press, 2003, pp. 456-534</li>
                        <li>Kaw, A. K., "Mechanics of Composite Materials", 2nd ed., CRC Press, 2005, pp. 312-389</li>
                        <li>Goldberg, D. E., "Genetic Algorithms in Search, Optimization, and Machine Learning", Addison-Wesley, 1989, pp. 1-89</li>
                        <li>Deb, K., "Multi-Objective Optimization Using Evolutionary Algorithms", Wiley, 2001, pp. 234-312</li>
                        <li>Liu, B., Haftka, R. T., and Akgun, M. A., "Two-level Composite Wing Structural Optimization Using Response Surfaces", Structural and Multidisciplinary Optimization, Vol. 20, 2000, pp. 87-96</li>
                        <li>Simulia, "Abaqus Analysis User's Guide: Composite Materials", Dassault SystÃ¨mes, 2020, pp. 23.1.1-23.6.8</li>
                        <li>Bathe, K. J., "Finite Element Procedures", Prentice Hall, 1996, pp. 634-712</li>
                        <li>Hunter, J. D., "Matplotlib: A 2D Graphics Environment", Computing in Science & Engineering, Vol. 9, 2007, pp. 90-95</li>
                    </ol>
                </section>

                <div class="navigation">
                    <a href="chapter-4.html" class="prev">â† ç¬¬4ç«  è¤‡åˆææ–™ã®è©•ä¾¡</a>
                    <a href="index.html" class="next">ç›®æ¬¡ã¸ â†’</a>
                </div>
            </article>
        </main>
    </div>

    <footer>
        <p>&copy; 2025 Materials Science Learning Series. All rights reserved.</p>
    </footer>

    <script>
        mermaid.initialize({ startOnLoad: true });
    </script>
</body>
</html>