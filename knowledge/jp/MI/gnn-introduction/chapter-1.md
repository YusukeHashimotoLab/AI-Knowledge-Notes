---
title: ç¬¬1ç« ï¼šãªãœææ–™ç§‘å­¦ã«GNNãŒå¿…è¦ã‹
chapter_title: ç¬¬1ç« ï¼šãªãœææ–™ç§‘å­¦ã«GNNãŒå¿…è¦ã‹
subtitle: å¾“æ¥æ‰‹æ³•ã®é™ç•Œã¨ã‚°ãƒ©ãƒ•è¡¨ç¾ã®é©æ–°æ€§
reading_time: 20-25åˆ†
difficulty: åˆç´šã€œä¸­ç´š
code_examples: 6
exercises: 3
---

# ç¬¬1ç« ï¼šãªãœææ–™ç§‘å­¦ã«GNNãŒå¿…è¦ã‹

åˆ†å­ãƒ»çµæ™¶ã‚’â€œã‚°ãƒ©ãƒ•â€ã§è¡¨ã™åˆ©ç‚¹ã‚’ç›´æ„Ÿã§æ´ã¿ã¾ã™ã€‚å¾“æ¥è¨˜è¿°å­ã®é™ç•Œã¨ã€GNNãŒè§£ãã¹ãèª²é¡Œã‚’å…·ä½“ä¾‹ã§ç†è§£ã—ã¾ã™ã€‚

**ğŸ’¡ è£œè¶³:** ã‚°ãƒ©ãƒ•ã¯â€œäº¤å·®ç‚¹ï¼ˆåŸå­ï¼‰ã¨é“è·¯ï¼ˆçµåˆï¼‰â€ã€‚ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒéš£ã¸ä¼ã‚ã‚‹æ§˜å­ã‚’â€œå™‚ãŒåºƒãŒã‚‹â€ã‚¤ãƒ¡ãƒ¼ã‚¸ã§æ‰ãˆã¾ã™ã€‚

**åˆ†å­ãƒ»ææ–™ã®ã€Œå½¢ã€ã‚’ç†è§£ã™ã‚‹AIã®é©æ–°**

## å­¦ç¿’ç›®æ¨™

ã“ã®ç« ã‚’èª­ã‚€ã“ã¨ã§ã€ä»¥ä¸‹ã‚’ç¿’å¾—ã§ãã¾ã™ï¼š

  * âœ… å¾“æ¥ã®ææ–™è¨˜è¿°å­ï¼ˆãƒ™ã‚¯ãƒˆãƒ«è¡¨ç¾ï¼‰ã®3ã¤ã®é™ç•Œã‚’ç†è§£ã™ã‚‹
  * âœ… ã‚°ãƒ©ãƒ•ç†è«–ã®åŸºç¤ï¼ˆé ‚ç‚¹ã€è¾ºã€éš£æ¥è¡Œåˆ—ï¼‰ã‚’å­¦ã¶
  * âœ… åˆ†å­ãƒ»ææ–™ã‚’ã‚°ãƒ©ãƒ•ã¨ã—ã¦è¡¨ç¾ã™ã‚‹æ–¹æ³•ã‚’ç¿’å¾—ã™ã‚‹
  * âœ… GNNãŒææ–™ç§‘å­¦ã§é‡è¦è¦–ã•ã‚Œã‚‹ç†ç”±ã‚’èª¬æ˜ã§ãã‚‹
  * âœ… å®Ÿä¸–ç•Œã®GNNæˆåŠŸäº‹ä¾‹ï¼ˆOC20ã€QM9ã€Materials Projectï¼‰ã‚’çŸ¥ã‚‹
  * âœ… Pythonã§ã‚°ãƒ©ãƒ•æ§‹é€ ã‚’å¯è¦–åŒ–ã§ãã‚‹

**èª­äº†æ™‚é–“** : 20-25åˆ† **ã‚³ãƒ¼ãƒ‰ä¾‹** : 6å€‹ **æ¼”ç¿’å•é¡Œ** : 3å•

* * *

## 1.1 å¾“æ¥æ‰‹æ³•ã®é™ç•Œï¼šãªãœãƒ™ã‚¯ãƒˆãƒ«è¡¨ç¾ã§ã¯ä¸ååˆ†ã‹

### ææ–™è¨˜è¿°å­ï¼ˆDescriptorï¼‰ã¨ã¯

ææ–™ç§‘å­¦ã§ã¯ã€åˆ†å­ã‚„çµæ™¶ã‚’æ©Ÿæ¢°å­¦ç¿’ã§æ‰±ã†ãŸã‚ã«ã€Œ**ææ–™è¨˜è¿°å­** ã€ã¨ã„ã†æ•°å€¤ãƒ™ã‚¯ãƒˆãƒ«ã«å¤‰æ›ã—ã¾ã™ã€‚

**ä¾‹ï¼šæ°´åˆ†å­ï¼ˆHâ‚‚Oï¼‰ã®ãƒ™ã‚¯ãƒˆãƒ«è¡¨ç¾**
    
    
    # çµ„æˆãƒ™ãƒ¼ã‚¹ã®è¨˜è¿°å­
    water_descriptor = [
        2.0,   # HåŸå­æ•°
        1.0,   # OåŸå­æ•°
        2.55,  # å¹³å‡é›»æ°—é™°æ€§åº¦
        0.66,  # å¹³å‡åŸå­åŠå¾„ (Ã…)
        18.01  # åˆ†å­é‡
    ]
    

ã“ã®ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã¯**å˜ç´”ã§é«˜é€Ÿ** ã§ã™ãŒã€é‡å¤§ãªé™ç•ŒãŒã‚ã‚Šã¾ã™ã€‚

* * *

### é™ç•Œ1ï¼šæ§‹é€ æƒ…å ±ã®æ¬ è½

**å•é¡Œç‚¹** : åŸå­ã®é…ç½®ãƒ»çµåˆé–¢ä¿‚ãŒå¤±ã‚ã‚Œã‚‹

**ä¾‹ï¼šãƒ–ã‚¿ãƒ³ï¼ˆCâ‚„Hâ‚â‚€ï¼‰ã®ç•°æ€§ä½“**
    
    
    # ãƒ–ã‚¿ãƒ³ï¼ˆn-butaneï¼‰ã¨ ã‚¤ã‚½ãƒ–ã‚¿ãƒ³ï¼ˆisobutaneï¼‰ã¯åŒã˜çµ„æˆ
    n_butane = [
        4,    # CåŸå­æ•°
        10,   # HåŸå­æ•°
        2.5   # å¹³å‡ä¾¡é›»å­æ•°
    ]
    
    iso_butane = [
        4,    # CåŸå­æ•°ï¼ˆåŒã˜ï¼‰
        10,   # HåŸå­æ•°ï¼ˆåŒã˜ï¼‰
        2.5   # å¹³å‡ä¾¡é›»å­æ•°ï¼ˆåŒã˜ï¼‰
    ]
    

**åŒã˜ãƒ™ã‚¯ãƒˆãƒ« â†’ åˆ¥ã®åŒ–åˆç‰©ï¼**
    
    
    n-butane:     C-C-C-Cï¼ˆç·šå½¢ï¼‰
    isobutane:       C
                     |
                  C-C-C ï¼ˆåˆ†å²ï¼‰
    

**æ²¸ç‚¹ã®é•ã„** ï¼š \- n-butane: -0.5Â°C \- isobutane: -11.7Â°C

å¾“æ¥ã®è¨˜è¿°å­ã§ã¯ã€ã“ã®**11.2Â°Cã®å·®** ã‚’èª¬æ˜ã§ãã¾ã›ã‚“ã€‚

* * *

### é™ç•Œ2ï¼šé•·è·é›¢ç›¸äº’ä½œç”¨ã®ç„¡è¦–

**å•é¡Œç‚¹** : åŸå­é–“ã®è·é›¢ãƒ»è§’åº¦ãŒè€ƒæ…®ã•ã‚Œãªã„

**ä¾‹ï¼šã‚¿ãƒ³ãƒ‘ã‚¯è³ªã®æŠ˜ã‚ŠãŸãŸã¿**
    
    
    import numpy as np
    
    # ã‚¢ãƒŸãƒé…¸é…åˆ—ï¼ˆ1æ¬¡å…ƒãƒ™ã‚¯ãƒˆãƒ«ï¼‰
    sequence = [1, 5, 3, 8, 2, ...]  # ã‚¢ãƒŸãƒé…¸IDã®åˆ—
    
    # å®Ÿéš›ã®3Dæ§‹é€ ã¯10^300é€šã‚Šä»¥ä¸Šã®å¯èƒ½æ€§
    # ãƒ™ã‚¯ãƒˆãƒ«è¡¨ç¾ã§ã¯1ã¤ã®é…åˆ— â†’ ç„¡é™ã®3Då½¢çŠ¶
    

**è§¦åª’æ´»æ€§ã®ä¾‹** : \- æ´»æ€§ã‚µã‚¤ãƒˆï¼ˆåå¿œãŒèµ·ã“ã‚‹å ´æ‰€ï¼‰ã¯3Dç©ºé–“é…ç½®ã§æ±ºã¾ã‚‹ \- é…åˆ—ãŒåŒã˜ã§ã‚‚ã€ç©ºé–“é…ç½®ãŒé•ãˆã°æ´»æ€§ãŒ100å€å¤‰ã‚ã‚‹ã“ã¨ã‚‚

* * *

### é™ç•Œ3ï¼šç½®æ›åŸºã®éå¯¾ç§°æ€§

**å•é¡Œç‚¹** : åˆ†å­ã®å¯¾ç§°æ€§ãƒ»éå¯¾ç§°æ€§ãŒè¡¨ç¾ã§ããªã„

**ä¾‹ï¼šè–¬å‰¤ã®é¡åƒç•°æ€§ä½“ï¼ˆã‚¨ãƒŠãƒ³ãƒã‚ªãƒãƒ¼ï¼‰**
    
    
    L-dopaï¼ˆãƒ‘ãƒ¼ã‚­ãƒ³ã‚½ãƒ³ç—…æ²»ç™‚è–¬ï¼‰
        COOH
         |
      H-C-NHâ‚‚  ï¼ˆå·¦æ‰‹å‹ï¼‰
         |
        CHâ‚‚-...
    
    D-dopaï¼ˆåŠ¹æœãªã—ã€æ¯’æ€§ã®å¯èƒ½æ€§ï¼‰
        COOH
         |
      Hâ‚‚N-C-H  ï¼ˆå³æ‰‹å‹ã€é¡åƒï¼‰
         |
        CHâ‚‚-...
    

**ãƒ™ã‚¯ãƒˆãƒ«è¡¨ç¾ã§ã¯åŒã˜** ï¼š
    
    
    L_dopa = [9, 11, 4, 2]  # C, H, O, Næ•°
    D_dopa = [9, 11, 4, 2]  # åŒã˜ãƒ™ã‚¯ãƒˆãƒ«
    

ã—ã‹ã—**ç”Ÿç†æ´»æ€§ã¯æ­£åå¯¾** ã§ã™ã€‚

* * *

### å¾“æ¥æ‰‹æ³•ã®é™ç•Œã¾ã¨ã‚

é™ç•Œ | èª¬æ˜ | å½±éŸ¿  
---|---|---  
æ§‹é€ æƒ…å ±ã®æ¬ è½ | çµåˆé–¢ä¿‚ãŒå¤±ã‚ã‚Œã‚‹ | ç•°æ€§ä½“ã‚’åŒºåˆ¥ã§ããªã„  
é•·è·é›¢ç›¸äº’ä½œç”¨ã®ç„¡è¦– | 3Dç©ºé–“é…ç½®ãŒä¸æ˜ | è§¦åª’æ´»æ€§äºˆæ¸¬ã®å¤±æ•—  
ç½®æ›åŸºã®éå¯¾ç§°æ€§ | é¡åƒç•°æ€§ä½“ã‚’åŒºåˆ¥ä¸å¯ | è–¬å‰¤ã®å®‰å…¨æ€§å•é¡Œ  
  
**çµè«–** : ææ–™ãƒ»åˆ†å­ã®ã€Œå½¢ã€ã‚’ç†è§£ã™ã‚‹ã«ã¯ã€**ã‚°ãƒ©ãƒ•è¡¨ç¾** ãŒå¿…è¦ã§ã™ã€‚

* * *

## 1.2 ã‚°ãƒ©ãƒ•ç†è«–ã®åŸºç¤ï¼šåˆ†å­ãƒ»ææ–™ã®æ–°ã—ã„è¨€èª

### ã‚°ãƒ©ãƒ•ã¨ã¯ä½•ã‹

**å®šç¾©** :

> ã‚°ãƒ©ãƒ•ï¼ˆGraphï¼‰ã¨ã¯ã€**é ‚ç‚¹ï¼ˆVertex/Nodeï¼‰** ã¨**è¾ºï¼ˆEdgeï¼‰** ã®é›†åˆã§ã™ã€‚

**æ•°å­¦çš„è¨˜æ³•** : $$ G = (V, E) $$

  * $V$: é ‚ç‚¹ã®é›†åˆ
  * $E$: è¾ºã®é›†åˆ

* * *

### æ°´åˆ†å­ï¼ˆHâ‚‚Oï¼‰ã®ã‚°ãƒ©ãƒ•è¡¨ç¾
    
    
    ```mermaid
    flowchart LR
        H1[H] --|çµåˆ| O[O]
        O --|çµåˆ| H2[H]
    
        style H1 fill:#e3f2fd
        style O fill:#ffcdd2
        style H2 fill:#e3f2fd
    ```

**Pythonã§ã®è¡¨ç¾** :
    
    
    # NetworkXãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ä½¿ç”¨
    import networkx as nx
    import matplotlib.pyplot as plt
    
    # ã‚°ãƒ©ãƒ•ã®ä½œæˆ
    G = nx.Graph()
    
    # é ‚ç‚¹ã®è¿½åŠ ï¼ˆåŸå­ï¼‰
    G.add_node('O', element='O', mass=16.0)
    G.add_node('H1', element='H', mass=1.0)
    G.add_node('H2', element='H', mass=1.0)
    
    # è¾ºã®è¿½åŠ ï¼ˆçµåˆï¼‰
    G.add_edge('O', 'H1', bond_type='single')
    G.add_edge('O', 'H2', bond_type='single')
    
    # å¯è¦–åŒ–
    pos = {'O': (0, 0), 'H1': (-1, -1), 'H2': (1, -1)}
    nx.draw(
        G, pos, with_labels=True,
        node_color='lightblue',
        node_size=2000,
        font_size=16,
        font_weight='bold'
    )
    plt.title('Hâ‚‚Oåˆ†å­ã®ã‚°ãƒ©ãƒ•è¡¨ç¾')
    plt.show()
    

**å‡ºåŠ›** :
    
    
            O
           / \
          /   \
        H1     H2
    

* * *

### éš£æ¥è¡Œåˆ—ï¼ˆAdjacency Matrixï¼‰

ã‚°ãƒ©ãƒ•ã‚’ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ã§æ‰±ã†ãŸã‚ã®è¡¨ç¾æ–¹æ³•ã§ã™ã€‚

**å®šç¾©** : $$ A_{ij} = \begin{cases} 1 & \text{if edge between node } i \text{ and } j \ 0 & \text{otherwise} \end{cases} $$

**Hâ‚‚Oã®éš£æ¥è¡Œåˆ—** :
    
    
    import numpy as np
    
    # é ‚ç‚¹ã®é †ç•ª: [O, H1, H2]
    adjacency_matrix = np.array([
        [0, 1, 1],  # O: H1ã¨H2ã«çµåˆ
        [1, 0, 0],  # H1: Oã«çµåˆ
        [1, 0, 0]   # H2: Oã«çµåˆ
    ])
    
    print(adjacency_matrix)
    

**å‡ºåŠ›** :
    
    
    [[0 1 1]
     [1 0 0]
     [1 0 0]]
    

**é‡è¦ãªãƒã‚¤ãƒ³ãƒˆ** : \- **å¯¾ç§°è¡Œåˆ—** ï¼ˆç„¡å‘ã‚°ãƒ©ãƒ•ã®å ´åˆï¼‰ \- **å¯¾è§’æˆåˆ†ã¯0** ï¼ˆè‡ªå·±ãƒ«ãƒ¼ãƒ—ãªã—ï¼‰ \- **ç–è¡Œåˆ—** ï¼ˆã»ã¨ã‚“ã©ã®è¦ç´ ãŒ0ï¼‰

* * *

### ã‚ˆã‚Šè¤‡é›‘ãªåˆ†å­ï¼šãƒ¡ã‚¿ãƒ³ï¼ˆCHâ‚„ï¼‰
    
    
    # ãƒ¡ã‚¿ãƒ³ã®ã‚°ãƒ©ãƒ•
    methane = nx.Graph()
    
    # ç‚­ç´ ï¼ˆä¸­å¿ƒï¼‰
    methane.add_node('C', element='C', mass=12.0)
    
    # æ°´ç´ 4å€‹
    for i in range(1, 5):
        methane.add_node(f'H{i}', element='H', mass=1.0)
        methane.add_edge('C', f'H{i}', bond_type='single')
    
    # éš£æ¥è¡Œåˆ—
    A = nx.adjacency_matrix(methane).todense()
    print(f"ãƒ¡ã‚¿ãƒ³ã®éš£æ¥è¡Œåˆ—:\n{A}")
    

**å‡ºåŠ›** :
    
    
    ãƒ¡ã‚¿ãƒ³ã®éš£æ¥è¡Œåˆ—:
    [[0 1 1 1 1]   # C: 4ã¤ã®Hã«çµåˆ
     [1 0 0 0 0]   # H1
     [1 0 0 0 0]   # H2
     [1 0 0 0 0]   # H3
     [1 0 0 0 0]]  # H4
    

* * *

### ã‚°ãƒ©ãƒ•ã®ç¨®é¡

ã‚°ãƒ©ãƒ•ã‚¿ã‚¤ãƒ— | èª¬æ˜ | ææ–™ç§‘å­¦ã§ã®ä¾‹  
---|---|---  
**ç„¡å‘ã‚°ãƒ©ãƒ•** | è¾ºã«æ–¹å‘ãªã— | å…±æœ‰çµåˆï¼ˆH-O-Hï¼‰  
**æœ‰å‘ã‚°ãƒ©ãƒ•** | è¾ºã«æ–¹å‘ã‚ã‚Š | é…ä½çµåˆï¼ˆLewiså¡©åŸºâ†’é…¸ï¼‰  
**åŠ é‡ã‚°ãƒ©ãƒ•** | è¾ºã«é‡ã¿ã‚ã‚Š | çµåˆã‚¨ãƒãƒ«ã‚®ãƒ¼  
**å¤šé‡ã‚°ãƒ©ãƒ•** | è¤‡æ•°ã®è¾ºè¨±å¯ | äºŒé‡çµåˆï¼ˆC=Oï¼‰  
  
* * *

## 1.3 åˆ†å­ãƒ»ææ–™ã®ã‚°ãƒ©ãƒ•è¡¨ç¾

### åˆ†å­ã‚°ãƒ©ãƒ•ï¼ˆMolecular Graphï¼‰

**å®šç¾©** : \- **é ‚ç‚¹ï¼ˆNodeï¼‰** : åŸå­ \- **è¾ºï¼ˆEdgeï¼‰** : åŒ–å­¦çµåˆ \- **é ‚ç‚¹ç‰¹å¾´é‡** : åŸå­ç•ªå·ã€é›»è·ã€æ··æˆè»Œé“ \- **è¾ºç‰¹å¾´é‡** : çµåˆæ¬¡æ•°ã€çµåˆé•·ã€çµåˆè§’

* * *

### ä¾‹ï¼šã‚¨ã‚¿ãƒãƒ¼ãƒ«ï¼ˆCâ‚‚Hâ‚…OHï¼‰
    
    
    import rdkit
    from rdkit import Chem
    from rdkit.Chem import Draw
    
    # SMILESã‹ã‚‰ã‚°ãƒ©ãƒ•ç”Ÿæˆ
    ethanol_smiles = 'CCO'
    mol = Chem.MolFromSmiles(ethanol_smiles)
    
    # ã‚°ãƒ©ãƒ•æƒ…å ±ã®æŠ½å‡º
    print("=== ã‚¨ã‚¿ãƒãƒ¼ãƒ«ã®ã‚°ãƒ©ãƒ•æ§‹é€  ===")
    print(f"åŸå­æ•°ï¼ˆé ‚ç‚¹æ•°ï¼‰: {mol.GetNumAtoms()}")
    print(f"çµåˆæ•°ï¼ˆè¾ºæ•°ï¼‰: {mol.GetNumBonds()}")
    
    # å„åŸå­ï¼ˆé ‚ç‚¹ï¼‰ã®æƒ…å ±
    for atom in mol.GetAtoms():
        print(f"Atom {atom.GetIdx()}: {atom.GetSymbol()}, "
              f"ä¾¡é›»å­={atom.GetTotalValence()}, "
              f"æ··æˆ={atom.GetHybridization()}")
    
    # å„çµåˆï¼ˆè¾ºï¼‰ã®æƒ…å ±
    for bond in mol.GetBonds():
        print(f"Bond {bond.GetIdx()}: "
              f"{bond.GetBeginAtomIdx()}-{bond.GetEndAtomIdx()}, "
              f"type={bond.GetBondType()}")
    

**å‡ºåŠ›** :
    
    
    === ã‚¨ã‚¿ãƒãƒ¼ãƒ«ã®ã‚°ãƒ©ãƒ•æ§‹é€  ===
    åŸå­æ•°ï¼ˆé ‚ç‚¹æ•°ï¼‰: 9
    çµåˆæ•°ï¼ˆè¾ºæ•°ï¼‰: 8
    Atom 0: C, ä¾¡é›»å­=4, æ··æˆ=SP3
    Atom 1: C, ä¾¡é›»å­=4, æ··æˆ=SP3
    Atom 2: O, ä¾¡é›»å­=2, æ··æˆ=SP3
    Atom 3: H, ä¾¡é›»å­=1, æ··æˆ=S
    ...
    Bond 0: 0-1, type=SINGLE
    Bond 1: 1-2, type=SINGLE
    Bond 2: 0-3, type=SINGLE
    ...
    

* * *

### çµæ™¶æ§‹é€ ã®ã‚°ãƒ©ãƒ•è¡¨ç¾ï¼ˆPeriodic Graphï¼‰

çµæ™¶ã¯**å‘¨æœŸçš„ãªã‚°ãƒ©ãƒ•** ã¨ã—ã¦è¡¨ç¾ã•ã‚Œã¾ã™ã€‚
    
    
    from pymatgen.core import Structure, Lattice
    
    # NaClçµæ™¶æ§‹é€ 
    lattice = Lattice.cubic(5.64)  # æ ¼å­å®šæ•° 5.64 Ã…
    structure = Structure(
        lattice,
        species=['Na', 'Cl'],
        coords=[[0, 0, 0], [0.5, 0.5, 0.5]]
    )
    
    print("=== NaClçµæ™¶ã®ã‚°ãƒ©ãƒ•è¡¨ç¾ ===")
    print(f"å˜ä½æ ¼å­å†…ã®åŸå­æ•°: {len(structure)}")
    
    # éš£æ¥åŸå­ã®å–å¾—ï¼ˆcutoff=3.0 Ã…ï¼‰
    neighbors = structure.get_neighbors(structure[0], r=3.0)
    print(f"NaåŸå­ã®éš£æ¥åŸå­æ•°ï¼ˆ3Ã…ä»¥å†…ï¼‰: {len(neighbors)}")
    for neighbor in neighbors:
        print(f"  {neighbor.species_string} at {neighbor.nn_distance:.2f} Ã…")
    

**å‡ºåŠ›** :
    
    
    === NaClçµæ™¶ã®ã‚°ãƒ©ãƒ•è¡¨ç¾ ===
    å˜ä½æ ¼å­å†…ã®åŸå­æ•°: 2
    NaåŸå­ã®éš£æ¥åŸå­æ•°ï¼ˆ3Ã…ä»¥å†…ï¼‰: 6
      Cl at 2.82 Ã…
      Cl at 2.82 Ã…
      Cl at 2.82 Ã…
      Cl at 2.82 Ã…
      Cl at 2.82 Ã…
      Cl at 2.82 Ã…
    

**ã‚°ãƒ©ãƒ•æ§‹é€ ã®å¯è¦–åŒ–** :
    
    
    ```mermaid
    flowchart TD
        Na1[Na] --- Cl1[Cl]
        Na1 --- Cl2[Cl]
        Na1 --- Cl3[Cl]
        Na1 --- Cl4[Cl]
        Na1 --- Cl5[Cl]
        Na1 --- Cl6[Cl]
    
        style Na1 fill:#fff3e0
        style Cl1 fill:#e8f5e9
        style Cl2 fill:#e8f5e9
        style Cl3 fill:#e8f5e9
        style Cl4 fill:#e8f5e9
        style Cl5 fill:#e8f5e9
        style Cl6 fill:#e8f5e9
    ```

* * *

### ã‚°ãƒ©ãƒ•è¡¨ç¾ã®åˆ©ç‚¹

**å¾“æ¥ã®ãƒ™ã‚¯ãƒˆãƒ«è¡¨ç¾ã¨ã®æ¯”è¼ƒ** :
    
    
    # ===== å¾“æ¥ã®ãƒ™ã‚¯ãƒˆãƒ«è¡¨ç¾ =====
    # ã‚¨ã‚¿ãƒãƒ¼ãƒ« (Câ‚‚Hâ‚…OH)
    ethanol_vector = [
        2,     # CåŸå­æ•°
        6,     # HåŸå­æ•°
        1,     # OåŸå­æ•°
        2.3    # å¹³å‡é›»æ°—é™°æ€§åº¦
    ]
    
    # ã‚¤ã‚½ãƒ—ãƒ­ãƒ‘ãƒãƒ¼ãƒ« (Câ‚ƒHâ‚‡OH) - ç•°æ€§ä½“ã ãŒåŒºåˆ¥ä¸å¯èƒ½
    isopropanol_vector = [
        3,     # CåŸå­æ•°
        8,     # HåŸå­æ•°
        1,     # OåŸå­æ•°
        2.3    # å¹³å‡é›»æ°—é™°æ€§åº¦ï¼ˆã»ã¼åŒã˜ï¼‰
    ]
    
    # ===== ã‚°ãƒ©ãƒ•è¡¨ç¾ =====
    # ã‚¨ã‚¿ãƒãƒ¼ãƒ«
    ethanol_graph = {
        'nodes': ['C', 'C', 'O', 'H', 'H', 'H', 'H', 'H', 'H'],
        'edges': [(0,1), (1,2), (0,3), (0,4), (0,5),
                  (1,6), (1,7), (2,8)],
        'structure': 'C-C-O-H (ç·šå½¢)'
    }
    
    # ã‚¤ã‚½ãƒ—ãƒ­ãƒ‘ãƒãƒ¼ãƒ«
    isopropanol_graph = {
        'nodes': ['C', 'C', 'C', 'O', 'H', 'H', 'H', 'H',
                  'H', 'H', 'H', 'H'],
        'edges': [(0,1), (1,2), (1,3), (0,4), (0,5), (0,6),
                  (2,7), (2,8), (2,9), (3,10), ...],
        'structure': '(CHâ‚ƒ)-CH(OH)-CHâ‚ƒ (åˆ†å²)'
    }
    

**æ˜ç¢ºãªåŒºåˆ¥ãŒå¯èƒ½ï¼**

ç‰¹å¾´ | ãƒ™ã‚¯ãƒˆãƒ«è¡¨ç¾ | ã‚°ãƒ©ãƒ•è¡¨ç¾  
---|---|---  
ç•°æ€§ä½“ã®åŒºåˆ¥ | âŒ ä¸å¯èƒ½ | âœ… å¯èƒ½  
ç©ºé–“é…ç½® | âŒ ç„¡è¦– | âœ… ä¿æŒ  
çµåˆæƒ…å ± | âŒ æ¬ è½ | âœ… å®Œå…¨  
é•·è·é›¢ç›¸äº’ä½œç”¨ | âŒ å›°é›£ | âœ… å¯èƒ½  
è§£é‡ˆæ€§ | âœ… é«˜ã„ | âœ… é«˜ã„  
  
* * *

## 1.4 GNNã®åˆ©ç‚¹ï¼šãªãœææ–™ç§‘å­¦ã§æ³¨ç›®ã•ã‚Œã‚‹ã®ã‹

### åˆ©ç‚¹1ï¼šEnd-to-Endã®ç‰¹å¾´é‡å­¦ç¿’

**å¾“æ¥æ‰‹æ³•ï¼ˆæ‰‹å‹•ç‰¹å¾´é‡è¨­è¨ˆï¼‰** :
    
    
    # Step 1: å°‚é–€å®¶ãŒç‰¹å¾´é‡ã‚’è¨­è¨ˆï¼ˆæ•°é€±é–“ã€œæ•°ãƒ¶æœˆï¼‰
    features = calculate_descriptors(molecule)
    # [é›»æ°—é™°æ€§åº¦, åŸå­åŠå¾„, ã‚¤ã‚ªãƒ³åŒ–ã‚¨ãƒãƒ«ã‚®ãƒ¼, ...]
    
    # Step 2: æ©Ÿæ¢°å­¦ç¿’ãƒ¢ãƒ‡ãƒ«
    model.fit(features, target)
    

**GNNæ‰‹æ³•ï¼ˆè‡ªå‹•ç‰¹å¾´é‡å­¦ç¿’ï¼‰** :
    
    
    # ã‚°ãƒ©ãƒ•ã‚’å…¥åŠ›ã™ã‚‹ã ã‘
    gnn_model.fit(graph, target)
    # GNNãŒæœ€é©ãªç‰¹å¾´é‡ã‚’è‡ªå‹•å­¦ç¿’
    

**çµæœ** : \- é–‹ç™ºæ™‚é–“: æ•°ãƒ¶æœˆ â†’ æ•°æ—¥ \- æ€§èƒ½: å°‚é–€å®¶è¨­è¨ˆã‚’è¶…ãˆã‚‹ã“ã¨ã‚‚

* * *

### åˆ©ç‚¹2ï¼šè»¢ç§»å­¦ç¿’ï¼ˆTransfer Learningï¼‰

**äº‹å‰å­¦ç¿’ãƒ¢ãƒ‡ãƒ«** ã®æ´»ç”¨ãŒå¯èƒ½ã§ã™ã€‚
    
    
    from torch_geometric.nn import GCN
    
    # Step 1: å¤§è¦æ¨¡ãƒ‡ãƒ¼ã‚¿ã§äº‹å‰å­¦ç¿’ï¼ˆ1Måˆ†å­ï¼‰
    pretrained_model = GCN.from_pretrained('molecular-gnn-base')
    
    # Step 2: å°è¦æ¨¡ãƒ‡ãƒ¼ã‚¿ã§ãƒ•ã‚¡ã‚¤ãƒ³ãƒãƒ¥ãƒ¼ãƒ‹ãƒ³ã‚°ï¼ˆ100åˆ†å­ï¼‰
    pretrained_model.finetune(
        your_small_dataset,
        epochs=10
    )
    

**åŠ¹æœ** : \- å¿…è¦ãƒ‡ãƒ¼ã‚¿: 10,000ã‚µãƒ³ãƒ—ãƒ« â†’ 100ã‚µãƒ³ãƒ—ãƒ« \- ç²¾åº¦: 80% â†’ 92%

* * *

### åˆ©ç‚¹3ï¼šè§£é‡ˆå¯èƒ½æ€§ï¼ˆInterpretabilityï¼‰

GNNã¯ã€Œãªãœãã®äºˆæ¸¬ã‚’ã—ãŸã‹ã€ã‚’èª¬æ˜ã§ãã¾ã™ã€‚
    
    
    # ã©ã®åŸå­ãŒé‡è¦ã‹å¯è¦–åŒ–
    atom_importance = gnn_model.explain(molecule)
    
    # è§¦åª’æ´»æ€§ã«å¯„ä¸ã™ã‚‹åŸå­ã‚’å¼·èª¿è¡¨ç¤º
    visualize_importance(molecule, atom_importance)
    

**ä¾‹ï¼šè§¦åª’è¨­è¨ˆ** \- æ´»æ€§ã‚µã‚¤ãƒˆã®ç‰¹å®š \- ç½®æ›åŸºã®æœ€é©åŒ– \- ãƒ¡ã‚«ãƒ‹ã‚ºãƒ ã®ç†è§£
    
    
    ```mermaid
    flowchart LR
        A[åˆ†å­å…¥åŠ›] --> B[GNNäºˆæ¸¬]
        B --> C[æ´»æ€§: 0.89]
        B --> D[é‡è¦åŸå­ã®ç‰¹å®š]
        D --> E[åŸå­3, 5, 7ãŒé‡è¦]
        E --> F[è¨­è¨ˆæ”¹å–„ã®ãƒ’ãƒ³ãƒˆ]
    
        style A fill:#e3f2fd
        style B fill:#fff3e0
        style C fill:#f3e5f5
        style D fill:#e8f5e9
        style E fill:#ffebee
        style F fill:#fff9c4
    ```

* * *

## 1.5 æˆåŠŸäº‹ä¾‹ï¼šGNNãŒå¤‰ãˆãŸææ–™ç§‘å­¦

### Case Study 1: OC20 - è§¦åª’ç™ºè¦‹ã®åŠ é€Ÿ

**ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ** : Open Catalyst 2020 (Meta AI Research) **ç›®æ¨™** : ã‚¯ãƒªãƒ¼ãƒ³ã‚¨ãƒãƒ«ã‚®ãƒ¼è§¦åª’ã®åŠ¹ç‡çš„æ¢ç´¢

**ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆ** : \- è¦æ¨¡: 1.3M DFTè¨ˆç®— \- å¯¾è±¡: è§¦åª’è¡¨é¢ã§ã®å¸ç€ã‚¨ãƒãƒ«ã‚®ãƒ¼ \- æ¢ç´¢ç©ºé–“: 10^12é€šã‚Šã®çµ„ã¿åˆã‚ã›

**GNNãƒ¢ãƒ‡ãƒ«** : SchNet, DimeNet++, GemNet

**çµæœ** :
    
    
    å¾“æ¥æ‰‹æ³•ï¼ˆDFTè¨ˆç®—ï¼‰: 1ææ–™ã‚ãŸã‚Š24æ™‚é–“
    GNNäºˆæ¸¬: 1ææ–™ã‚ãŸã‚Š0.01ç§’ï¼ˆ240ä¸‡å€é«˜é€ŸåŒ–ï¼‰
    
    ç²¾åº¦: MAE = 0.43 eVï¼ˆå®Ÿç”¨ãƒ¬ãƒ™ãƒ«ï¼‰
    ç™ºè¦‹ã•ã‚ŒãŸè§¦åª’: 10ç¨®é¡ï¼ˆå®Ÿé¨“ã§æ¤œè¨¼æ¸ˆã¿ï¼‰
    

**ã‚³ãƒ¼ãƒ‰ä¾‹ï¼ˆç°¡ç•¥ç‰ˆï¼‰** :
    
    
    from torch_geometric.datasets import OC20
    from torch_geometric.nn import SchNet
    
    # ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆèª­ã¿è¾¼ã¿
    dataset = OC20(root='./data/oc20', split='train')
    
    # SchNetãƒ¢ãƒ‡ãƒ«
    model = SchNet(
        hidden_channels=128,
        num_filters=128,
        num_interactions=6,
        num_gaussians=50,
        cutoff=6.0
    )
    
    # è¨“ç·´ï¼ˆç°¡ç•¥åŒ–ï¼‰
    for data in dataset[:1000]:
        pred_energy = model(data.z, data.pos, data.batch)
        # ...æå¤±è¨ˆç®—ã€æœ€é©åŒ–
    

**ã‚¤ãƒ³ãƒ‘ã‚¯ãƒˆ** : \- CO2å‰Šæ¸›è§¦åª’ã®ç™ºè¦‹ \- æ°´ç´ è£½é€ ã®åŠ¹ç‡åŒ– \- è«–æ–‡: Chanussot et al. (2021), _ACS Catalysis_

* * *

### Case Study 2: QM9 - åˆ†å­ç‰¹æ€§äºˆæ¸¬ã®æ¨™æº–

**ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆ** : QM9 - 134kæœ‰æ©Ÿåˆ†å­ **ç‰¹æ€§** : HOMO-LUMO gap, åŒæ¥µå­ãƒ¢ãƒ¼ãƒ¡ãƒ³ãƒˆã€ç†±å®¹é‡ãªã©

**GNNãƒ¢ãƒ‡ãƒ«** : MPNN (Message Passing Neural Network)

**çµæœ** :

ç‰¹æ€§ | å¾“æ¥æ‰‹æ³• (RF) | GNN (MPNN) | æ”¹å–„ç‡  
---|---|---|---  
HOMO-LUMO gap | MAE=0.25 eV | 0.04 eV | **84%**  
åŒæ¥µå­ãƒ¢ãƒ¼ãƒ¡ãƒ³ãƒˆ | MAE=0.45 D | 0.03 D | **93%**  
ç†±å®¹é‡ | MAE=1.2 cal/molÂ·K | 0.04 | **97%**  
  
**ã‚³ãƒ¼ãƒ‰ä¾‹** :
    
    
    from torch_geometric.datasets import QM9
    from torch_geometric.nn import GCNConv, global_mean_pool
    
    # ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆ
    dataset = QM9(root='./data/qm9')
    print(f"åˆ†å­æ•°: {len(dataset)}")
    print(f"ç‰¹æ€§æ•°: {dataset.num_tasks}")
    
    # ç°¡å˜ãªGNN
    class SimpleGNN(torch.nn.Module):
        def __init__(self):
            super().__init__()
            self.conv1 = GCNConv(11, 64)  # åŸå­ç‰¹å¾´é‡11æ¬¡å…ƒ
            self.conv2 = GCNConv(64, 64)
            self.lin = torch.nn.Linear(64, 1)
    
        def forward(self, data):
            x, edge_index, batch = data.x, data.edge_index, data.batch
    
            # ã‚°ãƒ©ãƒ•ç•³ã¿è¾¼ã¿
            x = F.relu(self.conv1(x, edge_index))
            x = F.relu(self.conv2(x, edge_index))
    
            # ã‚°ãƒ©ãƒ•ãƒ¬ãƒ™ãƒ«ã®äºˆæ¸¬
            x = global_mean_pool(x, batch)
            x = self.lin(x)
            return x
    
    model = SimpleGNN()
    

**è«–æ–‡** : Gilmer et al. (2017), _ICML_

* * *

### Case Study 3: Materials Project - çµæ™¶ç‰¹æ€§äºˆæ¸¬

**ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹** : Materials Project (140k+ ææ–™) **ã‚¿ã‚¹ã‚¯** : å½¢æˆã‚¨ãƒãƒ«ã‚®ãƒ¼ã€ãƒãƒ³ãƒ‰ã‚®ãƒ£ãƒƒãƒ—ã€å¼¾æ€§ç‡äºˆæ¸¬

**GNNãƒ¢ãƒ‡ãƒ«** : CGCNN (Crystal Graph Convolutional Neural Network)

**çµæœ** :
    
    
    å½¢æˆã‚¨ãƒãƒ«ã‚®ãƒ¼äºˆæ¸¬:
    - å¾“æ¥æ‰‹æ³• (RF): MAE = 0.15 eV/atom
    - CGCNN: MAE = 0.039 eV/atomï¼ˆ74%æ”¹å–„ï¼‰
    
    è¨ˆç®—æ™‚é–“:
    - DFTè¨ˆç®—: 10-100æ™‚é–“/ææ–™
    - CGCNNäºˆæ¸¬: 0.1ç§’/ææ–™ï¼ˆ360ä¸‡å€é«˜é€ŸåŒ–ï¼‰
    

**ã‚³ãƒ¼ãƒ‰ä¾‹** :
    
    
    from pymatgen.core import Structure
    import torch
    
    # çµæ™¶æ§‹é€ ã®èª­ã¿è¾¼ã¿
    structure = Structure.from_file('POSCAR')
    
    # ã‚°ãƒ©ãƒ•ã¸ã®å¤‰æ›
    def structure_to_graph(structure, cutoff=5.0):
        """
        çµæ™¶æ§‹é€ ã‚’ã‚°ãƒ©ãƒ•ã«å¤‰æ›
        """
        nodes = []  # åŸå­ã®ç‰¹å¾´é‡
        edges = []  # çµåˆæƒ…å ±
    
        for i, site in enumerate(structure):
            # ãƒãƒ¼ãƒ‰ç‰¹å¾´ï¼ˆåŸå­ç•ªå·ã€åº§æ¨™ãªã©ï¼‰
            nodes.append([
                site.specie.Z,  # åŸå­ç•ªå·
                site.x, site.y, site.z  # åº§æ¨™
            ])
    
            # éš£æ¥åŸå­ã®æ¤œç´¢
            neighbors = structure.get_neighbors(site, r=cutoff)
            for neighbor in neighbors:
                edges.append([i, neighbor.index])
    
        return {
            'nodes': torch.tensor(nodes),
            'edges': torch.tensor(edges)
        }
    
    graph = structure_to_graph(structure)
    print(f"ãƒãƒ¼ãƒ‰æ•°: {len(graph['nodes'])}")
    print(f"ã‚¨ãƒƒã‚¸æ•°: {len(graph['edges'])}")
    

**ã‚¤ãƒ³ãƒ‘ã‚¯ãƒˆ** : \- æ–°è¦Li-ioné›»æ± ææ–™ã®ç™ºè¦‹ \- å¤ªé™½é›»æ± ææ–™ã®æœ€é©åŒ– \- è«–æ–‡: Xie & Grossman (2018), _Physical Review Letters_

* * *

### æˆåŠŸäº‹ä¾‹ã®æ¯”è¼ƒ

ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ | å¯¾è±¡ | ãƒ‡ãƒ¼ã‚¿è¦æ¨¡ | é«˜é€ŸåŒ– | ç²¾åº¦æ”¹å–„  
---|---|---|---|---  
**OC20** | è§¦åª’ | 1.3M | 240ä¸‡å€ | MAE 0.43 eV  
**QM9** | æœ‰æ©Ÿåˆ†å­ | 134k | 1000å€ | 84-97%æ”¹å–„  
**Materials Project** | çµæ™¶ | 140k+ | 360ä¸‡å€ | 74%æ”¹å–„  
  
**å…±é€šç‚¹** : \- ã‚°ãƒ©ãƒ•è¡¨ç¾ã®æ¡ç”¨ \- End-to-Endå­¦ç¿’ \- æ¡é•ã„ã®é«˜é€ŸåŒ– \- å®Ÿç”¨ãƒ¬ãƒ™ãƒ«ã®ç²¾åº¦

* * *

## 1.6 ã‚³ãƒ©ãƒ ï¼šã‚°ãƒ©ãƒ•ç†è«–ã®æ­´å²ã¨ææ–™ç§‘å­¦

### ã‚ªã‚¤ãƒ©ãƒ¼ã®ä¸ƒã¤æ©‹å•é¡Œï¼ˆ1736å¹´ï¼‰

ã‚°ãƒ©ãƒ•ç†è«–ã®èµ·æºã¯ã€**ãƒ¬ã‚ªãƒ³ãƒãƒ«ãƒˆãƒ»ã‚ªã‚¤ãƒ©ãƒ¼** ã«ã‚ˆã‚‹ã€Œã‚±ãƒ¼ãƒ‹ãƒ’ã‚¹ãƒ™ãƒ«ã‚¯ã®æ©‹å•é¡Œã€ã§ã™ã€‚

**å•é¡Œ** : 7ã¤ã®æ©‹ã‚’ä¸€ç­†æ›¸ãã§æ¸¡ã‚Œã‚‹ã‹ï¼Ÿ
    
    
    ```mermaid
    flowchart TD
        A[å³¶A] --|æ©‹1| B[å³¶B]
        A --|æ©‹2| B
        A --|æ©‹3| C[å³¶C]
        B --|æ©‹4| C
        B --|æ©‹5| D[å³¶D]
        C --|æ©‹6| D
        C --|æ©‹7| D
    
        style A fill:#e3f2fd
        style B fill:#fff3e0
        style C fill:#f3e5f5
        style D fill:#e8f5e9
    ```

**ã‚ªã‚¤ãƒ©ãƒ¼ã®è§£ç­”** : ä¸å¯èƒ½ï¼ˆå„é ‚ç‚¹ã®æ¬¡æ•°ãŒå¶æ•°ã§ãªã„ãŸã‚ï¼‰

**ææ–™ç§‘å­¦ã¸ã®å¿œç”¨** : \- åˆ†å­ã®é€£çµæ€§åˆ¤å®š \- åå¿œçµŒè·¯ã®æ¢ç´¢ \- çµæ™¶ã®å¯¾ç§°æ€§è§£æ

* * *

### åŒ–å­¦ã‚°ãƒ©ãƒ•ç†è«–ï¼ˆ1950å¹´ä»£ã€œï¼‰

**Arthur Cayley** (1857): åˆã®åˆ†å­ã‚°ãƒ©ãƒ•è¡¨ç¾ **Harry Wiener** (1947): Wiener Indexï¼ˆåˆ†å­è¨˜è¿°å­ï¼‰

**Wiener Index ã®è¨ˆç®—ä¾‹** :
    
    
    import networkx as nx
    
    # ãƒ–ã‚¿ãƒ³åˆ†å­ã®ã‚°ãƒ©ãƒ•
    butane = nx.path_graph(4)  # C-C-C-C
    
    # Wiener Index = å…¨ãƒšã‚¢é–“ã®æœ€çŸ­è·é›¢ã®å’Œ
    wiener_index = sum(
        dict(nx.all_pairs_shortest_path_length(butane))[i][j]
        for i in range(4)
        for j in range(i+1, 4)
    )
    print(f"Wiener Index: {wiener_index}")
    # å‡ºåŠ›: 10 = (1+2+3) + (1+2) + (1)
    

**ç¾ä»£ã¸ã®å½±éŸ¿** : \- GNNã®ç†è«–çš„åŸºç¤ \- ã‚°ãƒ©ãƒ•ã‚«ãƒ¼ãƒãƒ«æ‰‹æ³• \- åˆ†å­é¡ä¼¼æ€§ã®å®šé‡åŒ–

* * *

## 1.7 æœ¬ç« ã®ã¾ã¨ã‚

### å­¦ã‚“ã ã“ã¨

  1. **å¾“æ¥æ‰‹æ³•ã®é™ç•Œ** \- æ§‹é€ æƒ…å ±ã®æ¬ è½ï¼ˆç•°æ€§ä½“ã‚’åŒºåˆ¥ä¸å¯ï¼‰ \- é•·è·é›¢ç›¸äº’ä½œç”¨ã®ç„¡è¦–ï¼ˆ3Dé…ç½®ãŒä¸æ˜ï¼‰ \- ç½®æ›åŸºã®éå¯¾ç§°æ€§ï¼ˆé¡åƒç•°æ€§ä½“ã‚’åŒºåˆ¥ä¸å¯ï¼‰

  2. **ã‚°ãƒ©ãƒ•ç†è«–ã®åŸºç¤** \- ã‚°ãƒ©ãƒ• = é ‚ç‚¹ + è¾º \- éš£æ¥è¡Œåˆ—ã«ã‚ˆã‚‹æ•°å€¤è¡¨ç¾ \- åˆ†å­ãƒ»çµæ™¶ã®ã‚°ãƒ©ãƒ•è¡¨ç¾

  3. **GNNã®åˆ©ç‚¹** \- End-to-Endã®ç‰¹å¾´é‡å­¦ç¿’ \- è»¢ç§»å­¦ç¿’ï¼ˆå°‘ãªã„ãƒ‡ãƒ¼ã‚¿ã§é«˜ç²¾åº¦ï¼‰ \- è§£é‡ˆå¯èƒ½æ€§ï¼ˆé‡è¦åŸå­ã®ç‰¹å®šï¼‰

  4. **æˆåŠŸäº‹ä¾‹** \- OC20ï¼ˆè§¦åª’ã€240ä¸‡å€é«˜é€ŸåŒ–ï¼‰ \- QM9ï¼ˆåˆ†å­ç‰¹æ€§ã€84-97%ç²¾åº¦æ”¹å–„ï¼‰ \- Materials Projectï¼ˆçµæ™¶ã€74%ç²¾åº¦æ”¹å–„ï¼‰

### é‡è¦ãªãƒã‚¤ãƒ³ãƒˆ

  * âœ… ææ–™ãƒ»åˆ†å­ã¯**ã‚°ãƒ©ãƒ•** ã¨ã—ã¦è¡¨ç¾ã§ãã‚‹
  * âœ… ã‚°ãƒ©ãƒ•è¡¨ç¾ã¯å¾“æ¥ã®ãƒ™ã‚¯ãƒˆãƒ«è¡¨ç¾ã‚ˆã‚Š**æƒ…å ±é‡ãŒå¤šã„**
  * âœ… GNNã¯**æ§‹é€ ã‚’ç†è§£ã™ã‚‹** AIã§ã‚ã‚‹
  * âœ… å®Ÿä¸–ç•Œã§**æ¡é•ã„ã®é«˜é€ŸåŒ–** ã‚’å®Ÿç¾
  * âœ… åŒ–å­¦ãƒ»ææ–™ç§‘å­¦ã®**æ¨™æº–ãƒ„ãƒ¼ãƒ«** ã«ãªã‚Šã¤ã¤ã‚ã‚‹

### æ¬¡ã®ç« ã¸

ç¬¬2ç« ã§ã¯ã€**GNNã®åŸºç¤ç†è«–** ã‚’å­¦ã³ã¾ã™ï¼š \- Message Passingã®ä»•çµ„ã¿ \- GCNã€GATã€GraphSAGEã®é•ã„ \- SchNetã€DimeNetãªã©ææ–™ç§‘å­¦ç‰¹åŒ–GNN \- æ•°å­¦çš„ãªèƒŒæ™¯ã¨å®Ÿè£…ã®åŸºç¤

**[ç¬¬2ç« ï¼šGNNã®åŸºç¤ç†è«– â†’](<./chapter-2.html>)**

* * *

## æ¼”ç¿’å•é¡Œ

### å•é¡Œ1ï¼ˆé›£æ˜“åº¦ï¼šeasyï¼‰

æ¬¡ã®æ–‡ç« ã®æ­£èª¤ã‚’åˆ¤å®šã—ã¦ãã ã•ã„ã€‚

  1. ã‚°ãƒ©ãƒ•ã®éš£æ¥è¡Œåˆ—ã¯å¸¸ã«å¯¾ç§°è¡Œåˆ—ã§ã‚ã‚‹
  2. åˆ†å­ã®ç•°æ€§ä½“ã¯å¾“æ¥ã®ãƒ™ã‚¯ãƒˆãƒ«è¡¨ç¾ã§åŒºåˆ¥ã§ãã‚‹
  3. GNNã¯åŸå­é–“ã®çµåˆæƒ…å ±ã‚’æ´»ç”¨ã§ãã‚‹

ãƒ’ãƒ³ãƒˆ \- ç„¡å‘ã‚°ãƒ©ãƒ•ã¨æœ‰å‘ã‚°ãƒ©ãƒ•ã®é•ã„ã‚’è€ƒãˆã¾ã—ã‚‡ã† \- 1.2ç¯€ã®ã€Œé™ç•Œ1ã€ã‚’å¾©ç¿’ã—ã¾ã—ã‚‡ã† \- ã‚°ãƒ©ãƒ•è¡¨ç¾ã®åˆ©ç‚¹ã‚’æ€ã„å‡ºã—ã¾ã—ã‚‡ã†  è§£ç­”ä¾‹ **è§£ç­”**: 1\. **èª¤** - ç„¡å‘ã‚°ãƒ©ãƒ•ã®å ´åˆã®ã¿å¯¾ç§°ã€‚æœ‰å‘ã‚°ãƒ©ãƒ•ã¯éå¯¾ç§°ã€‚ 2\. **èª¤** - ãƒ™ã‚¯ãƒˆãƒ«è¡¨ç¾ã§ã¯ç•°æ€§ä½“ã‚’åŒºåˆ¥ã§ããªã„ï¼ˆåŒã˜çµ„æˆ â†’ åŒã˜ãƒ™ã‚¯ãƒˆãƒ«ï¼‰ 3\. **æ­£** - GNNã¯è¾ºï¼ˆçµåˆï¼‰æƒ…å ±ã‚’ç›´æ¥åˆ©ç”¨ã§ãã‚‹ **è§£èª¬**: 1ã«ã¤ã„ã¦ï¼š 
    
    
    # æœ‰å‘ã‚°ãƒ©ãƒ•ã®ä¾‹ï¼ˆéå¯¾ç§°ï¼‰
    import numpy as np
    A = np.array([
        [0, 1, 0],
        [0, 0, 1],
        [0, 0, 0]
    ])
    # A â‰  A^T ï¼ˆè»¢ç½®ã¨ç•°ãªã‚‹ï¼‰
    

2ã«ã¤ã„ã¦ï¼š \- n-butane ã¨ isobutane ã¯çµ„æˆãŒåŒã˜ï¼ˆCâ‚„Hâ‚â‚€ï¼‰ \- ãƒ™ã‚¯ãƒˆãƒ«è¡¨ç¾: [4, 10] â†’ åŒºåˆ¥ä¸å¯ \- ã‚°ãƒ©ãƒ•è¡¨ç¾: æ¥ç¶šãŒç•°ãªã‚‹ â†’ åŒºåˆ¥å¯èƒ½ 3ã«ã¤ã„ã¦ï¼š \- GNNã¯ `edge_index` ã§çµåˆæƒ…å ±ã‚’å—ã‘å–ã‚‹ \- ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ‘ãƒƒã‚·ãƒ³ã‚°ã§éš£æ¥åŸå­æƒ…å ±ã‚’é›†ç´„ 

* * *

### å•é¡Œ2ï¼ˆé›£æ˜“åº¦ï¼šmediumï¼‰

ä»¥ä¸‹ã®åˆ†å­ï¼ˆãƒ—ãƒ­ãƒ‘ãƒ³ã€Câ‚ƒHâ‚ˆï¼‰ã®ã‚°ãƒ©ãƒ•è¡¨ç¾ã‚’ä½œæˆã—ã€éš£æ¥è¡Œåˆ—ã‚’æ±‚ã‚ã¦ãã ã•ã„ã€‚
    
    
    æ§‹é€ : CHâ‚ƒ-CHâ‚‚-CHâ‚ƒ
    åŸå­ã®é †ç•ª: C1, C2, C3, H1, H2, H3, H4, H5, H6, H7, H8
    

**è¦æ±‚äº‹é …** : 1\. NetworkXã§ ã‚°ãƒ©ãƒ•ã‚’ä½œæˆ 2\. éš£æ¥è¡Œåˆ—ã‚’è¨ˆç®— 3\. ã‚°ãƒ©ãƒ•ã‚’å¯è¦–åŒ–

ãƒ’ãƒ³ãƒˆ \- ç‚­ç´ ã¯4æœ¬ã®çµåˆã‚’æŒã¤ \- C1-C2-C3ã®éª¨æ ¼ã‚’å…ˆã«ä½œã‚‹ \- æ°´ç´ ã¯æœ«ç«¯ã«è¿½åŠ  **ä½¿ç”¨ã™ã‚‹é–¢æ•°**: \- `nx.Graph()`: ã‚°ãƒ©ãƒ•ä½œæˆ \- `G.add_edge(u, v)`: è¾ºã®è¿½åŠ  \- `nx.adjacency_matrix(G)`: éš£æ¥è¡Œåˆ—  è§£ç­”ä¾‹
    
    
    import networkx as nx
    import numpy as np
    import matplotlib.pyplot as plt
    
    # ã‚°ãƒ©ãƒ•ã®ä½œæˆ
    G = nx.Graph()
    
    # ç‚­ç´ éª¨æ ¼ï¼ˆC1-C2-C3ï¼‰
    G.add_edge('C1', 'C2')
    G.add_edge('C2', 'C3')
    
    # æ°´ç´ ã®è¿½åŠ 
    # C1ã«3ã¤ã®æ°´ç´ 
    G.add_edge('C1', 'H1')
    G.add_edge('C1', 'H2')
    G.add_edge('C1', 'H3')
    
    # C2ã«2ã¤ã®æ°´ç´ 
    G.add_edge('C2', 'H4')
    G.add_edge('C2', 'H5')
    
    # C3ã«3ã¤ã®æ°´ç´ 
    G.add_edge('C3', 'H6')
    G.add_edge('C3', 'H7')
    G.add_edge('C3', 'H8')
    
    # éš£æ¥è¡Œåˆ—
    A = nx.adjacency_matrix(G).todense()
    print("éš£æ¥è¡Œåˆ—ï¼ˆ11Ã—11ï¼‰:")
    print(A)
    
    # å¯è¦–åŒ–
    pos = nx.spring_layout(G, seed=42)
    nx.draw(
        G, pos, with_labels=True,
        node_color='lightblue',
        node_size=1500,
        font_size=10,
        font_weight='bold',
        edge_color='gray'
    )
    plt.title('ãƒ—ãƒ­ãƒ‘ãƒ³ (Câ‚ƒHâ‚ˆ) ã®ã‚°ãƒ©ãƒ•è¡¨ç¾')
    plt.show()
    

**å‡ºåŠ›**: 
    
    
    éš£æ¥è¡Œåˆ—ï¼ˆ11Ã—11ï¼‰:
    [[0 1 0 1 1 1 0 0 0 0 0]  # C1
     [1 0 1 0 0 0 1 1 0 0 0]  # C2
     [0 1 0 0 0 0 0 0 1 1 1]  # C3
     [1 0 0 0 0 0 0 0 0 0 0]  # H1
     ...
    ]
    

**è§£èª¬**: 1\. **é ‚ç‚¹æ•°**: 11å€‹ï¼ˆCÃ—3 + HÃ—8ï¼‰ 2\. **è¾ºæ•°**: 10å€‹ï¼ˆC-CçµåˆÃ—2 + C-HçµåˆÃ—8ï¼‰ 3\. **æ¬¡æ•°**: \- C1: 4ï¼ˆC2 + H1 + H2 + H3ï¼‰ \- C2: 4ï¼ˆC1 + C3 + H4 + H5ï¼‰ \- C3: 4ï¼ˆC2 + H6 + H7 + H8ï¼‰ \- å„H: 1 **æ‹¡å¼µèª²é¡Œ**: \- ãƒ—ãƒ­ãƒšãƒ³ï¼ˆCâ‚ƒHâ‚†ã€äºŒé‡çµåˆã‚ã‚Šï¼‰ã®ã‚°ãƒ©ãƒ•ã‚’ä½œæˆã—ã¦ã¿ã¾ã—ã‚‡ã† \- éš£æ¥è¡Œåˆ—ã«çµåˆæ¬¡æ•°ï¼ˆsingle=1, double=2ï¼‰ã‚’åæ˜ ã•ã›ã¾ã—ã‚‡ã† 

* * *

### å•é¡Œ3ï¼ˆé›£æ˜“åº¦ï¼šhardï¼‰

ä»¥ä¸‹ã®ã‚·ãƒŠãƒªã‚ªã§ã€GNNãŒã©ã®ã‚ˆã†ã«æ´»ç”¨ã§ãã‚‹ã‹ææ¡ˆã—ã¦ãã ã•ã„ã€‚

**ã‚·ãƒŠãƒªã‚ª** : ã‚ãªãŸã¯è£½è–¬ä¼šç¤¾ã®ç ”ç©¶è€…ã§ã™ã€‚æ–°ã—ã„COVID-19æ²»ç™‚è–¬ã®å€™è£œåŒ–åˆç‰©ã‚’æ¢ç´¢ã—ã¦ã„ã¾ã™ã€‚

**èƒŒæ™¯** : \- æ—¢çŸ¥ã®é˜»å®³å‰¤: 1,000åŒ–åˆç‰©ï¼ˆæ´»æ€§ãƒ‡ãƒ¼ã‚¿ã‚ã‚Šï¼‰ \- å€™è£œåŒ–åˆç‰©ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹: 10å„„åŒ–åˆç‰© \- ç›®æ¨™: ã‚¦ã‚¤ãƒ«ã‚¹ã®ãƒ—ãƒ­ãƒ†ã‚¢ãƒ¼ã‚¼ï¼ˆã‚¿ãƒ³ãƒ‘ã‚¯è³ªï¼‰ã«çµåˆã™ã‚‹åŒ–åˆç‰©ã‚’è¦‹ã¤ã‘ã‚‹ \- åˆ¶ç´„: å®Ÿé¨“1åŒ–åˆç‰©ã‚ãŸã‚Š100ä¸‡å††ã€100ä¸‡æ™‚é–“/åŒ–åˆç‰©

**èª²é¡Œ** : 1\. GNNã‚’ä½¿ã£ãŸåŠ¹ç‡çš„ãªæ¢ç´¢æˆ¦ç•¥ã‚’ææ¡ˆã—ã¦ãã ã•ã„ 2\. å¿…è¦ãªãƒ‡ãƒ¼ã‚¿ã¨ãƒ¢ãƒ‡ãƒ«ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã‚’èª¬æ˜ã—ã¦ãã ã•ã„ 3\. æœŸå¾…ã•ã‚Œã‚‹åŠ¹æœï¼ˆã‚³ã‚¹ãƒˆå‰Šæ¸›ã€æ™‚é–“çŸ­ç¸®ï¼‰ã‚’è¦‹ç©ã‚‚ã£ã¦ãã ã•ã„

ãƒ’ãƒ³ãƒˆ **ã‚¢ãƒ—ãƒ­ãƒ¼ãƒ**: 1\. æ—¢çŸ¥ãƒ‡ãƒ¼ã‚¿ã§äº‹å‰å­¦ç¿’ 2\. GNNã§10å„„åŒ–åˆç‰©ã‚’ã‚¹ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚° 3\. ä¸Šä½å€™è£œã‚’å®Ÿé¨“æ¤œè¨¼ **è€ƒæ…®äº‹é …**: \- è»¢ç§»å­¦ç¿’ã®æ´»ç”¨ \- äºˆæ¸¬ç²¾åº¦ã¨æ¢ç´¢ç¯„å›²ã®ãƒˆãƒ¬ãƒ¼ãƒ‰ã‚ªãƒ• \- å®Ÿé¨“ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ã®æ´»ç”¨ï¼ˆã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ©ãƒ¼ãƒ‹ãƒ³ã‚°ï¼‰  è§£ç­”ä¾‹ **ææ¡ˆï¼šGNNé§†å‹•ã®æ®µéšçš„ã‚¹ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°** ### ã‚¹ãƒ†ãƒƒãƒ—1: ãƒ‡ãƒ¼ã‚¿æº–å‚™ã¨ãƒ¢ãƒ‡ãƒ«è¨“ç·´ 
    
    
    from torch_geometric.nn import GCNConv, global_max_pool
    import torch.nn.functional as F
    
    class DrugGNN(torch.nn.Module):
        def __init__(self):
            super().__init__()
            # ã‚°ãƒ©ãƒ•ç•³ã¿è¾¼ã¿å±¤
            self.conv1 = GCNConv(75, 128)  # åŸå­ç‰¹å¾´é‡75æ¬¡å…ƒ
            self.conv2 = GCNConv(128, 128)
            self.conv3 = GCNConv(128, 64)
    
            # å…¨çµåˆå±¤ï¼ˆé˜»å®³æ´»æ€§äºˆæ¸¬ï¼‰
            self.lin1 = torch.nn.Linear(64, 32)
            self.lin2 = torch.nn.Linear(32, 1)
    
        def forward(self, data):
            x, edge_index, batch = data.x, data.edge_index, data.batch
    
            # ã‚°ãƒ©ãƒ•ç•³ã¿è¾¼ã¿
            x = F.relu(self.conv1(x, edge_index))
            x = F.relu(self.conv2(x, edge_index))
            x = F.relu(self.conv3(x, edge_index))
    
            # ã‚°ãƒ©ãƒ•ãƒ¬ãƒ™ãƒ«äºˆæ¸¬
            x = global_max_pool(x, batch)
            x = F.relu(self.lin1(x))
            x = self.lin2(x)
            return x  # é˜»å®³æ´»æ€§ã‚¹ã‚³ã‚¢
    
    # è¨“ç·´ï¼ˆ1,000æ—¢çŸ¥åŒ–åˆç‰©ï¼‰
    model = DrugGNN()
    # ... è¨“ç·´ãƒ«ãƒ¼ãƒ—
    

### ã‚¹ãƒ†ãƒƒãƒ—2: å¤§è¦æ¨¡ã‚¹ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚° 
    
    
    # 10å„„åŒ–åˆç‰©ã‚’ä¸¦åˆ—äºˆæ¸¬
    def screen_compounds(model, compound_library, batch_size=1000):
        """
        å¤§è¦æ¨¡åŒ–åˆç‰©ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ã‚¹ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°
        """
        predictions = []
    
        for i in range(0, len(compound_library), batch_size):
            batch = compound_library[i:i+batch_size]
            # ã‚°ãƒ©ãƒ•ã«å¤‰æ›
            graphs = [smiles_to_graph(smiles) for smiles in batch]
            # äºˆæ¸¬
            scores = model.predict(graphs)
            predictions.extend(scores)
    
        # ä¸Šä½1,000åŒ–åˆç‰©ã‚’é¸æŠ
        top_candidates = sorted(
            zip(compound_library, predictions),
            key=lambda x: x[1],
            reverse=True
        )[:1000]
    
        return top_candidates
    
    # å®Ÿè¡Œ
    top_1000 = screen_compounds(model, billion_compounds)
    

### ã‚¹ãƒ†ãƒƒãƒ—3: å®Ÿé¨“æ¤œè¨¼ã¨ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ 
    
    
    # ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ©ãƒ¼ãƒ‹ãƒ³ã‚°
    for iteration in range(10):
        # ä¸Šä½100åŒ–åˆç‰©ã‚’å®Ÿé¨“æ¤œè¨¼
        experimental_results = run_experiments(top_1000[:100])
    
        # ãƒ¢ãƒ‡ãƒ«ã‚’å†è¨“ç·´ï¼ˆæ–°ãƒ‡ãƒ¼ã‚¿ã‚’è¿½åŠ ï¼‰
        model.finetune(experimental_results)
    
        # æ®‹ã‚Šã®åŒ–åˆç‰©ã‚’å†ã‚¹ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°
        top_1000 = screen_compounds(
            model,
            remaining_compounds
        )
    

\--- ### æœŸå¾…ã•ã‚Œã‚‹åŠ¹æœ **ã‚³ã‚¹ãƒˆå‰Šæ¸›**: 
    
    
    å¾“æ¥æ‰‹æ³•ï¼ˆãƒ©ãƒ³ãƒ€ãƒ ã‚¹ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°ï¼‰:
    - å®Ÿé¨“æ•°: 10,000åŒ–åˆç‰©
    - ã‚³ã‚¹ãƒˆ: 10,000 Ã— 100ä¸‡å†† = 100å„„å††
    - æ™‚é–“: 10,000 Ã— 1ä¸‡æ™‚é–“ = 1å„„æ™‚é–“ â‰ˆ 11,000å¹´
    
    GNNæ‰‹æ³•:
    - è¨ˆç®—ã‚¹ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°: 10å„„åŒ–åˆç‰©ï¼ˆ1é€±é–“ã€1,000ä¸‡å††ï¼‰
    - å®Ÿé¨“æ¤œè¨¼: 1,000åŒ–åˆç‰©ï¼ˆ10å„„å††ã€1ä¸‡æ™‚é–“ â‰ˆ 1å¹´ï¼‰
    - ç·ã‚³ã‚¹ãƒˆ: 11å„„å††ï¼ˆ91%å‰Šæ¸›ï¼‰
    - ç·æ™‚é–“: 1å¹´ï¼ˆ99.99%çŸ­ç¸®ï¼‰
    

**ç²¾åº¦å‘ä¸Š**: \- ãƒ’ãƒƒãƒˆç‡: 0.1% â†’ 10%ï¼ˆ100å€å‘ä¸Šï¼‰ \- äº‹å‰å­¦ç¿’ãƒ¢ãƒ‡ãƒ«ï¼ˆChemBERTaç­‰ï¼‰æ´»ç”¨ã§æ›´ã«æ”¹å–„ \--- ### è¿½åŠ ã®æ¤œè¨äº‹é … **ãƒªã‚¹ã‚¯ç®¡ç†**: 1\. **False Positiveï¼ˆå½é™½æ€§ï¼‰** \- GNNäºˆæ¸¬ãŒé«˜ãã¦ã‚‚å®Ÿé¨“ã§å¤±æ•— \- å¯¾ç­–: ä¸ç¢ºå®Ÿæ€§æ¨å®šï¼ˆãƒ™ã‚¤ã‚ºGNNï¼‰ 2\. **ãƒ‡ãƒ¼ã‚¿ãƒã‚¤ã‚¢ã‚¹** \- æ—¢çŸ¥åŒ–åˆç‰©ã«é¡ä¼¼ã—ãŸæ§‹é€ ã«åã‚‹ \- å¯¾ç­–: å¤šæ§˜æ€§ã‚’è€ƒæ…®ã—ãŸæ¢ç´¢ 3\. **ç‰¹è¨±ãƒ»è¦åˆ¶** \- å€™è£œåŒ–åˆç‰©ã®çŸ¥è²¡ç¢ºèª \- æ¯’æ€§ãƒ»å‰¯ä½œç”¨äºˆæ¸¬ **å®Ÿè£…ã®è©³ç´°**: \- ãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢: GPUÃ—8å°ï¼ˆ1é€±é–“ã§10å„„åŒ–åˆç‰©ï¼‰ \- ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢: PyTorch Geometric, RDKit, DeepChem \- ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹: PubChemã€ZINCã€ChEMBL \--- ### å­¦ã‚“ã ã‚¹ã‚­ãƒ« ã“ã®æ¼”ç¿’ã‚’é€šã˜ã¦ï¼š \- âœ… GNNã®ç”£æ¥­å¿œç”¨ã‚’å…·ä½“åŒ–ã§ããŸ \- âœ… ã‚³ã‚¹ãƒˆãƒ»æ™‚é–“ãƒ»ç²¾åº¦ã®ãƒˆãƒ¬ãƒ¼ãƒ‰ã‚ªãƒ•ã‚’åˆ†æã§ããŸ \- âœ… æ®µéšçš„ã‚¹ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°æˆ¦ç•¥ã‚’è¨­è¨ˆã§ããŸ \- âœ… ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ©ãƒ¼ãƒ‹ãƒ³ã‚°ã®é‡è¦æ€§ã‚’ç†è§£ã—ãŸ 

* * *

## å‚è€ƒæ–‡çŒ®

  1. Gilmer, J. et al. (2017). "Neural Message Passing for Quantum Chemistry." _ICML_. DOI: <https://arxiv.org/abs/1704.01212>

  2. Chanussot, L. et al. (2021). "Open Catalyst 2020 (OC20) Dataset and Community Challenges." _ACS Catalysis_ , 11, 6059-6072. DOI: <https://doi.org/10.1021/acscatal.0c04525>

  3. Xie, T. & Grossman, J. C. (2018). "Crystal Graph Convolutional Neural Networks for an Accurate and Interpretable Prediction of Material Properties." _Physical Review Letters_ , 120, 145301. DOI: <https://doi.org/10.1103/PhysRevLett.120.145301>

  4. SchÃ¼tt, K. T. et al. (2017). "SchNet: A continuous-filter convolutional neural network for modeling quantum interactions." _NeurIPS_. DOI: <https://arxiv.org/abs/1706.08566>

  5. Wu, Z. et al. (2020). "A Comprehensive Survey on Graph Neural Networks." _IEEE Transactions on Neural Networks and Learning Systems_ , 32(1), 4-24. DOI: <https://doi.org/10.1109/TNNLS.2020.2978386>

* * *

## ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³

### æ¬¡ã®ç« 

**[ç¬¬2ç« ï¼šGNNã®åŸºç¤ç†è«– â†’](<./chapter-2.html>)**

### ã‚·ãƒªãƒ¼ã‚ºç›®æ¬¡

**[â† ã‚·ãƒªãƒ¼ã‚ºç›®æ¬¡ã«æˆ»ã‚‹](<./index.html>)**

* * *

## è‘—è€…æƒ…å ±

**ä½œæˆè€…** : AI Terakoya Content Team **ä½œæˆæ—¥** : 2025-10-17 **ãƒãƒ¼ã‚¸ãƒ§ãƒ³** : 1.0

**æ›´æ–°å±¥æ­´** : \- 2025-10-17: v1.0 åˆç‰ˆå…¬é–‹

**ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯** : \- GitHub Issues: [ãƒªãƒã‚¸ãƒˆãƒªURL]/issues \- Email: yusuke.hashimoto.b8@tohoku.ac.jp

**ãƒ©ã‚¤ã‚»ãƒ³ã‚¹** : Creative Commons BY 4.0

* * *

**ç¬¬2ç« ã§ã€GNNã®å†…éƒ¨ãƒ¡ã‚«ãƒ‹ã‚ºãƒ ã‚’è©³ã—ãå­¦ã³ã¾ã—ã‚‡ã†ï¼**
