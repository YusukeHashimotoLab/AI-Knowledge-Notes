<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Á¨¨2Á´†Ôºö„Çπ„Éö„ÇØ„Éà„É´„Éá„Éº„ÇøËß£Êûê - AI Terakoya</title>

    <style>
        :root {
            --color-primary: #2c3e50;
            --color-primary-dark: #1a252f;
            --color-accent: #7b2cbf;
            --color-accent-light: #9d4edd;
            --color-text: #2d3748;
            --color-text-light: #4a5568;
            --color-bg: #ffffff;
            --color-bg-alt: #f7fafc;
            --color-border: #e2e8f0;
            --color-code-bg: #f8f9fa;
            --color-link: #3182ce;
            --color-link-hover: #2c5aa0;

            --spacing-xs: 0.5rem;
            --spacing-sm: 1rem;
            --spacing-md: 1.5rem;
            --spacing-lg: 2rem;
            --spacing-xl: 3rem;

            --font-body: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            --font-mono: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;

            --border-radius: 8px;
            --box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-body);
            line-height: 1.7;
            color: var(--color-text);
            background-color: var(--color-bg);
            font-size: 16px;
        }

        header {
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            color: white;
            padding: var(--spacing-xl) var(--spacing-md);
            margin-bottom: var(--spacing-xl);
            box-shadow: var(--box-shadow);
        }

        .header-content {
            max-width: 900px;
            margin: 0 auto;
        }

        h1 {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: var(--spacing-sm);
            line-height: 1.2;
        }

        .subtitle {
            font-size: 1.1rem;
            opacity: 0.95;
            font-weight: 400;
            margin-bottom: var(--spacing-md);
        }

        .meta {
            display: flex;
            flex-wrap: wrap;
            gap: var(--spacing-md);
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .meta-item {
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 0 var(--spacing-md) var(--spacing-xl);
        }

        h2 {
            font-size: 1.75rem;
            color: var(--color-primary);
            margin-top: var(--spacing-xl);
            margin-bottom: var(--spacing-md);
            padding-bottom: var(--spacing-xs);
            border-bottom: 3px solid var(--color-accent);
        }

        h3 {
            font-size: 1.4rem;
            color: var(--color-primary);
            margin-top: var(--spacing-lg);
            margin-bottom: var(--spacing-sm);
        }

        h4 {
            font-size: 1.1rem;
            color: var(--color-primary-dark);
            margin-top: var(--spacing-md);
            margin-bottom: var(--spacing-sm);
        }

        p {
            margin-bottom: var(--spacing-md);
            color: var(--color-text);
        }

        a {
            color: var(--color-link);
            text-decoration: none;
            transition: color 0.2s;
        }

        a:hover {
            color: var(--color-link-hover);
            text-decoration: underline;
        }

        ul, ol {
            margin-left: var(--spacing-lg);
            margin-bottom: var(--spacing-md);
        }

        li {
            margin-bottom: var(--spacing-xs);
            color: var(--color-text);
        }

        pre {
            background-color: var(--color-code-bg);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            overflow-x: auto;
            margin-bottom: var(--spacing-md);
            font-family: var(--font-mono);
            font-size: 0.9rem;
            line-height: 1.5;
        }

        code {
            font-family: var(--font-mono);
            font-size: 0.9em;
            background-color: var(--color-code-bg);
            padding: 0.2em 0.4em;
            border-radius: 3px;
        }

        pre code {
            background-color: transparent;
            padding: 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: var(--spacing-md);
            font-size: 0.95rem;
        }

        th, td {
            border: 1px solid var(--color-border);
            padding: var(--spacing-sm);
            text-align: left;
        }

        th {
            background-color: var(--color-bg-alt);
            font-weight: 600;
            color: var(--color-primary);
        }

        blockquote {
            border-left: 4px solid var(--color-accent);
            padding-left: var(--spacing-md);
            margin: var(--spacing-md) 0;
            color: var(--color-text-light);
            font-style: italic;
            background-color: var(--color-bg-alt);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        .mermaid {
            text-align: center;
            margin: var(--spacing-lg) 0;
            background-color: var(--color-bg-alt);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        details {
            background-color: var(--color-bg-alt);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            margin-bottom: var(--spacing-md);
        }

        summary {
            cursor: pointer;
            font-weight: 600;
            color: var(--color-primary);
            user-select: none;
            padding: var(--spacing-xs);
            margin: calc(-1 * var(--spacing-md));
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        summary:hover {
            background-color: rgba(123, 44, 191, 0.1);
        }

        details[open] summary {
            margin-bottom: var(--spacing-md);
            border-bottom: 1px solid var(--color-border);
        }

        .learning-objectives {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            padding: var(--spacing-lg);
            border-radius: var(--border-radius);
            border-left: 4px solid var(--color-accent);
            margin-bottom: var(--spacing-xl);
        }

        .learning-objectives h2 {
            margin-top: 0;
            border-bottom: none;
        }

        .navigation {
            display: flex;
            justify-content: space-between;
            gap: var(--spacing-md);
            margin: var(--spacing-xl) 0;
            padding-top: var(--spacing-lg);
            border-top: 2px solid var(--color-border);
        }

        .nav-button {
            flex: 1;
            padding: var(--spacing-md);
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            color: white;
            border-radius: var(--border-radius);
            text-align: center;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: var(--box-shadow);
        }

        .nav-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            text-decoration: none;
        }

        footer {
            margin-top: var(--spacing-xl);
            padding: var(--spacing-lg) var(--spacing-md);
            background-color: var(--color-bg-alt);
            border-top: 1px solid var(--color-border);
            text-align: center;
            font-size: 0.9rem;
            color: var(--color-text-light);
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.5rem;
            }

            h2 {
                font-size: 1.4rem;
            }

            h3 {
                font-size: 1.2rem;
            }

            .meta {
                font-size: 0.85rem;
            }

            .navigation {
                flex-direction: column;
            }

            table {
                font-size: 0.85rem;
            }

            th, td {
                padding: var(--spacing-xs);
            }
        }
    </style>

    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ startOnLoad: true, theme: 'default' });
    </script>

    <!-- MathJax for LaTeX equation rendering -->
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\(', '\)']],
                displayMath: [['$$', '$$'], ['\[', '\]']],
                processEscapes: true,
                processEnvironments: true
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
                ignoreHtmlClass: 'mermaid'
            }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" id="MathJax-script" async></script>
</head>
<body>
    <header>
        <div class="header-content">
            <h1>Á¨¨2Á´†Ôºö„Çπ„Éö„ÇØ„Éà„É´„Éá„Éº„ÇøËß£Êûê</h1>
            <p class="subtitle">XRD„ÉªXPS„ÉªIR„ÉªRaman„ÅÆËá™ÂãïËß£Êûê - ÊßãÈÄ†„ÉªÁµÑÊàêÊÉÖÂ†±„ÅÆÊäΩÂá∫</p>
            <div class="meta">
                <span class="meta-item">üìñ Ë™≠‰∫ÜÊôÇÈñì: 25-30ÂàÜ</span>
                <span class="meta-item">üìä Èõ£ÊòìÂ∫¶: ‰∏≠Á¥ö</span>
                <span class="meta-item">üíª „Ç≥„Éº„Éâ‰æã: 11ÂÄã</span>
                <span class="meta-item">üìù ÊºîÁøíÂïèÈ°å: 3Âïè</span>
            </div>
        </div>
    </header>

    <main class="container">
<h1>Á¨¨2Á´†Ôºö„Çπ„Éö„ÇØ„Éà„É´„Éá„Éº„ÇøËß£Êûê</h1>
<p class="chapter-description" style="margin: 1.5rem 0; padding: 1rem; background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); border-left: 4px solid #7b2cbf; border-radius: 8px; font-size: 1.05rem; line-height: 1.8; color: #2d3748;">„Éî„Éº„ÇØÂêåÂÆö„Åã„Çâ„É™„Éï„Ç°„Ç§„É≥„É°„É≥„Éà„Åæ„Åß„ÄÅXRDËß£Êûê„ÅÆË¶ÅÁÇπ„ÇíPython„Åß‰ΩìÈ®ì„Åó„Åæ„Åô„ÄÇËá™ÂãïÂåñ„Åß„Éí„É•„Éº„Éû„É≥„Ç®„É©„Éº„ÇíÊ∏õ„Çâ„ÅôË¶ñÁÇπ„ÇíÂ≠¶„Å≥„Åæ„Åô„ÄÇ</p>




<p><strong>XRD„ÉªXPS„ÉªIR„ÉªRaman„ÅÆËá™ÂãïËß£Êûê - ÊßãÈÄ†„ÉªÁµÑÊàêÊÉÖÂ†±„ÅÆÊäΩÂá∫</strong></p>
<h2>Â≠¶ÁøíÁõÆÊ®ô</h2>
<p>„Åì„ÅÆÁ´†„ÇíË™≠„ÇÄ„Åì„Å®„Åß„ÄÅ‰ª•‰∏ã„ÇíÁøíÂæó„Åß„Åç„Åæ„ÅôÔºö</p>
<ul>
<li>‚úÖ XRD„ÉªXPS„ÉªIR„ÉªRaman„Çπ„Éö„ÇØ„Éà„É´„ÅÆÁâπÂæ¥„ÇíÁêÜËß£„Åó„ÄÅÈÅ©Âàá„Å™ÂâçÂá¶ÁêÜ„ÇíÈÅ∏Êäû„Åß„Åç„Çã</li>
<li>‚úÖ „Éî„Éº„ÇØÊ§úÂá∫„Ç¢„É´„Ç¥„É™„Ç∫„É†„ÇíÂÆüË£Ö„Åó„ÄÅ„Éî„Éº„ÇØ‰ΩçÁΩÆ„ÉªÂº∑Â∫¶„ÇíÂÆöÈáè„Åß„Åç„Çã</li>
<li>‚úÖ „Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÈô§ÂéªÊâãÊ≥ïÔºàÂ§öÈ†ÖÂºè„Éï„Ç£„ÉÉ„ÉÜ„Ç£„É≥„Ç∞„ÄÅSNIPÔºâ„Çí‰Ωø„ÅÑÂàÜ„Åë„Çâ„Çå„Çã</li>
<li>‚úÖ XRD„Éë„Çø„Éº„É≥„Åã„ÇâÂÆöÈáèÁõ∏ÂàÜÊûêÔºàRIRÊ≥ïÔºâ„ÇíÂÆüË°å„Åß„Åç„Çã</li>
<li>‚úÖ „Çπ„Éö„ÇØ„Éà„É´Ëß£Êûê„Éë„Ç§„Éó„É©„Ç§„É≥„ÇíËá™ÂãïÂåñ„Åß„Åç„Çã</li>
</ul>
<p><strong>Ë™≠‰∫ÜÊôÇÈñì</strong>: 25-30ÂàÜ
<strong>„Ç≥„Éº„Éâ‰æã</strong>: 11ÂÄã
<strong>ÊºîÁøíÂïèÈ°å</strong>: 3Âïè</p>
<hr />
<h2>2.1 „Çπ„Éö„ÇØ„Éà„É´„Éá„Éº„Çø„ÅÆÁâπÂæ¥„Å®ÂâçÂá¶ÁêÜÊà¶Áï•</h2>
<h3>ÂêÑÊ∏¨ÂÆöÊäÄË°ì„ÅÆÁâπÂæ¥</h3>
<p>ÊùêÊñôÁßëÂ≠¶„ÅßÈ†ªÁπÅ„Å´‰ΩøÁî®„Åï„Çå„Çã4„Å§„ÅÆ„Çπ„Éö„ÇØ„Éà„É´Ê∏¨ÂÆöÊäÄË°ì„ÅÆÁâπÂæ¥„ÇíÁêÜËß£„Åô„Çã„Åì„Å®„ÅØ„ÄÅÈÅ©Âàá„Å™Ëß£ÊûêÊâãÊ≥ï„ÇíÈÅ∏Êäû„Åô„Çã‰∏ä„ÅßÈáçË¶Å„Åß„Åô„ÄÇ</p>
<table>
<thead>
<tr>
<th>Ê∏¨ÂÆöÊäÄË°ì</th>
<th>Âæó„Çâ„Çå„ÇãÊÉÖÂ†±</th>
<th>„Éî„Éº„ÇØ„ÅÆÁâπÂæ¥</th>
<th>ÂÖ∏ÂûãÁöÑ„Å™„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„Éâ</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>XRD</strong></td>
<td>ÁµêÊô∂ÊßãÈÄ†„ÄÅÁõ∏ÂêåÂÆö</td>
<td>„Ç∑„É£„Éº„ÉóÔºàÂõûÊäò„Éî„Éº„ÇØÔºâ</td>
<td>‰ΩéÂº∑Â∫¶„ÄÅÁ∑©„ÇÑ„Åã„Å™‰∏äÊòáÔºàÈùûÊô∂Ë≥™Ôºâ</td>
</tr>
<tr>
<td><strong>XPS</strong></td>
<td>ÂÖÉÁ¥†ÁµÑÊàê„ÄÅÂåñÂ≠¶Áä∂ÊÖã</td>
<td>ÈùûÂØæÁß∞Ôºà„Çπ„Éî„É≥ËªåÈÅìÂàÜË£ÇÔºâ</td>
<td>„Ç∑„É£„Éº„É™„ÉºÂûãÔºàÈùûÂºæÊÄßÊï£‰π±Ôºâ</td>
</tr>
<tr>
<td><strong>IR</strong></td>
<td>ÂàÜÂ≠êÊåØÂãï„ÄÅÂÆòËÉΩÂü∫</td>
<td>„Ç∑„É£„Éº„Éó„Äú„Éñ„É≠„Éº„Éâ</td>
<td>„Åª„Åº„Éï„É©„ÉÉ„ÉàÔºàÈÄèÈÅéÊ≥ïÔºâ</td>
</tr>
<tr>
<td><strong>Raman</strong></td>
<td>ÁµêÊô∂ÊÄß„ÄÅÂàÜÂ≠êÊåØÂãï</td>
<td>„Ç∑„É£„Éº„ÉóÔºàÁµêÊô∂ÊÄßÈ´òÔºâ</td>
<td>ËõçÂÖâ„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÔºàÊúâÊ©üÁâ©Ôºâ</td>
</tr>
</tbody>
</table>
<h3>„Çπ„Éö„ÇØ„Éà„É´Ëß£Êûê„ÅÆÂÖ∏ÂûãÁöÑ„ÉØ„Éº„ÇØ„Éï„É≠„Éº</h3>
<div class="mermaid">
flowchart TD
    A[„Çπ„Éö„ÇØ„Éà„É´Ê∏¨ÂÆö] --> B[„Éá„Éº„ÇøË™≠„ÅøËæº„Åø]
    B --> C[„Éé„Ç§„Ç∫Èô§Âéª]
    C --> D[„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÈô§Âéª]
    D --> E[„Éî„Éº„ÇØÊ§úÂá∫]
    E --> F[„Éî„Éº„ÇØ„Éï„Ç£„ÉÉ„ÉÜ„Ç£„É≥„Ç∞]
    F --> G[ÂÆöÈáèËß£Êûê]
    G --> H[ÁµêÊûúÂèØË¶ñÂåñ]

    style A fill:#e3f2fd
    style D fill:#fff3e0
    style E fill:#f3e5f5
    style G fill:#e8f5e9
    style H fill:#fce4ec
</div>

<p><strong>ÂêÑ„Çπ„ÉÜ„ÉÉ„Éó„ÅÆÁõÆÁöÑ</strong>:
1. <strong>„Éé„Ç§„Ç∫Èô§Âéª</strong>: S/NÊØîÂêë‰∏äÔºàÁ¨¨1Á´†„ÅßÂ≠¶ÁøíÊ∏à„ÅøÔºâ
2. <strong>„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÈô§Âéª</strong>: „Éô„Éº„Çπ„É©„Ç§„É≥Ë£úÊ≠£
3. <strong>„Éî„Éº„ÇØÊ§úÂá∫</strong>: „Éî„Éº„ÇØ‰ΩçÁΩÆ„ÅÆËá™ÂãïÂêåÂÆö
4. <strong>„Éî„Éº„ÇØ„Éï„Ç£„ÉÉ„ÉÜ„Ç£„É≥„Ç∞</strong>: „Éî„Éº„ÇØÂΩ¢Áä∂„ÅÆ„É¢„Éá„É´Âåñ
5. <strong>ÂÆöÈáèËß£Êûê</strong>: ÁµÑÊàê„ÉªÁõ∏ÂàÜÁéá„ÅÆÁÆóÂá∫</p>
<hr />
<h2>2.2 „Éá„Éº„Çø„É©„Ç§„Çª„É≥„Çπ„Å®ÂÜçÁèæÊÄß</h2>
<h3>„Çπ„Éö„ÇØ„Éà„É´„Éá„Éº„Çø„É™„Éù„Ç∏„Éà„É™„Å®„É©„Ç§„Çª„É≥„Çπ</h3>
<p>„Çπ„Éö„ÇØ„Éà„É´Ëß£Êûê„Åß„ÅØ„ÄÅÊ®ôÊ∫ñ„Éá„Éº„Çø„Éô„Éº„Çπ„ÇÑÂÖ¨Èñã„Éá„Éº„Çø„ÅÆÊ¥ªÁî®„ÅåÈáçË¶Å„Åß„Åô„ÄÇ</p>
<h4>‰∏ªË¶Å„Å™„Çπ„Éö„ÇØ„Éà„É´„Éá„Éº„Çø„Éô„Éº„Çπ</h4>
<table>
<thead>
<tr>
<th>„Éá„Éº„Çø„Éô„Éº„Çπ</th>
<th>ÂÜÖÂÆπ</th>
<th>„É©„Ç§„Çª„É≥„Çπ</th>
<th>„Ç¢„ÇØ„Çª„Çπ</th>
<th>ÂºïÁî®Ë¶Å‰ª∂</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>ICDD PDF-4+</strong></td>
<td>XRDÊ®ôÊ∫ñ„Éë„Çø„Éº„É≥</td>
<td>ÂïÜÁî®„É©„Ç§„Çª„É≥„Çπ</td>
<td>ÊúâÊñô„Çµ„Éñ„Çπ„ÇØ„É™„Éó„Ç∑„Éß„É≥</td>
<td>ÂøÖÈ†à</td>
</tr>
<tr>
<td><strong>COD (Crystallography Open Database)</strong></td>
<td>ÁµêÊô∂ÊßãÈÄ†„ÉªXRD</td>
<td>CC0 / Public Domain</td>
<td>ÁÑ°Êñô</td>
<td>Êé®Â•®</td>
</tr>
<tr>
<td><strong>NIST XPS Database</strong></td>
<td>XPSÊ®ôÊ∫ñ„Çπ„Éö„ÇØ„Éà„É´</td>
<td>Public Domain</td>
<td>ÁÑ°Êñô</td>
<td>ÂøÖÈ†à</td>
</tr>
<tr>
<td><strong>RRUFF Project</strong></td>
<td>Raman/IRÈâ±Áâ©„Çπ„Éö„ÇØ„Éà„É´</td>
<td>CC BY-NC-SA 3.0</td>
<td>ÁÑ°Êñô</td>
<td>ÂøÖÈ†à</td>
</tr>
<tr>
<td><strong>SDBS (Spectral Database)</strong></td>
<td>IR/RamanÊúâÊ©üÂåñÂêàÁâ©</td>
<td>ÁÑ°Êñô</td>
<td>ÁÑ°Êñô</td>
<td>Êé®Â•®</td>
</tr>
</tbody>
</table>
<h4>„Éá„Éº„ÇøÂà©Áî®ÊôÇ„ÅÆÊ≥®ÊÑè‰∫ãÈ†Ö</h4>
<p><strong>ÂïÜÁî®„Éá„Éº„Çø„Éô„Éº„ÇπÂà©Áî®ÊôÇ</strong>:</p>
<pre><code class="language-python"># ICDD PDF-4+„Éá„Éº„Çø„Çí‰ΩøÁî®„Åô„ÇãÂ†¥Âêà„ÅÆ„Ç≥„É°„É≥„Éà‰æã
&quot;&quot;&quot;
XRD peak matching using ICDD PDF-4+ database.
Reference: ICDD PDF-4+ 2024 (Entry 01-089-0599)
License: International Centre for Diffraction Data
Note: Commercial license required for publication use
&quot;&quot;&quot;
</code></pre>
<p><strong>„Ç™„Éº„Éó„É≥„Éá„Éº„ÇøÂà©Áî®ÊôÇ</strong>:</p>
<pre><code class="language-python"># COD (Crystallography Open Database)‰ΩøÁî®‰æã
&quot;&quot;&quot;
Crystal structure data from COD.
Reference: COD Entry 1234567
Citation: Gra≈æulis, S. et al. (2012) Nucleic Acids Research, 40, D420-D427
License: CC0 1.0 Universal (Public Domain)
URL: http://www.crystallography.net/cod/1234567.html
&quot;&quot;&quot;
</code></pre>
<h3>„Ç≥„Éº„ÉâÂÜçÁèæÊÄß„ÅÆ„Éô„Çπ„Éà„Éó„É©„ÇØ„ÉÜ„Ç£„Çπ</h3>
<h4>Áí∞Â¢ÉÊÉÖÂ†±„ÅÆË®òÈå≤</h4>
<pre><code class="language-python">import sys
import numpy as np
import scipy
from scipy import signal
import matplotlib

print(&quot;=== „Çπ„Éö„ÇØ„Éà„É´Ëß£ÊûêÁí∞Â¢É ===&quot;)
print(f&quot;Python: {sys.version}&quot;)
print(f&quot;NumPy: {np.__version__}&quot;)
print(f&quot;SciPy: {scipy.__version__}&quot;)
print(f&quot;Matplotlib: {matplotlib.__version__}&quot;)

# Êé®Â•®„Éê„Éº„Ç∏„Éß„É≥Ôºà2025Âπ¥10ÊúàÊôÇÁÇπÔºâ:
# - Python: 3.10‰ª•‰∏ä
# - NumPy: 1.24‰ª•‰∏ä
# - SciPy: 1.10‰ª•‰∏ä
# - Matplotlib: 3.7‰ª•‰∏ä
</code></pre>
<h4>„Éë„É©„É°„Éº„Çø„ÅÆÊñáÊõ∏Âåñ</h4>
<p><strong>ÊÇ™„ÅÑ‰æã</strong>ÔºàÂÜçÁèæ‰∏çÂèØËÉΩÔºâ:</p>
<pre><code class="language-python">bg = snip_background(spectrum, 50)  # „Å™„Åú50?
</code></pre>
<p><strong>ËâØ„ÅÑ‰æã</strong>ÔºàÂÜçÁèæÂèØËÉΩÔºâ:</p>
<pre><code class="language-python"># SNIPÊ≥ï„Éë„É©„É°„Éº„ÇøË®≠ÂÆö
SNIP_ITERATIONS = 50  # „Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÂπÖ„ÅÆÊé®ÂÆöÂÄ§Ôºà„Éá„Éº„ÇøÁÇπ„ÅÆÁ¥Ñ5%Ôºâ
SNIP_DESCRIPTION = &quot;&quot;&quot;
„Ç§„ÉÜ„É¨„Éº„Ç∑„Éß„É≥ÂõûÊï∞„ÅØ„ÄÅ„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„Éâ„ÅÆÁâπÂæ¥ÁöÑ„Å™ÂπÖ„Å´ÂØæÂøú„ÄÇ
XRD„Éá„Éº„ÇøÔºà700ÁÇπ„ÄÅ2Œ∏=10-80¬∞Ôºâ„Åß„ÅØ„ÄÅÂπÖÁ¥Ñ10¬∞‚âà100ÁÇπ„Å´ÂØæÂøú„Åô„Çã„Åü„ÇÅ„ÄÅ
iterations=50ÔºàÂπÖ„ÅÆÂçäÂàÜÁ®ãÂ∫¶Ôºâ„ÅåÈÅ©Âàá„ÄÇ
&quot;&quot;&quot;
bg = snip_background(spectrum, iterations=SNIP_ITERATIONS)
</code></pre>
<h4>Ëß£Êûê„Éë„É©„É°„Éº„Çø„ÅÆË®òÈå≤</h4>
<pre><code class="language-python"># „Éî„Éº„ÇØÊ§úÂá∫„Éë„É©„É°„Éº„ÇøÔºàÂÆüÈ®ì„Éé„Éº„Éà„Å´Ë®òÈå≤„Åô„Åπ„ÅçÊÉÖÂ†±Ôºâ
PEAK_DETECTION_PARAMS = {
    'method': 'find_peaks',
    'prominence': 100,  # countsÔºà„Éé„Ç§„Ç∫„É¨„Éô„É´„ÅÆÁ¥Ñ5ÂÄçÔºâ
    'distance': 10,     # pointsÔºàÁ¥Ñ0.1¬∞ in 2Œ∏Ôºâ
    'height': 50,       # countsÔºàÊúÄÂ∞èÁâ©ÁêÜÁöÑÊÑèÂë≥„ÅÆ„ÅÇ„ÇãÂº∑Â∫¶Ôºâ
    'width': 3,         # pointsÔºàÊúÄÂ∞è„Éî„Éº„ÇØÂπÖÔºâ
    'noise_level': 20   # countsÔºà„Éô„Éº„Çπ„É©„Ç§„É≥È†òÂüü„ÅÆÊ®ôÊ∫ñÂÅèÂ∑ÆÔºâ
}

# „Éë„É©„É°„Éº„Çø„ÇíJSON‰øùÂ≠òÔºàÂÜçÁèæÊÄßÊãÖ‰øùÔºâ
import json
with open('peak_detection_params.json', 'w') as f:
    json.dump(PEAK_DETECTION_PARAMS, f, indent=2)
</code></pre>
<hr />
<h2>2.3 „Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÈô§ÂéªÊâãÊ≥ï</h2>
<h3>Â§öÈ†ÖÂºè„Éï„Ç£„ÉÉ„ÉÜ„Ç£„É≥„Ç∞Ê≥ï</h3>
<p>ÊúÄ„ÇÇ„Ç∑„É≥„Éó„É´„Å™ÊâãÊ≥ï„Åß„ÄÅ„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„Éâ„ÇíÂ§öÈ†ÖÂºè„ÅßËøë‰ºº„Åó„ÄÅÂÖÉ„Éá„Éº„Çø„Åã„ÇâÊ∏õÁÆó„Åó„Åæ„Åô„ÄÇ</p>
<p><strong>„Ç≥„Éº„Éâ‰æã1: Â§öÈ†ÖÂºè„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÈô§Âéª</strong></p>
<pre><code class="language-python"># XRD„Éë„Çø„Éº„É≥„ÅÆ„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÈô§Âéª
import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import savgol_filter

# „Çµ„É≥„Éó„É´XRD„Éá„Éº„ÇøÁîüÊàê
np.random.seed(42)
two_theta = np.linspace(10, 80, 700)

# „Éî„Éº„ÇØÊàêÂàÜ
peaks = (
    1000 * np.exp(-((two_theta - 28) ** 2) / 10) +
    1500 * np.exp(-((two_theta - 32) ** 2) / 8) +
    800 * np.exp(-((two_theta - 47) ** 2) / 12)
)

# „Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÔºàÈùûÊô∂Ë≥™„Éè„É≠„ÉºÔºâ
background = (
    100 +
    50 * np.sin(two_theta / 10) +
    30 * (two_theta / 80) ** 2
)

# „Éé„Ç§„Ç∫
noise = np.random.normal(0, 20, len(two_theta))

# ÂÖ®‰Ωì„ÅÆ‰ø°Âè∑
intensity = peaks + background + noise

# Â§öÈ†ÖÂºè„Éï„Ç£„ÉÉ„ÉÜ„Ç£„É≥„Ç∞„Å´„Çà„Çã„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÊé®ÂÆö
poly_degree = 5
coeffs = np.polyfit(two_theta, intensity, poly_degree)
background_fit = np.polyval(coeffs, two_theta)

# „Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÊ∏õÁÆó
intensity_corrected = intensity - background_fit

# ÂèØË¶ñÂåñ
fig, axes = plt.subplots(2, 2, figsize=(14, 10))

# ÂÖÉ„Éá„Éº„Çø
axes[0, 0].plot(two_theta, intensity, linewidth=1)
axes[0, 0].set_xlabel('2Œ∏ (degree)')
axes[0, 0].set_ylabel('Intensity')
axes[0, 0].set_title('Raw XRD Pattern')
axes[0, 0].grid(True, alpha=0.3)

# „Éï„Ç£„ÉÉ„ÉÜ„Ç£„É≥„Ç∞ÁµêÊûú
axes[0, 1].plot(two_theta, intensity, label='Raw data', alpha=0.5)
axes[0, 1].plot(two_theta, background_fit,
                label=f'Polynomial fit (deg={poly_degree})',
                linewidth=2, color='red')
axes[0, 1].set_xlabel('2Œ∏ (degree)')
axes[0, 1].set_ylabel('Intensity')
axes[0, 1].set_title('Background Estimation')
axes[0, 1].legend()
axes[0, 1].grid(True, alpha=0.3)

# Ë£úÊ≠£Âæå
axes[1, 0].plot(two_theta, intensity_corrected, linewidth=1,
                color='green')
axes[1, 0].axhline(y=0, color='r', linestyle='--', alpha=0.5)
axes[1, 0].set_xlabel('2Œ∏ (degree)')
axes[1, 0].set_ylabel('Intensity')
axes[1, 0].set_title('After Background Subtraction')
axes[1, 0].grid(True, alpha=0.3)

# Áúü„ÅÆ„Éî„Éº„ÇØ„Å®„ÅÆÊØîËºÉ
axes[1, 1].plot(two_theta, peaks, label='True peaks',
                linewidth=2, alpha=0.7)
axes[1, 1].plot(two_theta, intensity_corrected,
                label='Corrected data', linewidth=1.5, alpha=0.7)
axes[1, 1].set_xlabel('2Œ∏ (degree)')
axes[1, 1].set_ylabel('Intensity')
axes[1, 1].set_title('Comparison with True Peaks')
axes[1, 1].legend()
axes[1, 1].grid(True, alpha=0.3)

plt.tight_layout()
plt.show()

print(f&quot;Â§öÈ†ÖÂºèÊ¨°Êï∞: {poly_degree}&quot;)
print(f&quot;„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÂπ≥ÂùáÂÄ§: {background_fit.mean():.1f}&quot;)
print(f&quot;Ë£úÊ≠£Âæå„ÅÆÂπ≥ÂùáÂÄ§: {intensity_corrected.mean():.1f}&quot;)
</code></pre>
<p><strong>Âá∫Âäõ</strong>:</p>
<pre><code>Â§öÈ†ÖÂºèÊ¨°Êï∞: 5
„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÂπ≥ÂùáÂÄ§: 150.3
Ë£úÊ≠£Âæå„ÅÆÂπ≥ÂùáÂÄ§: 0.5
</code></pre>
<p><strong>‰Ωø„ÅÑÂàÜ„Åë„Ç¨„Ç§„Éâ</strong>:
- <strong>‰ΩéÊ¨°Ôºà2-3Ê¨°Ôºâ</strong>: Á∑©„ÇÑ„Åã„Å™„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÔºàIR„ÄÅXPSÔºâ
- <strong>‰∏≠Ê¨°Ôºà4-6Ê¨°Ôºâ</strong>: „ÇÑ„ÇÑË§áÈõë„Å™ÂΩ¢Áä∂ÔºàXRDÈùûÊô∂Ë≥™„Éè„É≠„ÉºÔºâ
- <strong>È´òÊ¨°Ôºà&gt;7Ê¨°Ôºâ</strong>: Ë§áÈõë„Å™ÂΩ¢Áä∂ÔºàÊ≥®ÊÑèÔºö„Ç™„Éº„Éê„Éº„Éï„Ç£„ÉÉ„ÉÜ„Ç£„É≥„Ç∞„ÅÆ„É™„Çπ„ÇØÔºâ</p>
<h3>SNIPÊ≥ïÔºàStatistics-sensitive Non-linear Iterative Peak-clippingÔºâ</h3>
<p>„Éî„Éº„ÇØÊÉÖÂ†±„Çí‰øùÊåÅ„Åó„Å™„Åå„Çâ„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„Éâ„ÇíÊé®ÂÆö„Åô„ÇãÈ´òÂ∫¶„Å™ÊâãÊ≥ï„Åß„Åô„ÄÇ</p>
<p><strong>„Ç≥„Éº„Éâ‰æã2: SNIPÊ≥ï„Å´„Çà„Çã„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÈô§Âéª</strong></p>
<pre><code class="language-python">def snip_background(spectrum, iterations=30):
    &quot;&quot;&quot;
    SNIPÊ≥ï„Å´„Çà„Çã„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÊé®ÂÆö

    Parameters:
    -----------
    spectrum : array-like
        ÂÖ•Âäõ„Çπ„Éö„ÇØ„Éà„É´
    iterations : int
        „Ç§„ÉÜ„É¨„Éº„Ç∑„Éß„É≥ÂõûÊï∞Ôºà„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„Éâ„ÅÆÂπÖ„Å´ÂØæÂøúÔºâ

    Returns:
    --------
    background : array-like
        Êé®ÂÆö„Åï„Çå„Åü„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„Éâ
    &quot;&quot;&quot;
    spectrum = np.array(spectrum, dtype=float)
    background = np.copy(spectrum)

    for i in range(1, iterations + 1):
        # Â∑¶Âè≥„ÅÆÂÄ§„Å®„ÅÆÊØîËºÉ
        for j in range(i, len(background) - i):
            v1 = (background[j - i] + background[j + i]) / 2
            v2 = background[j]
            background[j] = min(v1, v2)

    return background

# SNIPÊ≥ï„ÅÆÈÅ©Áî®
snip_bg = snip_background(intensity, iterations=50)
intensity_snip = intensity - snip_bg

# ÂèØË¶ñÂåñ
fig, axes = plt.subplots(1, 3, figsize=(16, 5))

# ÂÖÉ„Éá„Éº„Çø„Å®SNIP„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„Éâ
axes[0].plot(two_theta, intensity, label='Raw data', alpha=0.6)
axes[0].plot(two_theta, snip_bg, label='SNIP background',
             linewidth=2, color='orange')
axes[0].set_xlabel('2Œ∏ (degree)')
axes[0].set_ylabel('Intensity')
axes[0].set_title('SNIP Background Estimation')
axes[0].legend()
axes[0].grid(True, alpha=0.3)

# SNIPË£úÊ≠£Âæå
axes[1].plot(two_theta, intensity_snip, linewidth=1.5,
             color='purple')
axes[1].axhline(y=0, color='r', linestyle='--', alpha=0.5)
axes[1].set_xlabel('2Œ∏ (degree)')
axes[1].set_ylabel('Intensity')
axes[1].set_title('After SNIP Subtraction')
axes[1].grid(True, alpha=0.3)

# Â§öÈ†ÖÂºè vs SNIP ÊØîËºÉ
axes[2].plot(two_theta, intensity_corrected,
             label='Polynomial', alpha=0.7, linewidth=1.5)
axes[2].plot(two_theta, intensity_snip,
             label='SNIP', alpha=0.7, linewidth=1.5)
axes[2].set_xlabel('2Œ∏ (degree)')
axes[2].set_ylabel('Intensity')
axes[2].set_title('Polynomial vs SNIP')
axes[2].legend()
axes[2].grid(True, alpha=0.3)

plt.tight_layout()
plt.show()

print(f&quot;SNIP „Ç§„ÉÜ„É¨„Éº„Ç∑„Éß„É≥ÂõûÊï∞: 50&quot;)
print(f&quot;Â§öÈ†ÖÂºèÊ≥ï„ÅÆÊÆãÂ∑Æ: {np.std(intensity_corrected - peaks):.2f}&quot;)
print(f&quot;SNIPÊ≥ï„ÅÆÊÆãÂ∑Æ: {np.std(intensity_snip - peaks):.2f}&quot;)
</code></pre>
<p><strong>SNIPÊ≥ï„ÅÆÂà©ÁÇπ</strong>:
- „Éî„Éº„ÇØ„ÅÆÂΩ±Èüø„ÇíÂèó„Åë„Å´„Åè„ÅÑ
- Ë§áÈõë„Å™„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÂΩ¢Áä∂„Å´„ÇÇÂØæÂøú
- „Éë„É©„É°„Éº„ÇøË™øÊï¥„ÅåÁõ¥ÊÑüÁöÑÔºàiterations = „Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„Éâ„ÅÆÂπÖÔºâ</p>
<hr />
<h2>2.3 „Éî„Éº„ÇØÊ§úÂá∫„Ç¢„É´„Ç¥„É™„Ç∫„É†</h2>
<h3>scipy.signal.find_peaks „Å´„Çà„ÇãÂü∫Êú¨ÁöÑ„Å™„Éî„Éº„ÇØÊ§úÂá∫</h3>
<p><strong>„Ç≥„Éº„Éâ‰æã3: „Éî„Éº„ÇØÊ§úÂá∫„ÅÆÂü∫Êú¨</strong></p>
<pre><code class="language-python">from scipy.signal import find_peaks

# „Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÈô§ÂéªÊ∏à„Åø„Éá„Éº„Çø„Åß„Éî„Éº„ÇØÊ§úÂá∫
peaks_idx, properties = find_peaks(
    intensity_snip,
    height=100,        # ÊúÄ‰Ωé„Éî„Éº„ÇØÈ´ò„Åï
    prominence=80,     # ÂçìË∂äÂ∫¶ÔºàÂë®Âõ≤„Å®„ÅÆÈ´ò‰ΩéÂ∑ÆÔºâ
    distance=10,       # ÊúÄÂ∞è„Éî„Éº„ÇØÈñìÈöîÔºà„Éá„Éº„ÇøÁÇπÊï∞Ôºâ
    width=3           # ÊúÄÂ∞è„Éî„Éº„ÇØÂπÖ
)

peak_positions = two_theta[peaks_idx]
peak_heights = intensity_snip[peaks_idx]

# ÂèØË¶ñÂåñ
plt.figure(figsize=(14, 6))

plt.plot(two_theta, intensity_snip, linewidth=1.5,
         label='Background-corrected')
plt.plot(peak_positions, peak_heights, 'rx',
         markersize=12, markeredgewidth=2, label='Detected peaks')

# „Éî„Éº„ÇØ‰ΩçÁΩÆ„Å´„É©„Éô„É´
for pos, height in zip(peak_positions, peak_heights):
    plt.annotate(f'{pos:.1f}¬∞',
                xy=(pos, height),
                xytext=(pos, height + 100),
                ha='center',
                fontsize=9,
                bbox=dict(boxstyle='round,pad=0.3',
                         facecolor='yellow', alpha=0.5))

plt.xlabel('2Œ∏ (degree)')
plt.ylabel('Intensity')
plt.title('Peak Detection Results')
plt.legend()
plt.grid(True, alpha=0.3)
plt.tight_layout()
plt.show()

print(&quot;=== Ê§úÂá∫„Åï„Çå„Åü„Éî„Éº„ÇØ ===&quot;)
for i, (pos, height) in enumerate(zip(peak_positions,
                                       peak_heights), 1):
    print(f&quot;„Éî„Éº„ÇØ {i}: 2Œ∏ = {pos:.2f}¬∞, Âº∑Â∫¶ = {height:.1f}&quot;)
</code></pre>
<p><strong>Âá∫Âäõ</strong>:</p>
<pre><code>=== Ê§úÂá∫„Åï„Çå„Åü„Éî„Éº„ÇØ ===
„Éî„Éº„ÇØ 1: 2Œ∏ = 28.04¬∞, Âº∑Â∫¶ = 1021.3
„Éî„Éº„ÇØ 2: 2Œ∏ = 32.05¬∞, Âº∑Â∫¶ = 1512.7
„Éî„Éº„ÇØ 3: 2Œ∏ = 47.07¬∞, Âº∑Â∫¶ = 798.5
</code></pre>
<h3>„Éî„Éº„ÇØÊ§úÂá∫„Éë„É©„É°„Éº„Çø„ÅÆÊúÄÈÅ©Âåñ</h3>
<p><strong>„Ç≥„Éº„Éâ‰æã4: „Éë„É©„É°„Éº„ÇøÊÑüÂ∫¶Ëß£Êûê</strong></p>
<pre><code class="language-python"># Áï∞„Å™„Çã„Éë„É©„É°„Éº„Çø„Åß„Éî„Éº„ÇØÊ§úÂá∫
prominence_values = [30, 50, 80, 100]

fig, axes = plt.subplots(2, 2, figsize=(14, 10))
axes = axes.ravel()

for i, prom in enumerate(prominence_values):
    peaks_idx, _ = find_peaks(
        intensity_snip,
        prominence=prom,
        distance=5
    )

    axes[i].plot(two_theta, intensity_snip, linewidth=1.5)
    axes[i].plot(two_theta[peaks_idx], intensity_snip[peaks_idx],
                'rx', markersize=10, markeredgewidth=2)
    axes[i].set_xlabel('2Œ∏ (degree)')
    axes[i].set_ylabel('Intensity')
    axes[i].set_title(f'Prominence = {prom} ({len(peaks_idx)} peaks)')
    axes[i].grid(True, alpha=0.3)

plt.tight_layout()
plt.show()

print(&quot;=== „Éë„É©„É°„Éº„ÇøÊÑüÂ∫¶ ===&quot;)
for prom in prominence_values:
    peaks_idx, _ = find_peaks(intensity_snip, prominence=prom)
    print(f&quot;Prominence = {prom:3d}: {len(peaks_idx)} peaks detected&quot;)
</code></pre>
<h3>„Éî„Éº„ÇØ„Éï„Ç£„ÉÉ„ÉÜ„Ç£„É≥„Ç∞Ôºà„Ç¨„Ç¶„Ç∑„Ç¢„É≥„Éª„É≠„Éº„É¨„É≥„ÉÑÔºâ</h3>
<p><strong>„Ç≥„Éº„Éâ‰æã5: „Ç¨„Ç¶„Ç∑„Ç¢„É≥„Éï„Ç£„ÉÉ„ÉÜ„Ç£„É≥„Ç∞</strong></p>
<pre><code class="language-python">from scipy.optimize import curve_fit

def gaussian(x, amplitude, center, sigma):
    &quot;&quot;&quot;„Ç¨„Ç¶„Ç∑„Ç¢„É≥Èñ¢Êï∞&quot;&quot;&quot;
    return amplitude * np.exp(-((x - center) ** 2) / (2 * sigma ** 2))

def lorentzian(x, amplitude, center, gamma):
    &quot;&quot;&quot;„É≠„Éº„É¨„É≥„ÉÑÈñ¢Êï∞&quot;&quot;&quot;
    return amplitude * gamma**2 / ((x - center)**2 + gamma**2)

# ÊúÄÂàù„ÅÆ„Éî„Éº„ÇØÂë®Ëæ∫„ÇíÊäΩÂá∫
peak_region_mask = (two_theta &gt; 26) &amp; (two_theta &lt; 30)
x_data = two_theta[peak_region_mask]
y_data = intensity_snip[peak_region_mask]

# „Ç¨„Ç¶„Ç∑„Ç¢„É≥„Éï„Ç£„ÉÉ„ÉÜ„Ç£„É≥„Ç∞
initial_guess = [1000, 28, 1]  # [amplitude, center, sigma]
params_gauss, _ = curve_fit(gaussian, x_data, y_data,
                             p0=initial_guess)

# „É≠„Éº„É¨„É≥„ÉÑ„Éï„Ç£„ÉÉ„ÉÜ„Ç£„É≥„Ç∞
initial_guess_lor = [1000, 28, 0.5]  # [amplitude, center, gamma]
params_lor, _ = curve_fit(lorentzian, x_data, y_data,
                          p0=initial_guess_lor)

# „Éï„Ç£„ÉÉ„ÉàÁµêÊûú
x_fit = np.linspace(x_data.min(), x_data.max(), 200)
y_gauss = gaussian(x_fit, *params_gauss)
y_lor = lorentzian(x_fit, *params_lor)

# ÂèØË¶ñÂåñ
plt.figure(figsize=(12, 6))

plt.plot(x_data, y_data, 'o', label='Data', markersize=6)
plt.plot(x_fit, y_gauss, '-', linewidth=2,
         label=f'Gaussian (œÉ={params_gauss[2]:.2f})')
plt.plot(x_fit, y_lor, '--', linewidth=2,
         label=f'Lorentzian (Œ≥={params_lor[2]:.2f})')

plt.xlabel('2Œ∏ (degree)')
plt.ylabel('Intensity')
plt.title('Peak Fitting: Gaussian vs Lorentzian')
plt.legend()
plt.grid(True, alpha=0.3)
plt.tight_layout()
plt.show()

print(&quot;=== „Éï„Ç£„ÉÉ„ÉÜ„Ç£„É≥„Ç∞ÁµêÊûú ===&quot;)
print(f&quot;„Ç¨„Ç¶„Ç∑„Ç¢„É≥:&quot;)
print(f&quot;  ‰∏≠ÂøÉ‰ΩçÁΩÆ: {params_gauss[1]:.3f}¬∞&quot;)
print(f&quot;  ÊåØÂπÖ: {params_gauss[0]:.1f}&quot;)
print(f&quot;  œÉ: {params_gauss[2]:.3f}¬∞&quot;)
print(f&quot;\n„É≠„Éº„É¨„É≥„ÉÑ:&quot;)
print(f&quot;  ‰∏≠ÂøÉ‰ΩçÁΩÆ: {params_lor[1]:.3f}¬∞&quot;)
print(f&quot;  ÊåØÂπÖ: {params_lor[0]:.1f}&quot;)
print(f&quot;  Œ≥: {params_lor[2]:.3f}¬∞&quot;)
</code></pre>
<hr />
<h2>2.4 XPS „Çπ„Éö„ÇØ„Éà„É´Ëß£Êûê</h2>
<h3>„Ç∑„É£„Éº„É™„ÉºÂûã„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÈô§Âéª</h3>
<p>XPS„Çπ„Éö„ÇØ„Éà„É´„ÅØÈùûÂºæÊÄßÊï£‰π±„Å´„Çà„ÇãÁâπÂæ¥ÁöÑ„Å™„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„Éâ„ÇíÊåÅ„Å°„Åæ„Åô„ÄÇ</p>
<p><strong>„Ç≥„Éº„Éâ‰æã6: „Ç∑„É£„Éº„É™„Éº„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„Éâ</strong></p>
<pre><code class="language-python">def shirley_background(x, y, tol=1e-5, max_iter=50):
    &quot;&quot;&quot;
    „Ç∑„É£„Éº„É™„ÉºÂûã„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÊé®ÂÆö

    Parameters:
    -----------
    x : array-like
        „Ç®„Éç„É´„ÇÆ„ÉºËª∏ÔºàÈôçÈ†Ü„ÇíÊé®Â•®Ôºâ
    y : array-like
        Âº∑Â∫¶
    tol : float
        ÂèéÊùüÂà§ÂÆöÈñæÂÄ§
    max_iter : int
        ÊúÄÂ§ß„Ç§„ÉÜ„É¨„Éº„Ç∑„Éß„É≥ÂõûÊï∞

    Returns:
    --------
    background : array-like
        „Ç∑„É£„Éº„É™„Éº„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„Éâ
    &quot;&quot;&quot;
    # „Éá„Éº„Çø„ÅÆÊ∫ñÂÇô
    y = np.array(y, dtype=float)
    background = np.zeros_like(y)

    # ‰∏°Á´Ø„ÅÆÂÄ§
    y_min = min(y[0], y[-1])
    y_max = max(y[0], y[-1])

    # ÂàùÊúü„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÔºàÁ∑öÂΩ¢Ôºâ
    background = np.linspace(y[0], y[-1], len(y))

    # „Ç§„ÉÜ„É¨„Éº„Ç∑„Éß„É≥
    for iteration in range(max_iter):
        background_old = background.copy()

        # Á¥ØÁ©çÂíå„Çí‰ΩøÁî®
        cumsum = np.cumsum(y - background)
        total = cumsum[-1]

        if total == 0:
            break

        # Êñ∞„Åó„ÅÑ„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„Éâ
        background = y[-1] + (y[0] - y[-1]) * cumsum / total

        # ÂèéÊùüÂà§ÂÆö
        if np.max(np.abs(background - background_old)) &lt; tol:
            break

    return background

# XPS„Çµ„É≥„Éó„É´„Éá„Éº„ÇøÁîüÊàêÔºàC 1s „Çπ„Éö„ÇØ„Éà„É´Ôºâ
binding_energy = np.linspace(280, 295, 300)[::-1]  # ÈôçÈ†Ü
xps_peak = 5000 * np.exp(-((binding_energy - 285) ** 2) / 2)
shirley_bg = np.linspace(500, 200, len(binding_energy))
xps_spectrum = xps_peak + shirley_bg + \
               np.random.normal(0, 50, len(binding_energy))

# „Ç∑„É£„Éº„É™„Éº„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÊé®ÂÆö
shirley_bg_calc = shirley_background(binding_energy, xps_spectrum)

# „Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÊ∏õÁÆó
xps_corrected = xps_spectrum - shirley_bg_calc

# ÂèØË¶ñÂåñ
fig, axes = plt.subplots(1, 3, figsize=(16, 5))

# XPSÁîü„Éá„Éº„Çø
axes[0].plot(binding_energy, xps_spectrum, linewidth=1.5)
axes[0].set_xlabel('Binding Energy (eV)')
axes[0].set_ylabel('Intensity (CPS)')
axes[0].set_title('Raw XPS Spectrum (C 1s)')
axes[0].invert_xaxis()
axes[0].grid(True, alpha=0.3)

# „Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÊé®ÂÆö
axes[1].plot(binding_energy, xps_spectrum,
             label='Raw data', alpha=0.6)
axes[1].plot(binding_energy, shirley_bg_calc,
             label='Shirley background',
             linewidth=2, color='red')
axes[1].set_xlabel('Binding Energy (eV)')
axes[1].set_ylabel('Intensity (CPS)')
axes[1].set_title('Shirley Background Estimation')
axes[1].invert_xaxis()
axes[1].legend()
axes[1].grid(True, alpha=0.3)

# Ë£úÊ≠£Âæå
axes[2].plot(binding_energy, xps_corrected,
             linewidth=1.5, color='green')
axes[2].set_xlabel('Binding Energy (eV)')
axes[2].set_ylabel('Intensity (CPS)')
axes[2].set_title('After Shirley Subtraction')
axes[2].invert_xaxis()
axes[2].grid(True, alpha=0.3)

plt.tight_layout()
plt.show()

print(&quot;=== „Ç∑„É£„Éº„É™„Éº„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÈô§Âéª ===&quot;)
print(f&quot;„Ç®„Éç„É´„ÇÆ„ÉºÁØÑÂõ≤: {binding_energy.max():.1f} - &quot;
      f&quot;{binding_energy.min():.1f} eV&quot;)
print(f&quot;„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÈ´ò„ÅïÔºàÈ´òBEÂÅ¥Ôºâ: {shirley_bg_calc[0]:.1f}&quot;)
print(f&quot;„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÈ´ò„ÅïÔºà‰ΩéBEÂÅ¥Ôºâ: {shirley_bg_calc[-1]:.1f}&quot;)
</code></pre>
<hr />
<h2>2.5 IR„ÉªRaman„Çπ„Éö„ÇØ„Éà„É´Ëß£Êûê</h2>
<h3>„Éô„Éº„Çπ„É©„Ç§„É≥Ë£úÊ≠£ÔºàAsymmetric Least SquaresÊ≥ïÔºâ</h3>
<p>IR„ÉªRaman„Çπ„Éö„ÇØ„Éà„É´„ÅÆËõçÂÖâ„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÈô§Âéª„Å´ÊúâÂäπ„Åß„Åô„ÄÇ</p>
<p><strong>„Ç≥„Éº„Éâ‰æã7: ALSÊ≥ï„Å´„Çà„Çã„Éô„Éº„Çπ„É©„Ç§„É≥Ë£úÊ≠£</strong></p>
<pre><code class="language-python">from scipy import sparse
from scipy.sparse.linalg import spsolve

def als_baseline(y, lam=1e5, p=0.01, niter=10):
    &quot;&quot;&quot;
    Asymmetric Least SquaresÊ≥ï„Å´„Çà„Çã„Éô„Éº„Çπ„É©„Ç§„É≥Êé®ÂÆö

    Parameters:
    -----------
    y : array-like
        „Çπ„Éö„ÇØ„Éà„É´„Éá„Éº„Çø
    lam : float
        Âπ≥ÊªëÂåñ„Éë„É©„É°„Éº„ÇøÔºàÂ§ß„Åç„ÅÑ„Åª„Å©Êªë„Çâ„ÅãÔºâ
    p : float
        ÈùûÂØæÁß∞„Éë„É©„É°„Éº„ÇøÔºà0-1„ÄÅÂ∞è„Åï„ÅÑ„Åª„Å©„Éî„Éº„ÇØ„ÇíÈÅø„Åë„ÇãÔºâ
    niter : int
        „Ç§„ÉÜ„É¨„Éº„Ç∑„Éß„É≥ÂõûÊï∞

    Returns:
    --------
    baseline : array-like
        Êé®ÂÆö„Åï„Çå„Åü„Éô„Éº„Çπ„É©„Ç§„É≥
    &quot;&quot;&quot;
    L = len(y)
    D = sparse.diags([1, -2, 1], [0, -1, -2], shape=(L, L-2))
    w = np.ones(L)

    for i in range(niter):
        W = sparse.spdiags(w, 0, L, L)
        Z = W + lam * D.dot(D.transpose())
        z = spsolve(Z, w * y)
        w = p * (y &gt; z) + (1 - p) * (y &lt; z)

    return z

# Raman„Çµ„É≥„Éó„É´„Éá„Éº„ÇøÁîüÊàê
raman_shift = np.linspace(200, 2000, 900)
raman_peaks = (
    3000 * np.exp(-((raman_shift - 520) ** 2) / 100) +
    2000 * np.exp(-((raman_shift - 950) ** 2) / 200) +
    1500 * np.exp(-((raman_shift - 1350) ** 2) / 150)
)
fluorescence_bg = 500 + 0.5 * raman_shift + \
                  0.0005 * (raman_shift - 1000) ** 2
raman_spectrum = raman_peaks + fluorescence_bg + \
                 np.random.normal(0, 50, len(raman_shift))

# ALSÊ≥ïÈÅ©Áî®
als_bg = als_baseline(raman_spectrum, lam=1e6, p=0.01)
raman_corrected = raman_spectrum - als_bg

# ÂèØË¶ñÂåñ
fig, axes = plt.subplots(1, 3, figsize=(16, 5))

# Áîü„Éá„Éº„Çø
axes[0].plot(raman_shift, raman_spectrum, linewidth=1.5)
axes[0].set_xlabel('Raman Shift (cm‚Åª¬π)')
axes[0].set_ylabel('Intensity (a.u.)')
axes[0].set_title('Raw Raman Spectrum')
axes[0].grid(True, alpha=0.3)

# „Éô„Éº„Çπ„É©„Ç§„É≥Êé®ÂÆö
axes[1].plot(raman_shift, raman_spectrum,
             label='Raw data', alpha=0.6)
axes[1].plot(raman_shift, als_bg,
             label='ALS baseline', linewidth=2, color='red')
axes[1].set_xlabel('Raman Shift (cm‚Åª¬π)')
axes[1].set_ylabel('Intensity (a.u.)')
axes[1].set_title('ALS Baseline Estimation')
axes[1].legend()
axes[1].grid(True, alpha=0.3)

# Ë£úÊ≠£Âæå
axes[2].plot(raman_shift, raman_corrected,
             linewidth=1.5, color='purple')
axes[2].set_xlabel('Raman Shift (cm‚Åª¬π)')
axes[2].set_ylabel('Intensity (a.u.)')
axes[2].set_title('After ALS Subtraction')
axes[2].grid(True, alpha=0.3)

plt.tight_layout()
plt.show()

print(&quot;=== ALS „Éô„Éº„Çπ„É©„Ç§„É≥Ë£úÊ≠£ ===&quot;)
print(f&quot;Âπ≥ÊªëÂåñ„Éë„É©„É°„Éº„Çø (Œª): 1e6&quot;)
print(f&quot;ÈùûÂØæÁß∞„Éë„É©„É°„Éº„Çø (p): 0.01&quot;)
</code></pre>
<hr />
<h2>2.6 ÂÆöÈáèÁõ∏ÂàÜÊûêÔºàXRD-RIRÊ≥ïÔºâ</h2>
<h3>Reference Intensity RatioÔºàRIRÔºâÊ≥ï</h3>
<p>Ë§áÊï∞Áõ∏„ÇíÂê´„ÇÄXRD„Éë„Çø„Éº„É≥„Åã„Çâ„ÄÅÂêÑÁõ∏„ÅÆÈáçÈáèÂàÜÁéá„ÇíÁÆóÂá∫„Åó„Åæ„Åô„ÄÇ</p>
<p><strong>„Ç≥„Éº„Éâ‰æã8: RIRÊ≥ï„Å´„Çà„ÇãÂÆöÈáèÁõ∏ÂàÜÊûê</strong></p>
<pre><code class="language-python"># 2Áõ∏Á≥ª„ÅÆXRD„Éë„Çø„Éº„É≥ÁîüÊàê
two_theta = np.linspace(10, 80, 700)

# Áõ∏AÔºà‰æãÔºöŒ±-Fe2O3„ÄÅ‰∏ª„Éî„Éº„ÇØ: 33.2¬∞Ôºâ
phase_A = (
    2000 * np.exp(-((two_theta - 33.2) ** 2) / 15) +
    1200 * np.exp(-((two_theta - 35.6) ** 2) / 10) +
    800 * np.exp(-((two_theta - 54.1) ** 2) / 12)
)

# Áõ∏BÔºà‰æãÔºöFe3O4„ÄÅ‰∏ª„Éî„Éº„ÇØ: 35.5¬∞Ôºâ
phase_B = (
    1500 * np.exp(-((two_theta - 35.5) ** 2) / 18) +
    1000 * np.exp(-((two_theta - 30.1) ** 2) / 12) +
    600 * np.exp(-((two_theta - 62.7) ** 2) / 14)
)

# Ê∑∑Âêà„Éë„Çø„Éº„É≥ÔºàÁõ∏A:Áõ∏B = 70:30 wt%Ôºâ
ratio_A = 0.7
ratio_B = 0.3
mixed_pattern = ratio_A * phase_A + ratio_B * phase_B + \
                np.random.normal(0, 30, len(two_theta))

# RIRÂÄ§ÔºàÊñáÁåÆÂÄ§„ÄÅ„Ç≥„É©„É≥„ÉÄ„É†„Å´ÂØæ„Åô„ÇãÁõ∏ÂØæÂÄ§Ôºâ
RIR_A = 3.5  # Œ±-Fe2O3„ÅÆRIR
RIR_B = 2.8  # Fe3O4„ÅÆRIR

# ‰∏ª„Éî„Éº„ÇØÂº∑Â∫¶Ê∏¨ÂÆö
# Áõ∏A„ÅÆ‰∏ª„Éî„Éº„ÇØÔºà33.2¬∞‰ªòËøëÔºâ
peak_A_idx = np.argmax(mixed_pattern[(two_theta &gt; 32) &amp;
                                     (two_theta &lt; 34)])
I_A = mixed_pattern[(two_theta &gt; 32) &amp; (two_theta &lt; 34)][peak_A_idx]

# Áõ∏B„ÅÆ‰∏ª„Éî„Éº„ÇØÔºà35.5¬∞‰ªòËøëÔºâ
peak_B_idx = np.argmax(mixed_pattern[(two_theta &gt; 34.5) &amp;
                                     (two_theta &lt; 36)])
I_B = mixed_pattern[(two_theta &gt; 34.5) &amp; (two_theta &lt; 36)][peak_B_idx]

# RIRÊ≥ï„Å´„Çà„ÇãÈáçÈáèÂàÜÁéáË®àÁÆó
# W_A / W_B = (I_A / I_B) * (RIR_B / RIR_A)
ratio_calc = (I_A / I_B) * (RIR_B / RIR_A)

# Ê≠£Ë¶èÂåñ
W_A_calc = ratio_calc / (1 + ratio_calc)
W_B_calc = 1 - W_A_calc

# ÂèØË¶ñÂåñ
fig, axes = plt.subplots(2, 2, figsize=(14, 10))

# Ê∑∑Âêà„Éë„Çø„Éº„É≥
axes[0, 0].plot(two_theta, mixed_pattern, linewidth=1.5)
axes[0, 0].set_xlabel('2Œ∏ (degree)')
axes[0, 0].set_ylabel('Intensity')
axes[0, 0].set_title('Mixed XRD Pattern (Phase A + B)')
axes[0, 0].grid(True, alpha=0.3)

# ÂêÑÁõ∏„ÅÆÂØÑ‰∏é
axes[0, 1].plot(two_theta, ratio_A * phase_A,
                label='Phase A (70%)', linewidth=1.5)
axes[0, 1].plot(two_theta, ratio_B * phase_B,
                label='Phase B (30%)', linewidth=1.5)
axes[0, 1].set_xlabel('2Œ∏ (degree)')
axes[0, 1].set_ylabel('Intensity')
axes[0, 1].set_title('Individual Phase Contributions')
axes[0, 1].legend()
axes[0, 1].grid(True, alpha=0.3)

# ‰∏ª„Éî„Éº„ÇØ„ÅÆ‰ΩçÁΩÆ
axes[1, 0].plot(two_theta, mixed_pattern, linewidth=1.5)
axes[1, 0].axvline(x=33.2, color='blue',
                   linestyle='--', label='Phase A peak')
axes[1, 0].axvline(x=35.5, color='orange',
                   linestyle='--', label='Phase B peak')
axes[1, 0].set_xlabel('2Œ∏ (degree)')
axes[1, 0].set_ylabel('Intensity')
axes[1, 0].set_title('Main Peak Positions')
axes[1, 0].legend()
axes[1, 0].grid(True, alpha=0.3)

# ÂÆöÈáèÁµêÊûú
categories = ['Phase A', 'Phase B']
true_values = [ratio_A * 100, ratio_B * 100]
calc_values = [W_A_calc * 100, W_B_calc * 100]

x = np.arange(len(categories))
width = 0.35

axes[1, 1].bar(x - width/2, true_values, width,
               label='True', alpha=0.7)
axes[1, 1].bar(x + width/2, calc_values, width,
               label='Calculated (RIR)', alpha=0.7)
axes[1, 1].set_ylabel('Weight Fraction (%)')
axes[1, 1].set_title('Quantitative Phase Analysis')
axes[1, 1].set_xticks(x)
axes[1, 1].set_xticklabels(categories)
axes[1, 1].legend()
axes[1, 1].grid(True, alpha=0.3, axis='y')

plt.tight_layout()
plt.show()

print(&quot;=== RIRÊ≥ï„Å´„Çà„ÇãÂÆöÈáèÁõ∏ÂàÜÊûê ===&quot;)
print(f&quot;‰∏ª„Éî„Éº„ÇØÂº∑Â∫¶:&quot;)
print(f&quot;  Áõ∏A (33.2¬∞): {I_A:.1f}&quot;)
print(f&quot;  Áõ∏B (35.5¬∞): {I_B:.1f}&quot;)
print(f&quot;\nRIRÂÄ§:&quot;)
print(f&quot;  Áõ∏A: {RIR_A}&quot;)
print(f&quot;  Áõ∏B: {RIR_B}&quot;)
print(f&quot;\nÈáçÈáèÂàÜÁéá:&quot;)
print(f&quot;  ÁúüÂÄ§ - Áõ∏A: {ratio_A*100:.1f}%, Áõ∏B: {ratio_B*100:.1f}%&quot;)
print(f&quot;  Ë®àÁÆó - Áõ∏A: {W_A_calc*100:.1f}%, Áõ∏B: {W_B_calc*100:.1f}%&quot;)
print(f&quot;  Ë™§Â∑Æ: Áõ∏A {abs(ratio_A - W_A_calc)*100:.1f}%&quot;)
</code></pre>
<hr />
<h2>2.7 „Çπ„Éö„ÇØ„Éà„É´Ëß£Êûê„ÅÆËá™ÂãïÂåñ„Éë„Ç§„Éó„É©„Ç§„É≥</h2>
<h3>Áµ±ÂêàËß£Êûê„Éë„Ç§„Éó„É©„Ç§„É≥</h3>
<p><strong>„Ç≥„Éº„Éâ‰æã9: Ëá™Âãï„Çπ„Éö„ÇØ„Éà„É´Ëß£Êûê„Éë„Ç§„Éó„É©„Ç§„É≥</strong></p>
<pre><code class="language-python">from dataclasses import dataclass
from typing import Tuple, List

@dataclass
class PeakInfo:
    &quot;&quot;&quot;„Éî„Éº„ÇØÊÉÖÂ†±„ÇíÊ†ºÁ¥ç„Åô„Çã„Éá„Éº„Çø„ÇØ„É©„Çπ&quot;&quot;&quot;
    position: float
    intensity: float
    width: float
    area: float

class SpectrumAnalyzer:
    &quot;&quot;&quot;„Çπ„Éö„ÇØ„Éà„É´Ëá™ÂãïËß£Êûê„ÇØ„É©„Çπ&quot;&quot;&quot;

    def __init__(self, spectrum_type='XRD'):
        &quot;&quot;&quot;
        Parameters:
        -----------
        spectrum_type : str
            'XRD', 'XPS', 'IR', 'Raman'
        &quot;&quot;&quot;
        self.spectrum_type = spectrum_type
        self.x = None
        self.y = None
        self.y_corrected = None
        self.peaks = []

    def load_data(self, x: np.ndarray, y: np.ndarray):
        &quot;&quot;&quot;„Éá„Éº„ÇøË™≠„ÅøËæº„Åø&quot;&quot;&quot;
        self.x = np.array(x)
        self.y = np.array(y)

    def remove_background(self, method='snip', **kwargs):
        &quot;&quot;&quot;„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÈô§Âéª&quot;&quot;&quot;
        if method == 'snip':
            iterations = kwargs.get('iterations', 30)
            bg = snip_background(self.y, iterations)
        elif method == 'polynomial':
            degree = kwargs.get('degree', 5)
            coeffs = np.polyfit(self.x, self.y, degree)
            bg = np.polyval(coeffs, self.x)
        elif method == 'als':
            lam = kwargs.get('lam', 1e5)
            p = kwargs.get('p', 0.01)
            bg = als_baseline(self.y, lam, p)
        else:
            raise ValueError(f&quot;Unknown method: {method}&quot;)

        self.y_corrected = self.y - bg
        return self.y_corrected

    def detect_peaks(self, **kwargs):
        &quot;&quot;&quot;„Éî„Éº„ÇØÊ§úÂá∫&quot;&quot;&quot;
        if self.y_corrected is None:
            raise ValueError(&quot;Run remove_background first&quot;)

        prominence = kwargs.get('prominence', 50)
        distance = kwargs.get('distance', 10)

        peaks_idx, properties = find_peaks(
            self.y_corrected,
            prominence=prominence,
            distance=distance
        )

        self.peaks = []
        for idx in peaks_idx:
            peak = PeakInfo(
                position=self.x[idx],
                intensity=self.y_corrected[idx],
                width=properties['widths'][0] if 'widths' in properties else 0,
                area=0  # Âæå„ÅßË®àÁÆó
            )
            self.peaks.append(peak)

        return self.peaks

    def report(self):
        &quot;&quot;&quot;ÁµêÊûú„É¨„Éù„Éº„Éà&quot;&quot;&quot;
        print(f&quot;\n=== {self.spectrum_type} Spectrum Analysis Report ===&quot;)
        print(f&quot;„Éá„Éº„ÇøÁÇπÊï∞: {len(self.x)}&quot;)
        print(f&quot;Ê§úÂá∫„Åï„Çå„Åü„Éî„Éº„ÇØÊï∞: {len(self.peaks)}&quot;)
        print(f&quot;\n„Éî„Éº„ÇØÊÉÖÂ†±:&quot;)
        for i, peak in enumerate(self.peaks, 1):
            if self.spectrum_type == 'XRD':
                print(f&quot;  „Éî„Éº„ÇØ {i}: 2Œ∏ = {peak.position:.2f}¬∞, &quot;
                      f&quot;Âº∑Â∫¶ = {peak.intensity:.1f}&quot;)
            elif self.spectrum_type == 'XPS':
                print(f&quot;  „Éî„Éº„ÇØ {i}: BE = {peak.position:.2f} eV, &quot;
                      f&quot;Âº∑Â∫¶ = {peak.intensity:.1f}&quot;)
            elif self.spectrum_type in ['IR', 'Raman']:
                print(f&quot;  „Éî„Éº„ÇØ {i}: {peak.position:.1f} cm‚Åª¬π, &quot;
                      f&quot;Âº∑Â∫¶ = {peak.intensity:.1f}&quot;)

# ‰ΩøÁî®‰æã
analyzer = SpectrumAnalyzer(spectrum_type='XRD')
analyzer.load_data(two_theta, intensity)
analyzer.remove_background(method='snip', iterations=50)
peaks = analyzer.detect_peaks(prominence=80, distance=10)
analyzer.report()

# ÂèØË¶ñÂåñ
plt.figure(figsize=(14, 6))

plt.subplot(1, 2, 1)
plt.plot(analyzer.x, analyzer.y, label='Raw', alpha=0.5)
plt.plot(analyzer.x, analyzer.y_corrected,
         label='Background-corrected', linewidth=1.5)
plt.xlabel('2Œ∏ (degree)')
plt.ylabel('Intensity')
plt.title('Spectrum Processing')
plt.legend()
plt.grid(True, alpha=0.3)

plt.subplot(1, 2, 2)
plt.plot(analyzer.x, analyzer.y_corrected, linewidth=1.5)
peak_positions = [p.position for p in peaks]
peak_intensities = [p.intensity for p in peaks]
plt.plot(peak_positions, peak_intensities, 'rx',
         markersize=12, markeredgewidth=2)
plt.xlabel('2Œ∏ (degree)')
plt.ylabel('Intensity')
plt.title('Peak Detection')
plt.grid(True, alpha=0.3)

plt.tight_layout()
plt.show()
</code></pre>
<hr />
<h2>2.8 ÂÆüË∑µÁöÑ„Å™ËêΩ„Å®„ÅóÁ©¥„Å®ÂØæÁ≠ñ</h2>
<h3>„Çà„Åè„ÅÇ„ÇãÂ§±Êïó‰æã„Å®„Éô„Çπ„Éà„Éó„É©„ÇØ„ÉÜ„Ç£„Çπ</h3>
<h4>Â§±Êïó1: „Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÈô§Âéª„ÅÆÈÅéÂâ∞ÈÅ©Áî®</h4>
<p><strong>ÁóáÁä∂</strong>: „Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÈô§ÂéªÂæå„ÄÅ„Éî„Éº„ÇØÂº∑Â∫¶„ÅåË≤†„Å´„Å™„Çã„ÄÅ„Åæ„Åü„ÅØÂ∞è„Åï„Å™„Éî„Éº„ÇØ„ÅåÊ∂àÂ§±</p>
<p><strong>ÂéüÂõ†</strong>: Â§öÈ†ÖÂºèÊ¨°Êï∞„ÅåÈ´ò„Åô„Åé„Çã„ÄÅ„Åæ„Åü„ÅØSNIP„ÅÆiterationsÂÄ§„ÅåÂ§ß„Åç„Åô„Åé„Çã</p>
<p><strong>ÂØæÁ≠ñ</strong>:</p>
<pre><code class="language-python"># ‚ùå ÊÇ™„ÅÑ‰æãÔºöÈÅéÂ∫¶„Å™„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÈô§Âéª
poly_degree = 15  # È´ò„Åô„Åé„ÇãÊ¨°Êï∞
bg = np.polyval(np.polyfit(two_theta, intensity, poly_degree), two_theta)
corrected = intensity - bg
# ÁµêÊûú: „Éî„Éº„ÇØ„ÅåÊ≠™„Åø„ÄÅË≤†„ÅÆÂÄ§„ÅåÁô∫Áîü

# ‚úÖ ËâØ„ÅÑ‰æãÔºöÈÅ©Âàá„Å™„Éë„É©„É°„Éº„Çø„Å®Ê§úË®º
poly_degree = 5  # ÈÅ©Â∫¶„Å™Ê¨°Êï∞
bg = np.polyval(np.polyfit(two_theta, intensity, poly_degree), two_theta)
corrected = intensity - bg

# Ê§úË®º: Ë≤†„ÅÆÂÄ§„ÅÆÂâ≤Âêà„Çí„ÉÅ„Çß„ÉÉ„ÇØ
negative_ratio = (corrected &lt; 0).sum() / len(corrected)
if negative_ratio &gt; 0.05:  # 5%‰ª•‰∏ä„ÅåË≤†„Å™„ÇâË≠¶Âëä
    print(f&quot;Ë≠¶Âëä: „Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÈô§Âéª„ÅåÈÅéÂâ∞„Åß„ÅôÔºàË≤†„ÅÆÂÄ§„Åå{negative_ratio*100:.1f}%Ôºâ&quot;)
    print(&quot;Â§öÈ†ÖÂºèÊ¨°Êï∞„Çí‰∏ã„Åí„Çã„Åã„ÄÅSNIP„ÅÆiterations„ÇíÊ∏õ„Çâ„Åó„Å¶„Åè„Å†„Åï„ÅÑ&quot;)
</code></pre>
<h4>Â§±Êïó2: „Éî„Éº„ÇØÊ§úÂá∫„Éë„É©„É°„Éº„Çø„ÅÆ‰∏çÈÅ©Âàá„Å™Ë®≠ÂÆö</h4>
<p><strong>ÁóáÁä∂</strong>: „Éé„Ç§„Ç∫„ÇíË™§„Å£„Å¶„Éî„Éº„ÇØ„Å®„Åó„Å¶Ê§úÂá∫„ÄÅ„Åæ„Åü„ÅØÁúü„ÅÆ„Éî„Éº„ÇØ„ÇíË¶ãÈÄÉ„Åô</p>
<p><strong>ÂéüÂõ†</strong>: prominence„ÇÑheight„ÅÆÈñæÂÄ§„ÅåÈÅ©Âàá„Åß„Å™„ÅÑ</p>
<p><strong>ÂØæÁ≠ñ</strong>:</p>
<pre><code class="language-python"># ‚ùå ÊÇ™„ÅÑ‰æãÔºöÂõ∫ÂÆö„Éë„É©„É°„Éº„Çø
peaks, _ = find_peaks(spectrum, prominence=50, height=100)
# Áï∞„Å™„ÇãS/NÊØî„ÅÆ„Éá„Éº„Çø„Å´ÂØæÂøú„Åß„Åç„Å™„ÅÑ

# ‚úÖ ËâØ„ÅÑ‰æãÔºöÈÅ©ÂøúÁöÑ„Éë„É©„É°„Éº„ÇøË®≠ÂÆö
# „Éé„Ç§„Ç∫„É¨„Éô„É´„ÅÆÂÆöÈáèË©ï‰æ°
baseline_region = spectrum[(two_theta &gt; 70) &amp; (two_theta &lt; 80)]  # ‰ø°Âè∑„Å™„ÅóÈ†òÂüü
noise_std = np.std(baseline_region)
snr = spectrum.max() / noise_std

# S/NÊØî„Å´Âøú„Åò„Åü„Éë„É©„É°„Éº„ÇøË™øÊï¥
if snr &gt; 50:  # È´òÂìÅË≥™„Éá„Éº„Çø
    prominence = 3 * noise_std
    height = 2 * noise_std
elif snr &gt; 20:  # ‰∏≠ÂìÅË≥™„Éá„Éº„Çø
    prominence = 5 * noise_std
    height = 3 * noise_std
else:  # ‰ΩéÂìÅË≥™„Éá„Éº„Çø
    prominence = 10 * noise_std
    height = 5 * noise_std
    print(f&quot;Ë≠¶Âëä: S/NÊØî„Åå‰Ωé„ÅÑÔºà{snr:.1f}Ôºâ„ÄÇÊ∏¨ÂÆö„ÇíÂÜçÂÆüË°å„Åó„Å¶„Åè„Å†„Åï„ÅÑ&quot;)

peaks, properties = find_peaks(spectrum, prominence=prominence, height=height)
print(f&quot;„Éé„Ç§„Ç∫„É¨„Éô„É´: {noise_std:.2f}, S/NÊØî: {snr:.1f}&quot;)
print(f&quot;Ê§úÂá∫„Åï„Çå„Åü„Éî„Éº„ÇØÊï∞: {len(peaks)}&quot;)
</code></pre>
<h4>Â§±Êïó3: XPS„Çπ„Éö„ÇØ„Éà„É´„ÅÆË™§„Å£„ÅüÂÆöÈáè</h4>
<p><strong>ÁóáÁä∂</strong>: ÂÖÉÁ¥†ÁµÑÊàê„ÅåÁâ©ÁêÜÁöÑ„Å´„ÅÇ„Çä„Åà„Å™„ÅÑÂÄ§ÔºàÂêàË®à„Åå100%„ÇíÂ§ß„Åç„ÅèË∂Ö„Åà„Çã„ÄÅ„Åæ„Åü„ÅØË≤†Ôºâ</p>
<p><strong>ÂéüÂõ†</strong>: „Ç∑„É£„Éº„É™„Éº„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÈô§Âéª„ÅÆÂ§±Êïó„ÄÅ„Åæ„Åü„ÅØÊÑüÂ∫¶‰øÇÊï∞„ÅÆË™§Áî®</p>
<p><strong>ÂØæÁ≠ñ</strong>:</p>
<pre><code class="language-python"># ‚ùå ÊÇ™„ÅÑ‰æãÔºö„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÈô§Âéª„Å™„Åó„ÅßÂÆöÈáè
peak_area_C = np.trapz(xps_C_spectrum, binding_energy_C)
peak_area_O = np.trapz(xps_O_spectrum, binding_energy_O)
# ÁµêÊûú: „Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„Éâ„ÇÇÂê´„ÇÅ„ÅüÁ©çÂàÜÂÄ§

# ‚úÖ ËâØ„ÅÑ‰æãÔºö„Ç∑„É£„Éº„É™„ÉºË£úÊ≠£Âæå„ÅÆ„Éî„Éº„ÇØÈù¢Á©ç
bg_C = shirley_background(binding_energy_C, xps_C_spectrum)
corrected_C = xps_C_spectrum - bg_C
peak_area_C = np.trapz(corrected_C[corrected_C &gt; 0],
                       binding_energy_C[corrected_C &gt; 0])

bg_O = shirley_background(binding_energy_O, xps_O_spectrum)
corrected_O = xps_O_spectrum - bg_O
peak_area_O = np.trapz(corrected_O[corrected_O &gt; 0],
                       binding_energy_O[corrected_O &gt; 0])

# ÊÑüÂ∫¶‰øÇÊï∞„ÅßË£úÊ≠£ÔºàÊñáÁåÆÂÄ§„Çí‰ΩøÁî®Ôºâ
SENSITIVITY_FACTORS = {'C': 0.296, 'O': 0.711, 'Fe': 2.957}  # Scofield
atomic_ratio_C = peak_area_C / SENSITIVITY_FACTORS['C']
atomic_ratio_O = peak_area_O / SENSITIVITY_FACTORS['O']

# Ê≠£Ë¶èÂåñ
total = atomic_ratio_C + atomic_ratio_O
at_percent_C = (atomic_ratio_C / total) * 100
at_percent_O = (atomic_ratio_O / total) * 100

# Ê§úË®º
assert abs(at_percent_C + at_percent_O - 100) &lt; 1, &quot;ÁµÑÊàê„ÅÆÂêàË®à„Åå100%„Åß„ÅÇ„Çä„Åæ„Åõ„Çì&quot;
print(f&quot;C: {at_percent_C:.1f} at%, O: {at_percent_O:.1f} at%&quot;)
</code></pre>
<h4>Â§±Êïó4: RIRÊ≥ï„ÅÆË™§Áî®</h4>
<p><strong>ÁóáÁä∂</strong>: ÂÆöÈáèÁõ∏ÂàÜÊûê„ÅÆÁµêÊûú„ÅåÈáçÈáèÊØî„ÅÆÂêàË®à100%„ÇíÂ§ß„Åç„ÅèÈÄ∏ËÑ±</p>
<p><strong>ÂéüÂõ†</strong>: RIRÂÄ§„ÅÆ‰∏ç‰∏ÄËá¥ÔºàÁï∞„Å™„ÇãÂèÇÁÖßÁâ©Ë≥™Ôºâ„ÄÅ„Åæ„Åü„ÅØ„Éî„Éº„ÇØÈáç„Å™„Çä„ÅÆÁÑ°Ë¶ñ</p>
<p><strong>ÂØæÁ≠ñ</strong>:</p>
<pre><code class="language-python"># ‚ùå ÊÇ™„ÅÑ‰æãÔºö„Éî„Éº„ÇØÈáç„Å™„Çä„ÇíÁÑ°Ë¶ñ„Åó„ÅüÂÆöÈáè
I_A = intensity[peak_A_index]  # Âçò‰∏ÄÁÇπ„ÅÆÂº∑Â∫¶
I_B = intensity[peak_B_index]
# ÁµêÊûú: ËøëÊé•„Éî„Éº„ÇØ„ÅÆÂΩ±Èüø„ÅßË™§Â∑Æ„ÅåÂ§ß„Åç„ÅÑ

# ‚úÖ ËâØ„ÅÑ‰æãÔºö„Éî„Éº„ÇØÂàÜÈõ¢„Å®RIRÊ≥ï„ÅÆÊ≠£„Åó„ÅÑÈÅ©Áî®
# „Éî„Éº„ÇØÈ†òÂüü„ÅÆÊäΩÂá∫
peak_A_region = (two_theta &gt; 32) &amp; (two_theta &lt; 34)
peak_B_region = (two_theta &gt; 34.5) &amp; (two_theta &lt; 36.5)

# „Ç¨„Ç¶„Ç∑„Ç¢„É≥„Éï„Ç£„ÉÉ„ÉÜ„Ç£„É≥„Ç∞„Åß„Éî„Éº„ÇØÂàÜÈõ¢
from scipy.optimize import curve_fit

def gaussian(x, amp, cen, wid):
    return amp * np.exp(-(x - cen)**2 / (2 * wid**2))

# Áõ∏A„ÅÆ„Éî„Éº„ÇØ„Éï„Ç£„ÉÉ„Éà
popt_A, _ = curve_fit(gaussian, two_theta[peak_A_region],
                      intensity[peak_A_region],
                      p0=[1000, 33.2, 0.5])
I_A_corrected = popt_A[0]  # „Éî„Éº„ÇØÈ´ò„Åï

# Áõ∏B„ÅÆ„Éî„Éº„ÇØ„Éï„Ç£„ÉÉ„ÉàÔºàÂêåÊßòÔºâ
popt_B, _ = curve_fit(gaussian, two_theta[peak_B_region],
                      intensity[peak_B_region],
                      p0=[1500, 35.5, 0.5])
I_B_corrected = popt_B[0]

# RIRÂÄ§„ÅÆÁ¢∫Ë™çÔºàÂêå„ÅòÂèÇÁÖßÁâ©Ë≥™„Å´ÂØæ„Åô„ÇãÂÄ§„Çí‰ΩøÁî®Ôºâ
RIR_A = 3.5  # vs Corundum (Œ±-Al2O3)
RIR_B = 2.8  # vs Corundum (Œ±-Al2O3)

# ÈáçÈáèÂàÜÁéáË®àÁÆó
ratio = (I_A_corrected / I_B_corrected) * (RIR_B / RIR_A)
W_A = ratio / (1 + ratio)
W_B = 1 - W_A

# Ê§úË®º
assert abs(W_A + W_B - 1.0) &lt; 0.01, &quot;ÈáçÈáèÂàÜÁéá„ÅÆÂêàË®à„Åå1„Åß„ÅÇ„Çä„Åæ„Åõ„Çì&quot;
print(f&quot;Áõ∏A: {W_A*100:.1f} wt%, Áõ∏B: {W_B*100:.1f} wt%&quot;)
</code></pre>
<h4>Â§±Êïó5: „Çπ„Éö„ÇØ„Éà„É´Ëß£Êûê„ÅÆÊ∏¨ÂÆöË™§Â∑ÆÁÑ°Ë¶ñ</h4>
<p><strong>ÁóáÁä∂</strong>: Ëß£ÊûêÁµêÊûú„Å´Ë™§Â∑ÆÁØÑÂõ≤„ÅåÁ§∫„Åï„Çå„Åö„ÄÅÂÜçÁèæÊÄß„ÅåË©ï‰æ°„Åß„Åç„Å™„ÅÑ</p>
<p><strong>ÂéüÂõ†</strong>: Ê∏¨ÂÆö„ÅÆÁπ∞„ÇäËøî„Åó„ÇÑ„Éé„Ç§„Ç∫„ÅÆÂΩ±Èüø„ÇíÂÆöÈáè„Åó„Å¶„ÅÑ„Å™„ÅÑ</p>
<p><strong>ÂØæÁ≠ñ</strong>:</p>
<pre><code class="language-python"># ‚ùå ÊÇ™„ÅÑ‰æãÔºö1ÂõûÊ∏¨ÂÆö„ÅÆ„Åø„ÄÅË™§Â∑Æ„Å™„Åó
peak_position = two_theta[peak_index]
print(f&quot;„Éî„Éº„ÇØ‰ΩçÁΩÆ: {peak_position:.2f}¬∞&quot;)

# ‚úÖ ËâØ„ÅÑ‰æãÔºöË§áÊï∞Ê∏¨ÂÆö„Å®Ë™§Â∑ÆË©ï‰æ°
# Âêå‰∏Ä„Çµ„É≥„Éó„É´„ÅÆ3ÂõûÊ∏¨ÂÆö
measurements = []
for i in range(3):
    spectrum_i = measure_xrd()  # Ê∏¨ÂÆöÈñ¢Êï∞
    bg_i = snip_background(spectrum_i, iterations=50)
    corrected_i = spectrum_i - bg_i
    peaks_i, _ = find_peaks(corrected_i, prominence=80)

    # ‰∏ª„Éî„Éº„ÇØÔºàÊúÄÂ§ßÂº∑Â∫¶„Éî„Éº„ÇØÔºâ„ÅÆ‰ΩçÁΩÆ
    main_peak_i = two_theta[peaks_i[np.argmax(corrected_i[peaks_i])]]
    measurements.append(main_peak_i)

# Áµ±Ë®àÂá¶ÁêÜ
peak_mean = np.mean(measurements)
peak_std = np.std(measurements, ddof=1)  # ‰∏çÂÅèÊ®ôÊ∫ñÂÅèÂ∑Æ
peak_sem = peak_std / np.sqrt(len(measurements))  # Ê®ôÊ∫ñË™§Â∑Æ

print(f&quot;„Éî„Éº„ÇØ‰ΩçÁΩÆ: {peak_mean:.3f} ¬± {peak_sem:.3f}¬∞ÔºàÂπ≥Âùá¬±Ê®ôÊ∫ñË™§Â∑Æ„ÄÅn=3Ôºâ&quot;)

# Ê∏¨ÂÆöË™§Â∑Æ„ÅåÂ§ß„Åç„ÅÑÂ†¥Âêà„ÅÆË≠¶Âëä
if peak_std &gt; 0.1:  # 0.1¬∞‰ª•‰∏ä„ÅÆ„Å∞„Çâ„Å§„Åç
    print(f&quot;Ë≠¶Âëä: Ê∏¨ÂÆö„ÅÆ„Å∞„Çâ„Å§„Åç„ÅåÂ§ß„Åç„ÅÑÔºàœÉ={peak_std:.3f}¬∞Ôºâ&quot;)
    print(&quot;Ë©¶Êñô„ÅÆ„Ç¢„É©„Ç§„É°„É≥„Éà„ÇÑË£ÖÁΩÆ„ÅÆÂÆâÂÆöÊÄß„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ&quot;)
</code></pre>
<hr />
<h2>2.9 „Çπ„Éö„ÇØ„Éà„É´Ëß£Êûê„ÉÅ„Çß„ÉÉ„ÇØ„É™„Çπ„Éà</h2>
<h3>„Éá„Éº„ÇøË™≠„ÅøËæº„Åø„Å®Ê§úË®º</h3>
<ul>
<li>[ ] „Éá„Éº„ÇøÂΩ¢Âºè„ÅåÊ≠£„Åó„ÅÑ„ÅãÁ¢∫Ë™çÔºà2Œ∏, „Ç®„Éç„É´„ÇÆ„Éº, Ê≥¢Êï∞„ÅÆÂçò‰ΩçÔºâ</li>
<li>[ ] „Éá„Éº„ÇøÁØÑÂõ≤„ÅåÂ¶•ÂΩì„ÅãÁ¢∫Ë™çÔºàXRD: 10-80¬∞, XPS: 0-1200 eV, Raman: 200-2000 cm‚Åª¬πÔºâ</li>
<li>[ ] Ê¨†ÊêçÂÄ§„ÅÆÂâ≤Âêà„ÇíÁ¢∫Ë™çÔºà10%‰ª•‰∏ä„ÅØË¶ÅÊ≥®ÊÑèÔºâ</li>
<li>[ ] „Éá„Éº„ÇøÁÇπÊï∞„ÅåÂçÅÂàÜ„ÅãÁ¢∫Ë™çÔºàÊúÄ‰Ωé100ÁÇπ‰ª•‰∏äÊé®Â•®Ôºâ</li>
<li>[ ] „Çπ„Éö„ÇØ„Éà„É´„ÅÆÂèØË¶ñÂåñÔºàÂÖ®‰ΩìÂÉè„ÅÆÊääÊè°Ôºâ</li>
</ul>
<h3>Áí∞Â¢É„Å®ÂÜçÁèæÊÄß</h3>
<ul>
<li>[ ] Python, NumPy, SciPy, Matplotlib„ÅÆ„Éê„Éº„Ç∏„Éß„É≥„ÇíË®òÈå≤</li>
<li>[ ] Ëß£Êûê„Éë„É©„É°„Éº„Çø„ÇíJSON/YAML„Éï„Ç°„Ç§„É´„Å´‰øùÂ≠ò</li>
<li>[ ] „Éá„Éº„Çø„Éô„Éº„Çπ‰ΩøÁî®ÊôÇ„ÅØ„É©„Ç§„Çª„É≥„Çπ„Å®ÂºïÁî®ÊÉÖÂ†±„ÇíË®òÈå≤</li>
<li>[ ] ÂïÜÁî®„Éá„Éº„Çø„Éô„Éº„ÇπÔºàICDDÔºâ‰ΩøÁî®ÊôÇ„ÅØÂà©Áî®Ë¶èÁ¥Ñ„ÇíÈÅµÂÆà</li>
<li>[ ] ‰π±Êï∞„Ç∑„Éº„ÉâÂõ∫ÂÆöÔºàË©≤ÂΩì„Åô„ÇãÂ†¥ÂêàÔºâ</li>
</ul>
<h3>„Éé„Ç§„Ç∫„É¨„Éô„É´Ë©ï‰æ°</h3>
<ul>
<li>[ ] „Éô„Éº„Çπ„É©„Ç§„É≥È†òÂüü„Åß„Éé„Ç§„Ç∫„ÅÆÊ®ôÊ∫ñÂÅèÂ∑Æ„ÇíË®àÁÆó</li>
<li>[ ] S/NÊØî„ÇíË®àÁÆóÔºà„Éî„Éº„ÇØÈ´ò„Åï / „Éé„Ç§„Ç∫Ê®ôÊ∫ñÂÅèÂ∑ÆÔºâ</li>
<li>[ ] S/NÊØî„Åå3‰ª•‰∏ä„Åß„ÅÇ„Çã„Åì„Å®„ÇíÁ¢∫Ë™ç</li>
<li>[ ] ÂøÖË¶Å„Å´Âøú„Åò„Å¶„Çπ„É†„Éº„Ç∏„É≥„Ç∞ÈÅ©Áî®Ôºà„Éé„Ç§„Ç∫Èô§ÂéªÔºâ</li>
</ul>
<h3>„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÈô§Âéª</h3>
<ul>
<li>[ ] Ê∏¨ÂÆöÊäÄË°ì„Å´Âøú„Åò„ÅüÊâãÊ≥ï„ÇíÈÅ∏Êäû</li>
<li>XRD/Raman: SNIPÊ≥ï„Åæ„Åü„ÅØÂ§öÈ†ÖÂºè„Éï„Ç£„ÉÉ„ÉÜ„Ç£„É≥„Ç∞</li>
<li>XPS: „Ç∑„É£„Éº„É™„ÉºÂûã„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„Éâ</li>
<li>IR/RamanÔºàËõçÂÖâ„ÅÇ„ÇäÔºâ: ALSÊ≥ï</li>
<li>[ ] „Éë„É©„É°„Éº„Çø„ÇíË®òÈå≤ÔºàÂ§öÈ†ÖÂºèÊ¨°Êï∞„ÄÅSNIP„Ç§„ÉÜ„É¨„Éº„Ç∑„Éß„É≥Êï∞Ôºâ</li>
<li>[ ] „Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÊ∏õÁÆóÂæå„ÄÅË≤†„ÅÆÂÄ§„ÅÆÂâ≤Âêà„ÇíÁ¢∫Ë™çÔºà5%‰ª•‰∏ã„ÅåÊúõ„Åæ„Åó„ÅÑÔºâ</li>
<li>[ ] <strong>Ë£úÊ≠£ÂâçÂæå„ÅÆ„Çπ„Éö„ÇØ„Éà„É´„ÇíÂøÖ„ÅöÂèØË¶ñÂåñ</strong></li>
</ul>
<h3>„Éî„Éº„ÇØÊ§úÂá∫</h3>
<ul>
<li>[ ] „Éé„Ç§„Ç∫„É¨„Éô„É´„Å´Âü∫„Å•„ÅÑ„Å¶prominence/height„ÇíË®≠ÂÆö</li>
<li>[ ] Áâ©ÁêÜÁöÑ„Å´Â¶•ÂΩì„Å™„Éî„Éº„ÇØÂπÖÔºàwidthÔºâ„ÇíË®≠ÂÆö</li>
<li>[ ] ÊúÄÂ∞è„Éî„Éº„ÇØÈñìÈöîÔºàdistanceÔºâ„ÇíË®≠ÂÆö</li>
<li>[ ] <strong>Ê§úÂá∫„Åï„Çå„Åü„Éî„Éº„ÇØ„ÇíÂÖÉ„Çπ„Éö„ÇØ„Éà„É´„Å´Èáç„Å≠„Å¶ÂèØË¶ñÂåñ</strong></li>
<li>[ ] „Éî„Éº„ÇØÊï∞„ÅåÊúüÂæÖÂÄ§„Å®‰∏ÄËá¥„Åô„Çã„ÅãÁ¢∫Ë™ç</li>
</ul>
<h3>„Éî„Éº„ÇØ„Éï„Ç£„ÉÉ„ÉÜ„Ç£„É≥„Ç∞</h3>
<ul>
<li>[ ] „Éî„Éº„ÇØÂΩ¢Áä∂Èñ¢Êï∞„ÇíÈÅ∏ÊäûÔºà„Ç¨„Ç¶„Ç∑„Ç¢„É≥„ÄÅ„É≠„Éº„É¨„É≥„ÉÑ„ÄÅPseudo-VoigtÔºâ</li>
<li>[ ] ÂàùÊúüÂÄ§„ÇíÈÅ©Âàá„Å´Ë®≠ÂÆöÔºà„Éï„Ç£„ÉÉ„ÉÜ„Ç£„É≥„Ç∞„ÅÆÂèéÊùüÊÄßÔºâ</li>
<li>[ ] „Éï„Ç£„ÉÉ„ÉÜ„Ç£„É≥„Ç∞ÁµêÊûú„ÅÆR¬≤ÂÄ§„ÇíÁ¢∫Ë™çÔºà0.95‰ª•‰∏ä„ÅåÊúõ„Åæ„Åó„ÅÑÔºâ</li>
<li>[ ] „Éï„Ç£„ÉÉ„ÉàÊõ≤Á∑ö„Å®ÂÆüÊ∏¨ÂÄ§„ÇíÂèØË¶ñÂåñ</li>
<li>[ ] ÊÆãÂ∑Æ„Éó„É≠„ÉÉ„Éà„ÅßÁ≥ªÁµ±Ë™§Â∑Æ„ÇíÁ¢∫Ë™ç</li>
</ul>
<h3>ÂÆöÈáèÂàÜÊûêÔºàXRD-RIRÊ≥ïÔºâ</h3>
<ul>
<li>[ ] RIRÂÄ§„ÅÆÂèÇÁÖßÁâ©Ë≥™„ÅåÁµ±‰∏Ä„Åï„Çå„Å¶„ÅÑ„Çã„ÅãÁ¢∫Ë™ç</li>
<li>[ ] „Éî„Éº„ÇØÈáç„Å™„Çä„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅØ„Éî„Éº„ÇØÂàÜÈõ¢„ÇíÂÆüÊñΩ</li>
<li>[ ] ÈáçÈáèÂàÜÁéá„ÅÆÂêàË®à„Åå100%„Å´Ëøë„ÅÑ„ÅãÁ¢∫Ë™çÔºà¬±5%‰ª•ÂÜÖÔºâ</li>
<li>[ ] Ë§áÊï∞Ê∏¨ÂÆö„ÅÆÂπ≥Âùá„Å®Ê®ôÊ∫ñÂÅèÂ∑Æ„ÇíÂ†±Âëä</li>
</ul>
<h3>ÂÆöÈáèÂàÜÊûêÔºàXPSÔºâ</h3>
<ul>
<li>[ ] „Ç∑„É£„Éº„É™„Éº„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÈô§Âéª„ÇíÂÆüÊñΩ</li>
<li>[ ] „Éî„Éº„ÇØÈù¢Á©ç„ÇíÁ©çÂàÜÔºàË≤†„ÅÆÂÄ§„ÇíÈô§Â§ñÔºâ</li>
<li>[ ] ÊÑüÂ∫¶‰øÇÊï∞„ÅßË£úÊ≠£ÔºàScofield‰øÇÊï∞„Å™„Å©Ôºâ</li>
<li>[ ] ÂéüÂ≠ê%„ÅÆÂêàË®à„Åå100%„Åß„ÅÇ„Çã„Åì„Å®„ÇíÁ¢∫Ë™ç</li>
<li>[ ] „Çπ„Éî„É≥ËªåÈÅìÂàÜË£Ç„ÇíËÄÉÊÖÆÔºàË©≤ÂΩì„Åô„ÇãÂ†¥ÂêàÔºâ</li>
</ul>
<h3>ÁµêÊûú„ÅÆÂ¶•ÂΩìÊÄßÊ§úË®º</h3>
<ul>
<li>[ ] Êó¢Áü•„Çµ„É≥„Éó„É´„ÅßÊâãÊ≥ï„ÇíÊ§úË®º</li>
<li>[ ] ÊñáÁåÆÂÄ§„Å®ÊØîËºÉÔºà„Éî„Éº„ÇØ‰ΩçÁΩÆ„ÄÅÂº∑Â∫¶ÊØîÔºâ</li>
<li>[ ] Ë§áÊï∞Ê∏¨ÂÆö„ÅÆÂÜçÁèæÊÄß„ÇíÁ¢∫Ë™çÔºàÊ®ôÊ∫ñÂÅèÂ∑Æ„ÄÅÊ®ôÊ∫ñË™§Â∑ÆÔºâ</li>
<li>[ ] Áâ©ÁêÜÁöÑ„ÉªÂåñÂ≠¶ÁöÑÂ¶•ÂΩìÊÄß„ÇíË©ï‰æ°</li>
<li>[ ] Ê∏¨ÂÆöË™§Â∑Æ„Å®Ëß£ÊûêË™§Â∑Æ„ÇíÂàÜÈõ¢</li>
</ul>
<h3>Ëá™ÂãïÂåñ„Éª„Éê„ÉÉ„ÉÅÂá¶ÁêÜ</h3>
<ul>
<li>[ ] „Ç®„É©„Éº„Éè„É≥„Éâ„É™„É≥„Ç∞„ÇíÂÆüË£ÖÔºàtry-exceptÔºâ</li>
<li>[ ] Âá¶ÁêÜÂ§±ÊïóÊôÇ„ÅÆ„É≠„Ç∞Ë®òÈå≤</li>
<li>[ ] Âá¶ÁêÜÊôÇÈñì„ÇíÊ∏¨ÂÆö„ÉªË®òÈå≤</li>
<li>[ ] ÊàêÂäüÁéá„ÇíË®àÁÆó„ÉªÂ†±ÂëäÔºà‰æã: 95/100 files succeededÔºâ</li>
<li>[ ] ÁµêÊûú„ÇíJSON/CSVÂΩ¢Âºè„Åß‰øùÂ≠ò</li>
</ul>
<h3>ÊñáÊõ∏Âåñ</h3>
<ul>
<li>[ ] Ëß£ÊûêÊâãÈ†Ü„ÇíÂÜçÁèæÂèØËÉΩ„Å™ÂΩ¢„ÅßË®òÈå≤</li>
<li>[ ] „Éë„É©„É°„Éº„ÇøË®≠ÂÆö„ÅÆÊ†πÊã†„ÇíË®òËºâ</li>
<li>[ ] ‰ΩøÁî®„Åó„Åü„Éá„Éº„Çø„Éô„Éº„Çπ„ÉªÊñáÁåÆ„ÇíÂºïÁî®</li>
<li>[ ] ÊúÄÁµÇÁµêÊûú„ÅÆ‰∏çÁ¢∫„Åã„Åï„ÇíÊòéÁ§∫</li>
<li>[ ] „Ç≥„Éº„Éâ„Å´„Ç≥„É°„É≥„Éà„ÇíËøΩÂä†ÔºàÂ∞ÜÊù•„ÅÆËá™ÂàÜ„ÅÆ„Åü„ÇÅÔºâ</li>
</ul>
<hr />
<h2>2.10 Êú¨Á´†„ÅÆ„Åæ„Å®„ÇÅ</h2>
<h3>Â≠¶„Çì„Å†„Åì„Å®</h3>
<ol>
<li>
<p><strong>„Éá„Éº„Çø„É©„Ç§„Çª„É≥„Çπ„Å®ÂÜçÁèæÊÄß</strong>
   - „Çπ„Éö„ÇØ„Éà„É´„Éá„Éº„Çø„Éô„Éº„Çπ„ÅÆÊ¥ªÁî®„Å®„É©„Ç§„Çª„É≥„ÇπÈÅµÂÆà
   - Áí∞Â¢ÉÊÉÖÂ†±„Å®„Éë„É©„É°„Éº„Çø„ÅÆÊñáÊõ∏Âåñ
   - „Ç≥„Éº„ÉâÂÜçÁèæÊÄß„ÅÆ„Éô„Çπ„Éà„Éó„É©„ÇØ„ÉÜ„Ç£„Çπ</p>
</li>
<li>
<p><strong>„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÈô§ÂéªÊâãÊ≥ï</strong>
   - Â§öÈ†ÖÂºè„Éï„Ç£„ÉÉ„ÉÜ„Ç£„É≥„Ç∞ÔºàÊ±éÁî®Ôºâ
   - SNIPÊ≥ïÔºàXRD„ÄÅRamanÔºâ
   - „Ç∑„É£„Éº„É™„ÉºÂûãÔºàXPSÔºâ
   - ALSÊ≥ïÔºàIR„ÄÅRamanÔºâ</p>
</li>
<li>
<p><strong>„Éî„Éº„ÇØÊ§úÂá∫</strong>
   - <code>scipy.signal.find_peaks</code>„ÅÆÊ¥ªÁî®
   - „Éë„É©„É°„Éº„ÇøÊúÄÈÅ©ÂåñÔºàprominence„ÄÅdistance„ÄÅwidthÔºâ
   - „Ç¨„Ç¶„Ç∑„Ç¢„É≥„Éª„É≠„Éº„É¨„É≥„ÉÑ„Éï„Ç£„ÉÉ„ÉÜ„Ç£„É≥„Ç∞</p>
</li>
<li>
<p><strong>ÂÆöÈáèÂàÜÊûê</strong>
   - RIRÊ≥ï„Å´„Çà„ÇãÁõ∏ÂàÜÁéáË®àÁÆó
   - XPSÂÆöÈáèÔºàÊÑüÂ∫¶‰øÇÊï∞Ë£úÊ≠£Ôºâ
   - „Éî„Éº„ÇØÈù¢Á©ç„ÅÆÂÆöÈáèË©ï‰æ°</p>
</li>
<li>
<p><strong>ÂÆüË∑µÁöÑ„Å™ËêΩ„Å®„ÅóÁ©¥</strong>
   - „Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÈô§Âéª„ÅÆÈÅéÂâ∞ÈÅ©Áî®ÂõûÈÅø
   - ÈÅ©ÂøúÁöÑ„Éë„É©„É°„Éº„ÇøË®≠ÂÆö
   - Ê∏¨ÂÆöË™§Â∑Æ„ÅÆÂÆöÈáèË©ï‰æ°</p>
</li>
<li>
<p><strong>Ëá™ÂãïÂåñ</strong>
   - „ÇØ„É©„Çπ„Éô„Éº„Çπ„ÅÆËß£Êûê„Éë„Ç§„Éó„É©„Ç§„É≥
   - Ë§áÊï∞Ê∏¨ÂÆöÊäÄË°ì„Å∏„ÅÆÂØæÂøú</p>
</li>
</ol>
<h3>ÈáçË¶Å„Å™„Éù„Ç§„É≥„Éà</h3>
<ul>
<li>‚úÖ „Éá„Éº„Çø„Éô„Éº„Çπ‰ΩøÁî®ÊôÇ„ÅØ„É©„Ç§„Çª„É≥„Çπ„Å®ÂºïÁî®„ÇíÂøÖ„ÅöÁ¢∫Ë™ç</li>
<li>‚úÖ Ëß£Êûê„Éë„É©„É°„Éº„Çø„ÇíÊñáÊõ∏Âåñ„ÅóÂÜçÁèæÊÄß„ÇíÁ¢∫‰øù</li>
<li>‚úÖ „Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÈô§Âéª„ÅØÊ∏¨ÂÆöÊäÄË°ì„Åî„Å®„Å´ÈÅ©Âàá„Å™ÊâãÊ≥ï„ÇíÈÅ∏Êäû</li>
<li>‚úÖ „Éî„Éº„ÇØÊ§úÂá∫„Åß„ÅØ„ÄÅ„Éë„É©„É°„Éº„ÇøË™øÊï¥„Å®ÂèØË¶ñÂåñÁ¢∫Ë™ç„ÅåÂøÖÈ†à</li>
<li>‚úÖ ÂÆöÈáèÂàÜÊûê„Å´„ÅØÊ®ôÊ∫ñË©¶Êñô„ÇÑRIRÂÄ§„Å™„Å©„ÅÆÂèÇÁÖßÊÉÖÂ†±„ÅåÂøÖË¶Å</li>
<li>‚úÖ Ê∏¨ÂÆöË™§Â∑Æ„ÇíÂÆöÈáèË©ï‰æ°„Åó„ÄÅÁµêÊûú„Å´‰∏çÁ¢∫„Åã„Åï„ÇíÊòéÁ§∫</li>
<li>‚úÖ Ëá™ÂãïÂåñ„Å´„Çà„ÇäÂÜçÁèæÊÄß„Å®Âá¶ÁêÜÈÄüÂ∫¶„ÅåÂ§ßÂπÖ„Å´Âêë‰∏ä</li>
</ul>
<h3>Ê¨°„ÅÆÁ´†„Å∏</h3>
<p>Á¨¨3Á´†„Åß„ÅØ„ÄÅÁîªÂÉè„Éá„Éº„ÇøÔºàSEM„ÄÅTEMÔºâ„ÅÆËß£ÊûêÊâãÊ≥ï„ÇíÂ≠¶„Å≥„Åæ„ÅôÔºö
- ÁîªÂÉèÂâçÂá¶ÁêÜÔºà„Éé„Ç§„Ç∫Èô§Âéª„ÄÅ„Ç≥„É≥„Éà„É©„Çπ„ÉàË™øÊï¥Ôºâ
- Á≤íÂ≠êÊ§úÂá∫ÔºàWatershedÊ≥ïÔºâ
- Á≤íÂæÑÂàÜÂ∏ÉËß£Êûê
- CNN„Å´„Çà„ÇãÁîªÂÉèÂàÜÈ°û</p>
<p><strong><a href="./chapter-3.html">Á¨¨3Á´†ÔºöÁîªÂÉè„Éá„Éº„ÇøËß£Êûê ‚Üí</a></strong></p>
<hr />
<h2>ÊºîÁøíÂïèÈ°å</h2>
<h3>ÂïèÈ°å1ÔºàÈõ£ÊòìÂ∫¶ÔºöeasyÔºâ</h3>
<p>Ê¨°„ÅÆÊñáÁ´†„ÅÆÊ≠£Ë™§„ÇíÂà§ÂÆö„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
<ol>
<li>SNIPÊ≥ï„ÅØÂ§öÈ†ÖÂºè„Éï„Ç£„ÉÉ„ÉÜ„Ç£„É≥„Ç∞„Çà„Çä„ÇÇ„Éî„Éº„ÇØ„ÅÆÂΩ±Èüø„ÇíÂèó„Åë„Å´„Åè„ÅÑ</li>
<li>XPS„Çπ„Éö„ÇØ„Éà„É´„Å´„ÅØÁ∑öÂΩ¢„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„Éâ„ÅåÈÅ©„Åó„Å¶„ÅÑ„Çã</li>
<li>„Éî„Éº„ÇØÊ§úÂá∫„ÅÆprominence„Éë„É©„É°„Éº„Çø„ÅØ„ÄÅ„Éî„Éº„ÇØÈñì„ÅÆÊúÄÂ∞èË∑ùÈõ¢„ÇíÊåáÂÆö„Åô„Çã</li>
</ol>
<details>
<summary>„Éí„É≥„Éà</summary>

1. SNIPÊ≥ï„ÅÆÂãï‰ΩúÂéüÁêÜÔºà„Éî„Éº„ÇØ„ÇØ„É™„ÉÉ„Éî„É≥„Ç∞Ôºâ„ÇíËÄÉ„Åà„Çã
2. XPS„ÅÆ„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„Éâ„ÅØÈùûÂºæÊÄßÊï£‰π±„Å´Ëµ∑Âõ†„Åô„Çã
3. prominence„ÄÅdistance„ÄÅwidth„Éë„É©„É°„Éº„Çø„ÅÆÊÑèÂë≥„ÇíÁ¢∫Ë™ç

</details>

<details>
<summary>Ëß£Á≠î‰æã</summary>

**Ëß£Á≠î**:
1. **Ê≠£** - SNIPÊ≥ï„ÅØ„Éî„Éº„ÇØ„ÇíÈÅø„Åë„Å¶„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„Éâ„ÇíÊé®ÂÆö„Åô„Çã„Åü„ÇÅ„ÄÅÂ§öÈ†ÖÂºè„Çà„Çä„É≠„Éê„Çπ„Éà
2. **Ë™§** - XPS„ÅØ„Ç∑„É£„Éº„É™„ÉºÂûã„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„Éâ„ÅåÈÅ©ÂàáÔºàÈùûÂºæÊÄßÊï£‰π±„Å´„Çà„ÇãÈùûÂØæÁß∞ÂΩ¢Áä∂Ôºâ
3. **Ë™§** - prominence„ÅØÂçìË∂äÂ∫¶ÔºàÂë®Âõ≤„Å®„ÅÆÈ´ò‰ΩéÂ∑ÆÔºâ„ÄÅ„Éî„Éº„ÇØÈñìË∑ùÈõ¢„ÅØdistance„Éë„É©„É°„Éº„Çø

**Ëß£Ë™¨**:
„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÈô§ÂéªÊâãÊ≥ï„ÅÆÈÅ∏Êäû„ÅØÊ∏¨ÂÆöÂéüÁêÜ„Å´Âü∫„Å•„Åè„Åì„Å®„ÅåÈáçË¶Å„Åß„Åô„ÄÇXPS„ÅÆÈùûÂºæÊÄßÊï£‰π±„ÄÅRaman„ÅÆËõçÂÖâ„ÄÅXRD„ÅÆÈùûÊô∂Ë≥™„Éè„É≠„Éº„Å™„Å©„ÄÅ„Åù„Çå„Åû„ÇåÁï∞„Å™„Çã„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÂΩ¢Áä∂„ÇíÊåÅ„Å°„Åæ„Åô„ÄÇ

</details>

<hr />
<h3>ÂïèÈ°å2ÔºàÈõ£ÊòìÂ∫¶ÔºömediumÔºâ</h3>
<p>‰ª•‰∏ã„ÅÆXRD„Éá„Éº„Çø„Å´ÂØæ„Åó„Å¶„ÄÅSNIPÊ≥ï„Åß„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÈô§Âéª„ÇíË°å„ÅÑ„ÄÅ„Éî„Éº„ÇØ„ÇíÊ§úÂá∫„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
<pre><code class="language-python">import numpy as np

# „Çµ„É≥„Éó„É´XRD„Éá„Éº„Çø
np.random.seed(123)
two_theta = np.linspace(15, 75, 600)
intensity = (
    1200 * np.exp(-((two_theta - 26.6) ** 2) / 12) +
    1800 * np.exp(-((two_theta - 33.8) ** 2) / 10) +
    1000 * np.exp(-((two_theta - 54.8) ** 2) / 15) +
    150 + 50 * np.sin(two_theta / 8) +
    np.random.normal(0, 40, len(two_theta))
)
</code></pre>
<p><strong>Ë¶ÅÊ±Ç‰∫ãÈ†Ö</strong>:
1. SNIPÊ≥ï„Åß„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÈô§ÂéªÔºàiterations=40Ôºâ
2. „Éî„Éº„ÇØÊ§úÂá∫Ôºàprominence=100Ôºâ
3. Ê§úÂá∫„Åï„Çå„Åü„Éî„Éº„ÇØ‰ΩçÁΩÆ„Å®Âº∑Â∫¶„ÇíÂá∫Âäõ
4. Âá¶ÁêÜÂâçÂæå„ÅÆ„Çπ„Éö„ÇØ„Éà„É´„ÇíÂèØË¶ñÂåñ</p>
<details>
<summary>„Éí„É≥„Éà</summary>

**Âá¶ÁêÜ„Éï„É≠„Éº**:
1. SNIPÈñ¢Êï∞„ÇíÂÆöÁæ©„Åæ„Åü„ÅØÂÜçÂà©Áî®
2. „Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÊ∏õÁÆó
3. `find_peaks`„Åß„Éî„Éº„ÇØÊ§úÂá∫
4. ÁµêÊûú„ÇíÊï¥ÁêÜ„Åó„Å¶Âá∫Âäõ
5. `matplotlib`„Åß3ÊÆµÈöéÔºàÂÖÉ„Éá„Éº„Çø„ÄÅ„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„Éâ„ÄÅË£úÊ≠£ÂæåÔºâ„ÇíÂèØË¶ñÂåñ

</details>

<details>
<summary>Ëß£Á≠î‰æã</summary>


<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import find_peaks

# SNIPÈñ¢Êï∞Ôºà„Ç≥„Éº„Éâ‰æã2„Çà„ÇäÔºâ
def snip_background(spectrum, iterations=30):
    spectrum = np.array(spectrum, dtype=float)
    background = np.copy(spectrum)

    for i in range(1, iterations + 1):
        for j in range(i, len(background) - i):
            v1 = (background[j - i] + background[j + i]) / 2
            v2 = background[j]
            background[j] = min(v1, v2)

    return background

# „Çµ„É≥„Éó„É´„Éá„Éº„Çø
np.random.seed(123)
two_theta = np.linspace(15, 75, 600)
intensity = (
    1200 * np.exp(-((two_theta - 26.6) ** 2) / 12) +
    1800 * np.exp(-((two_theta - 33.8) ** 2) / 10) +
    1000 * np.exp(-((two_theta - 54.8) ** 2) / 15) +
    150 + 50 * np.sin(two_theta / 8) +
    np.random.normal(0, 40, len(two_theta))
)

# SNIPÊ≥ïÈÅ©Áî®
bg = snip_background(intensity, iterations=40)
intensity_corrected = intensity - bg

# „Éî„Éº„ÇØÊ§úÂá∫
peaks_idx, _ = find_peaks(intensity_corrected, prominence=100)
peak_positions = two_theta[peaks_idx]
peak_intensities = intensity_corrected[peaks_idx]

# ÁµêÊûúÂá∫Âäõ
print(&quot;=== „Éî„Éº„ÇØÊ§úÂá∫ÁµêÊûú ===&quot;)
for i, (pos, intens) in enumerate(zip(peak_positions,
                                       peak_intensities), 1):
    print(f&quot;„Éî„Éº„ÇØ {i}: 2Œ∏ = {pos:.2f}¬∞, Âº∑Â∫¶ = {intens:.1f}&quot;)

# ÂèØË¶ñÂåñ
fig, axes = plt.subplots(1, 3, figsize=(16, 5))

axes[0].plot(two_theta, intensity, linewidth=1.5)
axes[0].set_xlabel('2Œ∏ (degree)')
axes[0].set_ylabel('Intensity')
axes[0].set_title('Raw XRD Pattern')
axes[0].grid(True, alpha=0.3)

axes[1].plot(two_theta, intensity, label='Raw', alpha=0.6)
axes[1].plot(two_theta, bg, label='SNIP background',
             linewidth=2, color='red')
axes[1].set_xlabel('2Œ∏ (degree)')
axes[1].set_ylabel('Intensity')
axes[1].set_title('Background Estimation')
axes[1].legend()
axes[1].grid(True, alpha=0.3)

axes[2].plot(two_theta, intensity_corrected, linewidth=1.5)
axes[2].plot(peak_positions, peak_intensities, 'rx',
             markersize=12, markeredgewidth=2)
axes[2].set_xlabel('2Œ∏ (degree)')
axes[2].set_ylabel('Intensity')
axes[2].set_title('After Background Subtraction + Peak Detection')
axes[2].grid(True, alpha=0.3)

plt.tight_layout()
plt.show()
</code></pre>


**Âá∫Âäõ**:

<pre><code>=== „Éî„Éº„ÇØÊ§úÂá∫ÁµêÊûú ===
„Éî„Éº„ÇØ 1: 2Œ∏ = 26.59¬∞, Âº∑Â∫¶ = 1205.3
„Éî„Éº„ÇØ 2: 2Œ∏ = 33.81¬∞, Âº∑Â∫¶ = 1813.7
„Éî„Éº„ÇØ 3: 2Œ∏ = 54.76¬∞, Âº∑Â∫¶ = 1008.2
</code></pre>


**Ëß£Ë™¨**:
SNIPÊ≥ï„ÅÆiterations=40„ÅØ„ÄÅ„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„Éâ„ÅÆÁâπÂæ¥ÁöÑ„Å™ÂπÖÔºà„Éá„Éº„ÇøÁÇπÊï∞Ôºâ„Å´ÂØæÂøú„Åó„Åæ„Åô„ÄÇ„Åì„ÅÆ‰æã„Åß„ÅØÁ∑©„ÇÑ„Åã„Å™„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„Éâ„ÅÆ„Åü„ÇÅ„ÄÅ40„Ç§„ÉÜ„É¨„Éº„Ç∑„Éß„É≥„ÅßÂçÅÂàÜ„Åß„Åô„ÄÇprominence=100„Å´„Çà„Çä„ÄÅ„Éé„Ç§„Ç∫„Éî„Éº„ÇØ„ÇíÈô§Â§ñ„Åó„ÄÅ‰∏ªË¶Å„Å™3„Éî„Éº„ÇØ„ÅÆ„Åø„ÇíÊ§úÂá∫„Åß„Åç„Åæ„Åó„Åü„ÄÇ

</details>

<hr />
<h3>ÂïèÈ°å3ÔºàÈõ£ÊòìÂ∫¶ÔºöhardÔºâ</h3>
<p>Ë§áÊï∞„ÅÆÊ∏¨ÂÆöÊäÄË°ìÔºàXRD„ÄÅXPS„ÄÅRamanÔºâ„ÅÆ„Çπ„Éö„ÇØ„Éà„É´„Éá„Éº„Çø„ÇíËá™ÂãïÂá¶ÁêÜ„Åô„Çã„Éê„ÉÉ„ÉÅ„Ç∑„Çπ„ÉÜ„É†„ÇíÊßãÁØâ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
<p><strong>ËÉåÊôØ</strong>:
ÊùêÊñô„É©„Ç§„Éñ„É©„É™„Éº„Åã„Çâ100„Çµ„É≥„Éó„É´„ÅÆË§áÂêàÊ∏¨ÂÆö„Éá„Éº„ÇøÔºàXRD„ÄÅXPS„ÄÅRamanÔºâ„ÅåÂæó„Çâ„Çå„Åæ„Åó„Åü„ÄÇÂêÑÊ∏¨ÂÆö„Å´„Å§„ÅÑ„Å¶ÈÅ©Âàá„Å™ÂâçÂá¶ÁêÜ„ÇíËá™ÂãïÈÅ∏Êäû„Åó„ÄÅ„Éî„Éº„ÇØÊÉÖÂ†±„ÇíÊäΩÂá∫„Åô„ÇãÁµ±Âêà„Ç∑„Çπ„ÉÜ„É†„ÅåÂøÖË¶Å„Åß„Åô„ÄÇ</p>
<p><strong>Ë™≤È°å</strong>:
1. Ê∏¨ÂÆöÊäÄË°ì„Å´Âøú„Åò„ÅüÊúÄÈÅ©„Å™„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÈô§ÂéªÊâãÊ≥ï„ÅÆËá™ÂãïÈÅ∏Êäû
2. „Éî„Éº„ÇØÊ§úÂá∫„Éë„É©„É°„Éº„Çø„ÅÆËá™ÂãïË™øÊï¥
3. ÁµêÊûú„ÇíJSONÂΩ¢Âºè„Åß‰øùÂ≠ò
4. „Ç®„É©„Éº„Éè„É≥„Éâ„É™„É≥„Ç∞„Å®„É≠„Ç∞Âá∫Âäõ</p>
<p><strong>Âà∂Á¥ÑÊù°‰ª∂</strong>:
- ÂêÑÊ∏¨ÂÆöÊäÄË°ì„ÅßÁï∞„Å™„Çã„Éá„Éº„ÇøÂΩ¢ÂºèÔºàÂàóÂêç„ÄÅÂçò‰ΩçÔºâ
- Ê∏¨ÂÆöÂìÅË≥™„ÅÆ„Å∞„Çâ„Å§„ÅçÔºà„Éé„Ç§„Ç∫„É¨„Éô„É´Ôºâ
- Âá¶ÁêÜÊôÇÈñìÔºö10Áßí‰ª•ÂÜÖ/„Çµ„É≥„Éó„É´</p>
<details>
<summary>„Éí„É≥„Éà</summary>

**Ë®≠Ë®àÊñπÈáù**:
1. `SpectrumAnalyzer`„ÇØ„É©„Çπ„ÇíÊã°Âºµ
2. Ê∏¨ÂÆöÊäÄË°ì„ÅÆËá™ÂãïÂà§ÂÆöÔºà„É°„Çø„Éá„Éº„Çø„Åæ„Åü„ÅØ„Éï„Ç°„Ç§„É´Âêç„Åã„ÇâÔºâ
3. ÈÅ©ÂøúÁöÑ„Éë„É©„É°„Éº„ÇøË™øÊï¥Ôºà„Éé„Ç§„Ç∫„É¨„Éô„É´„Å´Âøú„Åò„Å¶prominenceË™øÊï¥Ôºâ
4. JSONÂá∫Âäõ„Å´„ÅØ„Éî„Éº„ÇØ‰ΩçÁΩÆ„ÄÅÂº∑Â∫¶„ÄÅÊé®ÂÆöÁõ∏ÊÉÖÂ†±„ÇíÂê´„ÇÅ„Çã

**„ÇØ„É©„ÇπË®≠Ë®à‰æã**:

<pre><code class="language-python">class AutoSpectrumProcessor:
    def __init__(self):
        self.analyzers = {}  # Ê∏¨ÂÆöÊäÄË°ì„Åî„Å®„ÅÆanalyzer

    def detect_spectrum_type(self, data):
        # „É°„Çø„Éá„Éº„Çø„Åã„ÇâÊ∏¨ÂÆöÊäÄË°ì„ÇíÂà§ÂÆö
        pass

    def adaptive_parameters(self, spectrum):
        # „Éé„Ç§„Ç∫„É¨„Éô„É´„Å´Âøú„Åò„Å¶„Éë„É©„É°„Éº„ÇøË™øÊï¥
        pass

    def batch_process(self, file_list):
        # Ë§áÊï∞„Éï„Ç°„Ç§„É´Âá¶ÁêÜ
        pass
</code></pre>


</details>

<details>
<summary>Ëß£Á≠î‰æã</summary>

**Ëß£Á≠î„ÅÆÊ¶ÇË¶Å**:
Ê∏¨ÂÆöÊäÄË°ì„ÅÆËá™ÂãïÂà§ÂÆö„ÄÅÈÅ©ÂøúÁöÑ„Éë„É©„É°„Éº„ÇøË™øÊï¥„ÄÅÁµêÊûú„ÅÆJSON‰øùÂ≠ò„ÇíÂê´„ÇÄÁµ±ÂêàÂá¶ÁêÜ„Ç∑„Çπ„ÉÜ„É†„ÇíÊßãÁØâ„Åó„Åæ„Åô„ÄÇ

**ÂÆüË£Ö„Ç≥„Éº„Éâ**:


<pre><code class="language-python">import json
import logging
from pathlib import Path
from typing import Dict, List
from dataclasses import dataclass, asdict

logging.basicConfig(level=logging.INFO)

@dataclass
class SpectrumResult:
    &quot;&quot;&quot;Ëß£ÊûêÁµêÊûú„ÇíÊ†ºÁ¥ç&quot;&quot;&quot;
    spectrum_type: str
    num_peaks: int
    peaks: List[Dict]
    processing_time: float
    background_method: str

class AutoSpectrumProcessor:
    &quot;&quot;&quot;Ëá™Âãï„Çπ„Éö„ÇØ„Éà„É´Ëß£Êûê„Ç∑„Çπ„ÉÜ„É†&quot;&quot;&quot;

    def __init__(self):
        self.bg_methods = {
            'XRD': 'snip',
            'XPS': 'shirley',
            'Raman': 'als',
            'IR': 'als'
        }

    def detect_spectrum_type(self, x: np.ndarray) -&gt; str:
        &quot;&quot;&quot;
        „Éá„Éº„ÇøÁØÑÂõ≤„Åã„ÇâÊ∏¨ÂÆöÊäÄË°ì„ÇíÊé®ÂÆö
        &quot;&quot;&quot;
        x_range = x.max() - x.min()
        x_min = x.min()

        if x_min &gt; 5 and x_range &lt; 100:  # 2Œ∏ÁØÑÂõ≤
            return 'XRD'
        elif x_min &gt; 200 and x_range &gt; 500:  # BEÁØÑÂõ≤
            return 'XPS'
        elif x_min &gt; 100 and x_range &gt; 1000:  # cm-1ÁØÑÂõ≤
            return 'Raman' if x.max() &lt; 4000 else 'IR'
        else:
            return 'Unknown'

    def adaptive_prominence(self, spectrum: np.ndarray) -&gt; float:
        &quot;&quot;&quot;
        „Éé„Ç§„Ç∫„É¨„Éô„É´„Å´Âøú„Åò„Å¶prominenceË™øÊï¥
        &quot;&quot;&quot;
        noise_std = np.std(np.diff(spectrum))
        snr = np.max(spectrum) / (noise_std + 1e-10)

        if snr &gt; 50:
            return 0.05 * np.max(spectrum)  # È´òS/N
        elif snr &gt; 20:
            return 0.08 * np.max(spectrum)  # ‰∏≠S/N
        else:
            return 0.12 * np.max(spectrum)  # ‰ΩéS/N

    def process_spectrum(self, x: np.ndarray, y: np.ndarray,
                        metadata: Dict = None) -&gt; SpectrumResult:
        &quot;&quot;&quot;
        Âçò‰∏Ä„Çπ„Éö„ÇØ„Éà„É´„ÅÆÂá¶ÁêÜ
        &quot;&quot;&quot;
        import time
        start_time = time.time()

        # Ê∏¨ÂÆöÊäÄË°ì„ÅÆÂà§ÂÆö
        if metadata and 'type' in metadata:
            spec_type = metadata['type']
        else:
            spec_type = self.detect_spectrum_type(x)

        logging.info(f&quot;Detected spectrum type: {spec_type}&quot;)

        # „Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„ÉâÈô§Âéª
        bg_method = self.bg_methods.get(spec_type, 'snip')

        if bg_method == 'snip':
            bg = snip_background(y, iterations=40)
        elif bg_method == 'als':
            bg = als_baseline(y, lam=1e6, p=0.01)
        else:
            # Á∞°ÊòìÁ∑öÂΩ¢ÔºàshirleyÊú™ÂÆüË£Ö„ÅÆÂ†¥ÂêàÔºâ
            bg = np.linspace(y[0], y[-1], len(y))

        y_corrected = y - bg

        # ÈÅ©ÂøúÁöÑ„Éî„Éº„ÇØÊ§úÂá∫
        prominence = self.adaptive_prominence(y_corrected)
        peaks_idx, _ = find_peaks(y_corrected, prominence=prominence)

        # „Éî„Éº„ÇØÊÉÖÂ†±„ÇíÊßãÈÄ†Âåñ
        peaks_info = []
        for idx in peaks_idx:
            peaks_info.append({
                'position': float(x[idx]),
                'intensity': float(y_corrected[idx]),
                'unit': '2Œ∏(deg)' if spec_type == 'XRD' else 'cm-1'
            })

        processing_time = time.time() - start_time

        result = SpectrumResult(
            spectrum_type=spec_type,
            num_peaks=len(peaks_idx),
            peaks=peaks_info,
            processing_time=processing_time,
            background_method=bg_method
        )

        return result

    def batch_process(self, data_list: List[Dict],
                     output_file: str = 'results.json'):
        &quot;&quot;&quot;
        „Éê„ÉÉ„ÉÅÂá¶ÁêÜ

        Parameters:
        -----------
        data_list : list of dict
            ÂêÑË¶ÅÁ¥†„ÅØ {'x': array, 'y': array, 'metadata': dict}
        &quot;&quot;&quot;
        results = []

        for i, data in enumerate(data_list, 1):
            try:
                logging.info(f&quot;Processing spectrum {i}/{len(data_list)}&quot;)
                result = self.process_spectrum(
                    data['x'],
                    data['y'],
                    data.get('metadata')
                )
                results.append(asdict(result))

            except Exception as e:
                logging.error(f&quot;Failed to process spectrum {i}: {e}&quot;)
                continue

        # JSON‰øùÂ≠ò
        with open(output_file, 'w') as f:
            json.dump(results, f, indent=2)

        logging.info(f&quot;Results saved to {output_file}&quot;)
        return results

# „Éá„É¢ÂÆüË°å
if __name__ == &quot;__main__&quot;:
    processor = AutoSpectrumProcessor()

    # „Çµ„É≥„Éó„É´„Éá„Éº„ÇøÁîüÊàêÔºà3Á®ÆÈ°û„ÅÆÊ∏¨ÂÆöÔºâ
    data_list = []

    # XRD„Éá„Éº„Çø
    two_theta = np.linspace(20, 60, 400)
    xrd_y = (
        1000 * np.exp(-((two_theta - 28) ** 2) / 10) +
        1500 * np.exp(-((two_theta - 35) ** 2) / 8) +
        100 + np.random.normal(0, 30, len(two_theta))
    )
    data_list.append({
        'x': two_theta,
        'y': xrd_y,
        'metadata': {'type': 'XRD', 'sample': 'Fe2O3'}
    })

    # Raman„Éá„Éº„Çø
    raman_shift = np.linspace(200, 2000, 900)
    raman_y = (
        2000 * np.exp(-((raman_shift - 520) ** 2) / 100) +
        1500 * np.exp(-((raman_shift - 950) ** 2) / 150) +
        500 + np.random.normal(0, 50, len(raman_shift))
    )
    data_list.append({
        'x': raman_shift,
        'y': raman_y,
        'metadata': {'type': 'Raman', 'sample': 'Si'}
    })

    # „Éê„ÉÉ„ÉÅÂá¶ÁêÜÂÆüË°å
    results = processor.batch_process(data_list,
                                      output_file='spectrum_results.json')

    print(&quot;\n=== Processing Summary ===&quot;)
    for i, result in enumerate(results, 1):
        print(f&quot;Spectrum {i}:&quot;)
        print(f&quot;  Type: {result['spectrum_type']}&quot;)
        print(f&quot;  Peaks detected: {result['num_peaks']}&quot;)
        print(f&quot;  Processing time: {result['processing_time']:.3f}s&quot;)
</code></pre>


**ÁµêÊûúÔºàJSONÂá∫Âäõ‰æãÔºâ**:

<pre><code class="language-json">[
  {
    &quot;spectrum_type&quot;: &quot;XRD&quot;,
    &quot;num_peaks&quot;: 2,
    &quot;peaks&quot;: [
      {&quot;position&quot;: 28.05, &quot;intensity&quot;: 1023.4, &quot;unit&quot;: &quot;2Œ∏(deg)&quot;},
      {&quot;position&quot;: 35.01, &quot;intensity&quot;: 1518.7, &quot;unit&quot;: &quot;2Œ∏(deg)&quot;}
    ],
    &quot;processing_time&quot;: 0.045,
    &quot;background_method&quot;: &quot;snip&quot;
  },
  {
    &quot;spectrum_type&quot;: &quot;Raman&quot;,
    &quot;num_peaks&quot;: 2,
    &quot;peaks&quot;: [
      {&quot;position&quot;: 520.3, &quot;intensity&quot;: 2015.6, &quot;unit&quot;: &quot;cm-1&quot;},
      {&quot;position&quot;: 949.8, &quot;intensity&quot;: 1507.2, &quot;unit&quot;: &quot;cm-1&quot;}
    ],
    &quot;processing_time&quot;: 0.052,
    &quot;background_method&quot;: &quot;als&quot;
  }
]
</code></pre>


**Ë©≥Á¥∞„Å™Ëß£Ë™¨**:
1. **Ëá™ÂãïÂà§ÂÆö**: „Éá„Éº„ÇøÁØÑÂõ≤„Åã„ÇâÊ∏¨ÂÆöÊäÄË°ì„ÇíÊé®ÂÆöÔºàXRD: 10-80¬∞„ÄÅRaman: 200-2000 cm‚Åª¬πÔºâ
2. **ÈÅ©ÂøúÁöÑ„Éë„É©„É°„Éº„Çø**: S/NÊØî„Åã„Çâprominence„ÇíËá™ÂãïË™øÊï¥
3. **ÊßãÈÄ†ÂåñÂá∫Âäõ**: JSONÂΩ¢Âºè„ÅßÂæåÁ∂öËß£Êûê„ÇÑ„Éá„Éº„Çø„Éô„Éº„ÇπÁôªÈå≤„Å´ÂØæÂøú
4. **„Ç®„É©„Éº„Éè„É≥„Éâ„É™„É≥„Ç∞**: ÂÄãÂà•„Çπ„Éö„ÇØ„Éà„É´„ÅÆÂ§±Êïó„Åå„Éê„ÉÉ„ÉÅÂÖ®‰Ωì„ÇíÂÅúÊ≠¢„Åï„Åõ„Å™„ÅÑ

**ËøΩÂä†„ÅÆÊ§úË®é‰∫ãÈ†Ö**:
- Ê∏¨ÂÆöÊäÄË°ì„ÅÆÂà§ÂÆöÁ≤æÂ∫¶Âêë‰∏äÔºàÊ©üÊ¢∞Â≠¶ÁøíÂàÜÈ°ûÂô®„ÅÆÂ∞éÂÖ•Ôºâ
- „ÇØ„É©„Ç¶„Éâ„Çπ„Éà„É¨„Éº„Ç∏ÔºàS3„ÄÅGCSÔºâ„Åã„Çâ„ÅÆ„Éá„Éº„ÇøË™≠„ÅøËæº„Åø
- Web„ÉÄ„ÉÉ„Ç∑„É•„Éú„Éº„Éâ„Åß„ÅÆ„É™„Ç¢„É´„Çø„Ç§„É†ÂèØË¶ñÂåñ
- „Éá„Éº„Çø„Éô„Éº„ÇπÔºàMongoDBÔºâ„Å∏„ÅÆÁµêÊûú‰øùÂ≠ò

</details>

<hr />
<h2>ÂèÇËÄÉÊñáÁåÆ</h2>
<ol>
<li>
<p>Pecharsky, V. K., &amp; Zavalij, P. Y. (2009). "Fundamentals of Powder Diffraction and Structural Characterization of Materials." Springer. ISBN: 978-0387095783</p>
</li>
<li>
<p>Briggs, D., &amp; Seah, M. P. (1990). "Practical Surface Analysis by Auger and X-ray Photoelectron Spectroscopy." Wiley. ISBN: 978-0471920816</p>
</li>
<li>
<p>Ryan, C. G. et al. (1988). "SNIP, a statistics-sensitive background treatment for the quantitative analysis of PIXE spectra in geoscience applications." <em>Nuclear Instruments and Methods in Physics Research B</em>, 34(3), 396-402. DOI: <a href="https://doi.org/10.1016/0168-583X(88)90063-8">10.1016/0168-583X(88)90063-8</a></p>
</li>
<li>
<p>Eilers, P. H. C., &amp; Boelens, H. F. M. (2005). "Baseline Correction with Asymmetric Least Squares Smoothing." <em>Leiden University Medical Centre Report</em>.</p>
</li>
<li>
<p>SciPy Documentation: Signal Processing. URL: <a href="https://docs.scipy.org/doc/scipy/reference/signal.html">https://docs.scipy.org/doc/scipy/reference/signal.html</a></p>
</li>
</ol>
<hr />
<h2>„Éä„Éì„Ç≤„Éº„Ç∑„Éß„É≥</h2>
<h3>Ââç„ÅÆÁ´†</h3>
<p><strong><a href="./chapter-1.html">Á¨¨1Á´†ÔºöÂÆüÈ®ì„Éá„Éº„ÇøËß£Êûê„ÅÆÂü∫Á§é ‚Üê</a></strong></p>
<h3>Ê¨°„ÅÆÁ´†</h3>
<p><strong><a href="./chapter-3.html">Á¨¨3Á´†ÔºöÁîªÂÉè„Éá„Éº„ÇøËß£Êûê ‚Üí</a></strong></p>
<h3>„Ç∑„É™„Éº„Ç∫ÁõÆÊ¨°</h3>
<p><strong><a href="./index.html">‚Üê „Ç∑„É™„Éº„Ç∫ÁõÆÊ¨°„Å´Êàª„Çã</a></strong></p>
<hr />
<h2>ËëóËÄÖÊÉÖÂ†±</h2>
<p><strong>‰ΩúÊàêËÄÖ</strong>: AI Terakoya Content Team
<strong>Áõ£‰øÆ</strong>: Dr. Yusuke HashimotoÔºàÊù±ÂåóÂ§ßÂ≠¶Ôºâ
<strong>‰ΩúÊàêÊó•</strong>: 2025-10-17
<strong>„Éê„Éº„Ç∏„Éß„É≥</strong>: 1.0</p>
<p><strong>Êõ¥Êñ∞Â±•Ê≠¥</strong>:
- 2025-10-17: v1.0 ÂàùÁâàÂÖ¨Èñã</p>
<p><strong>„Éï„Ç£„Éº„Éâ„Éê„ÉÉ„ÇØ</strong>:
- GitHub Issues: [„É™„Éù„Ç∏„Éà„É™URL]/issues
- Email: yusuke.hashimoto.b8@tohoku.ac.jp</p>
<p><strong>„É©„Ç§„Çª„É≥„Çπ</strong>: Creative Commons BY 4.0</p>
<hr />
<p><strong>Ê¨°„ÅÆÁ´†„ÅßÂ≠¶Áøí„ÇíÁ∂ö„Åë„Åæ„Åó„Çá„ÅÜÔºÅ</strong></p><div class="navigation">
    <a href="chapter-1.html" class="nav-button">‚Üê Ââç„ÅÆÁ´†</a>
    <a href="index.html" class="nav-button">„Ç∑„É™„Éº„Ç∫ÁõÆÊ¨°„Å´Êàª„Çã</a>
    <a href="chapter-3.html" class="nav-button">Ê¨°„ÅÆÁ´† ‚Üí</a>
</div>
    </main>

    <footer>
        <p><strong>‰ΩúÊàêËÄÖ</strong>: AI Terakoya Content Team</p>
        <p><strong>Áõ£‰øÆ</strong>: Dr. Yusuke HashimotoÔºàÊù±ÂåóÂ§ßÂ≠¶Ôºâ</p>
        <p><strong>„Éê„Éº„Ç∏„Éß„É≥</strong>: 1.0 | <strong>‰ΩúÊàêÊó•</strong>: 2025-10-17</p>
        <p><strong>„É©„Ç§„Çª„É≥„Çπ</strong>: Creative Commons BY 4.0</p>
        <p>¬© 2025 AI Terakoya. All rights reserved.</p>
    </footer>
</body>
</html>
