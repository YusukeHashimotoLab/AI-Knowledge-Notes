<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç¬¬2ç« ï¼šã‚¹ãƒšã‚¯ãƒˆãƒ«ãƒ‡ãƒ¼ã‚¿è§£æ - AI Terakoya</title>

    <style>
        :root {
            --color-primary: #2c3e50;
            --color-primary-dark: #1a252f;
            --color-accent: #7b2cbf;
            --color-accent-light: #9d4edd;
            --color-text: #2d3748;
            --color-text-light: #4a5568;
            --color-bg: #ffffff;
            --color-bg-alt: #f7fafc;
            --color-border: #e2e8f0;
            --color-code-bg: #f8f9fa;
            --color-link: #3182ce;
            --color-link-hover: #2c5aa0;

            --spacing-xs: 0.5rem;
            --spacing-sm: 1rem;
            --spacing-md: 1.5rem;
            --spacing-lg: 2rem;
            --spacing-xl: 3rem;

            --font-body: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            --font-mono: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;

            --border-radius: 8px;
            --box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-body);
            line-height: 1.7;
            color: var(--color-text);
            background-color: var(--color-bg);
            font-size: 16px;
        }

        header {
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            color: white;
            padding: var(--spacing-xl) var(--spacing-md);
            margin-bottom: var(--spacing-xl);
            box-shadow: var(--box-shadow);
        }

        .header-content {
            max-width: 900px;
            margin: 0 auto;
        }

        h1 {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: var(--spacing-sm);
            line-height: 1.2;
        }

        .subtitle {
            font-size: 1.1rem;
            opacity: 0.95;
            font-weight: 400;
            margin-bottom: var(--spacing-md);
        }

        .meta {
            display: flex;
            flex-wrap: wrap;
            gap: var(--spacing-md);
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .meta-item {
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 0 var(--spacing-md) var(--spacing-xl);
        }

        h2 {
            font-size: 1.75rem;
            color: var(--color-primary);
            margin-top: var(--spacing-xl);
            margin-bottom: var(--spacing-md);
            padding-bottom: var(--spacing-xs);
            border-bottom: 3px solid var(--color-accent);
        }

        h3 {
            font-size: 1.4rem;
            color: var(--color-primary);
            margin-top: var(--spacing-lg);
            margin-bottom: var(--spacing-sm);
        }

        h4 {
            font-size: 1.1rem;
            color: var(--color-primary-dark);
            margin-top: var(--spacing-md);
            margin-bottom: var(--spacing-sm);
        }

        p {
            margin-bottom: var(--spacing-md);
            color: var(--color-text);
        }

        a {
            color: var(--color-link);
            text-decoration: none;
            transition: color 0.2s;
        }

        a:hover {
            color: var(--color-link-hover);
            text-decoration: underline;
        }

        ul, ol {
            margin-left: var(--spacing-lg);
            margin-bottom: var(--spacing-md);
        }

        li {
            margin-bottom: var(--spacing-xs);
            color: var(--color-text);
        }

        pre {
            background-color: var(--color-code-bg);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            overflow-x: auto;
            margin-bottom: var(--spacing-md);
            font-family: var(--font-mono);
            font-size: 0.9rem;
            line-height: 1.5;
        }

        code {
            font-family: var(--font-mono);
            font-size: 0.9em;
            background-color: var(--color-code-bg);
            padding: 0.2em 0.4em;
            border-radius: 3px;
        }

        pre code {
            background-color: transparent;
            padding: 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: var(--spacing-md);
            font-size: 0.95rem;
        }

        th, td {
            border: 1px solid var(--color-border);
            padding: var(--spacing-sm);
            text-align: left;
        }

        th {
            background-color: var(--color-bg-alt);
            font-weight: 600;
            color: var(--color-primary);
        }

        blockquote {
            border-left: 4px solid var(--color-accent);
            padding-left: var(--spacing-md);
            margin: var(--spacing-md) 0;
            color: var(--color-text-light);
            font-style: italic;
            background-color: var(--color-bg-alt);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        .mermaid {
            text-align: center;
            margin: var(--spacing-lg) 0;
            background-color: var(--color-bg-alt);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        details {
            background-color: var(--color-bg-alt);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            margin-bottom: var(--spacing-md);
        }

        summary {
            cursor: pointer;
            font-weight: 600;
            color: var(--color-primary);
            user-select: none;
            padding: var(--spacing-xs);
            margin: calc(-1 * var(--spacing-md));
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        summary:hover {
            background-color: rgba(123, 44, 191, 0.1);
        }

        details[open] summary {
            margin-bottom: var(--spacing-md);
            border-bottom: 1px solid var(--color-border);
        }

        .learning-objectives {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            padding: var(--spacing-lg);
            border-radius: var(--border-radius);
            border-left: 4px solid var(--color-accent);
            margin-bottom: var(--spacing-xl);
        }

        .learning-objectives h2 {
            margin-top: 0;
            border-bottom: none;
        }

        .navigation {
            display: flex;
            justify-content: space-between;
            gap: var(--spacing-md);
            margin: var(--spacing-xl) 0;
            padding-top: var(--spacing-lg);
            border-top: 2px solid var(--color-border);
        }

        .nav-button {
            flex: 1;
            padding: var(--spacing-md);
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            color: white;
            border-radius: var(--border-radius);
            text-align: center;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: var(--box-shadow);
        }

        .nav-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            text-decoration: none;
        }

        footer {
            margin-top: var(--spacing-xl);
            padding: var(--spacing-lg) var(--spacing-md);
            background-color: var(--color-bg-alt);
            border-top: 1px solid var(--color-border);
            text-align: center;
            font-size: 0.9rem;
            color: var(--color-text-light);
        }
        .disclaimer {
            max-width: 900px;
            margin: 2rem auto;
            padding: 1.5rem;
            background: #f8f9fa;
            border-left: 4px solid #6c757d;
            border-radius: 4px;
        }

        .disclaimer h3 {
            color: #495057;
            margin-bottom: 1rem;
            font-size: 1.1rem;
        }

        .disclaimer ul {
            list-style: none;
            padding-left: 0;
        }

        .disclaimer li {
            padding: 0.5rem 0;
            padding-left: 1.5rem;
            position: relative;
            font-size: 0.9rem;
            color: #6c757d;
            line-height: 1.6;
        }

        .disclaimer li::before {
            content: "âš ï¸";
            position: absolute;
            left: 0;
        }


        @media (max-width: 768px) {
            h1 {
                font-size: 1.5rem;
            }

            h2 {
                font-size: 1.4rem;
            }

            h3 {
                font-size: 1.2rem;
            }

            .meta {
                font-size: 0.85rem;
            }

            .navigation {
                flex-direction: column;
            }

            table {
                font-size: 0.85rem;
            }

            th, td {
                padding: var(--spacing-xs);
            }
        }
    
        
    
        /* Breadcrumb styles */
        .breadcrumb {
            background: #f7fafc;
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #e2e8f0;
            font-size: 0.9rem;
        }

        .breadcrumb-content {
            max-width: 900px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .breadcrumb a {
            color: #667eea;
            text-decoration: none;
            transition: color 0.2s;
        }

        .breadcrumb a:hover {
            color: #764ba2;
            text-decoration: underline;
        }

        .breadcrumb-separator {
            color: #a0aec0;
            margin: 0 0.25rem;
        }

        .breadcrumb-current {
            color: #4a5568;
            font-weight: 500;
        }
    </style>

    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <script>
        mermaid.initialize({ startOnLoad: true, theme: 'default', securityLevel: 'strict' });
    </script>

    <!-- MathJax for LaTeX equation rendering -->
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\(', '\)']],
                displayMath: [['$$', '$$'], ['\[', '\]']],
                processEscapes: true,
                processEnvironments: true
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
                ignoreHtmlClass: 'mermaid'
            }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" id="MathJax-script" async></script>

    <style>
        /* Locale Switcher Styles */
        .locale-switcher {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 6px;
            font-size: 0.9rem;
            margin-bottom: 1rem;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .current-locale {
            font-weight: 600;
            color: #7b2cbf;
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .locale-separator {
            color: #adb5bd;
            font-weight: 300;
        }

        .locale-link {
            color: #f093fb;
            text-decoration: none;
            font-weight: 500;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 0.25rem;
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
        }

        .locale-link:hover {
            background: rgba(240, 147, 251, 0.1);
            color: #d07be8;
            transform: translateY(-1px);
        }

        .locale-meta {
            color: #868e96;
            font-size: 0.85rem;
            font-style: italic;
            margin-left: auto;
        }

        @media (max-width: 768px) {
            .locale-switcher {
                font-size: 0.85rem;
                padding: 0.4rem 0.8rem;
            }
            .locale-meta {
                display: none;
            }
        }
    </style>
</head>
<body>
            <div class="locale-switcher">
<span class="current-locale">ğŸŒ JP</span>
<span class="locale-separator">|</span>
<a href="../../../en/MI/experimental-data-analysis-introduction/chapter-2.html" class="locale-link">ğŸ‡¬ğŸ‡§ EN</a>
<span class="locale-separator">|</span>
<span class="locale-meta">Last sync: 2025-11-16</span>
</div>
<nav class="breadcrumb">
        <div class="breadcrumb-content">
            <a href="../../index.html">AIå¯ºå­å±‹ãƒˆãƒƒãƒ—</a><span class="breadcrumb-separator">â€º</span><a href="../../MI/index.html">ãƒãƒ†ãƒªã‚¢ãƒ«ã‚ºãƒ»ã‚¤ãƒ³ãƒ•ã‚©ãƒãƒ†ã‚£ã‚¯ã‚¹</a><span class="breadcrumb-separator">â€º</span><a href="../../MI/experimental-data-analysis-introduction/index.html">Experimental Data Analysis</a><span class="breadcrumb-separator">â€º</span><span class="breadcrumb-current">Chapter 2</span>
        </div>
    </nav>

        <header>
        <div class="header-content">
            <h1>ç¬¬2ç« ï¼šã‚¹ãƒšã‚¯ãƒˆãƒ«ãƒ‡ãƒ¼ã‚¿è§£æ</h1>
            <p class="subtitle">XRDãƒ»XPSãƒ»IRãƒ»Ramanã®è‡ªå‹•è§£æ - æ§‹é€ ãƒ»çµ„æˆæƒ…å ±ã®æŠ½å‡º</p>
            <div class="meta">
                <span class="meta-item">ğŸ“– èª­äº†æ™‚é–“: 25-30åˆ†</span>
                <span class="meta-item">ğŸ“Š é›£æ˜“åº¦: ä¸­ç´š</span>
                <span class="meta-item">ğŸ’» ã‚³ãƒ¼ãƒ‰ä¾‹: 11å€‹</span>
                <span class="meta-item">ğŸ“ æ¼”ç¿’å•é¡Œ: 3å•</span>
            </div>
        </div>
    </header>

    <main class="container">
<h1>ç¬¬2ç« ï¼šã‚¹ãƒšã‚¯ãƒˆãƒ«ãƒ‡ãƒ¼ã‚¿è§£æ</h1>
<p class="chapter-description" style="margin: 1.5rem 0; padding: 1rem; background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); border-left: 4px solid #7b2cbf; border-radius: 8px; font-size: 1.05rem; line-height: 1.8; color: #2d3748;">ãƒ”ãƒ¼ã‚¯åŒå®šã‹ã‚‰ãƒªãƒ•ã‚¡ã‚¤ãƒ³ãƒ¡ãƒ³ãƒˆã¾ã§ã€XRDè§£æã®è¦ç‚¹ã‚’Pythonã§ä½“é¨“ã—ã¾ã™ã€‚è‡ªå‹•åŒ–ã§ãƒ’ãƒ¥ãƒ¼ãƒãƒ³ã‚¨ãƒ©ãƒ¼ã‚’æ¸›ã‚‰ã™è¦–ç‚¹ã‚’å­¦ã³ã¾ã™ã€‚</p>
<p class="chapter-supplement" style="margin: 0.75rem 0 1.5rem 0; padding: 0.75rem 1rem; background: linear-gradient(135deg, #fff8e1 0%, #fff3cd 100%); border-left: 3px solid #f59e0b; border-radius: 6px; font-size: 0.95rem; line-height: 1.7; color: #4a5568;"><strong>ğŸ’¡ è£œè¶³:</strong> å‚è€ƒãƒ‘ã‚¿ãƒ¼ãƒ³ã®é¸å®šã¨åˆæœŸå€¤ãŒåæŸã®éµã€‚ãƒ­ã‚°ã‚’æ®‹ã—ã¦æ”¹å–„ã‚µã‚¤ã‚¯ãƒ«ã‚’æ—©ã‚ã¾ã™ã€‚</p>





<p><strong>XRDãƒ»XPSãƒ»IRãƒ»Ramanã®è‡ªå‹•è§£æ - æ§‹é€ ãƒ»çµ„æˆæƒ…å ±ã®æŠ½å‡º</strong></p>
<h2>å­¦ç¿’ç›®æ¨™</h2>
<p>ã“ã®ç« ã‚’èª­ã‚€ã“ã¨ã§ã€ä»¥ä¸‹ã‚’ç¿’å¾—ã§ãã¾ã™ï¼š</p>
<ul>
<li>âœ… XRDãƒ»XPSãƒ»IRãƒ»Ramanã‚¹ãƒšã‚¯ãƒˆãƒ«ã®ç‰¹å¾´ã‚’ç†è§£ã—ã€é©åˆ‡ãªå‰å‡¦ç†ã‚’é¸æŠã§ãã‚‹</li>
<li>âœ… ãƒ”ãƒ¼ã‚¯æ¤œå‡ºã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚’å®Ÿè£…ã—ã€ãƒ”ãƒ¼ã‚¯ä½ç½®ãƒ»å¼·åº¦ã‚’å®šé‡ã§ãã‚‹</li>
<li>âœ… ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰é™¤å»æ‰‹æ³•ï¼ˆå¤šé …å¼ãƒ•ã‚£ãƒƒãƒ†ã‚£ãƒ³ã‚°ã€SNIPï¼‰ã‚’ä½¿ã„åˆ†ã‘ã‚‰ã‚Œã‚‹</li>
<li>âœ… XRDãƒ‘ã‚¿ãƒ¼ãƒ³ã‹ã‚‰å®šé‡ç›¸åˆ†æï¼ˆRIRæ³•ï¼‰ã‚’å®Ÿè¡Œã§ãã‚‹</li>
<li>âœ… ã‚¹ãƒšã‚¯ãƒˆãƒ«è§£æãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚’è‡ªå‹•åŒ–ã§ãã‚‹</li>
</ul>
<p><strong>èª­äº†æ™‚é–“</strong>: 25-30åˆ†
<strong>ã‚³ãƒ¼ãƒ‰ä¾‹</strong>: 11å€‹
<strong>æ¼”ç¿’å•é¡Œ</strong>: 3å•</p>
<hr />
<h2>2.1 ã‚¹ãƒšã‚¯ãƒˆãƒ«ãƒ‡ãƒ¼ã‚¿ã®ç‰¹å¾´ã¨å‰å‡¦ç†æˆ¦ç•¥</h2>
<h3>å„æ¸¬å®šæŠ€è¡“ã®ç‰¹å¾´</h3>
<p>ææ–™ç§‘å­¦ã§é »ç¹ã«ä½¿ç”¨ã•ã‚Œã‚‹4ã¤ã®ã‚¹ãƒšã‚¯ãƒˆãƒ«æ¸¬å®šæŠ€è¡“ã®ç‰¹å¾´ã‚’ç†è§£ã™ã‚‹ã“ã¨ã¯ã€é©åˆ‡ãªè§£ææ‰‹æ³•ã‚’é¸æŠã™ã‚‹ä¸Šã§é‡è¦ã§ã™ã€‚</p>
<table>
<thead>
<tr>
<th>æ¸¬å®šæŠ€è¡“</th>
<th>å¾—ã‚‰ã‚Œã‚‹æƒ…å ±</th>
<th>ãƒ”ãƒ¼ã‚¯ã®ç‰¹å¾´</th>
<th>å…¸å‹çš„ãªãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>XRD</strong></td>
<td>çµæ™¶æ§‹é€ ã€ç›¸åŒå®š</td>
<td>ã‚·ãƒ£ãƒ¼ãƒ—ï¼ˆå›æŠ˜ãƒ”ãƒ¼ã‚¯ï¼‰</td>
<td>ä½å¼·åº¦ã€ç·©ã‚„ã‹ãªä¸Šæ˜‡ï¼ˆéæ™¶è³ªï¼‰</td>
</tr>
<tr>
<td><strong>XPS</strong></td>
<td>å…ƒç´ çµ„æˆã€åŒ–å­¦çŠ¶æ…‹</td>
<td>éå¯¾ç§°ï¼ˆã‚¹ãƒ”ãƒ³è»Œé“åˆ†è£‚ï¼‰</td>
<td>ã‚·ãƒ£ãƒ¼ãƒªãƒ¼å‹ï¼ˆéå¼¾æ€§æ•£ä¹±ï¼‰</td>
</tr>
<tr>
<td><strong>IR</strong></td>
<td>åˆ†å­æŒ¯å‹•ã€å®˜èƒ½åŸº</td>
<td>ã‚·ãƒ£ãƒ¼ãƒ—ã€œãƒ–ãƒ­ãƒ¼ãƒ‰</td>
<td>ã»ã¼ãƒ•ãƒ©ãƒƒãƒˆï¼ˆé€éæ³•ï¼‰</td>
</tr>
<tr>
<td><strong>Raman</strong></td>
<td>çµæ™¶æ€§ã€åˆ†å­æŒ¯å‹•</td>
<td>ã‚·ãƒ£ãƒ¼ãƒ—ï¼ˆçµæ™¶æ€§é«˜ï¼‰</td>
<td>è›å…‰ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ï¼ˆæœ‰æ©Ÿç‰©ï¼‰</td>
</tr>
</tbody>
</table>
<h3>ã‚¹ãƒšã‚¯ãƒˆãƒ«è§£æã®å…¸å‹çš„ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼</h3>
<div class="mermaid">
flowchart TD
    A[ã‚¹ãƒšã‚¯ãƒˆãƒ«æ¸¬å®š] --> B[ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿]
    B --> C[ãƒã‚¤ã‚ºé™¤å»]
    C --> D[ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰é™¤å»]
    D --> E[ãƒ”ãƒ¼ã‚¯æ¤œå‡º]
    E --> F[ãƒ”ãƒ¼ã‚¯ãƒ•ã‚£ãƒƒãƒ†ã‚£ãƒ³ã‚°]
    F --> G[å®šé‡è§£æ]
    G --> H[çµæœå¯è¦–åŒ–]

    style A fill:#e3f2fd
    style D fill:#fff3e0
    style E fill:#f3e5f5
    style G fill:#e8f5e9
    style H fill:#fce4ec
</div>

<p><strong>å„ã‚¹ãƒ†ãƒƒãƒ—ã®ç›®çš„</strong>:
1. <strong>ãƒã‚¤ã‚ºé™¤å»</strong>: S/Næ¯”å‘ä¸Šï¼ˆç¬¬1ç« ã§å­¦ç¿’æ¸ˆã¿ï¼‰
2. <strong>ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰é™¤å»</strong>: ãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ³è£œæ­£
3. <strong>ãƒ”ãƒ¼ã‚¯æ¤œå‡º</strong>: ãƒ”ãƒ¼ã‚¯ä½ç½®ã®è‡ªå‹•åŒå®š
4. <strong>ãƒ”ãƒ¼ã‚¯ãƒ•ã‚£ãƒƒãƒ†ã‚£ãƒ³ã‚°</strong>: ãƒ”ãƒ¼ã‚¯å½¢çŠ¶ã®ãƒ¢ãƒ‡ãƒ«åŒ–
5. <strong>å®šé‡è§£æ</strong>: çµ„æˆãƒ»ç›¸åˆ†ç‡ã®ç®—å‡º</p>
<hr />
<h2>2.2 ãƒ‡ãƒ¼ã‚¿ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã¨å†ç¾æ€§</h2>
<h3>ã‚¹ãƒšã‚¯ãƒˆãƒ«ãƒ‡ãƒ¼ã‚¿ãƒªãƒã‚¸ãƒˆãƒªã¨ãƒ©ã‚¤ã‚»ãƒ³ã‚¹</h3>
<p>ã‚¹ãƒšã‚¯ãƒˆãƒ«è§£æã§ã¯ã€æ¨™æº–ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚„å…¬é–‹ãƒ‡ãƒ¼ã‚¿ã®æ´»ç”¨ãŒé‡è¦ã§ã™ã€‚</p>
<h4>ä¸»è¦ãªã‚¹ãƒšã‚¯ãƒˆãƒ«ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹</h4>
<table>
<thead>
<tr>
<th>ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹</th>
<th>å†…å®¹</th>
<th>ãƒ©ã‚¤ã‚»ãƒ³ã‚¹</th>
<th>ã‚¢ã‚¯ã‚»ã‚¹</th>
<th>å¼•ç”¨è¦ä»¶</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>ICDD PDF-4+</strong></td>
<td>XRDæ¨™æº–ãƒ‘ã‚¿ãƒ¼ãƒ³</td>
<td>å•†ç”¨ãƒ©ã‚¤ã‚»ãƒ³ã‚¹</td>
<td>æœ‰æ–™ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³</td>
<td>å¿…é ˆ</td>
</tr>
<tr>
<td><strong>COD (Crystallography Open Database)</strong></td>
<td>çµæ™¶æ§‹é€ ãƒ»XRD</td>
<td>CC0 / Public Domain</td>
<td>ç„¡æ–™</td>
<td>æ¨å¥¨</td>
</tr>
<tr>
<td><strong>NIST XPS Database</strong></td>
<td>XPSæ¨™æº–ã‚¹ãƒšã‚¯ãƒˆãƒ«</td>
<td>Public Domain</td>
<td>ç„¡æ–™</td>
<td>å¿…é ˆ</td>
</tr>
<tr>
<td><strong>RRUFF Project</strong></td>
<td>Raman/IRé‰±ç‰©ã‚¹ãƒšã‚¯ãƒˆãƒ«</td>
<td>CC BY-NC-SA 3.0</td>
<td>ç„¡æ–™</td>
<td>å¿…é ˆ</td>
</tr>
<tr>
<td><strong>SDBS (Spectral Database)</strong></td>
<td>IR/Ramanæœ‰æ©ŸåŒ–åˆç‰©</td>
<td>ç„¡æ–™</td>
<td>ç„¡æ–™</td>
<td>æ¨å¥¨</td>
</tr>
</tbody>
</table>
<h4>ãƒ‡ãƒ¼ã‚¿åˆ©ç”¨æ™‚ã®æ³¨æ„äº‹é …</h4>
<p><strong>å•†ç”¨ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹åˆ©ç”¨æ™‚</strong>:</p>
<pre><code class="language-python"># ICDD PDF-4+ãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ç”¨ã™ã‚‹å ´åˆã®ã‚³ãƒ¡ãƒ³ãƒˆä¾‹
&quot;&quot;&quot;
XRD peak matching using ICDD PDF-4+ database.
Reference: ICDD PDF-4+ 2024 (Entry 01-089-0599)
License: International Centre for Diffraction Data
Note: Commercial license required for publication use
&quot;&quot;&quot;
</code></pre>
<p><strong>ã‚ªãƒ¼ãƒ—ãƒ³ãƒ‡ãƒ¼ã‚¿åˆ©ç”¨æ™‚</strong>:</p>
<pre><code class="language-python"># COD (Crystallography Open Database)ä½¿ç”¨ä¾‹
&quot;&quot;&quot;
Crystal structure data from COD.
Reference: COD Entry 1234567
Citation: GraÅ¾ulis, S. et al. (2012) Nucleic Acids Research, 40, D420-D427
License: CC0 1.0 Universal (Public Domain)
URL: http://www.crystallography.net/cod/1234567.html
&quot;&quot;&quot;
</code></pre>
<h3>ã‚³ãƒ¼ãƒ‰å†ç¾æ€§ã®ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹</h3>
<h4>ç’°å¢ƒæƒ…å ±ã®è¨˜éŒ²</h4>
<pre><code class="language-python">import sys
import numpy as np
import scipy
from scipy import signal
import matplotlib

print(&quot;=== ã‚¹ãƒšã‚¯ãƒˆãƒ«è§£æç’°å¢ƒ ===&quot;)
print(f&quot;Python: {sys.version}&quot;)
print(f&quot;NumPy: {np.__version__}&quot;)
print(f&quot;SciPy: {scipy.__version__}&quot;)
print(f&quot;Matplotlib: {matplotlib.__version__}&quot;)

# æ¨å¥¨ãƒãƒ¼ã‚¸ãƒ§ãƒ³ï¼ˆ2025å¹´10æœˆæ™‚ç‚¹ï¼‰:
# - Python: 3.10ä»¥ä¸Š
# - NumPy: 1.24ä»¥ä¸Š
# - SciPy: 1.10ä»¥ä¸Š
# - Matplotlib: 3.7ä»¥ä¸Š
</code></pre>
<h4>ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®æ–‡æ›¸åŒ–</h4>
<p><strong>æ‚ªã„ä¾‹</strong>ï¼ˆå†ç¾ä¸å¯èƒ½ï¼‰:</p>
<pre><code class="language-python">bg = snip_background(spectrum, 50)  # ãªãœ50?
</code></pre>
<p><strong>è‰¯ã„ä¾‹</strong>ï¼ˆå†ç¾å¯èƒ½ï¼‰:</p>
<pre><code class="language-python"># SNIPæ³•ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿è¨­å®š
SNIP_ITERATIONS = 50  # ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰å¹…ã®æ¨å®šå€¤ï¼ˆãƒ‡ãƒ¼ã‚¿ç‚¹ã®ç´„5%ï¼‰
SNIP_DESCRIPTION = &quot;&quot;&quot;
ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å›æ•°ã¯ã€ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã®ç‰¹å¾´çš„ãªå¹…ã«å¯¾å¿œã€‚
XRDãƒ‡ãƒ¼ã‚¿ï¼ˆ700ç‚¹ã€2Î¸=10-80Â°ï¼‰ã§ã¯ã€å¹…ç´„10Â°â‰ˆ100ç‚¹ã«å¯¾å¿œã™ã‚‹ãŸã‚ã€
iterations=50ï¼ˆå¹…ã®åŠåˆ†ç¨‹åº¦ï¼‰ãŒé©åˆ‡ã€‚
&quot;&quot;&quot;
bg = snip_background(spectrum, iterations=SNIP_ITERATIONS)
</code></pre>
<h4>è§£æãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®è¨˜éŒ²</h4>
<pre><code class="language-python"># ãƒ”ãƒ¼ã‚¯æ¤œå‡ºãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ï¼ˆå®Ÿé¨“ãƒãƒ¼ãƒˆã«è¨˜éŒ²ã™ã¹ãæƒ…å ±ï¼‰
PEAK_DETECTION_PARAMS = {
    'method': 'find_peaks',
    'prominence': 100,  # countsï¼ˆãƒã‚¤ã‚ºãƒ¬ãƒ™ãƒ«ã®ç´„5å€ï¼‰
    'distance': 10,     # pointsï¼ˆç´„0.1Â° in 2Î¸ï¼‰
    'height': 50,       # countsï¼ˆæœ€å°ç‰©ç†çš„æ„å‘³ã®ã‚ã‚‹å¼·åº¦ï¼‰
    'width': 3,         # pointsï¼ˆæœ€å°ãƒ”ãƒ¼ã‚¯å¹…ï¼‰
    'noise_level': 20   # countsï¼ˆãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ³é ˜åŸŸã®æ¨™æº–åå·®ï¼‰
}

# ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’JSONä¿å­˜ï¼ˆå†ç¾æ€§æ‹…ä¿ï¼‰
import json
with open('peak_detection_params.json', 'w') as f:
    json.dump(PEAK_DETECTION_PARAMS, f, indent=2)
</code></pre>
<hr />
<h2>2.3 ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰é™¤å»æ‰‹æ³•</h2>
<h3>å¤šé …å¼ãƒ•ã‚£ãƒƒãƒ†ã‚£ãƒ³ã‚°æ³•</h3>
<p>æœ€ã‚‚ã‚·ãƒ³ãƒ—ãƒ«ãªæ‰‹æ³•ã§ã€ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã‚’å¤šé …å¼ã§è¿‘ä¼¼ã—ã€å…ƒãƒ‡ãƒ¼ã‚¿ã‹ã‚‰æ¸›ç®—ã—ã¾ã™ã€‚</p>
<p><strong>ã‚³ãƒ¼ãƒ‰ä¾‹1: å¤šé …å¼ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰é™¤å»</strong></p>
<pre><code class="language-python"># XRDãƒ‘ã‚¿ãƒ¼ãƒ³ã®ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰é™¤å»
import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import savgol_filter

# ã‚µãƒ³ãƒ—ãƒ«XRDãƒ‡ãƒ¼ã‚¿ç”Ÿæˆ
np.random.seed(42)
two_theta = np.linspace(10, 80, 700)

# ãƒ”ãƒ¼ã‚¯æˆåˆ†
peaks = (
    1000 * np.exp(-((two_theta - 28) ** 2) / 10) +
    1500 * np.exp(-((two_theta - 32) ** 2) / 8) +
    800 * np.exp(-((two_theta - 47) ** 2) / 12)
)

# ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ï¼ˆéæ™¶è³ªãƒãƒ­ãƒ¼ï¼‰
background = (
    100 +
    50 * np.sin(two_theta / 10) +
    30 * (two_theta / 80) ** 2
)

# ãƒã‚¤ã‚º
noise = np.random.normal(0, 20, len(two_theta))

# å…¨ä½“ã®ä¿¡å·
intensity = peaks + background + noise

# å¤šé …å¼ãƒ•ã‚£ãƒƒãƒ†ã‚£ãƒ³ã‚°ã«ã‚ˆã‚‹ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰æ¨å®š
poly_degree = 5
coeffs = np.polyfit(two_theta, intensity, poly_degree)
background_fit = np.polyval(coeffs, two_theta)

# ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰æ¸›ç®—
intensity_corrected = intensity - background_fit

# å¯è¦–åŒ–
fig, axes = plt.subplots(2, 2, figsize=(14, 10))

# å…ƒãƒ‡ãƒ¼ã‚¿
axes[0, 0].plot(two_theta, intensity, linewidth=1)
axes[0, 0].set_xlabel('2Î¸ (degree)')
axes[0, 0].set_ylabel('Intensity')
axes[0, 0].set_title('Raw XRD Pattern')
axes[0, 0].grid(True, alpha=0.3)

# ãƒ•ã‚£ãƒƒãƒ†ã‚£ãƒ³ã‚°çµæœ
axes[0, 1].plot(two_theta, intensity, label='Raw data', alpha=0.5)
axes[0, 1].plot(two_theta, background_fit,
                label=f'Polynomial fit (deg={poly_degree})',
                linewidth=2, color='red')
axes[0, 1].set_xlabel('2Î¸ (degree)')
axes[0, 1].set_ylabel('Intensity')
axes[0, 1].set_title('Background Estimation')
axes[0, 1].legend()
axes[0, 1].grid(True, alpha=0.3)

# è£œæ­£å¾Œ
axes[1, 0].plot(two_theta, intensity_corrected, linewidth=1,
                color='green')
axes[1, 0].axhline(y=0, color='r', linestyle='--', alpha=0.5)
axes[1, 0].set_xlabel('2Î¸ (degree)')
axes[1, 0].set_ylabel('Intensity')
axes[1, 0].set_title('After Background Subtraction')
axes[1, 0].grid(True, alpha=0.3)

# çœŸã®ãƒ”ãƒ¼ã‚¯ã¨ã®æ¯”è¼ƒ
axes[1, 1].plot(two_theta, peaks, label='True peaks',
                linewidth=2, alpha=0.7)
axes[1, 1].plot(two_theta, intensity_corrected,
                label='Corrected data', linewidth=1.5, alpha=0.7)
axes[1, 1].set_xlabel('2Î¸ (degree)')
axes[1, 1].set_ylabel('Intensity')
axes[1, 1].set_title('Comparison with True Peaks')
axes[1, 1].legend()
axes[1, 1].grid(True, alpha=0.3)

plt.tight_layout()
plt.show()

print(f&quot;å¤šé …å¼æ¬¡æ•°: {poly_degree}&quot;)
print(f&quot;ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰å¹³å‡å€¤: {background_fit.mean():.1f}&quot;)
print(f&quot;è£œæ­£å¾Œã®å¹³å‡å€¤: {intensity_corrected.mean():.1f}&quot;)
</code></pre>
<p><strong>å‡ºåŠ›</strong>:</p>
<pre><code>å¤šé …å¼æ¬¡æ•°: 5
ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰å¹³å‡å€¤: 150.3
è£œæ­£å¾Œã®å¹³å‡å€¤: 0.5
</code></pre>
<p><strong>ä½¿ã„åˆ†ã‘ã‚¬ã‚¤ãƒ‰</strong>:
- <strong>ä½æ¬¡ï¼ˆ2-3æ¬¡ï¼‰</strong>: ç·©ã‚„ã‹ãªãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ï¼ˆIRã€XPSï¼‰
- <strong>ä¸­æ¬¡ï¼ˆ4-6æ¬¡ï¼‰</strong>: ã‚„ã‚„è¤‡é›‘ãªå½¢çŠ¶ï¼ˆXRDéæ™¶è³ªãƒãƒ­ãƒ¼ï¼‰
- <strong>é«˜æ¬¡ï¼ˆ&gt;7æ¬¡ï¼‰</strong>: è¤‡é›‘ãªå½¢çŠ¶ï¼ˆæ³¨æ„ï¼šã‚ªãƒ¼ãƒãƒ¼ãƒ•ã‚£ãƒƒãƒ†ã‚£ãƒ³ã‚°ã®ãƒªã‚¹ã‚¯ï¼‰</p>
<h3>SNIPæ³•ï¼ˆStatistics-sensitive Non-linear Iterative Peak-clippingï¼‰</h3>
<p>ãƒ”ãƒ¼ã‚¯æƒ…å ±ã‚’ä¿æŒã—ãªãŒã‚‰ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã‚’æ¨å®šã™ã‚‹é«˜åº¦ãªæ‰‹æ³•ã§ã™ã€‚</p>
<p><strong>ã‚³ãƒ¼ãƒ‰ä¾‹2: SNIPæ³•ã«ã‚ˆã‚‹ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰é™¤å»</strong></p>
<pre><code class="language-python">def snip_background(spectrum, iterations=30):
    &quot;&quot;&quot;
    SNIPæ³•ã«ã‚ˆã‚‹ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰æ¨å®š

    Parameters:
    -----------
    spectrum : array-like
        å…¥åŠ›ã‚¹ãƒšã‚¯ãƒˆãƒ«
    iterations : int
        ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å›æ•°ï¼ˆãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã®å¹…ã«å¯¾å¿œï¼‰

    Returns:
    --------
    background : array-like
        æ¨å®šã•ã‚ŒãŸãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰
    &quot;&quot;&quot;
    spectrum = np.array(spectrum, dtype=float)
    background = np.copy(spectrum)

    for i in range(1, iterations + 1):
        # å·¦å³ã®å€¤ã¨ã®æ¯”è¼ƒ
        for j in range(i, len(background) - i):
            v1 = (background[j - i] + background[j + i]) / 2
            v2 = background[j]
            background[j] = min(v1, v2)

    return background

# SNIPæ³•ã®é©ç”¨
snip_bg = snip_background(intensity, iterations=50)
intensity_snip = intensity - snip_bg

# å¯è¦–åŒ–
fig, axes = plt.subplots(1, 3, figsize=(16, 5))

# å…ƒãƒ‡ãƒ¼ã‚¿ã¨SNIPãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰
axes[0].plot(two_theta, intensity, label='Raw data', alpha=0.6)
axes[0].plot(two_theta, snip_bg, label='SNIP background',
             linewidth=2, color='orange')
axes[0].set_xlabel('2Î¸ (degree)')
axes[0].set_ylabel('Intensity')
axes[0].set_title('SNIP Background Estimation')
axes[0].legend()
axes[0].grid(True, alpha=0.3)

# SNIPè£œæ­£å¾Œ
axes[1].plot(two_theta, intensity_snip, linewidth=1.5,
             color='purple')
axes[1].axhline(y=0, color='r', linestyle='--', alpha=0.5)
axes[1].set_xlabel('2Î¸ (degree)')
axes[1].set_ylabel('Intensity')
axes[1].set_title('After SNIP Subtraction')
axes[1].grid(True, alpha=0.3)

# å¤šé …å¼ vs SNIP æ¯”è¼ƒ
axes[2].plot(two_theta, intensity_corrected,
             label='Polynomial', alpha=0.7, linewidth=1.5)
axes[2].plot(two_theta, intensity_snip,
             label='SNIP', alpha=0.7, linewidth=1.5)
axes[2].set_xlabel('2Î¸ (degree)')
axes[2].set_ylabel('Intensity')
axes[2].set_title('Polynomial vs SNIP')
axes[2].legend()
axes[2].grid(True, alpha=0.3)

plt.tight_layout()
plt.show()

print(f&quot;SNIP ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å›æ•°: 50&quot;)
print(f&quot;å¤šé …å¼æ³•ã®æ®‹å·®: {np.std(intensity_corrected - peaks):.2f}&quot;)
print(f&quot;SNIPæ³•ã®æ®‹å·®: {np.std(intensity_snip - peaks):.2f}&quot;)
</code></pre>
<p><strong>SNIPæ³•ã®åˆ©ç‚¹</strong>:
- ãƒ”ãƒ¼ã‚¯ã®å½±éŸ¿ã‚’å—ã‘ã«ãã„
- è¤‡é›‘ãªãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰å½¢çŠ¶ã«ã‚‚å¯¾å¿œ
- ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿èª¿æ•´ãŒç›´æ„Ÿçš„ï¼ˆiterations = ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã®å¹…ï¼‰</p>
<hr />
<h2>2.3 ãƒ”ãƒ¼ã‚¯æ¤œå‡ºã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ </h2>
<h3>scipy.signal.find_peaks ã«ã‚ˆã‚‹åŸºæœ¬çš„ãªãƒ”ãƒ¼ã‚¯æ¤œå‡º</h3>
<p><strong>ã‚³ãƒ¼ãƒ‰ä¾‹3: ãƒ”ãƒ¼ã‚¯æ¤œå‡ºã®åŸºæœ¬</strong></p>
<pre><code class="language-python">from scipy.signal import find_peaks

# ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰é™¤å»æ¸ˆã¿ãƒ‡ãƒ¼ã‚¿ã§ãƒ”ãƒ¼ã‚¯æ¤œå‡º
peaks_idx, properties = find_peaks(
    intensity_snip,
    height=100,        # æœ€ä½ãƒ”ãƒ¼ã‚¯é«˜ã•
    prominence=80,     # å“è¶Šåº¦ï¼ˆå‘¨å›²ã¨ã®é«˜ä½å·®ï¼‰
    distance=10,       # æœ€å°ãƒ”ãƒ¼ã‚¯é–“éš”ï¼ˆãƒ‡ãƒ¼ã‚¿ç‚¹æ•°ï¼‰
    width=3           # æœ€å°ãƒ”ãƒ¼ã‚¯å¹…
)

peak_positions = two_theta[peaks_idx]
peak_heights = intensity_snip[peaks_idx]

# å¯è¦–åŒ–
plt.figure(figsize=(14, 6))

plt.plot(two_theta, intensity_snip, linewidth=1.5,
         label='Background-corrected')
plt.plot(peak_positions, peak_heights, 'rx',
         markersize=12, markeredgewidth=2, label='Detected peaks')

# ãƒ”ãƒ¼ã‚¯ä½ç½®ã«ãƒ©ãƒ™ãƒ«
for pos, height in zip(peak_positions, peak_heights):
    plt.annotate(f'{pos:.1f}Â°',
                xy=(pos, height),
                xytext=(pos, height + 100),
                ha='center',
                fontsize=9,
                bbox=dict(boxstyle='round,pad=0.3',
                         facecolor='yellow', alpha=0.5))

plt.xlabel('2Î¸ (degree)')
plt.ylabel('Intensity')
plt.title('Peak Detection Results')
plt.legend()
plt.grid(True, alpha=0.3)
plt.tight_layout()
plt.show()

print(&quot;=== æ¤œå‡ºã•ã‚ŒãŸãƒ”ãƒ¼ã‚¯ ===&quot;)
for i, (pos, height) in enumerate(zip(peak_positions,
                                       peak_heights), 1):
    print(f&quot;ãƒ”ãƒ¼ã‚¯ {i}: 2Î¸ = {pos:.2f}Â°, å¼·åº¦ = {height:.1f}&quot;)
</code></pre>
<p><strong>å‡ºåŠ›</strong>:</p>
<pre><code>=== æ¤œå‡ºã•ã‚ŒãŸãƒ”ãƒ¼ã‚¯ ===
ãƒ”ãƒ¼ã‚¯ 1: 2Î¸ = 28.04Â°, å¼·åº¦ = 1021.3
ãƒ”ãƒ¼ã‚¯ 2: 2Î¸ = 32.05Â°, å¼·åº¦ = 1512.7
ãƒ”ãƒ¼ã‚¯ 3: 2Î¸ = 47.07Â°, å¼·åº¦ = 798.5
</code></pre>
<h3>ãƒ”ãƒ¼ã‚¯æ¤œå‡ºãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®æœ€é©åŒ–</h3>
<p><strong>ã‚³ãƒ¼ãƒ‰ä¾‹4: ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿æ„Ÿåº¦è§£æ</strong></p>
<pre><code class="language-python"># ç•°ãªã‚‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã§ãƒ”ãƒ¼ã‚¯æ¤œå‡º
prominence_values = [30, 50, 80, 100]

fig, axes = plt.subplots(2, 2, figsize=(14, 10))
axes = axes.ravel()

for i, prom in enumerate(prominence_values):
    peaks_idx, _ = find_peaks(
        intensity_snip,
        prominence=prom,
        distance=5
    )

    axes[i].plot(two_theta, intensity_snip, linewidth=1.5)
    axes[i].plot(two_theta[peaks_idx], intensity_snip[peaks_idx],
                'rx', markersize=10, markeredgewidth=2)
    axes[i].set_xlabel('2Î¸ (degree)')
    axes[i].set_ylabel('Intensity')
    axes[i].set_title(f'Prominence = {prom} ({len(peaks_idx)} peaks)')
    axes[i].grid(True, alpha=0.3)

plt.tight_layout()
plt.show()

print(&quot;=== ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿æ„Ÿåº¦ ===&quot;)
for prom in prominence_values:
    peaks_idx, _ = find_peaks(intensity_snip, prominence=prom)
    print(f&quot;Prominence = {prom:3d}: {len(peaks_idx)} peaks detected&quot;)
</code></pre>
<h3>ãƒ”ãƒ¼ã‚¯ãƒ•ã‚£ãƒƒãƒ†ã‚£ãƒ³ã‚°ï¼ˆã‚¬ã‚¦ã‚·ã‚¢ãƒ³ãƒ»ãƒ­ãƒ¼ãƒ¬ãƒ³ãƒ„ï¼‰</h3>
<p><strong>ã‚³ãƒ¼ãƒ‰ä¾‹5: ã‚¬ã‚¦ã‚·ã‚¢ãƒ³ãƒ•ã‚£ãƒƒãƒ†ã‚£ãƒ³ã‚°</strong></p>
<pre><code class="language-python">from scipy.optimize import curve_fit

def gaussian(x, amplitude, center, sigma):
    &quot;&quot;&quot;ã‚¬ã‚¦ã‚·ã‚¢ãƒ³é–¢æ•°&quot;&quot;&quot;
    return amplitude * np.exp(-((x - center) ** 2) / (2 * sigma ** 2))

def lorentzian(x, amplitude, center, gamma):
    &quot;&quot;&quot;ãƒ­ãƒ¼ãƒ¬ãƒ³ãƒ„é–¢æ•°&quot;&quot;&quot;
    return amplitude * gamma**2 / ((x - center)**2 + gamma**2)

# æœ€åˆã®ãƒ”ãƒ¼ã‚¯å‘¨è¾ºã‚’æŠ½å‡º
peak_region_mask = (two_theta &gt; 26) &amp; (two_theta &lt; 30)
x_data = two_theta[peak_region_mask]
y_data = intensity_snip[peak_region_mask]

# ã‚¬ã‚¦ã‚·ã‚¢ãƒ³ãƒ•ã‚£ãƒƒãƒ†ã‚£ãƒ³ã‚°
initial_guess = [1000, 28, 1]  # [amplitude, center, sigma]
params_gauss, _ = curve_fit(gaussian, x_data, y_data,
                             p0=initial_guess)

# ãƒ­ãƒ¼ãƒ¬ãƒ³ãƒ„ãƒ•ã‚£ãƒƒãƒ†ã‚£ãƒ³ã‚°
initial_guess_lor = [1000, 28, 0.5]  # [amplitude, center, gamma]
params_lor, _ = curve_fit(lorentzian, x_data, y_data,
                          p0=initial_guess_lor)

# ãƒ•ã‚£ãƒƒãƒˆçµæœ
x_fit = np.linspace(x_data.min(), x_data.max(), 200)
y_gauss = gaussian(x_fit, *params_gauss)
y_lor = lorentzian(x_fit, *params_lor)

# å¯è¦–åŒ–
plt.figure(figsize=(12, 6))

plt.plot(x_data, y_data, 'o', label='Data', markersize=6)
plt.plot(x_fit, y_gauss, '-', linewidth=2,
         label=f'Gaussian (Ïƒ={params_gauss[2]:.2f})')
plt.plot(x_fit, y_lor, '--', linewidth=2,
         label=f'Lorentzian (Î³={params_lor[2]:.2f})')

plt.xlabel('2Î¸ (degree)')
plt.ylabel('Intensity')
plt.title('Peak Fitting: Gaussian vs Lorentzian')
plt.legend()
plt.grid(True, alpha=0.3)
plt.tight_layout()
plt.show()

print(&quot;=== ãƒ•ã‚£ãƒƒãƒ†ã‚£ãƒ³ã‚°çµæœ ===&quot;)
print(f&quot;ã‚¬ã‚¦ã‚·ã‚¢ãƒ³:&quot;)
print(f&quot;  ä¸­å¿ƒä½ç½®: {params_gauss[1]:.3f}Â°&quot;)
print(f&quot;  æŒ¯å¹…: {params_gauss[0]:.1f}&quot;)
print(f&quot;  Ïƒ: {params_gauss[2]:.3f}Â°&quot;)
print(f&quot;\nãƒ­ãƒ¼ãƒ¬ãƒ³ãƒ„:&quot;)
print(f&quot;  ä¸­å¿ƒä½ç½®: {params_lor[1]:.3f}Â°&quot;)
print(f&quot;  æŒ¯å¹…: {params_lor[0]:.1f}&quot;)
print(f&quot;  Î³: {params_lor[2]:.3f}Â°&quot;)
</code></pre>
<hr />
<h2>2.4 XPS ã‚¹ãƒšã‚¯ãƒˆãƒ«è§£æ</h2>
<h3>ã‚·ãƒ£ãƒ¼ãƒªãƒ¼å‹ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰é™¤å»</h3>
<p>XPSã‚¹ãƒšã‚¯ãƒˆãƒ«ã¯éå¼¾æ€§æ•£ä¹±ã«ã‚ˆã‚‹ç‰¹å¾´çš„ãªãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã‚’æŒã¡ã¾ã™ã€‚</p>
<p><strong>ã‚³ãƒ¼ãƒ‰ä¾‹6: ã‚·ãƒ£ãƒ¼ãƒªãƒ¼ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰</strong></p>
<pre><code class="language-python">def shirley_background(x, y, tol=1e-5, max_iter=50):
    &quot;&quot;&quot;
    ã‚·ãƒ£ãƒ¼ãƒªãƒ¼å‹ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰æ¨å®š

    Parameters:
    -----------
    x : array-like
        ã‚¨ãƒãƒ«ã‚®ãƒ¼è»¸ï¼ˆé™é †ã‚’æ¨å¥¨ï¼‰
    y : array-like
        å¼·åº¦
    tol : float
        åæŸåˆ¤å®šé–¾å€¤
    max_iter : int
        æœ€å¤§ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å›æ•°

    Returns:
    --------
    background : array-like
        ã‚·ãƒ£ãƒ¼ãƒªãƒ¼ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰
    &quot;&quot;&quot;
    # ãƒ‡ãƒ¼ã‚¿ã®æº–å‚™
    y = np.array(y, dtype=float)
    background = np.zeros_like(y)

    # ä¸¡ç«¯ã®å€¤
    y_min = min(y[0], y[-1])
    y_max = max(y[0], y[-1])

    # åˆæœŸãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ï¼ˆç·šå½¢ï¼‰
    background = np.linspace(y[0], y[-1], len(y))

    # ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
    for iteration in range(max_iter):
        background_old = background.copy()

        # ç´¯ç©å’Œã‚’ä½¿ç”¨
        cumsum = np.cumsum(y - background)
        total = cumsum[-1]

        if total == 0:
            break

        # æ–°ã—ã„ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰
        background = y[-1] + (y[0] - y[-1]) * cumsum / total

        # åæŸåˆ¤å®š
        if np.max(np.abs(background - background_old)) &lt; tol:
            break

    return background

# XPSã‚µãƒ³ãƒ—ãƒ«ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆï¼ˆC 1s ã‚¹ãƒšã‚¯ãƒˆãƒ«ï¼‰
binding_energy = np.linspace(280, 295, 300)[::-1]  # é™é †
xps_peak = 5000 * np.exp(-((binding_energy - 285) ** 2) / 2)
shirley_bg = np.linspace(500, 200, len(binding_energy))
xps_spectrum = xps_peak + shirley_bg + \
               np.random.normal(0, 50, len(binding_energy))

# ã‚·ãƒ£ãƒ¼ãƒªãƒ¼ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰æ¨å®š
shirley_bg_calc = shirley_background(binding_energy, xps_spectrum)

# ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰æ¸›ç®—
xps_corrected = xps_spectrum - shirley_bg_calc

# å¯è¦–åŒ–
fig, axes = plt.subplots(1, 3, figsize=(16, 5))

# XPSç”Ÿãƒ‡ãƒ¼ã‚¿
axes[0].plot(binding_energy, xps_spectrum, linewidth=1.5)
axes[0].set_xlabel('Binding Energy (eV)')
axes[0].set_ylabel('Intensity (CPS)')
axes[0].set_title('Raw XPS Spectrum (C 1s)')
axes[0].invert_xaxis()
axes[0].grid(True, alpha=0.3)

# ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰æ¨å®š
axes[1].plot(binding_energy, xps_spectrum,
             label='Raw data', alpha=0.6)
axes[1].plot(binding_energy, shirley_bg_calc,
             label='Shirley background',
             linewidth=2, color='red')
axes[1].set_xlabel('Binding Energy (eV)')
axes[1].set_ylabel('Intensity (CPS)')
axes[1].set_title('Shirley Background Estimation')
axes[1].invert_xaxis()
axes[1].legend()
axes[1].grid(True, alpha=0.3)

# è£œæ­£å¾Œ
axes[2].plot(binding_energy, xps_corrected,
             linewidth=1.5, color='green')
axes[2].set_xlabel('Binding Energy (eV)')
axes[2].set_ylabel('Intensity (CPS)')
axes[2].set_title('After Shirley Subtraction')
axes[2].invert_xaxis()
axes[2].grid(True, alpha=0.3)

plt.tight_layout()
plt.show()

print(&quot;=== ã‚·ãƒ£ãƒ¼ãƒªãƒ¼ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰é™¤å» ===&quot;)
print(f&quot;ã‚¨ãƒãƒ«ã‚®ãƒ¼ç¯„å›²: {binding_energy.max():.1f} - &quot;
      f&quot;{binding_energy.min():.1f} eV&quot;)
print(f&quot;ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰é«˜ã•ï¼ˆé«˜BEå´ï¼‰: {shirley_bg_calc[0]:.1f}&quot;)
print(f&quot;ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰é«˜ã•ï¼ˆä½BEå´ï¼‰: {shirley_bg_calc[-1]:.1f}&quot;)
</code></pre>
<hr />
<h2>2.5 IRãƒ»Ramanã‚¹ãƒšã‚¯ãƒˆãƒ«è§£æ</h2>
<h3>ãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ³è£œæ­£ï¼ˆAsymmetric Least Squaresæ³•ï¼‰</h3>
<p>IRãƒ»Ramanã‚¹ãƒšã‚¯ãƒˆãƒ«ã®è›å…‰ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰é™¤å»ã«æœ‰åŠ¹ã§ã™ã€‚</p>
<p><strong>ã‚³ãƒ¼ãƒ‰ä¾‹7: ALSæ³•ã«ã‚ˆã‚‹ãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ³è£œæ­£</strong></p>
<pre><code class="language-python">from scipy import sparse
from scipy.sparse.linalg import spsolve

def als_baseline(y, lam=1e5, p=0.01, niter=10):
    &quot;&quot;&quot;
    Asymmetric Least Squaresæ³•ã«ã‚ˆã‚‹ãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ³æ¨å®š

    Parameters:
    -----------
    y : array-like
        ã‚¹ãƒšã‚¯ãƒˆãƒ«ãƒ‡ãƒ¼ã‚¿
    lam : float
        å¹³æ»‘åŒ–ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ï¼ˆå¤§ãã„ã»ã©æ»‘ã‚‰ã‹ï¼‰
    p : float
        éå¯¾ç§°ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ï¼ˆ0-1ã€å°ã•ã„ã»ã©ãƒ”ãƒ¼ã‚¯ã‚’é¿ã‘ã‚‹ï¼‰
    niter : int
        ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å›æ•°

    Returns:
    --------
    baseline : array-like
        æ¨å®šã•ã‚ŒãŸãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ³
    &quot;&quot;&quot;
    L = len(y)
    D = sparse.diags([1, -2, 1], [0, -1, -2], shape=(L, L-2))
    w = np.ones(L)

    for i in range(niter):
        W = sparse.spdiags(w, 0, L, L)
        Z = W + lam * D.dot(D.transpose())
        z = spsolve(Z, w * y)
        w = p * (y &gt; z) + (1 - p) * (y &lt; z)

    return z

# Ramanã‚µãƒ³ãƒ—ãƒ«ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆ
raman_shift = np.linspace(200, 2000, 900)
raman_peaks = (
    3000 * np.exp(-((raman_shift - 520) ** 2) / 100) +
    2000 * np.exp(-((raman_shift - 950) ** 2) / 200) +
    1500 * np.exp(-((raman_shift - 1350) ** 2) / 150)
)
fluorescence_bg = 500 + 0.5 * raman_shift + \
                  0.0005 * (raman_shift - 1000) ** 2
raman_spectrum = raman_peaks + fluorescence_bg + \
                 np.random.normal(0, 50, len(raman_shift))

# ALSæ³•é©ç”¨
als_bg = als_baseline(raman_spectrum, lam=1e6, p=0.01)
raman_corrected = raman_spectrum - als_bg

# å¯è¦–åŒ–
fig, axes = plt.subplots(1, 3, figsize=(16, 5))

# ç”Ÿãƒ‡ãƒ¼ã‚¿
axes[0].plot(raman_shift, raman_spectrum, linewidth=1.5)
axes[0].set_xlabel('Raman Shift (cmâ»Â¹)')
axes[0].set_ylabel('Intensity (a.u.)')
axes[0].set_title('Raw Raman Spectrum')
axes[0].grid(True, alpha=0.3)

# ãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ³æ¨å®š
axes[1].plot(raman_shift, raman_spectrum,
             label='Raw data', alpha=0.6)
axes[1].plot(raman_shift, als_bg,
             label='ALS baseline', linewidth=2, color='red')
axes[1].set_xlabel('Raman Shift (cmâ»Â¹)')
axes[1].set_ylabel('Intensity (a.u.)')
axes[1].set_title('ALS Baseline Estimation')
axes[1].legend()
axes[1].grid(True, alpha=0.3)

# è£œæ­£å¾Œ
axes[2].plot(raman_shift, raman_corrected,
             linewidth=1.5, color='purple')
axes[2].set_xlabel('Raman Shift (cmâ»Â¹)')
axes[2].set_ylabel('Intensity (a.u.)')
axes[2].set_title('After ALS Subtraction')
axes[2].grid(True, alpha=0.3)

plt.tight_layout()
plt.show()

print(&quot;=== ALS ãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ³è£œæ­£ ===&quot;)
print(f&quot;å¹³æ»‘åŒ–ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ (Î»): 1e6&quot;)
print(f&quot;éå¯¾ç§°ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ (p): 0.01&quot;)
</code></pre>
<hr />
<h2>2.6 å®šé‡ç›¸åˆ†æï¼ˆXRD-RIRæ³•ï¼‰</h2>
<h3>Reference Intensity Ratioï¼ˆRIRï¼‰æ³•</h3>
<p>è¤‡æ•°ç›¸ã‚’å«ã‚€XRDãƒ‘ã‚¿ãƒ¼ãƒ³ã‹ã‚‰ã€å„ç›¸ã®é‡é‡åˆ†ç‡ã‚’ç®—å‡ºã—ã¾ã™ã€‚</p>
<p><strong>ã‚³ãƒ¼ãƒ‰ä¾‹8: RIRæ³•ã«ã‚ˆã‚‹å®šé‡ç›¸åˆ†æ</strong></p>
<pre><code class="language-python"># 2ç›¸ç³»ã®XRDãƒ‘ã‚¿ãƒ¼ãƒ³ç”Ÿæˆ
two_theta = np.linspace(10, 80, 700)

# ç›¸Aï¼ˆä¾‹ï¼šÎ±-Fe2O3ã€ä¸»ãƒ”ãƒ¼ã‚¯: 33.2Â°ï¼‰
phase_A = (
    2000 * np.exp(-((two_theta - 33.2) ** 2) / 15) +
    1200 * np.exp(-((two_theta - 35.6) ** 2) / 10) +
    800 * np.exp(-((two_theta - 54.1) ** 2) / 12)
)

# ç›¸Bï¼ˆä¾‹ï¼šFe3O4ã€ä¸»ãƒ”ãƒ¼ã‚¯: 35.5Â°ï¼‰
phase_B = (
    1500 * np.exp(-((two_theta - 35.5) ** 2) / 18) +
    1000 * np.exp(-((two_theta - 30.1) ** 2) / 12) +
    600 * np.exp(-((two_theta - 62.7) ** 2) / 14)
)

# æ··åˆãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆç›¸A:ç›¸B = 70:30 wt%ï¼‰
ratio_A = 0.7
ratio_B = 0.3
mixed_pattern = ratio_A * phase_A + ratio_B * phase_B + \
                np.random.normal(0, 30, len(two_theta))

# RIRå€¤ï¼ˆæ–‡çŒ®å€¤ã€ã‚³ãƒ©ãƒ³ãƒ€ãƒ ã«å¯¾ã™ã‚‹ç›¸å¯¾å€¤ï¼‰
RIR_A = 3.5  # Î±-Fe2O3ã®RIR
RIR_B = 2.8  # Fe3O4ã®RIR

# ä¸»ãƒ”ãƒ¼ã‚¯å¼·åº¦æ¸¬å®š
# ç›¸Aã®ä¸»ãƒ”ãƒ¼ã‚¯ï¼ˆ33.2Â°ä»˜è¿‘ï¼‰
peak_A_idx = np.argmax(mixed_pattern[(two_theta &gt; 32) &amp;
                                     (two_theta &lt; 34)])
I_A = mixed_pattern[(two_theta &gt; 32) &amp; (two_theta &lt; 34)][peak_A_idx]

# ç›¸Bã®ä¸»ãƒ”ãƒ¼ã‚¯ï¼ˆ35.5Â°ä»˜è¿‘ï¼‰
peak_B_idx = np.argmax(mixed_pattern[(two_theta &gt; 34.5) &amp;
                                     (two_theta &lt; 36)])
I_B = mixed_pattern[(two_theta &gt; 34.5) &amp; (two_theta &lt; 36)][peak_B_idx]

# RIRæ³•ã«ã‚ˆã‚‹é‡é‡åˆ†ç‡è¨ˆç®—
# W_A / W_B = (I_A / I_B) * (RIR_B / RIR_A)
ratio_calc = (I_A / I_B) * (RIR_B / RIR_A)

# æ­£è¦åŒ–
W_A_calc = ratio_calc / (1 + ratio_calc)
W_B_calc = 1 - W_A_calc

# å¯è¦–åŒ–
fig, axes = plt.subplots(2, 2, figsize=(14, 10))

# æ··åˆãƒ‘ã‚¿ãƒ¼ãƒ³
axes[0, 0].plot(two_theta, mixed_pattern, linewidth=1.5)
axes[0, 0].set_xlabel('2Î¸ (degree)')
axes[0, 0].set_ylabel('Intensity')
axes[0, 0].set_title('Mixed XRD Pattern (Phase A + B)')
axes[0, 0].grid(True, alpha=0.3)

# å„ç›¸ã®å¯„ä¸
axes[0, 1].plot(two_theta, ratio_A * phase_A,
                label='Phase A (70%)', linewidth=1.5)
axes[0, 1].plot(two_theta, ratio_B * phase_B,
                label='Phase B (30%)', linewidth=1.5)
axes[0, 1].set_xlabel('2Î¸ (degree)')
axes[0, 1].set_ylabel('Intensity')
axes[0, 1].set_title('Individual Phase Contributions')
axes[0, 1].legend()
axes[0, 1].grid(True, alpha=0.3)

# ä¸»ãƒ”ãƒ¼ã‚¯ã®ä½ç½®
axes[1, 0].plot(two_theta, mixed_pattern, linewidth=1.5)
axes[1, 0].axvline(x=33.2, color='blue',
                   linestyle='--', label='Phase A peak')
axes[1, 0].axvline(x=35.5, color='orange',
                   linestyle='--', label='Phase B peak')
axes[1, 0].set_xlabel('2Î¸ (degree)')
axes[1, 0].set_ylabel('Intensity')
axes[1, 0].set_title('Main Peak Positions')
axes[1, 0].legend()
axes[1, 0].grid(True, alpha=0.3)

# å®šé‡çµæœ
categories = ['Phase A', 'Phase B']
true_values = [ratio_A * 100, ratio_B * 100]
calc_values = [W_A_calc * 100, W_B_calc * 100]

x = np.arange(len(categories))
width = 0.35

axes[1, 1].bar(x - width/2, true_values, width,
               label='True', alpha=0.7)
axes[1, 1].bar(x + width/2, calc_values, width,
               label='Calculated (RIR)', alpha=0.7)
axes[1, 1].set_ylabel('Weight Fraction (%)')
axes[1, 1].set_title('Quantitative Phase Analysis')
axes[1, 1].set_xticks(x)
axes[1, 1].set_xticklabels(categories)
axes[1, 1].legend()
axes[1, 1].grid(True, alpha=0.3, axis='y')

plt.tight_layout()
plt.show()

print(&quot;=== RIRæ³•ã«ã‚ˆã‚‹å®šé‡ç›¸åˆ†æ ===&quot;)
print(f&quot;ä¸»ãƒ”ãƒ¼ã‚¯å¼·åº¦:&quot;)
print(f&quot;  ç›¸A (33.2Â°): {I_A:.1f}&quot;)
print(f&quot;  ç›¸B (35.5Â°): {I_B:.1f}&quot;)
print(f&quot;\nRIRå€¤:&quot;)
print(f&quot;  ç›¸A: {RIR_A}&quot;)
print(f&quot;  ç›¸B: {RIR_B}&quot;)
print(f&quot;\né‡é‡åˆ†ç‡:&quot;)
print(f&quot;  çœŸå€¤ - ç›¸A: {ratio_A*100:.1f}%, ç›¸B: {ratio_B*100:.1f}%&quot;)
print(f&quot;  è¨ˆç®— - ç›¸A: {W_A_calc*100:.1f}%, ç›¸B: {W_B_calc*100:.1f}%&quot;)
print(f&quot;  èª¤å·®: ç›¸A {abs(ratio_A - W_A_calc)*100:.1f}%&quot;)
</code></pre>
<hr />
<h2>2.7 ã‚¹ãƒšã‚¯ãƒˆãƒ«è§£æã®è‡ªå‹•åŒ–ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³</h2>
<h3>çµ±åˆè§£æãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³</h3>
<p><strong>ã‚³ãƒ¼ãƒ‰ä¾‹9: è‡ªå‹•ã‚¹ãƒšã‚¯ãƒˆãƒ«è§£æãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³</strong></p>
<pre><code class="language-python">from dataclasses import dataclass
from typing import Tuple, List

@dataclass
class PeakInfo:
    &quot;&quot;&quot;ãƒ”ãƒ¼ã‚¯æƒ…å ±ã‚’æ ¼ç´ã™ã‚‹ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒ©ã‚¹&quot;&quot;&quot;
    position: float
    intensity: float
    width: float
    area: float

class SpectrumAnalyzer:
    &quot;&quot;&quot;ã‚¹ãƒšã‚¯ãƒˆãƒ«è‡ªå‹•è§£æã‚¯ãƒ©ã‚¹&quot;&quot;&quot;

    def __init__(self, spectrum_type='XRD'):
        &quot;&quot;&quot;
        Parameters:
        -----------
        spectrum_type : str
            'XRD', 'XPS', 'IR', 'Raman'
        &quot;&quot;&quot;
        self.spectrum_type = spectrum_type
        self.x = None
        self.y = None
        self.y_corrected = None
        self.peaks = []

    def load_data(self, x: np.ndarray, y: np.ndarray):
        &quot;&quot;&quot;ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿&quot;&quot;&quot;
        self.x = np.array(x)
        self.y = np.array(y)

    def remove_background(self, method='snip', **kwargs):
        &quot;&quot;&quot;ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰é™¤å»&quot;&quot;&quot;
        if method == 'snip':
            iterations = kwargs.get('iterations', 30)
            bg = snip_background(self.y, iterations)
        elif method == 'polynomial':
            degree = kwargs.get('degree', 5)
            coeffs = np.polyfit(self.x, self.y, degree)
            bg = np.polyval(coeffs, self.x)
        elif method == 'als':
            lam = kwargs.get('lam', 1e5)
            p = kwargs.get('p', 0.01)
            bg = als_baseline(self.y, lam, p)
        else:
            raise ValueError(f&quot;Unknown method: {method}&quot;)

        self.y_corrected = self.y - bg
        return self.y_corrected

    def detect_peaks(self, **kwargs):
        &quot;&quot;&quot;ãƒ”ãƒ¼ã‚¯æ¤œå‡º&quot;&quot;&quot;
        if self.y_corrected is None:
            raise ValueError(&quot;Run remove_background first&quot;)

        prominence = kwargs.get('prominence', 50)
        distance = kwargs.get('distance', 10)

        peaks_idx, properties = find_peaks(
            self.y_corrected,
            prominence=prominence,
            distance=distance
        )

        self.peaks = []
        for idx in peaks_idx:
            peak = PeakInfo(
                position=self.x[idx],
                intensity=self.y_corrected[idx],
                width=properties['widths'][0] if 'widths' in properties else 0,
                area=0  # å¾Œã§è¨ˆç®—
            )
            self.peaks.append(peak)

        return self.peaks

    def report(self):
        &quot;&quot;&quot;çµæœãƒ¬ãƒãƒ¼ãƒˆ&quot;&quot;&quot;
        print(f&quot;\n=== {self.spectrum_type} Spectrum Analysis Report ===&quot;)
        print(f&quot;ãƒ‡ãƒ¼ã‚¿ç‚¹æ•°: {len(self.x)}&quot;)
        print(f&quot;æ¤œå‡ºã•ã‚ŒãŸãƒ”ãƒ¼ã‚¯æ•°: {len(self.peaks)}&quot;)
        print(f&quot;\nãƒ”ãƒ¼ã‚¯æƒ…å ±:&quot;)
        for i, peak in enumerate(self.peaks, 1):
            if self.spectrum_type == 'XRD':
                print(f&quot;  ãƒ”ãƒ¼ã‚¯ {i}: 2Î¸ = {peak.position:.2f}Â°, &quot;
                      f&quot;å¼·åº¦ = {peak.intensity:.1f}&quot;)
            elif self.spectrum_type == 'XPS':
                print(f&quot;  ãƒ”ãƒ¼ã‚¯ {i}: BE = {peak.position:.2f} eV, &quot;
                      f&quot;å¼·åº¦ = {peak.intensity:.1f}&quot;)
            elif self.spectrum_type in ['IR', 'Raman']:
                print(f&quot;  ãƒ”ãƒ¼ã‚¯ {i}: {peak.position:.1f} cmâ»Â¹, &quot;
                      f&quot;å¼·åº¦ = {peak.intensity:.1f}&quot;)

# ä½¿ç”¨ä¾‹
analyzer = SpectrumAnalyzer(spectrum_type='XRD')
analyzer.load_data(two_theta, intensity)
analyzer.remove_background(method='snip', iterations=50)
peaks = analyzer.detect_peaks(prominence=80, distance=10)
analyzer.report()

# å¯è¦–åŒ–
plt.figure(figsize=(14, 6))

plt.subplot(1, 2, 1)
plt.plot(analyzer.x, analyzer.y, label='Raw', alpha=0.5)
plt.plot(analyzer.x, analyzer.y_corrected,
         label='Background-corrected', linewidth=1.5)
plt.xlabel('2Î¸ (degree)')
plt.ylabel('Intensity')
plt.title('Spectrum Processing')
plt.legend()
plt.grid(True, alpha=0.3)

plt.subplot(1, 2, 2)
plt.plot(analyzer.x, analyzer.y_corrected, linewidth=1.5)
peak_positions = [p.position for p in peaks]
peak_intensities = [p.intensity for p in peaks]
plt.plot(peak_positions, peak_intensities, 'rx',
         markersize=12, markeredgewidth=2)
plt.xlabel('2Î¸ (degree)')
plt.ylabel('Intensity')
plt.title('Peak Detection')
plt.grid(True, alpha=0.3)

plt.tight_layout()
plt.show()
</code></pre>
<hr />
<h2>2.8 å®Ÿè·µçš„ãªè½ã¨ã—ç©´ã¨å¯¾ç­–</h2>
<h3>ã‚ˆãã‚ã‚‹å¤±æ•—ä¾‹ã¨ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹</h3>
<h4>å¤±æ•—1: ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰é™¤å»ã®éå‰°é©ç”¨</h4>
<p><strong>ç—‡çŠ¶</strong>: ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰é™¤å»å¾Œã€ãƒ”ãƒ¼ã‚¯å¼·åº¦ãŒè² ã«ãªã‚‹ã€ã¾ãŸã¯å°ã•ãªãƒ”ãƒ¼ã‚¯ãŒæ¶ˆå¤±</p>
<p><strong>åŸå› </strong>: å¤šé …å¼æ¬¡æ•°ãŒé«˜ã™ãã‚‹ã€ã¾ãŸã¯SNIPã®iterationså€¤ãŒå¤§ãã™ãã‚‹</p>
<p><strong>å¯¾ç­–</strong>:</p>
<pre><code class="language-python"># âŒ æ‚ªã„ä¾‹ï¼šéåº¦ãªãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰é™¤å»
poly_degree = 15  # é«˜ã™ãã‚‹æ¬¡æ•°
bg = np.polyval(np.polyfit(two_theta, intensity, poly_degree), two_theta)
corrected = intensity - bg
# çµæœ: ãƒ”ãƒ¼ã‚¯ãŒæ­ªã¿ã€è² ã®å€¤ãŒç™ºç”Ÿ

# âœ… è‰¯ã„ä¾‹ï¼šé©åˆ‡ãªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¨æ¤œè¨¼
poly_degree = 5  # é©åº¦ãªæ¬¡æ•°
bg = np.polyval(np.polyfit(two_theta, intensity, poly_degree), two_theta)
corrected = intensity - bg

# æ¤œè¨¼: è² ã®å€¤ã®å‰²åˆã‚’ãƒã‚§ãƒƒã‚¯
negative_ratio = (corrected &lt; 0).sum() / len(corrected)
if negative_ratio &gt; 0.05:  # 5%ä»¥ä¸ŠãŒè² ãªã‚‰è­¦å‘Š
    print(f&quot;è­¦å‘Š: ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰é™¤å»ãŒéå‰°ã§ã™ï¼ˆè² ã®å€¤ãŒ{negative_ratio*100:.1f}%ï¼‰&quot;)
    print(&quot;å¤šé …å¼æ¬¡æ•°ã‚’ä¸‹ã’ã‚‹ã‹ã€SNIPã®iterationsã‚’æ¸›ã‚‰ã—ã¦ãã ã•ã„&quot;)
</code></pre>
<h4>å¤±æ•—2: ãƒ”ãƒ¼ã‚¯æ¤œå‡ºãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®ä¸é©åˆ‡ãªè¨­å®š</h4>
<p><strong>ç—‡çŠ¶</strong>: ãƒã‚¤ã‚ºã‚’èª¤ã£ã¦ãƒ”ãƒ¼ã‚¯ã¨ã—ã¦æ¤œå‡ºã€ã¾ãŸã¯çœŸã®ãƒ”ãƒ¼ã‚¯ã‚’è¦‹é€ƒã™</p>
<p><strong>åŸå› </strong>: prominenceã‚„heightã®é–¾å€¤ãŒé©åˆ‡ã§ãªã„</p>
<p><strong>å¯¾ç­–</strong>:</p>
<pre><code class="language-python"># âŒ æ‚ªã„ä¾‹ï¼šå›ºå®šãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
peaks, _ = find_peaks(spectrum, prominence=50, height=100)
# ç•°ãªã‚‹S/Næ¯”ã®ãƒ‡ãƒ¼ã‚¿ã«å¯¾å¿œã§ããªã„

# âœ… è‰¯ã„ä¾‹ï¼šé©å¿œçš„ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿è¨­å®š
# ãƒã‚¤ã‚ºãƒ¬ãƒ™ãƒ«ã®å®šé‡è©•ä¾¡
baseline_region = spectrum[(two_theta &gt; 70) &amp; (two_theta &lt; 80)]  # ä¿¡å·ãªã—é ˜åŸŸ
noise_std = np.std(baseline_region)
snr = spectrum.max() / noise_std

# S/Næ¯”ã«å¿œã˜ãŸãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿èª¿æ•´
if snr &gt; 50:  # é«˜å“è³ªãƒ‡ãƒ¼ã‚¿
    prominence = 3 * noise_std
    height = 2 * noise_std
elif snr &gt; 20:  # ä¸­å“è³ªãƒ‡ãƒ¼ã‚¿
    prominence = 5 * noise_std
    height = 3 * noise_std
else:  # ä½å“è³ªãƒ‡ãƒ¼ã‚¿
    prominence = 10 * noise_std
    height = 5 * noise_std
    print(f&quot;è­¦å‘Š: S/Næ¯”ãŒä½ã„ï¼ˆ{snr:.1f}ï¼‰ã€‚æ¸¬å®šã‚’å†å®Ÿè¡Œã—ã¦ãã ã•ã„&quot;)

peaks, properties = find_peaks(spectrum, prominence=prominence, height=height)
print(f&quot;ãƒã‚¤ã‚ºãƒ¬ãƒ™ãƒ«: {noise_std:.2f}, S/Næ¯”: {snr:.1f}&quot;)
print(f&quot;æ¤œå‡ºã•ã‚ŒãŸãƒ”ãƒ¼ã‚¯æ•°: {len(peaks)}&quot;)
</code></pre>
<h4>å¤±æ•—3: XPSã‚¹ãƒšã‚¯ãƒˆãƒ«ã®èª¤ã£ãŸå®šé‡</h4>
<p><strong>ç—‡çŠ¶</strong>: å…ƒç´ çµ„æˆãŒç‰©ç†çš„ã«ã‚ã‚Šãˆãªã„å€¤ï¼ˆåˆè¨ˆãŒ100%ã‚’å¤§ããè¶…ãˆã‚‹ã€ã¾ãŸã¯è² ï¼‰</p>
<p><strong>åŸå› </strong>: ã‚·ãƒ£ãƒ¼ãƒªãƒ¼ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰é™¤å»ã®å¤±æ•—ã€ã¾ãŸã¯æ„Ÿåº¦ä¿‚æ•°ã®èª¤ç”¨</p>
<p><strong>å¯¾ç­–</strong>:</p>
<pre><code class="language-python"># âŒ æ‚ªã„ä¾‹ï¼šãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰é™¤å»ãªã—ã§å®šé‡
peak_area_C = np.trapz(xps_C_spectrum, binding_energy_C)
peak_area_O = np.trapz(xps_O_spectrum, binding_energy_O)
# çµæœ: ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã‚‚å«ã‚ãŸç©åˆ†å€¤

# âœ… è‰¯ã„ä¾‹ï¼šã‚·ãƒ£ãƒ¼ãƒªãƒ¼è£œæ­£å¾Œã®ãƒ”ãƒ¼ã‚¯é¢ç©
bg_C = shirley_background(binding_energy_C, xps_C_spectrum)
corrected_C = xps_C_spectrum - bg_C
peak_area_C = np.trapz(corrected_C[corrected_C &gt; 0],
                       binding_energy_C[corrected_C &gt; 0])

bg_O = shirley_background(binding_energy_O, xps_O_spectrum)
corrected_O = xps_O_spectrum - bg_O
peak_area_O = np.trapz(corrected_O[corrected_O &gt; 0],
                       binding_energy_O[corrected_O &gt; 0])

# æ„Ÿåº¦ä¿‚æ•°ã§è£œæ­£ï¼ˆæ–‡çŒ®å€¤ã‚’ä½¿ç”¨ï¼‰
SENSITIVITY_FACTORS = {'C': 0.296, 'O': 0.711, 'Fe': 2.957}  # Scofield
atomic_ratio_C = peak_area_C / SENSITIVITY_FACTORS['C']
atomic_ratio_O = peak_area_O / SENSITIVITY_FACTORS['O']

# æ­£è¦åŒ–
total = atomic_ratio_C + atomic_ratio_O
at_percent_C = (atomic_ratio_C / total) * 100
at_percent_O = (atomic_ratio_O / total) * 100

# æ¤œè¨¼
assert abs(at_percent_C + at_percent_O - 100) &lt; 1, &quot;çµ„æˆã®åˆè¨ˆãŒ100%ã§ã‚ã‚Šã¾ã›ã‚“&quot;
print(f&quot;C: {at_percent_C:.1f} at%, O: {at_percent_O:.1f} at%&quot;)
</code></pre>
<h4>å¤±æ•—4: RIRæ³•ã®èª¤ç”¨</h4>
<p><strong>ç—‡çŠ¶</strong>: å®šé‡ç›¸åˆ†æã®çµæœãŒé‡é‡æ¯”ã®åˆè¨ˆ100%ã‚’å¤§ããé€¸è„±</p>
<p><strong>åŸå› </strong>: RIRå€¤ã®ä¸ä¸€è‡´ï¼ˆç•°ãªã‚‹å‚ç…§ç‰©è³ªï¼‰ã€ã¾ãŸã¯ãƒ”ãƒ¼ã‚¯é‡ãªã‚Šã®ç„¡è¦–</p>
<p><strong>å¯¾ç­–</strong>:</p>
<pre><code class="language-python"># âŒ æ‚ªã„ä¾‹ï¼šãƒ”ãƒ¼ã‚¯é‡ãªã‚Šã‚’ç„¡è¦–ã—ãŸå®šé‡
I_A = intensity[peak_A_index]  # å˜ä¸€ç‚¹ã®å¼·åº¦
I_B = intensity[peak_B_index]
# çµæœ: è¿‘æ¥ãƒ”ãƒ¼ã‚¯ã®å½±éŸ¿ã§èª¤å·®ãŒå¤§ãã„

# âœ… è‰¯ã„ä¾‹ï¼šãƒ”ãƒ¼ã‚¯åˆ†é›¢ã¨RIRæ³•ã®æ­£ã—ã„é©ç”¨
# ãƒ”ãƒ¼ã‚¯é ˜åŸŸã®æŠ½å‡º
peak_A_region = (two_theta &gt; 32) &amp; (two_theta &lt; 34)
peak_B_region = (two_theta &gt; 34.5) &amp; (two_theta &lt; 36.5)

# ã‚¬ã‚¦ã‚·ã‚¢ãƒ³ãƒ•ã‚£ãƒƒãƒ†ã‚£ãƒ³ã‚°ã§ãƒ”ãƒ¼ã‚¯åˆ†é›¢
from scipy.optimize import curve_fit

def gaussian(x, amp, cen, wid):
    return amp * np.exp(-(x - cen)**2 / (2 * wid**2))

# ç›¸Aã®ãƒ”ãƒ¼ã‚¯ãƒ•ã‚£ãƒƒãƒˆ
popt_A, _ = curve_fit(gaussian, two_theta[peak_A_region],
                      intensity[peak_A_region],
                      p0=[1000, 33.2, 0.5])
I_A_corrected = popt_A[0]  # ãƒ”ãƒ¼ã‚¯é«˜ã•

# ç›¸Bã®ãƒ”ãƒ¼ã‚¯ãƒ•ã‚£ãƒƒãƒˆï¼ˆåŒæ§˜ï¼‰
popt_B, _ = curve_fit(gaussian, two_theta[peak_B_region],
                      intensity[peak_B_region],
                      p0=[1500, 35.5, 0.5])
I_B_corrected = popt_B[0]

# RIRå€¤ã®ç¢ºèªï¼ˆåŒã˜å‚ç…§ç‰©è³ªã«å¯¾ã™ã‚‹å€¤ã‚’ä½¿ç”¨ï¼‰
RIR_A = 3.5  # vs Corundum (Î±-Al2O3)
RIR_B = 2.8  # vs Corundum (Î±-Al2O3)

# é‡é‡åˆ†ç‡è¨ˆç®—
ratio = (I_A_corrected / I_B_corrected) * (RIR_B / RIR_A)
W_A = ratio / (1 + ratio)
W_B = 1 - W_A

# æ¤œè¨¼
assert abs(W_A + W_B - 1.0) &lt; 0.01, &quot;é‡é‡åˆ†ç‡ã®åˆè¨ˆãŒ1ã§ã‚ã‚Šã¾ã›ã‚“&quot;
print(f&quot;ç›¸A: {W_A*100:.1f} wt%, ç›¸B: {W_B*100:.1f} wt%&quot;)
</code></pre>
<h4>å¤±æ•—5: ã‚¹ãƒšã‚¯ãƒˆãƒ«è§£æã®æ¸¬å®šèª¤å·®ç„¡è¦–</h4>
<p><strong>ç—‡çŠ¶</strong>: è§£æçµæœã«èª¤å·®ç¯„å›²ãŒç¤ºã•ã‚Œãšã€å†ç¾æ€§ãŒè©•ä¾¡ã§ããªã„</p>
<p><strong>åŸå› </strong>: æ¸¬å®šã®ç¹°ã‚Šè¿”ã—ã‚„ãƒã‚¤ã‚ºã®å½±éŸ¿ã‚’å®šé‡ã—ã¦ã„ãªã„</p>
<p><strong>å¯¾ç­–</strong>:</p>
<pre><code class="language-python"># âŒ æ‚ªã„ä¾‹ï¼š1å›æ¸¬å®šã®ã¿ã€èª¤å·®ãªã—
peak_position = two_theta[peak_index]
print(f&quot;ãƒ”ãƒ¼ã‚¯ä½ç½®: {peak_position:.2f}Â°&quot;)

# âœ… è‰¯ã„ä¾‹ï¼šè¤‡æ•°æ¸¬å®šã¨èª¤å·®è©•ä¾¡
# åŒä¸€ã‚µãƒ³ãƒ—ãƒ«ã®3å›æ¸¬å®š
measurements = []
for i in range(3):
    spectrum_i = measure_xrd()  # æ¸¬å®šé–¢æ•°
    bg_i = snip_background(spectrum_i, iterations=50)
    corrected_i = spectrum_i - bg_i
    peaks_i, _ = find_peaks(corrected_i, prominence=80)

    # ä¸»ãƒ”ãƒ¼ã‚¯ï¼ˆæœ€å¤§å¼·åº¦ãƒ”ãƒ¼ã‚¯ï¼‰ã®ä½ç½®
    main_peak_i = two_theta[peaks_i[np.argmax(corrected_i[peaks_i])]]
    measurements.append(main_peak_i)

# çµ±è¨ˆå‡¦ç†
peak_mean = np.mean(measurements)
peak_std = np.std(measurements, ddof=1)  # ä¸åæ¨™æº–åå·®
peak_sem = peak_std / np.sqrt(len(measurements))  # æ¨™æº–èª¤å·®

print(f&quot;ãƒ”ãƒ¼ã‚¯ä½ç½®: {peak_mean:.3f} Â± {peak_sem:.3f}Â°ï¼ˆå¹³å‡Â±æ¨™æº–èª¤å·®ã€n=3ï¼‰&quot;)

# æ¸¬å®šèª¤å·®ãŒå¤§ãã„å ´åˆã®è­¦å‘Š
if peak_std &gt; 0.1:  # 0.1Â°ä»¥ä¸Šã®ã°ã‚‰ã¤ã
    print(f&quot;è­¦å‘Š: æ¸¬å®šã®ã°ã‚‰ã¤ããŒå¤§ãã„ï¼ˆÏƒ={peak_std:.3f}Â°ï¼‰&quot;)
    print(&quot;è©¦æ–™ã®ã‚¢ãƒ©ã‚¤ãƒ¡ãƒ³ãƒˆã‚„è£…ç½®ã®å®‰å®šæ€§ã‚’ç¢ºèªã—ã¦ãã ã•ã„&quot;)
</code></pre>
<hr />
<h2>2.9 ã‚¹ãƒšã‚¯ãƒˆãƒ«è§£æãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ</h2>
<h3>ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿ã¨æ¤œè¨¼</h3>
<ul>
<li>[ ] ãƒ‡ãƒ¼ã‚¿å½¢å¼ãŒæ­£ã—ã„ã‹ç¢ºèªï¼ˆ2Î¸, ã‚¨ãƒãƒ«ã‚®ãƒ¼, æ³¢æ•°ã®å˜ä½ï¼‰</li>
<li>[ ] ãƒ‡ãƒ¼ã‚¿ç¯„å›²ãŒå¦¥å½“ã‹ç¢ºèªï¼ˆXRD: 10-80Â°, XPS: 0-1200 eV, Raman: 200-2000 cmâ»Â¹ï¼‰</li>
<li>[ ] æ¬ æå€¤ã®å‰²åˆã‚’ç¢ºèªï¼ˆ10%ä»¥ä¸Šã¯è¦æ³¨æ„ï¼‰</li>
<li>[ ] ãƒ‡ãƒ¼ã‚¿ç‚¹æ•°ãŒååˆ†ã‹ç¢ºèªï¼ˆæœ€ä½100ç‚¹ä»¥ä¸Šæ¨å¥¨ï¼‰</li>
<li>[ ] ã‚¹ãƒšã‚¯ãƒˆãƒ«ã®å¯è¦–åŒ–ï¼ˆå…¨ä½“åƒã®æŠŠæ¡ï¼‰</li>
</ul>
<h3>ç’°å¢ƒã¨å†ç¾æ€§</h3>
<ul>
<li>[ ] Python, NumPy, SciPy, Matplotlibã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’è¨˜éŒ²</li>
<li>[ ] è§£æãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’JSON/YAMLãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜</li>
<li>[ ] ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ä½¿ç”¨æ™‚ã¯ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã¨å¼•ç”¨æƒ…å ±ã‚’è¨˜éŒ²</li>
<li>[ ] å•†ç”¨ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ï¼ˆICDDï¼‰ä½¿ç”¨æ™‚ã¯åˆ©ç”¨è¦ç´„ã‚’éµå®ˆ</li>
<li>[ ] ä¹±æ•°ã‚·ãƒ¼ãƒ‰å›ºå®šï¼ˆè©²å½“ã™ã‚‹å ´åˆï¼‰</li>
</ul>
<h3>ãƒã‚¤ã‚ºãƒ¬ãƒ™ãƒ«è©•ä¾¡</h3>
<ul>
<li>[ ] ãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ³é ˜åŸŸã§ãƒã‚¤ã‚ºã®æ¨™æº–åå·®ã‚’è¨ˆç®—</li>
<li>[ ] S/Næ¯”ã‚’è¨ˆç®—ï¼ˆãƒ”ãƒ¼ã‚¯é«˜ã• / ãƒã‚¤ã‚ºæ¨™æº–åå·®ï¼‰</li>
<li>[ ] S/Næ¯”ãŒ3ä»¥ä¸Šã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèª</li>
<li>[ ] å¿…è¦ã«å¿œã˜ã¦ã‚¹ãƒ ãƒ¼ã‚¸ãƒ³ã‚°é©ç”¨ï¼ˆãƒã‚¤ã‚ºé™¤å»ï¼‰</li>
</ul>
<h3>ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰é™¤å»</h3>
<ul>
<li>[ ] æ¸¬å®šæŠ€è¡“ã«å¿œã˜ãŸæ‰‹æ³•ã‚’é¸æŠ</li>
<li>XRD/Raman: SNIPæ³•ã¾ãŸã¯å¤šé …å¼ãƒ•ã‚£ãƒƒãƒ†ã‚£ãƒ³ã‚°</li>
<li>XPS: ã‚·ãƒ£ãƒ¼ãƒªãƒ¼å‹ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰</li>
<li>IR/Ramanï¼ˆè›å…‰ã‚ã‚Šï¼‰: ALSæ³•</li>
<li>[ ] ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’è¨˜éŒ²ï¼ˆå¤šé …å¼æ¬¡æ•°ã€SNIPã‚¤ãƒ†ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³æ•°ï¼‰</li>
<li>[ ] ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰æ¸›ç®—å¾Œã€è² ã®å€¤ã®å‰²åˆã‚’ç¢ºèªï¼ˆ5%ä»¥ä¸‹ãŒæœ›ã¾ã—ã„ï¼‰</li>
<li>[ ] <strong>è£œæ­£å‰å¾Œã®ã‚¹ãƒšã‚¯ãƒˆãƒ«ã‚’å¿…ãšå¯è¦–åŒ–</strong></li>
</ul>
<h3>ãƒ”ãƒ¼ã‚¯æ¤œå‡º</h3>
<ul>
<li>[ ] ãƒã‚¤ã‚ºãƒ¬ãƒ™ãƒ«ã«åŸºã¥ã„ã¦prominence/heightã‚’è¨­å®š</li>
<li>[ ] ç‰©ç†çš„ã«å¦¥å½“ãªãƒ”ãƒ¼ã‚¯å¹…ï¼ˆwidthï¼‰ã‚’è¨­å®š</li>
<li>[ ] æœ€å°ãƒ”ãƒ¼ã‚¯é–“éš”ï¼ˆdistanceï¼‰ã‚’è¨­å®š</li>
<li>[ ] <strong>æ¤œå‡ºã•ã‚ŒãŸãƒ”ãƒ¼ã‚¯ã‚’å…ƒã‚¹ãƒšã‚¯ãƒˆãƒ«ã«é‡ã­ã¦å¯è¦–åŒ–</strong></li>
<li>[ ] ãƒ”ãƒ¼ã‚¯æ•°ãŒæœŸå¾…å€¤ã¨ä¸€è‡´ã™ã‚‹ã‹ç¢ºèª</li>
</ul>
<h3>ãƒ”ãƒ¼ã‚¯ãƒ•ã‚£ãƒƒãƒ†ã‚£ãƒ³ã‚°</h3>
<ul>
<li>[ ] ãƒ”ãƒ¼ã‚¯å½¢çŠ¶é–¢æ•°ã‚’é¸æŠï¼ˆã‚¬ã‚¦ã‚·ã‚¢ãƒ³ã€ãƒ­ãƒ¼ãƒ¬ãƒ³ãƒ„ã€Pseudo-Voigtï¼‰</li>
<li>[ ] åˆæœŸå€¤ã‚’é©åˆ‡ã«è¨­å®šï¼ˆãƒ•ã‚£ãƒƒãƒ†ã‚£ãƒ³ã‚°ã®åæŸæ€§ï¼‰</li>
<li>[ ] ãƒ•ã‚£ãƒƒãƒ†ã‚£ãƒ³ã‚°çµæœã®RÂ²å€¤ã‚’ç¢ºèªï¼ˆ0.95ä»¥ä¸ŠãŒæœ›ã¾ã—ã„ï¼‰</li>
<li>[ ] ãƒ•ã‚£ãƒƒãƒˆæ›²ç·šã¨å®Ÿæ¸¬å€¤ã‚’å¯è¦–åŒ–</li>
<li>[ ] æ®‹å·®ãƒ—ãƒ­ãƒƒãƒˆã§ç³»çµ±èª¤å·®ã‚’ç¢ºèª</li>
</ul>
<h3>å®šé‡åˆ†æï¼ˆXRD-RIRæ³•ï¼‰</h3>
<ul>
<li>[ ] RIRå€¤ã®å‚ç…§ç‰©è³ªãŒçµ±ä¸€ã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª</li>
<li>[ ] ãƒ”ãƒ¼ã‚¯é‡ãªã‚ŠãŒã‚ã‚‹å ´åˆã¯ãƒ”ãƒ¼ã‚¯åˆ†é›¢ã‚’å®Ÿæ–½</li>
<li>[ ] é‡é‡åˆ†ç‡ã®åˆè¨ˆãŒ100%ã«è¿‘ã„ã‹ç¢ºèªï¼ˆÂ±5%ä»¥å†…ï¼‰</li>
<li>[ ] è¤‡æ•°æ¸¬å®šã®å¹³å‡ã¨æ¨™æº–åå·®ã‚’å ±å‘Š</li>
</ul>
<h3>å®šé‡åˆ†æï¼ˆXPSï¼‰</h3>
<ul>
<li>[ ] ã‚·ãƒ£ãƒ¼ãƒªãƒ¼ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰é™¤å»ã‚’å®Ÿæ–½</li>
<li>[ ] ãƒ”ãƒ¼ã‚¯é¢ç©ã‚’ç©åˆ†ï¼ˆè² ã®å€¤ã‚’é™¤å¤–ï¼‰</li>
<li>[ ] æ„Ÿåº¦ä¿‚æ•°ã§è£œæ­£ï¼ˆScofieldä¿‚æ•°ãªã©ï¼‰</li>
<li>[ ] åŸå­%ã®åˆè¨ˆãŒ100%ã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèª</li>
<li>[ ] ã‚¹ãƒ”ãƒ³è»Œé“åˆ†è£‚ã‚’è€ƒæ…®ï¼ˆè©²å½“ã™ã‚‹å ´åˆï¼‰</li>
</ul>
<h3>çµæœã®å¦¥å½“æ€§æ¤œè¨¼</h3>
<ul>
<li>[ ] æ—¢çŸ¥ã‚µãƒ³ãƒ—ãƒ«ã§æ‰‹æ³•ã‚’æ¤œè¨¼</li>
<li>[ ] æ–‡çŒ®å€¤ã¨æ¯”è¼ƒï¼ˆãƒ”ãƒ¼ã‚¯ä½ç½®ã€å¼·åº¦æ¯”ï¼‰</li>
<li>[ ] è¤‡æ•°æ¸¬å®šã®å†ç¾æ€§ã‚’ç¢ºèªï¼ˆæ¨™æº–åå·®ã€æ¨™æº–èª¤å·®ï¼‰</li>
<li>[ ] ç‰©ç†çš„ãƒ»åŒ–å­¦çš„å¦¥å½“æ€§ã‚’è©•ä¾¡</li>
<li>[ ] æ¸¬å®šèª¤å·®ã¨è§£æèª¤å·®ã‚’åˆ†é›¢</li>
</ul>
<h3>è‡ªå‹•åŒ–ãƒ»ãƒãƒƒãƒå‡¦ç†</h3>
<ul>
<li>[ ] ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã‚’å®Ÿè£…ï¼ˆtry-exceptï¼‰</li>
<li>[ ] å‡¦ç†å¤±æ•—æ™‚ã®ãƒ­ã‚°è¨˜éŒ²</li>
<li>[ ] å‡¦ç†æ™‚é–“ã‚’æ¸¬å®šãƒ»è¨˜éŒ²</li>
<li>[ ] æˆåŠŸç‡ã‚’è¨ˆç®—ãƒ»å ±å‘Šï¼ˆä¾‹: 95/100 files succeededï¼‰</li>
<li>[ ] çµæœã‚’JSON/CSVå½¢å¼ã§ä¿å­˜</li>
</ul>
<h3>æ–‡æ›¸åŒ–</h3>
<ul>
<li>[ ] è§£ææ‰‹é †ã‚’å†ç¾å¯èƒ½ãªå½¢ã§è¨˜éŒ²</li>
<li>[ ] ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿è¨­å®šã®æ ¹æ‹ ã‚’è¨˜è¼‰</li>
<li>[ ] ä½¿ç”¨ã—ãŸãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãƒ»æ–‡çŒ®ã‚’å¼•ç”¨</li>
<li>[ ] æœ€çµ‚çµæœã®ä¸ç¢ºã‹ã•ã‚’æ˜ç¤º</li>
<li>[ ] ã‚³ãƒ¼ãƒ‰ã«ã‚³ãƒ¡ãƒ³ãƒˆã‚’è¿½åŠ ï¼ˆå°†æ¥ã®è‡ªåˆ†ã®ãŸã‚ï¼‰</li>
</ul>
<hr />
<h2>2.10 æœ¬ç« ã®ã¾ã¨ã‚</h2>
<h3>å­¦ã‚“ã ã“ã¨</h3>
<ol>
<li>
<p><strong>ãƒ‡ãƒ¼ã‚¿ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã¨å†ç¾æ€§</strong>
   - ã‚¹ãƒšã‚¯ãƒˆãƒ«ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®æ´»ç”¨ã¨ãƒ©ã‚¤ã‚»ãƒ³ã‚¹éµå®ˆ
   - ç’°å¢ƒæƒ…å ±ã¨ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®æ–‡æ›¸åŒ–
   - ã‚³ãƒ¼ãƒ‰å†ç¾æ€§ã®ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹</p>
</li>
<li>
<p><strong>ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰é™¤å»æ‰‹æ³•</strong>
   - å¤šé …å¼ãƒ•ã‚£ãƒƒãƒ†ã‚£ãƒ³ã‚°ï¼ˆæ±ç”¨ï¼‰
   - SNIPæ³•ï¼ˆXRDã€Ramanï¼‰
   - ã‚·ãƒ£ãƒ¼ãƒªãƒ¼å‹ï¼ˆXPSï¼‰
   - ALSæ³•ï¼ˆIRã€Ramanï¼‰</p>
</li>
<li>
<p><strong>ãƒ”ãƒ¼ã‚¯æ¤œå‡º</strong>
   - <code>scipy.signal.find_peaks</code>ã®æ´»ç”¨
   - ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿æœ€é©åŒ–ï¼ˆprominenceã€distanceã€widthï¼‰
   - ã‚¬ã‚¦ã‚·ã‚¢ãƒ³ãƒ»ãƒ­ãƒ¼ãƒ¬ãƒ³ãƒ„ãƒ•ã‚£ãƒƒãƒ†ã‚£ãƒ³ã‚°</p>
</li>
<li>
<p><strong>å®šé‡åˆ†æ</strong>
   - RIRæ³•ã«ã‚ˆã‚‹ç›¸åˆ†ç‡è¨ˆç®—
   - XPSå®šé‡ï¼ˆæ„Ÿåº¦ä¿‚æ•°è£œæ­£ï¼‰
   - ãƒ”ãƒ¼ã‚¯é¢ç©ã®å®šé‡è©•ä¾¡</p>
</li>
<li>
<p><strong>å®Ÿè·µçš„ãªè½ã¨ã—ç©´</strong>
   - ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰é™¤å»ã®éå‰°é©ç”¨å›é¿
   - é©å¿œçš„ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿è¨­å®š
   - æ¸¬å®šèª¤å·®ã®å®šé‡è©•ä¾¡</p>
</li>
<li>
<p><strong>è‡ªå‹•åŒ–</strong>
   - ã‚¯ãƒ©ã‚¹ãƒ™ãƒ¼ã‚¹ã®è§£æãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³
   - è¤‡æ•°æ¸¬å®šæŠ€è¡“ã¸ã®å¯¾å¿œ</p>
</li>
</ol>
<h3>é‡è¦ãªãƒã‚¤ãƒ³ãƒˆ</h3>
<ul>
<li>âœ… ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ä½¿ç”¨æ™‚ã¯ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã¨å¼•ç”¨ã‚’å¿…ãšç¢ºèª</li>
<li>âœ… è§£æãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’æ–‡æ›¸åŒ–ã—å†ç¾æ€§ã‚’ç¢ºä¿</li>
<li>âœ… ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰é™¤å»ã¯æ¸¬å®šæŠ€è¡“ã”ã¨ã«é©åˆ‡ãªæ‰‹æ³•ã‚’é¸æŠ</li>
<li>âœ… ãƒ”ãƒ¼ã‚¯æ¤œå‡ºã§ã¯ã€ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿èª¿æ•´ã¨å¯è¦–åŒ–ç¢ºèªãŒå¿…é ˆ</li>
<li>âœ… å®šé‡åˆ†æã«ã¯æ¨™æº–è©¦æ–™ã‚„RIRå€¤ãªã©ã®å‚ç…§æƒ…å ±ãŒå¿…è¦</li>
<li>âœ… æ¸¬å®šèª¤å·®ã‚’å®šé‡è©•ä¾¡ã—ã€çµæœã«ä¸ç¢ºã‹ã•ã‚’æ˜ç¤º</li>
<li>âœ… è‡ªå‹•åŒ–ã«ã‚ˆã‚Šå†ç¾æ€§ã¨å‡¦ç†é€Ÿåº¦ãŒå¤§å¹…ã«å‘ä¸Š</li>
</ul>
<h3>æ¬¡ã®ç« ã¸</h3>
<p>ç¬¬3ç« ã§ã¯ã€ç”»åƒãƒ‡ãƒ¼ã‚¿ï¼ˆSEMã€TEMï¼‰ã®è§£ææ‰‹æ³•ã‚’å­¦ã³ã¾ã™ï¼š
- ç”»åƒå‰å‡¦ç†ï¼ˆãƒã‚¤ã‚ºé™¤å»ã€ã‚³ãƒ³ãƒˆãƒ©ã‚¹ãƒˆèª¿æ•´ï¼‰
- ç²’å­æ¤œå‡ºï¼ˆWatershedæ³•ï¼‰
- ç²’å¾„åˆ†å¸ƒè§£æ
- CNNã«ã‚ˆã‚‹ç”»åƒåˆ†é¡</p>
<p><strong><a href="./chapter-3.html">ç¬¬3ç« ï¼šç”»åƒãƒ‡ãƒ¼ã‚¿è§£æ â†’</a></strong></p>
<hr />
<h2>æ¼”ç¿’å•é¡Œ</h2>
<h3>å•é¡Œ1ï¼ˆé›£æ˜“åº¦ï¼šeasyï¼‰</h3>
<p>æ¬¡ã®æ–‡ç« ã®æ­£èª¤ã‚’åˆ¤å®šã—ã¦ãã ã•ã„ã€‚</p>
<ol>
<li>SNIPæ³•ã¯å¤šé …å¼ãƒ•ã‚£ãƒƒãƒ†ã‚£ãƒ³ã‚°ã‚ˆã‚Šã‚‚ãƒ”ãƒ¼ã‚¯ã®å½±éŸ¿ã‚’å—ã‘ã«ãã„</li>
<li>XPSã‚¹ãƒšã‚¯ãƒˆãƒ«ã«ã¯ç·šå½¢ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ãŒé©ã—ã¦ã„ã‚‹</li>
<li>ãƒ”ãƒ¼ã‚¯æ¤œå‡ºã®prominenceãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¯ã€ãƒ”ãƒ¼ã‚¯é–“ã®æœ€å°è·é›¢ã‚’æŒ‡å®šã™ã‚‹</li>
</ol>
<details>
<summary>ãƒ’ãƒ³ãƒˆ</summary>

1. SNIPæ³•ã®å‹•ä½œåŸç†ï¼ˆãƒ”ãƒ¼ã‚¯ã‚¯ãƒªãƒƒãƒ”ãƒ³ã‚°ï¼‰ã‚’è€ƒãˆã‚‹
2. XPSã®ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã¯éå¼¾æ€§æ•£ä¹±ã«èµ·å› ã™ã‚‹
3. prominenceã€distanceã€widthãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®æ„å‘³ã‚’ç¢ºèª

</details>

<details>
<summary>è§£ç­”ä¾‹</summary>

**è§£ç­”**:
1. **æ­£** - SNIPæ³•ã¯ãƒ”ãƒ¼ã‚¯ã‚’é¿ã‘ã¦ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã‚’æ¨å®šã™ã‚‹ãŸã‚ã€å¤šé …å¼ã‚ˆã‚Šãƒ­ãƒã‚¹ãƒˆ
2. **èª¤** - XPSã¯ã‚·ãƒ£ãƒ¼ãƒªãƒ¼å‹ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ãŒé©åˆ‡ï¼ˆéå¼¾æ€§æ•£ä¹±ã«ã‚ˆã‚‹éå¯¾ç§°å½¢çŠ¶ï¼‰
3. **èª¤** - prominenceã¯å“è¶Šåº¦ï¼ˆå‘¨å›²ã¨ã®é«˜ä½å·®ï¼‰ã€ãƒ”ãƒ¼ã‚¯é–“è·é›¢ã¯distanceãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿

**è§£èª¬**:
ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰é™¤å»æ‰‹æ³•ã®é¸æŠã¯æ¸¬å®šåŸç†ã«åŸºã¥ãã“ã¨ãŒé‡è¦ã§ã™ã€‚XPSã®éå¼¾æ€§æ•£ä¹±ã€Ramanã®è›å…‰ã€XRDã®éæ™¶è³ªãƒãƒ­ãƒ¼ãªã©ã€ãã‚Œãã‚Œç•°ãªã‚‹ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰å½¢çŠ¶ã‚’æŒã¡ã¾ã™ã€‚

</details>

<hr />
<h3>å•é¡Œ2ï¼ˆé›£æ˜“åº¦ï¼šmediumï¼‰</h3>
<p>ä»¥ä¸‹ã®XRDãƒ‡ãƒ¼ã‚¿ã«å¯¾ã—ã¦ã€SNIPæ³•ã§ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰é™¤å»ã‚’è¡Œã„ã€ãƒ”ãƒ¼ã‚¯ã‚’æ¤œå‡ºã—ã¦ãã ã•ã„ã€‚</p>
<pre><code class="language-python">import numpy as np

# ã‚µãƒ³ãƒ—ãƒ«XRDãƒ‡ãƒ¼ã‚¿
np.random.seed(123)
two_theta = np.linspace(15, 75, 600)
intensity = (
    1200 * np.exp(-((two_theta - 26.6) ** 2) / 12) +
    1800 * np.exp(-((two_theta - 33.8) ** 2) / 10) +
    1000 * np.exp(-((two_theta - 54.8) ** 2) / 15) +
    150 + 50 * np.sin(two_theta / 8) +
    np.random.normal(0, 40, len(two_theta))
)
</code></pre>
<p><strong>è¦æ±‚äº‹é …</strong>:
1. SNIPæ³•ã§ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰é™¤å»ï¼ˆiterations=40ï¼‰
2. ãƒ”ãƒ¼ã‚¯æ¤œå‡ºï¼ˆprominence=100ï¼‰
3. æ¤œå‡ºã•ã‚ŒãŸãƒ”ãƒ¼ã‚¯ä½ç½®ã¨å¼·åº¦ã‚’å‡ºåŠ›
4. å‡¦ç†å‰å¾Œã®ã‚¹ãƒšã‚¯ãƒˆãƒ«ã‚’å¯è¦–åŒ–</p>
<details>
<summary>ãƒ’ãƒ³ãƒˆ</summary>

**å‡¦ç†ãƒ•ãƒ­ãƒ¼**:
1. SNIPé–¢æ•°ã‚’å®šç¾©ã¾ãŸã¯å†åˆ©ç”¨
2. ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰æ¸›ç®—
3. `find_peaks`ã§ãƒ”ãƒ¼ã‚¯æ¤œå‡º
4. çµæœã‚’æ•´ç†ã—ã¦å‡ºåŠ›
5. `matplotlib`ã§3æ®µéšï¼ˆå…ƒãƒ‡ãƒ¼ã‚¿ã€ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã€è£œæ­£å¾Œï¼‰ã‚’å¯è¦–åŒ–

</details>

<details>
<summary>è§£ç­”ä¾‹</summary>


<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import find_peaks

# SNIPé–¢æ•°ï¼ˆã‚³ãƒ¼ãƒ‰ä¾‹2ã‚ˆã‚Šï¼‰
def snip_background(spectrum, iterations=30):
    spectrum = np.array(spectrum, dtype=float)
    background = np.copy(spectrum)

    for i in range(1, iterations + 1):
        for j in range(i, len(background) - i):
            v1 = (background[j - i] + background[j + i]) / 2
            v2 = background[j]
            background[j] = min(v1, v2)

    return background

# ã‚µãƒ³ãƒ—ãƒ«ãƒ‡ãƒ¼ã‚¿
np.random.seed(123)
two_theta = np.linspace(15, 75, 600)
intensity = (
    1200 * np.exp(-((two_theta - 26.6) ** 2) / 12) +
    1800 * np.exp(-((two_theta - 33.8) ** 2) / 10) +
    1000 * np.exp(-((two_theta - 54.8) ** 2) / 15) +
    150 + 50 * np.sin(two_theta / 8) +
    np.random.normal(0, 40, len(two_theta))
)

# SNIPæ³•é©ç”¨
bg = snip_background(intensity, iterations=40)
intensity_corrected = intensity - bg

# ãƒ”ãƒ¼ã‚¯æ¤œå‡º
peaks_idx, _ = find_peaks(intensity_corrected, prominence=100)
peak_positions = two_theta[peaks_idx]
peak_intensities = intensity_corrected[peaks_idx]

# çµæœå‡ºåŠ›
print(&quot;=== ãƒ”ãƒ¼ã‚¯æ¤œå‡ºçµæœ ===&quot;)
for i, (pos, intens) in enumerate(zip(peak_positions,
                                       peak_intensities), 1):
    print(f&quot;ãƒ”ãƒ¼ã‚¯ {i}: 2Î¸ = {pos:.2f}Â°, å¼·åº¦ = {intens:.1f}&quot;)

# å¯è¦–åŒ–
fig, axes = plt.subplots(1, 3, figsize=(16, 5))

axes[0].plot(two_theta, intensity, linewidth=1.5)
axes[0].set_xlabel('2Î¸ (degree)')
axes[0].set_ylabel('Intensity')
axes[0].set_title('Raw XRD Pattern')
axes[0].grid(True, alpha=0.3)

axes[1].plot(two_theta, intensity, label='Raw', alpha=0.6)
axes[1].plot(two_theta, bg, label='SNIP background',
             linewidth=2, color='red')
axes[1].set_xlabel('2Î¸ (degree)')
axes[1].set_ylabel('Intensity')
axes[1].set_title('Background Estimation')
axes[1].legend()
axes[1].grid(True, alpha=0.3)

axes[2].plot(two_theta, intensity_corrected, linewidth=1.5)
axes[2].plot(peak_positions, peak_intensities, 'rx',
             markersize=12, markeredgewidth=2)
axes[2].set_xlabel('2Î¸ (degree)')
axes[2].set_ylabel('Intensity')
axes[2].set_title('After Background Subtraction + Peak Detection')
axes[2].grid(True, alpha=0.3)

plt.tight_layout()
plt.show()
</code></pre>


**å‡ºåŠ›**:

<pre><code>=== ãƒ”ãƒ¼ã‚¯æ¤œå‡ºçµæœ ===
ãƒ”ãƒ¼ã‚¯ 1: 2Î¸ = 26.59Â°, å¼·åº¦ = 1205.3
ãƒ”ãƒ¼ã‚¯ 2: 2Î¸ = 33.81Â°, å¼·åº¦ = 1813.7
ãƒ”ãƒ¼ã‚¯ 3: 2Î¸ = 54.76Â°, å¼·åº¦ = 1008.2
</code></pre>


**è§£èª¬**:
SNIPæ³•ã®iterations=40ã¯ã€ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã®ç‰¹å¾´çš„ãªå¹…ï¼ˆãƒ‡ãƒ¼ã‚¿ç‚¹æ•°ï¼‰ã«å¯¾å¿œã—ã¾ã™ã€‚ã“ã®ä¾‹ã§ã¯ç·©ã‚„ã‹ãªãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã®ãŸã‚ã€40ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã§ååˆ†ã§ã™ã€‚prominence=100ã«ã‚ˆã‚Šã€ãƒã‚¤ã‚ºãƒ”ãƒ¼ã‚¯ã‚’é™¤å¤–ã—ã€ä¸»è¦ãª3ãƒ”ãƒ¼ã‚¯ã®ã¿ã‚’æ¤œå‡ºã§ãã¾ã—ãŸã€‚

</details>

<hr />
<h3>å•é¡Œ3ï¼ˆé›£æ˜“åº¦ï¼šhardï¼‰</h3>
<p>è¤‡æ•°ã®æ¸¬å®šæŠ€è¡“ï¼ˆXRDã€XPSã€Ramanï¼‰ã®ã‚¹ãƒšã‚¯ãƒˆãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’è‡ªå‹•å‡¦ç†ã™ã‚‹ãƒãƒƒãƒã‚·ã‚¹ãƒ†ãƒ ã‚’æ§‹ç¯‰ã—ã¦ãã ã•ã„ã€‚</p>
<p><strong>èƒŒæ™¯</strong>:
ææ–™ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ¼ã‹ã‚‰100ã‚µãƒ³ãƒ—ãƒ«ã®è¤‡åˆæ¸¬å®šãƒ‡ãƒ¼ã‚¿ï¼ˆXRDã€XPSã€Ramanï¼‰ãŒå¾—ã‚‰ã‚Œã¾ã—ãŸã€‚å„æ¸¬å®šã«ã¤ã„ã¦é©åˆ‡ãªå‰å‡¦ç†ã‚’è‡ªå‹•é¸æŠã—ã€ãƒ”ãƒ¼ã‚¯æƒ…å ±ã‚’æŠ½å‡ºã™ã‚‹çµ±åˆã‚·ã‚¹ãƒ†ãƒ ãŒå¿…è¦ã§ã™ã€‚</p>
<p><strong>èª²é¡Œ</strong>:
1. æ¸¬å®šæŠ€è¡“ã«å¿œã˜ãŸæœ€é©ãªãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰é™¤å»æ‰‹æ³•ã®è‡ªå‹•é¸æŠ
2. ãƒ”ãƒ¼ã‚¯æ¤œå‡ºãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®è‡ªå‹•èª¿æ•´
3. çµæœã‚’JSONå½¢å¼ã§ä¿å­˜
4. ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã¨ãƒ­ã‚°å‡ºåŠ›</p>
<p><strong>åˆ¶ç´„æ¡ä»¶</strong>:
- å„æ¸¬å®šæŠ€è¡“ã§ç•°ãªã‚‹ãƒ‡ãƒ¼ã‚¿å½¢å¼ï¼ˆåˆ—åã€å˜ä½ï¼‰
- æ¸¬å®šå“è³ªã®ã°ã‚‰ã¤ãï¼ˆãƒã‚¤ã‚ºãƒ¬ãƒ™ãƒ«ï¼‰
- å‡¦ç†æ™‚é–“ï¼š10ç§’ä»¥å†…/ã‚µãƒ³ãƒ—ãƒ«</p>
<details>
<summary>ãƒ’ãƒ³ãƒˆ</summary>

**è¨­è¨ˆæ–¹é‡**:
1. `SpectrumAnalyzer`ã‚¯ãƒ©ã‚¹ã‚’æ‹¡å¼µ
2. æ¸¬å®šæŠ€è¡“ã®è‡ªå‹•åˆ¤å®šï¼ˆãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã¾ãŸã¯ãƒ•ã‚¡ã‚¤ãƒ«åã‹ã‚‰ï¼‰
3. é©å¿œçš„ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿èª¿æ•´ï¼ˆãƒã‚¤ã‚ºãƒ¬ãƒ™ãƒ«ã«å¿œã˜ã¦prominenceèª¿æ•´ï¼‰
4. JSONå‡ºåŠ›ã«ã¯ãƒ”ãƒ¼ã‚¯ä½ç½®ã€å¼·åº¦ã€æ¨å®šç›¸æƒ…å ±ã‚’å«ã‚ã‚‹

**ã‚¯ãƒ©ã‚¹è¨­è¨ˆä¾‹**:

<pre><code class="language-python">class AutoSpectrumProcessor:
    def __init__(self):
        self.analyzers = {}  # æ¸¬å®šæŠ€è¡“ã”ã¨ã®analyzer

    def detect_spectrum_type(self, data):
        # ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰æ¸¬å®šæŠ€è¡“ã‚’åˆ¤å®š
        pass

    def adaptive_parameters(self, spectrum):
        # ãƒã‚¤ã‚ºãƒ¬ãƒ™ãƒ«ã«å¿œã˜ã¦ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿èª¿æ•´
        pass

    def batch_process(self, file_list):
        # è¤‡æ•°ãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç†
        pass
</code></pre>


</details>

<details>
<summary>è§£ç­”ä¾‹</summary>

**è§£ç­”ã®æ¦‚è¦**:
æ¸¬å®šæŠ€è¡“ã®è‡ªå‹•åˆ¤å®šã€é©å¿œçš„ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿èª¿æ•´ã€çµæœã®JSONä¿å­˜ã‚’å«ã‚€çµ±åˆå‡¦ç†ã‚·ã‚¹ãƒ†ãƒ ã‚’æ§‹ç¯‰ã—ã¾ã™ã€‚

**å®Ÿè£…ã‚³ãƒ¼ãƒ‰**:


<pre><code class="language-python">import json
import logging
from pathlib import Path
from typing import Dict, List
from dataclasses import dataclass, asdict

logging.basicConfig(level=logging.INFO)

@dataclass
class SpectrumResult:
    &quot;&quot;&quot;è§£æçµæœã‚’æ ¼ç´&quot;&quot;&quot;
    spectrum_type: str
    num_peaks: int
    peaks: List[Dict]
    processing_time: float
    background_method: str

class AutoSpectrumProcessor:
    &quot;&quot;&quot;è‡ªå‹•ã‚¹ãƒšã‚¯ãƒˆãƒ«è§£æã‚·ã‚¹ãƒ†ãƒ &quot;&quot;&quot;

    def __init__(self):
        self.bg_methods = {
            'XRD': 'snip',
            'XPS': 'shirley',
            'Raman': 'als',
            'IR': 'als'
        }

    def detect_spectrum_type(self, x: np.ndarray) -&gt; str:
        &quot;&quot;&quot;
        ãƒ‡ãƒ¼ã‚¿ç¯„å›²ã‹ã‚‰æ¸¬å®šæŠ€è¡“ã‚’æ¨å®š
        &quot;&quot;&quot;
        x_range = x.max() - x.min()
        x_min = x.min()

        if x_min &gt; 5 and x_range &lt; 100:  # 2Î¸ç¯„å›²
            return 'XRD'
        elif x_min &gt; 200 and x_range &gt; 500:  # BEç¯„å›²
            return 'XPS'
        elif x_min &gt; 100 and x_range &gt; 1000:  # cm-1ç¯„å›²
            return 'Raman' if x.max() &lt; 4000 else 'IR'
        else:
            return 'Unknown'

    def adaptive_prominence(self, spectrum: np.ndarray) -&gt; float:
        &quot;&quot;&quot;
        ãƒã‚¤ã‚ºãƒ¬ãƒ™ãƒ«ã«å¿œã˜ã¦prominenceèª¿æ•´
        &quot;&quot;&quot;
        noise_std = np.std(np.diff(spectrum))
        snr = np.max(spectrum) / (noise_std + 1e-10)

        if snr &gt; 50:
            return 0.05 * np.max(spectrum)  # é«˜S/N
        elif snr &gt; 20:
            return 0.08 * np.max(spectrum)  # ä¸­S/N
        else:
            return 0.12 * np.max(spectrum)  # ä½S/N

    def process_spectrum(self, x: np.ndarray, y: np.ndarray,
                        metadata: Dict = None) -&gt; SpectrumResult:
        &quot;&quot;&quot;
        å˜ä¸€ã‚¹ãƒšã‚¯ãƒˆãƒ«ã®å‡¦ç†
        &quot;&quot;&quot;
        import time
        start_time = time.time()

        # æ¸¬å®šæŠ€è¡“ã®åˆ¤å®š
        if metadata and 'type' in metadata:
            spec_type = metadata['type']
        else:
            spec_type = self.detect_spectrum_type(x)

        logging.info(f&quot;Detected spectrum type: {spec_type}&quot;)

        # ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰é™¤å»
        bg_method = self.bg_methods.get(spec_type, 'snip')

        if bg_method == 'snip':
            bg = snip_background(y, iterations=40)
        elif bg_method == 'als':
            bg = als_baseline(y, lam=1e6, p=0.01)
        else:
            # ç°¡æ˜“ç·šå½¢ï¼ˆshirleyæœªå®Ÿè£…ã®å ´åˆï¼‰
            bg = np.linspace(y[0], y[-1], len(y))

        y_corrected = y - bg

        # é©å¿œçš„ãƒ”ãƒ¼ã‚¯æ¤œå‡º
        prominence = self.adaptive_prominence(y_corrected)
        peaks_idx, _ = find_peaks(y_corrected, prominence=prominence)

        # ãƒ”ãƒ¼ã‚¯æƒ…å ±ã‚’æ§‹é€ åŒ–
        peaks_info = []
        for idx in peaks_idx:
            peaks_info.append({
                'position': float(x[idx]),
                'intensity': float(y_corrected[idx]),
                'unit': '2Î¸(deg)' if spec_type == 'XRD' else 'cm-1'
            })

        processing_time = time.time() - start_time

        result = SpectrumResult(
            spectrum_type=spec_type,
            num_peaks=len(peaks_idx),
            peaks=peaks_info,
            processing_time=processing_time,
            background_method=bg_method
        )

        return result

    def batch_process(self, data_list: List[Dict],
                     output_file: str = 'results.json'):
        &quot;&quot;&quot;
        ãƒãƒƒãƒå‡¦ç†

        Parameters:
        -----------
        data_list : list of dict
            å„è¦ç´ ã¯ {'x': array, 'y': array, 'metadata': dict}
        &quot;&quot;&quot;
        results = []

        for i, data in enumerate(data_list, 1):
            try:
                logging.info(f&quot;Processing spectrum {i}/{len(data_list)}&quot;)
                result = self.process_spectrum(
                    data['x'],
                    data['y'],
                    data.get('metadata')
                )
                results.append(asdict(result))

            except Exception as e:
                logging.error(f&quot;Failed to process spectrum {i}: {e}&quot;)
                continue

        # JSONä¿å­˜
        with open(output_file, 'w') as f:
            json.dump(results, f, indent=2)

        logging.info(f&quot;Results saved to {output_file}&quot;)
        return results

# ãƒ‡ãƒ¢å®Ÿè¡Œ
if __name__ == &quot;__main__&quot;:
    processor = AutoSpectrumProcessor()

    # ã‚µãƒ³ãƒ—ãƒ«ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆï¼ˆ3ç¨®é¡ã®æ¸¬å®šï¼‰
    data_list = []

    # XRDãƒ‡ãƒ¼ã‚¿
    two_theta = np.linspace(20, 60, 400)
    xrd_y = (
        1000 * np.exp(-((two_theta - 28) ** 2) / 10) +
        1500 * np.exp(-((two_theta - 35) ** 2) / 8) +
        100 + np.random.normal(0, 30, len(two_theta))
    )
    data_list.append({
        'x': two_theta,
        'y': xrd_y,
        'metadata': {'type': 'XRD', 'sample': 'Fe2O3'}
    })

    # Ramanãƒ‡ãƒ¼ã‚¿
    raman_shift = np.linspace(200, 2000, 900)
    raman_y = (
        2000 * np.exp(-((raman_shift - 520) ** 2) / 100) +
        1500 * np.exp(-((raman_shift - 950) ** 2) / 150) +
        500 + np.random.normal(0, 50, len(raman_shift))
    )
    data_list.append({
        'x': raman_shift,
        'y': raman_y,
        'metadata': {'type': 'Raman', 'sample': 'Si'}
    })

    # ãƒãƒƒãƒå‡¦ç†å®Ÿè¡Œ
    results = processor.batch_process(data_list,
                                      output_file='spectrum_results.json')

    print(&quot;\n=== Processing Summary ===&quot;)
    for i, result in enumerate(results, 1):
        print(f&quot;Spectrum {i}:&quot;)
        print(f&quot;  Type: {result['spectrum_type']}&quot;)
        print(f&quot;  Peaks detected: {result['num_peaks']}&quot;)
        print(f&quot;  Processing time: {result['processing_time']:.3f}s&quot;)
</code></pre>


**çµæœï¼ˆJSONå‡ºåŠ›ä¾‹ï¼‰**:

<pre><code class="language-json">[
  {
    &quot;spectrum_type&quot;: &quot;XRD&quot;,
    &quot;num_peaks&quot;: 2,
    &quot;peaks&quot;: [
      {&quot;position&quot;: 28.05, &quot;intensity&quot;: 1023.4, &quot;unit&quot;: &quot;2Î¸(deg)&quot;},
      {&quot;position&quot;: 35.01, &quot;intensity&quot;: 1518.7, &quot;unit&quot;: &quot;2Î¸(deg)&quot;}
    ],
    &quot;processing_time&quot;: 0.045,
    &quot;background_method&quot;: &quot;snip&quot;
  },
  {
    &quot;spectrum_type&quot;: &quot;Raman&quot;,
    &quot;num_peaks&quot;: 2,
    &quot;peaks&quot;: [
      {&quot;position&quot;: 520.3, &quot;intensity&quot;: 2015.6, &quot;unit&quot;: &quot;cm-1&quot;},
      {&quot;position&quot;: 949.8, &quot;intensity&quot;: 1507.2, &quot;unit&quot;: &quot;cm-1&quot;}
    ],
    &quot;processing_time&quot;: 0.052,
    &quot;background_method&quot;: &quot;als&quot;
  }
]
</code></pre>


**è©³ç´°ãªè§£èª¬**:
1. **è‡ªå‹•åˆ¤å®š**: ãƒ‡ãƒ¼ã‚¿ç¯„å›²ã‹ã‚‰æ¸¬å®šæŠ€è¡“ã‚’æ¨å®šï¼ˆXRD: 10-80Â°ã€Raman: 200-2000 cmâ»Â¹ï¼‰
2. **é©å¿œçš„ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿**: S/Næ¯”ã‹ã‚‰prominenceã‚’è‡ªå‹•èª¿æ•´
3. **æ§‹é€ åŒ–å‡ºåŠ›**: JSONå½¢å¼ã§å¾Œç¶šè§£æã‚„ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ç™»éŒ²ã«å¯¾å¿œ
4. **ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°**: å€‹åˆ¥ã‚¹ãƒšã‚¯ãƒˆãƒ«ã®å¤±æ•—ãŒãƒãƒƒãƒå…¨ä½“ã‚’åœæ­¢ã•ã›ãªã„

**è¿½åŠ ã®æ¤œè¨äº‹é …**:
- æ¸¬å®šæŠ€è¡“ã®åˆ¤å®šç²¾åº¦å‘ä¸Šï¼ˆæ©Ÿæ¢°å­¦ç¿’åˆ†é¡å™¨ã®å°å…¥ï¼‰
- ã‚¯ãƒ©ã‚¦ãƒ‰ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ï¼ˆS3ã€GCSï¼‰ã‹ã‚‰ã®ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿
- Webãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ã§ã®ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ å¯è¦–åŒ–
- ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ï¼ˆMongoDBï¼‰ã¸ã®çµæœä¿å­˜

</details>

<hr />
<h2>å‚è€ƒæ–‡çŒ®</h2>
<ol>
<li>
<p>Pecharsky, V. K., &amp; Zavalij, P. Y. (2009). "Fundamentals of Powder Diffraction and Structural Characterization of Materials." Springer. ISBN: 978-0387095783</p>
</li>
<li>
<p>Briggs, D., &amp; Seah, M. P. (1990). "Practical Surface Analysis by Auger and X-ray Photoelectron Spectroscopy." Wiley. ISBN: 978-0471920816</p>
</li>
<li>
<p>Ryan, C. G. et al. (1988). "SNIP, a statistics-sensitive background treatment for the quantitative analysis of PIXE spectra in geoscience applications." <em>Nuclear Instruments and Methods in Physics Research B</em>, 34(3), 396-402. DOI: <a href="https://doi.org/10.1016/0168-583X(88)90063-8">10.1016/0168-583X(88)90063-8</a></p>
</li>
<li>
<p>Eilers, P. H. C., &amp; Boelens, H. F. M. (2005). "Baseline Correction with Asymmetric Least Squares Smoothing." <em>Leiden University Medical Centre Report</em>.</p>
</li>
<li>
<p>SciPy Documentation: Signal Processing. URL: <a href="https://docs.scipy.org/doc/scipy/reference/signal.html">https://docs.scipy.org/doc/scipy/reference/signal.html</a></p>
</li>
</ol>
<hr />
<h2>ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³</h2>
<h3>å‰ã®ç« </h3>
<p><strong><a href="./chapter-1.html">ç¬¬1ç« ï¼šå®Ÿé¨“ãƒ‡ãƒ¼ã‚¿è§£æã®åŸºç¤ â†</a></strong></p>
<h3>æ¬¡ã®ç« </h3>
<p><strong><a href="./chapter-3.html">ç¬¬3ç« ï¼šç”»åƒãƒ‡ãƒ¼ã‚¿è§£æ â†’</a></strong></p>
<h3>ã‚·ãƒªãƒ¼ã‚ºç›®æ¬¡</h3>
<p><strong><a href="./index.html">â† ã‚·ãƒªãƒ¼ã‚ºç›®æ¬¡ã«æˆ»ã‚‹</a></strong></p>
<hr />
<h2>è‘—è€…æƒ…å ±</h2>
<p><strong>ä½œæˆè€…</strong>: AI Terakoya Content Team
<strong>ä½œæˆæ—¥</strong>: 2025-10-17
<strong>ãƒãƒ¼ã‚¸ãƒ§ãƒ³</strong>: 1.0</p>
<p><strong>æ›´æ–°å±¥æ­´</strong>:
- 2025-10-17: v1.0 åˆç‰ˆå…¬é–‹</p>
<p><strong>ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯</strong>:
- GitHub Issues: [ãƒªãƒã‚¸ãƒˆãƒªURL]/issues
- Email: yusuke.hashimoto.b8@tohoku.ac.jp</p>
<p><strong>ãƒ©ã‚¤ã‚»ãƒ³ã‚¹</strong>: Creative Commons BY 4.0</p>
<hr />
<p><strong>æ¬¡ã®ç« ã§å­¦ç¿’ã‚’ç¶šã‘ã¾ã—ã‚‡ã†ï¼</strong></p><div class="navigation">
    <a href="chapter-1.html" class="nav-button">â† å‰ã®ç« </a>
    <a href="index.html" class="nav-button">ã‚·ãƒªãƒ¼ã‚ºç›®æ¬¡ã«æˆ»ã‚‹</a>
    <a href="chapter-3.html" class="nav-button">æ¬¡ã®ç«  â†’</a>
</div>
    </main>

    
    <section class="disclaimer">
        <h3>å…è²¬äº‹é …</h3>
        <ul>
            <li>æœ¬ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã¯æ•™è‚²ãƒ»ç ”ç©¶ãƒ»æƒ…å ±æä¾›ã®ã¿ã‚’ç›®çš„ã¨ã—ã¦ãŠã‚Šã€å°‚é–€çš„ãªåŠ©è¨€(æ³•å¾‹ãƒ»ä¼šè¨ˆãƒ»æŠ€è¡“çš„ä¿è¨¼ãªã©)ã‚’æä¾›ã™ã‚‹ã‚‚ã®ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚</li>
            <li>æœ¬ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãŠã‚ˆã³ä»˜éšã™ã‚‹ã‚³ãƒ¼ãƒ‰ä¾‹ã¯ã€Œç¾çŠ¶æœ‰å§¿(AS IS)ã€ã§æä¾›ã•ã‚Œã€æ˜ç¤ºã¾ãŸã¯é»™ç¤ºã‚’å•ã‚ãšã€å•†å“æ€§ã€ç‰¹å®šç›®çš„é©åˆæ€§ã€æ¨©åˆ©éä¾µå®³ã€æ­£ç¢ºæ€§ãƒ»å®Œå…¨æ€§ã€å‹•ä½œãƒ»å®‰å…¨æ€§ç­‰ã„ã‹ãªã‚‹ä¿è¨¼ã‚‚ã—ã¾ã›ã‚“ã€‚</li>
            <li>å¤–éƒ¨ãƒªãƒ³ã‚¯ã€ç¬¬ä¸‰è€…ãŒæä¾›ã™ã‚‹ãƒ‡ãƒ¼ã‚¿ãƒ»ãƒ„ãƒ¼ãƒ«ãƒ»ãƒ©ã‚¤ãƒ–ãƒ©ãƒªç­‰ã®å†…å®¹ãƒ»å¯ç”¨æ€§ãƒ»å®‰å…¨æ€§ã«ã¤ã„ã¦ã€ä½œæˆè€…ãŠã‚ˆã³æ±åŒ—å¤§å­¦ã¯ä¸€åˆ‡ã®è²¬ä»»ã‚’è² ã„ã¾ã›ã‚“ã€‚</li>
            <li>æœ¬ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®åˆ©ç”¨ãƒ»å®Ÿè¡Œãƒ»è§£é‡ˆã«ã‚ˆã‚Šç›´æ¥çš„ãƒ»é–“æ¥çš„ãƒ»ä»˜éšçš„ãƒ»ç‰¹åˆ¥ãƒ»çµæœçš„ãƒ»æ‡²ç½°çš„æå®³ãŒç”Ÿã˜ãŸå ´åˆã§ã‚‚ã€é©ç”¨æ³•ã§è¨±å®¹ã•ã‚Œã‚‹æœ€å¤§é™ã®ç¯„å›²ã§ã€ä½œæˆè€…ãŠã‚ˆã³æ±åŒ—å¤§å­¦ã¯è²¬ä»»ã‚’è² ã„ã¾ã›ã‚“ã€‚</li>
            <li>æœ¬ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®å†…å®¹ã¯ã€äºˆå‘Šãªãå¤‰æ›´ãƒ»æ›´æ–°ãƒ»æä¾›åœæ­¢ã•ã‚Œã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚</li>
            <li>æœ¬ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®è‘—ä½œæ¨©ãƒ»ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã¯æ˜è¨˜ã•ã‚ŒãŸæ¡ä»¶(ä¾‹: CC BY 4.0)ã«å¾“ã„ã¾ã™ã€‚å½“è©²ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã¯é€šå¸¸ã€ç„¡ä¿è¨¼æ¡é …ã‚’å«ã¿ã¾ã™ã€‚</li>
        </ul>
    </section>

<footer>
        <p><strong>ä½œæˆè€…</strong>: AI Terakoya Content Team</p>
        <p><strong>ãƒãƒ¼ã‚¸ãƒ§ãƒ³</strong>: 1.0 | <strong>ä½œæˆæ—¥</strong>: 2025-10-17</p>
        <p><strong>ãƒ©ã‚¤ã‚»ãƒ³ã‚¹</strong>: Creative Commons BY 4.0</p>
        <p>Â© 2025 AI Terakoya. All rights reserved.</p>
    </footer>
</body>
</html>
