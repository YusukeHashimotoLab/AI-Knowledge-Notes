---
title: "ç¬¬5ç« : é‡å­åŒ–å­¦è¨ˆç®—ã®å®Ÿè·µ"
chapter_title: "ç¬¬5ç« : é‡å­åŒ–å­¦è¨ˆç®—ã®å®Ÿè·µ"
subtitle: Practical Quantum Chemistry Calculations
---

[AIå¯ºå­å±‹ãƒˆãƒƒãƒ—](<../../index.html>)â€º[ãƒãƒ†ãƒªã‚¢ãƒ«ã‚ºãƒ»ã‚¤ãƒ³ãƒ•ã‚©ãƒãƒ†ã‚£ã‚¯ã‚¹](<../../MI/index.html>)â€º[Quantum Chemistry](<../../MI/quantum-chemistry-introduction/index.html>)â€ºChapter 5

â† ç¬¬4ç« : å¯†åº¦æ±é–¢æ•°ç†è«–ï¼ˆæº–å‚™ä¸­ï¼‰ [ç›®æ¬¡ã«æˆ»ã‚‹](<index.html>)

## 5.1 PySCFã«ã‚ˆã‚‹åˆ†å­è¨ˆç®—

### ğŸ“š PySCFã¨ã¯

**PySCF (Python-based Simulations of Chemistry Framework)** ã¯ã€é‡å­åŒ–å­¦è¨ˆç®—ã®ãŸã‚ã®ã‚ªãƒ¼ãƒ—ãƒ³ã‚½ãƒ¼ã‚¹Pythonãƒ©ã‚¤ãƒ–ãƒ©ãƒªã§ã™ã€‚

  * **Hartree-Fockæ³•** : RHF, UHF, ROHF
  * **DFT** : å¤šæ§˜ãªäº¤æ›ç›¸é–¢æ±é–¢æ•°ï¼ˆLDA, GGA, hybridï¼‰
  * **Post-HFæ³•** : MP2, CCSD, CI
  * **åŠ±èµ·çŠ¶æ…‹** : TD-DFT, EOM-CCSD
  * **å›ºä½“è¨ˆç®—** : PBC (Periodic Boundary Conditions)

### æ°´åˆ†å­ã®Hartree-Fockè¨ˆç®—

PySCFã§æ°´åˆ†å­ï¼ˆHâ‚‚Oï¼‰ã®ã‚¨ãƒãƒ«ã‚®ãƒ¼ã¨åˆ†å­è»Œé“ã‚’è¨ˆç®—ã—ã¾ã™ã€‚

import numpy as np import matplotlib.pyplot as plt from scipy.linalg import eigh # PySCFäº’æ›ã®ãƒŸãƒ‹ãƒãƒ«å®Ÿè£…ï¼ˆãƒ‡ãƒ¢ç”¨ï¼‰ class WaterMoleculeHF: """æ°´åˆ†å­ã®Hartree-Fockè¨ˆç®—ï¼ˆç°¡æ˜“ç‰ˆï¼‰""" def __init__(self, basis='sto-3g'): # æ°´åˆ†å­ã®æ§‹é€ ï¼ˆO-Hè·é›¢0.96Ã…, H-O-Hè§’104.5Â°ï¼‰ self.atoms = [ ('O', [0.0, 0.0, 0.0]), ('H', [0.0, 0.757, 0.587]), ('H', [0.0, -0.757, 0.587]) ] self.n_electrons = 10 # 8(O) + 1(H) + 1(H) self.n_basis = 7 # STO-3G: O(5) + H(1) + H(1) def compute_integrals(self): """ç©åˆ†è¡Œåˆ—ã®è¨ˆç®—ï¼ˆç°¡æ˜“ç‰ˆï¼‰""" # é‡ãªã‚Šç©åˆ†è¡Œåˆ—ï¼ˆå¯¾è§’åŒ–ã§å˜ä½è¡Œåˆ—ã«è¿‘ã„å½¢ï¼‰ S = np.eye(self.n_basis) for i in range(self.n_basis): for j in range(i+1, self.n_basis): S[i,j] = S[j,i] = 0.2 * np.exp(-0.5 * (i-j)**2) # ã‚³ã‚¢ãƒãƒŸãƒ«ãƒˆãƒ‹ã‚¢ãƒ³ï¼ˆé‹å‹•ã‚¨ãƒãƒ«ã‚®ãƒ¼ + æ ¸-é›»å­å¼•åŠ›ï¼‰ H_core = -np.diag([20.0, 15.0, 15.0, 15.0, 15.0, 7.0, 7.0]) # 2é›»å­ç©åˆ†ï¼ˆç°¡æ˜“ç‰ˆï¼‰ g = np.zeros((self.n_basis, self.n_basis, self.n_basis, self.n_basis)) for i in range(self.n_basis): for j in range(self.n_basis): g[i,i,j,j] = 10.0 / (i+j+2) g[i,j,i,j] = 8.0 / (i+j+3) return S, H_core, g def build_fock(self, P, H_core, g): """Fockè¡Œåˆ—ã®æ§‹ç¯‰""" F = H_core.copy() for i in range(self.n_basis): for j in range(self.n_basis): for k in range(self.n_basis): for l in range(self.n_basis): F[i,j] += P[k,l] * (g[i,j,k,l] - 0.5 * g[i,k,j,l]) return F def run_scf(self, max_iter=30, conv=1e-6): """SCFè¨ˆç®—""" S, H_core, g = self.compute_integrals() # åˆæœŸå¯†åº¦è¡Œåˆ— P = np.zeros((self.n_basis, self.n_basis)) E_old = 0.0 energies = [] for iteration in range(max_iter): # Fockè¡Œåˆ—æ§‹ç¯‰ F = self.build_fock(P, H_core, g) # ä¸€èˆ¬åŒ–å›ºæœ‰å€¤å•é¡Œ epsilon, C = eigh(F, S) # å¯†åº¦è¡Œåˆ—æ›´æ–°ï¼ˆ10é›»å­ = 5å æœ‰è»Œé“ï¼‰ n_occ = self.n_electrons // 2 P_new = 2 * C[:, :n_occ] @ C[:, :n_occ].T # ã‚¨ãƒãƒ«ã‚®ãƒ¼è¨ˆç®— E_elec = np.sum(P_new * (H_core + F)) / 2 E_nuc = 9.0 # æ ¸é–“åç™ºï¼ˆç°¡æ˜“å€¤ï¼‰ E_total = E_elec + E_nuc energies.append(E_total) # åæŸåˆ¤å®š if np.abs(E_total - E_old) < conv: print(f"SCFåæŸ: {iteration+1}åå¾©") break E_old = E_total P = P_new return E_total, epsilon, C, energies # æ°´åˆ†å­ã®HFè¨ˆç®—å®Ÿè¡Œ h2o = WaterMoleculeHF() E_total, epsilon, C, energies = h2o.run_scf() # å¯è¦–åŒ– fig, axes = plt.subplots(2, 2, figsize=(12, 10)) # (1) SCFåæŸ axes[0,0].plot(energies, 'o-', linewidth=2) axes[0,0].set_xlabel('Iteration', fontsize=12) axes[0,0].set_ylabel('Energy (Hartree)', fontsize=12) axes[0,0].set_title('SCF Convergence', fontsize=14, fontweight='bold') axes[0,0].grid(True, alpha=0.3) # (2) è»Œé“ã‚¨ãƒãƒ«ã‚®ãƒ¼æº–ä½ n_occ = h2o.n_electrons // 2 colors = ['blue' if i < n_occ else 'red' for i in range(h2o.n_basis)] axes[0,1].barh(range(h2o.n_basis), epsilon, color=colors, alpha=0.7) axes[0,1].axvline(0, color='black', linestyle='--', alpha=0.5) axes[0,1].set_xlabel('Energy (Hartree)', fontsize=12) axes[0,1].set_ylabel('Orbital Index', fontsize=12) axes[0,1].set_title('Orbital Energy Levels', fontsize=14, fontweight='bold') axes[0,1].legend(['Occupied', 'Virtual'], loc='best') # (3) HOMO-LUMOä¿‚æ•° homo_idx = n_occ - 1 lumo_idx = n_occ x = np.arange(h2o.n_basis) axes[1,0].bar(x - 0.2, C[:, homo_idx], width=0.4, label='HOMO', alpha=0.8) axes[1,0].bar(x + 0.2, C[:, lumo_idx], width=0.4, label='LUMO', alpha=0.8) axes[1,0].set_xlabel('Basis Function', fontsize=12) axes[1,0].set_ylabel('Coefficient', fontsize=12) axes[1,0].set_title('HOMO-LUMO Molecular Orbitals', fontsize=14, fontweight='bold') axes[1,0].legend() axes[1,0].grid(True, alpha=0.3, axis='y') # (4) è¨ˆç®—çµæœã‚µãƒãƒªãƒ¼ axes[1,1].axis('off') summary = f""" Hâ‚‚O Hartree-Fock Calculation Total Energy: {E_total:.6f} Hartree {E_total * 27.211:.2f} eV HOMO Energy: {epsilon[homo_idx]:.6f} Hartree LUMO Energy: {epsilon[lumo_idx]:.6f} Hartree HOMO-LUMO Gap: {(epsilon[lumo_idx] - epsilon[homo_idx]) * 27.211:.2f} eV Basis Set: STO-3G Electrons: {h2o.n_electrons} Basis Funcs: {h2o.n_basis} """ axes[1,1].text(0.1, 0.5, summary, fontsize=11, family='monospace', verticalalignment='center') plt.tight_layout() plt.savefig('water_hf_calculation.png', dpi=150, bbox_inches='tight') plt.show() print(f"Hâ‚‚O Total Energy: {E_total:.6f} Hartree") print(f"HOMO-LUMO Gap: {(epsilon[lumo_idx] - epsilon[homo_idx]) * 27.211:.2f} eV") 

### DFTè¨ˆç®—ã¨ã®æ¯”è¼ƒ

åŒã˜æ°´åˆ†å­ã‚’DFTï¼ˆB3LYPæ±é–¢æ•°ï¼‰ã§è¨ˆç®—ã—ã€HFæ³•ã¨æ¯”è¼ƒã—ã¾ã™ã€‚

class WaterMoleculeDFT(WaterMoleculeHF): """æ°´åˆ†å­ã®DFTè¨ˆç®—ï¼ˆB3LYPç°¡æ˜“ç‰ˆï¼‰""" def __init__(self, functional='b3lyp'): super().__init__() self.functional = functional def xc_energy(self, rho): """äº¤æ›ç›¸é–¢ã‚¨ãƒãƒ«ã‚®ãƒ¼ï¼ˆB3LYPè¿‘ä¼¼ï¼‰""" # LDA exchange C_x = (3/4) * (3/np.pi)**(1/3) E_x_lda = -C_x * rho**(4/3) # GGA correction (gradient approximation) E_x_gga = E_x_lda * (1.0 \+ 0.1 * rho**(1/3)) # B3LYP mixing (20% HF + 80% DFT) E_xc = 0.8 * E_x_gga return E_xc def build_fock_dft(self, P, H_core, g): """Kohn-Sham Fockè¡Œåˆ—""" F = H_core.copy() # Coulomb + Exchange for i in range(self.n_basis): for j in range(self.n_basis): for k in range(self.n_basis): for l in range(self.n_basis): # Coulomb F[i,j] += P[k,l] * g[i,j,k,l] # Exchange (20% HF for B3LYP) F[i,j] -= 0.2 * P[k,l] * g[i,k,j,l] # XC potential (simplified) rho = np.diag(P) V_xc = self.xc_energy(rho + 1e-10) F += np.diag(V_xc) return F def run_dft(self, max_iter=30, conv=1e-6): """DFT-SCFè¨ˆç®—""" S, H_core, g = self.compute_integrals() P = np.zeros((self.n_basis, self.n_basis)) E_old = 0.0 energies = [] for iteration in range(max_iter): F = self.build_fock_dft(P, H_core, g) epsilon, C = eigh(F, S) n_occ = self.n_electrons // 2 P_new = 2 * C[:, :n_occ] @ C[:, :n_occ].T E_elec = np.sum(P_new * (H_core + F)) / 2 E_nuc = 9.0 E_total = E_elec + E_nuc energies.append(E_total) if np.abs(E_total - E_old) < conv: print(f"DFT-SCFåæŸ: {iteration+1}åå¾©") break E_old = E_total P = P_new return E_total, epsilon, C, energies # DFTè¨ˆç®—å®Ÿè¡Œ h2o_dft = WaterMoleculeDFT() E_dft, eps_dft, C_dft, energies_dft = h2o_dft.run_dft() # HF vs DFT æ¯”è¼ƒ print(f"\n=== Hâ‚‚O Energy Comparison ===") print(f"HF Energy: {E_total:.6f} Hartree") print(f"DFT Energy: {E_dft:.6f} Hartree") print(f"Difference: {(E_dft - E_total)*1000:.2f} mHartree") n_occ = h2o.n_electrons // 2 homo_hf = epsilon[n_occ-1] lumo_hf = epsilon[n_occ] homo_dft = eps_dft[n_occ-1] lumo_dft = eps_dft[n_occ] print(f"\nHOMO-LUMO Gap:") print(f"HF: {(lumo_hf - homo_hf)*27.211:.2f} eV") print(f"DFT: {(lumo_dft - homo_dft)*27.211:.2f} eV") 

## 5.2 æ§‹é€ æœ€é©åŒ–ã¨æŒ¯å‹•è§£æ

### ğŸ“š ãƒãƒ†ãƒ³ã‚·ãƒ£ãƒ«ã‚¨ãƒãƒ«ã‚®ãƒ¼æ›²é¢

**æ§‹é€ æœ€é©åŒ–** ã¯ã€ãƒãƒ†ãƒ³ã‚·ãƒ£ãƒ«ã‚¨ãƒãƒ«ã‚®ãƒ¼æ›²é¢ï¼ˆPESï¼‰ä¸Šã§æœ€å°ã‚¨ãƒãƒ«ã‚®ãƒ¼æ§‹é€ ã‚’æ¢ç´¢ã™ã‚‹éç¨‹ã§ã™ã€‚

ã‚¨ãƒãƒ«ã‚®ãƒ¼å‹¾é…:

\\[ \mathbf{g}_I = -\frac{\partial E}{\partial \mathbf{R}_I} \\]

åŠ›ãŒ0ã«ãªã‚‹ç‚¹ï¼ˆ\\(\mathbf{g}_I = 0\\)ï¼‰ãŒå®‰å®šæ§‹é€ ã§ã™ã€‚

### æ°´ç´ åˆ†å­ã®çµåˆè·é›¢æœ€é©åŒ–

Hâ‚‚åˆ†å­ã®çµåˆè·é›¢ã‚’æœ€é©åŒ–ã—ã€å¹³è¡¡æ§‹é€ ã¨ã‚¨ãƒãƒ«ã‚®ãƒ¼ã‚’æ±‚ã‚ã¾ã™ã€‚

from scipy.optimize import minimize def h2_energy(R): """Hâ‚‚åˆ†å­ã®ã‚¨ãƒãƒ«ã‚®ãƒ¼ï¼ˆMorse potentialè¿‘ä¼¼ï¼‰""" D_e = 4.75 # eV alpha = 1.44 # Ã…â»Â¹ R_e = 0.741 # Ã… E = D_e * ((1 \- np.exp(-alpha * (R - R_e)))**2 \- 1) return E def h2_gradient(R): """ã‚¨ãƒãƒ«ã‚®ãƒ¼å‹¾é…""" D_e = 4.75 alpha = 1.44 R_e = 0.741 exp_term = np.exp(-alpha * (R - R_e)) dE_dR = 2 * D_e * alpha * (1 \- exp_term) * exp_term return dE_dR # æ§‹é€ æœ€é©åŒ–ï¼ˆåˆæœŸå€¤: R=1.0Ã…ï¼‰ result = minimize(h2_energy, x0=[1.0], method='BFGS', jac=h2_gradient) R_opt = result.x[0] E_opt = result.fun print(f"æœ€é©åŒ–çµæœ:") print(f" å¹³è¡¡è·é›¢: {R_opt:.4f} Ã…") print(f" çµåˆã‚¨ãƒãƒ«ã‚®ãƒ¼: {E_opt:.4f} eV") # ãƒãƒ†ãƒ³ã‚·ãƒ£ãƒ«æ›²ç·šã¨PES R_range = np.linspace(0.3, 3.0, 100) E_range = [h2_energy(r) for r in R_range] fig, axes = plt.subplots(2, 2, figsize=(12, 10)) # (1) ãƒãƒ†ãƒ³ã‚·ãƒ£ãƒ«ã‚¨ãƒãƒ«ã‚®ãƒ¼æ›²ç·š axes[0,0].plot(R_range, E_range, 'b-', linewidth=2, label='Morse Potential') axes[0,0].plot(R_opt, E_opt, 'ro', markersize=10, label=f'Minimum: {R_opt:.3f}Ã…') axes[0,0].axhline(0, color='k', linestyle='--', alpha=0.3) axes[0,0].set_xlabel('H-H Distance (Ã…)', fontsize=12) axes[0,0].set_ylabel('Energy (eV)', fontsize=12) axes[0,0].set_title('Hâ‚‚ Potential Energy Curve', fontsize=14, fontweight='bold') axes[0,0].legend() axes[0,0].grid(True, alpha=0.3) # (2) ã‚¨ãƒãƒ«ã‚®ãƒ¼å‹¾é… gradient_range = [h2_gradient(r) for r in R_range] axes[0,1].plot(R_range, gradient_range, 'g-', linewidth=2) axes[0,1].axhline(0, color='r', linestyle='--', linewidth=2, label='Zero gradient') axes[0,1].plot(R_opt, 0, 'ro', markersize=10) axes[0,1].set_xlabel('H-H Distance (Ã…)', fontsize=12) axes[0,1].set_ylabel('dE/dR (eV/Ã…)', fontsize=12) axes[0,1].set_title('Energy Gradient', fontsize=14, fontweight='bold') axes[0,1].legend() axes[0,1].grid(True, alpha=0.3) # (3) æŒ¯å‹•ã‚¨ãƒãƒ«ã‚®ãƒ¼æº–ä½ # MorseæŒ¯å‹•å­ã®æº–ä½ omega = 4401.2 # cmâ»Â¹ (Hâ‚‚æŒ¯å‹•æ•°) D_e_cm = D_e * 8065.5 # eV â†’ cmâ»Â¹ n_max = int(D_e_cm / omega) n_levels = np.arange(0, min(n_max, 15)) E_vib = omega * (n_levels + 0.5) - omega**2 * (n_levels + 0.5)**2 / (4 * D_e_cm) axes[1,0].barh(n_levels, E_vib / 8065.5, height=0.8, alpha=0.7) axes[1,0].set_ylabel('Vibrational Quantum Number (n)', fontsize=12) axes[1,0].set_xlabel('Energy (eV)', fontsize=12) axes[1,0].set_title('Vibrational Energy Levels', fontsize=14, fontweight='bold') axes[1,0].grid(True, alpha=0.3, axis='x') # (4) æœ€é©åŒ–ã‚µãƒãƒªãƒ¼ axes[1,1].axis('off') summary = f""" Hâ‚‚ Geometry Optimization Equilibrium Distance: {R_opt:.4f} Ã… Bond Energy: {-E_opt:.4f} eV {-E_opt * 96.485:.1f} kJ/mol Vibrational Frequency: {omega:.1f} cmâ»Â¹ Zero-Point Energy: {E_vib[0] / 8065.5:.4f} eV Optimization Method: BFGS Convergence: {result.success} Iterations: {result.nit} """ axes[1,1].text(0.1, 0.5, summary, fontsize=11, family='monospace', verticalalignment='center') plt.tight_layout() plt.savefig('h2_geometry_optimization.png', dpi=150, bbox_inches='tight') plt.show() 

## 5.3 åŠ±èµ·çŠ¶æ…‹è¨ˆç®—ï¼ˆTD-DFTï¼‰

### ğŸ“š æ™‚é–“ä¾å­˜å¯†åº¦æ±é–¢æ•°ç†è«–

**TD-DFT (Time-Dependent DFT)** ã¯ã€åŠ±èµ·çŠ¶æ…‹ã®é›»å­æ§‹é€ ã‚’è¨ˆç®—ã™ã‚‹æ‰‹æ³•ã§ã™ã€‚

ç·šå½¢å¿œç­”ç†è«–ã«åŸºã¥ãã€åŸºåº•çŠ¶æ…‹ã‹ã‚‰ã®åŠ±èµ·ã‚¨ãƒãƒ«ã‚®ãƒ¼ã‚’æ±‚ã‚ã¾ã™:

\\[ \omega_n = E_n - E_0 \\]

å¸åã‚¹ãƒšã‚¯ãƒˆãƒ«ã€ç™ºå…‰ã‚¹ãƒšã‚¯ãƒˆãƒ«ã€å…‰åŒ–å­¦åå¿œã®è§£æã«ä½¿ã‚ã‚Œã¾ã™ã€‚

### ã‚¨ãƒãƒ¬ãƒ³åˆ†å­ã®åŠ±èµ·çŠ¶æ…‹

ã‚¨ãƒãƒ¬ãƒ³ï¼ˆCâ‚‚Hâ‚„ï¼‰ã®Ï€â†’Ï€*é·ç§»ã‚’è¨ˆç®—ã—ã€ç´«å¤–å¸åã‚¹ãƒšã‚¯ãƒˆãƒ«ã‚’äºˆæ¸¬ã—ã¾ã™ã€‚

class EthyleneTDDFT: """ã‚¨ãƒãƒ¬ãƒ³åˆ†å­ã®TD-DFTè¨ˆç®—ï¼ˆç°¡æ˜“ç‰ˆï¼‰""" def __init__(self): self.n_occ = 6 # å æœ‰è»Œé“æ•° self.n_virt = 4 # ä»®æƒ³è»Œé“æ•° # è»Œé“ã‚¨ãƒãƒ«ã‚®ãƒ¼ï¼ˆå®Ÿé¨“å€¤è¿‘ä¼¼ã€Hartreeå˜ä½ï¼‰ self.epsilon_occ = np.array([-0.8, -0.7, -0.6, -0.5, -0.4, -0.35]) self.epsilon_virt = np.array([0.1, 0.2, 0.3, 0.4]) def compute_excitations(self): """ä¸€é›»å­åŠ±èµ·ã‚¨ãƒãƒ«ã‚®ãƒ¼""" excitations = [] for i, e_occ in enumerate(self.epsilon_occ): for a, e_virt in enumerate(self.epsilon_virt): omega = e_virt - e_occ # æŒ¯å‹•å­å¼·åº¦ï¼ˆç°¡æ˜“è¿‘ä¼¼ï¼‰ f = 0.1 * np.exp(-2 * (i + a)) excitations.append({ 'from': i, 'to': a, 'energy_hartree': omega, 'energy_eV': omega * 27.211, 'wavelength_nm': 1239.8 / (omega * 27.211), 'oscillator_strength': f }) return sorted(excitations, key=lambda x: x['energy_eV']) def absorption_spectrum(self, excitations, lambda_range): """å¸åã‚¹ãƒšã‚¯ãƒˆãƒ«ã®è¨ˆç®—""" spectrum = np.zeros_like(lambda_range) for exc in excitations: # Lorentzian broadening gamma = 20 # nm (åŠå€¤å¹…) lambda_0 = exc['wavelength_nm'] f = exc['oscillator_strength'] spectrum += f * (gamma / 2) / ((lambda_range - lambda_0)**2 \+ (gamma / 2)**2) return spectrum # TD-DFTè¨ˆç®—å®Ÿè¡Œ ethylene = EthyleneTDDFT() excitations = ethylene.compute_excitations() # ä¸»è¦ãªåŠ±èµ·çŠ¶æ…‹ï¼ˆæŒ¯å‹•å­å¼·åº¦ > 0.01ï¼‰ major_exc = [exc for exc in excitations if exc['oscillator_strength'] > 0.01] print("ä¸»è¦ãªåŠ±èµ·çŠ¶æ…‹:") for i, exc in enumerate(major_exc[:5], 1): print(f"{i}. {exc['energy_eV']:.2f} eV ({exc['wavelength_nm']:.1f} nm) " f"[{exc['from']}â†’{exc['to']}] f={exc['oscillator_strength']:.3f}") # ã‚¹ãƒšã‚¯ãƒˆãƒ«è¨ˆç®— lambda_range = np.linspace(100, 400, 500) spectrum = ethylene.absorption_spectrum(excitations, lambda_range) # å¯è¦–åŒ– fig, axes = plt.subplots(2, 2, figsize=(12, 10)) # (1) è»Œé“ã‚¨ãƒãƒ«ã‚®ãƒ¼ãƒ€ã‚¤ã‚¢ã‚°ãƒ©ãƒ  y_occ = np.arange(ethylene.n_occ) y_virt = np.arange(ethylene.n_virt) + ethylene.n_occ + 1 axes[0,0].barh(y_occ, ethylene.epsilon_occ * 27.211, height=0.6, color='blue', alpha=0.7, label='Occupied') axes[0,0].barh(y_virt, ethylene.epsilon_virt * 27.211, height=0.6, color='red', alpha=0.7, label='Virtual') axes[0,0].axvline(0, color='k', linestyle='--', alpha=0.3) # Ï€â†’Ï€*é·ç§»ã®çŸ¢å° homo = ethylene.n_occ - 1 lumo = ethylene.n_occ + 1 axes[0,0].annotate('', xy=(ethylene.epsilon_virt[0]*27.211, lumo), xytext=(ethylene.epsilon_occ[-1]*27.211, homo), arrowprops=dict(arrowstyle='->', lw=2, color='green')) axes[0,0].text(-5, (homo+lumo)/2, 'Ï€â†’Ï€*', fontsize=12, color='green', fontweight='bold') axes[0,0].set_xlabel('Energy (eV)', fontsize=12) axes[0,0].set_ylabel('Orbital Index', fontsize=12) axes[0,0].set_title('Molecular Orbital Diagram', fontsize=14, fontweight='bold') axes[0,0].legend() # (2) åŠ±èµ·ã‚¨ãƒãƒ«ã‚®ãƒ¼ã‚¹ãƒšã‚¯ãƒˆãƒ«ï¼ˆã‚¹ãƒ†ã‚£ãƒƒã‚¯ã‚¹ãƒšã‚¯ãƒˆãƒ«ï¼‰ energies = [exc['energy_eV'] for exc in major_exc] intensities = [exc['oscillator_strength'] for exc in major_exc] axes[0,1].stem(energies, intensities, basefmt=' ') axes[0,1].set_xlabel('Excitation Energy (eV)', fontsize=12) axes[0,1].set_ylabel('Oscillator Strength', fontsize=12) axes[0,1].set_title('Excitation Spectrum', fontsize=14, fontweight='bold') axes[0,1].grid(True, alpha=0.3) # (3) UV-Viså¸åã‚¹ãƒšã‚¯ãƒˆãƒ« axes[1,0].plot(lambda_range, spectrum, 'b-', linewidth=2) axes[1,0].fill_between(lambda_range, spectrum, alpha=0.3) axes[1,0].set_xlabel('Wavelength (nm)', fontsize=12) axes[1,0].set_ylabel('Absorbance (a.u.)', fontsize=12) axes[1,0].set_title('UV-Vis Absorption Spectrum', fontsize=14, fontweight='bold') axes[1,0].set_xlim(100, 400) axes[1,0].grid(True, alpha=0.3) # ä¸»è¦ãƒ”ãƒ¼ã‚¯ä½ç½®ã‚’æ³¨é‡ˆ max_idx = np.argmax(spectrum) max_lambda = lambda_range[max_idx] axes[1,0].annotate(f'{max_lambda:.1f} nm', xy=(max_lambda, spectrum[max_idx]), xytext=(max_lambda+50, spectrum[max_idx]*0.8), arrowprops=dict(arrowstyle='->', color='red'), fontsize=11, color='red', fontweight='bold') # (4) åŠ±èµ·çŠ¶æ…‹ã‚µãƒãƒªãƒ¼ axes[1,1].axis('off') summary = f""" Câ‚‚Hâ‚„ TD-DFT Excitation Analysis Lowest Excitation: Energy: {major_exc[0]['energy_eV']:.2f} eV Wavelength: {major_exc[0]['wavelength_nm']:.1f} nm Type: Ï€ â†’ Ï€* f: {major_exc[0]['oscillator_strength']:.3f} Max Absorption: Î»max: {max_lambda:.1f} nm Region: {'UV-C' if max_lambda < 280 else 'UV-B' if max_lambda < 315 else 'UV-A'} Total Excitations: {len(excitations)} Major (f>0.01): {len(major_exc)} """ axes[1,1].text(0.1, 0.5, summary, fontsize=11, family='monospace', verticalalignment='center') plt.tight_layout() plt.savefig('ethylene_tddft.png', dpi=150, bbox_inches='tight') plt.show() 

## 5.4 å›ºä½“ãƒãƒ³ãƒ‰è¨ˆç®—

### ğŸ“š å‘¨æœŸå¢ƒç•Œæ¡ä»¶ã¨Blochå®šç†

å›ºä½“ã¯å‘¨æœŸçš„ãªçµæ™¶æ§‹é€ ã‚’æŒã¡ã¾ã™ã€‚**Blochå®šç†** ã«ã‚ˆã‚Šã€æ³¢å‹•é–¢æ•°ã¯:

\\[ \psi_{n\mathbf{k}}(\mathbf{r}) = e^{i\mathbf{k}\cdot\mathbf{r}} u_{n\mathbf{k}}(\mathbf{r}) \\]

ã“ã“ã§\\(u_{n\mathbf{k}}\\)ã¯æ ¼å­å‘¨æœŸé–¢æ•°ã§ã™ã€‚\\(\mathbf{k}\\)ã¯æ³¢æ•°ãƒ™ã‚¯ãƒˆãƒ«ã§ã€**ãƒãƒ³ãƒ‰æ§‹é€ ** \\(E_n(\mathbf{k})\\)ã‚’å®šç¾©ã—ã¾ã™ã€‚

### 1æ¬¡å…ƒå‘¨æœŸãƒãƒ†ãƒ³ã‚·ãƒ£ãƒ«ã®ãƒãƒ³ãƒ‰æ§‹é€ 

Kronig-Penneyãƒ¢ãƒ‡ãƒ«ã§1æ¬¡å…ƒå›ºä½“ã®ãƒãƒ³ãƒ‰ã‚®ãƒ£ãƒƒãƒ—ã‚’è¨ˆç®—ã—ã¾ã™ã€‚

class KronigPenney1D: """1æ¬¡å…ƒå‘¨æœŸãƒãƒ†ãƒ³ã‚·ãƒ£ãƒ«ï¼ˆKronig-Penneyãƒ¢ãƒ‡ãƒ«ï¼‰""" def __init__(self, a=1.0, V0=10.0, N_pw=21): self.a = a # æ ¼å­å®šæ•° self.V0 = V0 # ãƒãƒ†ãƒ³ã‚·ãƒ£ãƒ«æ·±ã• self.N_pw = N_pw # å¹³é¢æ³¢æ•° def potential(self, x): """å‘¨æœŸãƒãƒ†ãƒ³ã‚·ãƒ£ãƒ«ï¼ˆã‚³ã‚µã‚¤ãƒ³å‹ï¼‰""" return -self.V0 * np.cos(2 * np.pi * x / self.a) def hamiltonian_matrix(self, k): """kç‚¹ã§ã®ãƒãƒŸãƒ«ãƒˆãƒ‹ã‚¢ãƒ³è¡Œåˆ—""" # å¹³é¢æ³¢åŸºåº•: exp(i(k + n*G)x), G = 2Ï€/a G = 2 * np.pi / self.a n_indices = np.arange(-self.N_pw // 2, self.N_pw // 2 \+ 1) H = np.zeros((self.N_pw, self.N_pw), dtype=complex) for i, n_i in enumerate(n_indices): for j, n_j in enumerate(n_indices): k_i = k + n_i * G k_j = k + n_j * G if i == j: # é‹å‹•ã‚¨ãƒãƒ«ã‚®ãƒ¼ H[i,j] = 0.5 * k_i**2 elif abs(n_i - n_j) == 1: # ãƒãƒ†ãƒ³ã‚·ãƒ£ãƒ«ï¼ˆç¬¬ä¸€è¿‘æ¥ã®ã¿ï¼‰ H[i,j] = -self.V0 / 2 return H def compute_bands(self, k_points): """ãƒãƒ³ãƒ‰æ§‹é€ è¨ˆç®—""" bands = [] for k in k_points: H = self.hamiltonian_matrix(k) eigenvalues = eigh(H, eigvals_only=True) bands.append(eigenvalues) return np.array(bands) # ãƒãƒ³ãƒ‰æ§‹é€ è¨ˆç®— kp = KronigPenney1D(a=1.0, V0=5.0, N_pw=21) # ç¬¬1ãƒ–ãƒªãƒ«ã‚¢ãƒ³ã‚¾ãƒ¼ãƒ³: -Ï€/a â‰¤ k â‰¤ Ï€/a k_points = np.linspace(-np.pi/kp.a, np.pi/kp.a, 100) bands = kp.compute_bands(k_points) # ãƒãƒ³ãƒ‰ã‚®ãƒ£ãƒƒãƒ—æ¤œå‡º def find_band_gap(bands): """ç›´æ¥ãƒãƒ³ãƒ‰ã‚®ãƒ£ãƒƒãƒ—ã‚’æ¤œå‡º""" valence_band_max = np.max(bands[:, :11]) # ä¸‹ä½ãƒãƒ³ãƒ‰ conduction_band_min = np.min(bands[:, 11:]) # ä¸Šä½ãƒãƒ³ãƒ‰ gap = conduction_band_min - valence_band_max return gap, valence_band_max, conduction_band_min gap, vbm, cbm = find_band_gap(bands) # å¯è¦–åŒ– fig, axes = plt.subplots(2, 2, figsize=(12, 10)) # (1) å‘¨æœŸãƒãƒ†ãƒ³ã‚·ãƒ£ãƒ« x = np.linspace(0, 3*kp.a, 500) V = kp.potential(x) axes[0,0].plot(x, V, 'b-', linewidth=2) for i in range(4): axes[0,0].axvline(i*kp.a, color='gray', linestyle='--', alpha=0.5) axes[0,0].set_xlabel('Position x/a', fontsize=12) axes[0,0].set_ylabel('Potential V(x)', fontsize=12) axes[0,0].set_title('Periodic Potential', fontsize=14, fontweight='bold') axes[0,0].grid(True, alpha=0.3) # (2) ãƒãƒ³ãƒ‰æ§‹é€  for n in range(min(10, bands.shape[1])): color = 'blue' if n < 5 else 'red' axes[0,1].plot(k_points * kp.a / np.pi, bands[:, n], color=color, linewidth=2) axes[0,1].axhline(vbm, color='blue', linestyle='--', alpha=0.5, label='VBM') axes[0,1].axhline(cbm, color='red', linestyle='--', alpha=0.5, label='CBM') axes[0,1].axvline(0, color='black', linestyle='-', alpha=0.3) axes[0,1].set_xlabel('Wave Vector (k/Ï€/a)', fontsize=12) axes[0,1].set_ylabel('Energy (a.u.)', fontsize=12) axes[0,1].set_title('Band Structure', fontsize=14, fontweight='bold') axes[0,1].set_xlim(-1, 1) axes[0,1].legend() axes[0,1].grid(True, alpha=0.3) # ãƒãƒ³ãƒ‰ã‚®ãƒ£ãƒƒãƒ—é ˜åŸŸã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆ axes[0,1].fill_between([-1, 1], vbm, cbm, alpha=0.2, color='yellow') # (3) çŠ¶æ…‹å¯†åº¦ï¼ˆDOSï¼‰ energy_bins = np.linspace(bands.min(), bands.max(), 200) dos, _ = np.histogram(bands.flatten(), bins=energy_bins, density=True) axes[1,0].plot(dos, energy_bins[:-1], 'b-', linewidth=2) axes[1,0].fill_betweenx(energy_bins[:-1], dos, alpha=0.3) axes[1,0].axhline(vbm, color='blue', linestyle='--') axes[1,0].axhline(cbm, color='red', linestyle='--') axes[1,0].set_xlabel('Density of States', fontsize=12) axes[1,0].set_ylabel('Energy (a.u.)', fontsize=12) axes[1,0].set_title('Density of States (DOS)', fontsize=14, fontweight='bold') axes[1,0].grid(True, alpha=0.3) # (4) è¨ˆç®—çµæœã‚µãƒãƒªãƒ¼ axes[1,1].axis('off') summary = f""" 1D Periodic Crystal Band Structure Lattice Constant: {kp.a:.2f} Potential Depth: {kp.V0:.2f} Plane Waves: {kp.N_pw} Band Gap: {gap:.4f} a.u. {gap * 27.211:.2f} eV VBM: {vbm:.4f} a.u. CBM: {cbm:.4f} a.u. Material Type: {'Insulator' if gap > 0.2 else 'Semiconductor'} """ axes[1,1].text(0.1, 0.5, summary, fontsize=11, family='monospace', verticalalignment='center') plt.tight_layout() plt.savefig('band_structure_1d.png', dpi=150, bbox_inches='tight') plt.show() print(f"\nãƒãƒ³ãƒ‰ã‚®ãƒ£ãƒƒãƒ—: {gap * 27.211:.2f} eV") print(f"ææ–™ã‚¿ã‚¤ãƒ—: {'çµ¶ç¸ä½“' if gap > 0.2 else 'åŠå°ä½“'}") 

### ğŸ¯ æ¼”ç¿’å•é¡Œ

  1. **ãƒ¡ã‚¿ãƒ³ï¼ˆCHâ‚„ï¼‰ã®HFè¨ˆç®—** : æ­£å››é¢ä½“æ§‹é€ ã®ãƒ¡ã‚¿ãƒ³åˆ†å­ã§HF-SCFè¨ˆç®—ã‚’å®Ÿè£…ã—ã€å…¨ã‚¨ãƒãƒ«ã‚®ãƒ¼ã¨åˆ†å­è»Œé“ã‚’æ±‚ã‚ã‚ˆã€‚
  2. **COâ‚‚ã®æ§‹é€ æœ€é©åŒ–** : COâ‚‚åˆ†å­ã®C=Oçµåˆè·é›¢ã¨âˆ OCOè§’åº¦ã‚’æœ€é©åŒ–ã—ã€èµ¤å¤–æ´»æ€§ãªæŒ¯å‹•ãƒ¢ãƒ¼ãƒ‰ã‚’è¨ˆç®—ã›ã‚ˆã€‚
  3. **ãƒ™ãƒ³ã‚¼ãƒ³ã®åŠ±èµ·çŠ¶æ…‹** : ãƒ™ãƒ³ã‚¼ãƒ³ã®Ï€â†’Ï€*é·ç§»ã‚’TD-DFTã§è¨ˆç®—ã—ã€ç´«å¤–å¸åã‚¹ãƒšã‚¯ãƒˆãƒ«ã‚’äºˆæ¸¬ã›ã‚ˆã€‚
  4. **ã‚·ãƒªã‚³ãƒ³ã®ãƒãƒ³ãƒ‰æ§‹é€ ** : ãƒ€ã‚¤ãƒ¤ãƒ¢ãƒ³ãƒ‰æ§‹é€ ã‚·ãƒªã‚³ãƒ³ã®ãƒãƒ³ãƒ‰ã‚®ãƒ£ãƒƒãƒ—ã‚’è¨ˆç®—ã—ã€å®Ÿé¨“å€¤ï¼ˆ1.1 eVï¼‰ã¨æ¯”è¼ƒã›ã‚ˆã€‚
  5. **åå¿œçµŒè·¯æ¢ç´¢** : Hâ‚‚ + F â†’ HF + Håå¿œã®é·ç§»çŠ¶æ…‹ã‚’æ¢ç´¢ã—ã€æ´»æ€§åŒ–ã‚¨ãƒãƒ«ã‚®ãƒ¼ã‚’æ±‚ã‚ã‚ˆã€‚

## 5.5 ææ–™ç§‘å­¦ã¸ã®å¿œç”¨

### ğŸ“š ç¬¬ä¸€åŸç†è¨ˆç®—ã®ææ–™å¿œç”¨

é‡å­åŒ–å­¦è¨ˆç®—ã¯ã€å®Ÿé¨“ã«å…ˆç«‹ã¤**ææ–™ã‚¹ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°** ã€**åå¿œæ©Ÿæ§‹è§£æ˜** ã€**ç‰©æ€§äºˆæ¸¬** ã«ä¸å¯æ¬ ã§ã™ã€‚

  * **è§¦åª’è¨­è¨ˆ** : å¸ç€ã‚¨ãƒãƒ«ã‚®ãƒ¼ã€åå¿œéšœå£ã®è¨ˆç®—
  * **é›»æ± ææ–™** : é›»æ¥µé›»ä½ã€ã‚¤ã‚ªãƒ³æ‹¡æ•£ä¿‚æ•°
  * **åŠå°ä½“** : ãƒãƒ³ãƒ‰ã‚®ãƒ£ãƒƒãƒ—ã€ã‚­ãƒ£ãƒªã‚¢ç§»å‹•åº¦
  * **å…‰å­¦ææ–™** : å¸åã‚¹ãƒšã‚¯ãƒˆãƒ«ã€éç·šå½¢å…‰å­¦å¿œç­”
  * **æ©Ÿæ¢°å­¦ç¿’ãƒãƒ†ãƒ³ã‚·ãƒ£ãƒ«** : DFTãƒ‡ãƒ¼ã‚¿ã§è¨“ç·´ã€é«˜é€ŸMD

### è§¦åª’è¡¨é¢å¸ç€ã‚¨ãƒãƒ«ã‚®ãƒ¼

é‡‘å±è¡¨é¢ã¸ã®COå¸ç€ã‚’è¨ˆç®—ã—ã€è§¦åª’æ´»æ€§ã‚’è©•ä¾¡ã—ã¾ã™ã€‚

class MetalSurfaceAdsorption: """é‡‘å±è¡¨é¢å¸ç€ã‚¨ãƒãƒ«ã‚®ãƒ¼è¨ˆç®—ï¼ˆç°¡æ˜“ãƒ¢ãƒ‡ãƒ«ï¼‰""" def __init__(self, metal='Pt'): self.metal = metal # é‡‘å±ã®ä»•äº‹é–¢æ•°ï¼ˆeVï¼‰ self.work_functions = {'Pt': 5.65, 'Pd': 5.12, 'Cu': 4.65, 'Au': 5.1} self.phi = self.work_functions.get(metal, 5.0) def lennard_jones(self, r, epsilon, sigma): """Lennard-Jonesãƒãƒ†ãƒ³ã‚·ãƒ£ãƒ«""" return 4 * epsilon * ((sigma/r)**12 \- (sigma/r)**6) def adsorption_energy(self, z, molecule='CO'): """å¸ç€ã‚¨ãƒãƒ«ã‚®ãƒ¼ã®è¨ˆç®—""" # LJ ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ï¼ˆé‡‘å±-COï¼‰ epsilon = 0.5 # eV sigma = 2.5 # Ã… # å¸ç€ã‚¨ãƒãƒ«ã‚®ãƒ¼ = LJ + é™é›»ç›¸äº’ä½œç”¨ E_vdw = self.lennard_jones(z, epsilon, sigma) E_elec = -0.3 * self.phi * np.exp(-z / 2.0) return E_vdw + E_elec def find_optimal_height(self): """æœ€é©å¸ç€é«˜ã•ã®æ¢ç´¢""" z_range = np.linspace(1.5, 6.0, 200) E_ads = [self.adsorption_energy(z) for z in z_range] min_idx = np.argmin(E_ads) z_opt = z_range[min_idx] E_opt = E_ads[min_idx] return z_opt, E_opt, z_range, E_ads # è¤‡æ•°é‡‘å±ã®æ¯”è¼ƒ metals = ['Pt', 'Pd', 'Cu', 'Au'] results = {} for metal in metals: surface = MetalSurfaceAdsorption(metal) z_opt, E_opt, z_range, E_ads = surface.find_optimal_height() results[metal] = {'z': z_opt, 'E': E_opt, 'curve': (z_range, E_ads)} print(f"{metal}: z = {z_opt:.2f} Ã…, E_ads = {E_opt:.3f} eV") # å¯è¦–åŒ– fig, axes = plt.subplots(2, 2, figsize=(12, 10)) # (1) å¸ç€ã‚¨ãƒãƒ«ã‚®ãƒ¼æ›²ç·š colors = {'Pt': 'blue', 'Pd': 'green', 'Cu': 'orange', 'Au': 'gold'} for metal, data in results.items(): z_range, E_ads = data['curve'] axes[0,0].plot(z_range, E_ads, color=colors[metal], linewidth=2, label=metal) axes[0,0].plot(data['z'], data['E'], 'o', color=colors[metal], markersize=8) axes[0,0].axhline(0, color='k', linestyle='--', alpha=0.3) axes[0,0].set_xlabel('Distance from Surface (Ã…)', fontsize=12) axes[0,0].set_ylabel('Adsorption Energy (eV)', fontsize=12) axes[0,0].set_title('CO Adsorption on Metal Surfaces', fontsize=14, fontweight='bold') axes[0,0].legend() axes[0,0].grid(True, alpha=0.3) # (2) å¸ç€ã‚¨ãƒãƒ«ã‚®ãƒ¼ã®æ¯”è¼ƒ metal_names = list(results.keys()) E_ads_values = [-results[m]['E'] for m in metal_names] # æ­£ã®å€¤ã§è¡¨ç¤º bar_colors = [colors[m] for m in metal_names] axes[0,1].bar(metal_names, E_ads_values, color=bar_colors, alpha=0.7) axes[0,1].set_ylabel('|E_ads| (eV)', fontsize=12) axes[0,1].set_title('Adsorption Energy Comparison', fontsize=14, fontweight='bold') axes[0,1].grid(True, alpha=0.3, axis='y') # æœ€å¼·å¸ç€ã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆ max_idx = np.argmax(E_ads_values) axes[0,1].text(max_idx, E_ads_values[max_idx] + 0.05, 'Strongest', ha='center', fontsize=10, fontweight='bold') # (3) ä»•äº‹é–¢æ•° vs å¸ç€ã‚¨ãƒãƒ«ã‚®ãƒ¼ phi_values = [MetalSurfaceAdsorption(m).phi for m in metal_names] axes[1,0].scatter(phi_values, E_ads_values, s=150, c=bar_colors, alpha=0.7) for i, metal in enumerate(metal_names): axes[1,0].annotate(metal, (phi_values[i], E_ads_values[i]), xytext=(5, 5), textcoords='offset points', fontsize=11, fontweight='bold') # ç·šå½¢ãƒ•ã‚£ãƒƒãƒˆ z = np.polyfit(phi_values, E_ads_values, 1) p = np.poly1d(z) phi_fit = np.linspace(min(phi_values), max(phi_values), 100) axes[1,0].plot(phi_fit, p(phi_fit), 'r--', alpha=0.5, label=f'y = {z[0]:.2f}x + {z[1]:.2f}') axes[1,0].set_xlabel('Work Function (eV)', fontsize=12) axes[1,0].set_ylabel('|E_ads| (eV)', fontsize=12) axes[1,0].set_title('Work Function vs Adsorption Energy', fontsize=14, fontweight='bold') axes[1,0].legend() axes[1,0].grid(True, alpha=0.3) # (4) è§¦åª’æ´»æ€§ã‚µãƒãƒªãƒ¼ axes[1,1].axis('off') best_metal = metal_names[max_idx] summary = f""" CO Adsorption on Metal Surfaces Best Catalyst: {best_metal} E_ads: {-results[best_metal]['E']:.3f} eV Height: {results[best_metal]['z']:.2f} Ã… Work Func: {MetalSurfaceAdsorption(best_metal).phi:.2f} eV Ranking (by |E_ads|): """ for i, m in enumerate(sorted(metal_names, key=lambda x: -results[x]['E']), 1): summary += f" {i}. {m:3s} {-results[m]['E']:.3f} eV\n" axes[1,1].text(0.1, 0.5, summary, fontsize=11, family='monospace', verticalalignment='center') plt.tight_layout() plt.savefig('catalyst_adsorption.png', dpi=150, bbox_inches='tight') plt.show() 

## ã¾ã¨ã‚

æœ¬ç« ã§ã¯ã€é‡å­åŒ–å­¦è¨ˆç®—ã®å®Ÿè·µçš„æ‰‹æ³•ã‚’å­¦ã³ã¾ã—ãŸ:

  * **PySCFã«ã‚ˆã‚‹åˆ†å­è¨ˆç®—** : HFæ³•ã¨DFTã§æ°´åˆ†å­ã®é›»å­çŠ¶æ…‹ã‚’è¨ˆç®—
  * **æ§‹é€ æœ€é©åŒ–** : ã‚¨ãƒãƒ«ã‚®ãƒ¼å‹¾é…ã«åŸºã¥ãå¹³è¡¡æ§‹é€ ã®æ¢ç´¢
  * **æŒ¯å‹•è§£æ** : èª¿å’ŒæŒ¯å‹•å­è¿‘ä¼¼ã«ã‚ˆã‚‹æŒ¯å‹•ã‚¹ãƒšã‚¯ãƒˆãƒ«äºˆæ¸¬
  * **TD-DFT** : åŠ±èµ·çŠ¶æ…‹è¨ˆç®—ã¨UV-Viså¸åã‚¹ãƒšã‚¯ãƒˆãƒ«
  * **ãƒãƒ³ãƒ‰è¨ˆç®—** : å‘¨æœŸç³»ã®Blochå®šç†ã¨å›ºä½“é›»å­æ§‹é€ 
  * **ææ–™å¿œç”¨** : è§¦åª’ã€é›»æ± ã€åŠå°ä½“ã¸ã®å®Ÿç”¨çš„å¿œç”¨

ã“ã‚Œã‚‰ã®æ‰‹æ³•ã¯ã€**Materials Informatics** ã«ãŠã„ã¦ã€æ©Ÿæ¢°å­¦ç¿’ã¨çµ„ã¿åˆã‚ã›ã‚‹ã“ã¨ã§ã€é«˜é€Ÿãªææ–™ã‚¹ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°ã¨ç‰©æ€§äºˆæ¸¬ã‚’å¯èƒ½ã«ã—ã¾ã™ã€‚ç¬¬ä¸€åŸç†è¨ˆç®—ã§ç”Ÿæˆã•ã‚ŒãŸé«˜ç²¾åº¦ãƒ‡ãƒ¼ã‚¿ã¯ã€æ©Ÿæ¢°å­¦ç¿’ãƒãƒ†ãƒ³ã‚·ãƒ£ãƒ«ã®è¨“ç·´ã€è¨˜è¿°å­ã®è¨­è¨ˆã€äºˆæ¸¬ãƒ¢ãƒ‡ãƒ«ã®æ§‹ç¯‰ã«æ´»ç”¨ã•ã‚Œã¾ã™ã€‚

â† ç¬¬4ç« : å¯†åº¦æ±é–¢æ•°ç†è«–ï¼ˆæº–å‚™ä¸­ï¼‰ [ç›®æ¬¡ã«æˆ»ã‚‹](<index.html>)

### å…è²¬äº‹é …

  * æœ¬ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã¯æ•™è‚²ãƒ»ç ”ç©¶ãƒ»æƒ…å ±æä¾›ã®ã¿ã‚’ç›®çš„ã¨ã—ã¦ãŠã‚Šã€å°‚é–€çš„ãªåŠ©è¨€(æ³•å¾‹ãƒ»ä¼šè¨ˆãƒ»æŠ€è¡“çš„ä¿è¨¼ãªã©)ã‚’æä¾›ã™ã‚‹ã‚‚ã®ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚
  * æœ¬ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãŠã‚ˆã³ä»˜éšã™ã‚‹Code examplesã¯ã€Œç¾çŠ¶æœ‰å§¿(AS IS)ã€ã§æä¾›ã•ã‚Œã€æ˜ç¤ºã¾ãŸã¯é»™ç¤ºã‚’å•ã‚ãšã€å•†å“æ€§ã€ç‰¹å®šç›®çš„é©åˆæ€§ã€æ¨©åˆ©éä¾µå®³ã€æ­£ç¢ºæ€§ãƒ»å®Œå…¨æ€§ã€å‹•ä½œãƒ»å®‰å…¨æ€§ç­‰ã„ã‹ãªã‚‹ä¿è¨¼ã‚‚ã—ã¾ã›ã‚“ã€‚
  * å¤–éƒ¨ãƒªãƒ³ã‚¯ã€ç¬¬ä¸‰è€…ãŒæä¾›ã™ã‚‹ãƒ‡ãƒ¼ã‚¿ãƒ»ãƒ„ãƒ¼ãƒ«ãƒ»ãƒ©ã‚¤ãƒ–ãƒ©ãƒªç­‰ã®å†…å®¹ãƒ»å¯ç”¨æ€§ãƒ»å®‰å…¨æ€§ã«ã¤ã„ã¦ã€ä½œæˆè€…ãŠã‚ˆã³æ±åŒ—å¤§å­¦ã¯ä¸€åˆ‡ã®è²¬ä»»ã‚’è² ã„ã¾ã›ã‚“ã€‚
  * æœ¬ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®åˆ©ç”¨ãƒ»å®Ÿè¡Œãƒ»è§£é‡ˆã«ã‚ˆã‚Šç›´æ¥çš„ãƒ»é–“æ¥çš„ãƒ»ä»˜éšçš„ãƒ»ç‰¹åˆ¥ãƒ»çµæœçš„ãƒ»æ‡²ç½°çš„æå®³ãŒç”Ÿã˜ãŸå ´åˆã§ã‚‚ã€é©ç”¨æ³•ã§è¨±å®¹ã•ã‚Œã‚‹æœ€å¤§é™ã®ç¯„å›²ã§ã€ä½œæˆè€…ãŠã‚ˆã³æ±åŒ—å¤§å­¦ã¯è²¬ä»»ã‚’è² ã„ã¾ã›ã‚“ã€‚
  * æœ¬ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®å†…å®¹ã¯ã€äºˆå‘Šãªãå¤‰æ›´ãƒ»æ›´æ–°ãƒ»æä¾›åœæ­¢ã•ã‚Œã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚
  * æœ¬ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®è‘—ä½œæ¨©ãƒ»ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã¯æ˜è¨˜ã•ã‚ŒãŸæ¡ä»¶(ä¾‹: CC BY 4.0)ã«å¾“ã„ã¾ã™ã€‚å½“è©²ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã¯é€šå¸¸ã€ç„¡ä¿è¨¼æ¡é …ã‚’å«ã¿ã¾ã™ã€‚
