<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç¬¬3ç« : åˆ†å­è»Œé“æ³•ã¨é›»å­çŠ¶æ…‹è¨ˆç®— | é‡å­åŒ–å­¦å…¥é–€</title>
    <meta name="description" content="Hartree-Fockæ³•ã€è‡ªå·±ç„¡æ’ç€å ´ã€Roothaanæ–¹ç¨‹å¼ã€åŸºåº•é–¢æ•°ã€HÃ¼ckelæ³•ã‚’å­¦ã³ã¾ã™ã€‚">
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            line-height: 1.8;
            color: #333;
            background: #f5f5f5;
        }
        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 2rem 1rem;
            text-align: center;
        }
        .breadcrumb {
            max-width: 1200px;
            margin: 1rem auto;
            padding: 0 1rem;
            font-size: 0.9rem;
        }
        .breadcrumb a { color: #667eea; text-decoration: none; }
        .breadcrumb a:hover { text-decoration: underline; }
        .container {
            max-width: 1200px;
            margin: 2rem auto;
            padding: 0 1rem;
        }
        .content {
            background: white;
            padding: 2rem;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            margin-bottom: 2rem;
        }
        h1 { font-size: 2rem; margin-bottom: 1rem; }
        h2 {
            font-size: 1.5rem;
            margin: 2rem 0 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 3px solid #764ba2;
            color: #667eea;
        }
        h3 { font-size: 1.2rem; margin: 1.5rem 0 1rem; color: #555; }
        p { margin-bottom: 1rem; }
        ul, ol { margin: 1rem 0 1rem 2rem; }
        li { margin-bottom: 0.5rem; }
        .theory-box {
            background: linear-gradient(to right, #f0f4ff, #faf5ff);
            border-left: 4px solid #667eea;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-radius: 8px;
        }
        .code-example {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 1.5rem;
            border-radius: 8px;
            overflow-x: auto;
            margin: 1rem 0;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            line-height: 1.6;
        }
        .code-title {
            background: #667eea;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 6px 6px 0 0;
            font-weight: 600;
            margin-top: 1.5rem;
        }
        .exercise {
            background: #fff9e6;
            border-left: 4px solid #f59e0b;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-radius: 8px;
        }
        .navigation {
            display: flex;
            justify-content: space-between;
            margin-top: 3rem;
            gap: 1rem;
        }
        .nav-button {
            padding: 0.75rem 1.5rem;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            text-decoration: none;
            border-radius: 8px;
            font-weight: 600;
            transition: transform 0.3s;
        }
        .nav-button:hover { transform: translateY(-2px); }
        footer {
            background: #2c3e50;
            color: white;
            text-align: center;
            padding: 2rem 1rem;
            margin-top: 4rem;
        }
        @media (max-width: 768px) {
            .content { padding: 1.5rem; }
            h1 { font-size: 1.5rem; }
            h2 { font-size: 1.3rem; }
            .navigation { flex-direction: column; }
        }
    </style>
</head>
<body>
    <header>
        <h1>ğŸ”¬ ç¬¬3ç« : åˆ†å­è»Œé“æ³•ã¨é›»å­çŠ¶æ…‹è¨ˆç®—</h1>
        <p>Molecular Orbital Theory and Electronic Structure Calculations</p>
    </header>

    <div class="breadcrumb">
        <a href="../../index.html">ãƒŠãƒ¬ãƒƒã‚¸ãƒ™ãƒ¼ã‚¹</a> &gt;
        <a href="../index.html">MI</a> &gt;
        <a href="index.html">é‡å­åŒ–å­¦å…¥é–€</a> &gt;
        ç¬¬3ç« 
    </div>

    <div class="container">
        <div class="content">
            <h2>ğŸ¯ å­¦ç¿’ç›®æ¨™</h2>
            <ul>
                <li>Hartree-Fockæ–¹ç¨‹å¼ã®å°å‡ºã¨ç‰©ç†çš„æ„å‘³ã‚’ç†è§£ã™ã‚‹</li>
                <li>Fockæ¼”ç®—å­ã¨è‡ªå·±ç„¡æ’ç€å ´ï¼ˆSCFï¼‰æ³•ã‚’å­¦ã¶</li>
                <li>Roothaanæ–¹ç¨‹å¼ã¨åŸºåº•é–¢æ•°å±•é–‹ã‚’ç¿’å¾—ã™ã‚‹</li>
                <li>Gaussianå‹åŸºåº•é–¢æ•°ã¨Slaterå‹åŸºåº•é–¢æ•°ã‚’ç†è§£ã™ã‚‹</li>
                <li>LCAO-MOï¼ˆåŸå­è»Œé“ã®ç·šå½¢çµåˆï¼‰æ³•ã‚’å®Ÿè£…ã™ã‚‹</li>
                <li>HÃ¼ckelåˆ†å­è»Œé“æ³•ã¨æ‹¡å¼µHÃ¼ckelæ³•ã‚’å­¦ã¶</li>
                <li>é›»å­ç›¸é–¢ã¨é…ç½®é–“ç›¸äº’ä½œç”¨ï¼ˆCIï¼‰ã‚’ç†è§£ã™ã‚‹</li>
                <li>å®Ÿéš›ã®åˆ†å­ã«å¯¾ã™ã‚‹SCFè¨ˆç®—ã‚’å®Ÿè£…ã™ã‚‹</li>
            </ul>
        </div>

        <div class="content">
            <h2>ğŸ“– Hartree-Fockæ–¹ç¨‹å¼</h2>

            <div class="theory-box">
                <h3>å¤šé›»å­ç³»ã®Hamiltonian</h3>
                <p>Né›»å­ç³»ã®é›»å­Hamiltonianï¼ˆåŸå­å˜ä½ç³»ï¼‰ï¼š</p>
                <p>\[
                \hat{H}_{el} = \sum_{i=1}^N \left(-\frac{1}{2}\nabla_i^2 - \sum_A \frac{Z_A}{r_{iA}}\right) + \sum_{i<j} \frac{1}{r_{ij}}
                \]</p>
                <ul>
                    <li>ç¬¬1é …ï¼šé›»å­ã®é‹å‹•ã‚¨ãƒãƒ«ã‚®ãƒ¼</li>
                    <li>ç¬¬2é …ï¼šé›»å­-æ ¸é–“å¼•åŠ›</li>
                    <li>ç¬¬3é …ï¼šé›»å­-é›»å­é–“åç™ºï¼ˆå¤šä½“é …ï¼‰</li>
                </ul>
                <p>ã“ã®å¤šä½“å•é¡Œã‚’è¿‘ä¼¼çš„ã«è§£ãã®ãŒHartree-Fockæ³•ã§ã™ã€‚</p>
            </div>

            <div class="theory-box">
                <h3>Hartree-Fockè¿‘ä¼¼</h3>
                <p>Né›»å­æ³¢å‹•é–¢æ•°ã‚’<strong>Slaterè¡Œåˆ—å¼</strong>ã§è¡¨ç¾ï¼š</p>
                <p>\[
                \Psi_{HF} = \frac{1}{\sqrt{N!}} \begin{vmatrix}
                \chi_1(1) & \chi_2(1) & \cdots & \chi_N(1) \\
                \chi_1(2) & \chi_2(2) & \cdots & \chi_N(2) \\
                \vdots & \vdots & \ddots & \vdots \\
                \chi_1(N) & \chi_2(N) & \cdots & \chi_N(N)
                \end{vmatrix}
                \]</p>
                <p>ã“ã“ã§ \(\chi_i\) ã¯ã‚¹ãƒ”ãƒ³è»Œé“ï¼ˆç©ºé–“è»Œé“Ã—ã‚¹ãƒ”ãƒ³ï¼‰ã§ã™ã€‚</p>
                <p><strong>Fockæ–¹ç¨‹å¼</strong>:</p>
                <p>\[
                \hat{f} \chi_i = \varepsilon_i \chi_i
                \]</p>
                <p><strong>Fockæ¼”ç®—å­</strong>:</p>
                <p>\[
                \hat{f}(1) = \hat{h}(1) + \sum_{j=1}^N \left[\hat{J}_j(1) - \hat{K}_j(1)\right]
                \]</p>
                <ul>
                    <li>\(\hat{h}\)ï¼š1é›»å­Hamiltonian</li>
                    <li>\(\hat{J}_j\)ï¼šCoulombæ¼”ç®—å­ï¼ˆå¤å…¸çš„é›»å­-é›»å­åç™ºï¼‰</li>
                    <li>\(\hat{K}_j\)ï¼šäº¤æ›æ¼”ç®—å­ï¼ˆé‡å­åŠ›å­¦çš„åŠ¹æœã€Pauliæ’ä»–åŸç†ï¼‰</li>
                </ul>
            </div>
        </div>

        <div class="content">
            <h2>ğŸ’» ä¾‹é¡Œ3.1: Roothaanæ–¹ç¨‹å¼ã¨SCFæ³•</h2>

            <div class="theory-box">
                <h3>Roothaanæ–¹ç¨‹å¼</h3>
                <p>åŸºåº•é–¢æ•° \(\{\phi_\mu\}\) ã§åˆ†å­è»Œé“ã‚’å±•é–‹ï¼š</p>
                <p>\[
                \psi_i = \sum_{\mu=1}^K C_{\mu i} \phi_\mu
                \]</p>
                <p>Roothaanæ–¹ç¨‹å¼ï¼ˆè¡Œåˆ—å½¢å¼ã®Hartree-Fockæ–¹ç¨‹å¼ï¼‰ï¼š</p>
                <p>\[
                \mathbf{F}\mathbf{C} = \mathbf{S}\mathbf{C}\mathbf{\varepsilon}
                \]</p>
                <ul>
                    <li>\(\mathbf{F}\)ï¼šFockè¡Œåˆ— \(F_{\mu\nu} = \langle \phi_\mu | \hat{f} | \phi_\nu \rangle\)</li>
                    <li>\(\mathbf{S}\)ï¼šé‡ãªã‚Šè¡Œåˆ— \(S_{\mu\nu} = \langle \phi_\mu | \phi_\nu \rangle\)</li>
                    <li>\(\mathbf{C}\)ï¼šè»Œé“ä¿‚æ•°è¡Œåˆ—</li>
                    <li>\(\mathbf{\varepsilon}\)ï¼šè»Œé“ã‚¨ãƒãƒ«ã‚®ãƒ¼ï¼ˆå¯¾è§’è¡Œåˆ—ï¼‰</li>
                </ul>
                <p><strong>SCFï¼ˆSelf-Consistent Fieldï¼‰ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ </strong>:</p>
                <ol>
                    <li>åˆæœŸè»Œé“ä¿‚æ•° \(\mathbf{C}^{(0)}\) ã‚’è¨­å®š</li>
                    <li>å¯†åº¦è¡Œåˆ— \(\mathbf{P}\) ã‚’è¨ˆç®—</li>
                    <li>Fockè¡Œåˆ— \(\mathbf{F}\) ã‚’æ§‹ç¯‰</li>
                    <li>Roothaanæ–¹ç¨‹å¼ã‚’è§£ã„ã¦æ–°ã—ã„ \(\mathbf{C}\) ã‚’å¾—ã‚‹</li>
                    <li>åæŸã™ã‚‹ã¾ã§2-4ã‚’ç¹°ã‚Šè¿”ã™</li>
                </ol>
            </div>

            <div class="code-title">Pythonå®Ÿè£…: æœ€å°åŸºåº•Hâ‚‚ã®SCFè¨ˆç®—</div>
            <div class="code-example">import numpy as np
import matplotlib.pyplot as plt
from scipy.linalg import eigh

class MinimalBasisH2:
    """æœ€å°åŸºåº•ï¼ˆSTO-1Gï¼‰ã§ã®Hâ‚‚åˆ†å­ã®SCFè¨ˆç®—"""

    def __init__(self, R=1.4):
        """
        R: æ ¸é–“è·é›¢ï¼ˆBohrï¼‰
        """
        self.R = R
        self.alpha = 1.0  # STO-1Gã®exponentï¼ˆç°¡ç•¥åŒ–ï¼‰

    def overlap_matrix(self):
        """é‡ãªã‚Šè¡Œåˆ— S"""
        R = self.R
        alpha = self.alpha

        # S_11 = S_22 = 1 (è¦æ ¼åŒ–)
        # S_12 = S_21 = âŸ¨Ï†_A|Ï†_BâŸ©ï¼ˆç°¡æ˜“è¿‘ä¼¼ï¼‰
        S_12 = np.exp(-alpha * R) * (1 + alpha * R + (alpha * R)**2 / 3)

        S = np.array([[1.0, S_12],
                      [S_12, 1.0]])
        return S

    def core_hamiltonian(self):
        """ã‚³ã‚¢Hamiltonianè¡Œåˆ— H_core"""
        R = self.R
        alpha = self.alpha

        # é‹å‹•ã‚¨ãƒãƒ«ã‚®ãƒ¼ + æ ¸å¼•åŠ›
        # H_11 = âŸ¨Ï†_A|T + V_A + V_B|Ï†_AâŸ©
        H_11 = -alpha**2 / 2 - 1/R * (1 + 1/R) * np.exp(-2*alpha*R) - 1.0

        # H_12 = âŸ¨Ï†_A|T + V_A + V_B|Ï†_BâŸ©
        S_12 = np.exp(-alpha * R) * (1 + alpha * R + (alpha * R)**2 / 3)
        H_12 = -alpha**2 * S_12 / 2 - S_12 / R - S_12 / alpha

        H_core = np.array([[H_11, H_12],
                           [H_12, H_11]])
        return H_core

    def two_electron_integrals(self):
        """2é›»å­ç©åˆ†ï¼ˆç°¡æ˜“è¿‘ä¼¼ï¼‰"""
        R = self.R
        alpha = self.alpha

        # (Î¼Î½|Î»Ïƒ) ç©åˆ†ï¼ˆç°¡ç•¥åŒ–ï¼‰
        g = {}
        g['1111'] = 5/8 * alpha  # âŸ¨Ï†_A Ï†_A|Ï†_A Ï†_AâŸ©
        g['1122'] = 1/R * np.exp(-alpha * R)  # âŸ¨Ï†_A Ï†_A|Ï†_B Ï†_BâŸ©
        g['1212'] = 0.5 * g['1122']  # âŸ¨Ï†_A Ï†_B|Ï†_A Ï†_BâŸ©
        g['2222'] = g['1111']

        return g

    def build_fock_matrix(self, P, H_core, g):
        """Fockè¡Œåˆ—ã®æ§‹ç¯‰"""
        # F_Î¼Î½ = H_Î¼Î½^core + Î£_Î»Ïƒ P_Î»Ïƒ [(Î¼Î½|Î»Ïƒ) - 0.5(Î¼Î»|Î½Ïƒ)]
        F = H_core.copy()

        # Coulombé …ã¨Exchangeé …ï¼ˆç°¡ç•¥åŒ–ï¼‰
        F[0, 0] += P[0, 0] * g['1111'] + P[1, 1] * (g['1122'] - 0.5 * g['1212'])
        F[1, 1] += P[1, 1] * g['2222'] + P[0, 0] * (g['1122'] - 0.5 * g['1212'])
        F[0, 1] += P[0, 1] * (g['1212'] - 0.5 * g['1122'])
        F[1, 0] = F[0, 1]

        return F

    def scf_iteration(self, max_iter=50, conv_threshold=1e-6):
        """SCFåå¾©è¨ˆç®—"""
        S = self.overlap_matrix()
        H_core = self.core_hamiltonian()
        g = self.two_electron_integrals()

        # åˆæœŸå¯†åº¦è¡Œåˆ—ï¼ˆã‚¼ãƒ­ï¼‰
        P = np.zeros((2, 2))

        energies = []
        converged = False

        for iteration in range(max_iter):
            # Fockè¡Œåˆ—æ§‹ç¯‰
            F = self.build_fock_matrix(P, H_core, g)

            # ä¸€èˆ¬åŒ–å›ºæœ‰å€¤å•é¡Œã‚’è§£ã: FC = SCÎµ
            epsilon, C = eigh(F, S)

            # å¯†åº¦è¡Œåˆ—ã®æ›´æ–°ï¼ˆ2é›»å­ç³»ãªã®ã§å æœ‰è»Œé“1ã¤ï¼‰
            P_new = 2 * np.outer(C[:, 0], C[:, 0])  # 2é›»å­åˆ†

            # é›»å­ã‚¨ãƒãƒ«ã‚®ãƒ¼
            E_elec = 0.5 * np.sum(P_new * (H_core + F))

            # æ ¸é–“åç™º
            V_NN = 1 / self.R

            # å…¨ã‚¨ãƒãƒ«ã‚®ãƒ¼
            E_total = E_elec + V_NN

            energies.append(E_total)

            # åæŸåˆ¤å®š
            if iteration > 0:
                delta_E = abs(E_total - energies[-2])
                if delta_E < conv_threshold:
                    converged = True
                    break

            P = P_new

        return {
            'converged': converged,
            'iterations': iteration + 1,
            'energy': E_total,
            'orbital_energies': epsilon,
            'coefficients': C,
            'density_matrix': P,
            'energy_history': energies
        }

# ç•°ãªã‚‹æ ¸é–“è·é›¢ã§SCFè¨ˆç®—
R_range = np.linspace(0.5, 4.0, 30)
energies_scf = []
orbital_energies_bonding = []
orbital_energies_antibonding = []

for R in R_range:
    h2 = MinimalBasisH2(R)
    result = h2.scf_iteration()
    energies_scf.append(result['energy'])
    orbital_energies_bonding.append(result['orbital_energies'][0])
    orbital_energies_antibonding.append(result['orbital_energies'][1])

# å¹³è¡¡æ ¸é–“è·é›¢
E_array = np.array(energies_scf)
R_eq_idx = np.argmin(E_array)
R_eq = R_range[R_eq_idx]
E_eq = E_array[R_eq_idx]

# å¯è¦–åŒ–
fig, axes = plt.subplots(2, 2, figsize=(14, 10))

# ãƒãƒ†ãƒ³ã‚·ãƒ£ãƒ«ã‚¨ãƒãƒ«ã‚®ãƒ¼æ›²ç·š
ax1 = axes[0, 0]
ax1.plot(R_range, energies_scf, 'b-', linewidth=2, label='SCF Energy')
ax1.plot(R_eq, E_eq, 'ro', markersize=10, label=f'R_eq = {R_eq:.2f} Bohr')
ax1.axhline(0, color='k', linestyle='--', linewidth=1)

ax1.set_xlabel('Internuclear distance R (Bohr)')
ax1.set_ylabel('Energy (Hartree)')
ax1.set_title('Hâ‚‚ ãƒãƒ†ãƒ³ã‚·ãƒ£ãƒ«ã‚¨ãƒãƒ«ã‚®ãƒ¼æ›²ç·šï¼ˆSCFï¼‰')
ax1.legend()
ax1.grid(True, alpha=0.3)

# è»Œé“ã‚¨ãƒãƒ«ã‚®ãƒ¼
ax2 = axes[0, 1]
ax2.plot(R_range, orbital_energies_bonding, 'b-', linewidth=2, label='Bonding MO')
ax2.plot(R_range, orbital_energies_antibonding, 'r-', linewidth=2, label='Antibonding MO')
ax2.axhline(0, color='k', linestyle='--', linewidth=1)

ax2.set_xlabel('Internuclear distance R (Bohr)')
ax2.set_ylabel('Orbital energy (Hartree)')
ax2.set_title('åˆ†å­è»Œé“ã‚¨ãƒãƒ«ã‚®ãƒ¼')
ax2.legend()
ax2.grid(True, alpha=0.3)

# SCFåæŸå±¥æ­´ï¼ˆR = R_eqï¼‰
ax3 = axes[1, 0]
h2_eq = MinimalBasisH2(R_eq)
result_eq = h2_eq.scf_iteration()

ax3.plot(result_eq['energy_history'], 'go-', linewidth=2, markersize=6)
ax3.set_xlabel('SCF iteration')
ax3.set_ylabel('Total energy (Hartree)')
ax3.set_title(f'SCFåæŸï¼ˆR = {R_eq:.2f} Bohrï¼‰')
ax3.grid(True, alpha=0.3)

# åˆ†å­è»Œé“ä¿‚æ•°ï¼ˆR = R_eqï¼‰
ax4 = axes[1, 1]
C = result_eq['coefficients']

x = ['Ï†_A (H_A)', 'Ï†_B (H_B)']
width = 0.35

bonding_coeffs = C[:, 0]
antibonding_coeffs = C[:, 1]

x_pos = np.arange(len(x))
ax4.bar(x_pos - width/2, bonding_coeffs, width, label='Bonding', color='blue')
ax4.bar(x_pos + width/2, antibonding_coeffs, width, label='Antibonding', color='red')

ax4.set_ylabel('Coefficient')
ax4.set_title(f'åˆ†å­è»Œé“ä¿‚æ•°ï¼ˆR = {R_eq:.2f} Bohrï¼‰')
ax4.set_xticks(x_pos)
ax4.set_xticklabels(x)
ax4.legend()
ax4.grid(True, alpha=0.3, axis='y')
ax4.axhline(0, color='k', linewidth=0.5)

plt.tight_layout()
plt.savefig('qchem_scf_h2.png', dpi=300, bbox_inches='tight')
plt.show()

# æ•°å€¤çµæœ
print("=== Hâ‚‚åˆ†å­ã®SCFè¨ˆç®—ï¼ˆæœ€å°åŸºåº•ï¼‰===\n")
print(f"å¹³è¡¡æ ¸é–“è·é›¢: R_eq = {R_eq:.3f} Bohr = {R_eq * 0.529:.3f} Ã…")
print(f"å…¨ã‚¨ãƒãƒ«ã‚®ãƒ¼: E = {E_eq:.6f} Hartree = {E_eq * 27.2114:.3f} eV")
print(f"\nSCFåæŸ:")
print(f"  åå¾©å›æ•°: {result_eq['iterations']}")
print(f"  åæŸ: {result_eq['converged']}")
print(f"\nè»Œé“ã‚¨ãƒãƒ«ã‚®ãƒ¼ï¼ˆR = R_eqï¼‰:")
print(f"  çµåˆæ€§MO: Îµâ‚ = {result_eq['orbital_energies'][0]:.6f} Hartree")
print(f"  åçµåˆæ€§MO: Îµâ‚‚ = {result_eq['orbital_energies'][1]:.6f} Hartree")
</div>
        </div>

        <div class="content">
            <h2>ğŸ’» ä¾‹é¡Œ3.2: åŸºåº•é–¢æ•°ã¨Gaussianå‹è»Œé“</h2>

            <div class="theory-box">
                <h3>åŸºåº•é–¢æ•°ã®ç¨®é¡</h3>
                <p><strong>Slaterå‹è»Œé“ï¼ˆSTOï¼‰</strong>:</p>
                <p>\[
                \chi_{STO}(r) = N r^{n-1} e^{-\zeta r} Y_l^m(\theta, \phi)
                \]</p>
                <ul>
                    <li>åŸå­è»Œé“ã«è¿‘ã„å½¢çŠ¶</li>
                    <li>2é›»å­ç©åˆ†ã®è¨ˆç®—ãŒå›°é›£</li>
                </ul>
                <p><strong>Gaussianå‹è»Œé“ï¼ˆGTOï¼‰</strong>:</p>
                <p>\[
                \chi_{GTO}(r) = N r^{2n-2-l} e^{-\alpha r^2} Y_l^m(\theta, \phi)
                \]</p>
                <ul>
                    <li>2é›»å­ç©åˆ†ãŒè§£æçš„ã«è¨ˆç®—å¯èƒ½</li>
                    <li>è¤‡æ•°ã®Gaussianã§STOã‚’è¿‘ä¼¼ï¼ˆSTO-nGåŸºåº•ï¼‰</li>
                </ul>
                <p><strong>ç¸®ç´„GaussianåŸºåº•</strong>:</p>
                <p>\[
                \chi_{CGTO} = \sum_i d_i \chi_{GTO,i}
                \]</p>
                <p>ä»£è¡¨çš„ãªåŸºåº•ã‚»ãƒƒãƒˆï¼šSTO-3Gã€3-21Gã€6-31Gã€6-311Gã€cc-pVDZã€cc-pVTZãªã©</p>
            </div>

            <div class="code-title">Pythonå®Ÿè£…: Gaussianå‹åŸºåº•é–¢æ•°</div>
            <div class="code-example">import numpy as np
import matplotlib.pyplot as plt

def gaussian_1s(r, alpha):
    """Gaussianå‹1sè»Œé“ï¼ˆè¦æ ¼åŒ–æ¸ˆã¿ï¼‰"""
    N = (2 * alpha / np.pi)**(3/4)
    return N * np.exp(-alpha * r**2)

def slater_1s(r, zeta=1.0):
    """Slaterå‹1sè»Œé“ï¼ˆè¦æ ¼åŒ–æ¸ˆã¿ï¼‰"""
    N = (zeta**3 / np.pi)**0.5
    return N * np.exp(-zeta * r)

def sto_3g_1s(r):
    """STO-3GåŸºåº•ï¼ˆ3ã¤ã®Gaussianã§STOã‚’è¿‘ä¼¼ï¼‰"""
    # HåŸå­ã®1sè»Œé“ï¼ˆÎ¶=1.0ï¼‰ã«å¯¾ã™ã‚‹STO-3Gãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
    alphas = np.array([0.168856, 0.623913, 3.42525])
    coeffs = np.array([0.444635, 0.535328, 0.154329])

    result = np.zeros_like(r)
    for alpha, coeff in zip(alphas, coeffs):
        result += coeff * gaussian_1s(r, alpha)

    return result

# å‹•å¾„åº§æ¨™
r = np.linspace(0, 5, 500)

# ç•°ãªã‚‹åŸºåº•é–¢æ•°
psi_slater = slater_1s(r, zeta=1.0)
psi_sto3g = sto_3g_1s(r)
psi_gauss_single = gaussian_1s(r, alpha=0.3)

# å¯è¦–åŒ–
fig, axes = plt.subplots(2, 2, figsize=(14, 10))

# æ³¢å‹•é–¢æ•°ã®æ¯”è¼ƒ
ax1 = axes[0, 0]
ax1.plot(r, psi_slater, 'b-', linewidth=2, label='Slater 1s (Î¶=1.0)')
ax1.plot(r, psi_sto3g, 'r--', linewidth=2, label='STO-3G')
ax1.plot(r, psi_gauss_single, 'g:', linewidth=2, label='Single Gaussian (Î±=0.3)')

ax1.set_xlabel('r (Bohr)')
ax1.set_ylabel('Ïˆ(r)')
ax1.set_title('åŸºåº•é–¢æ•°ã®æ¯”è¼ƒ')
ax1.legend()
ax1.grid(True, alpha=0.3)

# å‹•å¾„ç¢ºç‡å¯†åº¦
ax2 = axes[0, 1]
ax2.plot(r, r**2 * psi_slater**2, 'b-', linewidth=2, label='Slater')
ax2.plot(r, r**2 * psi_sto3g**2, 'r--', linewidth=2, label='STO-3G')

ax2.set_xlabel('r (Bohr)')
ax2.set_ylabel('rÂ² |Ïˆ(r)|Â²')
ax2.set_title('å‹•å¾„ç¢ºç‡å¯†åº¦')
ax2.legend()
ax2.grid(True, alpha=0.3)

# STO-3Gã®æ§‹æˆGaussian
ax3 = axes[1, 0]
alphas_sto3g = np.array([0.168856, 0.623913, 3.42525])
coeffs_sto3g = np.array([0.444635, 0.535328, 0.154329])

for i, (alpha, coeff) in enumerate(zip(alphas_sto3g, coeffs_sto3g)):
    psi_component = coeff * gaussian_1s(r, alpha)
    ax3.plot(r, psi_component, linewidth=2, label=f'G{i+1} (Î±={alpha:.2f}, c={coeff:.3f})')

ax3.plot(r, psi_sto3g, 'k-', linewidth=3, label='STO-3G (sum)')
ax3.set_xlabel('r (Bohr)')
ax3.set_ylabel('Ïˆ(r)')
ax3.set_title('STO-3Gæ§‹æˆGaussian')
ax3.legend()
ax3.grid(True, alpha=0.3)

# åŸºåº•ã‚»ãƒƒãƒˆã‚µã‚¤ã‚ºã®åŠ¹æœï¼ˆæ¦‚å¿µçš„ï¼‰
ax4 = axes[1, 1]
basis_sets = ['Minimal\n(STO-3G)', 'Double-Î¶\n(6-31G)', 'Triple-Î¶\n(6-311G)', 'cc-pVDZ', 'cc-pVTZ']
n_functions = [1, 2, 3, 5, 14]  # HåŸå­ã§ã®é–¢æ•°æ•°ï¼ˆæ¦‚ç®—ï¼‰
relative_accuracy = [0.8, 0.92, 0.96, 0.98, 0.995]

x_pos = np.arange(len(basis_sets))
bars = ax4.bar(x_pos, relative_accuracy, color=['red', 'orange', 'yellow', 'lightgreen', 'green'])
ax4.set_ylabel('Relative accuracy')
ax4.set_title('åŸºåº•ã‚»ãƒƒãƒˆã‚µã‚¤ã‚ºã¨ç²¾åº¦')
ax4.set_xticks(x_pos)
ax4.set_xticklabels(basis_sets, rotation=15, ha='right')
ax4.set_ylim([0.7, 1.0])
ax4.grid(True, alpha=0.3, axis='y')

for i, (bar, n_func) in enumerate(zip(bars, n_functions)):
    height = bar.get_height()
    ax4.text(bar.get_x() + bar.get_width()/2., height + 0.01,
             f'{n_func} funcs', ha='center', va='bottom', fontsize=9)

plt.tight_layout()
plt.savefig('qchem_basis_functions.png', dpi=300, bbox_inches='tight')
plt.show()

# æ•°å€¤çµæœ
print("\n=== åŸºåº•é–¢æ•° ===\n")
print("STO-3G ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ï¼ˆH 1sï¼‰:")
for i, (alpha, coeff) in enumerate(zip(alphas_sto3g, coeffs_sto3g)):
    print(f"  Gaussian {i+1}: Î± = {alpha:.6f}, c = {coeff:.6f}")

print("\nåŸºåº•ã‚»ãƒƒãƒˆã®é¸æŠæŒ‡é‡:")
print("  - Minimalï¼ˆSTO-3Gï¼‰: å®šæ€§çš„ç†è§£ã€å¤§è¦æ¨¡ç³»")
print("  - Double-Î¶ï¼ˆ6-31Gï¼‰: æ¨™æº–è¨ˆç®—ã€åˆç†çš„ç²¾åº¦")
print("  - Triple-Î¶ï¼ˆ6-311Gï¼‰: é«˜ç²¾åº¦è¨ˆç®—")
print("  - cc-pVnZ: ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯è¨ˆç®—ã€ç›¸é–¢ã‚¨ãƒãƒ«ã‚®ãƒ¼")
</div>
        </div>

        <div class="content">
            <h2>ğŸ’» ä¾‹é¡Œ3.3: HÃ¼ckelåˆ†å­è»Œé“æ³•</h2>

            <div class="theory-box">
                <h3>HÃ¼ckelè¿‘ä¼¼</h3>
                <p>Ï€é›»å­ç³»ã®ç°¡æ˜“çš„åˆ†å­è»Œé“è¨ˆç®—æ³•ï¼š</p>
                <ul>
                    <li>Ïƒé›»å­ã¨Ï€é›»å­ã‚’åˆ†é›¢</li>
                    <li>Ï€é›»å­ã®ã¿ã‚’è€ƒæ…®ï¼ˆp_zè»Œé“ï¼‰</li>
                    <li>é‡ãªã‚Šç©åˆ†ã‚’ç„¡è¦–ï¼ˆS = Iï¼‰</li>
                </ul>
                <p><strong>HÃ¼ckel Hamiltonianè¡Œåˆ—</strong>:</p>
                <p>\[
                H_{ii} = \alpha \quad (\text{å¯¾è§’è¦ç´ })
                \]</p>
                <p>\[
                H_{ij} = \beta \quad (\text{éš£æ¥åŸå­}), \quad H_{ij} = 0 \quad (\text{ééš£æ¥})
                \]</p>
                <ul>
                    <li>\(\alpha\)ï¼šCoulombç©åˆ†ï¼ˆp_zè»Œé“ã®ã‚¨ãƒãƒ«ã‚®ãƒ¼ï¼‰</li>
                    <li>\(\beta\)ï¼šå…±é³´ç©åˆ†ï¼ˆè² ã®å€¤ã€çµåˆã‚¨ãƒãƒ«ã‚®ãƒ¼ã«å¯¾å¿œï¼‰</li>
                </ul>
            </div>

            <div class="code-title">Pythonå®Ÿè£…: ãƒ™ãƒ³ã‚¼ãƒ³ã®HÃ¼ckelè¨ˆç®—</div>
            <div class="code-example">import numpy as np
import matplotlib.pyplot as plt
from scipy.linalg import eigh

class HuckelMO:
    """HÃ¼ckelåˆ†å­è»Œé“æ³•"""

    def __init__(self, adjacency_matrix, alpha=0, beta=-1):
        """
        adjacency_matrix: éš£æ¥è¡Œåˆ—ï¼ˆçµåˆã®æœ‰ç„¡ï¼‰
        alpha: Coulombç©åˆ†ï¼ˆã‚¨ãƒãƒ«ã‚®ãƒ¼ã‚¼ãƒ­ç‚¹ï¼‰
        beta: å…±é³´ç©åˆ†
        """
        self.adjacency = adjacency_matrix
        self.n_atoms = len(adjacency_matrix)
        self.alpha = alpha
        self.beta = beta

    def build_hamiltonian(self):
        """HÃ¼ckel Hamiltonianè¡Œåˆ—"""
        H = self.alpha * np.eye(self.n_atoms) + self.beta * self.adjacency
        return H

    def solve(self):
        """å›ºæœ‰å€¤å•é¡Œã‚’è§£ã"""
        H = self.build_hamiltonian()
        eigenvalues, eigenvectors = eigh(H)

        # ã‚¨ãƒãƒ«ã‚®ãƒ¼é †ã«ã‚½ãƒ¼ãƒˆ
        idx = np.argsort(eigenvalues)
        eigenvalues = eigenvalues[idx]
        eigenvectors = eigenvectors[:, idx]

        return eigenvalues, eigenvectors

    def pi_energy(self, n_electrons):
        """Ï€é›»å­ã‚¨ãƒãƒ«ã‚®ãƒ¼"""
        eigenvalues, _ = self.solve()

        # å æœ‰è»Œé“ã®ã‚¨ãƒãƒ«ã‚®ãƒ¼åˆè¨ˆ
        n_occupied = n_electrons // 2  # å„è»Œé“ã«2é›»å­
        E_pi = 2 * np.sum(eigenvalues[:n_occupied])

        return E_pi

# ãƒ™ãƒ³ã‚¼ãƒ³ï¼ˆC6H6ï¼‰ã®éš£æ¥è¡Œåˆ—
benzene_adj = np.array([
    [0, 1, 0, 0, 0, 1],
    [1, 0, 1, 0, 0, 0],
    [0, 1, 0, 1, 0, 0],
    [0, 0, 1, 0, 1, 0],
    [0, 0, 0, 1, 0, 1],
    [1, 0, 0, 0, 1, 0]
])

# ãƒ–ã‚¿ã‚¸ã‚¨ãƒ³ï¼ˆC4H6ï¼‰ã®éš£æ¥è¡Œåˆ—
butadiene_adj = np.array([
    [0, 1, 0, 0],
    [1, 0, 1, 0],
    [0, 1, 0, 1],
    [0, 0, 1, 0]
])

# ã‚¨ãƒãƒ¬ãƒ³ï¼ˆC2H4ï¼‰
ethylene_adj = np.array([
    [0, 1],
    [1, 0]
])

# ãƒ™ãƒ³ã‚¼ãƒ³ã®è¨ˆç®—
benzene = HuckelMO(benzene_adj, alpha=0, beta=-1)
E_benzene, C_benzene = benzene.solve()
E_pi_benzene = benzene.pi_energy(6)  # 6å€‹ã®Ï€é›»å­

# ãƒ–ã‚¿ã‚¸ã‚¨ãƒ³ã®è¨ˆç®—
butadiene = HuckelMO(butadiene_adj, alpha=0, beta=-1)
E_butadiene, C_butadiene = butadiene.solve()

# å¯è¦–åŒ–
fig, axes = plt.subplots(2, 2, figsize=(14, 10))

# ãƒ™ãƒ³ã‚¼ãƒ³ã®ã‚¨ãƒãƒ«ã‚®ãƒ¼æº–ä½å›³
ax1 = axes[0, 0]
colors_benzene = ['blue', 'green', 'green', 'red', 'red', 'red']
occupancy_benzene = [2, 2, 2, 0, 0, 0]  # å„æº–ä½ã®é›»å­æ•°

for i, (E, occ, color) in enumerate(zip(E_benzene, occupancy_benzene, colors_benzene)):
    ax1.hlines(E, i-0.3, i+0.3, colors=color, linewidth=3)
    # é›»å­ã‚’è¡¨ç¤º
    if occ > 0:
        ax1.plot([i-0.1, i+0.1], [E, E], 'o', color='black', markersize=8)

ax1.axhline(0, color='k', linestyle='--', linewidth=1, label='Î± (reference)')
ax1.set_xticks(range(len(E_benzene)))
ax1.set_xticklabels([f'MO{i+1}' for i in range(len(E_benzene))])
ax1.set_ylabel('Energy (units of Î²)')
ax1.set_title('ãƒ™ãƒ³ã‚¼ãƒ³ã®HÃ¼ckel MOæº–ä½')
ax1.legend()
ax1.grid(True, alpha=0.3, axis='y')

# ãƒ–ã‚¿ã‚¸ã‚¨ãƒ³ã®ã‚¨ãƒãƒ«ã‚®ãƒ¼æº–ä½
ax2 = axes[0, 1]
for i, E in enumerate(E_butadiene):
    color = 'blue' if i < 2 else 'red'
    ax2.hlines(E, i-0.3, i+0.3, colors=color, linewidth=3)
    if i < 2:  # å æœ‰è»Œé“
        ax2.plot([i-0.1, i+0.1], [E, E], 'o', color='black', markersize=8)

ax2.axhline(0, color='k', linestyle='--', linewidth=1)
ax2.set_xticks(range(len(E_butadiene)))
ax2.set_xticklabels([f'Ï€{i+1}' for i in range(len(E_butadiene))])
ax2.set_ylabel('Energy (units of Î²)')
ax2.set_title('ãƒ–ã‚¿ã‚¸ã‚¨ãƒ³ã®HÃ¼ckel MOæº–ä½')
ax2.grid(True, alpha=0.3, axis='y')

# ãƒ™ãƒ³ã‚¼ãƒ³ã®åˆ†å­è»Œé“ä¿‚æ•°ï¼ˆHOMOï¼‰
ax3 = axes[1, 0]
homo_index = 2  # 3ç•ªç›®ã®MOï¼ˆ0-indexedï¼‰
homo_coeffs = C_benzene[:, homo_index]

theta = np.linspace(0, 2*np.pi, 7)
x_pos = np.cos(theta[:6])
y_pos = np.sin(theta[:6])

# ä¿‚æ•°ã®ç¬¦å·ã§è‰²åˆ†ã‘
colors_coeff = ['red' if c > 0 else 'blue' for c in homo_coeffs]
sizes = np.abs(homo_coeffs) * 500

ax3.scatter(x_pos, y_pos, s=sizes, c=colors_coeff, alpha=0.6, edgecolors='black', linewidth=2)

# ãƒ™ãƒ³ã‚¼ãƒ³ç’°ã‚’æç”»
for i in range(6):
    ax3.plot([x_pos[i], x_pos[(i+1)%6]], [y_pos[i], y_pos[(i+1)%6]], 'k-', linewidth=1)

ax3.set_xlim([-1.5, 1.5])
ax3.set_ylim([-1.5, 1.5])
ax3.set_aspect('equal')
ax3.set_title(f'ãƒ™ãƒ³ã‚¼ãƒ³HOMOï¼ˆMO{homo_index+1}ï¼‰ä¿‚æ•°')
ax3.set_xticks([])
ax3.set_yticks([])
ax3.text(0, -1.8, 'èµ¤: æ­£, é’: è² ', ha='center', fontsize=10)

# Ï€é›»å­ã‚¨ãƒãƒ«ã‚®ãƒ¼ã®å…±å½¹é–é•·ä¾å­˜æ€§
ax4 = axes[1, 1]
chain_lengths = range(2, 11)
pi_energies = []

for n in chain_lengths:
    # ç›´é–å…±å½¹ç³»ã®éš£æ¥è¡Œåˆ—
    adj = np.diag(np.ones(n-1), 1) + np.diag(np.ones(n-1), -1)
    mol = HuckelMO(adj, alpha=0, beta=-1)
    E_pi = mol.pi_energy(n)  # nå€‹ã®Ï€é›»å­
    pi_energies.append(E_pi)

ax4.plot(chain_lengths, pi_energies, 'go-', linewidth=2, markersize=8)
ax4.set_xlabel('Number of carbon atoms')
ax4.set_ylabel('Total Ï€ energy (units of Î²)')
ax4.set_title('å…±å½¹é–é•·ã¨Ï€é›»å­ã‚¨ãƒãƒ«ã‚®ãƒ¼')
ax4.grid(True, alpha=0.3)

plt.tight_layout()
plt.savefig('qchem_huckel_mo.png', dpi=300, bbox_inches='tight')
plt.show()

# æ•°å€¤çµæœ
print("\n=== HÃ¼ckelåˆ†å­è»Œé“æ³• ===\n")
print("ãƒ™ãƒ³ã‚¼ãƒ³ï¼ˆC6H6ï¼‰:")
print(f"  MOã‚¨ãƒãƒ«ã‚®ãƒ¼ï¼ˆÎ± + xÎ²ï¼‰:")
for i, E in enumerate(E_benzene):
    print(f"    MO{i+1}: E = Î± + ({E:.4f})Î²")
print(f"  ç·Ï€é›»å­ã‚¨ãƒãƒ«ã‚®ãƒ¼: E_Ï€ = {E_pi_benzene:.4f}Î²")
print(f"  å…±é³´å®‰å®šåŒ–ã‚¨ãƒãƒ«ã‚®ãƒ¼: {E_pi_benzene - 6*(-1):.4f}Î²")

print("\nãƒ–ã‚¿ã‚¸ã‚¨ãƒ³ï¼ˆC4H6ï¼‰:")
for i, E in enumerate(E_butadiene):
    print(f"  Ï€{i+1}: E = Î± + ({E:.4f})Î²")
</div>
        </div>

        <div class="content">
            <h2>ğŸ’» ä¾‹é¡Œ3.4: é›»å­ç›¸é–¢ã¨é…ç½®é–“ç›¸äº’ä½œç”¨</h2>

            <div class="theory-box">
                <h3>é›»å­ç›¸é–¢</h3>
                <p>Hartree-Fockæ³•ã§ã¯ã€å„é›»å­ã¯å¹³å‡å ´ä¸­ã‚’é‹å‹•ã™ã‚‹ã¨è¿‘ä¼¼ã—ã¾ã™ã€‚
                ã—ã‹ã—å®Ÿéš›ã«ã¯ã€é›»å­é–“ã®ç¬é–“çš„ãªç›¸äº’ä½œç”¨ï¼ˆ<strong>é›»å­ç›¸é–¢</strong>ï¼‰ãŒå­˜åœ¨ã—ã¾ã™ã€‚</p>
                <p><strong>ç›¸é–¢ã‚¨ãƒãƒ«ã‚®ãƒ¼</strong>:</p>
                <p>\[
                E_{corr} = E_{exact} - E_{HF}
                \]</p>
                <p>é›»å­ç›¸é–¢ã‚’å–ã‚Šå…¥ã‚Œã‚‹æ–¹æ³•ï¼š</p>
                <ul>
                    <li><strong>CIï¼ˆConfiguration Interactionï¼‰</strong>: åŠ±èµ·é…ç½®ã®æ··åˆ</li>
                    <li><strong>MP2ï¼ˆMÃ¸ller-Plessetæ‘‚å‹•è«–ï¼‰</strong>: æ‘‚å‹•å±•é–‹</li>
                    <li><strong>CCSDï¼ˆCoupled Clusterï¼‰</strong>: é«˜ç²¾åº¦post-HFæ³•</li>
                    <li><strong>DFTï¼ˆå¯†åº¦æ±é–¢æ•°ç†è«–ï¼‰</strong>: æ¬¡ç« ã§å­¦ç¿’</li>
                </ul>
            </div>

            <div class="code-title">Pythonå®Ÿè£…: CIè¨ˆç®—ã®æ¦‚å¿µï¼ˆ2é›»å­ç³»ï¼‰</div>
            <div class="code-example">import numpy as np
import matplotlib.pyplot as plt
from scipy.linalg import eigh

class SimpleCIS:
    """ç°¡æ˜“çš„ãªCISï¼ˆConfiguration Interaction Singlesï¼‰"""

    def __init__(self, n_orbitals=4):
        """
        n_orbitals: åˆ†å­è»Œé“ã®æ•°
        """
        self.n_orbitals = n_orbitals

        # ãƒ€ãƒŸãƒ¼ã®è»Œé“ã‚¨ãƒãƒ«ã‚®ãƒ¼ï¼ˆHartreeå˜ä½ï¼‰
        self.orbital_energies = np.array([
            -0.5,  # HOMO-1
            -0.3,  # HOMO
            0.2,   # LUMO
            0.4    # LUMO+1
        ])

        # é›»å­æ•°ï¼ˆ2é›»å­ç³»ã¨ä»®å®šï¼‰
        self.n_electrons = 2
        self.homo_index = 1  # 0-indexed

    def ground_state_energy(self):
        """åŸºåº•çŠ¶æ…‹ã‚¨ãƒãƒ«ã‚®ãƒ¼ï¼ˆHFï¼‰"""
        # å æœ‰è»Œé“ã®ã‚¨ãƒãƒ«ã‚®ãƒ¼åˆè¨ˆ
        E_HF = 2 * np.sum(self.orbital_energies[:self.n_electrons//2])
        return E_HF

    def single_excitations(self):
        """1é›»å­åŠ±èµ·é…ç½®"""
        excitations = []

        # HOMO â†’ LUMO, HOMO â†’ LUMO+1ãªã©
        for occ in range(self.n_electrons // 2):
            for virt in range(self.n_electrons // 2, self.n_orbitals):
                excitation_energy = self.orbital_energies[virt] - self.orbital_energies[occ]
                excitations.append({
                    'from': occ,
                    'to': virt,
                    'energy': excitation_energy
                })

        return excitations

    def cis_matrix(self):
        """CIS Hamiltonianè¡Œåˆ—ï¼ˆç°¡ç•¥ç‰ˆï¼‰"""
        excitations = self.single_excitations()
        n_exc = len(excitations)

        H_CIS = np.zeros((n_exc, n_exc))

        # å¯¾è§’è¦ç´ ï¼šåŠ±èµ·ã‚¨ãƒãƒ«ã‚®ãƒ¼
        for i, exc in enumerate(excitations):
            H_CIS[i, i] = exc['energy']

        # éå¯¾è§’è¦ç´ ï¼šé…ç½®é–“ç›¸äº’ä½œç”¨ï¼ˆç°¡ç•¥åŒ–ï¼šç„¡è¦–ï¼‰
        # å®Ÿéš›ã«ã¯Coulombç©åˆ†ã¨Exchangeç©åˆ†ã‚’è¨ˆç®—

        return H_CIS, excitations

    def solve_cis(self):
        """CISæ–¹ç¨‹å¼ã‚’è§£ã"""
        H_CIS, excitations = self.cis_matrix()
        eigenvalues, eigenvectors = eigh(H_CIS)

        return eigenvalues, eigenvectors, excitations

# CISè¨ˆç®—
cis = SimpleCIS(n_orbitals=4)
E_ground = cis.ground_state_energy()
exc_energies, exc_states, excitations = cis.solve_cis()

# å¯è¦–åŒ–
fig, axes = plt.subplots(2, 2, figsize=(14, 10))

# è»Œé“ã‚¨ãƒãƒ«ã‚®ãƒ¼å›³
ax1 = axes[0, 0]
orb_energies = cis.orbital_energies
colors_orb = ['blue', 'blue', 'red', 'red']
labels_orb = ['HOMO-1', 'HOMO', 'LUMO', 'LUMO+1']

for i, (E, color, label) in enumerate(zip(orb_energies, colors_orb, labels_orb)):
    ax1.hlines(E, i-0.3, i+0.3, colors=color, linewidth=3)
    if i < 2:  # å æœ‰è»Œé“
        ax1.plot([i-0.1, i+0.1], [E, E], 'o', color='black', markersize=8)
    ax1.text(i, E - 0.15, label, ha='center', fontsize=9)

ax1.axhline(0, color='k', linestyle='--', linewidth=1, label='Vacuum level')
ax1.set_xlim([-0.5, 3.5])
ax1.set_ylabel('Energy (Hartree)')
ax1.set_title('åˆ†å­è»Œé“ã‚¨ãƒãƒ«ã‚®ãƒ¼æº–ä½')
ax1.set_xticks([])
ax1.legend()
ax1.grid(True, alpha=0.3, axis='y')

# åŠ±èµ·çŠ¶æ…‹ã‚¨ãƒãƒ«ã‚®ãƒ¼
ax2 = axes[0, 1]
state_labels = [f"S{i+1}" for i in range(len(exc_energies))]

ax2.barh(range(len(exc_energies)), exc_energies, color='orange', edgecolor='black')
for i, (E, label) in enumerate(zip(exc_energies, state_labels)):
    ax2.text(E + 0.02, i, f'{label}: {E:.3f} Ha', va='center', fontsize=10)

ax2.set_xlabel('Excitation energy (Hartree)')
ax2.set_ylabel('Excited state')
ax2.set_title('CISåŠ±èµ·çŠ¶æ…‹')
ax2.set_yticks(range(len(exc_energies)))
ax2.set_yticklabels(state_labels)
ax2.grid(True, alpha=0.3, axis='x')

# åŠ±èµ·é…ç½®ã®æ§‹æˆï¼ˆæœ€åˆã®åŠ±èµ·çŠ¶æ…‹ï¼‰
ax3 = axes[1, 0]
state_idx = 0
state_vector = exc_states[:, state_idx]

x_pos = np.arange(len(state_vector))
ax3.bar(x_pos, np.abs(state_vector)**2, color='green', edgecolor='black')

exc_labels = [f"{exc['from']}â†’{exc['to']}" for exc in excitations]
ax3.set_xticks(x_pos)
ax3.set_xticklabels(exc_labels)
ax3.set_xlabel('Excitation')
ax3.set_ylabel('|Coefficient|Â²')
ax3.set_title(f'åŠ±èµ·çŠ¶æ…‹S{state_idx+1}ã®æ§‹æˆ')
ax3.grid(True, alpha=0.3, axis='y')

# ç›¸é–¢ã‚¨ãƒãƒ«ã‚®ãƒ¼ã®æ¦‚å¿µå›³
ax4 = axes[1, 1]
methods = ['HF', 'CIS', 'CISD', 'CCSD', 'FCI']
relative_corr = [0, 0.1, 0.5, 0.8, 1.0]  # ç›¸å¯¾çš„ãªç›¸é–¢ã‚¨ãƒãƒ«ã‚®ãƒ¼å›å¾©ç‡

colors_method = ['red', 'orange', 'yellow', 'lightgreen', 'green']
bars = ax4.barh(range(len(methods)), relative_corr, color=colors_method, edgecolor='black')

ax4.set_xlabel('Correlation energy recovery')
ax4.set_ylabel('Method')
ax4.set_title('é›»å­ç›¸é–¢ã®å–ã‚Šæ‰±ã„ï¼ˆæ¦‚å¿µå›³ï¼‰')
ax4.set_yticks(range(len(methods)))
ax4.set_yticklabels(methods)
ax4.set_xlim([0, 1.1])
ax4.grid(True, alpha=0.3, axis='x')

for i, (bar, corr) in enumerate(zip(bars, relative_corr)):
    width = bar.get_width()
    ax4.text(width + 0.02, bar.get_y() + bar.get_height()/2,
             f'{corr*100:.0f}%', va='center', fontsize=10)

plt.tight_layout()
plt.savefig('qchem_electron_correlation.png', dpi=300, bbox_inches='tight')
plt.show()

# æ•°å€¤çµæœ
print("\n=== é›»å­ç›¸é–¢ã¨CI ===\n")
print(f"åŸºåº•çŠ¶æ…‹ã‚¨ãƒãƒ«ã‚®ãƒ¼ï¼ˆHFï¼‰: {E_ground:.6f} Hartree")
print(f"\nåŠ±èµ·çŠ¶æ…‹ï¼ˆCISï¼‰:")
for i, E_exc in enumerate(exc_energies):
    print(f"  S{i+1}: Î”E = {E_exc:.6f} Hartree = {E_exc * 27.2114:.3f} eV")

print("\nPost-HFæ³•ã®éšå±¤:")
print("  HF: å¹³å‡å ´è¿‘ä¼¼ã€é›»å­ç›¸é–¢ãªã—")
print("  CIS: 1é›»å­åŠ±èµ·ã®ã¿ã€åŠ±èµ·çŠ¶æ…‹è¨ˆç®—")
print("  CISD: 1é›»å­ãƒ»2é›»å­åŠ±èµ·ã€ç›¸é–¢ã®ä¸€éƒ¨")
print("  CCSD: Coupled Clusterã€é«˜ç²¾åº¦")
print("  FCI: Full CIã€å³å¯†è§£ï¼ˆå°åˆ†å­ã®ã¿ï¼‰")
</div>
        </div>

        <div class="content">
            <h2>ğŸ“š ã¾ã¨ã‚</h2>
            <ul>
                <li><strong>Hartree-Fockæ³•</strong>ã¯å¤šé›»å­ç³»ã‚’å¹³å‡å ´è¿‘ä¼¼ã§è§£ãåŸºæœ¬æ‰‹æ³•</li>
                <li><strong>Fockæ¼”ç®—å­</strong>ã¯Coulombé …ã¨äº¤æ›é …ã‚’å«ã¿ã€è‡ªå·±ç„¡æ’ç€çš„ã«è§£ãå¿…è¦ãŒã‚ã‚‹</li>
                <li><strong>Roothaanæ–¹ç¨‹å¼</strong>ã«ã‚ˆã‚ŠåŸºåº•é–¢æ•°å±•é–‹ã§HFæ–¹ç¨‹å¼ã‚’è¡Œåˆ—å½¢å¼ã§è§£ã‘ã‚‹</li>
                <li><strong>SCFæ³•</strong>ã¯åå¾©è¨ˆç®—ã«ã‚ˆã‚Šè‡ªå·±ç„¡æ’ç€ãªè§£ã«åæŸã•ã›ã‚‹æ‰‹æ³•</li>
                <li><strong>Gaussianå‹åŸºåº•é–¢æ•°</strong>ã¯è¨ˆç®—åŠ¹ç‡ãŒé«˜ãã€å®Ÿç”¨è¨ˆç®—ã§åºƒãä½¿ã‚ã‚Œã‚‹</li>
                <li><strong>åŸºåº•ã‚»ãƒƒãƒˆ</strong>ã®é¸æŠã¯è¨ˆç®—ç²¾åº¦ã¨ã‚³ã‚¹ãƒˆã®ãƒˆãƒ¬ãƒ¼ãƒ‰ã‚ªãƒ•</li>
                <li><strong>HÃ¼ckelæ³•</strong>ã¯Ï€é›»å­ç³»ã®å®šæ€§çš„ç†è§£ã«æœ‰ç”¨ãªç°¡æ˜“æ‰‹æ³•</li>
                <li><strong>é›»å­ç›¸é–¢</strong>ã¯HFæ³•ã§ç„¡è¦–ã•ã‚Œã‚‹é‡è¦ãªé‡å­åŠ¹æœ</li>
                <li><strong>CIæ³•</strong>ãªã©ã®post-HFæ³•ã§é›»å­ç›¸é–¢ã‚’å–ã‚Šå…¥ã‚Œã€é«˜ç²¾åº¦è¨ˆç®—ãŒå¯èƒ½</li>
                <li>ã“ã‚Œã‚‰ã®æ‰‹æ³•ã¯å¯†åº¦æ±é–¢æ•°ç†è«–ï¼ˆDFTï¼‰ã®åŸºç¤ã¨ãªã‚‹</li>
            </ul>
        </div>

        <div class="exercise">
            <h3>ğŸ’¡ æ¼”ç¿’å•é¡Œ</h3>
            <ol>
                <li><strong>Hâ‚‚ã®STO-6Gè¨ˆç®—</strong>: STO-6GåŸºåº•ï¼ˆ6ã¤ã®Gaussianï¼‰ã‚’ç”¨ã„ã¦Hâ‚‚ã®SCFè¨ˆç®—ã‚’å®Ÿè£…ã—ã€STO-3Gã¨ã®é•ã„ã‚’èª¿ã¹ã‚ˆã€‚</li>
                <li><strong>HeHâºã‚¤ã‚ªãƒ³</strong>: HeHâºã®æœ€å°åŸºåº•SCFè¨ˆç®—ã‚’å®Ÿè£…ã—ã€ãƒãƒ†ãƒ³ã‚·ãƒ£ãƒ«æ›²ç·šã‚’æ±‚ã‚ã‚ˆã€‚</li>
                <li><strong>ãƒŠãƒ•ã‚¿ãƒ¬ãƒ³ã®HÃ¼ckelè¨ˆç®—</strong>: ãƒŠãƒ•ã‚¿ãƒ¬ãƒ³ï¼ˆCâ‚â‚€Hâ‚ˆï¼‰ã®éš£æ¥è¡Œåˆ—ã‚’ä½œæˆã—ã€HÃ¼ckel MOã‚¨ãƒãƒ«ã‚®ãƒ¼ã¨å…±é³´å®‰å®šåŒ–ã‚¨ãƒãƒ«ã‚®ãƒ¼ã‚’è¨ˆç®—ã›ã‚ˆã€‚</li>
                <li><strong>Koopmansã®å®šç†</strong>: HFè»Œé“ã‚¨ãƒãƒ«ã‚®ãƒ¼ã¨ç¬¬ä¸€ã‚¤ã‚ªãƒ³åŒ–ã‚¨ãƒãƒ«ã‚®ãƒ¼ã®é–¢ä¿‚ã‚’æ¤œè¨¼ã›ã‚ˆã€‚</li>
                <li><strong>åŸºåº•ã‚»ãƒƒãƒˆé‡ã­åˆã‚ã›èª¤å·®</strong>: Hâ‚‚è¨ˆç®—ã§åŸºåº•ã‚»ãƒƒãƒˆã‚µã‚¤ã‚ºã‚’å¤‰ãˆã¦ã€BSSEï¼ˆBasis Set Superposition Errorï¼‰ã®å½±éŸ¿ã‚’èª¿ã¹ã‚ˆã€‚</li>
            </ol>
        </div>

        <div class="navigation">
            <a href="chapter-2.html" class="nav-button">â† ç¬¬2ç« : åŸå­ãƒ»åˆ†å­ã®é‡å­è«–</a>
            <a href="chapter-4.html" class="nav-button">ç¬¬4ç« : å¯†åº¦æ±é–¢æ•°ç†è«–ï¼ˆDFTï¼‰ â†’</a>
        </div>
    </div>

    <footer>
        <p>&copy; 2025 AI Terakoya - Quantum Chemistry for Materials Science</p>
    </footer>
</body>
</html>
