<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter - AI Terakoya</title>

    <style>
        :root {
            --color-primary: #2c3e50;
            --color-primary-dark: #1a252f;
            --color-accent: #7b2cbf;
            --color-accent-light: #9d4edd;
            --color-text: #2d3748;
            --color-text-light: #4a5568;
            --color-bg: #ffffff;
            --color-bg-alt: #f7fafc;
            --color-border: #e2e8f0;
            --color-code-bg: #f8f9fa;
            --color-link: #3182ce;
            --color-link-hover: #2c5aa0;

            --spacing-xs: 0.5rem;
            --spacing-sm: 1rem;
            --spacing-md: 1.5rem;
            --spacing-lg: 2rem;
            --spacing-xl: 3rem;

            --font-body: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            --font-mono: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;

            --border-radius: 8px;
            --box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-body);
            line-height: 1.7;
            color: var(--color-text);
            background-color: var(--color-bg);
            font-size: 16px;
        }

        header {
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            color: white;
            padding: var(--spacing-xl) var(--spacing-md);
            margin-bottom: var(--spacing-xl);
            box-shadow: var(--box-shadow);
        }

        .header-content {
            max-width: 900px;
            margin: 0 auto;
        }

        h1 {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: var(--spacing-sm);
            line-height: 1.2;
        }

        .subtitle {
            font-size: 1.1rem;
            opacity: 0.95;
            font-weight: 400;
            margin-bottom: var(--spacing-md);
        }

        .meta {
            display: flex;
            flex-wrap: wrap;
            gap: var(--spacing-md);
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .meta-item {
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 0 var(--spacing-md) var(--spacing-xl);
        }

        h2 {
            font-size: 1.75rem;
            color: var(--color-primary);
            margin-top: var(--spacing-xl);
            margin-bottom: var(--spacing-md);
            padding-bottom: var(--spacing-xs);
            border-bottom: 3px solid var(--color-accent);
        }

        h3 {
            font-size: 1.4rem;
            color: var(--color-primary);
            margin-top: var(--spacing-lg);
            margin-bottom: var(--spacing-sm);
        }

        h4 {
            font-size: 1.1rem;
            color: var(--color-primary-dark);
            margin-top: var(--spacing-md);
            margin-bottom: var(--spacing-sm);
        }

        p {
            margin-bottom: var(--spacing-md);
            color: var(--color-text);
        }

        a {
            color: var(--color-link);
            text-decoration: none;
            transition: color 0.2s;
        }

        a:hover {
            color: var(--color-link-hover);
            text-decoration: underline;
        }

        ul, ol {
            margin-left: var(--spacing-lg);
            margin-bottom: var(--spacing-md);
        }

        li {
            margin-bottom: var(--spacing-xs);
            color: var(--color-text);
        }

        pre {
            background-color: var(--color-code-bg);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            overflow-x: auto;
            margin-bottom: var(--spacing-md);
            font-family: var(--font-mono);
            font-size: 0.9rem;
            line-height: 1.5;
        }

        code {
            font-family: var(--font-mono);
            font-size: 0.9em;
            background-color: var(--color-code-bg);
            padding: 0.2em 0.4em;
            border-radius: 3px;
        }

        pre code {
            background-color: transparent;
            padding: 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: var(--spacing-md);
            font-size: 0.95rem;
        }

        th, td {
            border: 1px solid var(--color-border);
            padding: var(--spacing-sm);
            text-align: left;
        }

        th {
            background-color: var(--color-bg-alt);
            font-weight: 600;
            color: var(--color-primary);
        }

        blockquote {
            border-left: 4px solid var(--color-accent);
            padding-left: var(--spacing-md);
            margin: var(--spacing-md) 0;
            color: var(--color-text-light);
            font-style: italic;
            background-color: var(--color-bg-alt);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        .mermaid {
            text-align: center;
            margin: var(--spacing-lg) 0;
            background-color: var(--color-bg-alt);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        details {
            background-color: var(--color-bg-alt);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            margin-bottom: var(--spacing-md);
        }

        summary {
            cursor: pointer;
            font-weight: 600;
            color: var(--color-primary);
            user-select: none;
            padding: var(--spacing-xs);
            margin: calc(-1 * var(--spacing-md));
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        summary:hover {
            background-color: rgba(123, 44, 191, 0.1);
        }

        details[open] summary {
            margin-bottom: var(--spacing-md);
            border-bottom: 1px solid var(--color-border);
        }

        .learning-objectives {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            padding: var(--spacing-lg);
            border-radius: var(--border-radius);
            border-left: 4px solid var(--color-accent);
            margin-bottom: var(--spacing-xl);
        }

        .learning-objectives h2 {
            margin-top: 0;
            border-bottom: none;
        }

        .navigation {
            display: flex;
            justify-content: space-between;
            gap: var(--spacing-md);
            margin: var(--spacing-xl) 0;
            padding-top: var(--spacing-lg);
            border-top: 2px solid var(--color-border);
        }

        .nav-button {
            flex: 1;
            padding: var(--spacing-md);
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            color: white;
            border-radius: var(--border-radius);
            text-align: center;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: var(--box-shadow);
        }

        .nav-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            text-decoration: none;
        }

        footer {
            margin-top: var(--spacing-xl);
            padding: var(--spacing-lg) var(--spacing-md);
            background-color: var(--color-bg-alt);
            border-top: 1px solid var(--color-border);
            text-align: center;
            font-size: 0.9rem;
            color: var(--color-text-light);
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.5rem;
            }

            h2 {
                font-size: 1.4rem;
            }

            h3 {
                font-size: 1.2rem;
            }

            .meta {
                font-size: 0.85rem;
            }

            .navigation {
                flex-direction: column;
            }

            table {
                font-size: 0.85rem;
            }

            th, td {
                padding: var(--spacing-xs);
            }
        }
    </style>

    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ startOnLoad: true, theme: 'default' });
    </script>

    <!-- MathJax for LaTeX equation rendering -->
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\(', '\)']],
                displayMath: [['$$', '$$'], ['\[', '\]']],
                processEscapes: true,
                processEnvironments: true
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
                ignoreHtmlClass: 'mermaid'
            }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" id="MathJax-script" async></script>
</head>
<body>
    <header>
        <div class="header-content">
            <h1>Chapter</h1>
            <p class="subtitle"></p>
            <div class="meta">
                <span class="meta-item">üìñ Ë™≠‰∫ÜÊôÇÈñì: 20-25ÂàÜ</span>
                <span class="meta-item">üìä Èõ£ÊòìÂ∫¶: ÂàùÁ¥ö</span>
                <span class="meta-item">üíª „Ç≥„Éº„Éâ‰æã: 0ÂÄã</span>
                <span class="meta-item">üìù ÊºîÁøíÂïèÈ°å: 0Âïè</span>
            </div>
        </div>
    </header>

    <main class="container">
<h1>Á¨¨4Á´†ÔºöÂÆüË∑µÁ∑® - GNN + Ê¨°ÂÖÉÂâäÊ∏õ„Å´„Çà„ÇãÊùêÊñô„Éû„ÉÉ„Éî„É≥„Ç∞</h1>
<h2>Ê¶ÇË¶Å</h2>
<p>Êú¨Á´†„Åß„ÅØ„ÄÅ„Åì„Çå„Åæ„ÅßÂ≠¶„Çì„Å†GNN„Å´„Çà„ÇãË°®ÁèæÂ≠¶ÁøíÔºàÁ¨¨3Á´†Ôºâ„Å®Ê¨°ÂÖÉÂâäÊ∏õÊâãÊ≥ïÔºàÁ¨¨2Á´†Ôºâ„ÇíÁµÑ„ÅøÂêà„Çè„Åõ„Åü„ÄÅÂÆüË∑µÁöÑ„Å™ÊùêÊñôÁ©∫Èñì„Éû„ÉÉ„Éî„É≥„Ç∞„Ç∑„Çπ„ÉÜ„É†„ÇíÊßãÁØâ„Åó„Åæ„Åô„ÄÇMaterials Project API„Åã„ÇâÂÆü„Éá„Éº„Çø„ÇíÂèñÂæó„Åó„ÄÅ„Ç®„É≥„Éâ„ÉÑ„Éº„Ç®„É≥„Éâ„ÅÆ„Éë„Ç§„Éó„É©„Ç§„É≥„ÇíÂÆüË£Ö„Åó„Åæ„Åô„ÄÇ</p>
<h3>Â≠¶ÁøíÁõÆÊ®ô</h3>
<ul>
<li>Materials Project API„ÇíÁî®„ÅÑ„ÅüÂÆü„Éá„Éº„ÇøÂèéÈõÜ„Åå„Åß„Åç„Çã</li>
<li>GNNÂ≠¶Áøí„Éë„Ç§„Éó„É©„Ç§„É≥„ÇíÊßãÁØâ„Åß„Åç„Çã</li>
<li>Â≠¶ÁøíÊ∏à„ÅøGNNÂüã„ÇÅËæº„Åø„ÇíÊ¨°ÂÖÉÂâäÊ∏õ„ÅßÂèØË¶ñÂåñ„Åß„Åç„Çã</li>
<li>„Ç§„É≥„Çø„É©„ÇØ„ÉÜ„Ç£„Éñ„Å™ÊùêÊñôÊé¢Á¥¢„Ç∑„Çπ„ÉÜ„É†„ÇíÂÆüË£Ö„Åß„Åç„Çã</li>
<li>ÂÆüÈöõ„ÅÆÊùêÊñôË®≠Ë®à„Çø„Çπ„ÇØ„Å´ÂøúÁî®„Åß„Åç„Çã</li>
</ul>
<h2>4.1 Áí∞Â¢ÉÊßãÁØâ„Å®„Éá„Éº„ÇøÂèéÈõÜ</h2>
<h3>„Ç≥„Éº„Éâ‰æã1: ÂøÖË¶Å„Å™„É©„Ç§„Éñ„É©„É™„ÅÆ„Ç§„É≥„Çπ„Éà„Éº„É´</h3>
<pre><code class="language-python"># ÂøÖË¶Å„Å™„É©„Ç§„Éñ„É©„É™„ÅÆ„Ç§„É≥„Çπ„Éà„Éº„É´ÔºàÂàùÂõû„ÅÆ„ÅøÂÆüË°åÔºâ
&quot;&quot;&quot;
!pip install pymatgen
!pip install mp-api
!pip install torch torchvision torchaudio
!pip install torch-geometric
!pip install torch-scatter torch-sparse torch-cluster torch-spline-conv -f https://data.pyg.org/whl/torch-2.0.0+cpu.html
!pip install umap-learn
!pip install plotly
!pip install bokeh
!pip install scikit-learn
!pip install pandas matplotlib seaborn
!pip install tqdm
&quot;&quot;&quot;

# „Ç§„É≥„Éù„Éº„Éà
import warnings
warnings.filterwarnings('ignore')

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

import torch
import torch.nn as nn
import torch.nn.functional as F
from torch_geometric.data import Data, Dataset, DataLoader

import umap
from sklearn.decomposition import PCA
from sklearn.manifold import TSNE
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split
from sklearn.cluster import KMeans

from tqdm import tqdm
import json
import pickle
from pathlib import Path

print(&quot;All libraries imported successfully!&quot;)
print(f&quot;PyTorch version: {torch.__version__}&quot;)
print(f&quot;CUDA available: {torch.cuda.is_available()}&quot;)
</code></pre>
<h3>„Ç≥„Éº„Éâ‰æã2: Materials Project API„ÅÆË®≠ÂÆö„Å®„Éá„Éº„ÇøÂèñÂæó</h3>
<pre><code class="language-python">from mp_api.client import MPRester
from pymatgen.core import Structure
import warnings
warnings.filterwarnings('ignore')

# API„Ç≠„Éº„ÅÆË®≠ÂÆöÔºàÁí∞Â¢ÉÂ§âÊï∞„Åæ„Åü„ÅØÁõ¥Êé•ÊåáÂÆöÔºâ
# MP_API_KEY = &quot;your_api_key_here&quot;  # https://next-gen.materialsproject.org/api „ÅßÂèñÂæó
# Ê≥®: ÂÆüÈöõ„ÅÆ„Éó„É≠„Ç∏„Çß„ÇØ„Éà„Åß„ÅØÁí∞Â¢ÉÂ§âÊï∞„Åã„ÇâË™≠„ÅøËæº„ÇÄ„Åì„Å®„ÇíÊé®Â•®

def fetch_materials_data(api_key, criteria, properties, max_materials=1000):
    &quot;&quot;&quot;
    Materials Project API„Åã„ÇâÊùêÊñô„Éá„Éº„Çø„ÇíÂèñÂæó

    Parameters:
    -----------
    api_key : str
        Materials Project API„Ç≠„Éº
    criteria : dict
        Ê§úÁ¥¢Êù°‰ª∂
    properties : list
        ÂèñÂæó„Åô„ÇãÁâπÊÄß„ÅÆ„É™„Çπ„Éà
    max_materials : int
        ÂèñÂæó„Åô„ÇãÊúÄÂ§ßÊùêÊñôÊï∞

    Returns:
    --------
    materials_df : pd.DataFrame
        ÊùêÊñô„Éá„Éº„Çø
    structures : list
        ÁµêÊô∂ÊßãÈÄ†„ÅÆ„É™„Çπ„Éà
    &quot;&quot;&quot;
    with MPRester(api_key) as mpr:
        # „Éá„Éº„Çø„ÅÆÂèñÂæó
        docs = mpr.materials.summary.search(
            **criteria,
            fields=properties,
            num_chunks=10,
            chunk_size=100
        )

        # ÊúÄÂ§ßÊï∞„Å´Âà∂Èôê
        docs = docs[:max_materials]

        print(f&quot;ÂèñÂæó„Åó„ÅüÊùêÊñôÊï∞: {len(docs)}&quot;)

        # DataFrame„Å´Â§âÊèõ
        data_dict = {prop: [] for prop in properties}
        data_dict['material_id'] = []
        data_dict['formula'] = []
        structures = []

        for doc in tqdm(docs, desc=&quot;„Éá„Éº„ÇøÂá¶ÁêÜ‰∏≠&quot;):
            try:
                data_dict['material_id'].append(doc.material_id)
                data_dict['formula'].append(str(doc.formula_pretty))

                for prop in properties:
                    if prop == 'structure':
                        structures.append(doc.structure)
                    else:
                        value = getattr(doc, prop, None)
                        data_dict[prop].append(value)

            except Exception as e:
                print(f&quot;Error processing {doc.material_id}: {e}&quot;)
                continue

        materials_df = pd.DataFrame(data_dict)
        materials_df = materials_df.dropna()  # Ê¨†ÊêçÂÄ§„ÇíÂê´„ÇÄË°å„ÇíÂâäÈô§

        print(f&quot;ÊúâÂäπ„Å™ÊùêÊñôÊï∞: {len(materials_df)}&quot;)

        return materials_df, structures


# ‰ΩøÁî®‰æãÔºà„ÉÄ„Éü„Éº„Éá„Éº„Çø„Åß‰ª£Êõø - ÂÆüÈöõ„ÅÆAPI„Ç≠„Éº„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅØ„Ç≥„É°„É≥„ÉàËß£Èô§Ôºâ
# criteria = {
#     &quot;band_gap&quot;: (0.5, 5.0),  # „Éê„É≥„Éâ„ÇÆ„É£„ÉÉ„Éó 0.5-5.0 eV
#     &quot;is_stable&quot;: True,       # ÂÆâÂÆö„Å™ÊùêÊñô„ÅÆ„Åø
#     &quot;nelements&quot;: (2, 3)      # 2-3ÂÖÉÁ¥†Á≥ª
# }
#
# properties = [
#     &quot;material_id&quot;, &quot;formula_pretty&quot;, &quot;structure&quot;,
#     &quot;band_gap&quot;, &quot;formation_energy_per_atom&quot;, &quot;density&quot;,
#     &quot;energy_above_hull&quot;, &quot;volume&quot;
# ]
#
# materials_df, structures = fetch_materials_data(
#     api_key=MP_API_KEY,
#     criteria=criteria,
#     properties=properties,
#     max_materials=1000
# )

# „ÉÄ„Éü„Éº„Éá„Éº„Çø„ÅÆÁîüÊàêÔºàAPI„Ç≠„Éº„Åå„Å™„ÅÑÂ†¥ÂêàÔºâ
print(&quot;\n„ÉÄ„Éü„Éº„Éá„Éº„Çø„ÇíÁîüÊàê„Åó„Åæ„Åô...&quot;)
from pymatgen.core import Lattice, Structure

np.random.seed(42)
n_materials = 1000

materials_df = pd.DataFrame({
    'material_id': [f'mp-{1000+i}' for i in range(n_materials)],
    'formula': [f'Material_{i}' for i in range(n_materials)],
    'band_gap': np.random.exponential(2.0, n_materials),
    'formation_energy_per_atom': np.random.normal(-1.5, 0.8, n_materials),
    'density': np.random.normal(5.0, 1.5, n_materials).clip(0.1),
    'energy_above_hull': np.random.exponential(0.05, n_materials),
    'volume': np.random.normal(50, 15, n_materials).clip(10)
})

# „ÉÄ„Éü„ÉºÁµêÊô∂ÊßãÈÄ†„ÅÆÁîüÊàê
structures = []
for i in range(n_materials):
    lattice = Lattice.cubic(4.0 + np.random.rand())
    n_atoms = np.random.randint(2, 8)
    species = np.random.choice(['Li', 'Na', 'K', 'O', 'S', 'Cl', 'F'], n_atoms)
    coords = np.random.rand(n_atoms, 3)
    structure = Structure(lattice, species, coords)
    structures.append(structure)

print(f&quot;„ÉÄ„Éü„ÉºÊùêÊñô„Éá„Éº„Çø„Çí {n_materials}ÂÄã ÁîüÊàê„Åó„Åæ„Åó„Åü&quot;)
print(&quot;\nÊùêÊñô„Éá„Éº„Çø„ÅÆÊúÄÂàù„ÅÆ5Ë°å:&quot;)
print(materials_df.head())
</code></pre>
<p><strong>Âá∫Âäõ‰æã</strong>:</p>
<pre><code>„ÉÄ„Éü„ÉºÊùêÊñô„Éá„Éº„Çø„Çí 1000ÂÄã ÁîüÊàê„Åó„Åæ„Åó„Åü

ÊùêÊñô„Éá„Éº„Çø„ÅÆÊúÄÂàù„ÅÆ5Ë°å:
  material_id      formula  band_gap  formation_energy_per_atom  density  energy_above_hull  volume
0     mp-1000  Material_0  1.234567                  -1.678901    4.567             0.012345  45.678
1     mp-1001  Material_1  2.345678                  -1.234567    5.678             0.023456  50.789
2     mp-1002  Material_2  0.987654                  -2.012345    3.456             0.001234  48.901
3     mp-1003  Material_3  3.456789                  -0.987654    6.789             0.034567  52.345
4     mp-1004  Material_4  1.876543                  -1.456789    4.890             0.009876  47.234
</code></pre>
<h3>„Ç≥„Éº„Éâ‰æã3: „Éá„Éº„Çø„ÅÆÊé¢Á¥¢ÁöÑÂàÜÊûê</h3>
<pre><code class="language-python">import matplotlib.pyplot as plt
import seaborn as sns

# Âü∫Êú¨Áµ±Ë®àÈáè
print(&quot;ÊùêÊñô„Éá„Éº„Çø„ÅÆÂü∫Êú¨Áµ±Ë®àÈáè:&quot;)
print(materials_df.describe())

# ÁâπÊÄß„ÅÆÂàÜÂ∏É
fig, axes = plt.subplots(2, 3, figsize=(18, 12))
axes = axes.ravel()

properties_to_plot = [
    'band_gap', 'formation_energy_per_atom', 'density',
    'energy_above_hull', 'volume'
]

for idx, prop in enumerate(properties_to_plot):
    axes[idx].hist(materials_df[prop], bins=50, alpha=0.7,
                   edgecolor='black', color='steelblue')
    axes[idx].set_xlabel(prop.replace('_', ' ').title(), fontsize=12, fontweight='bold')
    axes[idx].set_ylabel('Frequency', fontsize=12, fontweight='bold')
    axes[idx].set_title(f'Distribution of {prop.replace(&quot;_&quot;, &quot; &quot;).title()}',
                        fontsize=14, fontweight='bold')
    axes[idx].grid(True, alpha=0.3)

# ÊúÄÂæå„ÅÆ„Çµ„Éñ„Éó„É≠„ÉÉ„Éà„ÇíÈùûË°®Á§∫
axes[-1].axis('off')

plt.tight_layout()
plt.savefig('materials_data_distributions.png', dpi=300, bbox_inches='tight')
print(&quot;\nÁâπÊÄßÂàÜÂ∏É„Çí materials_data_distributions.png „Å´‰øùÂ≠ò„Åó„Åæ„Åó„Åü&quot;)
plt.show()

# Áõ∏Èñ¢Ë°åÂàó
correlation_matrix = materials_df[properties_to_plot].corr()

plt.figure(figsize=(10, 8))
sns.heatmap(correlation_matrix, annot=True, fmt='.3f', cmap='RdBu_r',
            center=0, square=True, linewidths=1, cbar_kws={&quot;shrink&quot;: 0.8})
plt.title('Correlation Matrix of Material Properties',
          fontsize=16, fontweight='bold', pad=20)
plt.tight_layout()
plt.savefig('materials_correlation_matrix.png', dpi=300, bbox_inches='tight')
print(&quot;Áõ∏Èñ¢Ë°åÂàó„Çí materials_correlation_matrix.png „Å´‰øùÂ≠ò„Åó„Åæ„Åó„Åü&quot;)
plt.show()
</code></pre>
<h2>4.2 „Ç∞„É©„Éï„Éá„Éº„Çø„Çª„ÉÉ„Éà„ÅÆÊßãÁØâ</h2>
<h3>„Ç≥„Éº„Éâ‰æã4: ÁµêÊô∂ÊßãÈÄ†„Åã„Çâ„Ç∞„É©„Éï„Å∏„ÅÆÂ§âÊèõÔºàÊúÄÈÅ©ÂåñÁâàÔºâ</h3>
<pre><code class="language-python">import torch
from torch_geometric.data import Data
from pymatgen.core import Structure
from pymatgen.core.periodic_table import Element
import numpy as np

class MaterialGraphConverter:
    &quot;&quot;&quot;ÁµêÊô∂ÊßãÈÄ†„Çí„Ç∞„É©„Éï„Å´Â§âÊèõ„Åô„Çã„ÇØ„É©„Çπ&quot;&quot;&quot;

    def __init__(self, cutoff=5.0, max_neighbors=12):
        self.cutoff = cutoff
        self.max_neighbors = max_neighbors

        # ÂéüÂ≠êÁâπÊÄß„ÅÆÂÆöÁæ©ÔºàÂÖÉÁ¥†Ë®òÂè∑ ‚Üí ÁâπÂæ¥„Éô„ÇØ„Éà„É´Ôºâ
        self._build_atom_features()

    def _build_atom_features(self):
        &quot;&quot;&quot;ÂéüÂ≠êÁâπÊÄßËæûÊõ∏„ÇíÊßãÁØâ&quot;&quot;&quot;
        # ‰∏ªË¶Å„Å™ÂÖÉÁ¥†„ÅÆÁâπÊÄß„Çí‰∫ãÂâçË®àÁÆó
        common_elements = [
            'H', 'He', 'Li', 'Be', 'B', 'C', 'N', 'O', 'F', 'Ne',
            'Na', 'Mg', 'Al', 'Si', 'P', 'S', 'Cl', 'Ar', 'K', 'Ca',
            'Sc', 'Ti', 'V', 'Cr', 'Mn', 'Fe', 'Co', 'Ni', 'Cu', 'Zn',
            'Ga', 'Ge', 'As', 'Se', 'Br', 'Kr', 'Rb', 'Sr', 'Y', 'Zr'
        ]

        self.atom_features = {}

        for symbol in common_elements:
            try:
                element = Element(symbol)

                features = [
                    element.Z / 100.0,  # Ê≠£Ë¶èÂåñ„Åï„Çå„ÅüÂéüÂ≠êÁï™Âè∑
                    element.atomic_mass / 200.0,  # Ê≠£Ë¶èÂåñ„Åï„Çå„ÅüÂéüÂ≠êÈáè
                    element.X if element.X is not None else 0.0,  # ÈõªÊ∞óÈô∞ÊÄßÂ∫¶
                    element.atomic_radius if element.atomic_radius is not None else 0.0,  # ÂéüÂ≠êÂçäÂæÑ
                    element.group if element.group is not None else 0.0,  # Êóè
                    element.row if element.row is not None else 0.0,  # Âë®Êúü
                ]

                self.atom_features[symbol] = features

            except Exception as e:
                print(f&quot;Warning: Could not process element {symbol}: {e}&quot;)
                self.atom_features[symbol] = [0.0] * 6

    def get_atom_features(self, species):
        &quot;&quot;&quot;ÂÖÉÁ¥†Ë®òÂè∑„Åã„ÇâÁâπÂæ¥„Éô„ÇØ„Éà„É´„ÇíÂèñÂæó&quot;&quot;&quot;
        symbol = str(species)
        if symbol in self.atom_features:
            return self.atom_features[symbol]
        else:
            # Êú™Áü•„ÅÆÂÖÉÁ¥†„ÅØ„Çº„É≠„Éô„ÇØ„Éà„É´
            return [0.0] * 6

    def structure_to_graph(self, structure, target=None):
        &quot;&quot;&quot;
        pymatgen Structure„ÇíPyTorch Geometric Data„Å´Â§âÊèõ

        Parameters:
        -----------
        structure : pymatgen.Structure
            ÁµêÊô∂ÊßãÈÄ†
        target : float, optional
            „Çø„Éº„Ç≤„ÉÉ„ÉàÂÄ§ÔºàÁâπÊÄß‰∫àÊ∏¨Áî®Ôºâ

        Returns:
        --------
        data : torch_geometric.data.Data
            „Ç∞„É©„Éï„Éá„Éº„Çø
        &quot;&quot;&quot;
        # „Éé„Éº„ÉâÁâπÂæ¥
        node_features = []
        for site in structure:
            features = self.get_atom_features(site.specie)
            node_features.append(features)

        node_features = torch.tensor(node_features, dtype=torch.float)

        # „Ç®„ÉÉ„Ç∏„ÅÆÊßãÁØâ
        all_neighbors = structure.get_all_neighbors(self.cutoff)
        edge_index = []
        edge_attr = []

        for i, neighbors in enumerate(all_neighbors):
            # Ë∑ùÈõ¢„Åß„ÇΩ„Éº„Éà„Åó„Å¶Ëøë„ÅÑÈ†Ü„Å´max_neighborsÂÄã„Åæ„Åß
            neighbors = sorted(neighbors, key=lambda x: x.nn_distance)[:self.max_neighbors]

            for neighbor in neighbors:
                j = neighbor.index
                distance = neighbor.nn_distance

                edge_index.append([i, j])
                edge_attr.append([distance])

        # „Ç®„ÉÉ„Ç∏„Åå„Å™„ÅÑÂ†¥Âêà„ÅÆÂá¶ÁêÜ
        if len(edge_index) == 0:
            edge_index = torch.zeros((2, 0), dtype=torch.long)
            edge_attr = torch.zeros((0, 1), dtype=torch.float)
        else:
            edge_index = torch.tensor(edge_index, dtype=torch.long).t().contiguous()
            edge_attr = torch.tensor(edge_attr, dtype=torch.float)

        # Data„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÅÆ‰ΩúÊàê
        data = Data(x=node_features, edge_index=edge_index, edge_attr=edge_attr)

        if target is not None:
            data.y = torch.tensor([target], dtype=torch.float)

        return data


# „Ç§„É≥„Çπ„Çø„É≥„ÇπÂåñ„Å®„ÉÜ„Çπ„Éà
converter = MaterialGraphConverter(cutoff=5.0, max_neighbors=12)

# ÊúÄÂàù„ÅÆÊùêÊñô„Åß„ÉÜ„Çπ„Éà
test_structure = structures[0]
test_target = materials_df.iloc[0]['band_gap']
test_graph = converter.structure_to_graph(test_structure, test_target)

print(&quot;„Ç∞„É©„ÉïÂ§âÊèõ„ÅÆ„ÉÜ„Çπ„Éà:&quot;)
print(f&quot;„Éé„Éº„ÉâÊï∞: {test_graph.num_nodes}&quot;)
print(f&quot;„Ç®„ÉÉ„Ç∏Êï∞: {test_graph.num_edges}&quot;)
print(f&quot;„Éé„Éº„ÉâÁâπÂæ¥Ê¨°ÂÖÉ: {test_graph.x.shape[1]}&quot;)
print(f&quot;„Çø„Éº„Ç≤„ÉÉ„ÉàÂÄ§: {test_graph.y.item():.3f}&quot;)
</code></pre>
<h3>„Ç≥„Éº„Éâ‰æã5: „Ç´„Çπ„Çø„É†„Éá„Éº„Çø„Çª„ÉÉ„Éà„ÇØ„É©„Çπ</h3>
<pre><code class="language-python">from torch_geometric.data import Dataset, Data
import torch
from tqdm import tqdm
import pickle

class MaterialsDataset(Dataset):
    &quot;&quot;&quot;
    ÊùêÊñô„Éá„Éº„Çø„Çª„ÉÉ„Éà

    Parameters:
    -----------
    structures : list
        pymatgen.Structure „ÅÆ„É™„Çπ„Éà
    targets : array-like
        „Çø„Éº„Ç≤„ÉÉ„ÉàÂÄ§
    converter : MaterialGraphConverter
        „Ç∞„É©„ÉïÂ§âÊèõÂô®
    root : str
        „Éá„Éº„Çø‰øùÂ≠òÂÖà„Éá„Ç£„É¨„ÇØ„Éà„É™
    transform : callable, optional
        „Éá„Éº„ÇøÂ§âÊèõÈñ¢Êï∞
    pre_transform : callable, optional
        ÂâçÂá¶ÁêÜÈñ¢Êï∞
    &quot;&quot;&quot;

    def __init__(self, structures, targets, converter,
                 root='data/materials', transform=None, pre_transform=None):
        self.structures = structures
        self.targets = targets
        self.converter = converter

        super().__init__(root, transform, pre_transform)

    @property
    def raw_file_names(self):
        return []

    @property
    def processed_file_names(self):
        return [f'data_{i}.pt' for i in range(len(self.structures))]

    def download(self):
        pass

    def process(self):
        &quot;&quot;&quot;ÊßãÈÄ†„Çí„Ç∞„É©„Éï„Å´Â§âÊèõ„Åó„Å¶‰øùÂ≠ò&quot;&quot;&quot;
        for idx in tqdm(range(len(self.structures)), desc=&quot;„Ç∞„É©„ÉïÂ§âÊèõ‰∏≠&quot;):
            structure = self.structures[idx]
            target = self.targets[idx]

            # „Ç∞„É©„Éï„Å∏„ÅÆÂ§âÊèõ
            data = self.converter.structure_to_graph(structure, target)

            if self.pre_transform is not None:
                data = self.pre_transform(data)

            # ‰øùÂ≠ò
            torch.save(data, self.processed_paths[idx])

    def len(self):
        return len(self.structures)

    def get(self, idx):
        data = torch.load(self.processed_paths[idx])
        return data


# „Éá„Éº„Çø„Çª„ÉÉ„Éà„ÅÆ‰ΩúÊàê
print(&quot;„Éá„Éº„Çø„Çª„ÉÉ„Éà„Çí‰ΩúÊàê‰∏≠...&quot;)

# „Çø„Éº„Ç≤„ÉÉ„ÉàÁâπÊÄßÔºà„Éê„É≥„Éâ„ÇÆ„É£„ÉÉ„ÉóÔºâ
targets = materials_df['band_gap'].values

# „Éá„Éº„Çø„Çª„ÉÉ„Éà„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„ÇπÂåñ
dataset = MaterialsDataset(
    structures=structures,
    targets=targets,
    converter=converter,
    root='data/materials_dataset'
)

print(f&quot;\n„Éá„Éº„Çø„Çª„ÉÉ„Éà‰ΩúÊàêÂÆå‰∫ÜÔºÅ&quot;)
print(f&quot;„Éá„Éº„Çø„Çª„ÉÉ„Éà„Çµ„Ç§„Ç∫: {len(dataset)}&quot;)
print(f&quot;„Çµ„É≥„Éó„É´„Éá„Éº„Çø:&quot;)
print(dataset[0])
</code></pre>
<p><strong>Âá∫Âäõ‰æã</strong>:</p>
<pre><code>„Ç∞„É©„ÉïÂ§âÊèõ‰∏≠: 100%|‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà| 1000/1000 [00:15&lt;00:00, 63.42it/s]

„Éá„Éº„Çø„Çª„ÉÉ„Éà‰ΩúÊàêÂÆå‰∫ÜÔºÅ
„Éá„Éº„Çø„Çª„ÉÉ„Éà„Çµ„Ç§„Ç∫: 1000
„Çµ„É≥„Éó„É´„Éá„Éº„Çø:
Data(x=[5, 6], edge_index=[2, 48], edge_attr=[48, 1], y=[1])
</code></pre>
<h3>„Ç≥„Éº„Éâ‰æã6: „Éá„Éº„Çø„Çª„ÉÉ„Éà„ÅÆÂàÜÂâ≤„Å®DataLoader</h3>
<pre><code class="language-python">from torch_geometric.loader import DataLoader
from sklearn.model_selection import train_test_split
import torch

# „Éá„Éº„Çø„Çª„ÉÉ„Éà„ÅÆ„Ç§„É≥„Éá„ÉÉ„ÇØ„ÇπÂàÜÂâ≤
train_idx, temp_idx = train_test_split(
    range(len(dataset)), test_size=0.3, random_state=42
)
val_idx, test_idx = train_test_split(
    temp_idx, test_size=0.5, random_state=42
)

# „Çµ„Éñ„Çª„ÉÉ„Éà„ÅÆ‰ΩúÊàê
train_dataset = dataset[train_idx]
val_dataset = dataset[val_idx]
test_dataset = dataset[test_idx]

print(f&quot;„Éá„Éº„ÇøÂàÜÂâ≤:&quot;)
print(f&quot;  Â≠¶Áøí„Éá„Éº„Çø: {len(train_dataset)}&quot;)
print(f&quot;  Ê§úË®º„Éá„Éº„Çø: {len(val_dataset)}&quot;)
print(f&quot;  „ÉÜ„Çπ„Éà„Éá„Éº„Çø: {len(test_dataset)}&quot;)

# DataLoader„ÅÆ‰ΩúÊàê
batch_size = 32

train_loader = DataLoader(train_dataset, batch_size=batch_size, shuffle=True)
val_loader = DataLoader(val_dataset, batch_size=batch_size, shuffle=False)
test_loader = DataLoader(test_dataset, batch_size=batch_size, shuffle=False)

# DataLoader„ÅÆ„ÉÜ„Çπ„Éà
batch = next(iter(train_loader))
print(f&quot;\n„Éê„ÉÉ„ÉÅ„Éá„Éº„Çø:&quot;)
print(f&quot;  „Éê„ÉÉ„ÉÅ„Çµ„Ç§„Ç∫: {batch.num_graphs}&quot;)
print(f&quot;  Á∑è„Éé„Éº„ÉâÊï∞: {batch.num_nodes}&quot;)
print(f&quot;  Á∑è„Ç®„ÉÉ„Ç∏Êï∞: {batch.num_edges}&quot;)
print(f&quot;  „Éé„Éº„ÉâÁâπÂæ¥ÂΩ¢Áä∂: {batch.x.shape}&quot;)
print(f&quot;  „Çø„Éº„Ç≤„ÉÉ„ÉàÂΩ¢Áä∂: {batch.y.shape}&quot;)
</code></pre>
<p><strong>Âá∫Âäõ‰æã</strong>:</p>
<pre><code>„Éá„Éº„ÇøÂàÜÂâ≤:
  Â≠¶Áøí„Éá„Éº„Çø: 700
  Ê§úË®º„Éá„Éº„Çø: 150
  „ÉÜ„Çπ„Éà„Éá„Éº„Çø: 150

„Éê„ÉÉ„ÉÅ„Éá„Éº„Çø:
  „Éê„ÉÉ„ÉÅ„Çµ„Ç§„Ç∫: 32
  Á∑è„Éé„Éº„ÉâÊï∞: 168
  Á∑è„Ç®„ÉÉ„Ç∏Êï∞: 1568
  „Éé„Éº„ÉâÁâπÂæ¥ÂΩ¢Áä∂: torch.Size([168, 6])
  „Çø„Éº„Ç≤„ÉÉ„ÉàÂΩ¢Áä∂: torch.Size([32, 1])
</code></pre>
<h2>4.3 GNN„É¢„Éá„É´„ÅÆÂ≠¶Áøí</h2>
<h3>„Ç≥„Éº„Éâ‰æã7: ÊîπËâØÁâàCGCNN„É¢„Éá„É´</h3>
<pre><code class="language-python">import torch
import torch.nn as nn
import torch.nn.functional as F
from torch_geometric.nn import MessagePassing, global_mean_pool, global_add_pool, global_max_pool

class ImprovedCGConv(MessagePassing):
    &quot;&quot;&quot;ÊîπËâØÁâàCGCNNÁï≥„ÅøËæº„ÅøÂ±§&quot;&quot;&quot;

    def __init__(self, node_dim, edge_dim, hidden_dim=128):
        super().__init__(aggr='add')

        self.node_dim = node_dim
        self.edge_dim = edge_dim
        self.hidden_dim = hidden_dim

        # „Ç®„ÉÉ„Ç∏„Éç„ÉÉ„Éà„ÉØ„Éº„ÇØ
        self.edge_network = nn.Sequential(
            nn.Linear(2 * node_dim + edge_dim, hidden_dim),
            nn.BatchNorm1d(hidden_dim),
            nn.Softplus(),
            nn.Linear(hidden_dim, hidden_dim),
            nn.BatchNorm1d(hidden_dim),
            nn.Softplus()
        )

        # „Ç≤„Éº„Éà„Éç„ÉÉ„Éà„ÉØ„Éº„ÇØ
        self.gate_network = nn.Sequential(
            nn.Linear(2 * node_dim + edge_dim, hidden_dim),
            nn.Sigmoid()
        )

        # „Éé„Éº„ÉâÊõ¥Êñ∞„Éç„ÉÉ„Éà„ÉØ„Éº„ÇØ
        self.node_update = nn.Sequential(
            nn.Linear(node_dim + hidden_dim, hidden_dim),
            nn.BatchNorm1d(hidden_dim),
            nn.Softplus(),
            nn.Linear(hidden_dim, hidden_dim)
        )

    def forward(self, x, edge_index, edge_attr):
        return self.propagate(edge_index, x=x, edge_attr=edge_attr)

    def message(self, x_i, x_j, edge_attr):
        &quot;&quot;&quot;„É°„ÉÉ„Çª„Éº„Ç∏Èñ¢Êï∞&quot;&quot;&quot;
        # ÈÄÅ‰ø°ÂÖÉ„ÄÅÂèó‰ø°ÂÖà„ÄÅ„Ç®„ÉÉ„Ç∏ÁâπÂæ¥„ÇíÁµêÂêà
        z = torch.cat([x_i, x_j, edge_attr], dim=1)

        # „Ç≤„Éº„ÉÜ„Ç£„É≥„Ç∞Ê©üÊßã
        gate = self.gate_network(z)
        message = self.edge_network(z)

        return gate * message

    def update(self, aggr_out, x):
        &quot;&quot;&quot;„Éé„Éº„ÉâÊõ¥Êñ∞&quot;&quot;&quot;
        combined = torch.cat([x, aggr_out], dim=1)
        return self.node_update(combined)


class ImprovedCGCNN(nn.Module):
    &quot;&quot;&quot;ÊîπËâØÁâàCGCNN„É¢„Éá„É´&quot;&quot;&quot;

    def __init__(self, node_dim, edge_dim, hidden_dim=128,
                 num_conv=4, dropout=0.2, pooling='mean'):
        super().__init__()

        self.node_dim = node_dim
        self.edge_dim = edge_dim
        self.hidden_dim = hidden_dim
        self.num_conv = num_conv
        self.pooling = pooling

        # ÂÖ•ÂäõÂüã„ÇÅËæº„Åø
        self.node_embedding = nn.Sequential(
            nn.Linear(node_dim, hidden_dim),
            nn.BatchNorm1d(hidden_dim),
            nn.Softplus()
        )

        # CGConvÂ±§
        self.conv_layers = nn.ModuleList([
            ImprovedCGConv(hidden_dim, edge_dim, hidden_dim)
            for _ in range(num_conv)
        ])

        # Batch Normalization
        self.bn_layers = nn.ModuleList([
            nn.BatchNorm1d(hidden_dim)
            for _ in range(num_conv)
        ])

        # Dropout
        self.dropout = nn.Dropout(dropout)

        # „Éó„Éº„É™„É≥„Ç∞
        if pooling == 'mean':
            self.pool = global_mean_pool
        elif pooling == 'add':
            self.pool = global_add_pool
        elif pooling == 'max':
            self.pool = global_max_pool
        else:
            raise ValueError(f&quot;Unknown pooling: {pooling}&quot;)

        # Âá∫Âäõ„Éç„ÉÉ„Éà„ÉØ„Éº„ÇØ
        self.fc = nn.Sequential(
            nn.Linear(hidden_dim, hidden_dim // 2),
            nn.BatchNorm1d(hidden_dim // 2),
            nn.Softplus(),
            nn.Dropout(dropout),
            nn.Linear(hidden_dim // 2, hidden_dim // 4),
            nn.BatchNorm1d(hidden_dim // 4),
            nn.Softplus(),
            nn.Dropout(dropout),
            nn.Linear(hidden_dim // 4, 1)
        )

    def forward(self, data, return_embedding=False):
        &quot;&quot;&quot;
        È†Ü‰ºùÊí≠

        Parameters:
        -----------
        data : torch_geometric.data.Batch
            „Éê„ÉÉ„ÉÅ„Éá„Éº„Çø
        return_embedding : bool
            Âüã„ÇÅËæº„Åø„ÇíËøî„Åô„Åã

        Returns:
        --------
        out : Tensor
            ‰∫àÊ∏¨ÂÄ§
        embedding : Tensor (optional)
            „Ç∞„É©„ÉïÂüã„ÇÅËæº„Åø
        &quot;&quot;&quot;
        x, edge_index, edge_attr, batch = data.x, data.edge_index, data.edge_attr, data.batch

        # ÂÖ•ÂäõÂüã„ÇÅËæº„Åø
        x = self.node_embedding(x)

        # CGConvÂ±§„ÅÆÈÅ©Áî®
        for conv, bn in zip(self.conv_layers, self.bn_layers):
            x_new = conv(x, edge_index, edge_attr)
            x_new = bn(x_new)
            x_new = F.softplus(x_new)
            x_new = self.dropout(x_new)

            # ÊÆãÂ∑ÆÊé•Á∂ö
            x = x + x_new

        # „Ç∞„É©„Éï„É¨„Éô„É´„ÅÆ„Éó„Éº„É™„É≥„Ç∞
        graph_embedding = self.pool(x, batch)

        # Âá∫Âäõ
        out = self.fc(graph_embedding)

        if return_embedding:
            return out, graph_embedding
        else:
            return out


# „É¢„Éá„É´„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„ÇπÂåñ
device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')

model = ImprovedCGCNN(
    node_dim=6,
    edge_dim=1,
    hidden_dim=128,
    num_conv=4,
    dropout=0.2,
    pooling='mean'
).to(device)

print(f&quot;„É¢„Éá„É´„ÅÆÁ∑è„Éë„É©„É°„Éº„ÇøÊï∞: {sum(p.numel() for p in model.parameters()):,}&quot;)

# „ÉÜ„Çπ„Éà
batch = next(iter(train_loader)).to(device)
predictions, embeddings = model(batch, return_embedding=True)

print(f&quot;\n‰∫àÊ∏¨ÂÄ§„ÅÆÂΩ¢Áä∂: {predictions.shape}&quot;)
print(f&quot;Âüã„ÇÅËæº„Åø„ÅÆÂΩ¢Áä∂: {embeddings.shape}&quot;)
</code></pre>
<h3>„Ç≥„Éº„Éâ‰æã8: Â≠¶Áøí„É´„Éº„ÉóÔºàEarly Stopping‰ªò„ÅçÔºâ</h3>
<pre><code class="language-python">import torch
import torch.optim as optim
from torch.optim.lr_scheduler import ReduceLROnPlateau
import numpy as np
from tqdm import tqdm
import time

class EarlyStopping:
    &quot;&quot;&quot;Early Stopping„ÇØ„É©„Çπ&quot;&quot;&quot;

    def __init__(self, patience=20, delta=0.001, path='best_model.pt'):
        self.patience = patience
        self.delta = delta
        self.path = path
        self.counter = 0
        self.best_score = None
        self.early_stop = False
        self.val_loss_min = np.Inf

    def __call__(self, val_loss, model):
        score = -val_loss

        if self.best_score is None:
            self.best_score = score
            self.save_checkpoint(val_loss, model)
        elif score &lt; self.best_score + self.delta:
            self.counter += 1
            if self.counter &gt;= self.patience:
                self.early_stop = True
        else:
            self.best_score = score
            self.save_checkpoint(val_loss, model)
            self.counter = 0

    def save_checkpoint(self, val_loss, model):
        torch.save(model.state_dict(), self.path)
        self.val_loss_min = val_loss


def train_epoch(model, loader, criterion, optimizer, device):
    &quot;&quot;&quot;1„Ç®„Éù„ÉÉ„ÇØ„ÅÆÂ≠¶Áøí&quot;&quot;&quot;
    model.train()
    total_loss = 0
    total_samples = 0

    for batch in loader:
        batch = batch.to(device)

        optimizer.zero_grad()
        predictions = model(batch)
        loss = criterion(predictions, batch.y)

        loss.backward()
        optimizer.step()

        total_loss += loss.item() * batch.num_graphs
        total_samples += batch.num_graphs

    return total_loss / total_samples


def validate_epoch(model, loader, criterion, device):
    &quot;&quot;&quot;1„Ç®„Éù„ÉÉ„ÇØ„ÅÆÊ§úË®º&quot;&quot;&quot;
    model.eval()
    total_loss = 0
    total_samples = 0

    with torch.no_grad():
        for batch in loader:
            batch = batch.to(device)

            predictions = model(batch)
            loss = criterion(predictions, batch.y)

            total_loss += loss.item() * batch.num_graphs
            total_samples += batch.num_graphs

    return total_loss / total_samples


# Â≠¶ÁøíË®≠ÂÆö
criterion = nn.MSELoss()
optimizer = optim.Adam(model.parameters(), lr=0.001, weight_decay=1e-5)
scheduler = ReduceLROnPlateau(optimizer, mode='min', factor=0.5,
                              patience=10, verbose=True)
early_stopping = EarlyStopping(patience=30, delta=0.001,
                               path='best_cgcnn_model.pt')

# Â≠¶Áøí„É´„Éº„Éó
num_epochs = 200
train_losses = []
val_losses = []

print(&quot;Â≠¶ÁøíÈñãÂßã...&quot;)
start_time = time.time()

for epoch in range(num_epochs):
    # Â≠¶Áøí
    train_loss = train_epoch(model, train_loader, criterion, optimizer, device)
    train_losses.append(train_loss)

    # Ê§úË®º
    val_loss = validate_epoch(model, val_loader, criterion, device)
    val_losses.append(val_loss)

    # Â≠¶ÁøíÁéá„Çπ„Ç±„Ç∏„É•„Éº„É©
    scheduler.step(val_loss)

    # Early Stopping
    early_stopping(val_loss, model)

    if (epoch + 1) % 10 == 0:
        elapsed_time = time.time() - start_time
        print(f&quot;Epoch [{epoch+1}/{num_epochs}] - &quot;
              f&quot;Train Loss: {train_loss:.4f}, Val Loss: {val_loss:.4f} - &quot;
              f&quot;Time: {elapsed_time:.1f}s&quot;)

    if early_stopping.early_stop:
        print(f&quot;Early stopping at epoch {epoch+1}&quot;)
        break

total_time = time.time() - start_time
print(f&quot;\nÂ≠¶ÁøíÂÆå‰∫ÜÔºÅ Á∑èÊôÇÈñì: {total_time/60:.1f}ÂàÜ&quot;)

# „Éô„Çπ„Éà„É¢„Éá„É´„ÅÆ„É≠„Éº„Éâ
model.load_state_dict(torch.load('best_cgcnn_model.pt'))
print(f&quot;„Éô„Çπ„Éà„É¢„Éá„É´„Çí„É≠„Éº„Éâ„Åó„Åæ„Åó„Åü (Val Loss: {early_stopping.val_loss_min:.4f})&quot;)
</code></pre>
<p><strong>Âá∫Âäõ‰æã</strong>:</p>
<pre><code>Â≠¶ÁøíÈñãÂßã...
Epoch [10/200] - Train Loss: 1.2345, Val Loss: 1.3456 - Time: 15.3s
Epoch [20/200] - Train Loss: 0.9876, Val Loss: 1.1234 - Time: 30.7s
Epoch [30/200] - Train Loss: 0.7654, Val Loss: 1.0123 - Time: 46.1s
Epoch [40/200] - Train Loss: 0.6543, Val Loss: 0.9876 - Time: 61.5s
Epoch [50/200] - Train Loss: 0.5678, Val Loss: 0.9654 - Time: 76.9s
Early stopping at epoch 85

Â≠¶ÁøíÂÆå‰∫ÜÔºÅ Á∑èÊôÇÈñì: 2.3ÂàÜ
„Éô„Çπ„Éà„É¢„Éá„É´„Çí„É≠„Éº„Éâ„Åó„Åæ„Åó„Åü (Val Loss: 0.9234)
</code></pre>
<h3>„Ç≥„Éº„Éâ‰æã9: Â≠¶ÁøíÊõ≤Á∑ö„ÅÆÂèØË¶ñÂåñ</h3>
<pre><code class="language-python">import matplotlib.pyplot as plt
import numpy as np

# Â≠¶ÁøíÊõ≤Á∑ö
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 6))

# LossÊõ≤Á∑ö
epochs = range(1, len(train_losses) + 1)
ax1.plot(epochs, train_losses, label='Train Loss', linewidth=2, color='blue')
ax1.plot(epochs, val_losses, label='Validation Loss', linewidth=2, color='red')
ax1.set_xlabel('Epoch', fontsize=14, fontweight='bold')
ax1.set_ylabel('MSE Loss', fontsize=14, fontweight='bold')
ax1.set_title('Training and Validation Loss', fontsize=16, fontweight='bold')
ax1.legend(fontsize=12)
ax1.grid(True, alpha=0.3)

# ÂØæÊï∞„Çπ„Ç±„Éº„É´
ax2.semilogy(epochs, train_losses, label='Train Loss', linewidth=2, color='blue')
ax2.semilogy(epochs, val_losses, label='Validation Loss', linewidth=2, color='red')
ax2.set_xlabel('Epoch', fontsize=14, fontweight='bold')
ax2.set_ylabel('MSE Loss (log scale)', fontsize=14, fontweight='bold')
ax2.set_title('Training Curve (Log Scale)', fontsize=16, fontweight='bold')
ax2.legend(fontsize=12)
ax2.grid(True, alpha=0.3, which='both')

plt.tight_layout()
plt.savefig('training_curve.png', dpi=300, bbox_inches='tight')
print(&quot;Â≠¶ÁøíÊõ≤Á∑ö„Çí training_curve.png „Å´‰øùÂ≠ò„Åó„Åæ„Åó„Åü&quot;)
plt.show()
</code></pre>
<h3>„Ç≥„Éº„Éâ‰æã10: „ÉÜ„Çπ„Éà„Éá„Éº„Çø„Åß„ÅÆË©ï‰æ°</h3>
<pre><code class="language-python">from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score
import matplotlib.pyplot as plt
import numpy as np

def evaluate_model(model, loader, device):
    &quot;&quot;&quot;„É¢„Éá„É´„ÅÆË©ï‰æ°&quot;&quot;&quot;
    model.eval()

    all_predictions = []
    all_targets = []

    with torch.no_grad():
        for batch in loader:
            batch = batch.to(device)

            predictions = model(batch)

            all_predictions.append(predictions.cpu().numpy())
            all_targets.append(batch.y.cpu().numpy())

    predictions = np.concatenate(all_predictions, axis=0).flatten()
    targets = np.concatenate(all_targets, axis=0).flatten()

    return predictions, targets


# „ÉÜ„Çπ„Éà„Éá„Éº„Çø„Åß„ÅÆË©ï‰æ°
test_predictions, test_targets = evaluate_model(model, test_loader, device)

# Ë©ï‰æ°ÊåáÊ®ô„ÅÆË®àÁÆó
mae = mean_absolute_error(test_targets, test_predictions)
rmse = np.sqrt(mean_squared_error(test_targets, test_predictions))
r2 = r2_score(test_targets, test_predictions)

print(&quot;„ÉÜ„Çπ„Éà„Éá„Éº„Çø„Åß„ÅÆË©ï‰æ°:&quot;)
print(f&quot;  MAE:  {mae:.4f}&quot;)
print(f&quot;  RMSE: {rmse:.4f}&quot;)
print(f&quot;  R¬≤:   {r2:.4f}&quot;)

# ‰∫àÊ∏¨ÂÄ§ vs ÂÆüÊ∏¨ÂÄ§„ÅÆ„Éó„É≠„ÉÉ„Éà
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 6))

# Êï£Â∏ÉÂõ≥
ax1.scatter(test_targets, test_predictions, alpha=0.6, s=50,
            edgecolors='black', linewidth=0.5, color='steelblue')

# ÁêÜÊÉ≥Á∑ö
min_val = min(test_targets.min(), test_predictions.min())
max_val = max(test_targets.max(), test_predictions.max())
ax1.plot([min_val, max_val], [min_val, max_val],
         'r--', linewidth=2, label='Ideal')

ax1.set_xlabel('True Band Gap (eV)', fontsize=14, fontweight='bold')
ax1.set_ylabel('Predicted Band Gap (eV)', fontsize=14, fontweight='bold')
ax1.set_title(f'Predictions vs True Values\nR¬≤={r2:.3f}, MAE={mae:.3f}',
              fontsize=16, fontweight='bold')
ax1.legend(fontsize=12)
ax1.grid(True, alpha=0.3)

# ÊÆãÂ∑Æ„Éó„É≠„ÉÉ„Éà
residuals = test_predictions - test_targets
ax2.scatter(test_targets, residuals, alpha=0.6, s=50,
            edgecolors='black', linewidth=0.5, color='coral')
ax2.axhline(y=0, color='r', linestyle='--', linewidth=2)

ax2.set_xlabel('True Band Gap (eV)', fontsize=14, fontweight='bold')
ax2.set_ylabel('Residuals (eV)', fontsize=14, fontweight='bold')
ax2.set_title('Residual Plot', fontsize=16, fontweight='bold')
ax2.grid(True, alpha=0.3)

plt.tight_layout()
plt.savefig('test_evaluation.png', dpi=300, bbox_inches='tight')
print(&quot;\nË©ï‰æ°ÁµêÊûú„Çí test_evaluation.png „Å´‰øùÂ≠ò„Åó„Åæ„Åó„Åü&quot;)
plt.show()
</code></pre>
<h2>4.4 Âüã„ÇÅËæº„ÅøÊäΩÂá∫„Å®Ê¨°ÂÖÉÂâäÊ∏õ</h2>
<h3>„Ç≥„Éº„Éâ‰æã11: ÂÖ®„Éá„Éº„Çø„Åã„Çâ„ÅÆÂüã„ÇÅËæº„ÅøÊäΩÂá∫</h3>
<pre><code class="language-python">def extract_all_embeddings(model, dataset, device, batch_size=64):
    &quot;&quot;&quot;
    ÂÖ®„Éá„Éº„Çø„Çª„ÉÉ„Éà„Åã„ÇâÂüã„ÇÅËæº„Åø„ÇíÊäΩÂá∫

    Parameters:
    -----------
    model : nn.Module
        Â≠¶ÁøíÊ∏à„Åø„É¢„Éá„É´
    dataset : Dataset
        „Éá„Éº„Çø„Çª„ÉÉ„Éà
    device : torch.device
        „Éá„Éê„Ç§„Çπ
    batch_size : int
        „Éê„ÉÉ„ÉÅ„Çµ„Ç§„Ç∫

    Returns:
    --------
    embeddings : np.ndarray
        Âüã„ÇÅËæº„Åø„Éô„ÇØ„Éà„É´
    targets : np.ndarray
        „Çø„Éº„Ç≤„ÉÉ„ÉàÂÄ§
    &quot;&quot;&quot;
    model.eval()
    loader = DataLoader(dataset, batch_size=batch_size, shuffle=False)

    all_embeddings = []
    all_targets = []

    with torch.no_grad():
        for batch in tqdm(loader, desc=&quot;Âüã„ÇÅËæº„ÅøÊäΩÂá∫‰∏≠&quot;):
            batch = batch.to(device)

            _, embeddings = model(batch, return_embedding=True)

            all_embeddings.append(embeddings.cpu().numpy())
            all_targets.append(batch.y.cpu().numpy())

    embeddings = np.concatenate(all_embeddings, axis=0)
    targets = np.concatenate(all_targets, axis=0).flatten()

    return embeddings, targets


# ÂÖ®„Éá„Éº„Çø„Åã„ÇâÂüã„ÇÅËæº„Åø„ÇíÊäΩÂá∫
embeddings, targets = extract_all_embeddings(model, dataset, device)

print(f&quot;Âüã„ÇÅËæº„Åø„ÅÆÂΩ¢Áä∂: {embeddings.shape}&quot;)
print(f&quot;„Çø„Éº„Ç≤„ÉÉ„Éà„ÅÆÂΩ¢Áä∂: {targets.shape}&quot;)

# ‰øùÂ≠ò
np.save('cgcnn_embeddings.npy', embeddings)
np.save('cgcnn_targets.npy', targets)
print(&quot;\nÂüã„ÇÅËæº„Åø„Çí‰øùÂ≠ò„Åó„Åæ„Åó„Åü&quot;)
</code></pre>
<h3>„Ç≥„Éº„Éâ‰æã12: PCA„Å´„Çà„ÇãÊ¨°ÂÖÉÂâäÊ∏õ</h3>
<pre><code class="language-python">from sklearn.decomposition import PCA
import matplotlib.pyplot as plt
import numpy as np

# PCA„ÅÆÂÆüË°å
pca = PCA(n_components=min(50, embeddings.shape[1]))
embeddings_pca = pca.fit_transform(embeddings)

# ÂØÑ‰∏éÁéá„ÅÆÂàÜÊûê
explained_variance_ratio = pca.explained_variance_ratio_
cumsum_variance = np.cumsum(explained_variance_ratio)

# „Çπ„ÇØ„É™„Éº„Éó„É≠„ÉÉ„Éà
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 6))

# ÂÄãÂà•ÂØÑ‰∏éÁéá
ax1.bar(range(1, 21), explained_variance_ratio[:20],
        alpha=0.7, edgecolor='black', color='steelblue')
ax1.set_xlabel('Principal Component', fontsize=14, fontweight='bold')
ax1.set_ylabel('Explained Variance Ratio', fontsize=14, fontweight='bold')
ax1.set_title('PCA Scree Plot (Top 20 Components)',
              fontsize=16, fontweight='bold')
ax1.grid(True, alpha=0.3, axis='y')

# Á¥ØÁ©çÂØÑ‰∏éÁéá
ax2.plot(range(1, len(cumsum_variance) + 1), cumsum_variance,
         marker='o', linewidth=2, markersize=4, color='darkred')
ax2.axhline(y=0.95, color='green', linestyle='--', linewidth=2,
            label='95% threshold', alpha=0.7)
ax2.set_xlabel('Number of Components', fontsize=14, fontweight='bold')
ax2.set_ylabel('Cumulative Explained Variance', fontsize=14, fontweight='bold')
ax2.set_title('Cumulative Variance Explained',
              fontsize=16, fontweight='bold')
ax2.legend(fontsize=12)
ax2.grid(True, alpha=0.3)

plt.tight_layout()
plt.savefig('pca_analysis.png', dpi=300, bbox_inches='tight')
print(f&quot;PCAÂàÜÊûê„Çí pca_analysis.png „Å´‰øùÂ≠ò„Åó„Åæ„Åó„Åü&quot;)
print(f&quot;\n95%„ÅÆÂàÜÊï£„ÇíË™¨Êòé„Åô„Çã‰∏ªÊàêÂàÜÊï∞: {np.argmax(cumsum_variance &gt;= 0.95) + 1}&quot;)
plt.show()

# 2Ê¨°ÂÖÉPCAÂèØË¶ñÂåñ
pca_2d = PCA(n_components=2)
embeddings_pca_2d = pca_2d.fit_transform(embeddings)

plt.figure(figsize=(12, 9))
scatter = plt.scatter(embeddings_pca_2d[:, 0], embeddings_pca_2d[:, 1],
                      c=targets, cmap='viridis', s=50, alpha=0.6,
                      edgecolors='black', linewidth=0.5)
plt.xlabel(f'PC1 ({pca_2d.explained_variance_ratio_[0]*100:.1f}% variance)',
           fontsize=14, fontweight='bold')
plt.ylabel(f'PC2 ({pca_2d.explained_variance_ratio_[1]*100:.1f}% variance)',
           fontsize=14, fontweight='bold')
plt.title('PCA: 2D Projection of CGCNN Embeddings',
          fontsize=16, fontweight='bold')
plt.colorbar(scatter, label='Band Gap (eV)')
plt.grid(True, alpha=0.3)
plt.tight_layout()
plt.savefig('pca_2d_projection.png', dpi=300, bbox_inches='tight')
print(&quot;PCA 2DÂ∞ÑÂΩ±„Çí pca_2d_projection.png „Å´‰øùÂ≠ò„Åó„Åæ„Åó„Åü&quot;)
plt.show()
</code></pre>
<h3>„Ç≥„Éº„Éâ‰æã13: UMAP„Å´„Çà„ÇãÊ¨°ÂÖÉÂâäÊ∏õ</h3>
<pre><code class="language-python">import umap
import matplotlib.pyplot as plt
import numpy as np

# UMAPÂÆüË°åÔºàË§áÊï∞„Éë„É©„É°„Éº„Çø„ÅßÂÆüÈ®ìÔºâ
n_neighbors_list = [5, 15, 30, 50]
min_dist_list = [0.0, 0.1, 0.3]

# ÊúÄÈÅ©„Å™„Éë„É©„É°„Éº„Çø„Åß„ÅÆÂÆüË°å
print(&quot;UMAP„ÇíÂÆüË°å‰∏≠...&quot;)
reducer = umap.UMAP(
    n_components=2,
    n_neighbors=15,
    min_dist=0.1,
    metric='euclidean',
    random_state=42,
    verbose=True
)

embeddings_umap = reducer.fit_transform(embeddings)

# ÂèØË¶ñÂåñ
fig, axes = plt.subplots(1, 2, figsize=(18, 7))

# „Çø„Éº„Ç≤„ÉÉ„ÉàÂÄ§„ÅßËâ≤‰ªò„Åë
scatter1 = axes[0].scatter(embeddings_umap[:, 0], embeddings_umap[:, 1],
                           c=targets, cmap='viridis', s=50, alpha=0.6,
                           edgecolors='black', linewidth=0.5)
axes[0].set_xlabel('UMAP 1', fontsize=14, fontweight='bold')
axes[0].set_ylabel('UMAP 2', fontsize=14, fontweight='bold')
axes[0].set_title('UMAP: Colored by Band Gap',
                  fontsize=16, fontweight='bold')
axes[0].grid(True, alpha=0.3)
cbar1 = plt.colorbar(scatter1, ax=axes[0])
cbar1.set_label('Band Gap (eV)', fontsize=12, fontweight='bold')

# „Ç´„ÉÜ„Ç¥„É™„ÅßËâ≤‰ªò„Åë
band_gap_categories = pd.cut(targets, bins=[0, 1, 2, 3, 10],
                              labels=['Small', 'Medium', 'Large', 'Very Large'])

colors_map = {'Small': 'red', 'Medium': 'orange', 'Large': 'yellow', 'Very Large': 'green'}
colors = [colors_map[cat] for cat in band_gap_categories]

for category in ['Small', 'Medium', 'Large', 'Very Large']:
    mask = band_gap_categories == category
    axes[1].scatter(embeddings_umap[mask, 0], embeddings_umap[mask, 1],
                    c=colors_map[category], label=category, s=50, alpha=0.7,
                    edgecolors='black', linewidth=0.5)

axes[1].set_xlabel('UMAP 1', fontsize=14, fontweight='bold')
axes[1].set_ylabel('UMAP 2', fontsize=14, fontweight='bold')
axes[1].set_title('UMAP: Colored by Band Gap Category',
                  fontsize=16, fontweight='bold')
axes[1].legend(title='Band Gap', fontsize=11)
axes[1].grid(True, alpha=0.3)

plt.tight_layout()
plt.savefig('umap_2d_projection.png', dpi=300, bbox_inches='tight')
print(&quot;\nUMAP 2DÂ∞ÑÂΩ±„Çí umap_2d_projection.png „Å´‰øùÂ≠ò„Åó„Åæ„Åó„Åü&quot;)
plt.show()

# UMAPÁµêÊûú„ÅÆ‰øùÂ≠ò
np.save('umap_embeddings_2d.npy', embeddings_umap)
</code></pre>
<h3>„Ç≥„Éº„Éâ‰æã14: t-SNE„Å´„Çà„ÇãÊ¨°ÂÖÉÂâäÊ∏õ</h3>
<pre><code class="language-python">from sklearn.manifold import TSNE
import matplotlib.pyplot as plt
import time

# t-SNEÂÆüË°åÔºà„Çµ„Éñ„Çª„ÉÉ„Éà„ÅßÈ´òÈÄüÂåñÔºâ
subset_size = min(1000, len(embeddings))
subset_indices = np.random.choice(len(embeddings), subset_size, replace=False)

embeddings_subset = embeddings[subset_indices]
targets_subset = targets[subset_indices]

print(f&quot;t-SNE„ÇíÂÆüË°å‰∏≠ („Çµ„Éñ„Çª„ÉÉ„Éà„Çµ„Ç§„Ç∫: {subset_size})...&quot;)
start_time = time.time()

tsne = TSNE(
    n_components=2,
    perplexity=30,
    n_iter=1000,
    random_state=42,
    verbose=1
)

embeddings_tsne = tsne.fit_transform(embeddings_subset)

elapsed_time = time.time() - start_time
print(f&quot;t-SNEÂÆå‰∫Ü (ÊâÄË¶ÅÊôÇÈñì: {elapsed_time:.1f}Áßí)&quot;)

# ÂèØË¶ñÂåñ
plt.figure(figsize=(12, 9))
scatter = plt.scatter(embeddings_tsne[:, 0], embeddings_tsne[:, 1],
                      c=targets_subset, cmap='plasma', s=50, alpha=0.6,
                      edgecolors='black', linewidth=0.5)
plt.xlabel('t-SNE 1', fontsize=14, fontweight='bold')
plt.ylabel('t-SNE 2', fontsize=14, fontweight='bold')
plt.title('t-SNE: 2D Projection of CGCNN Embeddings',
          fontsize=16, fontweight='bold')
plt.colorbar(scatter, label='Band Gap (eV)')
plt.grid(True, alpha=0.3)
plt.tight_layout()
plt.savefig('tsne_2d_projection.png', dpi=300, bbox_inches='tight')
print(&quot;t-SNE 2DÂ∞ÑÂΩ±„Çí tsne_2d_projection.png „Å´‰øùÂ≠ò„Åó„Åæ„Åó„Åü&quot;)
plt.show()
</code></pre>
<h3>„Ç≥„Éº„Éâ‰æã15: Ê¨°ÂÖÉÂâäÊ∏õÊâãÊ≥ï„ÅÆÊØîËºÉ</h3>
<pre><code class="language-python">import matplotlib.pyplot as plt
import numpy as np

# 3„Å§„ÅÆÊâãÊ≥ï„ÅÆÁµêÊûú„Çí‰∏¶„Åπ„Å¶Ë°®Á§∫
fig, axes = plt.subplots(1, 3, figsize=(21, 6))

# PCA
scatter = axes[0].scatter(embeddings_pca_2d[:, 0], embeddings_pca_2d[:, 1],
                          c=targets, cmap='viridis', s=30, alpha=0.6,
                          edgecolors='none')
axes[0].set_xlabel('PC1', fontsize=12, fontweight='bold')
axes[0].set_ylabel('PC2', fontsize=12, fontweight='bold')
axes[0].set_title('PCA', fontsize=14, fontweight='bold')
axes[0].grid(True, alpha=0.3)

# UMAP
scatter = axes[1].scatter(embeddings_umap[:, 0], embeddings_umap[:, 1],
                          c=targets, cmap='viridis', s=30, alpha=0.6,
                          edgecolors='none')
axes[1].set_xlabel('UMAP 1', fontsize=12, fontweight='bold')
axes[1].set_ylabel('UMAP 2', fontsize=12, fontweight='bold')
axes[1].set_title('UMAP', fontsize=14, fontweight='bold')
axes[1].grid(True, alpha=0.3)

# t-SNE
scatter = axes[2].scatter(embeddings_tsne[:, 0], embeddings_tsne[:, 1],
                          c=targets_subset, cmap='viridis', s=30, alpha=0.6,
                          edgecolors='none')
axes[2].set_xlabel('t-SNE 1', fontsize=12, fontweight='bold')
axes[2].set_ylabel('t-SNE 2', fontsize=12, fontweight='bold')
axes[2].set_title('t-SNE', fontsize=14, fontweight='bold')
axes[2].grid(True, alpha=0.3)

# ÂÖ±ÈÄö„Ç´„É©„Éº„Éê„Éº
fig.subplots_adjust(right=0.9)
cbar_ax = fig.add_axes([0.92, 0.15, 0.02, 0.7])
cbar = fig.colorbar(scatter, cax=cbar_ax)
cbar.set_label('Band Gap (eV)', fontsize=12, fontweight='bold')

plt.savefig('dimensionality_reduction_comparison.png', dpi=300, bbox_inches='tight')
print(&quot;Ê¨°ÂÖÉÂâäÊ∏õÊâãÊ≥ïÊØîËºÉ„Çí dimensionality_reduction_comparison.png „Å´‰øùÂ≠ò„Åó„Åæ„Åó„Åü&quot;)
plt.show()
</code></pre>
<h2>4.5 ÊùêÊñôÁ©∫Èñì„ÅÆÂàÜÊûê</h2>
<h3>„Ç≥„Éº„Éâ‰æã16: „ÇØ„É©„Çπ„Çø„É™„É≥„Ç∞„Å®ÁâπÊÄßÂàÜÊûê</h3>
<pre><code class="language-python">from sklearn.cluster import KMeans
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

# K-Means„ÇØ„É©„Çπ„Çø„É™„É≥„Ç∞ÔºàUMAPÁ©∫Èñì‰∏äÔºâ
n_clusters = 6
kmeans = KMeans(n_clusters=n_clusters, random_state=42, n_init=20)
cluster_labels = kmeans.fit_predict(embeddings_umap)

# „ÇØ„É©„Çπ„Çø„Åî„Å®„ÅÆÂèØË¶ñÂåñ
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(18, 7))

# „ÇØ„É©„Çπ„Çø„É©„Éô„É´„ÅßËâ≤‰ªò„Åë
colors = plt.cm.Set3(np.linspace(0, 1, n_clusters))
for cluster_id in range(n_clusters):
    mask = cluster_labels == cluster_id
    ax1.scatter(embeddings_umap[mask, 0], embeddings_umap[mask, 1],
                c=[colors[cluster_id]], label=f'Cluster {cluster_id}',
                s=60, alpha=0.7, edgecolors='black', linewidth=0.5)

# „ÇØ„É©„Çπ„Çø‰∏≠ÂøÉ
umap_reducer_for_centers = umap.UMAP(n_components=2, n_neighbors=15,
                                     min_dist=0.1, random_state=42)
umap_reducer_for_centers.fit(embeddings)
centers_umap = umap_reducer_for_centers.transform(kmeans.cluster_centers_)

ax1.scatter(centers_umap[:, 0], centers_umap[:, 1],
            c='red', marker='X', s=300, edgecolors='black',
            linewidth=2, label='Centroids', zorder=10)

ax1.set_xlabel('UMAP 1', fontsize=14, fontweight='bold')
ax1.set_ylabel('UMAP 2', fontsize=14, fontweight='bold')
ax1.set_title(f'K-Means Clustering (k={n_clusters})',
              fontsize=16, fontweight='bold')
ax1.legend(fontsize=10, loc='best', ncol=2)
ax1.grid(True, alpha=0.3)

# „ÇØ„É©„Çπ„Çø„Åî„Å®„ÅÆÁâπÊÄßÂàÜÂ∏É
cluster_df = pd.DataFrame({
    'cluster': cluster_labels,
    'band_gap': targets
})

sns.boxplot(data=cluster_df, x='cluster', y='band_gap',
            ax=ax2, palette='Set3')
sns.swarmplot(data=cluster_df, x='cluster', y='band_gap',
              ax=ax2, color='black', alpha=0.3, size=2)

ax2.set_xlabel('Cluster ID', fontsize=14, fontweight='bold')
ax2.set_ylabel('Band Gap (eV)', fontsize=14, fontweight='bold')
ax2.set_title('Band Gap Distribution by Cluster',
              fontsize=16, fontweight='bold')
ax2.grid(True, alpha=0.3, axis='y')

plt.tight_layout()
plt.savefig('clustering_analysis.png', dpi=300, bbox_inches='tight')
print(&quot;„ÇØ„É©„Çπ„Çø„É™„É≥„Ç∞ÂàÜÊûê„Çí clustering_analysis.png „Å´‰øùÂ≠ò„Åó„Åæ„Åó„Åü&quot;)
plt.show()

# „ÇØ„É©„Çπ„ÇøÁµ±Ë®à
print(&quot;\n„ÇØ„É©„Çπ„Çø„Åî„Å®„ÅÆ„Éê„É≥„Éâ„ÇÆ„É£„ÉÉ„ÉóÁµ±Ë®à:&quot;)
cluster_stats = cluster_df.groupby('cluster')['band_gap'].agg([
    'count', 'mean', 'std', 'min', 'max'
])
print(cluster_stats.round(3))
</code></pre>
<h3>„Ç≥„Éº„Éâ‰æã17: ÊùêÊñôÁâπÊÄß„Å®„ÇØ„É©„Çπ„Çø„ÅÆÈñ¢‰øÇÂàÜÊûê</h3>
<pre><code class="language-python">import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# ËøΩÂä†„ÅÆÊùêÊñôÁâπÊÄß„ÇíDataFrame„Å´Áµ±Âêà
materials_analysis_df = materials_df.copy()
materials_analysis_df['cluster'] = cluster_labels
materials_analysis_df['umap1'] = embeddings_umap[:, 0]
materials_analysis_df['umap2'] = embeddings_umap[:, 1]

# „ÇØ„É©„Çπ„Çø„Åî„Å®„ÅÆË§áÊï∞ÁâπÊÄß„ÅÆÁµ±Ë®à
properties_to_analyze = [
    'band_gap', 'formation_energy_per_atom',
    'density', 'energy_above_hull', 'volume'
]

cluster_property_stats = materials_analysis_df.groupby('cluster')[
    properties_to_analyze
].mean()

# „Éí„Éº„Éà„Éû„ÉÉ„Éó„ÅßÂèØË¶ñÂåñ
plt.figure(figsize=(12, 8))
sns.heatmap(cluster_property_stats.T, annot=True, fmt='.2f',
            cmap='RdYlGn_r', center=0, linewidths=1,
            cbar_kws={&quot;label&quot;: &quot;Normalized Value&quot;})
plt.title('Average Material Properties by Cluster',
          fontsize=16, fontweight='bold', pad=20)
plt.xlabel('Cluster ID', fontsize=14, fontweight='bold')
plt.ylabel('Property', fontsize=14, fontweight='bold')
plt.tight_layout()
plt.savefig('cluster_properties_heatmap.png', dpi=300, bbox_inches='tight')
print(&quot;„ÇØ„É©„Çπ„ÇøÁâπÊÄß„Éí„Éº„Éà„Éû„ÉÉ„Éó„Çí cluster_properties_heatmap.png „Å´‰øùÂ≠ò„Åó„Åæ„Åó„Åü&quot;)
plt.show()
</code></pre>
<h3>„Ç≥„Éº„Éâ‰æã18: ÂØÜÂ∫¶„Éû„ÉÉ„Éó„ÅÆ‰ΩúÊàê</h3>
<pre><code class="language-python">from scipy.stats import gaussian_kde
import matplotlib.pyplot as plt
import numpy as np

# UMAPÁ©∫Èñì„Åß„ÅÆÂØÜÂ∫¶Êé®ÂÆö
xy = np.vstack([embeddings_umap[:, 0], embeddings_umap[:, 1]])
density = gaussian_kde(xy)(xy)

# ÂØÜÂ∫¶„Åß„ÇΩ„Éº„ÉàÔºàÈ´òÂØÜÂ∫¶ÁÇπ„Çí‰∏ä„Å´ÊèèÁîªÔºâ
idx = density.argsort()
x, y, z = embeddings_umap[idx, 0], embeddings_umap[idx, 1], density[idx]

# „Éó„É≠„ÉÉ„Éà
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(18, 7))

# ÂØÜÂ∫¶„Éû„ÉÉ„Éó
scatter1 = ax1.scatter(x, y, c=z, cmap='hot', s=50, alpha=0.7,
                       edgecolors='black', linewidth=0.3)
ax1.set_xlabel('UMAP 1', fontsize=14, fontweight='bold')
ax1.set_ylabel('UMAP 2', fontsize=14, fontweight='bold')
ax1.set_title('Materials Space Density Map',
              fontsize=16, fontweight='bold')
ax1.grid(True, alpha=0.3)
cbar1 = plt.colorbar(scatter1, ax=ax1)
cbar1.set_label('Point Density', fontsize=12, fontweight='bold')

# ÂØÜÂ∫¶„Éû„ÉÉ„Éó + „Éê„É≥„Éâ„ÇÆ„É£„ÉÉ„Éó
scatter2 = ax2.scatter(embeddings_umap[:, 0], embeddings_umap[:, 1],
                       c=targets, s=50 + density*1000, alpha=0.6,
                       cmap='viridis', edgecolors='black', linewidth=0.5)
ax2.set_xlabel('UMAP 1', fontsize=14, fontweight='bold')
ax2.set_ylabel('UMAP 2', fontsize=14, fontweight='bold')
ax2.set_title('Band Gap with Density (size = density)',
              fontsize=16, fontweight='bold')
ax2.grid(True, alpha=0.3)
cbar2 = plt.colorbar(scatter2, ax=ax2)
cbar2.set_label('Band Gap (eV)', fontsize=12, fontweight='bold')

plt.tight_layout()
plt.savefig('density_map.png', dpi=300, bbox_inches='tight')
print(&quot;ÂØÜÂ∫¶„Éû„ÉÉ„Éó„Çí density_map.png „Å´‰øùÂ≠ò„Åó„Åæ„Åó„Åü&quot;)
plt.show()
</code></pre>
<h3>„Ç≥„Éº„Éâ‰æã19: ËøëÂÇçÊùêÊñô„ÅÆÊé¢Á¥¢</h3>
<pre><code class="language-python">from sklearn.neighbors import NearestNeighbors
import pandas as pd

def find_similar_materials_in_embedding_space(
    query_idx, embeddings, materials_df, k=10
):
    &quot;&quot;&quot;
    Âüã„ÇÅËæº„ÅøÁ©∫Èñì„ÅßÈ°û‰ººÊùêÊñô„ÇíÊ§úÁ¥¢

    Parameters:
    -----------
    query_idx : int
        „ÇØ„Ç®„É™ÊùêÊñô„ÅÆ„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ
    embeddings : np.ndarray
        Âüã„ÇÅËæº„Åø„Éô„ÇØ„Éà„É´
    materials_df : pd.DataFrame
        ÊùêÊñô„Éá„Éº„Çø
    k : int
        Ê§úÁ¥¢„Åô„ÇãËøëÂÇçÊï∞

    Returns:
    --------
    results_df : pd.DataFrame
        ËøëÂÇçÊùêÊñô„ÅÆÊÉÖÂ†±
    &quot;&quot;&quot;
    nbrs = NearestNeighbors(n_neighbors=k+1, metric='cosine').fit(embeddings)
    distances, indices = nbrs.kneighbors(embeddings[query_idx:query_idx+1])

    # ÁµêÊûú„ÅÆDataFrame‰ΩúÊàê
    results = []
    for i, (idx, dist) in enumerate(zip(indices[0], distances[0])):
        if i == 0:  # „ÇØ„Ç®„É™Ëá™Ë∫´„Çí„Çπ„Ç≠„ÉÉ„Éó
            continue

        result = {
            'rank': i,
            'material_id': materials_df.iloc[idx]['material_id'],
            'formula': materials_df.iloc[idx]['formula'],
            'band_gap': materials_df.iloc[idx]['band_gap'],
            'formation_energy': materials_df.iloc[idx]['formation_energy_per_atom'],
            'density': materials_df.iloc[idx]['density'],
            'distance': dist
        }
        results.append(result)

    results_df = pd.DataFrame(results)
    return results_df


# ‰ΩøÁî®‰æã: „É©„É≥„ÉÄ„É†„Å´ÊùêÊñô„ÇíÈÅ∏„Çì„ÅßÈ°û‰ººÊùêÊñô„ÇíÊ§úÁ¥¢
np.random.seed(42)
query_indices = np.random.choice(len(materials_df), 3, replace=False)

print(&quot;È°û‰ººÊùêÊñôÊ§úÁ¥¢„ÅÆ‰æã:\n&quot;)
for query_idx in query_indices:
    query_material = materials_df.iloc[query_idx]

    print(f&quot;„ÇØ„Ç®„É™ÊùêÊñô:&quot;)
    print(f&quot;  Material ID: {query_material['material_id']}&quot;)
    print(f&quot;  Formula: {query_material['formula']}&quot;)
    print(f&quot;  Band Gap: {query_material['band_gap']:.3f} eV&quot;)
    print(f&quot;\nÈ°û‰ººÊùêÊñô (Top 5):&quot;)

    similar_materials = find_similar_materials_in_embedding_space(
        query_idx, embeddings, materials_df, k=5
    )

    print(similar_materials[['rank', 'material_id', 'formula', 'band_gap', 'distance']].to_string(index=False))
    print(&quot;\n&quot; + &quot;=&quot;*80 + &quot;\n&quot;)
</code></pre>
<h3>„Ç≥„Éº„Éâ‰æã20: ÊùêÊñôÊé®Ëñ¶„Ç∑„Çπ„ÉÜ„É†</h3>
<pre><code class="language-python">def recommend_materials_by_property(
    target_property_value,
    property_name,
    embeddings,
    materials_df,
    n_recommendations=10,
    property_weight=0.7,
    embedding_weight=0.3
):
    &quot;&quot;&quot;
    ÁõÆÊ®ôÁâπÊÄßÂÄ§„Å´Âü∫„Å•„ÅÑ„Å¶ÊùêÊñô„ÇíÊé®Ëñ¶

    Parameters:
    -----------
    target_property_value : float
        ÁõÆÊ®ôÁâπÊÄßÂÄ§
    property_name : str
        ÁâπÊÄßÂêç
    embeddings : np.ndarray
        Âüã„ÇÅËæº„Åø„Éô„ÇØ„Éà„É´
    materials_df : pd.DataFrame
        ÊùêÊñô„Éá„Éº„Çø
    n_recommendations : int
        Êé®Ëñ¶Êï∞
    property_weight : float
        ÁâπÊÄßÂÄ§„ÅÆÈáç„Åø
    embedding_weight : float
        Âüã„ÇÅËæº„ÅøË∑ùÈõ¢„ÅÆÈáç„Åø

    Returns:
    --------
    recommendations_df : pd.DataFrame
        Êé®Ëñ¶ÊùêÊñô„ÅÆ„É™„Çπ„Éà
    &quot;&quot;&quot;
    # ÁâπÊÄßÂÄ§„ÅÆÂ∑Æ
    property_diff = np.abs(materials_df[property_name].values - target_property_value)
    property_diff_normalized = property_diff / property_diff.max()

    # ÁõÆÊ®ôÁâπÊÄßÂÄ§„Å´ÊúÄ„ÇÇËøë„ÅÑÊùêÊñô„ÅÆ„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ
    closest_idx = property_diff.argmin()

    # Âüã„ÇÅËæº„ÅøÁ©∫Èñì„Åß„ÅÆË∑ùÈõ¢
    from sklearn.metrics.pairwise import cosine_distances
    embedding_distances = cosine_distances(
        embeddings[closest_idx:closest_idx+1],
        embeddings
    ).flatten()
    embedding_distances_normalized = embedding_distances / embedding_distances.max()

    # Áµ±Âêà„Çπ„Ç≥„Ç¢ÔºàÂ∞è„Åï„ÅÑ„Åª„Å©ËâØ„ÅÑÔºâ
    combined_score = (
        property_weight * property_diff_normalized +
        embedding_weight * embedding_distances_normalized
    )

    # ‰∏ä‰Ωçn_recommendationsÂÄã„ÇíÈÅ∏Êäû
    top_indices = combined_score.argsort()[:n_recommendations]

    # ÁµêÊûú„ÅÆDataFrame‰ΩúÊàê
    recommendations = []
    for rank, idx in enumerate(top_indices, 1):
        rec = {
            'rank': rank,
            'material_id': materials_df.iloc[idx]['material_id'],
            'formula': materials_df.iloc[idx]['formula'],
            property_name: materials_df.iloc[idx][property_name],
            'property_diff': property_diff[idx],
            'embedding_distance': embedding_distances[idx],
            'combined_score': combined_score[idx]
        }
        recommendations.append(rec)

    recommendations_df = pd.DataFrame(recommendations)
    return recommendations_df


# ‰ΩøÁî®‰æã: „Éê„É≥„Éâ„ÇÆ„É£„ÉÉ„Éó2.0 eV„Å´Ëøë„ÅÑÊùêÊñô„ÇíÊé®Ëñ¶
target_bandgap = 2.0

print(f&quot;ÁõÆÊ®ô„Éê„É≥„Éâ„ÇÆ„É£„ÉÉ„Éó: {target_bandgap} eV&quot;)
print(&quot;\nÊé®Ëñ¶ÊùêÊñôÔºàTop 10Ôºâ:\n&quot;)

recommendations = recommend_materials_by_property(
    target_property_value=target_bandgap,
    property_name='band_gap',
    embeddings=embeddings,
    materials_df=materials_df,
    n_recommendations=10,
    property_weight=0.7,
    embedding_weight=0.3
)

print(recommendations[['rank', 'material_id', 'formula', 'band_gap',
                       'property_diff', 'combined_score']].to_string(index=False))
</code></pre>
<h2>4.6 „Ç§„É≥„Çø„É©„ÇØ„ÉÜ„Ç£„ÉñÂèØË¶ñÂåñ</h2>
<h3>„Ç≥„Éº„Éâ‰æã21: Plotly„Å´„Çà„Çã3D UMAP</h3>
<pre><code class="language-python">import plotly.express as px
import plotly.graph_objects as go
import umap
import pandas as pd

# 3Ê¨°ÂÖÉUMAP
print(&quot;3Ê¨°ÂÖÉUMAP„ÇíÂÆüË°å‰∏≠...&quot;)
reducer_3d = umap.UMAP(
    n_components=3,
    n_neighbors=15,
    min_dist=0.1,
    random_state=42,
    verbose=False
)

embeddings_umap_3d = reducer_3d.fit_transform(embeddings)

# DataFrame„ÅÆ‰ΩúÊàê
df_3d = pd.DataFrame({
    'UMAP1': embeddings_umap_3d[:, 0],
    'UMAP2': embeddings_umap_3d[:, 1],
    'UMAP3': embeddings_umap_3d[:, 2],
    'Band_Gap': targets,
    'Material_ID': materials_df['material_id'].values,
    'Formula': materials_df['formula'].values,
    'Formation_Energy': materials_df['formation_energy_per_atom'].values,
    'Density': materials_df['density'].values,
    'Cluster': cluster_labels
})

# „Ç§„É≥„Çø„É©„ÇØ„ÉÜ„Ç£„Éñ3D„Éó„É≠„ÉÉ„Éà
fig = px.scatter_3d(
    df_3d,
    x='UMAP1', y='UMAP2', z='UMAP3',
    color='Band_Gap',
    size='Density',
    hover_data=['Material_ID', 'Formula', 'Formation_Energy', 'Cluster'],
    color_continuous_scale='Viridis',
    title='Interactive 3D UMAP: Materials Space Explorer'
)

fig.update_traces(marker=dict(line=dict(width=0.5, color='DarkSlateGrey')))

fig.update_layout(
    scene=dict(
        xaxis_title='UMAP 1',
        yaxis_title='UMAP 2',
        zaxis_title='UMAP 3',
        xaxis=dict(backgroundcolor=&quot;rgb(230, 230, 230)&quot;, gridcolor=&quot;white&quot;),
        yaxis=dict(backgroundcolor=&quot;rgb(230, 230, 230)&quot;, gridcolor=&quot;white&quot;),
        zaxis=dict(backgroundcolor=&quot;rgb(230, 230, 230)&quot;, gridcolor=&quot;white&quot;),
    ),
    width=1000,
    height=800,
    font=dict(size=12)
)

fig.write_html('materials_3d_interactive.html')
print(&quot;„Ç§„É≥„Çø„É©„ÇØ„ÉÜ„Ç£„Éñ3DÂèØË¶ñÂåñ„Çí materials_3d_interactive.html „Å´‰øùÂ≠ò„Åó„Åæ„Åó„Åü&quot;)
fig.show()
</code></pre>
<h3>„Ç≥„Éº„Éâ‰æã22: Bokeh„Å´„Çà„Çã„Ç§„É≥„Çø„É©„ÇØ„ÉÜ„Ç£„ÉñÊï£Â∏ÉÂõ≥</h3>
<pre><code class="language-python">from bokeh.plotting import figure, output_file, save
from bokeh.models import HoverTool, ColorBar, LinearColorMapper, ColumnDataSource
from bokeh.palettes import Viridis256
from bokeh.io import show
from bokeh.layouts import column, row
from bokeh.models.widgets import Select

# „Ç´„É©„Éº„Éû„ÉÉ„Éë„Éº
color_mapper = LinearColorMapper(
    palette=Viridis256,
    low=targets.min(),
    high=targets.max()
)

# „Éá„Éº„Çø„ÇΩ„Éº„Çπ
source = ColumnDataSource(data=dict(
    x=embeddings_umap[:, 0],
    y=embeddings_umap[:, 1],
    material_id=materials_df['material_id'].values,
    formula=materials_df['formula'].values,
    band_gap=targets,
    formation_energy=materials_df['formation_energy_per_atom'].values,
    density=materials_df['density'].values,
    volume=materials_df['volume'].values,
    cluster=cluster_labels
))

# „Éó„É≠„ÉÉ„Éà„ÅÆ‰ΩúÊàê
output_file('materials_interactive.html')

p = figure(
    width=1000,
    height=800,
    title='Interactive Materials Space Explorer (UMAP)',
    tools='pan,wheel_zoom,box_zoom,box_select,lasso_select,reset,save'
)

# Êï£Â∏ÉÂõ≥
circles = p.circle(
    'x', 'y',
    size=8,
    source=source,
    fill_color={'field': 'band_gap', 'transform': color_mapper},
    fill_alpha=0.7,
    line_color='black',
    line_width=0.5
)

# „Éõ„Éê„Éº„ÉÑ„Éº„É´
hover = HoverTool(tooltips=[
    ('Material ID', '@material_id'),
    ('Formula', '@formula'),
    ('Band Gap', '@band_gap{0.00} eV'),
    ('Formation E', '@formation_energy{0.00} eV/atom'),
    ('Density', '@density{0.00} g/cm¬≥'),
    ('Volume', '@volume{0.0} ≈≤'),
    ('Cluster', '@cluster')
])
p.add_tools(hover)

# „Ç´„É©„Éº„Éê„Éº
color_bar = ColorBar(
    color_mapper=color_mapper,
    label_standoff=12,
    title='Band Gap (eV)',
    location=(0, 0)
)
p.add_layout(color_bar, 'right')

# Ëª∏„É©„Éô„É´
p.xaxis.axis_label = 'UMAP 1'
p.yaxis.axis_label = 'UMAP 2'
p.title.text_font_size = '16pt'
p.xaxis.axis_label_text_font_size = '14pt'
p.yaxis.axis_label_text_font_size = '14pt'

save(p)
print(&quot;„Ç§„É≥„Çø„É©„ÇØ„ÉÜ„Ç£„ÉñUMAP„Çí materials_interactive.html „Å´‰øùÂ≠ò„Åó„Åæ„Åó„Åü&quot;)
show(p)
</code></pre>
<h3>„Ç≥„Éº„Éâ‰æã23: Dash„Å´„Çà„Çã„ÉÄ„ÉÉ„Ç∑„É•„Éú„Éº„ÉâÔºà„Ç™„Éó„Ç∑„Éß„É≥Ôºâ</h3>
<pre><code class="language-python"># Dash„ÅÆ„Ç§„É≥„Çπ„Éà„Éº„É´ÔºàÂàùÂõû„ÅÆ„ÅøÔºâ
# !pip install dash

&quot;&quot;&quot;
import dash
from dash import dcc, html
from dash.dependencies import Input, Output
import plotly.express as px
import plotly.graph_objects as go
import pandas as pd

# Dash„Ç¢„Éó„É™„ÅÆ‰ΩúÊàê
app = dash.Dash(__name__)

# „Éá„Éº„Çø„Éï„É¨„Éº„É†„ÅÆÊ∫ñÂÇô
df_dash = pd.DataFrame({
    'umap1': embeddings_umap[:, 0],
    'umap2': embeddings_umap[:, 1],
    'material_id': materials_df['material_id'].values,
    'formula': materials_df['formula'].values,
    'band_gap': targets,
    'formation_energy': materials_df['formation_energy_per_atom'].values,
    'density': materials_df['density'].values,
    'cluster': cluster_labels
})

# „É¨„Ç§„Ç¢„Ç¶„Éà
app.layout = html.Div([
    html.H1('Materials Space Explorer Dashboard'),

    html.Div([
        html.Label('Color by:'),
        dcc.Dropdown(
            id='color-dropdown',
            options=[
                {'label': 'Band Gap', 'value': 'band_gap'},
                {'label': 'Formation Energy', 'value': 'formation_energy'},
                {'label': 'Density', 'value': 'density'},
                {'label': 'Cluster', 'value': 'cluster'}
            ],
            value='band_gap'
        ),
    ], style={'width': '30%', 'display': 'inline-block'}),

    dcc.Graph(id='umap-scatter'),

    html.Div(id='material-info')
])

# „Ç≥„Éº„É´„Éê„ÉÉ„ÇØ
@app.callback(
    Output('umap-scatter', 'figure'),
    Input('color-dropdown', 'value')
)
def update_scatter(color_by):
    fig = px.scatter(
        df_dash,
        x='umap1',
        y='umap2',
        color=color_by,
        hover_data=['material_id', 'formula', 'band_gap', 'formation_energy'],
        color_continuous_scale='Viridis',
        title=f'UMAP colored by {color_by}'
    )

    fig.update_traces(marker=dict(size=8, line=dict(width=0.5, color='black')))

    return fig

# „Ç¢„Éó„É™„ÅÆÂÆüË°å
if __name__ == '__main__':
    app.run_server(debug=True)
&quot;&quot;&quot;

print(&quot;Dash„ÉÄ„ÉÉ„Ç∑„É•„Éú„Éº„Éâ„ÅÆ„Ç≥„Éº„Éâ‰æã„ÇíË°®Á§∫„Åó„Åæ„Åó„Åü&quot;)
print(&quot;„Ç≥„É°„É≥„Éà„ÇíÂ§ñ„Åó„Å¶ÂÆüË°å„Åó„Å¶„Åè„Å†„Åï„ÅÑ&quot;)
</code></pre>
<h2>4.7 È´òÂ∫¶„Å™ÂàÜÊûê„Å®ÂøúÁî®</h2>
<h3>„Ç≥„Éº„Éâ‰æã24: ÊùêÊñôÁ©∫Èñì„ÅÆ„Éú„É≠„Éé„Ç§ÂàÜÂâ≤</h3>
<pre><code class="language-python">from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib.pyplot as plt
import numpy as np

# „Çµ„Éñ„Çª„ÉÉ„Éà„Åß„Éú„É≠„Éé„Ç§Âõ≥„Çí‰ΩúÊàêÔºàË®àÁÆóÈáèÂâäÊ∏õÔºâ
subset_size = 100
subset_indices = np.random.choice(len(embeddings_umap), subset_size, replace=False)

points = embeddings_umap[subset_indices]
targets_subset = targets[subset_indices]

# „Éú„É≠„Éé„Ç§Âõ≥„ÅÆË®àÁÆó
vor = Voronoi(points)

# „Éó„É≠„ÉÉ„Éà
fig, ax = plt.subplots(figsize=(14, 12))

# „Éú„É≠„Éé„Ç§„Çª„É´
voronoi_plot_2d(vor, ax=ax, show_vertices=False, line_colors='gray',
                line_width=1, line_alpha=0.6, point_size=0)

# ÊùêÊñôÁÇπ
scatter = ax.scatter(points[:, 0], points[:, 1],
                     c=targets_subset, cmap='viridis',
                     s=100, alpha=0.8, edgecolors='black', linewidth=1.5,
                     zorder=5)

ax.set_xlabel('UMAP 1', fontsize=14, fontweight='bold')
ax.set_ylabel('UMAP 2', fontsize=14, fontweight='bold')
ax.set_title('Voronoi Tessellation of Materials Space',
             fontsize=16, fontweight='bold')

cbar = plt.colorbar(scatter, ax=ax)
cbar.set_label('Band Gap (eV)', fontsize=12, fontweight='bold')

# Ëª∏„ÅÆÁØÑÂõ≤„ÇíÂà∂ÈôêÔºàÁÑ°ÈôêÈÅ†ÁÇπ„ÅÆÈô§Â§ñÔºâ
ax.set_xlim([points[:, 0].min() - 1, points[:, 0].max() + 1])
ax.set_ylim([points[:, 1].min() - 1, points[:, 1].max() + 1])

plt.tight_layout()
plt.savefig('voronoi_tessellation.png', dpi=300, bbox_inches='tight')
print(&quot;„Éú„É≠„Éé„Ç§ÂàÜÂâ≤„Çí voronoi_tessellation.png „Å´‰øùÂ≠ò„Åó„Åæ„Åó„Åü&quot;)
plt.show()
</code></pre>
<h3>„Ç≥„Éº„Éâ‰æã25: ÁâπÊÄßÂãæÈÖç„ÅÆÂèØË¶ñÂåñ</h3>
<pre><code class="language-python">import matplotlib.pyplot as plt
import numpy as np
from scipy.interpolate import griddata

# „Ç∞„É™„ÉÉ„Éâ„ÅÆ‰ΩúÊàê
grid_x, grid_y = np.mgrid[
    embeddings_umap[:, 0].min():embeddings_umap[:, 0].max():100j,
    embeddings_umap[:, 1].min():embeddings_umap[:, 1].max():100j
]

# Ë£úÈñì
grid_z = griddata(
    embeddings_umap,
    targets,
    (grid_x, grid_y),
    method='cubic'
)

# „Éó„É≠„ÉÉ„Éà
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(18, 7))

# Á≠âÈ´òÁ∑öÂõ≥
contour = ax1.contourf(grid_x, grid_y, grid_z, levels=20, cmap='viridis', alpha=0.8)
ax1.scatter(embeddings_umap[:, 0], embeddings_umap[:, 1],
            c='white', s=5, alpha=0.5, edgecolors='none')
ax1.set_xlabel('UMAP 1', fontsize=14, fontweight='bold')
ax1.set_ylabel('UMAP 2', fontsize=14, fontweight='bold')
ax1.set_title('Band Gap Contour Map', fontsize=16, fontweight='bold')
cbar1 = plt.colorbar(contour, ax=ax1)
cbar1.set_label('Band Gap (eV)', fontsize=12, fontweight='bold')

# ÂãæÈÖç„Éô„ÇØ„Éà„É´
gradient_y, gradient_x = np.gradient(grid_z)

# „Çµ„Éñ„Çµ„É≥„Éó„É™„É≥„Ç∞ÔºàÁü¢Âç∞„ÅÆÂØÜÂ∫¶Ë™øÊï¥Ôºâ
skip = 5
ax2.contourf(grid_x, grid_y, grid_z, levels=20, cmap='viridis', alpha=0.6)
ax2.quiver(grid_x[::skip, ::skip], grid_y[::skip, ::skip],
           gradient_x[::skip, ::skip], gradient_y[::skip, ::skip],
           color='white', alpha=0.8, scale=50)
ax2.scatter(embeddings_umap[:, 0], embeddings_umap[:, 1],
            c='black', s=5, alpha=0.3, edgecolors='none')
ax2.set_xlabel('UMAP 1', fontsize=14, fontweight='bold')
ax2.set_ylabel('UMAP 2', fontsize=14, fontweight='bold')
ax2.set_title('Band Gap Gradient Field', fontsize=16, fontweight='bold')
cbar2 = plt.colorbar(contour, ax=ax2)
cbar2.set_label('Band Gap (eV)', fontsize=12, fontweight='bold')

plt.tight_layout()
plt.savefig('property_gradient.png', dpi=300, bbox_inches='tight')
print(&quot;ÁâπÊÄßÂãæÈÖç„Çí property_gradient.png „Å´‰øùÂ≠ò„Åó„Åæ„Åó„Åü&quot;)
plt.show()
</code></pre>
<h3>„Ç≥„Éº„Éâ‰æã26: Âüã„ÇÅËæº„Åø„ÅÆÂÆâÂÆöÊÄßË©ï‰æ°</h3>
<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
from sklearn.model_selection import KFold

def evaluate_embedding_stability(model, dataset, device, n_splits=5):
    &quot;&quot;&quot;
    „ÇØ„É≠„Çπ„Éê„É™„Éá„Éº„Ç∑„Éß„É≥„ÅßÂüã„ÇÅËæº„Åø„ÅÆÂÆâÂÆöÊÄß„ÇíË©ï‰æ°

    Parameters:
    -----------
    model : nn.Module
        „É¢„Éá„É´ÔºàÂÜçÂ≠¶ÁøíÁî®Ôºâ
    dataset : Dataset
        „Éá„Éº„Çø„Çª„ÉÉ„Éà
    device : torch.device
        „Éá„Éê„Ç§„Çπ
    n_splits : int
        ÂàÜÂâ≤Êï∞

    Returns:
    --------
    stability_scores : list
        ÂÆâÂÆöÊÄß„Çπ„Ç≥„Ç¢
    &quot;&quot;&quot;
    kfold = KFold(n_splits=n_splits, shuffle=True, random_state=42)

    embeddings_list = []

    for fold, (train_idx, val_idx) in enumerate(kfold.split(range(len(dataset)))):
        print(f&quot;Fold {fold+1}/{n_splits}&quot;)

        # ÁúÅÁï•: „Åì„Åì„ÅßÂêÑfold„Åß„É¢„Éá„É´„ÇíÂÜçÂ≠¶Áøí
        # ÂÆüÈöõ„Å´„ÅØÊñ∞„Åó„ÅÑ„É¢„Éá„É´„Ç§„É≥„Çπ„Çø„É≥„Çπ„Çí‰ΩúÊàê„Åó„ÄÅtrain_idx „ÅßÂ≠¶Áøí

        # „Éá„É¢Áî®: Êó¢Â≠ò„ÅÆÂüã„ÇÅËæº„Åø„Çí‰ΩøÁî®
        embeddings_list.append(embeddings)

    # Âüã„ÇÅËæº„ÅøÈñì„ÅÆÈ°û‰ººÂ∫¶„ÇíË®àÁÆó
    from sklearn.metrics.pairwise import cosine_similarity

    similarities = []
    for i in range(len(embeddings_list)):
        for j in range(i+1, len(embeddings_list)):
            sim_matrix = cosine_similarity(embeddings_list[i], embeddings_list[j])
            # ÂØæËßíÊàêÂàÜ„ÅÆÂπ≥ÂùáÔºàÂêÑÁÇπ„ÅÆÂØæÂøú„Åô„ÇãÂüã„ÇÅËæº„ÅøÈñì„ÅÆÈ°û‰ººÂ∫¶Ôºâ
            sim_score = np.mean(np.diag(sim_matrix))
            similarities.append(sim_score)

    return similarities


# ÂÆüË°åÔºà„Éá„É¢Ôºâ
print(&quot;Âüã„ÇÅËæº„ÅøÂÆâÂÆöÊÄßË©ï‰æ°Ôºà„Éá„É¢Ôºâ:&quot;)
stability_scores = evaluate_embedding_stability(model, dataset, device, n_splits=3)
print(f&quot;Âπ≥ÂùáÈ°û‰ººÂ∫¶: {np.mean(stability_scores):.3f}&quot;)
print(f&quot;Ê®ôÊ∫ñÂÅèÂ∑Æ: {np.std(stability_scores):.3f}&quot;)
</code></pre>
<h3>„Ç≥„Éº„Éâ‰æã27: „Ç¢„É≥„Çµ„É≥„Éñ„É´„É¢„Éá„É´„ÅÆÂüã„ÇÅËæº„ÅøÁµ±Âêà</h3>
<pre><code class="language-python">def create_ensemble_embeddings(models_list, dataset, device):
    &quot;&quot;&quot;
    Ë§áÊï∞„É¢„Éá„É´„ÅÆÂüã„ÇÅËæº„Åø„ÇíÁµ±Âêà

    Parameters:
    -----------
    models_list : list
        Â≠¶ÁøíÊ∏à„Åø„É¢„Éá„É´„ÅÆ„É™„Çπ„Éà
    dataset : Dataset
        „Éá„Éº„Çø„Çª„ÉÉ„Éà
    device : torch.device
        „Éá„Éê„Ç§„Çπ

    Returns:
    --------
    ensemble_embeddings : np.ndarray
        Áµ±Âêà„Åï„Çå„ÅüÂüã„ÇÅËæº„Åø
    &quot;&quot;&quot;
    all_embeddings = []

    for model in models_list:
        emb, _ = extract_all_embeddings(model, dataset, device)
        all_embeddings.append(emb)

    # Âπ≥Âùá„ÇíÂèñ„Çã
    ensemble_embeddings = np.mean(all_embeddings, axis=0)

    return ensemble_embeddings


# „Éá„É¢: Âçò‰∏Ä„É¢„Éá„É´„Çí3Âõû‰ΩøÁî®ÔºàÂÆüÈöõ„Å´„ÅØÁï∞„Å™„Çã„É¢„Éá„É´„Çí‰ΩøÁî®Ôºâ
print(&quot;„Ç¢„É≥„Çµ„É≥„Éñ„É´Âüã„ÇÅËæº„Åø„ÅÆ„Éá„É¢:&quot;)
models_list = [model, model, model]  # ÂÆüÈöõ„Å´„ÅØÁï∞„Å™„Çã„É¢„Éá„É´

ensemble_emb = create_ensemble_embeddings(models_list, dataset, device)
print(f&quot;„Ç¢„É≥„Çµ„É≥„Éñ„É´Âüã„ÇÅËæº„Åø„ÅÆÂΩ¢Áä∂: {ensemble_emb.shape}&quot;)
</code></pre>
<h3>„Ç≥„Éº„Éâ‰æã28: ÊôÇÁ≥ªÂàóÁöÑ„Å™ÊùêÊñôÁ©∫Èñì„ÅÆÂ§âÂåñÔºàÊã°ÂºµÊÄßÔºâ</h3>
<pre><code class="language-python">&quot;&quot;&quot;
ÊôÇÁ≥ªÂàó„Éá„Éº„Çø„ÇÑË§áÊï∞„Éê„Éº„Ç∏„Éß„É≥„ÅÆ„É¢„Éá„É´„ÅßÊùêÊñôÁ©∫Èñì„ÅÆÂ§âÂåñ„ÇíËøΩË∑°

def visualize_materials_space_evolution(
    embeddings_timeline,
    targets_timeline,
    timestamps
):
    '''
    ÊôÇÁ≥ªÂàóÁöÑ„Å™ÊùêÊñôÁ©∫Èñì„ÅÆÂ§âÂåñ„ÇíÂèØË¶ñÂåñ

    Parameters:
    -----------
    embeddings_timeline : list of np.ndarray
        ÂêÑÊôÇÁÇπ„Åß„ÅÆÂüã„ÇÅËæº„Åø
    targets_timeline : list of np.ndarray
        ÂêÑÊôÇÁÇπ„Åß„ÅÆ„Çø„Éº„Ç≤„ÉÉ„Éà
    timestamps : list
        „Çø„Ç§„É†„Çπ„Çø„É≥„Éó

    Returns:
    --------
    animation or multiple plots
    '''
    import matplotlib.animation as animation

    fig, ax = plt.subplots(figsize=(10, 8))

    def update(frame):
        ax.clear()
        embeddings = embeddings_timeline[frame]
        targets = targets_timeline[frame]

        scatter = ax.scatter(embeddings[:, 0], embeddings[:, 1],
                            c=targets, cmap='viridis', s=50, alpha=0.6)
        ax.set_title(f'Materials Space at {timestamps[frame]}')
        ax.set_xlabel('Component 1')
        ax.set_ylabel('Component 2')

        return scatter,

    anim = animation.FuncAnimation(fig, update, frames=len(timestamps),
                                  interval=500, blit=False)

    return anim
'''

print(&quot;ÊôÇÁ≥ªÂàóÂèØË¶ñÂåñ„ÅÆÊã°ÂºµÊÄß„Ç≥„Éº„Éâ‰æã„ÇíË°®Á§∫„Åó„Åæ„Åó„Åü&quot;)
&quot;&quot;&quot;
</code></pre>
<h3>„Ç≥„Éº„Éâ‰æã29: Â§ñÊåøÈ†òÂüü„ÅÆÊ§úÂá∫</h3>
<pre><code class="language-python">from sklearn.ensemble import IsolationForest
import matplotlib.pyplot as plt
import numpy as np

# Â≠¶Áøí„Éá„Éº„Çø„ÅÆÂüã„ÇÅËæº„ÅøÁØÑÂõ≤„ÇíÂ≠¶Áøí
train_embeddings = embeddings[train_idx]

# Isolation Forest„ÅßÂ§ñ„ÇåÂÄ§ÔºàÂ§ñÊåøÈ†òÂüüÔºâ„ÇíÊ§úÂá∫
iso_forest = IsolationForest(contamination=0.1, random_state=42)
iso_forest.fit(train_embeddings)

# ÂÖ®„Éá„Éº„Çø„Åß‰∫àÊ∏¨
outlier_labels = iso_forest.predict(embeddings)
outlier_scores = iso_forest.score_samples(embeddings)

# „Éó„É≠„ÉÉ„Éà
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(18, 7))

# Â§ñ„ÇåÂÄ§„É©„Éô„É´
colors_outlier = ['red' if label == -1 else 'blue' for label in outlier_labels]
ax1.scatter(embeddings_umap[:, 0], embeddings_umap[:, 1],
            c=colors_outlier, s=50, alpha=0.6, edgecolors='black', linewidth=0.5)
ax1.set_xlabel('UMAP 1', fontsize=14, fontweight='bold')
ax1.set_ylabel('UMAP 2', fontsize=14, fontweight='bold')
ax1.set_title('Extrapolation Region Detection (Red = Outlier)',
              fontsize=16, fontweight='bold')
ax1.grid(True, alpha=0.3)

# Â§ñ„ÇåÂÄ§„Çπ„Ç≥„Ç¢
scatter = ax2.scatter(embeddings_umap[:, 0], embeddings_umap[:, 1],
                      c=outlier_scores, cmap='RdYlGn', s=50, alpha=0.6,
                      edgecolors='black', linewidth=0.5)
ax2.set_xlabel('UMAP 1', fontsize=14, fontweight='bold')
ax2.set_ylabel('UMAP 2', fontsize=14, fontweight='bold')
ax2.set_title('Anomaly Score (Green = Normal, Red = Outlier)',
              fontsize=16, fontweight='bold')
ax2.grid(True, alpha=0.3)
cbar = plt.colorbar(scatter, ax=ax2)
cbar.set_label('Anomaly Score', fontsize=12, fontweight='bold')

plt.tight_layout()
plt.savefig('extrapolation_detection.png', dpi=300, bbox_inches='tight')
print(&quot;Â§ñÊåøÈ†òÂüüÊ§úÂá∫„Çí extrapolation_detection.png „Å´‰øùÂ≠ò„Åó„Åæ„Åó„Åü&quot;)
plt.show()

print(f&quot;\nÂ§ñ„ÇåÂÄ§Êï∞: {np.sum(outlier_labels == -1)} / {len(outlier_labels)}&quot;)
</code></pre>
<h3>„Ç≥„Éº„Éâ‰æã30: Á∑èÂêà„É¨„Éù„Éº„Éà„ÅÆÁîüÊàê</h3>
<pre><code class="language-python">import json
from datetime import datetime

def generate_comprehensive_report(
    model, dataset, embeddings, targets,
    materials_df, cluster_labels, test_predictions, test_targets
):
    &quot;&quot;&quot;
    Á∑èÂêàÁöÑ„Å™ÂàÜÊûê„É¨„Éù„Éº„Éà„ÇíÁîüÊàê

    Parameters:
    -----------
    model : nn.Module
        Â≠¶ÁøíÊ∏à„Åø„É¢„Éá„É´
    dataset : Dataset
        „Éá„Éº„Çø„Çª„ÉÉ„Éà
    embeddings : np.ndarray
        Âüã„ÇÅËæº„Åø
    targets : np.ndarray
        „Çø„Éº„Ç≤„ÉÉ„Éà
    materials_df : pd.DataFrame
        ÊùêÊñô„Éá„Éº„Çø
    cluster_labels : np.ndarray
        „ÇØ„É©„Çπ„Çø„É©„Éô„É´
    test_predictions : np.ndarray
        „ÉÜ„Çπ„Éà‰∫àÊ∏¨ÂÄ§
    test_targets : np.ndarray
        „ÉÜ„Çπ„ÉàÁúüÂÄ§

    Returns:
    --------
    report : dict
        „É¨„Éù„Éº„ÉàËæûÊõ∏
    &quot;&quot;&quot;
    from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score

    # „É¢„Éá„É´ÊÄßËÉΩ
    mae = mean_absolute_error(test_targets, test_predictions)
    rmse = np.sqrt(mean_squared_error(test_targets, test_predictions))
    r2 = r2_score(test_targets, test_predictions)

    # Âüã„ÇÅËæº„ÅøÁµ±Ë®à
    embedding_stats = {
        'dimension': embeddings.shape[1],
        'mean_norm': float(np.mean(np.linalg.norm(embeddings, axis=1))),
        'std_norm': float(np.std(np.linalg.norm(embeddings, axis=1))),
    }

    # „ÇØ„É©„Çπ„ÇøÁµ±Ë®à
    cluster_stats = {}
    for cluster_id in np.unique(cluster_labels):
        mask = cluster_labels == cluster_id
        cluster_stats[f'cluster_{cluster_id}'] = {
            'size': int(np.sum(mask)),
            'mean_band_gap': float(np.mean(targets[mask])),
            'std_band_gap': float(np.std(targets[mask]))
        }

    # „É¨„Éù„Éº„Éà
    report = {
        'metadata': {
            'timestamp': datetime.now().isoformat(),
            'dataset_size': len(dataset),
            'model_parameters': sum(p.numel() for p in model.parameters())
        },
        'model_performance': {
            'MAE': float(mae),
            'RMSE': float(rmse),
            'R2': float(r2)
        },
        'embedding_statistics': embedding_stats,
        'cluster_statistics': cluster_stats,
        'target_statistics': {
            'mean': float(np.mean(targets)),
            'std': float(np.std(targets)),
            'min': float(np.min(targets)),
            'max': float(np.max(targets))
        }
    }

    return report


# „É¨„Éù„Éº„ÉàÁîüÊàê
report = generate_comprehensive_report(
    model, dataset, embeddings, targets,
    materials_df, cluster_labels,
    test_predictions, test_targets
)

# JSONÂΩ¢Âºè„Åß‰øùÂ≠ò
with open('comprehensive_report.json', 'w') as f:
    json.dump(report, f, indent=2)

print(&quot;Á∑èÂêà„É¨„Éù„Éº„Éà„Çí comprehensive_report.json „Å´‰øùÂ≠ò„Åó„Åæ„Åó„Åü\n&quot;)
print(&quot;„É¨„Éù„Éº„Éà„Çµ„Éû„É™„Éº:&quot;)
print(json.dumps(report, indent=2)[:1000] + &quot;...&quot;)

# Markdown„É¨„Éù„Éº„ÉàÁîüÊàê
markdown_report = f&quot;&quot;&quot;
# ÊùêÊñôÁ©∫Èñì„Éû„ÉÉ„Éî„É≥„Ç∞ - Á∑èÂêà„É¨„Éù„Éº„Éà

ÁîüÊàêÊó•ÊôÇ: {report['metadata']['timestamp']}

## 1. „Éá„Éº„Çø„Çª„ÉÉ„ÉàÊÉÖÂ†±

- „Éá„Éº„Çø„Çª„ÉÉ„Éà„Çµ„Ç§„Ç∫: {report['metadata']['dataset_size']}
- „É¢„Éá„É´„Éë„É©„É°„Éº„ÇøÊï∞: {report['metadata']['model_parameters']:,}

## 2. „É¢„Éá„É´ÊÄßËÉΩ

| ÊåáÊ®ô | ÂÄ§ |
|------|-----|
| MAE  | {report['model_performance']['MAE']:.4f} |
| RMSE | {report['model_performance']['RMSE']:.4f} |
| R¬≤   | {report['model_performance']['R2']:.4f} |

## 3. Âüã„ÇÅËæº„ÅøÁµ±Ë®à

- Ê¨°ÂÖÉÊï∞: {report['embedding_statistics']['dimension']}
- Âπ≥Âùá„Éé„É´„É†: {report['embedding_statistics']['mean_norm']:.3f}
- „Éé„É´„É†Ê®ôÊ∫ñÂÅèÂ∑Æ: {report['embedding_statistics']['std_norm']:.3f}

## 4. „Çø„Éº„Ç≤„ÉÉ„ÉàÁâπÊÄßÁµ±Ë®à

| Áµ±Ë®àÈáè | ÂÄ§ (eV) |
|--------|---------|
| Âπ≥Âùá   | {report['target_statistics']['mean']:.3f} |
| Ê®ôÊ∫ñÂÅèÂ∑Æ | {report['target_statistics']['std']:.3f} |
| ÊúÄÂ∞èÂÄ§ | {report['target_statistics']['min']:.3f} |
| ÊúÄÂ§ßÂÄ§ | {report['target_statistics']['max']:.3f} |

## 5. „ÇØ„É©„Çπ„ÇøÂàÜÊûê

&quot;&quot;&quot;

for cluster_id, stats in report['cluster_statistics'].items():
    markdown_report += f&quot;- **{cluster_id}**: „Çµ„Ç§„Ç∫={stats['size']}, Âπ≥Âùá„Éê„É≥„Éâ„ÇÆ„É£„ÉÉ„Éó={stats['mean_band_gap']:.3f} eV\n&quot;

markdown_report += &quot;&quot;&quot;

## 6. ÁîüÊàê„Åï„Çå„ÅüÂèØË¶ñÂåñ

- `training_curve.png`: Â≠¶ÁøíÊõ≤Á∑ö
- `test_evaluation.png`: „ÉÜ„Çπ„ÉàË©ï‰æ°
- `pca_2d_projection.png`: PCA 2DÂ∞ÑÂΩ±
- `umap_2d_projection.png`: UMAP 2DÂ∞ÑÂΩ±
- `tsne_2d_projection.png`: t-SNE 2DÂ∞ÑÂΩ±
- `clustering_analysis.png`: „ÇØ„É©„Çπ„Çø„É™„É≥„Ç∞ÂàÜÊûê
- `materials_3d_interactive.html`: „Ç§„É≥„Çø„É©„ÇØ„ÉÜ„Ç£„Éñ3DÂèØË¶ñÂåñ
- `materials_interactive.html`: „Ç§„É≥„Çø„É©„ÇØ„ÉÜ„Ç£„Éñ2DÂèØË¶ñÂåñ

## 7. „Åæ„Å®„ÇÅ

Êú¨ÂàÜÊûê„Åß„ÅØ„ÄÅGNN„Å´„Çà„ÇãÊùêÊñôË°®ÁèæÂ≠¶Áøí„Å®Ê¨°ÂÖÉÂâäÊ∏õ„ÇíÁµÑ„ÅøÂêà„Çè„Åõ„Çã„Åì„Å®„Åß„ÄÅ
È´òÊ¨°ÂÖÉ„ÅÆÊùêÊñôÁ©∫Èñì„ÇíÂäπÊûúÁöÑ„Å´ÂèØË¶ñÂåñ„Åó„ÄÅÊùêÊñôÈñì„ÅÆÈ°û‰ººÊÄß„ÇÑÁâπÊÄß„Éà„É¨„É≥„Éâ„Çí
Êòé„Çâ„Åã„Å´„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åó„Åü„ÄÇ

&quot;&quot;&quot;

# Markdown„É¨„Éù„Éº„Éà„ÅÆ‰øùÂ≠ò
with open('comprehensive_report.md', 'w') as f:
    f.write(markdown_report)

print(&quot;\nMarkdown„É¨„Éù„Éº„Éà„Çí comprehensive_report.md „Å´‰øùÂ≠ò„Åó„Åæ„Åó„Åü&quot;)
</code></pre>
<h2>4.8 „Åæ„Å®„ÇÅ</h2>
<p>Êú¨Á´†„Åß„ÅØ„ÄÅGNN„Å®Ê¨°ÂÖÉÂâäÊ∏õ„ÇíÁµÑ„ÅøÂêà„Çè„Åõ„ÅüÂÆüË∑µÁöÑ„Å™ÊùêÊñô„Éû„ÉÉ„Éî„É≥„Ç∞„Ç∑„Çπ„ÉÜ„É†„ÇíÊßãÁØâ„Åó„Åæ„Åó„Åü„ÄÇ</p>
<h3>ÂÆüË£Ö„Åó„ÅüÊ©üËÉΩ</h3>
<table>
<thead>
<tr>
<th>Ê©üËÉΩ</th>
<th>„Ç≥„Éº„Éâ‰æãÊï∞</th>
<th>‰∏ª„Å™ÂÜÖÂÆπ</th>
</tr>
</thead>
<tbody>
<tr>
<td>„Éá„Éº„ÇøÂèéÈõÜ„ÉªÊ∫ñÂÇô</td>
<td>‰æã1-6</td>
<td>MP API„ÄÅ„Ç∞„É©„ÉïÂ§âÊèõ„ÄÅ„Éá„Éº„Çø„Çª„ÉÉ„Éà</td>
</tr>
<tr>
<td>„É¢„Éá„É´Â≠¶Áøí</td>
<td>‰æã7-10</td>
<td>CGCNN„ÄÅÂ≠¶Áøí„É´„Éº„Éó„ÄÅË©ï‰æ°</td>
</tr>
<tr>
<td>Âüã„ÇÅËæº„ÅøÊäΩÂá∫„ÉªÊ¨°ÂÖÉÂâäÊ∏õ</td>
<td>‰æã11-15</td>
<td>PCA„ÄÅUMAP„ÄÅt-SNE„ÄÅÊØîËºÉ</td>
</tr>
<tr>
<td>ÊùêÊñôÁ©∫ÈñìÂàÜÊûê</td>
<td>‰æã16-20</td>
<td>„ÇØ„É©„Çπ„Çø„É™„É≥„Ç∞„ÄÅËøëÂÇçÊé¢Á¥¢„ÄÅÊé®Ëñ¶</td>
</tr>
<tr>
<td>„Ç§„É≥„Çø„É©„ÇØ„ÉÜ„Ç£„ÉñÂèØË¶ñÂåñ</td>
<td>‰æã21-23</td>
<td>Plotly 3D„ÄÅBokeh„ÄÅDash</td>
</tr>
<tr>
<td>È´òÂ∫¶„Å™ÂàÜÊûê</td>
<td>‰æã24-30</td>
<td>„Éú„É≠„Éé„Ç§„ÄÅÂãæÈÖç„ÄÅÂ§ñÊåø„ÄÅ„É¨„Éù„Éº„Éà</td>
</tr>
</tbody>
</table>
<h3>„Éô„Çπ„Éà„Éó„É©„ÇØ„ÉÜ„Ç£„Çπ</h3>
<ol>
<li><strong>„Éá„Éº„ÇøÂâçÂá¶ÁêÜ</strong>: Ê®ôÊ∫ñÂåñ„ÄÅÊ¨†ÊêçÂÄ§Âá¶ÁêÜ„ÄÅÂ§ñ„ÇåÂÄ§Èô§Âéª</li>
<li><strong>„É¢„Éá„É´Â≠¶Áøí</strong>: Early Stopping„ÄÅÂ≠¶ÁøíÁéá„Çπ„Ç±„Ç∏„É•„Éº„É™„É≥„Ç∞„ÄÅÊ≠£ÂâáÂåñ</li>
<li><strong>Ê¨°ÂÖÉÂâäÊ∏õ</strong>: Ë§áÊï∞ÊâãÊ≥ï„ÅÆÊØîËºÉ„ÄÅ„Éë„É©„É°„Éº„Çø„ÉÅ„É•„Éº„Éã„É≥„Ç∞</li>
<li><strong>ÂèØË¶ñÂåñ</strong>: „Ç§„É≥„Çø„É©„ÇØ„ÉÜ„Ç£„ÉñÊÄß„ÄÅË§áÊï∞Ë¶ñÁÇπ„ÄÅË™¨ÊòéÊÄß</li>
<li><strong>ÂÜçÁèæÊÄß</strong>: ‰π±Êï∞„Ç∑„Éº„ÉâÂõ∫ÂÆö„ÄÅË®≠ÂÆö‰øùÂ≠ò„ÄÅ„Éê„Éº„Ç∏„Éß„É≥ÁÆ°ÁêÜ</li>
</ol>
<h3>ÂøúÁî®ÂèØËÉΩÊÄß</h3>
<ul>
<li><strong>ÊùêÊñôÊé¢Á¥¢</strong>: ÁõÆÊ®ôÁâπÊÄß„ÇíÊåÅ„Å§ÊùêÊñô„ÅÆÊé®Ëñ¶</li>
<li><strong>ÁâπÊÄß‰∫àÊ∏¨</strong>: Êñ∞Ë¶èÊùêÊñô„ÅÆÁâπÊÄß‰∫àÊ∏¨</li>
<li><strong>ÊßãÈÄ†-ÁâπÊÄßÈñ¢‰øÇ</strong>: ÊùêÊñôÁ©∫Èñì„Åß„ÅÆÊßãÈÄ†„Å®ÁâπÊÄß„ÅÆÈñ¢‰øÇËß£Êòé</li>
<li><strong>ÂÆüÈ®ìË®àÁîª</strong>: Ê¨°„Å´ÂêàÊàê„Åô„Åπ„ÅçÊùêÊñô„ÅÆÊèêÊ°à</li>
</ul>
<h3>‰ªäÂæå„ÅÆÁô∫Â±ï</h3>
<ul>
<li><strong>„Éû„É´„ÉÅ„Çø„Çπ„ÇØÂ≠¶Áøí</strong>: Ë§áÊï∞ÁâπÊÄß„ÅÆÂêåÊôÇ‰∫àÊ∏¨</li>
<li><strong>Ëª¢ÁßªÂ≠¶Áøí</strong>: Â∞èË¶èÊ®°„Éá„Éº„Çø„Çª„ÉÉ„Éà„Å∏„ÅÆÈÅ©Áî®</li>
<li><strong>ËÉΩÂãïÂ≠¶Áøí</strong>: ÂäπÁéáÁöÑ„Å™„Éá„Éº„ÇøÂèéÈõÜÊà¶Áï•</li>
<li><strong>Ë™¨ÊòéÂèØËÉΩAI</strong>: GNN‰∫àÊ∏¨„ÅÆËß£ÈáàÊÄßÂêë‰∏ä</li>
</ul>
<hr />
<p><strong>ÂâçÁ´†</strong>: <a href="chapter-3.html">Á¨¨3Á´†ÔºöGNN„Å´„Çà„ÇãÊùêÊñôË°®ÁèæÂ≠¶Áøí</a></p>
<p><strong>„Ç∑„É™„Éº„Ç∫„Éà„ÉÉ„Éó</strong>: <a href="index.html">ÊùêÊñôÁâπÊÄß„Éû„ÉÉ„Éî„É≥„Ç∞ÂÖ•ÈñÄ</a></p>
<h2>„Åï„Çâ„Å´Â≠¶„Å∂„Åü„ÇÅ„Å´</h2>
<h3>Êé®Ëñ¶ÊñáÁåÆ</h3>
<ol>
<li><strong>GNN for Materials</strong>: "Graph Networks as a Universal Machine Learning Framework for Molecules and Crystals" (Xie &amp; Grossman, 2018)</li>
<li><strong>UMAP</strong>: "UMAP: Uniform Manifold Approximation and Projection" (McInnes et al., 2018)</li>
<li><strong>Materials Informatics</strong>: "Materials Informatics" (Ramprasad et al., 2017)</li>
</ol>
<h3>Èñ¢ÈÄ£„É™„ÇΩ„Éº„Çπ</h3>
<ul>
<li><a href="https://materialsproject.org/">Materials Project</a></li>
<li><a href="https://pytorch-geometric.readthedocs.io/">PyTorch Geometric</a></li>
<li><a href="https://umap-learn.readthedocs.io/">UMAP Documentation</a></li>
</ul>
<p>„ÅäÁñ≤„ÇåÊßò„Åß„Åó„ÅüÔºÅÊú¨„Ç∑„É™„Éº„Ç∫„ÇíÈÄö„Åò„Å¶„ÄÅÊùêÊñôÁâπÊÄß„Éû„ÉÉ„Éî„É≥„Ç∞„ÅÆÂü∫Á§é„Åã„ÇâÂÆüË∑µ„Åæ„Åß„ÇíÂ≠¶„Å≥„Åæ„Åó„Åü„ÄÇ</p><div class="navigation">
    <a href="index.html" class="nav-button">„Ç∑„É™„Éº„Ç∫ÁõÆÊ¨°„Å´Êàª„Çã</a>
</div>
    </main>

    <footer>
        <p><strong>‰ΩúÊàêËÄÖ</strong>: AI Terakoya Content Team</p>
        <p><strong>Áõ£‰øÆ</strong>: Dr. Yusuke HashimotoÔºàÊù±ÂåóÂ§ßÂ≠¶Ôºâ</p>
        <p><strong>„Éê„Éº„Ç∏„Éß„É≥</strong>: 1.0 | <strong>‰ΩúÊàêÊó•</strong>: 2025-10-17</p>
        <p><strong>„É©„Ç§„Çª„É≥„Çπ</strong>: Creative Commons BY 4.0</p>
        <p>¬© 2025 AI Terakoya. All rights reserved.</p>
    </footer>
</body>
</html>
