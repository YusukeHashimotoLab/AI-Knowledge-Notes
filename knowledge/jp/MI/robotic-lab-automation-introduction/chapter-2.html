<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter - AI Terakoya</title>

    <style>
        :root {
            --color-primary: #2c3e50;
            --color-primary-dark: #1a252f;
            --color-accent: #7b2cbf;
            --color-accent-light: #9d4edd;
            --color-text: #2d3748;
            --color-text-light: #4a5568;
            --color-bg: #ffffff;
            --color-bg-alt: #f7fafc;
            --color-border: #e2e8f0;
            --color-code-bg: #f8f9fa;
            --color-link: #3182ce;
            --color-link-hover: #2c5aa0;

            --spacing-xs: 0.5rem;
            --spacing-sm: 1rem;
            --spacing-md: 1.5rem;
            --spacing-lg: 2rem;
            --spacing-xl: 3rem;

            --font-body: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            --font-mono: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;

            --border-radius: 8px;
            --box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-body);
            line-height: 1.7;
            color: var(--color-text);
            background-color: var(--color-bg);
            font-size: 16px;
        }

        header {
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            color: white;
            padding: var(--spacing-xl) var(--spacing-md);
            margin-bottom: var(--spacing-xl);
            box-shadow: var(--box-shadow);
        }

        .header-content {
            max-width: 900px;
            margin: 0 auto;
        }

        h1 {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: var(--spacing-sm);
            line-height: 1.2;
        }

        .subtitle {
            font-size: 1.1rem;
            opacity: 0.95;
            font-weight: 400;
            margin-bottom: var(--spacing-md);
        }

        .meta {
            display: flex;
            flex-wrap: wrap;
            gap: var(--spacing-md);
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .meta-item {
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 0 var(--spacing-md) var(--spacing-xl);
        }

        h2 {
            font-size: 1.75rem;
            color: var(--color-primary);
            margin-top: var(--spacing-xl);
            margin-bottom: var(--spacing-md);
            padding-bottom: var(--spacing-xs);
            border-bottom: 3px solid var(--color-accent);
        }

        h3 {
            font-size: 1.4rem;
            color: var(--color-primary);
            margin-top: var(--spacing-lg);
            margin-bottom: var(--spacing-sm);
        }

        h4 {
            font-size: 1.1rem;
            color: var(--color-primary-dark);
            margin-top: var(--spacing-md);
            margin-bottom: var(--spacing-sm);
        }

        p {
            margin-bottom: var(--spacing-md);
            color: var(--color-text);
        }

        a {
            color: var(--color-link);
            text-decoration: none;
            transition: color 0.2s;
        }

        a:hover {
            color: var(--color-link-hover);
            text-decoration: underline;
        }

        ul, ol {
            margin-left: var(--spacing-lg);
            margin-bottom: var(--spacing-md);
        }

        li {
            margin-bottom: var(--spacing-xs);
            color: var(--color-text);
        }

        pre {
            background-color: var(--color-code-bg);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            overflow-x: auto;
            margin-bottom: var(--spacing-md);
            font-family: var(--font-mono);
            font-size: 0.9rem;
            line-height: 1.5;
        }

        code {
            font-family: var(--font-mono);
            font-size: 0.9em;
            background-color: var(--color-code-bg);
            padding: 0.2em 0.4em;
            border-radius: 3px;
        }

        pre code {
            background-color: transparent;
            padding: 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: var(--spacing-md);
            font-size: 0.95rem;
        }

        th, td {
            border: 1px solid var(--color-border);
            padding: var(--spacing-sm);
            text-align: left;
        }

        th {
            background-color: var(--color-bg-alt);
            font-weight: 600;
            color: var(--color-primary);
        }

        blockquote {
            border-left: 4px solid var(--color-accent);
            padding-left: var(--spacing-md);
            margin: var(--spacing-md) 0;
            color: var(--color-text-light);
            font-style: italic;
            background-color: var(--color-bg-alt);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        .mermaid {
            text-align: center;
            margin: var(--spacing-lg) 0;
            background-color: var(--color-bg-alt);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        details {
            background-color: var(--color-bg-alt);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            margin-bottom: var(--spacing-md);
        }

        summary {
            cursor: pointer;
            font-weight: 600;
            color: var(--color-primary);
            user-select: none;
            padding: var(--spacing-xs);
            margin: calc(-1 * var(--spacing-md));
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        summary:hover {
            background-color: rgba(123, 44, 191, 0.1);
        }

        details[open] summary {
            margin-bottom: var(--spacing-md);
            border-bottom: 1px solid var(--color-border);
        }

        .learning-objectives {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            padding: var(--spacing-lg);
            border-radius: var(--border-radius);
            border-left: 4px solid var(--color-accent);
            margin-bottom: var(--spacing-xl);
        }

        .learning-objectives h2 {
            margin-top: 0;
            border-bottom: none;
        }

        .navigation {
            display: flex;
            justify-content: space-between;
            gap: var(--spacing-md);
            margin: var(--spacing-xl) 0;
            padding-top: var(--spacing-lg);
            border-top: 2px solid var(--color-border);
        }

        .nav-button {
            flex: 1;
            padding: var(--spacing-md);
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            color: white;
            border-radius: var(--border-radius);
            text-align: center;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: var(--box-shadow);
        }

        .nav-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            text-decoration: none;
        }

        footer {
            margin-top: var(--spacing-xl);
            padding: var(--spacing-lg) var(--spacing-md);
            background-color: var(--color-bg-alt);
            border-top: 1px solid var(--color-border);
            text-align: center;
            font-size: 0.9rem;
            color: var(--color-text-light);
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.5rem;
            }

            h2 {
                font-size: 1.4rem;
            }

            h3 {
                font-size: 1.2rem;
            }

            .meta {
                font-size: 0.85rem;
            }

            .navigation {
                flex-direction: column;
            }

            table {
                font-size: 0.85rem;
            }

            th, td {
                padding: var(--spacing-xs);
            }
        }
    </style>

    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <script>
        mermaid.initialize({ startOnLoad: true, theme: 'default', securityLevel: 'strict' });
    </script>

    <!-- MathJax for LaTeX equation rendering -->
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\(', '\)']],
                displayMath: [['$$', '$$'], ['\[', '\]']],
                processEscapes: true,
                processEnvironments: true
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
                ignoreHtmlClass: 'mermaid'
            }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" id="MathJax-script" async></script>
</head>
<body>
    <header>
        <div class="header-content">
            <h1>Chapter</h1>
            <p class="subtitle"></p>
            <div class="meta">
                <span class="meta-item">ğŸ“– èª­äº†æ™‚é–“: 20-25åˆ†</span>
                <span class="meta-item">ğŸ“Š é›£æ˜“åº¦: åˆç´š</span>
                <span class="meta-item">ğŸ’» ã‚³ãƒ¼ãƒ‰ä¾‹: 0å€‹</span>
                <span class="meta-item">ğŸ“ æ¼”ç¿’å•é¡Œ: 0å•</span>
            </div>
        </div>
    </header>

    <main class="container">
<h1>ç¬¬2ç« : ãƒ­ãƒœãƒ†ã‚£ã‚¯ã‚¹å®Ÿé¨“ã®åŸºç¤</h1>
<p><strong>å­¦ç¿’æ™‚é–“: 25-30åˆ†</strong></p>
<hr />
<h2>å°å…¥</h2>
<p>å®Ÿé¨“è‡ªå‹•åŒ–ã®å¿ƒè‡“éƒ¨ã¯ã€ãƒ­ãƒœãƒƒãƒˆã‚¢ãƒ¼ãƒ ã€æ¶²ä½“ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ ã€ã‚»ãƒ³ã‚µãƒ¼ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã§ã™ã€‚æœ¬ç« ã§ã¯ã€ã“ã‚Œã‚‰ã®åŸºç¤æŠ€è¡“ã‚’Pythonãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã‚’é€šã˜ã¦å®Ÿè·µçš„ã«å­¦ã³ã¾ã™ã€‚</p>
<p>OpenTrons OT-2æ¶²ä½“ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ãƒ­ãƒœãƒƒãƒˆã‚’ä¸­å¿ƒã«ã€å®Ÿéš›ã«å‹•ãã‚³ãƒ¼ãƒ‰ä¾‹ã‚’é€šã˜ã¦ã€è©¦è–¬ã®åˆ†æ³¨ã€ãƒ—ãƒ¬ãƒ¼ãƒˆã®ç§»å‹•ã€ã‚»ãƒ³ã‚µãƒ¼ãƒ‡ãƒ¼ã‚¿ã®å–å¾—ãªã©ã€è‡ªå‹•åŒ–å®Ÿé¨“ã®åŸºæœ¬æ“ä½œã‚’ç¿’å¾—ã—ã¾ã™ã€‚</p>
<hr />
<h2>å­¦ç¿’ç›®æ¨™</h2>
<p>æœ¬ç« ã‚’å­¦ç¿’ã™ã‚‹ã“ã¨ã§ã€ä»¥ä¸‹ã‚’ç¿’å¾—ã§ãã¾ã™ï¼š</p>
<ol>
<li><strong>ãƒ­ãƒœãƒƒãƒˆã‚¢ãƒ¼ãƒ åˆ¶å¾¡</strong>: é€†é‹å‹•å­¦ã€çµŒè·¯è¨ˆç”»ã®åŸºç¤ã¨Pythonå®Ÿè£…</li>
<li><strong>æ¶²ä½“ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°</strong>: OpenTrons OT-2ã§ã®ç²¾å¯†ãƒ”ãƒšãƒƒãƒ†ã‚£ãƒ³ã‚°</li>
<li><strong>å›ºä½“ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°</strong>: ç²‰æœ«è¨ˆé‡ã€éŒ å‰¤æˆå½¢ã®è‡ªå‹•åŒ–æ‰‹æ³•</li>
<li><strong>ã‚»ãƒ³ã‚µãƒ¼çµ±åˆ</strong>: ã‚«ãƒ¡ãƒ©ã€åˆ†å…‰è¨ˆã€XRDã¨ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹</li>
<li><strong>å®‰å…¨è¨­è¨ˆ</strong>: ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã€ç·Šæ€¥åœæ­¢ã€ç•°å¸¸æ¤œçŸ¥</li>
<li><strong>ãƒ©ãƒœã‚¦ã‚§ã‚¢æ¨™æº–åŒ–</strong>: ãƒã‚¤ã‚¯ãƒ­ãƒ—ãƒ¬ãƒ¼ãƒˆã€ãƒã‚¤ã‚¢ãƒ«ã€ã‚­ãƒ¥ãƒ™ãƒƒãƒˆã®çµ±ä¸€è¦æ ¼</li>
</ol>
<hr />
<h2>2.1 ãƒ­ãƒœãƒƒãƒˆã‚¢ãƒ¼ãƒ åˆ¶å¾¡ã®åŸºç¤</h2>
<h3>2.1.1 é †é‹å‹•å­¦ã¨é€†é‹å‹•å­¦</h3>
<p>ãƒ­ãƒœãƒƒãƒˆã‚¢ãƒ¼ãƒ ã®åˆ¶å¾¡ã«ã¯2ã¤ã®é‹å‹•å­¦å•é¡ŒãŒã‚ã‚Šã¾ã™ã€‚</p>
<p><strong>é †é‹å‹•å­¦ï¼ˆForward Kinematicsï¼‰</strong>:
é–¢ç¯€è§’åº¦ $\theta_1, \theta_2, ..., \theta_n$ ã‹ã‚‰ã‚¨ãƒ³ãƒ‰ã‚¨ãƒ•ã‚§ã‚¯ã‚¿ã®ä½ç½®ãƒ»å§¿å‹¢ $(x, y, z, roll, pitch, yaw)$ ã‚’è¨ˆç®—</p>
<p><strong>é€†é‹å‹•å­¦ï¼ˆInverse Kinematics, IKï¼‰</strong>:
ç›®æ¨™ä½ç½®ãƒ»å§¿å‹¢ã‹ã‚‰ãã‚Œã‚’å®Ÿç¾ã™ã‚‹é–¢ç¯€è§’åº¦ã‚’è¨ˆç®—ï¼ˆå®Ÿé¨“ã§ã¯é€šå¸¸ã“ã¡ã‚‰ã‚’ä½¿ç”¨ï¼‰</p>
<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

class SimpleRobotArm:
    &quot;&quot;&quot;
    2ãƒªãƒ³ã‚¯2Då¹³é¢ãƒ­ãƒœãƒƒãƒˆã‚¢ãƒ¼ãƒ ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
    ææ–™ç§‘å­¦å®Ÿé¨“ã§ã®è©¦è–¬ãƒœãƒˆãƒ«ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ã€ã‚µãƒ³ãƒ—ãƒ«ç§»å‹•ãªã©ã‚’æƒ³å®š
    &quot;&quot;&quot;

    def __init__(self, link1_length=0.3, link2_length=0.25):
        &quot;&quot;&quot;
        Args:
            link1_length: ç¬¬1ãƒªãƒ³ã‚¯ã®é•·ã•ï¼ˆãƒ¡ãƒ¼ãƒˆãƒ«ï¼‰
            link2_length: ç¬¬2ãƒªãƒ³ã‚¯ã®é•·ã•ï¼ˆãƒ¡ãƒ¼ãƒˆãƒ«ï¼‰
        &quot;&quot;&quot;
        self.L1 = link1_length
        self.L2 = link2_length

    def forward_kinematics(self, theta1, theta2):
        &quot;&quot;&quot;
        é †é‹å‹•å­¦: é–¢ç¯€è§’åº¦ã‹ã‚‰ã‚¨ãƒ³ãƒ‰ã‚¨ãƒ•ã‚§ã‚¯ã‚¿ä½ç½®ã‚’è¨ˆç®—

        Args:
            theta1: ç¬¬1é–¢ç¯€ã®è§’åº¦ï¼ˆåº¦ï¼‰
            theta2: ç¬¬2é–¢ç¯€ã®è§’åº¦ï¼ˆåº¦ï¼‰

        Returns:
            (x, y): ã‚¨ãƒ³ãƒ‰ã‚¨ãƒ•ã‚§ã‚¯ã‚¿ã®ä½ç½®
        &quot;&quot;&quot;
        # åº¦ã‚’ãƒ©ã‚¸ã‚¢ãƒ³ã«å¤‰æ›
        th1 = np.radians(theta1)
        th2 = np.radians(theta2)

        # ç¬¬1ãƒªãƒ³ã‚¯ã®å…ˆç«¯ä½ç½®
        x1 = self.L1 * np.cos(th1)
        y1 = self.L1 * np.sin(th1)

        # ã‚¨ãƒ³ãƒ‰ã‚¨ãƒ•ã‚§ã‚¯ã‚¿ã®ä½ç½®
        x = x1 + self.L2 * np.cos(th1 + th2)
        y = y1 + self.L2 * np.sin(th1 + th2)

        return x, y

    def inverse_kinematics(self, target_x, target_y):
        &quot;&quot;&quot;
        é€†é‹å‹•å­¦: ç›®æ¨™ä½ç½®ã‹ã‚‰é–¢ç¯€è§’åº¦ã‚’è¨ˆç®—

        Args:
            target_x: ç›®æ¨™Xåº§æ¨™
            target_y: ç›®æ¨™Yåº§æ¨™

        Returns:
            (theta1, theta2): é–¢ç¯€è§’åº¦ï¼ˆåº¦ï¼‰ã¾ãŸã¯ Noneï¼ˆåˆ°é”ä¸èƒ½ï¼‰
        &quot;&quot;&quot;
        # åˆ°é”å¯èƒ½æ€§ãƒã‚§ãƒƒã‚¯
        distance = np.sqrt(target_x**2 + target_y**2)
        if distance &gt; (self.L1 + self.L2) or distance &lt; abs(self.L1 - self.L2):
            print(f&quot;è­¦å‘Š: ç›®æ¨™ä½ç½® ({target_x:.2f}, {target_y:.2f}) ã¯åˆ°é”ä¸èƒ½&quot;)
            return None

        # ä½™å¼¦å®šç†ã«ã‚ˆã‚‹ç¬¬2é–¢ç¯€è§’åº¦ã®è¨ˆç®—
        cos_theta2 = (target_x**2 + target_y**2 - self.L1**2 - self.L2**2) / (2 * self.L1 * self.L2)
        # æ•°å€¤èª¤å·®å¯¾ç­–
        cos_theta2 = np.clip(cos_theta2, -1.0, 1.0)

        # Elbow-upã®è§£ã‚’é¸æŠï¼ˆå®Ÿé¨“ã§ä¸€èˆ¬çš„ï¼‰
        theta2_rad = np.arccos(cos_theta2)

        # ç¬¬1é–¢ç¯€è§’åº¦ã®è¨ˆç®—
        k1 = self.L1 + self.L2 * np.cos(theta2_rad)
        k2 = self.L2 * np.sin(theta2_rad)
        theta1_rad = np.arctan2(target_y, target_x) - np.arctan2(k2, k1)

        # ãƒ©ã‚¸ã‚¢ãƒ³ã‹ã‚‰åº¦ã«å¤‰æ›
        theta1 = np.degrees(theta1_rad)
        theta2 = np.degrees(theta2_rad)

        return theta1, theta2

    def plot_arm(self, theta1, theta2, target_point=None):
        &quot;&quot;&quot;ã‚¢ãƒ¼ãƒ ã®ç¾åœ¨ä½ç½®ã‚’å¯è¦–åŒ–&quot;&quot;&quot;
        th1 = np.radians(theta1)
        th2 = np.radians(theta2)

        # å„é–¢ç¯€ã®ä½ç½®
        x0, y0 = 0, 0  # ãƒ™ãƒ¼ã‚¹
        x1 = self.L1 * np.cos(th1)
        y1 = self.L1 * np.sin(th1)
        x2 = x1 + self.L2 * np.cos(th1 + th2)
        y2 = y1 + self.L2 * np.sin(th1 + th2)

        plt.figure(figsize=(8, 8))
        plt.plot([x0, x1, x2], [y0, y1, y2], 'o-', linewidth=3, markersize=10, label='ãƒ­ãƒœãƒƒãƒˆã‚¢ãƒ¼ãƒ ')
        plt.plot(x0, y0, 'ro', markersize=15, label='ãƒ™ãƒ¼ã‚¹')
        plt.plot(x2, y2, 'go', markersize=12, label='ã‚¨ãƒ³ãƒ‰ã‚¨ãƒ•ã‚§ã‚¯ã‚¿')

        if target_point:
            plt.plot(target_point[0], target_point[1], 'r*', markersize=20, label='ç›®æ¨™ä½ç½®')

        # åˆ°é”ç¯„å›²ã®å††
        theta = np.linspace(0, 2*np.pi, 100)
        r_max = self.L1 + self.L2
        r_min = abs(self.L1 - self.L2)
        plt.plot(r_max * np.cos(theta), r_max * np.sin(theta), 'k--', alpha=0.3, label='æœ€å¤§åˆ°é”ç¯„å›²')
        plt.plot(r_min * np.cos(theta), r_min * np.sin(theta), 'k--', alpha=0.3)

        plt.axis('equal')
        plt.grid(True, alpha=0.3)
        plt.xlabel('X ä½ç½® (m)', fontsize=12)
        plt.ylabel('Y ä½ç½® (m)', fontsize=12)
        plt.title('2ãƒªãƒ³ã‚¯ãƒ­ãƒœãƒƒãƒˆã‚¢ãƒ¼ãƒ ', fontsize=14, fontweight='bold')
        plt.legend()
        plt.tight_layout()


# ä½¿ç”¨ä¾‹
robot = SimpleRobotArm(link1_length=0.3, link2_length=0.25)

# é€†é‹å‹•å­¦ã®ä½¿ç”¨ä¾‹: è©¦è–¬ãƒœãƒˆãƒ« (0.4, 0.2) ã«ã‚¢ã‚¯ã‚»ã‚¹
target_x, target_y = 0.4, 0.2
angles = robot.inverse_kinematics(target_x, target_y)

if angles:
    theta1, theta2 = angles
    print(f&quot;ç›®æ¨™ä½ç½®: ({target_x}, {target_y})&quot;)
    print(f&quot;å¿…è¦ãªé–¢ç¯€è§’åº¦: Î¸1 = {theta1:.2f}Â°, Î¸2 = {theta2:.2f}Â°&quot;)

    # æ¤œè¨¼: é †é‹å‹•å­¦ã§ä½ç½®ã‚’ç¢ºèª
    x_check, y_check = robot.forward_kinematics(theta1, theta2)
    error = np.sqrt((x_check - target_x)**2 + (y_check - target_y)**2)
    print(f&quot;æ¤œè¨¼: å®Ÿéš›ã®ä½ç½® ({x_check:.4f}, {y_check:.4f}), èª¤å·® {error:.6f}m&quot;)

    # å¯è¦–åŒ–
    robot.plot_arm(theta1, theta2, target_point=(target_x, target_y))
    plt.savefig('robot_arm_ik.png', dpi=300, bbox_inches='tight')
    plt.show()
</code></pre>
<p><strong>ã‚³ãƒ¼ãƒ‰è§£èª¬</strong>:
1. <strong>é †é‹å‹•å­¦</strong>: ä¸‰è§’é–¢æ•°ã§å„ãƒªãƒ³ã‚¯ã®ä½ç½®ã‚’è¨ˆç®—
2. <strong>é€†é‹å‹•å­¦</strong>: ä½™å¼¦å®šç†ã¨ã‚¢ãƒ¼ã‚¯ã‚¿ãƒ³ã‚¸ã‚§ãƒ³ãƒˆã§é–¢ç¯€è§’åº¦ã‚’é€†ç®—
3. <strong>åˆ°é”å¯èƒ½æ€§</strong>: ç›®æ¨™è·é›¢ãŒ $|L_1 - L_2| \leq d \leq L_1 + L_2$ ã®ç¯„å›²ã«ã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
4. <strong>Elbow-up/down</strong>: åŒã˜ç›®æ¨™ä½ç½®ã«2ã¤ã®è§£ãŒã‚ã‚‹å ´åˆã€å®Ÿé¨“ã§ã¯é€šå¸¸elbow-upã‚’é¸æŠ</p>
<hr />
<h3>2.1.2 è»Œé“è¨ˆç”»ï¼ˆPath Planningï¼‰</h3>
<p>è©¦è–¬ãƒœãƒˆãƒ«ã‹ã‚‰åå¿œå®¹å™¨ã¸ã®ç§»å‹•ãªã©ã€ã‚¹ãƒ ãƒ¼ã‚ºã§å®‰å…¨ãªè»Œé“ã‚’è¨ˆç”»ã—ã¾ã™ã€‚</p>
<pre><code class="language-python">def linear_trajectory(start_pos, end_pos, num_points=50):
    &quot;&quot;&quot;
    2ç‚¹é–“ã®ç›´ç·šè»Œé“ã‚’ç”Ÿæˆ

    Args:
        start_pos: é–‹å§‹ä½ç½® (x, y)
        end_pos: çµ‚äº†ä½ç½® (x, y)
        num_points: è»Œé“ä¸Šã®ç‚¹æ•°

    Returns:
        è»Œé“ä¸Šã®ç‚¹ã®ãƒªã‚¹ãƒˆ [(x1, y1), (x2, y2), ...]
    &quot;&quot;&quot;
    x_traj = np.linspace(start_pos[0], end_pos[0], num_points)
    y_traj = np.linspace(start_pos[1], end_pos[1], num_points)

    trajectory = list(zip(x_traj, y_traj))
    return trajectory

def execute_trajectory(robot, trajectory, plot=True):
    &quot;&quot;&quot;
    è»Œé“ã‚’å®Ÿè¡Œï¼ˆã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰

    Args:
        robot: RobotArmã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
        trajectory: ç›®æ¨™ä½ç½®ã®ãƒªã‚¹ãƒˆ
        plot: è»Œé“ã‚’å¯è¦–åŒ–ã™ã‚‹ã‹
    &quot;&quot;&quot;
    joint_angles = []
    successful_points = []

    for i, (x, y) in enumerate(trajectory):
        angles = robot.inverse_kinematics(x, y)
        if angles:
            joint_angles.append(angles)
            successful_points.append((x, y))
        else:
            print(f&quot;è­¦å‘Š: ç‚¹ {i} ({x:.3f}, {y:.3f}) ã¯åˆ°é”ä¸èƒ½&quot;)

    if plot and successful_points:
        plt.figure(figsize=(10, 8))

        # åˆ°é”ç¯„å›²
        theta = np.linspace(0, 2*np.pi, 100)
        r_max = robot.L1 + robot.L2
        plt.plot(r_max * np.cos(theta), r_max * np.sin(theta), 'k--', alpha=0.2, label='æœ€å¤§åˆ°é”ç¯„å›²')

        # è»Œé“
        traj_x, traj_y = zip(*successful_points)
        plt.plot(traj_x, traj_y, 'b-', linewidth=2, alpha=0.6, label='è¨ˆç”»è»Œé“')
        plt.plot(traj_x[0], traj_y[0], 'go', markersize=15, label='é–‹å§‹ä½ç½®')
        plt.plot(traj_x[-1], traj_y[-1], 'ro', markersize=15, label='çµ‚äº†ä½ç½®')

        # ã„ãã¤ã‹ã®ä¸­é–“å§¿å‹¢ã‚’è¡¨ç¤º
        for i in range(0, len(joint_angles), len(joint_angles)//5):
            theta1, theta2 = joint_angles[i]
            th1 = np.radians(theta1)
            th2 = np.radians(theta2)

            x1 = robot.L1 * np.cos(th1)
            y1 = robot.L1 * np.sin(th1)
            x2 = x1 + robot.L2 * np.cos(th1 + th2)
            y2 = y1 + robot.L2 * np.sin(th1 + th2)

            plt.plot([0, x1, x2], [0, y1, y2], 'gray', alpha=0.3, linewidth=1)

        plt.axis('equal')
        plt.grid(True, alpha=0.3)
        plt.xlabel('X ä½ç½® (m)', fontsize=12)
        plt.ylabel('Y ä½ç½® (m)', fontsize=12)
        plt.title('ãƒ­ãƒœãƒƒãƒˆã‚¢ãƒ¼ãƒ ã®è»Œé“è¨ˆç”»', fontsize=14, fontweight='bold')
        plt.legend()
        plt.tight_layout()
        plt.savefig('trajectory_planning.png', dpi=300, bbox_inches='tight')
        plt.show()

    return joint_angles


# ä½¿ç”¨ä¾‹: è©¦è–¬ãƒœãƒˆãƒ« (0.35, 0.15) ã‹ã‚‰åå¿œå®¹å™¨ (0.25, 0.35) ã¸ã®ç§»å‹•
robot = SimpleRobotArm()
start = (0.35, 0.15)
end = (0.25, 0.35)

trajectory = linear_trajectory(start, end, num_points=30)
print(f&quot;è»Œé“ç”Ÿæˆ: {len(trajectory)}ç‚¹&quot;)

joint_angles = execute_trajectory(robot, trajectory, plot=True)
print(f&quot;å®Ÿè¡ŒæˆåŠŸ: {len(joint_angles)}/{len(trajectory)}ç‚¹&quot;)
</code></pre>
<hr />
<h2>2.2 æ¶²ä½“ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°: OpenTrons OT-2</h2>
<h3>2.2.1 OpenTrons OT-2ã®æ¦‚è¦</h3>
<p>OpenTrons OT-2ã¯ã€ç ”ç©¶å®¤ã§åºƒãä½¿ã‚ã‚Œã‚‹ã‚ªãƒ¼ãƒ—ãƒ³ã‚½ãƒ¼ã‚¹ã®æ¶²ä½“ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ãƒ­ãƒœãƒƒãƒˆã§ã™ã€‚</p>
<p><strong>ä¸»ãªä»•æ§˜</strong>:
- <strong>ç²¾åº¦</strong>: Â±1 ÂµLï¼ˆ1-20 ÂµLï¼‰ã€Â±2%ï¼ˆ20-300 ÂµLï¼‰
- <strong>å®¹é‡</strong>: 1-1000 ÂµLï¼ˆãƒ”ãƒšãƒƒãƒˆäº¤æ›ã§å¯¾å¿œï¼‰
- <strong>ãƒ‡ãƒƒã‚­ã‚µã‚¤ã‚º</strong>: 11ã‚¹ãƒ­ãƒƒãƒˆï¼ˆãƒã‚¤ã‚¯ãƒ­ãƒ—ãƒ¬ãƒ¼ãƒˆã€ãƒãƒ¥ãƒ¼ãƒ–ãƒ©ãƒƒã‚¯ã€è©¦è–¬ãƒœãƒˆãƒ«ï¼‰
- <strong>ä¾¡æ ¼</strong>: ç´„$10,000ï¼ˆå­¦è¡“å‰²å¼•ã‚ã‚Šï¼‰
- <strong>ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°</strong>: Python APIï¼ˆç›´æ„Ÿçš„ã§å­¦ç¿’å®¹æ˜“ï¼‰</p>
<h3>2.2.2 åŸºæœ¬çš„ãªãƒ”ãƒšãƒƒãƒ†ã‚£ãƒ³ã‚°</h3>
<pre><code class="language-python">from opentrons import protocol_api

# OT-2ãƒ—ãƒ­ãƒˆã‚³ãƒ«: 96ã‚¦ã‚§ãƒ«ãƒ—ãƒ¬ãƒ¼ãƒˆã¸ã®è©¦è–¬åˆ†æ³¨
metadata = {
    'protocolName': 'åŸºæœ¬çš„ãªãƒ”ãƒšãƒƒãƒ†ã‚£ãƒ³ã‚°',
    'author': 'Materials Lab',
    'description': 'è©¦è–¬ã‚’96ã‚¦ã‚§ãƒ«ãƒ—ãƒ¬ãƒ¼ãƒˆã«åˆ†æ³¨',
    'apiLevel': '2.13'
}

def run(protocol: protocol_api.ProtocolContext):
    &quot;&quot;&quot;
    åŸºæœ¬çš„ãªãƒ”ãƒšãƒƒãƒ†ã‚£ãƒ³ã‚°ãƒ—ãƒ­ãƒˆã‚³ãƒ«

    Args:
        protocol: OpenTrons ProtocolContext
    &quot;&quot;&quot;
    # ãƒ‡ãƒƒã‚­ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã®è¨­å®š
    # ã‚¹ãƒ­ãƒƒãƒˆ1: 96ã‚¦ã‚§ãƒ«ãƒ—ãƒ¬ãƒ¼ãƒˆï¼ˆåå¿œç”¨ï¼‰
    plate = protocol.load_labware('corning_96_wellplate_360ul_flat', location='1')

    # ã‚¹ãƒ­ãƒƒãƒˆ2: ãƒãƒ¥ãƒ¼ãƒ–ãƒ©ãƒƒã‚¯ï¼ˆè©¦è–¬ãƒœãƒˆãƒ«ï¼‰
    tuberack = protocol.load_labware('opentrons_24_tuberack_eppendorf_1.5ml_safelock_snapcap', location='2')

    # ã‚¹ãƒ­ãƒƒãƒˆ3: ãƒ”ãƒšãƒƒãƒˆãƒãƒƒãƒ—ãƒ©ãƒƒã‚¯
    tiprack = protocol.load_labware('opentrons_96_tiprack_300ul', location='3')

    # ãƒ”ãƒšãƒƒãƒˆã®è£…ç€ï¼ˆP300 Single-Channelï¼‰
    pipette = protocol.load_instrument('p300_single_gen2', mount='left', tip_racks=[tiprack])

    # ãƒ”ãƒšãƒƒãƒ†ã‚£ãƒ³ã‚°æ“ä½œ
    # è©¦è–¬Aï¼ˆãƒãƒ¥ãƒ¼ãƒ–A1ï¼‰ã‚’å„ã‚¦ã‚§ãƒ«ã«50 ÂµLåˆ†æ³¨
    reagent_a = tuberack.wells_by_name()['A1']

    for well in plate.wells():
        pipette.pick_up_tip()  # æ–°ã—ã„ãƒãƒƒãƒ—ã‚’å–ã‚‹
        pipette.aspirate(50, reagent_a)  # è©¦è–¬ã‚’å¸å¼•ï¼ˆ50 ÂµLï¼‰
        pipette.dispense(50, well)  # ã‚¦ã‚§ãƒ«ã«åˆ†æ³¨
        pipette.blow_out(well.top())  # ä½™å‰°æ¶²ã‚’æ’å‡º
        pipette.drop_tip()  # ãƒãƒƒãƒ—ã‚’å»ƒæ£„

    protocol.comment(&quot;ãƒ—ãƒ­ãƒˆã‚³ãƒ«å®Œäº†: 96ã‚¦ã‚§ãƒ«ã™ã¹ã¦ã«è©¦è–¬Aã‚’åˆ†æ³¨ã—ã¾ã—ãŸ&quot;)


# ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆå®Ÿæ©Ÿãªã—ã§å‹•ä½œç¢ºèªï¼‰
# ã‚¿ãƒ¼ãƒŸãƒŠãƒ«ã§å®Ÿè¡Œ: opentrons_simulate basic_pipetting.py
</code></pre>
<p><strong>ã‚³ãƒ¼ãƒ‰è§£èª¬</strong>:
1. <strong>Labwareèª­ã¿è¾¼ã¿</strong>: ãƒ—ãƒ¬ãƒ¼ãƒˆã€ãƒãƒ¥ãƒ¼ãƒ–ãƒ©ãƒƒã‚¯ã€ãƒãƒƒãƒ—ãƒ©ãƒƒã‚¯ã‚’ãƒ‡ãƒƒã‚­ã«é…ç½®
2. <strong>Pipetteè£…ç€</strong>: ã‚·ãƒ³ã‚°ãƒ«ãƒãƒ£ãƒ³ãƒãƒ«300 ÂµLãƒ”ãƒšãƒƒãƒˆ
3. <strong>ãƒ”ãƒšãƒƒãƒ†ã‚£ãƒ³ã‚°ãƒ«ãƒ¼ãƒ—</strong>: å„ã‚¦ã‚§ãƒ«ã«è©¦è–¬ã‚’åˆ†æ³¨
4. <strong>ã‚¯ãƒ­ã‚¹ã‚³ãƒ³ã‚¿ãƒŸãƒãƒ¼ã‚·ãƒ§ãƒ³é˜²æ­¢</strong>: æ¯å›æ–°ã—ã„ãƒãƒƒãƒ—ã‚’ä½¿ç”¨</p>
<hr />
<h3>2.2.3 ãƒãƒ«ãƒãƒãƒ£ãƒ³ãƒãƒ«ãƒ”ãƒšãƒƒãƒ†ã‚£ãƒ³ã‚°</h3>
<p>96ã‚¦ã‚§ãƒ«ãƒ—ãƒ¬ãƒ¼ãƒˆå…¨ä½“ã¸ã®é«˜é€Ÿåˆ†æ³¨ã«ã¯ã€8ãƒãƒ£ãƒ³ãƒãƒ«ãƒ”ãƒšãƒƒãƒˆã‚’ä½¿ç”¨ã—ã¾ã™ã€‚</p>
<pre><code class="language-python">def run(protocol: protocol_api.ProtocolContext):
    &quot;&quot;&quot;
    ãƒãƒ«ãƒãƒãƒ£ãƒ³ãƒãƒ«ãƒ”ãƒšãƒƒãƒ†ã‚£ãƒ³ã‚°ï¼ˆ8åˆ—åŒæ™‚åˆ†æ³¨ï¼‰
    &quot;&quot;&quot;
    # ãƒ‡ãƒƒã‚­ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ
    source_plate = protocol.load_labware('nest_12_reservoir_15ml', location='1')  # è©¦è–¬ãƒªã‚¶ãƒ¼ãƒãƒ¼
    dest_plate = protocol.load_labware('corning_96_wellplate_360ul_flat', location='2')
    tiprack = protocol.load_labware('opentrons_96_tiprack_300ul', location='3')

    # 8ãƒãƒ£ãƒ³ãƒãƒ«ãƒ”ãƒšãƒƒãƒˆ
    p300_multi = protocol.load_instrument('p300_multi_gen2', mount='left', tip_racks=[tiprack])

    # è©¦è–¬ãƒªã‚¶ãƒ¼ãƒãƒ¼ã‹ã‚‰96ã‚¦ã‚§ãƒ«ãƒ—ãƒ¬ãƒ¼ãƒˆã¸
    # 8ãƒãƒ£ãƒ³ãƒãƒ«ãƒ”ãƒšãƒƒãƒˆã¯ç¸¦1åˆ—ï¼ˆ8ã‚¦ã‚§ãƒ«ï¼‰ã‚’åŒæ™‚å‡¦ç†
    p300_multi.pick_up_tip()

    # 12åˆ—ã‚’é †æ¬¡å‡¦ç†ï¼ˆ96ã‚¦ã‚§ãƒ« = 12åˆ— Ã— 8è¡Œï¼‰
    for col in dest_plate.columns():
        p300_multi.aspirate(100, source_plate['A1'])  # ãƒªã‚¶ãƒ¼ãƒãƒ¼ã‹ã‚‰å¸å¼•
        p300_multi.dispense(100, col[0])  # åˆ—ã®æœ€åˆã®ã‚¦ã‚§ãƒ«ï¼ˆA1, A2, ..., A12ï¼‰
        p300_multi.blow_out()

    p300_multi.drop_tip()
    protocol.comment(&quot;96ã‚¦ã‚§ãƒ«å…¨ã¦ã«100 ÂµLåˆ†æ³¨å®Œäº†&quot;)


# åŠ¹ç‡æ¯”è¼ƒ
print(&quot;96ã‚¦ã‚§ãƒ«ãƒ—ãƒ¬ãƒ¼ãƒˆã¸ã®åˆ†æ³¨æ™‚é–“:&quot;)
print(&quot;  ã‚·ãƒ³ã‚°ãƒ«ãƒãƒ£ãƒ³ãƒãƒ«: 96ã‚¦ã‚§ãƒ« Ã— 20ç§’ = 32åˆ†&quot;)
print(&quot;  ãƒãƒ«ãƒãƒãƒ£ãƒ³ãƒãƒ«: 12åˆ— Ã— 20ç§’ = 4åˆ†&quot;)
print(&quot;  åŠ¹ç‡åŒ–: 8å€é«˜é€Ÿ&quot;)
</code></pre>
<hr />
<h3>2.2.4 æ®µéšå¸Œé‡ˆï¼ˆSerial Dilutionï¼‰</h3>
<p>è§¦åª’ã‚¹ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°ãªã©ã§é‡è¦ãªæ®µéšå¸Œé‡ˆã‚’è‡ªå‹•åŒ–ã—ã¾ã™ã€‚</p>
<pre><code class="language-python">def run(protocol: protocol_api.ProtocolContext):
    &quot;&quot;&quot;
    æ®µéšå¸Œé‡ˆãƒ—ãƒ­ãƒˆã‚³ãƒ«ï¼ˆ10å€å¸Œé‡ˆç³»åˆ—ï¼‰
    æ¿ƒåº¦: 10^0, 10^-1, 10^-2, ..., 10^-7 M
    &quot;&quot;&quot;
    plate = protocol.load_labware('corning_96_wellplate_360ul_flat', location='1')
    tiprack = protocol.load_labware('opentrons_96_tiprack_300ul', location='2')
    reservoir = protocol.load_labware('nest_12_reservoir_15ml', location='3')

    pipette = protocol.load_instrument('p300_single_gen2', mount='left', tip_racks=[tiprack])

    # å¸Œé‡ˆç³»åˆ—ã‚’ä½œæˆï¼ˆAåˆ—: 10^0 â†’ 10^-7ï¼‰
    # ã‚¦ã‚§ãƒ«A1: åŸæ¶²ã€A2-A8: å¸Œé‡ˆæ¶²

    # 1. å„ã‚¦ã‚§ãƒ«ã«æº¶åª’ã‚’åˆ†æ³¨ï¼ˆA2-A8ï¼‰
    solvent = reservoir['A1']
    for well in plate.columns()[0][1:8]:  # A2ã‹ã‚‰A8
        pipette.pick_up_tip()
        pipette.transfer(180, solvent, well, new_tip='never')
        pipette.drop_tip()

    # 2. åŸæ¶²ã‚’ A1 ã«åˆ†æ³¨
    stock_solution = reservoir['A2']
    pipette.transfer(200, stock_solution, plate['A1'], new_tip='once')

    # 3. æ®µéšå¸Œé‡ˆã®å®Ÿè¡Œ
    # A1 â†’ A2 â†’ A3 â†’ ... â†’ A8
    pipette.pick_up_tip()
    for i in range(7):
        source_well = plate.columns()[0][i]  # A1, A2, ..., A7
        dest_well = plate.columns()[0][i+1]  # A2, A3, ..., A8

        # 20 ÂµLã‚’æ¬¡ã®ã‚¦ã‚§ãƒ«ã«ç§»ã™
        pipette.aspirate(20, source_well)
        pipette.dispense(20, dest_well)
        pipette.mix(3, 100, dest_well)  # 3å›æ··åˆï¼ˆ100 ÂµLï¼‰

    pipette.drop_tip()
    protocol.comment(&quot;æ®µéšå¸Œé‡ˆå®Œäº†: 10^0 â†’ 10^-7 M&quot;)


# æ®µéšå¸Œé‡ˆã®æ¿ƒåº¦è¨ˆç®—
import pandas as pd

dilution_factor = 10  # 10å€å¸Œé‡ˆ
num_dilutions = 8
initial_concentration = 1.0  # M

concentrations = [initial_concentration / (dilution_factor ** i) for i in range(num_dilutions)]
wells = [f'A{i+1}' for i in range(num_dilutions)]

df_dilution = pd.DataFrame({
    'ã‚¦ã‚§ãƒ«': wells,
    'æ¿ƒåº¦ (M)': concentrations,
    'å¯¾æ•°æ¿ƒåº¦': [f'10^{int(np.log10(c))}' if c &gt;= 1e-10 else '0' for c in concentrations]
})

print(&quot;æ®µéšå¸Œé‡ˆç³»åˆ—:&quot;)
print(df_dilution.to_string(index=False))
</code></pre>
<hr />
<h2>2.3 å›ºä½“ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°</h2>
<h3>2.3.1 ç²‰æœ«è¨ˆé‡ã®è‡ªå‹•åŒ–</h3>
<p>å›ºä½“è©¦è–¬ã®è‡ªå‹•è¨ˆé‡ã«ã¯ã€ç²¾å¯†å¤©ç§¤ã¨ãƒ­ãƒœãƒƒãƒˆã‚¢ãƒ¼ãƒ ã®é€£æºãŒå¿…è¦ã§ã™ã€‚</p>
<pre><code class="language-python">class PowderDispenserSimulator:
    &quot;&quot;&quot;
    ç²‰æœ«åˆ†æ³¨ã‚·ã‚¹ãƒ†ãƒ ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼
    å®Ÿéš›ã®è£…ç½®: Mettler Toledo Balance + Robot Arm
    &quot;&quot;&quot;

    def __init__(self, accuracy=0.001):
        &quot;&quot;&quot;
        Args:
            accuracy: è¨ˆé‡ç²¾åº¦ï¼ˆã‚°ãƒ©ãƒ ï¼‰
        &quot;&quot;&quot;
        self.accuracy = accuracy
        self.dispensed_amounts = []

    def dispense_powder(self, target_mass, powder_name='è©¦è–¬A'):
        &quot;&quot;&quot;
        ç²‰æœ«ã‚’ç›®æ¨™è³ªé‡ã¾ã§åˆ†æ³¨

        Args:
            target_mass: ç›®æ¨™è³ªé‡ï¼ˆã‚°ãƒ©ãƒ ï¼‰
            powder_name: ç²‰æœ«ã®åå‰

        Returns:
            actual_mass: å®Ÿéš›ã«åˆ†æ³¨ã•ã‚ŒãŸè³ªé‡
        &quot;&quot;&quot;
        # ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³: æ­£è¦åˆ†å¸ƒã§ã°ã‚‰ã¤ãã‚’æ¨¡æ“¬
        actual_mass = np.random.normal(target_mass, self.accuracy)
        self.dispensed_amounts.append(actual_mass)

        error = actual_mass - target_mass
        print(f&quot;{powder_name} åˆ†æ³¨: ç›®æ¨™ {target_mass:.3f}g, å®Ÿæ¸¬ {actual_mass:.3f}g (èª¤å·®: {error:+.4f}g)&quot;)

        return actual_mass

    def multi_component_dispensing(self, composition_dict):
        &quot;&quot;&quot;
        å¤šæˆåˆ†ç²‰æœ«ã®è‡ªå‹•é…åˆ

        Args:
            composition_dict: {æˆåˆ†å: è³ªé‡(g)}

        Returns:
            actual_composition: å®Ÿéš›ã®çµ„æˆ
        &quot;&quot;&quot;
        print(&quot;å¤šæˆåˆ†é…åˆé–‹å§‹:&quot;)
        actual_composition = {}

        for component, target_mass in composition_dict.items():
            actual_mass = self.dispense_powder(target_mass, component)
            actual_composition[component] = actual_mass

        total_mass = sum(actual_composition.values())
        print(f&quot;\nåˆè¨ˆè³ªé‡: {total_mass:.3f}g&quot;)

        # çµ„æˆæ¯”ï¼ˆé‡é‡%ï¼‰
        print(&quot;\nå®Ÿéš›ã®çµ„æˆæ¯”ï¼ˆwt%ï¼‰:&quot;)
        for component, mass in actual_composition.items():
            percentage = (mass / total_mass) * 100
            print(f&quot;  {component}: {percentage:.2f}%&quot;)

        return actual_composition


# ä½¿ç”¨ä¾‹: ä¸‰å…ƒç³»è§¦åª’ (NiO, CoO, MnO2) ã®é…åˆ
dispenser = PowderDispenserSimulator(accuracy=0.002)

# ç›®æ¨™çµ„æˆ: Ni:Co:Mn = 60:20:20 (wt%)
total_mass = 1.0  # åˆè¨ˆ1.0g
composition = {
    'NiO': 0.6,
    'CoO': 0.2,
    'MnO2': 0.2
}

actual_comp = dispenser.multi_component_dispensing(composition)

# ç²¾åº¦è©•ä¾¡
print(&quot;\nç²¾åº¦è©•ä¾¡:&quot;)
for component, target_mass in composition.items():
    actual_mass = actual_comp[component]
    error_percent = abs((actual_mass - target_mass) / target_mass) * 100
    print(f&quot;  {component}: èª¤å·® {error_percent:.2f}%&quot;)
</code></pre>
<hr />
<h3>2.3.2 å›ºä½“è©¦æ–™ã®ç§»é€</h3>
<pre><code class="language-python">def solid_sample_transfer_protocol():
    &quot;&quot;&quot;
    å›ºä½“è©¦æ–™ã®è‡ªå‹•ç§»é€ãƒ—ãƒ­ãƒˆã‚³ãƒ«ï¼ˆç–‘ä¼¼ã‚³ãƒ¼ãƒ‰ï¼‰
    å®Ÿéš›ã®å®Ÿè£…ã¯ãƒ­ãƒœãƒƒãƒˆã‚¢ãƒ¼ãƒ ã®APIã«ä¾å­˜
    &quot;&quot;&quot;
    protocol_steps = [
        &quot;1. ãƒ­ãƒœãƒƒãƒˆã‚¢ãƒ¼ãƒ ãŒã‚µãƒ³ãƒ—ãƒ«ãƒ›ãƒ«ãƒ€ãƒ¼ã‚’æŠŠæŒ&quot;,
        &quot;2. XRDæ¸¬å®šä½ç½®ã«ç§»å‹•&quot;,
        &quot;3. ã‚µãƒ³ãƒ—ãƒ«ã‚’XRDã‚¹ãƒ†ãƒ¼ã‚¸ã«é…ç½®&quot;,
        &quot;4. XRDæ¸¬å®šé–‹å§‹ï¼ˆå¤–éƒ¨ãƒˆãƒªã‚¬ãƒ¼ï¼‰&quot;,
        &quot;5. æ¸¬å®šå®Œäº†ã‚’å¾…æ©Ÿ&quot;,
        &quot;6. ã‚µãƒ³ãƒ—ãƒ«ã‚’å›å&quot;,
        &quot;7. æ¬¡ã®ã‚µãƒ³ãƒ—ãƒ«ä½ç½®ã«ç§»å‹•&quot;,
        &quot;8. ã‚¹ãƒ†ãƒƒãƒ—1-7ã‚’ç¹°ã‚Šè¿”ã—&quot;
    ]

    for step in protocol_steps:
        print(step)

    # ç–‘ä¼¼ã‚³ãƒ¼ãƒ‰: å®Ÿéš›ã®ãƒ­ãƒœãƒƒãƒˆåˆ¶å¾¡
    &quot;&quot;&quot;
    # Universal Robots UR5eã®ä¾‹
    import urx

    robot = urx.Robot(&quot;192.168.1.100&quot;)  # ãƒ­ãƒœãƒƒãƒˆã®IPã‚¢ãƒ‰ãƒ¬ã‚¹

    # ã‚µãƒ³ãƒ—ãƒ«ä½ç½®ï¼ˆXYZåº§æ¨™ã€ãƒŸãƒªãƒ¡ãƒ¼ãƒˆãƒ«ï¼‰
    sample_position = [300, 200, 100, 0, 0, 0]  # X, Y, Z, RX, RY, RZ
    xrd_position = [500, 200, 150, 0, 0, 0]

    # ç§»å‹•
    robot.movel(sample_position, acc=0.1, vel=0.1)  # ç·šå½¢ç§»å‹•
    # ã‚°ãƒªãƒƒãƒ‘ãƒ¼ã§ã‚µãƒ³ãƒ—ãƒ«æŠŠæŒ
    robot.set_digital_out(0, True)  # ãƒ‡ã‚¸ã‚¿ãƒ«å‡ºåŠ›ã§ã‚°ãƒªãƒƒãƒ‘ãƒ¼åˆ¶å¾¡

    robot.movel(xrd_position, acc=0.1, vel=0.1)
    # ã‚µãƒ³ãƒ—ãƒ«ã‚’é…ç½®
    robot.set_digital_out(0, False)

    robot.close()
    &quot;&quot;&quot;

solid_sample_transfer_protocol()
</code></pre>
<hr />
<h2>2.4 ã‚»ãƒ³ã‚µãƒ¼çµ±åˆ</h2>
<h3>2.4.1 åˆ†å…‰è¨ˆã¨ã®é€£æº</h3>
<p>UV-Visåˆ†å…‰è¨ˆã§ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã«åå¿œã‚’ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°ã—ã¾ã™ã€‚</p>
<pre><code class="language-python">import time

class SpectrometerSimulator:
    &quot;&quot;&quot;
    UV-Visåˆ†å…‰è¨ˆã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼
    å®Ÿéš›ã®è£…ç½®: Ocean Optics USB4000, Agilent Cary 60
    &quot;&quot;&quot;

    def __init__(self, wavelength_range=(200, 800), resolution=1):
        &quot;&quot;&quot;
        Args:
            wavelength_range: æ³¢é•·ç¯„å›²ï¼ˆnmï¼‰
            resolution: æ³¢é•·åˆ†è§£èƒ½ï¼ˆnmï¼‰
        &quot;&quot;&quot;
        self.wavelengths = np.arange(wavelength_range[0], wavelength_range[1], resolution)

    def measure_absorbance(self, sample_id, concentration=0.1):
        &quot;&quot;&quot;
        å¸å…‰åº¦æ¸¬å®šï¼ˆã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰

        Args:
            sample_id: ã‚µãƒ³ãƒ—ãƒ«ID
            concentration: æ¿ƒåº¦ï¼ˆMï¼‰

        Returns:
            wavelengths, absorbance: æ³¢é•·ã¨å¸å…‰åº¦ã®é…åˆ—
        &quot;&quot;&quot;
        # Beer-Lambertå‰‡: A = Îµ * c * l
        # ãƒ”ãƒ¼ã‚¯æ³¢é•·: 450 nmï¼ˆä»®æƒ³çš„ãªåŒ–åˆç‰©ï¼‰
        peak_wavelength = 450
        peak_absorbance = concentration * 10  # Îµcl = 10 (ä»®å®š)

        # ã‚¬ã‚¦ã‚¹å‹å¸åã‚¹ãƒšã‚¯ãƒˆãƒ«
        absorbance = peak_absorbance * np.exp(-((self.wavelengths - peak_wavelength) / 50)**2)

        # ãƒã‚¤ã‚ºè¿½åŠ 
        noise = np.random.normal(0, 0.01, len(self.wavelengths))
        absorbance += noise

        print(f&quot;ã‚µãƒ³ãƒ—ãƒ« {sample_id} æ¸¬å®šå®Œäº†: ãƒ”ãƒ¼ã‚¯æ³¢é•· {peak_wavelength}nm, å¸å…‰åº¦ {peak_absorbance:.3f}&quot;)

        return self.wavelengths, absorbance

    def kinetic_measurement(self, duration=60, interval=5):
        &quot;&quot;&quot;
        åå¿œé€Ÿåº¦è«–æ¸¬å®šï¼ˆæ™‚é–“å¤‰åŒ–ã‚’è¿½è·¡ï¼‰

        Args:
            duration: æ¸¬å®šæ™‚é–“ï¼ˆç§’ï¼‰
            interval: æ¸¬å®šé–“éš”ï¼ˆç§’ï¼‰

        Returns:
            times, absorbance_at_450nm: æ™‚é–“ã¨450nmã§ã®å¸å…‰åº¦
        &quot;&quot;&quot;
        times = np.arange(0, duration, interval)
        absorbance_450 = []

        print(&quot;åå¿œé€Ÿåº¦è«–æ¸¬å®šé–‹å§‹...&quot;)
        for t in times:
            # ä¸€æ¬¡åå¿œã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³: [A] = [A]0 * exp(-kt)
            k = 0.02  # s^-1
            concentration = 0.1 * np.exp(-k * t)

            _, abs_spectrum = self.measure_absorbance(f't={t}s', concentration)
            # 450nmã§ã®å¸å…‰åº¦ã‚’æŠ½å‡º
            idx_450 = np.argmin(np.abs(self.wavelengths - 450))
            absorbance_450.append(abs_spectrum[idx_450])

            time.sleep(0.1)  # å®Ÿéš›ã®æ¸¬å®šã§ã¯å®Ÿæ™‚é–“ã§å¾…æ©Ÿ

        return times, np.array(absorbance_450)


# ä½¿ç”¨ä¾‹
spectrometer = SpectrometerSimulator()

# ã‚¹ãƒšã‚¯ãƒˆãƒ«æ¸¬å®š
wavelengths, absorbance = spectrometer.measure_absorbance('Sample_001', concentration=0.15)

plt.figure(figsize=(10, 6))
plt.plot(wavelengths, absorbance, linewidth=2)
plt.xlabel('æ³¢é•· (nm)', fontsize=12)
plt.ylabel('å¸å…‰åº¦', fontsize=12)
plt.title('UV-Viså¸åã‚¹ãƒšã‚¯ãƒˆãƒ«', fontsize=14, fontweight='bold')
plt.grid(alpha=0.3)
plt.tight_layout()
plt.savefig('uv_vis_spectrum.png', dpi=300, bbox_inches='tight')
plt.show()

# åå¿œé€Ÿåº¦è«–æ¸¬å®š
times, abs_450 = spectrometer.kinetic_measurement(duration=100, interval=10)

plt.figure(figsize=(10, 6))
plt.plot(times, abs_450, 'o-', linewidth=2, markersize=8)
plt.xlabel('æ™‚é–“ (s)', fontsize=12)
plt.ylabel('å¸å…‰åº¦ (450 nm)', fontsize=12)
plt.title('åå¿œé€Ÿåº¦è«–æ¸¬å®š', fontsize=14, fontweight='bold')
plt.grid(alpha=0.3)
plt.tight_layout()
plt.savefig('kinetic_measurement.png', dpi=300, bbox_inches='tight')
plt.show()

# ä¸€æ¬¡åå¿œé€Ÿåº¦å®šæ•°ã®ãƒ•ã‚£ãƒƒãƒ†ã‚£ãƒ³ã‚°
from scipy.optimize import curve_fit

def first_order_kinetics(t, A0, k):
    return A0 * np.exp(-k * t)

params, covariance = curve_fit(first_order_kinetics, times, abs_450, p0=[1.5, 0.02])
A0_fit, k_fit = params

print(f&quot;\nä¸€æ¬¡åå¿œãƒ•ã‚£ãƒƒãƒ†ã‚£ãƒ³ã‚°:&quot;)
print(f&quot;  åˆæœŸå¸å…‰åº¦ A0 = {A0_fit:.3f}&quot;)
print(f&quot;  é€Ÿåº¦å®šæ•° k = {k_fit:.4f} s^-1&quot;)
print(f&quot;  åŠæ¸›æœŸ t1/2 = {np.log(2)/k_fit:.1f} s&quot;)
</code></pre>
<hr />
<h3>2.4.2 ã‚«ãƒ¡ãƒ©ã«ã‚ˆã‚‹ç”»åƒè§£æ</h3>
<p>çµæ™¶æˆé•·ã€æ²ˆæ®¿å½¢æˆã€è‰²å¤‰åŒ–ãªã©ã‚’ã‚«ãƒ¡ãƒ©ã§è‡ªå‹•è¨˜éŒ²ãƒ»è§£æã—ã¾ã™ã€‚</p>
<pre><code class="language-python">from PIL import Image, ImageDraw, ImageFont
import cv2

class LabCameraSimulator:
    &quot;&quot;&quot;
    å®Ÿé¨“ç”¨ã‚«ãƒ¡ãƒ©ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼
    å®Ÿéš›ã®è£…ç½®: Basler ace, FLIR Blackfly
    &quot;&quot;&quot;

    def __init__(self, resolution=(1920, 1080)):
        self.resolution = resolution

    def capture_wellplate(self, plate_id='Plate_001'):
        &quot;&quot;&quot;
        96ã‚¦ã‚§ãƒ«ãƒ—ãƒ¬ãƒ¼ãƒˆã®ç”»åƒå–å¾—ï¼ˆã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰

        Returns:
            image: PIL Image
        &quot;&quot;&quot;
        # ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³: 96ã‚¦ã‚§ãƒ«ãƒ—ãƒ¬ãƒ¼ãƒˆã®ã‚°ãƒªãƒƒãƒ‰ç”»åƒã‚’ç”Ÿæˆ
        img = Image.new('RGB', self.resolution, color='white')
        draw = ImageDraw.Draw(img)

        # 8è¡Œ Ã— 12åˆ—ã®ã‚¦ã‚§ãƒ«
        well_diameter = 50
        spacing = 70
        offset_x, offset_y = 200, 100

        for row in range(8):
            for col in range(12):
                center_x = offset_x + col * spacing
                center_y = offset_y + row * spacing

                # ã‚¦ã‚§ãƒ«ã®è‰²ï¼ˆæ¿ƒåº¦ã«å¿œã˜ã¦å¤‰åŒ–ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆï¼‰
                intensity = int(255 * (1 - (row + col) / 20))  # å¾ã€…ã«æ¿ƒããªã‚‹
                color = (intensity, intensity, 255)

                # ã‚¦ã‚§ãƒ«ã‚’æç”»
                draw.ellipse([center_x - well_diameter//2, center_y - well_diameter//2,
                              center_x + well_diameter//2, center_y + well_diameter//2],
                             fill=color, outline='black')

        print(f&quot;ãƒ—ãƒ¬ãƒ¼ãƒˆ {plate_id} ã®ç”»åƒå–å¾—å®Œäº†&quot;)
        return img

    def analyze_well_color(self, image, well_position):
        &quot;&quot;&quot;
        ç‰¹å®šã‚¦ã‚§ãƒ«ã®è‰²ã‚’è§£æ

        Args:
            image: PIL Image
            well_position: (row, col) ã‚¦ã‚§ãƒ«ä½ç½®

        Returns:
            rgb_mean: RGBå¹³å‡å€¤
        &quot;&quot;&quot;
        row, col = well_position
        well_diameter = 50
        spacing = 70
        offset_x, offset_y = 200, 100

        center_x = offset_x + col * spacing
        center_y = offset_y + row * spacing

        # ã‚¦ã‚§ãƒ«é ˜åŸŸã‚’åˆ‡ã‚Šå‡ºã—
        crop_box = (center_x - well_diameter//2, center_y - well_diameter//2,
                    center_x + well_diameter//2, center_y + well_diameter//2)
        well_img = image.crop(crop_box)

        # RGBå¹³å‡å€¤ã‚’è¨ˆç®—
        well_array = np.array(well_img)
        rgb_mean = well_array.mean(axis=(0, 1))

        return rgb_mean


# ä½¿ç”¨ä¾‹
camera = LabCameraSimulator()
plate_image = camera.capture_wellplate('Plate_001')
plate_image.save('wellplate_image.png')

# ã‚¦ã‚§ãƒ«A1ã®è‰²è§£æ
rgb = camera.analyze_well_color(plate_image, well_position=(0, 0))
print(f&quot;ã‚¦ã‚§ãƒ«A1ã®RGBå€¤: R={rgb[0]:.1f}, G={rgb[1]:.1f}, B={rgb[2]:.1f}&quot;)

# å…¨ã‚¦ã‚§ãƒ«ã®è‰²è§£æ
print(&quot;\nå…¨ã‚¦ã‚§ãƒ«ã®é’è‰²æˆåˆ†ï¼ˆBå€¤ï¼‰ãƒãƒƒãƒ—:&quot;)
blue_values = np.zeros((8, 12))
for row in range(8):
    for col in range(12):
        rgb = camera.analyze_well_color(plate_image, (row, col))
        blue_values[row, col] = rgb[2]

plt.figure(figsize=(12, 6))
plt.imshow(blue_values, cmap='Blues', interpolation='nearest')
plt.colorbar(label='é’è‰²æˆåˆ† (Bå€¤)')
plt.xlabel('åˆ—', fontsize=12)
plt.ylabel('è¡Œ', fontsize=12)
plt.title('96ã‚¦ã‚§ãƒ«ãƒ—ãƒ¬ãƒ¼ãƒˆã®è‰²åˆ†å¸ƒ', fontsize=14, fontweight='bold')
plt.xticks(range(12), [f'{i+1}' for i in range(12)])
plt.yticks(range(8), ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'])
plt.tight_layout()
plt.savefig('wellplate_color_map.png', dpi=300, bbox_inches='tight')
plt.show()
</code></pre>
<hr />
<h2>2.5 å®‰å…¨æ€§ã¨ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°</h2>
<h3>2.5.1 ç·Šæ€¥åœæ­¢æ©Ÿèƒ½</h3>
<pre><code class="language-python">class SafetyController:
    &quot;&quot;&quot;
    å®Ÿé¨“è‡ªå‹•åŒ–ã‚·ã‚¹ãƒ†ãƒ ã®å®‰å…¨åˆ¶å¾¡
    &quot;&quot;&quot;

    def __init__(self):
        self.emergency_stop = False
        self.error_log = []

    def check_safety(self, temperature, pressure, liquid_level):
        &quot;&quot;&quot;
        å®‰å…¨ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®ãƒã‚§ãƒƒã‚¯

        Args:
            temperature: æ¸©åº¦ï¼ˆâ„ƒï¼‰
            pressure: åœ§åŠ›ï¼ˆbarï¼‰
            liquid_level: æ¶²é¢ãƒ¬ãƒ™ãƒ«ï¼ˆ%ï¼‰

        Returns:
            is_safe: å®‰å…¨ã‹ã©ã†ã‹
        &quot;&quot;&quot;
        is_safe = True
        warnings = []

        # æ¸©åº¦ãƒã‚§ãƒƒã‚¯
        if temperature &gt; 100:
            warnings.append(f&quot;è­¦å‘Š: æ¸©åº¦ãŒé«˜ã™ãã¾ã™ ({temperature}â„ƒ)&quot;)
            is_safe = False

        # åœ§åŠ›ãƒã‚§ãƒƒã‚¯
        if pressure &gt; 5:
            warnings.append(f&quot;è­¦å‘Š: åœ§åŠ›ãŒé«˜ã™ãã¾ã™ ({pressure} bar)&quot;)
            is_safe = False

        # æ¶²é¢ãƒ¬ãƒ™ãƒ«ãƒã‚§ãƒƒã‚¯
        if liquid_level &lt; 10:
            warnings.append(f&quot;è­¦å‘Š: æ¶²é¢ãŒä½ã™ãã¾ã™ ({liquid_level}%)&quot;)
            is_safe = False

        if not is_safe:
            for warning in warnings:
                print(warning)
                self.error_log.append({'time': time.strftime('%Y-%m-%d %H:%M:%S'), 'message': warning})

        return is_safe

    def emergency_stop_sequence(self):
        &quot;&quot;&quot;ç·Šæ€¥åœæ­¢ã‚·ãƒ¼ã‚±ãƒ³ã‚¹&quot;&quot;&quot;
        print(&quot;\nğŸš¨ ç·Šæ€¥åœæ­¢ã‚’å®Ÿè¡Œã—ã¾ã™ ğŸš¨&quot;)
        self.emergency_stop = True

        # åœæ­¢ã‚¢ã‚¯ã‚·ãƒ§ãƒ³
        actions = [
            &quot;1. ã™ã¹ã¦ã®ãƒ­ãƒœãƒƒãƒˆå‹•ä½œã‚’åœæ­¢&quot;,
            &quot;2. ãƒ’ãƒ¼ã‚¿ãƒ¼ã‚’åœæ­¢&quot;,
            &quot;3. å†·å´æ°´ã‚’å¾ªç’°&quot;,
            &quot;4. ãƒãƒ«ãƒ–ã‚’å®‰å…¨ä½ç½®ã«ç§»å‹•&quot;,
            &quot;5. ã‚ªãƒšãƒ¬ãƒ¼ã‚¿ãƒ¼ã«é€šçŸ¥&quot;,
            &quot;6. ãƒ­ã‚°ã‚’è¨˜éŒ²&quot;
        ]

        for action in actions:
            print(action)
            time.sleep(0.5)

        print(&quot;\nç·Šæ€¥åœæ­¢å®Œäº†ã€‚ã‚·ã‚¹ãƒ†ãƒ ã¯å®‰å…¨çŠ¶æ…‹ã§ã™ã€‚&quot;)

    def print_error_log(self):
        &quot;&quot;&quot;ã‚¨ãƒ©ãƒ¼ãƒ­ã‚°ã‚’è¡¨ç¤º&quot;&quot;&quot;
        print(&quot;\n=== ã‚¨ãƒ©ãƒ¼ãƒ­ã‚° ===&quot;)
        for error in self.error_log:
            print(f&quot;[{error['time']}] {error['message']}&quot;)


# ä½¿ç”¨ä¾‹
safety = SafetyController()

# æ­£å¸¸ãªçŠ¶æ…‹
print(&quot;=== æ­£å¸¸é‹è»¢ ===&quot;)
is_safe = safety.check_safety(temperature=80, pressure=2.0, liquid_level=50)
print(f&quot;å®‰å…¨çŠ¶æ…‹: {is_safe}\n&quot;)

# ç•°å¸¸ãªçŠ¶æ…‹
print(&quot;=== ç•°å¸¸æ¤œçŸ¥ ===&quot;)
is_safe = safety.check_safety(temperature=120, pressure=6.5, liquid_level=5)
print(f&quot;å®‰å…¨çŠ¶æ…‹: {is_safe}&quot;)

if not is_safe:
    safety.emergency_stop_sequence()

safety.print_error_log()
</code></pre>
<hr />
<h3>2.5.2 ã‚¨ãƒ©ãƒ¼ãƒªã‚«ãƒãƒªãƒ¼</h3>
<pre><code class="language-python">def robust_pipetting_with_retry(pipette, source, dest, volume, max_retries=3):
    &quot;&quot;&quot;
    ã‚¨ãƒ©ãƒ¼ãƒªã‚«ãƒãƒªãƒ¼ä»˜ããƒ”ãƒšãƒƒãƒ†ã‚£ãƒ³ã‚°

    Args:
        pipette: OT-2 pipette
        source: å¸å¼•å…ƒ
        dest: åˆ†æ³¨å…ˆ
        volume: å®¹é‡ï¼ˆÂµLï¼‰
        max_retries: æœ€å¤§ãƒªãƒˆãƒ©ã‚¤å›æ•°

    Returns:
        success: æˆåŠŸã—ãŸã‹ã©ã†ã‹
    &quot;&quot;&quot;
    for attempt in range(max_retries):
        try:
            pipette.pick_up_tip()
            pipette.aspirate(volume, source)
            pipette.dispense(volume, dest)
            pipette.drop_tip()

            print(f&quot;ãƒ”ãƒšãƒƒãƒ†ã‚£ãƒ³ã‚°æˆåŠŸ: {volume} ÂµL ({attempt+1}å›ç›®)&quot;)
            return True

        except Exception as e:
            print(f&quot;ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿ ({attempt+1}å›ç›®): {e}&quot;)

            # ãƒªã‚«ãƒãƒªãƒ¼ã‚¢ã‚¯ã‚·ãƒ§ãƒ³
            if pipette.has_tip:
                pipette.drop_tip()

            if attempt &lt; max_retries - 1:
                print(&quot;ãƒªãƒˆãƒ©ã‚¤ã—ã¾ã™...&quot;)
                time.sleep(1)
            else:
                print(&quot;æœ€å¤§ãƒªãƒˆãƒ©ã‚¤å›æ•°ã«é”ã—ã¾ã—ãŸã€‚æ“ä½œã‚’ä¸­æ­¢ã—ã¾ã™ã€‚&quot;)
                return False

    return False


# ç–‘ä¼¼ã‚³ãƒ¼ãƒ‰ã§ã®ä½¿ç”¨ä¾‹
print(&quot;ã‚¨ãƒ©ãƒ¼ãƒªã‚«ãƒãƒªãƒ¼ä»˜ããƒ”ãƒšãƒƒãƒ†ã‚£ãƒ³ã‚°ã®ãƒ‡ãƒ¢:\n&quot;)

class MockPipette:
    def __init__(self, fail_probability=0.3):
        self.has_tip = False
        self.fail_probability = fail_probability

    def pick_up_tip(self):
        if np.random.random() &lt; self.fail_probability:
            raise Exception(&quot;ãƒãƒƒãƒ—å–å¾—å¤±æ•—&quot;)
        self.has_tip = True

    def aspirate(self, volume, source):
        if np.random.random() &lt; self.fail_probability:
            raise Exception(&quot;å¸å¼•å¤±æ•—&quot;)

    def dispense(self, volume, dest):
        if np.random.random() &lt; self.fail_probability:
            raise Exception(&quot;åˆ†æ³¨å¤±æ•—&quot;)

    def drop_tip(self):
        self.has_tip = False

mock_pipette = MockPipette(fail_probability=0.4)  # 40%ã®ç¢ºç‡ã§å¤±æ•—
success = robust_pipetting_with_retry(mock_pipette, 'A1', 'B1', 100, max_retries=5)
print(f&quot;\næœ€çµ‚çµæœ: {'æˆåŠŸ' if success else 'å¤±æ•—'}&quot;)
</code></pre>
<hr />
<h2>2.6 ãƒ©ãƒœã‚¦ã‚§ã‚¢ã®æ¨™æº–åŒ–</h2>
<h3>2.6.1 SBSï¼ˆSociety for Biomolecular Screeningï¼‰è¦æ ¼</h3>
<p>96ã‚¦ã‚§ãƒ«ãƒ—ãƒ¬ãƒ¼ãƒˆã€384ã‚¦ã‚§ãƒ«ãƒ—ãƒ¬ãƒ¼ãƒˆãªã©ã€ãƒ©ãƒœã‚¦ã‚§ã‚¢ã®å¯¸æ³•ã¯å›½éš›è¦æ ¼ã§æ¨™æº–åŒ–ã•ã‚Œã¦ã„ã¾ã™ã€‚</p>
<pre><code class="language-python">class SBS_Labware:
    &quot;&quot;&quot;
    SBSè¦æ ¼ã®ãƒ©ãƒœã‚¦ã‚§ã‚¢ä»•æ§˜
    &quot;&quot;&quot;

    @staticmethod
    def plate_96_well():
        &quot;&quot;&quot;96ã‚¦ã‚§ãƒ«ãƒ—ãƒ¬ãƒ¼ãƒˆã®ä»•æ§˜&quot;&quot;&quot;
        specs = {
            'åç§°': '96ã‚¦ã‚§ãƒ«ãƒ—ãƒ¬ãƒ¼ãƒˆ',
            'ãƒ•ãƒƒãƒˆãƒ—ãƒªãƒ³ãƒˆ': '127.76 mm Ã— 85.48 mm (SBSè¦æ ¼)',
            'ã‚¦ã‚§ãƒ«é…ç½®': '8è¡Œ Ã— 12åˆ—',
            'ã‚¦ã‚§ãƒ«é–“éš”': '9.0 mm (ä¸­å¿ƒé–“)',
            'ã‚¦ã‚§ãƒ«å®¹é‡': 'é€šå¸¸ 300-360 ÂµL',
            'ã‚¦ã‚§ãƒ«å½¢çŠ¶': 'ãƒ•ãƒ©ãƒƒãƒˆã€Uå­—å‹ã€Vå­—å‹',
            'ç”¨é€”': 'ä¸€èˆ¬çš„ãªã‚¹ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°ã€ã‚¢ãƒƒã‚»ã‚¤'
        }
        return specs

    @staticmethod
    def plate_384_well():
        &quot;&quot;&quot;384ã‚¦ã‚§ãƒ«ãƒ—ãƒ¬ãƒ¼ãƒˆã®ä»•æ§˜&quot;&quot;&quot;
        specs = {
            'åç§°': '384ã‚¦ã‚§ãƒ«ãƒ—ãƒ¬ãƒ¼ãƒˆ',
            'ãƒ•ãƒƒãƒˆãƒ—ãƒªãƒ³ãƒˆ': '127.76 mm Ã— 85.48 mm (96ã‚¦ã‚§ãƒ«ã¨åŒã˜)',
            'ã‚¦ã‚§ãƒ«é…ç½®': '16è¡Œ Ã— 24åˆ—',
            'ã‚¦ã‚§ãƒ«é–“éš”': '4.5 mm (ä¸­å¿ƒé–“ã€96ã‚¦ã‚§ãƒ«ã®åŠåˆ†)',
            'ã‚¦ã‚§ãƒ«å®¹é‡': 'é€šå¸¸ 50-100 ÂµL',
            'ç”¨é€”': 'é«˜å¯†åº¦ã‚¹ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°ã€å‰µè–¬'
        }
        return specs

    @staticmethod
    def plot_wellplate_layout(n_wells=96):
        &quot;&quot;&quot;ã‚¦ã‚§ãƒ«ãƒ—ãƒ¬ãƒ¼ãƒˆã®ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã‚’å¯è¦–åŒ–&quot;&quot;&quot;
        if n_wells == 96:
            rows, cols = 8, 12
            well_spacing = 9.0  # mm
        elif n_wells == 384:
            rows, cols = 16, 24
            well_spacing = 4.5  # mm
        else:
            raise ValueError(&quot;96ã¾ãŸã¯384ã‚¦ã‚§ãƒ«ã®ã¿ã‚µãƒãƒ¼ãƒˆ&quot;)

        fig, ax = plt.subplots(figsize=(12, 6))

        # ã‚¦ã‚§ãƒ«ã‚’æç”»
        for row in range(rows):
            for col in range(cols):
                x = col * well_spacing
                y = row * well_spacing
                circle = plt.Circle((x, y), radius=well_spacing*0.4, color='lightblue', ec='black')
                ax.add_patch(circle)

                # ã‚¦ã‚§ãƒ«åã‚’è¡¨ç¤ºï¼ˆ96ã‚¦ã‚§ãƒ«ã®ã¿ã€è¦‹ã‚„ã™ã•ã®ãŸã‚ï¼‰
                if n_wells == 96:
                    well_name = f&quot;{chr(65+row)}{col+1}&quot;
                    ax.text(x, y, well_name, ha='center', va='center', fontsize=8)

        ax.set_xlim(-well_spacing, cols * well_spacing)
        ax.set_ylim(-well_spacing, rows * well_spacing)
        ax.set_aspect('equal')
        ax.invert_yaxis()  # Yè»¸ã‚’åè»¢ï¼ˆAè¡ŒãŒä¸Šï¼‰
        ax.set_xlabel('X æ–¹å‘ (mm)', fontsize=12)
        ax.set_ylabel('Y æ–¹å‘ (mm)', fontsize=12)
        ax.set_title(f'{n_wells}ã‚¦ã‚§ãƒ«ãƒ—ãƒ¬ãƒ¼ãƒˆ ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ (SBSè¦æ ¼)', fontsize=14, fontweight='bold')
        ax.grid(alpha=0.3)
        plt.tight_layout()
        plt.savefig(f'{n_wells}_wellplate_layout.png', dpi=300, bbox_inches='tight')
        plt.show()


# ä»•æ§˜ã®è¡¨ç¤º
labware = SBS_Labware()

print(&quot;=== 96ã‚¦ã‚§ãƒ«ãƒ—ãƒ¬ãƒ¼ãƒˆ ===&quot;)
for key, value in labware.plate_96_well().items():
    print(f&quot;{key}: {value}&quot;)

print(&quot;\n=== 384ã‚¦ã‚§ãƒ«ãƒ—ãƒ¬ãƒ¼ãƒˆ ===&quot;)
for key, value in labware.plate_384_well().items():
    print(f&quot;{key}: {value}&quot;)

# ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã®å¯è¦–åŒ–
labware.plot_wellplate_layout(n_wells=96)
</code></pre>
<hr />
<h2>2.7 æ¼”ç¿’å•é¡Œ</h2>
<h3>æ¼”ç¿’1: ãƒ­ãƒœãƒƒãƒˆã‚¢ãƒ¼ãƒ ã®è»Œé“æœ€é©åŒ–ï¼ˆé›£æ˜“åº¦: Mediumï¼‰</h3>
<p>2ã¤ã®è©¦è–¬ãƒœãƒˆãƒ«ï¼ˆä½ç½®A: (0.35, 0.15)ã€ä½ç½®B: (0.25, 0.35)ï¼‰ã¨åå¿œå®¹å™¨ï¼ˆä½ç½®C: (0.4, 0.3)ï¼‰ãŒã‚ã‚‹å ´åˆã€æœ€çŸ­æ™‚é–“ã§ A â†’ B â†’ C ã®é †ã«è¨ªå•ã™ã‚‹è»Œé“ã‚’è¨ˆç”»ã—ã¦ãã ã•ã„ã€‚</p>
<details>
<summary>ãƒ’ãƒ³ãƒˆ</summary>

ç›´ç·šè»Œé“ã®ç§»å‹•æ™‚é–“ã¯è·é›¢ã«æ¯”ä¾‹ã—ã¾ã™ã€‚Aâ†’Bâ†’C ã¨ Aâ†’Câ†’B ã®2ã¤ã®ãƒ«ãƒ¼ãƒˆã‚’æ¯”è¼ƒã—ã€ç·ç§»å‹•è·é›¢ãŒçŸ­ã„æ–¹ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚

</details>

<details>
<summary>è§£ç­”ä¾‹</summary>


<pre><code class="language-python">def calculate_path_length(points):
    &quot;&quot;&quot;çµŒè·¯ã®ç·è·é›¢ã‚’è¨ˆç®—&quot;&quot;&quot;
    total_distance = 0
    for i in range(len(points) - 1):
        dx = points[i+1][0] - points[i][0]
        dy = points[i+1][1] - points[i][1]
        distance = np.sqrt(dx**2 + dy**2)
        total_distance += distance
    return total_distance

# è©¦è–¬ãƒœãƒˆãƒ«ã¨åå¿œå®¹å™¨ã®ä½ç½®
A = (0.35, 0.15)  # è©¦è–¬A
B = (0.25, 0.35)  # è©¦è–¬B
C = (0.4, 0.3)    # åå¿œå®¹å™¨

# ãƒ«ãƒ¼ãƒˆ1: A â†’ B â†’ C
route1 = [A, B, C]
distance1 = calculate_path_length(route1)

# ãƒ«ãƒ¼ãƒˆ2: A â†’ C â†’ B
route2 = [A, C, B]
distance2 = calculate_path_length(route2)

print(&quot;ãƒ«ãƒ¼ãƒˆæ¯”è¼ƒ:&quot;)
print(f&quot;  A â†’ B â†’ C: {distance1:.3f} m&quot;)
print(f&quot;  A â†’ C â†’ B: {distance2:.3f} m&quot;)

if distance1 &lt; distance2:
    print(f&quot;\næœ€é©ãƒ«ãƒ¼ãƒˆ: A â†’ B â†’ Cï¼ˆ{distance1:.3f} mï¼‰&quot;)
    optimal_route = route1
else:
    print(f&quot;\næœ€é©ãƒ«ãƒ¼ãƒˆ: A â†’ C â†’ Bï¼ˆ{distance2:.3f} mï¼‰&quot;)
    optimal_route = route2

# å¯è¦–åŒ–
robot = SimpleRobotArm()
fig, ax = plt.subplots(figsize=(10, 8))

# åˆ°é”ç¯„å›²
theta = np.linspace(0, 2*np.pi, 100)
r_max = robot.L1 + robot.L2
ax.plot(r_max * np.cos(theta), r_max * np.sin(theta), 'k--', alpha=0.2, label='æœ€å¤§åˆ°é”ç¯„å›²')

# ä½ç½®ã‚’ãƒ—ãƒ­ãƒƒãƒˆ
for point, label in zip([A, B, C], ['è©¦è–¬A', 'è©¦è–¬B', 'åå¿œå®¹å™¨']):
    ax.plot(point[0], point[1], 'o', markersize=15, label=label)

# æœ€é©ãƒ«ãƒ¼ãƒˆã‚’æç”»
route_x, route_y = zip(*optimal_route)
ax.plot(route_x, route_y, 'r-', linewidth=2, alpha=0.6, label='æœ€é©çµŒè·¯')

ax.axis('equal')
ax.grid(alpha=0.3)
ax.set_xlabel('X ä½ç½® (m)', fontsize=12)
ax.set_ylabel('Y ä½ç½® (m)', fontsize=12)
ax.set_title('çµŒè·¯æœ€é©åŒ–', fontsize=14, fontweight='bold')
ax.legend()
plt.tight_layout()
plt.savefig('path_optimization.png', dpi=300, bbox_inches='tight')
plt.show()
</code></pre>


</details>

<hr />
<h3>æ¼”ç¿’2: 96ã‚¦ã‚§ãƒ«ãƒ—ãƒ¬ãƒ¼ãƒˆã¸ã®è¤‡æ•°è©¦è–¬åˆ†æ³¨ï¼ˆé›£æ˜“åº¦: Mediumï¼‰</h3>
<p>96ã‚¦ã‚§ãƒ«ãƒ—ãƒ¬ãƒ¼ãƒˆã«3ç¨®é¡ã®è©¦è–¬ï¼ˆAã€Bã€Cï¼‰ã‚’ä»¥ä¸‹ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã§åˆ†æ³¨ã™ã‚‹OpenTronsãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’ä½œæˆã—ã¦ãã ã•ã„ã€‚</p>
<ul>
<li>è©¦è–¬A: åˆ—1-4ï¼ˆã‚¦ã‚§ãƒ«A1-H4ï¼‰ã«50 ÂµL</li>
<li>è©¦è–¬B: åˆ—5-8ï¼ˆã‚¦ã‚§ãƒ«A5-H8ï¼‰ã«50 ÂµL</li>
<li>è©¦è–¬C: åˆ—9-12ï¼ˆã‚¦ã‚§ãƒ«A9-H12ï¼‰ã«50 ÂµL</li>
</ul>
<details>
<summary>ãƒ’ãƒ³ãƒˆ</summary>

8ãƒãƒ£ãƒ³ãƒãƒ«ãƒ”ãƒšãƒƒãƒˆã‚’ä½¿ç”¨ã™ã‚Œã°ã€å„åˆ—ã‚’1å›ã®ãƒ”ãƒšãƒƒãƒ†ã‚£ãƒ³ã‚°ã§å‡¦ç†ã§ãã¾ã™ã€‚`plate.columns()[0:4]`ã§åˆ—1-4ã‚’é¸æŠã§ãã¾ã™ã€‚

</details>

<details>
<summary>è§£ç­”ä¾‹</summary>


<pre><code class="language-python">from opentrons import protocol_api

metadata = {
    'protocolName': '96ã‚¦ã‚§ãƒ« 3è©¦è–¬åˆ†æ³¨',
    'author': 'Materials Lab',
    'description': '3ç¨®é¡ã®è©¦è–¬ã‚’åˆ—ã”ã¨ã«åˆ†æ³¨',
    'apiLevel': '2.13'
}

def run(protocol: protocol_api.ProtocolContext):
    # ãƒ‡ãƒƒã‚­ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ
    plate = protocol.load_labware('corning_96_wellplate_360ul_flat', location='1')
    reservoir = protocol.load_labware('nest_12_reservoir_15ml', location='2')
    tiprack = protocol.load_labware('opentrons_96_tiprack_300ul', location='3')

    # 8ãƒãƒ£ãƒ³ãƒãƒ«ãƒ”ãƒšãƒƒãƒˆ
    pipette = protocol.load_instrument('p300_multi_gen2', mount='left', tip_racks=[tiprack])

    # è©¦è–¬ã®ä½ç½®
    reagent_a = reservoir['A1']
    reagent_b = reservoir['A2']
    reagent_c = reservoir['A3']

    # è©¦è–¬Aã‚’åˆ—1-4ã«åˆ†æ³¨
    pipette.pick_up_tip()
    for col in plate.columns()[0:4]:  # åˆ—1-4
        pipette.aspirate(50, reagent_a)
        pipette.dispense(50, col[0])  # åˆ—ã®å…ˆé ­ã‚¦ã‚§ãƒ«ï¼ˆA1, A2, A3, A4ï¼‰
        pipette.blow_out()
    pipette.drop_tip()

    protocol.comment(&quot;è©¦è–¬A åˆ†æ³¨å®Œäº†&quot;)

    # è©¦è–¬Bã‚’åˆ—5-8ã«åˆ†æ³¨
    pipette.pick_up_tip()
    for col in plate.columns()[4:8]:  # åˆ—5-8
        pipette.aspirate(50, reagent_b)
        pipette.dispense(50, col[0])
        pipette.blow_out()
    pipette.drop_tip()

    protocol.comment(&quot;è©¦è–¬B åˆ†æ³¨å®Œäº†&quot;)

    # è©¦è–¬Cã‚’åˆ—9-12ã«åˆ†æ³¨
    pipette.pick_up_tip()
    for col in plate.columns()[8:12]:  # åˆ—9-12
        pipette.aspirate(50, reagent_c)
        pipette.dispense(50, col[0])
        pipette.blow_out()
    pipette.drop_tip()

    protocol.comment(&quot;è©¦è–¬C åˆ†æ³¨å®Œäº†&quot;)
    protocol.comment(&quot;ãƒ—ãƒ­ãƒˆã‚³ãƒ«å®Œäº†: 96ã‚¦ã‚§ãƒ«å…¨ã¦ã«è©¦è–¬ã‚’åˆ†æ³¨ã—ã¾ã—ãŸ&quot;)

# ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å®Ÿè¡Œ
print(&quot;ãƒ—ãƒ­ãƒˆã‚³ãƒ«ä½œæˆå®Œäº†&quot;)
print(&quot;å®Ÿè¡Œã‚³ãƒãƒ³ãƒ‰: opentrons_simulate three_reagent_protocol.py&quot;)
</code></pre>


</details>

<hr />
<h3>æ¼”ç¿’3: ã‚»ãƒ³ã‚µãƒ¼ãƒ‡ãƒ¼ã‚¿ã®ç•°å¸¸æ¤œçŸ¥ï¼ˆé›£æ˜“åº¦: Hardï¼‰</h3>
<p>UV-Visåˆ†å…‰è¨ˆã§åå¿œã‚’ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°ä¸­ã€ç•°å¸¸ãªå¸å…‰åº¦å¤‰åŒ–ï¼ˆæ€¥æ¿€ãªå¢—åŠ ã¾ãŸã¯æ¸›å°‘ï¼‰ã‚’æ¤œçŸ¥ã—ã€ç·Šæ€¥åœæ­¢ã™ã‚‹ã‚·ã‚¹ãƒ†ãƒ ã‚’å®Ÿè£…ã—ã¦ãã ã•ã„ã€‚</p>
<p><strong>æ¡ä»¶</strong>:
- æ¸¬å®šé–“éš”: 10ç§’
- ç•°å¸¸åˆ¤å®š: å‰å›æ¸¬å®šå€¤ã‹ã‚‰20%ä»¥ä¸Šå¤‰åŒ–ã—ãŸå ´åˆ
- ç•°å¸¸ãŒ2å›é€£ç¶šã—ãŸå ´åˆã«ç·Šæ€¥åœæ­¢</p>
<details>
<summary>ãƒ’ãƒ³ãƒˆ</summary>

å„æ¸¬å®šã§å‰å›å€¤ã¨æ¯”è¼ƒã—ã€å¤‰åŒ–ç‡ã‚’è¨ˆç®—ã—ã¾ã™ã€‚ç•°å¸¸ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ã‚’å°å…¥ã—ã€2å›é€£ç¶šã§ç•°å¸¸ãŒæ¤œçŸ¥ã•ã‚ŒãŸã‚‰ç·Šæ€¥åœæ­¢ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚

</details>

<details>
<summary>è§£ç­”ä¾‹</summary>


<pre><code class="language-python">class ReactionMonitor:
    &quot;&quot;&quot;
    åå¿œãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°ã¨ç•°å¸¸æ¤œçŸ¥
    &quot;&quot;&quot;

    def __init__(self, anomaly_threshold=0.2, consecutive_anomalies=2):
        &quot;&quot;&quot;
        Args:
            anomaly_threshold: ç•°å¸¸åˆ¤å®šã®é–¾å€¤ï¼ˆå¤‰åŒ–ç‡ï¼‰
            consecutive_anomalies: ç·Šæ€¥åœæ­¢ã¾ã§ã®é€£ç¶šç•°å¸¸å›æ•°
        &quot;&quot;&quot;
        self.threshold = anomaly_threshold
        self.consecutive_threshold = consecutive_anomalies
        self.anomaly_count = 0
        self.previous_value = None
        self.measurements = []

    def check_anomaly(self, current_value):
        &quot;&quot;&quot;
        ç•°å¸¸æ¤œçŸ¥

        Args:
            current_value: ç¾åœ¨ã®æ¸¬å®šå€¤

        Returns:
            is_anomaly: ç•°å¸¸ã‹ã©ã†ã‹
        &quot;&quot;&quot;
        if self.previous_value is None:
            self.previous_value = current_value
            return False

        # å¤‰åŒ–ç‡ã‚’è¨ˆç®—
        change_rate = abs((current_value - self.previous_value) / self.previous_value)

        is_anomaly = change_rate &gt; self.threshold

        if is_anomaly:
            self.anomaly_count += 1
            print(f&quot;âš ï¸ ç•°å¸¸æ¤œçŸ¥: å¤‰åŒ–ç‡ {change_rate*100:.1f}% (é–¾å€¤: {self.threshold*100:.1f}%)&quot;)
            print(f&quot;   å‰å›å€¤: {self.previous_value:.3f}, ç¾åœ¨å€¤: {current_value:.3f}&quot;)
            print(f&quot;   é€£ç¶šç•°å¸¸å›æ•°: {self.anomaly_count}/{self.consecutive_threshold}&quot;)
        else:
            self.anomaly_count = 0  # æ­£å¸¸ãªã‚‰ç•°å¸¸ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ã‚’ãƒªã‚»ãƒƒãƒˆ

        self.previous_value = current_value
        return is_anomaly

    def should_emergency_stop(self):
        &quot;&quot;&quot;ç·Šæ€¥åœæ­¢ãŒå¿…è¦ã‹åˆ¤å®š&quot;&quot;&quot;
        return self.anomaly_count &gt;= self.consecutive_threshold


# ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
print(&quot;=== åå¿œãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°é–‹å§‹ ===\n&quot;)
monitor = ReactionMonitor(anomaly_threshold=0.2, consecutive_anomalies=2)
safety = SafetyController()

# æ¸¬å®šãƒ‡ãƒ¼ã‚¿ï¼ˆã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰
# æ­£å¸¸ â†’ æ­£å¸¸ â†’ ç•°å¸¸1 â†’ ç•°å¸¸2ï¼ˆç·Šæ€¥åœæ­¢ï¼‰
simulated_absorbance = [1.0, 1.05, 1.08, 1.40, 1.75]

for i, absorbance in enumerate(simulated_absorbance):
    print(f&quot;--- æ¸¬å®š {i+1} ---&quot;)
    print(f&quot;å¸å…‰åº¦: {absorbance:.3f}&quot;)

    monitor.measurements.append(absorbance)
    is_anomaly = monitor.check_anomaly(absorbance)

    if monitor.should_emergency_stop():
        print(&quot;\nğŸš¨ é€£ç¶šç•°å¸¸æ¤œçŸ¥ï¼ ç·Šæ€¥åœæ­¢ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚&quot;)
        safety.emergency_stop_sequence()
        break

    print()

# æ¸¬å®šãƒ‡ãƒ¼ã‚¿ã®ãƒ—ãƒ­ãƒƒãƒˆ
plt.figure(figsize=(10, 6))
plt.plot(range(1, len(monitor.measurements) + 1), monitor.measurements, 'o-', linewidth=2, markersize=10)
plt.axhline(y=monitor.measurements[0] * (1 + monitor.threshold), color='red', linestyle='--', label='ä¸Šé™é–¾å€¤')
plt.axhline(y=monitor.measurements[0] * (1 - monitor.threshold), color='red', linestyle='--', label='ä¸‹é™é–¾å€¤')
plt.xlabel('æ¸¬å®šå›æ•°', fontsize=12)
plt.ylabel('å¸å…‰åº¦', fontsize=12)
plt.title('åå¿œãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°ã¨ç•°å¸¸æ¤œçŸ¥', fontsize=14, fontweight='bold')
plt.legend()
plt.grid(alpha=0.3)
plt.tight_layout()
plt.savefig('anomaly_detection.png', dpi=300, bbox_inches='tight')
plt.show()
</code></pre>


</details>

<hr />
<h2>æœ¬ç« ã®ã¾ã¨ã‚</h2>
<p>æœ¬ç« ã§ã¯ã€ãƒ­ãƒœãƒ†ã‚£ã‚¯ã‚¹å®Ÿé¨“ã®åŸºç¤æŠ€è¡“ã‚’å®Ÿè·µçš„ã«å­¦ã³ã¾ã—ãŸã€‚</p>
<h3>ã‚­ãƒ¼ãƒã‚¤ãƒ³ãƒˆ</h3>
<ol>
<li>
<p><strong>ãƒ­ãƒœãƒƒãƒˆã‚¢ãƒ¼ãƒ åˆ¶å¾¡</strong>:
   - é †é‹å‹•å­¦: é–¢ç¯€è§’åº¦â†’ä½ç½®
   - é€†é‹å‹•å­¦: ç›®æ¨™ä½ç½®â†’é–¢ç¯€è§’åº¦ï¼ˆå®Ÿé¨“ã§ä½¿ç”¨ï¼‰
   - è»Œé“è¨ˆç”»: ã‚¹ãƒ ãƒ¼ã‚ºã§å®‰å…¨ãªçµŒè·¯ç”Ÿæˆ</p>
</li>
<li>
<p><strong>æ¶²ä½“ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ï¼ˆOpenTrons OT-2ï¼‰</strong>:
   - åŸºæœ¬ãƒ”ãƒšãƒƒãƒ†ã‚£ãƒ³ã‚°: ç²¾åº¦Â±1 ÂµL
   - ãƒãƒ«ãƒãƒãƒ£ãƒ³ãƒãƒ«: 8å€é«˜é€ŸåŒ–
   - æ®µéšå¸Œé‡ˆ: 10^-7 Mã¾ã§ã®è‡ªå‹•å¸Œé‡ˆç³»åˆ—</p>
</li>
<li>
<p><strong>å›ºä½“ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°</strong>:
   - ç²‰æœ«è¨ˆé‡: Â±0.001 gã®ç²¾åº¦
   - å¤šæˆåˆ†é…åˆ: è‡ªå‹•åŒ–ã«ã‚ˆã‚‹å†ç¾æ€§å‘ä¸Š</p>
</li>
<li>
<p><strong>ã‚»ãƒ³ã‚µãƒ¼çµ±åˆ</strong>:
   - UV-Visåˆ†å…‰è¨ˆ: ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ åå¿œãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°
   - ã‚«ãƒ¡ãƒ©: ç”»åƒè§£æã«ã‚ˆã‚‹å®šé‡è©•ä¾¡</p>
</li>
<li>
<p><strong>å®‰å…¨è¨­è¨ˆ</strong>:
   - ç·Šæ€¥åœæ­¢: ç•°å¸¸æ¤œçŸ¥æ™‚ã®è‡ªå‹•åœæ­¢
   - ã‚¨ãƒ©ãƒ¼ãƒªã‚«ãƒãƒªãƒ¼: ãƒªãƒˆãƒ©ã‚¤æ©Ÿèƒ½
   - ãƒ­ã‚°è¨˜éŒ²: ãƒˆãƒ¬ãƒ¼ã‚µãƒ“ãƒªãƒ†ã‚£ç¢ºä¿</p>
</li>
<li>
<p><strong>ãƒ©ãƒœã‚¦ã‚§ã‚¢æ¨™æº–åŒ–</strong>:
   - SBSè¦æ ¼: 96/384ã‚¦ã‚§ãƒ«ãƒ—ãƒ¬ãƒ¼ãƒˆã®å›½éš›æ¨™æº–
   - äº’æ›æ€§: ç•°ãªã‚‹ãƒ¡ãƒ¼ã‚«ãƒ¼é–“ã§ã‚‚ä½¿ç”¨å¯èƒ½</p>
</li>
</ol>
<h3>æ¬¡ç« äºˆå‘Š</h3>
<p>ç¬¬3ç« ã§ã¯ã€ãƒ™ã‚¤ã‚ºæœ€é©åŒ–ã¨ãƒ­ãƒœãƒƒãƒˆå®Ÿé¨“ã‚’çµ±åˆã—ãŸã‚¯ãƒ­ãƒ¼ã‚ºãƒ‰ãƒ«ãƒ¼ãƒ—æœ€é©åŒ–ã‚’å­¦ã³ã¾ã™ã€‚å®Ÿé¨“â†’æ¸¬å®šâ†’è§£æâ†’äºˆæ¸¬â†’æ¬¡å®Ÿé¨“ã®è‡ªå‹•ã‚µã‚¤ã‚¯ãƒ«ã‚’å®Ÿè£…ã—ã€ææ–™æ¢ç´¢ã‚’åŠ‡çš„ã«åŠ é€Ÿã—ã¾ã™ã€‚</p>
<hr />
<h2>å‚è€ƒæ–‡çŒ®</h2>
<ol>
<li>OpenTrons. "OT-2 Robot Documentation." https://docs.opentrons.com/</li>
<li>Lynch, K. M., &amp; Park, F. C. (2017). <em>Modern Robotics: Mechanics, Planning, and Control</em>. Cambridge University Press.</li>
<li>Granda, J. M. et al. (2018). "Controlling an organic synthesis robot with machine learning to search for new reactivity." <em>Nature</em>, 559, 377-381.</li>
<li>SBS (Society for Laboratory Automation and Screening). "ANSI/SLAS Microplate Standards." https://www.slas.org/education/ansi-slas-microplate-standards/</li>
</ol>
<hr />
<p><strong>æ¬¡ã®ç« ã¸</strong>: <a href="chapter-3.html">ç¬¬3ç« : ã‚¯ãƒ­ãƒ¼ã‚ºãƒ‰ãƒ«ãƒ¼ãƒ—æœ€é©åŒ–</a></p>
<p><a href="index.html">ç›®æ¬¡ã«æˆ»ã‚‹</a></p><div class="navigation">
    <a href="chapter-1.html" class="nav-button">â† å‰ã®ç« </a>
    <a href="index.html" class="nav-button">ã‚·ãƒªãƒ¼ã‚ºç›®æ¬¡ã«æˆ»ã‚‹</a>
    <a href="chapter-3.html" class="nav-button">æ¬¡ã®ç«  â†’</a>
</div>
    </main>

    <footer>
        <p><strong>ä½œæˆè€…</strong>: AI Terakoya Content Team</p>
        <p><strong>ãƒãƒ¼ã‚¸ãƒ§ãƒ³</strong>: 1.0 | <strong>ä½œæˆæ—¥</strong>: 2025-10-17</p>
        <p><strong>ãƒ©ã‚¤ã‚»ãƒ³ã‚¹</strong>: Creative Commons BY 4.0</p>
        <p>Â© 2025 AI Terakoya. All rights reserved.</p>
    </footer>
</body>
</html>
