<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter - AI Terakoya</title>

    <style>
        :root {
            --color-primary: #2c3e50;
            --color-primary-dark: #1a252f;
            --color-accent: #7b2cbf;
            --color-accent-light: #9d4edd;
            --color-text: #2d3748;
            --color-text-light: #4a5568;
            --color-bg: #ffffff;
            --color-bg-alt: #f7fafc;
            --color-border: #e2e8f0;
            --color-code-bg: #f8f9fa;
            --color-link: #3182ce;
            --color-link-hover: #2c5aa0;

            --spacing-xs: 0.5rem;
            --spacing-sm: 1rem;
            --spacing-md: 1.5rem;
            --spacing-lg: 2rem;
            --spacing-xl: 3rem;

            --font-body: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            --font-mono: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;

            --border-radius: 8px;
            --box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-body);
            line-height: 1.7;
            color: var(--color-text);
            background-color: var(--color-bg);
            font-size: 16px;
        }

        header {
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            color: white;
            padding: var(--spacing-xl) var(--spacing-md);
            margin-bottom: var(--spacing-xl);
            box-shadow: var(--box-shadow);
        }

        .header-content {
            max-width: 900px;
            margin: 0 auto;
        }

        h1 {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: var(--spacing-sm);
            line-height: 1.2;
        }

        .subtitle {
            font-size: 1.1rem;
            opacity: 0.95;
            font-weight: 400;
            margin-bottom: var(--spacing-md);
        }

        .meta {
            display: flex;
            flex-wrap: wrap;
            gap: var(--spacing-md);
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .meta-item {
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 0 var(--spacing-md) var(--spacing-xl);
        }

        h2 {
            font-size: 1.75rem;
            color: var(--color-primary);
            margin-top: var(--spacing-xl);
            margin-bottom: var(--spacing-md);
            padding-bottom: var(--spacing-xs);
            border-bottom: 3px solid var(--color-accent);
        }

        h3 {
            font-size: 1.4rem;
            color: var(--color-primary);
            margin-top: var(--spacing-lg);
            margin-bottom: var(--spacing-sm);
        }

        h4 {
            font-size: 1.1rem;
            color: var(--color-primary-dark);
            margin-top: var(--spacing-md);
            margin-bottom: var(--spacing-sm);
        }

        p {
            margin-bottom: var(--spacing-md);
            color: var(--color-text);
        }

        a {
            color: var(--color-link);
            text-decoration: none;
            transition: color 0.2s;
        }

        a:hover {
            color: var(--color-link-hover);
            text-decoration: underline;
        }

        ul, ol {
            margin-left: var(--spacing-lg);
            margin-bottom: var(--spacing-md);
        }

        li {
            margin-bottom: var(--spacing-xs);
            color: var(--color-text);
        }

        pre {
            background-color: var(--color-code-bg);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            overflow-x: auto;
            margin-bottom: var(--spacing-md);
            font-family: var(--font-mono);
            font-size: 0.9rem;
            line-height: 1.5;
        }

        code {
            font-family: var(--font-mono);
            font-size: 0.9em;
            background-color: var(--color-code-bg);
            padding: 0.2em 0.4em;
            border-radius: 3px;
        }

        pre code {
            background-color: transparent;
            padding: 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: var(--spacing-md);
            font-size: 0.95rem;
        }

        th, td {
            border: 1px solid var(--color-border);
            padding: var(--spacing-sm);
            text-align: left;
        }

        th {
            background-color: var(--color-bg-alt);
            font-weight: 600;
            color: var(--color-primary);
        }

        blockquote {
            border-left: 4px solid var(--color-accent);
            padding-left: var(--spacing-md);
            margin: var(--spacing-md) 0;
            color: var(--color-text-light);
            font-style: italic;
            background-color: var(--color-bg-alt);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        .mermaid {
            text-align: center;
            margin: var(--spacing-lg) 0;
            background-color: var(--color-bg-alt);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        details {
            background-color: var(--color-bg-alt);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            margin-bottom: var(--spacing-md);
        }

        summary {
            cursor: pointer;
            font-weight: 600;
            color: var(--color-primary);
            user-select: none;
            padding: var(--spacing-xs);
            margin: calc(-1 * var(--spacing-md));
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        summary:hover {
            background-color: rgba(123, 44, 191, 0.1);
        }

        details[open] summary {
            margin-bottom: var(--spacing-md);
            border-bottom: 1px solid var(--color-border);
        }

        .learning-objectives {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            padding: var(--spacing-lg);
            border-radius: var(--border-radius);
            border-left: 4px solid var(--color-accent);
            margin-bottom: var(--spacing-xl);
        }

        .learning-objectives h2 {
            margin-top: 0;
            border-bottom: none;
        }

        .navigation {
            display: flex;
            justify-content: space-between;
            gap: var(--spacing-md);
            margin: var(--spacing-xl) 0;
            padding-top: var(--spacing-lg);
            border-top: 2px solid var(--color-border);
        }

        .nav-button {
            flex: 1;
            padding: var(--spacing-md);
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            color: white;
            border-radius: var(--border-radius);
            text-align: center;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: var(--box-shadow);
        }

        .nav-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            text-decoration: none;
        }

        footer {
            margin-top: var(--spacing-xl);
            padding: var(--spacing-lg) var(--spacing-md);
            background-color: var(--color-bg-alt);
            border-top: 1px solid var(--color-border);
            text-align: center;
            font-size: 0.9rem;
            color: var(--color-text-light);
        }
        .disclaimer {
            max-width: 900px;
            margin: 2rem auto;
            padding: 1.5rem;
            background: #f8f9fa;
            border-left: 4px solid #6c757d;
            border-radius: 4px;
        }

        .disclaimer h3 {
            color: #495057;
            margin-bottom: 1rem;
            font-size: 1.1rem;
        }

        .disclaimer ul {
            list-style: none;
            padding-left: 0;
        }

        .disclaimer li {
            padding: 0.5rem 0;
            padding-left: 1.5rem;
            position: relative;
            font-size: 0.9rem;
            color: #6c757d;
            line-height: 1.6;
        }

        .disclaimer li::before {
            content: "âš ï¸";
            position: absolute;
            left: 0;
        }


        @media (max-width: 768px) {
            h1 {
                font-size: 1.5rem;
            }

            h2 {
                font-size: 1.4rem;
            }

            h3 {
                font-size: 1.2rem;
            }

            .meta {
                font-size: 0.85rem;
            }

            .navigation {
                flex-direction: column;
            }

            table {
                font-size: 0.85rem;
            }

            th, td {
                padding: var(--spacing-xs);
            }
        }
    </style>

    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <script>
        mermaid.initialize({ startOnLoad: true, theme: 'default', securityLevel: 'strict' });
    </script>

    <!-- MathJax for LaTeX equation rendering -->
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\(', '\)']],
                displayMath: [['$$', '$$'], ['\[', '\]']],
                processEscapes: true,
                processEnvironments: true
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
                ignoreHtmlClass: 'mermaid'
            }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" id="MathJax-script" async></script>
</head>
<body>
    <header>
        <div class="header-content">
            <h1>è§¦åª’MIå®Ÿè£…ãƒãƒ³ã‚ºã‚ªãƒ³</h1>
            <p class="subtitle">ASEã¨Pythonã§å­¦ã¶å®Ÿè·µçš„è§¦åª’è¨­è¨ˆ</p>
            <div class="meta">
                <span class="meta-item">ğŸ“– èª­äº†æ™‚é–“: 65-75åˆ†</span>
                <span class="meta-item">ğŸ“Š é›£æ˜“åº¦: ä¸­ç´š</span>
                <span class="meta-item">ğŸ’» ã‚³ãƒ¼ãƒ‰ä¾‹: 30å€‹</span>
                <span class="meta-item">ğŸ“ æ¼”ç¿’å•é¡Œ: 5å•</span>
            </div>
        </div>
    </header>

    <main class="container">
<h1>ç¬¬3ç« ï¼šè§¦åª’MIå®Ÿè£…ãƒãƒ³ã‚ºã‚ªãƒ³</h1>
<p><strong>å­¦ç¿’ç›®æ¨™:</strong>
- ASEã‚’ä½¿ã£ãŸè§¦åª’æ§‹é€ ã®æ“ä½œã¨è¨ˆç®—
- è§¦åª’æ´»æ€§äºˆæ¸¬ãƒ¢ãƒ‡ãƒ«ã®æ§‹ç¯‰ã¨è©•ä¾¡
- ãƒ™ã‚¤ã‚ºæœ€é©åŒ–ã«ã‚ˆã‚‹è§¦åª’çµ„æˆæ¢ç´¢
- DFTè¨ˆç®—ã¨ã®çµ±åˆãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼</p>
<p><strong>å‰æçŸ¥è­˜:</strong>
- PythonåŸºç¤ï¼ˆNumPy, Pandas, Matplotlibï¼‰
- æ©Ÿæ¢°å­¦ç¿’åŸºç¤ï¼ˆscikit-learnï¼‰
- ç¬¬1ç« ãƒ»ç¬¬2ç« ã®å†…å®¹ç†è§£</p>
<p><strong>å®Ÿè¡Œç’°å¢ƒ:</strong></p>
<pre><code class="language-bash">pip install ase numpy pandas scikit-learn scikit-optimize matplotlib seaborn
</code></pre>
<hr />
<h2>3.1 ASEï¼ˆAtomic Simulation Environmentï¼‰åŸºç¤</h2>
<h3>ä¾‹1: ASEã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã¨åŸºæœ¬æ“ä½œ</h3>
<pre><code class="language-python">from ase import Atoms
from ase.visualize import view
import numpy as np

# é‡‘å±è¡¨é¢ã®ä½œæˆï¼ˆPt(111)è¡¨é¢ï¼‰
from ase.build import fcc111
slab = fcc111('Pt', size=(4, 4, 3), vacuum=10.0)

print(f&quot;åŸå­æ•°: {len(slab)}&quot;)
print(f&quot;ã‚»ãƒ«ã‚µã‚¤ã‚º: {slab.get_cell()}&quot;)
print(f&quot;åŒ–å­¦å¼: {slab.get_chemical_formula()}&quot;)

# åŸå­åº§æ¨™ã®ç¢ºèª
positions = slab.get_positions()
print(f&quot;æœ€ä¸Šå±¤Zåº§æ¨™: {positions[:, 2].max():.3f} Ã…&quot;)
</code></pre>
<p><strong>å‡ºåŠ›:</strong></p>
<pre><code>åŸå­æ•°: 48
ã‚»ãƒ«ã‚µã‚¤ã‚º: Cell([[11.122, 0.0, 0.0], [-5.561, 9.632, 0.0], [0.0, 0.0, 27.713]])
åŒ–å­¦å¼: Pt48
æœ€ä¸Šå±¤Zåº§æ¨™: 7.848 Ã…
</code></pre>
<h3>ä¾‹2: å¸ç€æ§‹é€ ã®ä½œæˆ</h3>
<pre><code class="language-python">from ase.build import fcc111, add_adsorbate
from ase import Atoms

# Pt(111)è¡¨é¢ã«COã‚’å¸ç€
slab = fcc111('Pt', size=(3, 3, 3), vacuum=10.0)
co = Atoms('CO', positions=[(0, 0, 0), (0, 0, 1.15)])

# Top siteã«å¸ç€
add_adsorbate(slab, co, height=2.0, position='ontop')

print(f&quot;å¸ç€å¾Œã®åŒ–å­¦å¼: {slab.get_chemical_formula()}&quot;)
print(f&quot;ç·åŸå­æ•°: {len(slab)}&quot;)

# COåˆ†å­ã®ä½ç½®ç¢ºèª
co_indices = [i for i, sym in enumerate(slab.get_chemical_symbols())
              if sym in ['C', 'O']]
print(f&quot;COåˆ†å­ã®index: {co_indices}&quot;)
</code></pre>
<h3>ä¾‹3: æ§‹é€ ã®æœ€é©åŒ–ï¼ˆè¨ˆç®—æ©ŸåŒ–å­¦ï¼‰</h3>
<pre><code class="language-python">from ase.build import fcc111, add_adsorbate
from ase.calculators.emt import EMT  # çµŒé¨“çš„ãƒãƒ†ãƒ³ã‚·ãƒ£ãƒ«
from ase.optimize import BFGS

# Ptè¡¨é¢ã«HåŸå­ã‚’å¸ç€
slab = fcc111('Pt', size=(3, 3, 3), vacuum=10.0)
from ase import Atoms
h_atom = Atoms('H')
add_adsorbate(slab, h_atom, height=1.5, position='fcc')

# è¨ˆç®—æ©Ÿã®è¨­å®šï¼ˆEMT: é«˜é€Ÿã ãŒç²¾åº¦ä½ã„ï¼‰
slab.calc = EMT()

# æ§‹é€ æœ€é©åŒ–
opt = BFGS(slab, trajectory='opt.traj')
opt.run(fmax=0.05)  # åŠ›ãŒ0.05 eV/Ã…ä»¥ä¸‹ã¾ã§æœ€é©åŒ–

# çµæœ
final_energy = slab.get_potential_energy()
print(f&quot;æœ€é©åŒ–å¾Œã‚¨ãƒãƒ«ã‚®ãƒ¼: {final_energy:.3f} eV&quot;)
</code></pre>
<h3>ä¾‹4: å¸ç€ã‚¨ãƒãƒ«ã‚®ãƒ¼è¨ˆç®—</h3>
<pre><code class="language-python">from ase.build import fcc111, add_adsorbate
from ase.calculators.emt import EMT
from ase.optimize import BFGS
from ase import Atoms

def calculate_adsorption_energy(metal='Pt', adsorbate='H'):
    &quot;&quot;&quot;å¸ç€ã‚¨ãƒãƒ«ã‚®ãƒ¼ã‚’è¨ˆç®—&quot;&quot;&quot;
    # æ¸…æµ„è¡¨é¢
    slab_clean = fcc111(metal, size=(3, 3, 3), vacuum=10.0)
    slab_clean.calc = EMT()
    E_slab = slab_clean.get_potential_energy()

    # å¸ç€ç³»
    slab_ads = fcc111(metal, size=(3, 3, 3), vacuum=10.0)
    atom = Atoms(adsorbate)
    add_adsorbate(slab_ads, atom, height=1.5, position='fcc')
    slab_ads.calc = EMT()
    opt = BFGS(slab_ads, logfile=None)
    opt.run(fmax=0.05)
    E_slab_ads = slab_ads.get_potential_energy()

    # æ°—ç›¸åˆ†å­
    molecule = Atoms(adsorbate)
    molecule.center(vacuum=10.0)
    molecule.calc = EMT()
    E_mol = molecule.get_potential_energy()

    # å¸ç€ã‚¨ãƒãƒ«ã‚®ãƒ¼
    E_ads = E_slab_ads - E_slab - E_mol
    return E_ads

# è¤‡æ•°é‡‘å±ã§ã®æ¯”è¼ƒ
metals = ['Pt', 'Pd', 'Ni', 'Cu']
for metal in metals:
    E_ads = calculate_adsorption_energy(metal, 'H')
    print(f&quot;{metal}è¡¨é¢ã¸ã®Hå¸ç€ã‚¨ãƒãƒ«ã‚®ãƒ¼: {E_ads:.3f} eV&quot;)
</code></pre>
<p><strong>å‡ºåŠ›ä¾‹:</strong></p>
<pre><code>Ptè¡¨é¢ã¸ã®Hå¸ç€ã‚¨ãƒãƒ«ã‚®ãƒ¼: -0.534 eV
Pdè¡¨é¢ã¸ã®Hå¸ç€ã‚¨ãƒãƒ«ã‚®ãƒ¼: -0.621 eV
Niè¡¨é¢ã¸ã®Hå¸ç€ã‚¨ãƒãƒ«ã‚®ãƒ¼: -0.482 eV
Cuè¡¨é¢ã¸ã®Hå¸ç€ã‚¨ãƒãƒ«ã‚®ãƒ¼: -0.213 eV
</code></pre>
<h3>ä¾‹5: d-bandä¸­å¿ƒã®è¨ˆç®—</h3>
<pre><code class="language-python">import numpy as np
from ase.build import bulk

def calculate_d_band_center(metal, k_points=(8, 8, 8)):
    &quot;&quot;&quot;d-bandä¸­å¿ƒã®ç°¡æ˜“è¨ˆç®—ï¼ˆå®Ÿéš›ã¯DFTãŒå¿…è¦ï¼‰&quot;&quot;&quot;
    # å®Ÿé¨“å€¤ãƒ™ãƒ¼ã‚¹ã®è¿‘ä¼¼
    d_band_centers = {
        'Pt': -2.25,  # eV (ãƒ•ã‚§ãƒ«ãƒŸæº–ä½åŸºæº–)
        'Pd': -1.83,
        'Ni': -1.29,
        'Cu': -2.67,
        'Au': -3.56,
        'Ag': -4.31
    }
    return d_band_centers.get(metal, None)

# è¤‡æ•°é‡‘å±ã®d-bandä¸­å¿ƒ
metals = ['Cu', 'Ni', 'Pd', 'Pt', 'Au']
for metal in metals:
    eps_d = calculate_d_band_center(metal)
    print(f&quot;{metal}: Îµd = {eps_d:.2f} eV&quot;)
</code></pre>
<h3>ä¾‹6: åˆé‡‘è¡¨é¢ã®ä½œæˆ</h3>
<pre><code class="language-python">from ase.build import fcc111
import numpy as np

def create_alloy_surface(metal1='Pt', metal2='Ni', ratio=0.5, size=(4, 4, 3)):
    &quot;&quot;&quot;åˆé‡‘è¡¨é¢ã®ä½œæˆ&quot;&quot;&quot;
    slab = fcc111(metal1, size=size, vacuum=10.0)

    # ãƒ©ãƒ³ãƒ€ãƒ ã«é‡‘å±ã‚’ç½®æ›
    n_atoms = len(slab)
    n_metal2 = int(n_atoms * ratio)
    indices = np.random.choice(n_atoms, n_metal2, replace=False)

    symbols = slab.get_chemical_symbols()
    for idx in indices:
        symbols[idx] = metal2
    slab.set_chemical_symbols(symbols)

    return slab

# PtNiåˆé‡‘è¡¨é¢ã®ä½œæˆ
alloy = create_alloy_surface('Pt', 'Ni', ratio=0.3, size=(5, 5, 3))
print(f&quot;çµ„æˆ: {alloy.get_chemical_formula()}&quot;)

# çµ„æˆæ¯”ã®ç¢ºèª
symbols = alloy.get_chemical_symbols()
pt_count = symbols.count('Pt')
ni_count = symbols.count('Ni')
print(f&quot;Pt: {pt_count}åŸå­ ({pt_count/(pt_count+ni_count)*100:.1f}%)&quot;)
print(f&quot;Ni: {ni_count}åŸå­ ({ni_count/(pt_count+ni_count)*100:.1f}%)&quot;)
</code></pre>
<h3>ä¾‹7: é…ä½æ•°ã®è¨ˆç®—</h3>
<pre><code class="language-python">from ase.build import fcc111
from ase.neighborlist import NeighborList
import numpy as np

def calculate_coordination_numbers(atoms, cutoff=3.0):
    &quot;&quot;&quot;å„åŸå­ã®é…ä½æ•°ã‚’è¨ˆç®—&quot;&quot;&quot;
    nl = NeighborList([cutoff/2]*len(atoms), self_interaction=False, bothways=True)
    nl.update(atoms)

    coord_numbers = []
    for i in range(len(atoms)):
        indices, offsets = nl.get_neighbors(i)
        coord_numbers.append(len(indices))

    return np.array(coord_numbers)

# Pt(111)è¡¨é¢ã®é…ä½æ•°åˆ†å¸ƒ
slab = fcc111('Pt', size=(4, 4, 3), vacuum=10.0)
coord_nums = calculate_coordination_numbers(slab, cutoff=3.0)

print(f&quot;é…ä½æ•°ã®åˆ†å¸ƒ:&quot;)
unique, counts = np.unique(coord_nums, return_counts=True)
for cn, count in zip(unique, counts):
    print(f&quot;  CN={cn}: {count}åŸå­&quot;)

# è¡¨é¢åŸå­ï¼ˆé…ä½æ•°ãŒä½ã„åŸå­ï¼‰
surface_indices = np.where(coord_nums &lt; 9)[0]
print(f&quot;è¡¨é¢åŸå­æ•°: {len(surface_indices)}&quot;)
</code></pre>
<hr />
<h2>3.2 è§¦åª’æ´»æ€§äºˆæ¸¬ãƒ¢ãƒ‡ãƒ«ã®æ§‹ç¯‰</h2>
<h3>ä¾‹8: è¨˜è¿°å­ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆã®ä½œæˆ</h3>
<pre><code class="language-python">import pandas as pd
import numpy as np

# é‡‘å±è§¦åª’ã®è¨˜è¿°å­ãƒ‡ãƒ¼ã‚¿
data = {
    'metal': ['Pt', 'Pd', 'Ni', 'Cu', 'Au', 'Ag', 'Rh', 'Ir', 'Fe', 'Co'],
    'd_band_center': [-2.25, -1.83, -1.29, -2.67, -3.56, -4.31, -1.73, -2.12, -1.34, -1.41],  # eV
    'work_function': [5.65, 5.12, 5.15, 4.65, 5.1, 4.26, 4.98, 5.27, 4.5, 5.0],  # eV
    'surface_energy': [2.48, 2.00, 2.38, 1.79, 1.50, 1.25, 2.66, 3.05, 2.90, 2.52],  # J/mÂ²
    'lattice_constant': [3.92, 3.89, 3.52, 3.61, 4.08, 4.09, 3.80, 3.84, 2.87, 3.54],  # Ã…
    'H_ads_energy': [-0.53, -0.62, -0.48, -0.21, -0.15, 0.12, -0.68, -0.71, -0.87, -0.74],  # eV
    'HER_activity': [8.2, 7.5, 6.8, 4.2, 3.8, 2.1, 7.9, 8.5, 5.3, 6.1]  # log10(i0) (A/cmÂ²)
}

df = pd.DataFrame(data)
print(df.head())
print(f&quot;\nãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆå½¢çŠ¶: {df.shape}&quot;)
print(f&quot;è¨˜è¿°å­: {df.columns.tolist()[1:-1]}&quot;)
</code></pre>
<h3>ä¾‹9: ãƒ‡ãƒ¼ã‚¿ã®å‰å‡¦ç†ã¨åˆ†å‰²</h3>
<pre><code class="language-python">from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler

# ç‰¹å¾´é‡ã¨ã‚¿ãƒ¼ã‚²ãƒƒãƒˆ
X = df[['d_band_center', 'work_function', 'surface_energy',
        'lattice_constant', 'H_ads_energy']].values
y = df['HER_activity'].values

# è¨“ç·´ãƒ‡ãƒ¼ã‚¿ã¨ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ã«åˆ†å‰²
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.3, random_state=42
)

# æ¨™æº–åŒ–
scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)

print(f&quot;è¨“ç·´ãƒ‡ãƒ¼ã‚¿: {X_train.shape}&quot;)
print(f&quot;ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿: {X_test.shape}&quot;)
print(f&quot;\nã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°å‰: mean={X_train.mean(axis=0)}, std={X_train.std(axis=0)}&quot;)
print(f&quot;ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°å¾Œ: mean={X_train_scaled.mean(axis=0)}, std={X_train_scaled.std(axis=0)}&quot;)
</code></pre>
<h3>ä¾‹10: ç·šå½¢å›å¸°ãƒ¢ãƒ‡ãƒ«</h3>
<pre><code class="language-python">from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_absolute_error, r2_score
import matplotlib.pyplot as plt

# ãƒ¢ãƒ‡ãƒ«è¨“ç·´
model_lr = LinearRegression()
model_lr.fit(X_train_scaled, y_train)

# äºˆæ¸¬
y_pred_train = model_lr.predict(X_train_scaled)
y_pred_test = model_lr.predict(X_test_scaled)

# è©•ä¾¡
mae_train = mean_absolute_error(y_train, y_pred_train)
mae_test = mean_absolute_error(y_test, y_pred_test)
r2_train = r2_score(y_train, y_pred_train)
r2_test = r2_score(y_test, y_pred_test)

print(f&quot;è¨“ç·´ãƒ‡ãƒ¼ã‚¿: MAE={mae_train:.3f}, RÂ²={r2_train:.3f}&quot;)
print(f&quot;ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿: MAE={mae_test:.3f}, RÂ²={r2_test:.3f}&quot;)

# ä¿‚æ•°ã®ç¢ºèª
feature_names = ['d-band center', 'work function', 'surface energy',
                 'lattice constant', 'H_ads_energy']
for name, coef in zip(feature_names, model_lr.coef_):
    print(f&quot;{name}: {coef:.3f}&quot;)
</code></pre>
<h3>ä¾‹11: ãƒ©ãƒ³ãƒ€ãƒ ãƒ•ã‚©ãƒ¬ã‚¹ãƒˆå›å¸°</h3>
<pre><code class="language-python">from sklearn.ensemble import RandomForestRegressor

# ãƒ¢ãƒ‡ãƒ«è¨“ç·´
model_rf = RandomForestRegressor(n_estimators=100, max_depth=5, random_state=42)
model_rf.fit(X_train_scaled, y_train)

# äºˆæ¸¬ã¨è©•ä¾¡
y_pred_test_rf = model_rf.predict(X_test_scaled)
mae_rf = mean_absolute_error(y_test, y_pred_test_rf)
r2_rf = r2_score(y_test, y_pred_test_rf)

print(f&quot;Random Forest: MAE={mae_rf:.3f}, RÂ²={r2_rf:.3f}&quot;)

# ç‰¹å¾´é‡é‡è¦åº¦
importances = model_rf.feature_importances_
for name, imp in zip(feature_names, importances):
    print(f&quot;{name}: {imp:.3f}&quot;)
</code></pre>
<h3>ä¾‹12: ã‚¯ãƒ­ã‚¹ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³</h3>
<pre><code class="language-python">from sklearn.model_selection import cross_val_score
from sklearn.linear_model import Ridge

# Ridgeãƒ¢ãƒ‡ãƒ«ã§ã‚¯ãƒ­ã‚¹ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
model_ridge = Ridge(alpha=1.0)
scores = cross_val_score(model_ridge, X_train_scaled, y_train,
                        cv=5, scoring='neg_mean_absolute_error')

print(f&quot;5-fold CV MAE: {-scores.mean():.3f} Â± {scores.std():.3f}&quot;)
print(f&quot;å„fold: {-scores}&quot;)

# ãƒã‚¤ãƒ‘ãƒ¼ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿èª¿æ•´
alphas = [0.01, 0.1, 1.0, 10.0, 100.0]
for alpha in alphas:
    model = Ridge(alpha=alpha)
    scores = cross_val_score(model, X_train_scaled, y_train,
                            cv=5, scoring='neg_mean_absolute_error')
    print(f&quot;alpha={alpha:6.2f}: MAE={-scores.mean():.3f}&quot;)
</code></pre>
<h3>ä¾‹13: Gaussian Processå›å¸°</h3>
<pre><code class="language-python">from sklearn.gaussian_process import GaussianProcessRegressor
from sklearn.gaussian_process.kernels import RBF, ConstantKernel

# ã‚«ãƒ¼ãƒãƒ«å®šç¾©
kernel = ConstantKernel(1.0) * RBF(length_scale=1.0)

# GPRãƒ¢ãƒ‡ãƒ«
model_gpr = GaussianProcessRegressor(kernel=kernel, n_restarts_optimizer=10,
                                     random_state=42)
model_gpr.fit(X_train_scaled, y_train)

# äºˆæ¸¬ï¼ˆä¸ç¢ºå®Ÿæ€§ä»˜ãï¼‰
y_pred_gpr, y_std = model_gpr.predict(X_test_scaled, return_std=True)

mae_gpr = mean_absolute_error(y_test, y_pred_gpr)
r2_gpr = r2_score(y_test, y_pred_gpr)

print(f&quot;GPR: MAE={mae_gpr:.3f}, RÂ²={r2_gpr:.3f}&quot;)
print(f&quot;\näºˆæ¸¬ã¨ä¸ç¢ºå®Ÿæ€§:&quot;)
for true, pred, std in zip(y_test, y_pred_gpr, y_std):
    print(f&quot;True: {true:.2f}, Pred: {pred:.2f} Â± {std:.2f}&quot;)
</code></pre>
<h3>ä¾‹14: ç«å±±å‹ãƒ—ãƒ­ãƒƒãƒˆã®ä½œæˆ</h3>
<pre><code class="language-python">import matplotlib.pyplot as plt
import numpy as np

# Hå¸ç€ã‚¨ãƒãƒ«ã‚®ãƒ¼ã¨HERæ´»æ€§ã®é–¢ä¿‚
fig, ax = plt.subplots(figsize=(8, 6))

ax.scatter(df['H_ads_energy'], df['HER_activity'], s=100, alpha=0.7)

# é‡‘å±åã‚’è¡¨ç¤º
for i, txt in enumerate(df['metal']):
    ax.annotate(txt, (df['H_ads_energy'].iloc[i], df['HER_activity'].iloc[i]),
                xytext=(5, 5), textcoords='offset points')

# ç«å±±å‹ãƒ•ã‚£ãƒƒãƒˆï¼ˆ2æ¬¡å¤šé …å¼ï¼‰
x_fit = np.linspace(df['H_ads_energy'].min(), df['H_ads_energy'].max(), 100)
coeffs = np.polyfit(df['H_ads_energy'], df['HER_activity'], 2)
y_fit = np.polyval(coeffs, x_fit)
ax.plot(x_fit, y_fit, 'r--', label='Volcano fit')

ax.set_xlabel('H adsorption energy (eV)', fontsize=12)
ax.set_ylabel('logâ‚â‚€(HER activity)', fontsize=12)
ax.set_title('Volcano Plot for HER Activity', fontsize=14)
ax.legend()
ax.grid(alpha=0.3)

print(f&quot;æœ€é©Hå¸ç€ã‚¨ãƒãƒ«ã‚®ãƒ¼: {-coeffs[1]/(2*coeffs[0]):.3f} eV&quot;)
</code></pre>
<h3>ä¾‹15: äºˆæ¸¬ãƒ¢ãƒ‡ãƒ«ã®ä¿å­˜ã¨èª­ã¿è¾¼ã¿</h3>
<pre><code class="language-python">import pickle

# ãƒ¢ãƒ‡ãƒ«ã®ä¿å­˜
with open('catalyst_model.pkl', 'wb') as f:
    pickle.dump({'model': model_rf, 'scaler': scaler}, f)

print(&quot;ãƒ¢ãƒ‡ãƒ«ã‚’ä¿å­˜ã—ã¾ã—ãŸ: catalyst_model.pkl&quot;)

# ãƒ¢ãƒ‡ãƒ«ã®èª­ã¿è¾¼ã¿
with open('catalyst_model.pkl', 'rb') as f:
    loaded = pickle.load(f)
    loaded_model = loaded['model']
    loaded_scaler = loaded['scaler']

# æ–°ã—ã„ãƒ‡ãƒ¼ã‚¿ã§äºˆæ¸¬
new_catalyst = np.array([[-2.0, 5.0, 2.0, 3.8, -0.4]])  # ä»®æƒ³è§¦åª’
new_catalyst_scaled = loaded_scaler.transform(new_catalyst)
prediction = loaded_model.predict(new_catalyst_scaled)

print(f&quot;æ–°è§¦åª’ã®äºˆæ¸¬HERæ´»æ€§: {prediction[0]:.2f}&quot;)
</code></pre>
<hr />
<h2>3.3 ãƒ™ã‚¤ã‚ºæœ€é©åŒ–ã«ã‚ˆã‚‹è§¦åª’çµ„æˆæ¢ç´¢</h2>
<h3>ä¾‹16: ãƒ™ã‚¤ã‚ºæœ€é©åŒ–ã®åŸºæœ¬</h3>
<pre><code class="language-python">from skopt import gp_minimize
from skopt.space import Real
import numpy as np

# ç›®çš„é–¢æ•°ï¼ˆè§¦åª’æ´»æ€§ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰
def catalyst_performance(x):
    &quot;&quot;&quot;
    x[0]: Ptæ¯”ç‡ (0-1)
    x[1]: ç„¼æˆæ¸©åº¦ (300-800 K)
    &quot;&quot;&quot;
    pt_ratio, temp = x
    # ä»®æƒ³çš„ãªæ´»æ€§é–¢æ•°ï¼ˆå®Ÿéš›ã¯å®Ÿé¨“ or DFTè¨ˆç®—ï¼‰
    activity = -((pt_ratio - 0.6)**2 * 10 + (temp - 600)**2 / 10000)
    noise = np.random.normal(0, 0.1)  # å®Ÿé¨“ãƒã‚¤ã‚º
    return -activity + noise  # æœ€å°åŒ–å•é¡Œã«å¤‰æ›

# æ¢ç´¢ç©ºé–“
space = [
    Real(0.0, 1.0, name='pt_ratio'),
    Real(300, 800, name='temperature')
]

# ãƒ™ã‚¤ã‚ºæœ€é©åŒ–å®Ÿè¡Œ
result = gp_minimize(
    catalyst_performance,
    space,
    n_calls=20,  # å®Ÿé¨“å›æ•°
    random_state=42,
    verbose=True
)

print(f&quot;\næœ€é©ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿:&quot;)
print(f&quot;  Ptæ¯”ç‡: {result.x[0]:.3f}&quot;)
print(f&quot;  ç„¼æˆæ¸©åº¦: {result.x[1]:.1f} K&quot;)
print(f&quot;  æœ€å¤§æ´»æ€§: {-result.fun:.3f}&quot;)
</code></pre>
<h3>ä¾‹17: ç²å¾—é–¢æ•°ã®æ¯”è¼ƒ</h3>
<pre><code class="language-python">from skopt import gp_minimize
from skopt.space import Real

# 3ã¤ã®ç²å¾—é–¢æ•°ã§æ¯”è¼ƒ
acq_funcs = ['EI', 'PI', 'LCB']
results = {}

for acq in acq_funcs:
    result = gp_minimize(
        catalyst_performance,
        space,
        n_calls=15,
        acq_func=acq,
        random_state=42,
        verbose=False
    )
    results[acq] = result
    print(f&quot;{acq}: æœ€é©å€¤ = {-result.fun:.3f}, &quot;
          f&quot;Ptæ¯”ç‡ = {result.x[0]:.3f}, æ¸©åº¦ = {result.x[1]:.1f}K&quot;)
</code></pre>
<h3>ä¾‹18: å¤šç›®çš„æœ€é©åŒ–ï¼ˆæ´»æ€§ vs ã‚³ã‚¹ãƒˆï¼‰</h3>
<pre><code class="language-python">from skopt import gp_minimize
import numpy as np

def multi_objective(x):
    &quot;&quot;&quot;æ´»æ€§ã¨ã‚³ã‚¹ãƒˆã®ãƒˆãƒ¬ãƒ¼ãƒ‰ã‚ªãƒ•&quot;&quot;&quot;
    pt_ratio = x[0]
    temp = x[1]

    # æ´»æ€§ï¼ˆé«˜ã„æ–¹ãŒè‰¯ã„ï¼‰
    activity = -((pt_ratio - 0.6)**2 * 10 + (temp - 600)**2 / 10000)

    # ã‚³ã‚¹ãƒˆï¼ˆPtä½¿ç”¨é‡ã«ä¾å­˜ã€ä½ã„æ–¹ãŒè‰¯ã„ï¼‰
    cost = pt_ratio * 100 + (temp - 300) / 10

    # é‡ã¿ä»˜ãå’Œï¼ˆã‚¹ã‚«ãƒ©ãƒ¼åŒ–ï¼‰
    weight_activity = 0.7
    weight_cost = 0.3
    return -(weight_activity * activity - weight_cost * cost)

result_mo = gp_minimize(multi_objective, space, n_calls=25, random_state=42)

print(f&quot;æœ€é©ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ï¼ˆå¤šç›®çš„ï¼‰:&quot;)
print(f&quot;  Ptæ¯”ç‡: {result_mo.x[0]:.3f}&quot;)
print(f&quot;  æ¸©åº¦: {result_mo.x[1]:.1f} K&quot;)
</code></pre>
<h3>ä¾‹19: å®Ÿé¨“å±¥æ­´ã®å¯è¦–åŒ–</h3>
<pre><code class="language-python">from skopt.plots import plot_convergence, plot_evaluations
import matplotlib.pyplot as plt

# åæŸãƒ—ãƒ­ãƒƒãƒˆ
fig, axes = plt.subplots(1, 2, figsize=(14, 5))

plot_convergence(result, ax=axes[0])
axes[0].set_title('Convergence Plot')
axes[0].set_ylabel('Objective Value')

# è©•ä¾¡ãƒ—ãƒ­ãƒƒãƒˆ
plot_evaluations(result, dimensions=['pt_ratio', 'temperature'], ax=axes[1])
axes[1].set_title('Parameter Evaluation')

plt.tight_layout()

# å®Ÿé¨“å±¥æ­´ã®å‡ºåŠ›
print(&quot;\nå®Ÿé¨“å±¥æ­´:&quot;)
for i, (params, value) in enumerate(zip(result.x_iters, result.func_vals)):
    print(f&quot;Exp {i+1}: Pt={params[0]:.3f}, T={params[1]:.1f}K, &quot;
          f&quot;Activity={-value:.3f}&quot;)
</code></pre>
<h3>ä¾‹20: åˆ¶ç´„ä»˜ãæœ€é©åŒ–</h3>
<pre><code class="language-python">from skopt import gp_minimize
import numpy as np

def constrained_objective(x):
    &quot;&quot;&quot;åˆ¶ç´„æ¡ä»¶ä»˜ãè§¦åª’æœ€é©åŒ–&quot;&quot;&quot;
    pt_ratio = x[0]
    ni_ratio = x[1]

    # åˆ¶ç´„: Pt + Ni â‰¤ 0.8ï¼ˆæ®‹ã‚Šã¯å®‰ä¾¡ãªæ‹…ä½“ï¼‰
    if pt_ratio + ni_ratio &gt; 0.8:
        return 1e6  # ãƒšãƒŠãƒ«ãƒ†ã‚£

    # æ´»æ€§äºˆæ¸¬
    activity = -(pt_ratio * 8 + ni_ratio * 5 -
                (pt_ratio - 0.5)**2 * 10 - (ni_ratio - 0.2)**2 * 10)
    return -activity

space_alloy = [
    Real(0.0, 0.8, name='pt_ratio'),
    Real(0.0, 0.8, name='ni_ratio')
]

result_const = gp_minimize(constrained_objective, space_alloy,
                          n_calls=30, random_state=42)

print(f&quot;æœ€é©çµ„æˆ:&quot;)
print(f&quot;  Pt: {result_const.x[0]:.3f}&quot;)
print(f&quot;  Ni: {result_const.x[1]:.3f}&quot;)
print(f&quot;  ãã®ä»–: {1 - result_const.x[0] - result_const.x[1]:.3f}&quot;)
print(f&quot;  äºˆæ¸¬æ´»æ€§: {-result_const.fun:.3f}&quot;)
</code></pre>
<h3>ä¾‹21: ãƒãƒƒãƒãƒ™ã‚¤ã‚ºæœ€é©åŒ–</h3>
<pre><code class="language-python">from skopt import gp_minimize
from skopt.optimizer import Optimizer

# ãƒãƒƒãƒå®Ÿé¨“ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ
optimizer = Optimizer(space, acq_func='EI', random_state=42)

# åˆæœŸã‚µãƒ³ãƒ—ãƒ«
n_initial = 5
X_init = [[np.random.uniform(0, 1), np.random.uniform(300, 800)]
          for _ in range(n_initial)]
y_init = [catalyst_performance(x) for x in X_init]

optimizer.tell(X_init, y_init)

# ãƒãƒƒãƒå®Ÿé¨“ï¼ˆä¸¦åˆ—ã«3å®Ÿé¨“ï¼‰
batch_size = 3
n_batches = 5

for batch in range(n_batches):
    # æ¬¡ã®å®Ÿé¨“å€™è£œã‚’ãƒãƒƒãƒç”Ÿæˆ
    X_next_batch = []
    for _ in range(batch_size):
        x_next = optimizer.ask()
        X_next_batch.append(x_next)

    # å®Ÿé¨“å®Ÿè¡Œï¼ˆä¸¦åˆ—ï¼‰
    y_next_batch = [catalyst_performance(x) for x in X_next_batch]

    # çµæœã‚’æ›´æ–°
    optimizer.tell(X_next_batch, y_next_batch)

    print(f&quot;Batch {batch+1}: Best so far = {-min(optimizer.yi):.3f}&quot;)

print(f&quot;\næœ€çµ‚æœ€é©å€¤: {-min(optimizer.yi):.3f}&quot;)
print(f&quot;ç·å®Ÿé¨“æ•°: {len(optimizer.Xi)}&quot;)
</code></pre>
<h3>ä¾‹22: è»¢ç§»å­¦ç¿’ãƒ™ã‚¤ã‚ºæœ€é©åŒ–</h3>
<pre><code class="language-python">from skopt import gp_minimize
from sklearn.gaussian_process.kernels import RBF, WhiteKernel
import numpy as np

# é¡ä¼¼è§¦åª’ç³»ã®éå»ãƒ‡ãƒ¼ã‚¿ï¼ˆè»¢ç§»å­¦ç¿’ã‚½ãƒ¼ã‚¹ï¼‰
X_source = np.array([[0.3, 400], [0.5, 500], [0.7, 600], [0.9, 700]])
y_source = np.array([-2.5, -4.0, -4.8, -3.5])  # æ´»æ€§ãƒ‡ãƒ¼ã‚¿

# æ–°è§¦åª’ç³»ã®æœ€é©åŒ–ï¼ˆã‚¿ãƒ¼ã‚²ãƒƒãƒˆï¼‰
def target_catalyst(x):
    &quot;&quot;&quot;æ–°ã—ã„è§¦åª’ç³»ï¼ˆé¡ä¼¼ã ãŒç•°ãªã‚‹ï¼‰&quot;&quot;&quot;
    pt_ratio, temp = x
    activity = -((pt_ratio - 0.55)**2 * 12 + (temp - 550)**2 / 8000)
    return -activity + np.random.normal(0, 0.1)

# GPRãƒ¢ãƒ‡ãƒ«ã‚’éå»ãƒ‡ãƒ¼ã‚¿ã§äº‹å‰å­¦ç¿’
from sklearn.gaussian_process import GaussianProcessRegressor

kernel = RBF(length_scale=1.0) + WhiteKernel(noise_level=0.1)
gpr_prior = GaussianProcessRegressor(kernel=kernel)
gpr_prior.fit(X_source, y_source)

# ãƒ™ã‚¤ã‚ºæœ€é©åŒ–ï¼ˆäº‹å‰çŸ¥è­˜ã‚’æ´»ç”¨ï¼‰
result_tl = gp_minimize(
    target_catalyst,
    space,
    n_calls=10,  # å°‘ãªã„å®Ÿé¨“æ•°
    random_state=42
)

print(f&quot;è»¢ç§»å­¦ç¿’ã‚ã‚Š: æœ€é©å€¤ = {-result_tl.fun:.3f} (10å®Ÿé¨“)&quot;)

# æ¯”è¼ƒ: è»¢ç§»å­¦ç¿’ãªã—
result_no_tl = gp_minimize(target_catalyst, space, n_calls=10, random_state=42)
print(f&quot;è»¢ç§»å­¦ç¿’ãªã—: æœ€é©å€¤ = {-result_no_tl.fun:.3f} (10å®Ÿé¨“)&quot;)
</code></pre>
<hr />
<h2>3.4 DFTè¨ˆç®—ã¨ã®çµ±åˆ</h2>
<h3>ä¾‹23: ASEã§ã®DFTè¨ˆç®—è¨­å®š</h3>
<pre><code class="language-python">from ase.build import fcc111, add_adsorbate
from ase import Atoms

# å®Ÿéš›ã®DFTè¨ˆç®—ã¯GPAW, VASP, Quantum ESPRESSOãªã©ãŒå¿…è¦
# ã“ã“ã§ã¯ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ä¾‹ã‚’ç¤ºã™

# Pt(111)è¡¨é¢ã«COå¸ç€
slab = fcc111('Pt', size=(3, 3, 4), vacuum=15.0)
co = Atoms('CO', positions=[(0, 0, 0), (0, 0, 1.15)])
add_adsorbate(slab, co, height=2.0, position='ontop')

# DFTè¨ˆç®—å™¨ã®è¨­å®šï¼ˆGPAWã®å ´åˆï¼‰
# from gpaw import GPAW, PW
# calc = GPAW(
#     mode=PW(500),  # Plane wave cutoff
#     xc='PBE',
#     kpts=(4, 4, 1),
#     txt='co_pt.txt'
# )
# slab.calc = calc

print(&quot;DFTè¨ˆç®—è¨­å®šå®Œäº†ï¼ˆå®Ÿè¡Œã«ã¯GPAWãªã©ãŒå¿…è¦ï¼‰&quot;)
print(f&quot;ã‚·ã‚¹ãƒ†ãƒ ã‚µã‚¤ã‚º: {len(slab)}åŸå­&quot;)
print(f&quot;ã‚»ãƒ«: {slab.get_cell()}&quot;)
</code></pre>
<h3>ä¾‹24: å¸ç€ã‚¨ãƒãƒ«ã‚®ãƒ¼ã®é«˜ç²¾åº¦è¨ˆç®—</h3>
<pre><code class="language-python">from ase.build import fcc111, add_adsorbate
from ase.calculators.emt import EMT  # DFTã®ä»£ã‚ã‚Šã«EMT
from ase.optimize import BFGS
import numpy as np

def dft_adsorption_energy(metal, adsorbate, site='fcc'):
    &quot;&quot;&quot;DFTç›¸å½“ã®å¸ç€ã‚¨ãƒãƒ«ã‚®ãƒ¼è¨ˆç®—&quot;&quot;&quot;
    # æ¸…æµ„è¡¨é¢
    slab = fcc111(metal, size=(3, 3, 4), vacuum=10.0)
    slab.calc = EMT()
    E_slab = slab.get_potential_energy()

    # å¸ç€ç³»
    slab_ads = slab.copy()
    if adsorbate == 'H':
        from ase import Atoms
        atom = Atoms('H')
        add_adsorbate(slab_ads, atom, height=1.5, position=site)

    slab_ads.calc = EMT()
    opt = BFGS(slab_ads, logfile=None)
    opt.run(fmax=0.01)  # é«˜ç²¾åº¦æœ€é©åŒ–
    E_slab_ads = slab_ads.get_potential_energy()

    # æ°—ç›¸H2
    from ase import Atoms
    h2 = Atoms('H2', positions=[(0, 0, 0), (0, 0, 0.74)])
    h2.center(vacuum=10.0)
    h2.calc = EMT()
    E_h2 = h2.get_potential_energy()

    E_ads = E_slab_ads - E_slab - 0.5 * E_h2
    return E_ads

# è¤‡æ•°ã‚µã‚¤ãƒˆã§ã®å¸ç€ã‚¨ãƒãƒ«ã‚®ãƒ¼
sites = ['fcc', 'hcp', 'ontop']
for site in sites:
    E_ads = dft_adsorption_energy('Pt', 'H', site)
    print(f&quot;Pt(111) {site}ã‚µã‚¤ãƒˆ Hå¸ç€: {E_ads:.3f} eV&quot;)
</code></pre>
<h3>ä¾‹25: åå¿œçµŒè·¯è§£æï¼ˆNEBæ³•ï¼‰</h3>
<pre><code class="language-python">from ase.build import fcc111
from ase.calculators.emt import EMT
from ase.neb import NEB
from ase.optimize import BFGS
import numpy as np

# åˆæœŸçŠ¶æ…‹ã¨æœ€çµ‚çŠ¶æ…‹ï¼ˆç°¡ç•¥åŒ–ä¾‹ï¼‰
def setup_reaction_path():
    &quot;&quot;&quot;HåŸå­ã®è¡¨é¢æ‹¡æ•£ï¼ˆfcc â†’ hcpï¼‰&quot;&quot;&quot;
    # åˆæœŸçŠ¶æ…‹: H at fcc site
    slab_initial = fcc111('Pt', size=(3, 3, 3), vacuum=10.0)
    from ase import Atoms
    from ase.build import add_adsorbate
    h_atom = Atoms('H')
    add_adsorbate(slab_initial, h_atom, height=1.5, position='fcc')
    slab_initial.calc = EMT()

    # æœ€çµ‚çŠ¶æ…‹: H at hcp site
    slab_final = fcc111('Pt', size=(3, 3, 3), vacuum=10.0)
    h_atom = Atoms('H')
    add_adsorbate(slab_final, h_atom, height=1.5, position='hcp')
    slab_final.calc = EMT()

    return slab_initial, slab_final

initial, final = setup_reaction_path()

# NEBè¨ˆç®—ï¼ˆç°¡ç•¥ç‰ˆï¼‰
print(&quot;NEBæ³•ã«ã‚ˆã‚‹é·ç§»çŠ¶æ…‹æ¢ç´¢&quot;)
print(f&quot;åˆæœŸçŠ¶æ…‹ã‚¨ãƒãƒ«ã‚®ãƒ¼: {initial.get_potential_energy():.3f} eV&quot;)
print(f&quot;æœ€çµ‚çŠ¶æ…‹ã‚¨ãƒãƒ«ã‚®ãƒ¼: {final.get_potential_energy():.3f} eV&quot;)
print(&quot;å®Ÿéš›ã®NEBè¨ˆç®—ã«ã¯è¤‡æ•°ã®ã‚¤ãƒ¡ãƒ¼ã‚¸ã¨æœ€é©åŒ–ãŒå¿…è¦&quot;)
</code></pre>
<h3>ä¾‹26: é›»å­çŠ¶æ…‹è§£æ</h3>
<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt

# DFTè¨ˆç®—ã‹ã‚‰å¾—ã‚‰ã‚Œã‚‹DOSï¼ˆçŠ¶æ…‹å¯†åº¦ï¼‰ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
def simulate_dos(metal):
    &quot;&quot;&quot;é‡‘å±ã®DOSã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ&quot;&quot;&quot;
    energies = np.linspace(-10, 5, 500)

    if metal == 'Pt':
        # d-band: -6 to -2 eV
        dos = np.exp(-((energies + 2.25)**2) / 2) * 3
        # sp-band
        dos += np.exp(-((energies - 0)**2) / 10) * 0.5
    elif metal == 'Cu':
        # d-band: -4 to -1 eV (deeper)
        dos = np.exp(-((energies + 2.67)**2) / 2) * 3
        dos += np.exp(-((energies - 0)**2) / 10) * 0.5

    return energies, dos

# ãƒ—ãƒ­ãƒƒãƒˆ
fig, ax = plt.subplots(figsize=(10, 6))

for metal in ['Pt', 'Cu']:
    energies, dos = simulate_dos(metal)
    ax.plot(energies, dos, label=metal, linewidth=2)

ax.axvline(0, color='k', linestyle='--', label='Fermi level')
ax.set_xlabel('Energy (eV)', fontsize=12)
ax.set_ylabel('Density of States', fontsize=12)
ax.set_title('Electronic DOS of Metal Catalysts', fontsize=14)
ax.legend()
ax.grid(alpha=0.3)

print(&quot;DOSãƒ—ãƒ­ãƒƒãƒˆä½œæˆå®Œäº†&quot;)
</code></pre>
<h3>ä¾‹27: DFT-MLé€£æºãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼</h3>
<pre><code class="language-python">from sklearn.gaussian_process import GaussianProcessRegressor
from sklearn.gaussian_process.kernels import RBF
import numpy as np

# ã‚¹ãƒ†ãƒƒãƒ—1: å°‘æ•°ã®DFTè¨ˆç®—
def expensive_dft_calculation(composition):
    &quot;&quot;&quot;é«˜ã‚³ã‚¹ãƒˆDFTè¨ˆç®—ï¼ˆã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰&quot;&quot;&quot;
    x = composition
    # å®Ÿéš›ã®å¸ç€ã‚¨ãƒãƒ«ã‚®ãƒ¼è¨ˆç®—
    energy = -2.0 + 3.0 * x - 2.0 * x**2 + np.random.normal(0, 0.05)
    return energy

# åˆæœŸDFTè¨ˆç®—ï¼ˆ5ç‚¹ï¼‰
X_dft = np.array([[0.2], [0.4], [0.6], [0.8], [1.0]])
y_dft = np.array([expensive_dft_calculation(x[0]) for x in X_dft])

# ã‚¹ãƒ†ãƒƒãƒ—2: GPRã‚µãƒ­ã‚²ãƒ¼ãƒˆãƒ¢ãƒ‡ãƒ«
gpr = GaussianProcessRegressor(kernel=RBF(), n_restarts_optimizer=10)
gpr.fit(X_dft, y_dft)

# ã‚¹ãƒ†ãƒƒãƒ—3: å¤šæ•°ç‚¹ã§ã®äºˆæ¸¬ï¼ˆä½ã‚³ã‚¹ãƒˆï¼‰
X_pred = np.linspace(0, 1, 100).reshape(-1, 1)
y_pred, y_std = gpr.predict(X_pred, return_std=True)

print(&quot;DFT-MLé€£æºãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼:&quot;)
print(f&quot;DFTè¨ˆç®—æ•°: {len(X_dft)}&quot;)
print(f&quot;MLäºˆæ¸¬æ•°: {len(X_pred)}&quot;)
print(f&quot;æœ€é©çµ„æˆï¼ˆäºˆæ¸¬ï¼‰: {X_pred[np.argmin(y_pred)][0]:.3f}&quot;)

# ãƒ—ãƒ­ãƒƒãƒˆ
import matplotlib.pyplot as plt
fig, ax = plt.subplots(figsize=(10, 6))
ax.scatter(X_dft, y_dft, c='red', s=100, label='DFT calc', zorder=10)
ax.plot(X_pred, y_pred, 'b-', label='GPR mean')
ax.fill_between(X_pred.ravel(), y_pred - y_std, y_pred + y_std,
                alpha=0.3, label='Â±1 std')
ax.set_xlabel('Composition')
ax.set_ylabel('Adsorption Energy (eV)')
ax.legend()
</code></pre>
<hr />
<h2>3.5 åå¿œé€Ÿåº¦è«–è§£æ</h2>
<h3>ä¾‹28: Arrheniusè§£æ</h3>
<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit

# å®Ÿé¨“ãƒ‡ãƒ¼ã‚¿ï¼ˆæ¸©åº¦ vs åå¿œé€Ÿåº¦ï¼‰
temperatures = np.array([300, 350, 400, 450, 500, 550])  # K
rate_constants = np.array([0.01, 0.05, 0.15, 0.35, 0.70, 1.20])  # sâ»Â¹

# Arrheniuså¼: k = A * exp(-Ea / (R*T))
def arrhenius(T, A, Ea):
    R = 8.314e-3  # kJ/(molÂ·K)
    return A * np.exp(-Ea / (R * T))

# ãƒ•ã‚£ãƒƒãƒ†ã‚£ãƒ³ã‚°
popt, pcov = curve_fit(arrhenius, temperatures, rate_constants, p0=[1e10, 50])
A_fit, Ea_fit = popt

print(f&quot;é »åº¦å› å­ A: {A_fit:.2e} sâ»Â¹&quot;)
print(f&quot;æ´»æ€§åŒ–ã‚¨ãƒãƒ«ã‚®ãƒ¼ Ea: {Ea_fit:.2f} kJ/mol&quot;)

# Arrheniusãƒ—ãƒ­ãƒƒãƒˆ
fig, axes = plt.subplots(1, 2, figsize=(14, 5))

# é€šå¸¸ãƒ—ãƒ­ãƒƒãƒˆ
axes[0].scatter(temperatures, rate_constants, label='Experimental', s=100)
T_fit = np.linspace(280, 570, 100)
axes[0].plot(T_fit, arrhenius(T_fit, A_fit, Ea_fit), 'r--', label='Fit')
axes[0].set_xlabel('Temperature (K)')
axes[0].set_ylabel('Rate constant (sâ»Â¹)')
axes[0].legend()

# Arrheniusãƒ—ãƒ­ãƒƒãƒˆï¼ˆç·šå½¢åŒ–ï¼‰
axes[1].scatter(1000/temperatures, np.log(rate_constants), s=100)
axes[1].plot(1000/T_fit, np.log(arrhenius(T_fit, A_fit, Ea_fit)), 'r--')
axes[1].set_xlabel('1000/T (Kâ»Â¹)')
axes[1].set_ylabel('ln(k)')
axes[1].set_title(f'Ea = {Ea_fit:.1f} kJ/mol')
</code></pre>
<h3>ä¾‹29: åå¿œæ¬¡æ•°è§£æ</h3>
<pre><code class="language-python">import numpy as np
from scipy.integrate import odeint
import matplotlib.pyplot as plt

# åå¿œé€Ÿåº¦å¼: -dC/dt = k * C^n
def reaction_rate(C, t, k, n):
    &quot;&quot;&quot;næ¬¡åå¿œã®é€Ÿåº¦å¼&quot;&quot;&quot;
    return -k * C**n

# ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
k = 0.1  # é€Ÿåº¦å®šæ•°
C0 = 1.0  # åˆæœŸæ¿ƒåº¦
t = np.linspace(0, 50, 100)

# ç•°ãªã‚‹åå¿œæ¬¡æ•°ã§è¨ˆç®—
fig, ax = plt.subplots(figsize=(10, 6))

for n in [0, 1, 2]:
    C = odeint(reaction_rate, C0, t, args=(k, n))
    ax.plot(t, C, label=f'n={n} order', linewidth=2)

ax.set_xlabel('Time', fontsize=12)
ax.set_ylabel('Concentration', fontsize=12)
ax.set_title('Reaction Order Effects', fontsize=14)
ax.legend()
ax.grid(alpha=0.3)

# åŠæ¸›æœŸã®è¨ˆç®—
def half_life(k, n, C0=1.0):
    &quot;&quot;&quot;næ¬¡åå¿œã®åŠæ¸›æœŸ&quot;&quot;&quot;
    if n == 0:
        return C0 / (2 * k)
    elif n == 1:
        return np.log(2) / k
    elif n == 2:
        return 1 / (k * C0)

for n in [0, 1, 2]:
    t_half = half_life(k, n, C0)
    print(f&quot;{n}æ¬¡åå¿œã®åŠæ¸›æœŸ: {t_half:.2f}&quot;)
</code></pre>
<h3>ä¾‹30: ãƒã‚¤ã‚¯ãƒ­ã‚­ãƒãƒ†ã‚£ã‚¯ã‚¹ãƒ¢ãƒ‡ãƒ«</h3>
<pre><code class="language-python">import numpy as np
from scipy.integrate import odeint
import matplotlib.pyplot as plt

# COé…¸åŒ–åå¿œã®ãƒã‚¤ã‚¯ãƒ­ã‚­ãƒãƒ†ã‚£ã‚¯ã‚¹ãƒ¢ãƒ‡ãƒ«
# CO(g) + O(g) -&gt; CO2(g) on Pt surface
def microkinetics(y, t, k1, k2, k3, k4):
    &quot;&quot;&quot;
    y: [Î¸_CO, Î¸_O, Î¸_free]  # è¡¨é¢è¢«è¦†ç‡
    k1: COå¸ç€é€Ÿåº¦å®šæ•°
    k2: O2è§£é›¢å¸ç€é€Ÿåº¦å®šæ•°
    k3: COé…¸åŒ–é€Ÿåº¦å®šæ•°
    k4: CO2è„±é›¢é€Ÿåº¦å®šæ•°
    &quot;&quot;&quot;
    theta_CO, theta_O, theta_free = y

    # æ°—ç›¸åˆ†åœ§ï¼ˆä¸€å®šï¼‰
    P_CO = 0.1  # bar
    P_O2 = 0.2  # bar

    # åå¿œé€Ÿåº¦
    r1 = k1 * P_CO * theta_free  # COå¸ç€
    r2 = k2 * P_O2 * theta_free**2  # O2è§£é›¢å¸ç€
    r3 = k3 * theta_CO * theta_O  # CO + O -&gt; CO2
    r4 = k4 * theta_CO * theta_O  # CO2è„±é›¢ï¼ˆåå¿œã¨åŒæ™‚ï¼‰

    # è¢«è¦†ç‡å¤‰åŒ–
    dtheta_CO_dt = r1 - r3
    dtheta_O_dt = 2 * r2 - r3
    dtheta_free_dt = -r1 - 2 * r2 + r3

    return [dtheta_CO_dt, dtheta_O_dt, dtheta_free_dt]

# åˆæœŸæ¡ä»¶
y0 = [0.0, 0.0, 1.0]  # æ¸…æµ„è¡¨é¢

# é€Ÿåº¦å®šæ•°ï¼ˆä»»æ„å˜ä½ï¼‰
k1, k2, k3, k4 = 1.0, 0.5, 2.0, 2.0

# æ™‚é–“ç™ºå±•
t = np.linspace(0, 10, 1000)
solution = odeint(microkinetics, y0, t, args=(k1, k2, k3, k4))

# ãƒ—ãƒ­ãƒƒãƒˆ
fig, ax = plt.subplots(figsize=(10, 6))
ax.plot(t, solution[:, 0], label='Î¸_CO', linewidth=2)
ax.plot(t, solution[:, 1], label='Î¸_O', linewidth=2)
ax.plot(t, solution[:, 2], label='Î¸_free', linewidth=2)
ax.set_xlabel('Time', fontsize=12)
ax.set_ylabel('Surface Coverage', fontsize=12)
ax.set_title('Microkinetic Model: CO Oxidation on Pt', fontsize=14)
ax.legend()
ax.grid(alpha=0.3)

# å®šå¸¸çŠ¶æ…‹
theta_CO_ss = solution[-1, 0]
theta_O_ss = solution[-1, 1]
TOF = k3 * theta_CO_ss * theta_O_ss  # Turnover Frequency

print(f&quot;å®šå¸¸çŠ¶æ…‹:&quot;)
print(f&quot;  Î¸_CO: {theta_CO_ss:.3f}&quot;)
print(f&quot;  Î¸_O: {theta_O_ss:.3f}&quot;)
print(f&quot;  TOF: {TOF:.3f} sâ»Â¹&quot;)
</code></pre>
<hr />
<h2>3.6 ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒãƒ£ãƒ¬ãƒ³ã‚¸</h2>
<p><strong>èª²é¡Œ: CO2é‚„å…ƒè§¦åª’ã®æœ€é©åŒ–</strong></p>
<p>ä»¥ä¸‹ã®æ‰‹é †ã§ã€CO2â†’COå¤‰æ›è§¦åª’ã‚’æœ€é©åŒ–ã—ã¦ãã ã•ã„ï¼š</p>
<ol>
<li><strong>ãƒ‡ãƒ¼ã‚¿åé›†</strong>: è¤‡æ•°é‡‘å±ï¼ˆCu, Ag, Au, Pd, Ptï¼‰ã®CO2å¸ç€ã‚¨ãƒãƒ«ã‚®ãƒ¼ã‚’è¨ˆç®—</li>
<li><strong>è¨˜è¿°å­è¨ˆç®—</strong>: d-band centerã€work functionãªã©ã‚’å–å¾—</li>
<li><strong>äºˆæ¸¬ãƒ¢ãƒ‡ãƒ«æ§‹ç¯‰</strong>: è¨˜è¿°å­ã‹ã‚‰æ´»æ€§ã‚’äºˆæ¸¬ã™ã‚‹GPRãƒ¢ãƒ‡ãƒ«</li>
<li><strong>ãƒ™ã‚¤ã‚ºæœ€é©åŒ–</strong>: åˆé‡‘çµ„æˆã‚’æœ€é©åŒ–ï¼ˆCu-AgäºŒå…ƒç³»ï¼‰</li>
<li><strong>æ¤œè¨¼</strong>: æœ€é©çµ„æˆã§ã®DFTè¨ˆç®—ï¼ˆEMTè¿‘ä¼¼ï¼‰</li>
</ol>
<p><strong>è©•ä¾¡åŸºæº–:</strong>
- COç”Ÿæˆé¸æŠæ€§ &gt; 80%
- éé›»åœ§ &lt; 0.5 V
- ã‚³ã‚¹ãƒˆï¼ˆAgä½¿ç”¨é‡ï¼‰æœ€å°åŒ–</p>
<p><strong>æå‡ºç‰©:</strong>
- æœ€é©çµ„æˆï¼ˆCu:Agæ¯”ç‡ï¼‰
- äºˆæ¸¬æ´»æ€§ã¨ã‚³ã‚¹ãƒˆã®ãƒˆãƒ¬ãƒ¼ãƒ‰ã‚ªãƒ•åˆ†æ
- Pythonã‚³ãƒ¼ãƒ‰å…¨ä½“</p>
<hr />
<h2>æ¼”ç¿’å•é¡Œ</h2>
<p><strong>å•1:</strong> Pt-Niåˆé‡‘è§¦åª’ï¼ˆPt:Ni = 3:1ï¼‰ã®(111)è¡¨é¢ã‚’ä½œæˆã—ã€é…ä½æ•°åˆ†å¸ƒã‚’è¨ˆç®—ã›ã‚ˆã€‚</p>
<p><strong>å•2:</strong> ç¬¬2ç« ã®SabatieråŸç†ã«åŸºã¥ãã€æœ€é©Hå¸ç€ã‚¨ãƒãƒ«ã‚®ãƒ¼ã‚’æ©Ÿæ¢°å­¦ç¿’ã§äºˆæ¸¬ã™ã‚‹ãƒ¢ãƒ‡ãƒ«ã‚’æ§‹ç¯‰ã›ã‚ˆï¼ˆä¾‹8-14å‚ç…§ï¼‰ã€‚</p>
<p><strong>å•3:</strong> ãƒ™ã‚¤ã‚ºæœ€é©åŒ–ã§ã€ç„¼æˆæ¸©åº¦ï¼ˆ400-900 Kï¼‰ã¨æ‹…æŒé‡ï¼ˆ0-50 wt%ï¼‰ã‚’åŒæ™‚æœ€é©åŒ–ã—ã€æœ€å¤§æ´»æ€§ã‚’é”æˆã›ã‚ˆã€‚</p>
<p><strong>å•4:</strong> Arrheniusãƒ—ãƒ­ãƒƒãƒˆã‹ã‚‰ã€ã‚ãªãŸã®å®Ÿé¨“ãƒ‡ãƒ¼ã‚¿ã®æ´»æ€§åŒ–ã‚¨ãƒãƒ«ã‚®ãƒ¼ã‚’ç®—å‡ºã›ã‚ˆã€‚</p>
<p><strong>å•5:</strong> ãƒã‚¤ã‚¯ãƒ­ã‚­ãƒãƒ†ã‚£ã‚¯ã‚¹ãƒ¢ãƒ‡ãƒ«ã§ã€CO/O2æ¯”ã‚’å¤‰åŒ–ã•ã›ãŸã¨ãã®å®šå¸¸çŠ¶æ…‹è¢«è¦†ç‡ã¨TOFã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã›ã‚ˆã€‚</p>
<hr />
<h2>å‚è€ƒæ–‡çŒ®</h2>
<ol>
<li><strong>ASE Documentation</strong>: https://wiki.fysik.dtu.dk/ase/</li>
<li><strong>scikit-optimize</strong>: https://scikit-optimize.github.io/</li>
<li>NÃ¸rskov, J. K. et al. "Origin of the Overpotential for Oxygen Reduction at a Fuel-Cell Cathode." <em>J. Phys. Chem. B</em> (2004).</li>
<li>Hammer, B. &amp; NÃ¸rskov, J. K. "Theoretical Surface Science and Catalysis." <em>Advances in Catalysis</em> (2000).</li>
</ol>
<hr />
<p><strong>æ¬¡ç« </strong>: <a href="chapter4-case-studies.html">ç¬¬4ç« ï¼šè§¦åª’MIå®Ÿè·µã‚±ãƒ¼ã‚¹ã‚¹ã‚¿ãƒ‡ã‚£</a></p>
<p><strong>ãƒ©ã‚¤ã‚»ãƒ³ã‚¹</strong>: ã“ã®ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã¯CC BY 4.0ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã®ä¸‹ã§æä¾›ã•ã‚Œã¦ã„ã¾ã™ã€‚</p><div class="navigation">
    <a href="chapter2-methods.html" class="nav-button">â† å‰ã®ç« </a>
    <a href="index.html" class="nav-button">ã‚·ãƒªãƒ¼ã‚ºç›®æ¬¡ã«æˆ»ã‚‹</a>
    <a href="chapter4-case-studies.html" class="nav-button">æ¬¡ã®ç«  â†’</a>
</div>
    </main>

    
    <section class="disclaimer">
        <h3>å…è²¬äº‹é …</h3>
        <ul>
            <li>æœ¬ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã¯æ•™è‚²ãƒ»ç ”ç©¶ãƒ»æƒ…å ±æä¾›ã®ã¿ã‚’ç›®çš„ã¨ã—ã¦ãŠã‚Šã€å°‚é–€çš„ãªåŠ©è¨€(æ³•å¾‹ãƒ»ä¼šè¨ˆãƒ»æŠ€è¡“çš„ä¿è¨¼ãªã©)ã‚’æä¾›ã™ã‚‹ã‚‚ã®ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚</li>
            <li>æœ¬ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãŠã‚ˆã³ä»˜éšã™ã‚‹ã‚³ãƒ¼ãƒ‰ä¾‹ã¯ã€Œç¾çŠ¶æœ‰å§¿(AS IS)ã€ã§æä¾›ã•ã‚Œã€æ˜ç¤ºã¾ãŸã¯é»™ç¤ºã‚’å•ã‚ãšã€å•†å“æ€§ã€ç‰¹å®šç›®çš„é©åˆæ€§ã€æ¨©åˆ©éä¾µå®³ã€æ­£ç¢ºæ€§ãƒ»å®Œå…¨æ€§ã€å‹•ä½œãƒ»å®‰å…¨æ€§ç­‰ã„ã‹ãªã‚‹ä¿è¨¼ã‚‚ã—ã¾ã›ã‚“ã€‚</li>
            <li>å¤–éƒ¨ãƒªãƒ³ã‚¯ã€ç¬¬ä¸‰è€…ãŒæä¾›ã™ã‚‹ãƒ‡ãƒ¼ã‚¿ãƒ»ãƒ„ãƒ¼ãƒ«ãƒ»ãƒ©ã‚¤ãƒ–ãƒ©ãƒªç­‰ã®å†…å®¹ãƒ»å¯ç”¨æ€§ãƒ»å®‰å…¨æ€§ã«ã¤ã„ã¦ã€ä½œæˆè€…ãŠã‚ˆã³æ±åŒ—å¤§å­¦ã¯ä¸€åˆ‡ã®è²¬ä»»ã‚’è² ã„ã¾ã›ã‚“ã€‚</li>
            <li>æœ¬ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®åˆ©ç”¨ãƒ»å®Ÿè¡Œãƒ»è§£é‡ˆã«ã‚ˆã‚Šç›´æ¥çš„ãƒ»é–“æ¥çš„ãƒ»ä»˜éšçš„ãƒ»ç‰¹åˆ¥ãƒ»çµæœçš„ãƒ»æ‡²ç½°çš„æå®³ãŒç”Ÿã˜ãŸå ´åˆã§ã‚‚ã€é©ç”¨æ³•ã§è¨±å®¹ã•ã‚Œã‚‹æœ€å¤§é™ã®ç¯„å›²ã§ã€ä½œæˆè€…ãŠã‚ˆã³æ±åŒ—å¤§å­¦ã¯è²¬ä»»ã‚’è² ã„ã¾ã›ã‚“ã€‚</li>
            <li>æœ¬ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®å†…å®¹ã¯ã€äºˆå‘Šãªãå¤‰æ›´ãƒ»æ›´æ–°ãƒ»æä¾›åœæ­¢ã•ã‚Œã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚</li>
            <li>æœ¬ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®è‘—ä½œæ¨©ãƒ»ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã¯æ˜è¨˜ã•ã‚ŒãŸæ¡ä»¶(ä¾‹: CC BY 4.0)ã«å¾“ã„ã¾ã™ã€‚å½“è©²ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã¯é€šå¸¸ã€ç„¡ä¿è¨¼æ¡é …ã‚’å«ã¿ã¾ã™ã€‚</li>
        </ul>
    </section>

<footer>
        <p><strong>ä½œæˆè€…</strong>: AI Terakoya Content Team</p>
        <p><strong>ãƒãƒ¼ã‚¸ãƒ§ãƒ³</strong>: 1.0 | <strong>ä½œæˆæ—¥</strong>: 2025-10-17</p>
        <p><strong>ãƒ©ã‚¤ã‚»ãƒ³ã‚¹</strong>: Creative Commons BY 4.0</p>
        <p>Â© 2025 AI Terakoya. All rights reserved.</p>
    </footer>
</body>
</html>
