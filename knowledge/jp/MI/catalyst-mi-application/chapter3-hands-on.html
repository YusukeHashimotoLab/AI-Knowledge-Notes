<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>触媒MI実装ハンズオン - AI Terakoya</title>

    <style>
        :root {
            --color-primary: #2c3e50;
            --color-primary-dark: #1a252f;
            --color-accent: #7b2cbf;
            --color-accent-light: #9d4edd;
            --color-text: #2d3748;
            --color-text-light: #4a5568;
            --color-bg: #ffffff;
            --color-bg-alt: #f7fafc;
            --color-border: #e2e8f0;
            --color-code-bg: #f8f9fa;
            --color-link: #3182ce;
            --color-link-hover: #2c5aa0;

            --spacing-xs: 0.5rem;
            --spacing-sm: 1rem;
            --spacing-md: 1.5rem;
            --spacing-lg: 2rem;
            --spacing-xl: 3rem;

            --font-body: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            --font-mono: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;

            --border-radius: 8px;
            --box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-body);
            line-height: 1.7;
            color: var(--color-text);
            background-color: var(--color-bg);
            font-size: 16px;
        }

        header {
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            color: white;
            padding: var(--spacing-xl) var(--spacing-md);
            margin-bottom: var(--spacing-xl);
            box-shadow: var(--box-shadow);
        }

        .header-content {
            max-width: 900px;
            margin: 0 auto;
        }

        h1 {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: var(--spacing-sm);
            line-height: 1.2;
        }

        .subtitle {
            font-size: 1.1rem;
            opacity: 0.95;
            font-weight: 400;
            margin-bottom: var(--spacing-md);
        }

        .meta {
            display: flex;
            flex-wrap: wrap;
            gap: var(--spacing-md);
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .meta-item {
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 0 var(--spacing-md) var(--spacing-xl);
        }

        h2 {
            font-size: 1.75rem;
            color: var(--color-primary);
            margin-top: var(--spacing-xl);
            margin-bottom: var(--spacing-md);
            padding-bottom: var(--spacing-xs);
            border-bottom: 3px solid var(--color-accent);
        }

        h3 {
            font-size: 1.4rem;
            color: var(--color-primary);
            margin-top: var(--spacing-lg);
            margin-bottom: var(--spacing-sm);
        }

        h4 {
            font-size: 1.1rem;
            color: var(--color-primary-dark);
            margin-top: var(--spacing-md);
            margin-bottom: var(--spacing-sm);
        }

        p {
            margin-bottom: var(--spacing-md);
            color: var(--color-text);
        }

        a {
            color: var(--color-link);
            text-decoration: none;
            transition: color 0.2s;
        }

        a:hover {
            color: var(--color-link-hover);
            text-decoration: underline;
        }

        ul, ol {
            margin-left: var(--spacing-lg);
            margin-bottom: var(--spacing-md);
        }

        li {
            margin-bottom: var(--spacing-xs);
            color: var(--color-text);
        }

        pre {
            background-color: var(--color-code-bg);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            overflow-x: auto;
            margin-bottom: var(--spacing-md);
            font-family: var(--font-mono);
            font-size: 0.9rem;
            line-height: 1.5;
        }

        code {
            font-family: var(--font-mono);
            font-size: 0.9em;
            background-color: var(--color-code-bg);
            padding: 0.2em 0.4em;
            border-radius: 3px;
        }

        pre code {
            background-color: transparent;
            padding: 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: var(--spacing-md);
            font-size: 0.95rem;
        }

        th, td {
            border: 1px solid var(--color-border);
            padding: var(--spacing-sm);
            text-align: left;
        }

        th {
            background-color: var(--color-bg-alt);
            font-weight: 600;
            color: var(--color-primary);
        }

        blockquote {
            border-left: 4px solid var(--color-accent);
            padding-left: var(--spacing-md);
            margin: var(--spacing-md) 0;
            color: var(--color-text-light);
            font-style: italic;
            background-color: var(--color-bg-alt);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        .mermaid {
            text-align: center;
            margin: var(--spacing-lg) 0;
            background-color: var(--color-bg-alt);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        details {
            background-color: var(--color-bg-alt);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            margin-bottom: var(--spacing-md);
        }

        summary {
            cursor: pointer;
            font-weight: 600;
            color: var(--color-primary);
            user-select: none;
            padding: var(--spacing-xs);
            margin: calc(-1 * var(--spacing-md));
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        summary:hover {
            background-color: rgba(123, 44, 191, 0.1);
        }

        details[open] summary {
            margin-bottom: var(--spacing-md);
            border-bottom: 1px solid var(--color-border);
        }

        .navigation {
            display: flex;
            justify-content: space-between;
            gap: var(--spacing-md);
            margin: var(--spacing-xl) 0;
            padding-top: var(--spacing-lg);
            border-top: 2px solid var(--color-border);
        }

        .nav-button {
            flex: 1;
            padding: var(--spacing-md);
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            color: white;
            border-radius: var(--border-radius);
            text-align: center;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: var(--box-shadow);
        }

        .nav-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            text-decoration: none;
        }

        footer {
            margin-top: var(--spacing-xl);
            padding: var(--spacing-lg) var(--spacing-md);
            background-color: var(--color-bg-alt);
            border-top: 1px solid var(--color-border);
            text-align: center;
            font-size: 0.9rem;
            color: var(--color-text-light);
        }

        @media (max-width: 768px) {
            h1 { font-size: 1.5rem; }
            h2 { font-size: 1.4rem; }
            h3 { font-size: 1.2rem; }
            .meta { font-size: 0.85rem; }
            .navigation { flex-direction: column; }
            table { font-size: 0.85rem; }
            th, td { padding: var(--spacing-xs); }
        }
    </style>

    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ startOnLoad: true, theme: 'default' });
    </script>

    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\(', '\)']],
                displayMath: [['$$', '$$'], ['\[', '\]']],
                processEscapes: true
            }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" async></script>
</head>
<body>
    <header>
        <div class="header-content">
            <h1>触媒MI実装ハンズオン</h1>
            <p class="subtitle">ASEとPythonで学ぶ実践的触媒設計</p>
            <div class="meta">
                <span class="meta-item">📖 65-75分</span>
                <span class="meta-item">📊 中級</span>
                <span class="meta-item">💻 30個</span>
                <span class="meta-item">📝 5問</span>
            </div>
        </div>
    </header>

    <main class="container">
<h1>第3章：触媒MI実装ハンズオン</h1>
<p><strong>学習目標:</strong>
- ASEを使った触媒構造の操作と計算
- 触媒活性予測モデルの構築と評価
- ベイズ最適化による触媒組成探索
- DFT計算との統合ワークフロー</p>
<p><strong>前提知識:</strong>
- Python基礎（NumPy, Pandas, Matplotlib）
- 機械学習基礎（scikit-learn）
- 第1章・第2章の内容理解</p>
<p><strong>実行環境:</strong></p>
<pre><code class="language-bash">pip install ase numpy pandas scikit-learn scikit-optimize matplotlib seaborn
</code></pre>
<hr />
<h2>3.1 ASE（Atomic Simulation Environment）基礎</h2>
<h3>例1: ASEインストールと基本操作</h3>
<pre><code class="language-python">from ase import Atoms
from ase.visualize import view
import numpy as np

# 金属表面の作成（Pt(111)表面）
from ase.build import fcc111
slab = fcc111('Pt', size=(4, 4, 3), vacuum=10.0)

print(f&quot;原子数: {len(slab)}&quot;)
print(f&quot;セルサイズ: {slab.get_cell()}&quot;)
print(f&quot;化学式: {slab.get_chemical_formula()}&quot;)

# 原子座標の確認
positions = slab.get_positions()
print(f&quot;最上層Z座標: {positions[:, 2].max():.3f} Å&quot;)
</code></pre>
<p><strong>出力:</strong></p>
<pre><code>原子数: 48
セルサイズ: Cell([[11.122, 0.0, 0.0], [-5.561, 9.632, 0.0], [0.0, 0.0, 27.713]])
化学式: Pt48
最上層Z座標: 7.848 Å
</code></pre>
<h3>例2: 吸着構造の作成</h3>
<pre><code class="language-python">from ase.build import fcc111, add_adsorbate
from ase import Atoms

# Pt(111)表面にCOを吸着
slab = fcc111('Pt', size=(3, 3, 3), vacuum=10.0)
co = Atoms('CO', positions=[(0, 0, 0), (0, 0, 1.15)])

# Top siteに吸着
add_adsorbate(slab, co, height=2.0, position='ontop')

print(f&quot;吸着後の化学式: {slab.get_chemical_formula()}&quot;)
print(f&quot;総原子数: {len(slab)}&quot;)

# CO分子の位置確認
co_indices = [i for i, sym in enumerate(slab.get_chemical_symbols())
              if sym in ['C', 'O']]
print(f&quot;CO分子のindex: {co_indices}&quot;)
</code></pre>
<h3>例3: 構造の最適化（計算機化学）</h3>
<pre><code class="language-python">from ase.build import fcc111, add_adsorbate
from ase.calculators.emt import EMT  # 経験的ポテンシャル
from ase.optimize import BFGS

# Pt表面にH原子を吸着
slab = fcc111('Pt', size=(3, 3, 3), vacuum=10.0)
from ase import Atoms
h_atom = Atoms('H')
add_adsorbate(slab, h_atom, height=1.5, position='fcc')

# 計算機の設定（EMT: 高速だが精度低い）
slab.calc = EMT()

# 構造最適化
opt = BFGS(slab, trajectory='opt.traj')
opt.run(fmax=0.05)  # 力が0.05 eV/Å以下まで最適化

# 結果
final_energy = slab.get_potential_energy()
print(f&quot;最適化後エネルギー: {final_energy:.3f} eV&quot;)
</code></pre>
<h3>例4: 吸着エネルギー計算</h3>
<pre><code class="language-python">from ase.build import fcc111, add_adsorbate
from ase.calculators.emt import EMT
from ase.optimize import BFGS
from ase import Atoms

def calculate_adsorption_energy(metal='Pt', adsorbate='H'):
    &quot;&quot;&quot;吸着エネルギーを計算&quot;&quot;&quot;
    # 清浄表面
    slab_clean = fcc111(metal, size=(3, 3, 3), vacuum=10.0)
    slab_clean.calc = EMT()
    E_slab = slab_clean.get_potential_energy()

    # 吸着系
    slab_ads = fcc111(metal, size=(3, 3, 3), vacuum=10.0)
    atom = Atoms(adsorbate)
    add_adsorbate(slab_ads, atom, height=1.5, position='fcc')
    slab_ads.calc = EMT()
    opt = BFGS(slab_ads, logfile=None)
    opt.run(fmax=0.05)
    E_slab_ads = slab_ads.get_potential_energy()

    # 気相分子
    molecule = Atoms(adsorbate)
    molecule.center(vacuum=10.0)
    molecule.calc = EMT()
    E_mol = molecule.get_potential_energy()

    # 吸着エネルギー
    E_ads = E_slab_ads - E_slab - E_mol
    return E_ads

# 複数金属での比較
metals = ['Pt', 'Pd', 'Ni', 'Cu']
for metal in metals:
    E_ads = calculate_adsorption_energy(metal, 'H')
    print(f&quot;{metal}表面へのH吸着エネルギー: {E_ads:.3f} eV&quot;)
</code></pre>
<p><strong>出力例:</strong></p>
<pre><code>Pt表面へのH吸着エネルギー: -0.534 eV
Pd表面へのH吸着エネルギー: -0.621 eV
Ni表面へのH吸着エネルギー: -0.482 eV
Cu表面へのH吸着エネルギー: -0.213 eV
</code></pre>
<h3>例5: d-band中心の計算</h3>
<pre><code class="language-python">import numpy as np
from ase.build import bulk

def calculate_d_band_center(metal, k_points=(8, 8, 8)):
    &quot;&quot;&quot;d-band中心の簡易計算（実際はDFTが必要）&quot;&quot;&quot;
    # 実験値ベースの近似
    d_band_centers = {
        'Pt': -2.25,  # eV (フェルミ準位基準)
        'Pd': -1.83,
        'Ni': -1.29,
        'Cu': -2.67,
        'Au': -3.56,
        'Ag': -4.31
    }
    return d_band_centers.get(metal, None)

# 複数金属のd-band中心
metals = ['Cu', 'Ni', 'Pd', 'Pt', 'Au']
for metal in metals:
    eps_d = calculate_d_band_center(metal)
    print(f&quot;{metal}: εd = {eps_d:.2f} eV&quot;)
</code></pre>
<h3>例6: 合金表面の作成</h3>
<pre><code class="language-python">from ase.build import fcc111
import numpy as np

def create_alloy_surface(metal1='Pt', metal2='Ni', ratio=0.5, size=(4, 4, 3)):
    &quot;&quot;&quot;合金表面の作成&quot;&quot;&quot;
    slab = fcc111(metal1, size=size, vacuum=10.0)

    # ランダムに金属を置換
    n_atoms = len(slab)
    n_metal2 = int(n_atoms * ratio)
    indices = np.random.choice(n_atoms, n_metal2, replace=False)

    symbols = slab.get_chemical_symbols()
    for idx in indices:
        symbols[idx] = metal2
    slab.set_chemical_symbols(symbols)

    return slab

# PtNi合金表面の作成
alloy = create_alloy_surface('Pt', 'Ni', ratio=0.3, size=(5, 5, 3))
print(f&quot;組成: {alloy.get_chemical_formula()}&quot;)

# 組成比の確認
symbols = alloy.get_chemical_symbols()
pt_count = symbols.count('Pt')
ni_count = symbols.count('Ni')
print(f&quot;Pt: {pt_count}原子 ({pt_count/(pt_count+ni_count)*100:.1f}%)&quot;)
print(f&quot;Ni: {ni_count}原子 ({ni_count/(pt_count+ni_count)*100:.1f}%)&quot;)
</code></pre>
<h3>例7: 配位数の計算</h3>
<pre><code class="language-python">from ase.build import fcc111
from ase.neighborlist import NeighborList
import numpy as np

def calculate_coordination_numbers(atoms, cutoff=3.0):
    &quot;&quot;&quot;各原子の配位数を計算&quot;&quot;&quot;
    nl = NeighborList([cutoff/2]*len(atoms), self_interaction=False, bothways=True)
    nl.update(atoms)

    coord_numbers = []
    for i in range(len(atoms)):
        indices, offsets = nl.get_neighbors(i)
        coord_numbers.append(len(indices))

    return np.array(coord_numbers)

# Pt(111)表面の配位数分布
slab = fcc111('Pt', size=(4, 4, 3), vacuum=10.0)
coord_nums = calculate_coordination_numbers(slab, cutoff=3.0)

print(f&quot;配位数の分布:&quot;)
unique, counts = np.unique(coord_nums, return_counts=True)
for cn, count in zip(unique, counts):
    print(f&quot;  CN={cn}: {count}原子&quot;)

# 表面原子（配位数が低い原子）
surface_indices = np.where(coord_nums &lt; 9)[0]
print(f&quot;表面原子数: {len(surface_indices)}&quot;)
</code></pre>
<hr />
<h2>3.2 触媒活性予測モデルの構築</h2>
<h3>例8: 記述子データセットの作成</h3>
<pre><code class="language-python">import pandas as pd
import numpy as np

# 金属触媒の記述子データ
data = {
    'metal': ['Pt', 'Pd', 'Ni', 'Cu', 'Au', 'Ag', 'Rh', 'Ir', 'Fe', 'Co'],
    'd_band_center': [-2.25, -1.83, -1.29, -2.67, -3.56, -4.31, -1.73, -2.12, -1.34, -1.41],  # eV
    'work_function': [5.65, 5.12, 5.15, 4.65, 5.1, 4.26, 4.98, 5.27, 4.5, 5.0],  # eV
    'surface_energy': [2.48, 2.00, 2.38, 1.79, 1.50, 1.25, 2.66, 3.05, 2.90, 2.52],  # J/m²
    'lattice_constant': [3.92, 3.89, 3.52, 3.61, 4.08, 4.09, 3.80, 3.84, 2.87, 3.54],  # Å
    'H_ads_energy': [-0.53, -0.62, -0.48, -0.21, -0.15, 0.12, -0.68, -0.71, -0.87, -0.74],  # eV
    'HER_activity': [8.2, 7.5, 6.8, 4.2, 3.8, 2.1, 7.9, 8.5, 5.3, 6.1]  # log10(i0) (A/cm²)
}

df = pd.DataFrame(data)
print(df.head())
print(f&quot;\nデータセット形状: {df.shape}&quot;)
print(f&quot;記述子: {df.columns.tolist()[1:-1]}&quot;)
</code></pre>
<h3>例9: データの前処理と分割</h3>
<pre><code class="language-python">from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler

# 特徴量とターゲット
X = df[['d_band_center', 'work_function', 'surface_energy',
        'lattice_constant', 'H_ads_energy']].values
y = df['HER_activity'].values

# 訓練データとテストデータに分割
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.3, random_state=42
)

# 標準化
scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)

print(f&quot;訓練データ: {X_train.shape}&quot;)
print(f&quot;テストデータ: {X_test.shape}&quot;)
print(f&quot;\nスケーリング前: mean={X_train.mean(axis=0)}, std={X_train.std(axis=0)}&quot;)
print(f&quot;スケーリング後: mean={X_train_scaled.mean(axis=0)}, std={X_train_scaled.std(axis=0)}&quot;)
</code></pre>
<h3>例10: 線形回帰モデル</h3>
<pre><code class="language-python">from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_absolute_error, r2_score
import matplotlib.pyplot as plt

# モデル訓練
model_lr = LinearRegression()
model_lr.fit(X_train_scaled, y_train)

# 予測
y_pred_train = model_lr.predict(X_train_scaled)
y_pred_test = model_lr.predict(X_test_scaled)

# 評価
mae_train = mean_absolute_error(y_train, y_pred_train)
mae_test = mean_absolute_error(y_test, y_pred_test)
r2_train = r2_score(y_train, y_pred_train)
r2_test = r2_score(y_test, y_pred_test)

print(f&quot;訓練データ: MAE={mae_train:.3f}, R²={r2_train:.3f}&quot;)
print(f&quot;テストデータ: MAE={mae_test:.3f}, R²={r2_test:.3f}&quot;)

# 係数の確認
feature_names = ['d-band center', 'work function', 'surface energy',
                 'lattice constant', 'H_ads_energy']
for name, coef in zip(feature_names, model_lr.coef_):
    print(f&quot;{name}: {coef:.3f}&quot;)
</code></pre>
<h3>例11: ランダムフォレスト回帰</h3>
<pre><code class="language-python">from sklearn.ensemble import RandomForestRegressor

# モデル訓練
model_rf = RandomForestRegressor(n_estimators=100, max_depth=5, random_state=42)
model_rf.fit(X_train_scaled, y_train)

# 予測と評価
y_pred_test_rf = model_rf.predict(X_test_scaled)
mae_rf = mean_absolute_error(y_test, y_pred_test_rf)
r2_rf = r2_score(y_test, y_pred_test_rf)

print(f&quot;Random Forest: MAE={mae_rf:.3f}, R²={r2_rf:.3f}&quot;)

# 特徴量重要度
importances = model_rf.feature_importances_
for name, imp in zip(feature_names, importances):
    print(f&quot;{name}: {imp:.3f}&quot;)
</code></pre>
<h3>例12: クロスバリデーション</h3>
<pre><code class="language-python">from sklearn.model_selection import cross_val_score
from sklearn.linear_model import Ridge

# Ridgeモデルでクロスバリデーション
model_ridge = Ridge(alpha=1.0)
scores = cross_val_score(model_ridge, X_train_scaled, y_train,
                        cv=5, scoring='neg_mean_absolute_error')

print(f&quot;5-fold CV MAE: {-scores.mean():.3f} ± {scores.std():.3f}&quot;)
print(f&quot;各fold: {-scores}&quot;)

# ハイパーパラメータ調整
alphas = [0.01, 0.1, 1.0, 10.0, 100.0]
for alpha in alphas:
    model = Ridge(alpha=alpha)
    scores = cross_val_score(model, X_train_scaled, y_train,
                            cv=5, scoring='neg_mean_absolute_error')
    print(f&quot;alpha={alpha:6.2f}: MAE={-scores.mean():.3f}&quot;)
</code></pre>
<h3>例13: Gaussian Process回帰</h3>
<pre><code class="language-python">from sklearn.gaussian_process import GaussianProcessRegressor
from sklearn.gaussian_process.kernels import RBF, ConstantKernel

# カーネル定義
kernel = ConstantKernel(1.0) * RBF(length_scale=1.0)

# GPRモデル
model_gpr = GaussianProcessRegressor(kernel=kernel, n_restarts_optimizer=10,
                                     random_state=42)
model_gpr.fit(X_train_scaled, y_train)

# 予測（不確実性付き）
y_pred_gpr, y_std = model_gpr.predict(X_test_scaled, return_std=True)

mae_gpr = mean_absolute_error(y_test, y_pred_gpr)
r2_gpr = r2_score(y_test, y_pred_gpr)

print(f&quot;GPR: MAE={mae_gpr:.3f}, R²={r2_gpr:.3f}&quot;)
print(f&quot;\n予測と不確実性:&quot;)
for true, pred, std in zip(y_test, y_pred_gpr, y_std):
    print(f&quot;True: {true:.2f}, Pred: {pred:.2f} ± {std:.2f}&quot;)
</code></pre>
<h3>例14: 火山型プロットの作成</h3>
<pre><code class="language-python">import matplotlib.pyplot as plt
import numpy as np

# H吸着エネルギーとHER活性の関係
fig, ax = plt.subplots(figsize=(8, 6))

ax.scatter(df['H_ads_energy'], df['HER_activity'], s=100, alpha=0.7)

# 金属名を表示
for i, txt in enumerate(df['metal']):
    ax.annotate(txt, (df['H_ads_energy'].iloc[i], df['HER_activity'].iloc[i]),
                xytext=(5, 5), textcoords='offset points')

# 火山型フィット（2次多項式）
x_fit = np.linspace(df['H_ads_energy'].min(), df['H_ads_energy'].max(), 100)
coeffs = np.polyfit(df['H_ads_energy'], df['HER_activity'], 2)
y_fit = np.polyval(coeffs, x_fit)
ax.plot(x_fit, y_fit, 'r--', label='Volcano fit')

ax.set_xlabel('H adsorption energy (eV)', fontsize=12)
ax.set_ylabel('log₁₀(HER activity)', fontsize=12)
ax.set_title('Volcano Plot for HER Activity', fontsize=14)
ax.legend()
ax.grid(alpha=0.3)

print(f&quot;最適H吸着エネルギー: {-coeffs[1]/(2*coeffs[0]):.3f} eV&quot;)
</code></pre>
<h3>例15: 予測モデルの保存と読み込み</h3>
<pre><code class="language-python">import pickle

# モデルの保存
with open('catalyst_model.pkl', 'wb') as f:
    pickle.dump({'model': model_rf, 'scaler': scaler}, f)

print(&quot;モデルを保存しました: catalyst_model.pkl&quot;)

# モデルの読み込み
with open('catalyst_model.pkl', 'rb') as f:
    loaded = pickle.load(f)
    loaded_model = loaded['model']
    loaded_scaler = loaded['scaler']

# 新しいデータで予測
new_catalyst = np.array([[-2.0, 5.0, 2.0, 3.8, -0.4]])  # 仮想触媒
new_catalyst_scaled = loaded_scaler.transform(new_catalyst)
prediction = loaded_model.predict(new_catalyst_scaled)

print(f&quot;新触媒の予測HER活性: {prediction[0]:.2f}&quot;)
</code></pre>
<hr />
<h2>3.3 ベイズ最適化による触媒組成探索</h2>
<h3>例16: ベイズ最適化の基本</h3>
<pre><code class="language-python">from skopt import gp_minimize
from skopt.space import Real
import numpy as np

# 目的関数（触媒活性シミュレーション）
def catalyst_performance(x):
    &quot;&quot;&quot;
    x[0]: Pt比率 (0-1)
    x[1]: 焼成温度 (300-800 K)
    &quot;&quot;&quot;
    pt_ratio, temp = x
    # 仮想的な活性関数（実際は実験 or DFT計算）
    activity = -((pt_ratio - 0.6)**2 * 10 + (temp - 600)**2 / 10000)
    noise = np.random.normal(0, 0.1)  # 実験ノイズ
    return -activity + noise  # 最小化問題に変換

# 探索空間
space = [
    Real(0.0, 1.0, name='pt_ratio'),
    Real(300, 800, name='temperature')
]

# ベイズ最適化実行
result = gp_minimize(
    catalyst_performance,
    space,
    n_calls=20,  # 実験回数
    random_state=42,
    verbose=True
)

print(f&quot;\n最適パラメータ:&quot;)
print(f&quot;  Pt比率: {result.x[0]:.3f}&quot;)
print(f&quot;  焼成温度: {result.x[1]:.1f} K&quot;)
print(f&quot;  最大活性: {-result.fun:.3f}&quot;)
</code></pre>
<h3>例17: 獲得関数の比較</h3>
<pre><code class="language-python">from skopt import gp_minimize
from skopt.space import Real

# 3つの獲得関数で比較
acq_funcs = ['EI', 'PI', 'LCB']
results = {}

for acq in acq_funcs:
    result = gp_minimize(
        catalyst_performance,
        space,
        n_calls=15,
        acq_func=acq,
        random_state=42,
        verbose=False
    )
    results[acq] = result
    print(f&quot;{acq}: 最適値 = {-result.fun:.3f}, &quot;
          f&quot;Pt比率 = {result.x[0]:.3f}, 温度 = {result.x[1]:.1f}K&quot;)
</code></pre>
<h3>例18: 多目的最適化（活性 vs コスト）</h3>
<pre><code class="language-python">from skopt import gp_minimize
import numpy as np

def multi_objective(x):
    &quot;&quot;&quot;活性とコストのトレードオフ&quot;&quot;&quot;
    pt_ratio = x[0]
    temp = x[1]

    # 活性（高い方が良い）
    activity = -((pt_ratio - 0.6)**2 * 10 + (temp - 600)**2 / 10000)

    # コスト（Pt使用量に依存、低い方が良い）
    cost = pt_ratio * 100 + (temp - 300) / 10

    # 重み付き和（スカラー化）
    weight_activity = 0.7
    weight_cost = 0.3
    return -(weight_activity * activity - weight_cost * cost)

result_mo = gp_minimize(multi_objective, space, n_calls=25, random_state=42)

print(f&quot;最適パラメータ（多目的）:&quot;)
print(f&quot;  Pt比率: {result_mo.x[0]:.3f}&quot;)
print(f&quot;  温度: {result_mo.x[1]:.1f} K&quot;)
</code></pre>
<h3>例19: 実験履歴の可視化</h3>
<pre><code class="language-python">from skopt.plots import plot_convergence, plot_evaluations
import matplotlib.pyplot as plt

# 収束プロット
fig, axes = plt.subplots(1, 2, figsize=(14, 5))

plot_convergence(result, ax=axes[0])
axes[0].set_title('Convergence Plot')
axes[0].set_ylabel('Objective Value')

# 評価プロット
plot_evaluations(result, dimensions=['pt_ratio', 'temperature'], ax=axes[1])
axes[1].set_title('Parameter Evaluation')

plt.tight_layout()

# 実験履歴の出力
print(&quot;\n実験履歴:&quot;)
for i, (params, value) in enumerate(zip(result.x_iters, result.func_vals)):
    print(f&quot;Exp {i+1}: Pt={params[0]:.3f}, T={params[1]:.1f}K, &quot;
          f&quot;Activity={-value:.3f}&quot;)
</code></pre>
<h3>例20: 制約付き最適化</h3>
<pre><code class="language-python">from skopt import gp_minimize
import numpy as np

def constrained_objective(x):
    &quot;&quot;&quot;制約条件付き触媒最適化&quot;&quot;&quot;
    pt_ratio = x[0]
    ni_ratio = x[1]

    # 制約: Pt + Ni ≤ 0.8（残りは安価な担体）
    if pt_ratio + ni_ratio &gt; 0.8:
        return 1e6  # ペナルティ

    # 活性予測
    activity = -(pt_ratio * 8 + ni_ratio * 5 -
                (pt_ratio - 0.5)**2 * 10 - (ni_ratio - 0.2)**2 * 10)
    return -activity

space_alloy = [
    Real(0.0, 0.8, name='pt_ratio'),
    Real(0.0, 0.8, name='ni_ratio')
]

result_const = gp_minimize(constrained_objective, space_alloy,
                          n_calls=30, random_state=42)

print(f&quot;最適組成:&quot;)
print(f&quot;  Pt: {result_const.x[0]:.3f}&quot;)
print(f&quot;  Ni: {result_const.x[1]:.3f}&quot;)
print(f&quot;  その他: {1 - result_const.x[0] - result_const.x[1]:.3f}&quot;)
print(f&quot;  予測活性: {-result_const.fun:.3f}&quot;)
</code></pre>
<h3>例21: バッチベイズ最適化</h3>
<pre><code class="language-python">from skopt import gp_minimize
from skopt.optimizer import Optimizer

# バッチ実験をシミュレート
optimizer = Optimizer(space, acq_func='EI', random_state=42)

# 初期サンプル
n_initial = 5
X_init = [[np.random.uniform(0, 1), np.random.uniform(300, 800)]
          for _ in range(n_initial)]
y_init = [catalyst_performance(x) for x in X_init]

optimizer.tell(X_init, y_init)

# バッチ実験（並列に3実験）
batch_size = 3
n_batches = 5

for batch in range(n_batches):
    # 次の実験候補をバッチ生成
    X_next_batch = []
    for _ in range(batch_size):
        x_next = optimizer.ask()
        X_next_batch.append(x_next)

    # 実験実行（並列）
    y_next_batch = [catalyst_performance(x) for x in X_next_batch]

    # 結果を更新
    optimizer.tell(X_next_batch, y_next_batch)

    print(f&quot;Batch {batch+1}: Best so far = {-min(optimizer.yi):.3f}&quot;)

print(f&quot;\n最終最適値: {-min(optimizer.yi):.3f}&quot;)
print(f&quot;総実験数: {len(optimizer.Xi)}&quot;)
</code></pre>
<h3>例22: 転移学習ベイズ最適化</h3>
<pre><code class="language-python">from skopt import gp_minimize
from sklearn.gaussian_process.kernels import RBF, WhiteKernel
import numpy as np

# 類似触媒系の過去データ（転移学習ソース）
X_source = np.array([[0.3, 400], [0.5, 500], [0.7, 600], [0.9, 700]])
y_source = np.array([-2.5, -4.0, -4.8, -3.5])  # 活性データ

# 新触媒系の最適化（ターゲット）
def target_catalyst(x):
    &quot;&quot;&quot;新しい触媒系（類似だが異なる）&quot;&quot;&quot;
    pt_ratio, temp = x
    activity = -((pt_ratio - 0.55)**2 * 12 + (temp - 550)**2 / 8000)
    return -activity + np.random.normal(0, 0.1)

# GPRモデルを過去データで事前学習
from sklearn.gaussian_process import GaussianProcessRegressor

kernel = RBF(length_scale=1.0) + WhiteKernel(noise_level=0.1)
gpr_prior = GaussianProcessRegressor(kernel=kernel)
gpr_prior.fit(X_source, y_source)

# ベイズ最適化（事前知識を活用）
result_tl = gp_minimize(
    target_catalyst,
    space,
    n_calls=10,  # 少ない実験数
    random_state=42
)

print(f&quot;転移学習あり: 最適値 = {-result_tl.fun:.3f} (10実験)&quot;)

# 比較: 転移学習なし
result_no_tl = gp_minimize(target_catalyst, space, n_calls=10, random_state=42)
print(f&quot;転移学習なし: 最適値 = {-result_no_tl.fun:.3f} (10実験)&quot;)
</code></pre>
<hr />
<h2>3.4 DFT計算との統合</h2>
<h3>例23: ASEでのDFT計算設定</h3>
<pre><code class="language-python">from ase.build import fcc111, add_adsorbate
from ase import Atoms

# 実際のDFT計算はGPAW, VASP, Quantum ESPRESSOなどが必要
# ここではセットアップ例を示す

# Pt(111)表面にCO吸着
slab = fcc111('Pt', size=(3, 3, 4), vacuum=15.0)
co = Atoms('CO', positions=[(0, 0, 0), (0, 0, 1.15)])
add_adsorbate(slab, co, height=2.0, position='ontop')

# DFT計算器の設定（GPAWの場合）
# from gpaw import GPAW, PW
# calc = GPAW(
#     mode=PW(500),  # Plane wave cutoff
#     xc='PBE',
#     kpts=(4, 4, 1),
#     txt='co_pt.txt'
# )
# slab.calc = calc

print(&quot;DFT計算設定完了（実行にはGPAWなどが必要）&quot;)
print(f&quot;システムサイズ: {len(slab)}原子&quot;)
print(f&quot;セル: {slab.get_cell()}&quot;)
</code></pre>
<h3>例24: 吸着エネルギーの高精度計算</h3>
<pre><code class="language-python">from ase.build import fcc111, add_adsorbate
from ase.calculators.emt import EMT  # DFTの代わりにEMT
from ase.optimize import BFGS
import numpy as np

def dft_adsorption_energy(metal, adsorbate, site='fcc'):
    &quot;&quot;&quot;DFT相当の吸着エネルギー計算&quot;&quot;&quot;
    # 清浄表面
    slab = fcc111(metal, size=(3, 3, 4), vacuum=10.0)
    slab.calc = EMT()
    E_slab = slab.get_potential_energy()

    # 吸着系
    slab_ads = slab.copy()
    if adsorbate == 'H':
        from ase import Atoms
        atom = Atoms('H')
        add_adsorbate(slab_ads, atom, height=1.5, position=site)

    slab_ads.calc = EMT()
    opt = BFGS(slab_ads, logfile=None)
    opt.run(fmax=0.01)  # 高精度最適化
    E_slab_ads = slab_ads.get_potential_energy()

    # 気相H2
    from ase import Atoms
    h2 = Atoms('H2', positions=[(0, 0, 0), (0, 0, 0.74)])
    h2.center(vacuum=10.0)
    h2.calc = EMT()
    E_h2 = h2.get_potential_energy()

    E_ads = E_slab_ads - E_slab - 0.5 * E_h2
    return E_ads

# 複数サイトでの吸着エネルギー
sites = ['fcc', 'hcp', 'ontop']
for site in sites:
    E_ads = dft_adsorption_energy('Pt', 'H', site)
    print(f&quot;Pt(111) {site}サイト H吸着: {E_ads:.3f} eV&quot;)
</code></pre>
<h3>例25: 反応経路解析（NEB法）</h3>
<pre><code class="language-python">from ase.build import fcc111
from ase.calculators.emt import EMT
from ase.neb import NEB
from ase.optimize import BFGS
import numpy as np

# 初期状態と最終状態（簡略化例）
def setup_reaction_path():
    &quot;&quot;&quot;H原子の表面拡散（fcc → hcp）&quot;&quot;&quot;
    # 初期状態: H at fcc site
    slab_initial = fcc111('Pt', size=(3, 3, 3), vacuum=10.0)
    from ase import Atoms
    from ase.build import add_adsorbate
    h_atom = Atoms('H')
    add_adsorbate(slab_initial, h_atom, height=1.5, position='fcc')
    slab_initial.calc = EMT()

    # 最終状態: H at hcp site
    slab_final = fcc111('Pt', size=(3, 3, 3), vacuum=10.0)
    h_atom = Atoms('H')
    add_adsorbate(slab_final, h_atom, height=1.5, position='hcp')
    slab_final.calc = EMT()

    return slab_initial, slab_final

initial, final = setup_reaction_path()

# NEB計算（簡略版）
print(&quot;NEB法による遷移状態探索&quot;)
print(f&quot;初期状態エネルギー: {initial.get_potential_energy():.3f} eV&quot;)
print(f&quot;最終状態エネルギー: {final.get_potential_energy():.3f} eV&quot;)
print(&quot;実際のNEB計算には複数のイメージと最適化が必要&quot;)
</code></pre>
<h3>例26: 電子状態解析</h3>
<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt

# DFT計算から得られるDOS（状態密度）のシミュレーション
def simulate_dos(metal):
    &quot;&quot;&quot;金属のDOSをシミュレート&quot;&quot;&quot;
    energies = np.linspace(-10, 5, 500)

    if metal == 'Pt':
        # d-band: -6 to -2 eV
        dos = np.exp(-((energies + 2.25)**2) / 2) * 3
        # sp-band
        dos += np.exp(-((energies - 0)**2) / 10) * 0.5
    elif metal == 'Cu':
        # d-band: -4 to -1 eV (deeper)
        dos = np.exp(-((energies + 2.67)**2) / 2) * 3
        dos += np.exp(-((energies - 0)**2) / 10) * 0.5

    return energies, dos

# プロット
fig, ax = plt.subplots(figsize=(10, 6))

for metal in ['Pt', 'Cu']:
    energies, dos = simulate_dos(metal)
    ax.plot(energies, dos, label=metal, linewidth=2)

ax.axvline(0, color='k', linestyle='--', label='Fermi level')
ax.set_xlabel('Energy (eV)', fontsize=12)
ax.set_ylabel('Density of States', fontsize=12)
ax.set_title('Electronic DOS of Metal Catalysts', fontsize=14)
ax.legend()
ax.grid(alpha=0.3)

print(&quot;DOSプロット作成完了&quot;)
</code></pre>
<h3>例27: DFT-ML連携ワークフロー</h3>
<pre><code class="language-python">from sklearn.gaussian_process import GaussianProcessRegressor
from sklearn.gaussian_process.kernels import RBF
import numpy as np

# ステップ1: 少数のDFT計算
def expensive_dft_calculation(composition):
    &quot;&quot;&quot;高コストDFT計算（シミュレーション）&quot;&quot;&quot;
    x = composition
    # 実際の吸着エネルギー計算
    energy = -2.0 + 3.0 * x - 2.0 * x**2 + np.random.normal(0, 0.05)
    return energy

# 初期DFT計算（5点）
X_dft = np.array([[0.2], [0.4], [0.6], [0.8], [1.0]])
y_dft = np.array([expensive_dft_calculation(x[0]) for x in X_dft])

# ステップ2: GPRサロゲートモデル
gpr = GaussianProcessRegressor(kernel=RBF(), n_restarts_optimizer=10)
gpr.fit(X_dft, y_dft)

# ステップ3: 多数点での予測（低コスト）
X_pred = np.linspace(0, 1, 100).reshape(-1, 1)
y_pred, y_std = gpr.predict(X_pred, return_std=True)

print(&quot;DFT-ML連携ワークフロー:&quot;)
print(f&quot;DFT計算数: {len(X_dft)}&quot;)
print(f&quot;ML予測数: {len(X_pred)}&quot;)
print(f&quot;最適組成（予測）: {X_pred[np.argmin(y_pred)][0]:.3f}&quot;)

# プロット
import matplotlib.pyplot as plt
fig, ax = plt.subplots(figsize=(10, 6))
ax.scatter(X_dft, y_dft, c='red', s=100, label='DFT calc', zorder=10)
ax.plot(X_pred, y_pred, 'b-', label='GPR mean')
ax.fill_between(X_pred.ravel(), y_pred - y_std, y_pred + y_std,
                alpha=0.3, label='±1 std')
ax.set_xlabel('Composition')
ax.set_ylabel('Adsorption Energy (eV)')
ax.legend()
</code></pre>
<hr />
<h2>3.5 反応速度論解析</h2>
<h3>例28: Arrhenius解析</h3>
<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit

# 実験データ（温度 vs 反応速度）
temperatures = np.array([300, 350, 400, 450, 500, 550])  # K
rate_constants = np.array([0.01, 0.05, 0.15, 0.35, 0.70, 1.20])  # s⁻¹

# Arrhenius式: k = A * exp(-Ea / (R*T))
def arrhenius(T, A, Ea):
    R = 8.314e-3  # kJ/(mol·K)
    return A * np.exp(-Ea / (R * T))

# フィッティング
popt, pcov = curve_fit(arrhenius, temperatures, rate_constants, p0=[1e10, 50])
A_fit, Ea_fit = popt

print(f&quot;頻度因子 A: {A_fit:.2e} s⁻¹&quot;)
print(f&quot;活性化エネルギー Ea: {Ea_fit:.2f} kJ/mol&quot;)

# Arrheniusプロット
fig, axes = plt.subplots(1, 2, figsize=(14, 5))

# 通常プロット
axes[0].scatter(temperatures, rate_constants, label='Experimental', s=100)
T_fit = np.linspace(280, 570, 100)
axes[0].plot(T_fit, arrhenius(T_fit, A_fit, Ea_fit), 'r--', label='Fit')
axes[0].set_xlabel('Temperature (K)')
axes[0].set_ylabel('Rate constant (s⁻¹)')
axes[0].legend()

# Arrheniusプロット（線形化）
axes[1].scatter(1000/temperatures, np.log(rate_constants), s=100)
axes[1].plot(1000/T_fit, np.log(arrhenius(T_fit, A_fit, Ea_fit)), 'r--')
axes[1].set_xlabel('1000/T (K⁻¹)')
axes[1].set_ylabel('ln(k)')
axes[1].set_title(f'Ea = {Ea_fit:.1f} kJ/mol')
</code></pre>
<h3>例29: 反応次数解析</h3>
<pre><code class="language-python">import numpy as np
from scipy.integrate import odeint
import matplotlib.pyplot as plt

# 反応速度式: -dC/dt = k * C^n
def reaction_rate(C, t, k, n):
    &quot;&quot;&quot;n次反応の速度式&quot;&quot;&quot;
    return -k * C**n

# パラメータ
k = 0.1  # 速度定数
C0 = 1.0  # 初期濃度
t = np.linspace(0, 50, 100)

# 異なる反応次数で計算
fig, ax = plt.subplots(figsize=(10, 6))

for n in [0, 1, 2]:
    C = odeint(reaction_rate, C0, t, args=(k, n))
    ax.plot(t, C, label=f'n={n} order', linewidth=2)

ax.set_xlabel('Time', fontsize=12)
ax.set_ylabel('Concentration', fontsize=12)
ax.set_title('Reaction Order Effects', fontsize=14)
ax.legend()
ax.grid(alpha=0.3)

# 半減期の計算
def half_life(k, n, C0=1.0):
    &quot;&quot;&quot;n次反応の半減期&quot;&quot;&quot;
    if n == 0:
        return C0 / (2 * k)
    elif n == 1:
        return np.log(2) / k
    elif n == 2:
        return 1 / (k * C0)

for n in [0, 1, 2]:
    t_half = half_life(k, n, C0)
    print(f&quot;{n}次反応の半減期: {t_half:.2f}&quot;)
</code></pre>
<h3>例30: マイクロキネティクスモデル</h3>
<pre><code class="language-python">import numpy as np
from scipy.integrate import odeint
import matplotlib.pyplot as plt

# CO酸化反応のマイクロキネティクスモデル
# CO(g) + O(g) -&gt; CO2(g) on Pt surface
def microkinetics(y, t, k1, k2, k3, k4):
    &quot;&quot;&quot;
    y: [θ_CO, θ_O, θ_free]  # 表面被覆率
    k1: CO吸着速度定数
    k2: O2解離吸着速度定数
    k3: CO酸化速度定数
    k4: CO2脱離速度定数
    &quot;&quot;&quot;
    theta_CO, theta_O, theta_free = y

    # 気相分圧（一定）
    P_CO = 0.1  # bar
    P_O2 = 0.2  # bar

    # 反応速度
    r1 = k1 * P_CO * theta_free  # CO吸着
    r2 = k2 * P_O2 * theta_free**2  # O2解離吸着
    r3 = k3 * theta_CO * theta_O  # CO + O -&gt; CO2
    r4 = k4 * theta_CO * theta_O  # CO2脱離（反応と同時）

    # 被覆率変化
    dtheta_CO_dt = r1 - r3
    dtheta_O_dt = 2 * r2 - r3
    dtheta_free_dt = -r1 - 2 * r2 + r3

    return [dtheta_CO_dt, dtheta_O_dt, dtheta_free_dt]

# 初期条件
y0 = [0.0, 0.0, 1.0]  # 清浄表面

# 速度定数（任意単位）
k1, k2, k3, k4 = 1.0, 0.5, 2.0, 2.0

# 時間発展
t = np.linspace(0, 10, 1000)
solution = odeint(microkinetics, y0, t, args=(k1, k2, k3, k4))

# プロット
fig, ax = plt.subplots(figsize=(10, 6))
ax.plot(t, solution[:, 0], label='θ_CO', linewidth=2)
ax.plot(t, solution[:, 1], label='θ_O', linewidth=2)
ax.plot(t, solution[:, 2], label='θ_free', linewidth=2)
ax.set_xlabel('Time', fontsize=12)
ax.set_ylabel('Surface Coverage', fontsize=12)
ax.set_title('Microkinetic Model: CO Oxidation on Pt', fontsize=14)
ax.legend()
ax.grid(alpha=0.3)

# 定常状態
theta_CO_ss = solution[-1, 0]
theta_O_ss = solution[-1, 1]
TOF = k3 * theta_CO_ss * theta_O_ss  # Turnover Frequency

print(f&quot;定常状態:&quot;)
print(f&quot;  θ_CO: {theta_CO_ss:.3f}&quot;)
print(f&quot;  θ_O: {theta_O_ss:.3f}&quot;)
print(f&quot;  TOF: {TOF:.3f} s⁻¹&quot;)
</code></pre>
<hr />
<h2>3.6 プロジェクトチャレンジ</h2>
<p><strong>課題: CO2還元触媒の最適化</strong></p>
<p>以下の手順で、CO2→CO変換触媒を最適化してください：</p>
<ol>
<li><strong>データ収集</strong>: 複数金属（Cu, Ag, Au, Pd, Pt）のCO2吸着エネルギーを計算</li>
<li><strong>記述子計算</strong>: d-band center、work functionなどを取得</li>
<li><strong>予測モデル構築</strong>: 記述子から活性を予測するGPRモデル</li>
<li><strong>ベイズ最適化</strong>: 合金組成を最適化（Cu-Ag二元系）</li>
<li><strong>検証</strong>: 最適組成でのDFT計算（EMT近似）</li>
</ol>
<p><strong>評価基準:</strong>
- CO生成選択性 &gt; 80%
- 過電圧 &lt; 0.5 V
- コスト（Ag使用量）最小化</p>
<p><strong>提出物:</strong>
- 最適組成（Cu:Ag比率）
- 予測活性とコストのトレードオフ分析
- Pythonコード全体</p>
<hr />
<h2>演習問題</h2>
<p><strong>問1:</strong> Pt-Ni合金触媒（Pt:Ni = 3:1）の(111)表面を作成し、配位数分布を計算せよ。</p>
<p><strong>問2:</strong> 第2章のSabatier原理に基づき、最適H吸着エネルギーを機械学習で予測するモデルを構築せよ（例8-14参照）。</p>
<p><strong>問3:</strong> ベイズ最適化で、焼成温度（400-900 K）と担持量（0-50 wt%）を同時最適化し、最大活性を達成せよ。</p>
<p><strong>問4:</strong> Arrheniusプロットから、あなたの実験データの活性化エネルギーを算出せよ。</p>
<p><strong>問5:</strong> マイクロキネティクスモデルで、CO/O2比を変化させたときの定常状態被覆率とTOFをシミュレートせよ。</p>
<hr />
<h2>参考文献</h2>
<ol>
<li><strong>ASE Documentation</strong>: https://wiki.fysik.dtu.dk/ase/</li>
<li><strong>scikit-optimize</strong>: https://scikit-optimize.github.io/</li>
<li>Nørskov, J. K. et al. "Origin of the Overpotential for Oxygen Reduction at a Fuel-Cell Cathode." <em>J. Phys. Chem. B</em> (2004).</li>
<li>Hammer, B. &amp; Nørskov, J. K. "Theoretical Surface Science and Catalysis." <em>Advances in Catalysis</em> (2000).</li>
</ol>
<hr />
<p><strong>次章</strong>: <a href="chapter4-case-studies.md">第4章：触媒MI実践ケーススタディ</a></p>
<p><strong>ライセンス</strong>: このコンテンツはCC BY 4.0ライセンスの下で提供されています。</p><div class="navigation">
    <a href="chapter2-methods.html" class="nav-button">← 第2章</a>
    <a href="index.html" class="nav-button">シリーズ目次</a>
    <a href="chapter4-case-studies.html" class="nav-button">第4章 →</a>
</div>
    </main>

    <footer>
        <p><strong>AI Terakoya マテリアルズ・インフォマティクス教育コンテンツ</strong></p>
        <p>監修: Dr. Yusuke Hashimoto（東北大学）</p>
        <p>© 2025 AI Terakoya. Licensed under CC BY 4.0</p>
    </footer>
</body>
</html>
