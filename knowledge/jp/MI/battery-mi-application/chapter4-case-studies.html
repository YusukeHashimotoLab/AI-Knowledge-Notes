<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>電池MI実践ケーススタディ - AI Terakoya</title>

    <style>
        :root {
            --color-primary: #2c3e50;
            --color-primary-dark: #1a252f;
            --color-accent: #7b2cbf;
            --color-accent-light: #9d4edd;
            --color-text: #2d3748;
            --color-text-light: #4a5568;
            --color-bg: #ffffff;
            --color-bg-alt: #f7fafc;
            --color-border: #e2e8f0;
            --color-code-bg: #f8f9fa;
            --color-link: #3182ce;
            --color-link-hover: #2c5aa0;

            --spacing-xs: 0.5rem;
            --spacing-sm: 1rem;
            --spacing-md: 1.5rem;
            --spacing-lg: 2rem;
            --spacing-xl: 3rem;

            --font-body: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            --font-mono: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;

            --border-radius: 8px;
            --box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-body);
            line-height: 1.7;
            color: var(--color-text);
            background-color: var(--color-bg);
            font-size: 16px;
        }

        header {
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            color: white;
            padding: var(--spacing-xl) var(--spacing-md);
            margin-bottom: var(--spacing-xl);
            box-shadow: var(--box-shadow);
        }

        .header-content {
            max-width: 900px;
            margin: 0 auto;
        }

        h1 {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: var(--spacing-sm);
            line-height: 1.2;
        }

        .subtitle {
            font-size: 1.1rem;
            opacity: 0.95;
            font-weight: 400;
            margin-bottom: var(--spacing-md);
        }

        .meta {
            display: flex;
            flex-wrap: wrap;
            gap: var(--spacing-md);
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .meta-item {
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 0 var(--spacing-md) var(--spacing-xl);
        }

        h2 {
            font-size: 1.75rem;
            color: var(--color-primary);
            margin-top: var(--spacing-xl);
            margin-bottom: var(--spacing-md);
            padding-bottom: var(--spacing-xs);
            border-bottom: 3px solid var(--color-accent);
        }

        h3 {
            font-size: 1.4rem;
            color: var(--color-primary);
            margin-top: var(--spacing-lg);
            margin-bottom: var(--spacing-sm);
        }

        h4 {
            font-size: 1.1rem;
            color: var(--color-primary-dark);
            margin-top: var(--spacing-md);
            margin-bottom: var(--spacing-sm);
        }

        p {
            margin-bottom: var(--spacing-md);
            color: var(--color-text);
        }

        a {
            color: var(--color-link);
            text-decoration: none;
            transition: color 0.2s;
        }

        a:hover {
            color: var(--color-link-hover);
            text-decoration: underline;
        }

        ul, ol {
            margin-left: var(--spacing-lg);
            margin-bottom: var(--spacing-md);
        }

        li {
            margin-bottom: var(--spacing-xs);
            color: var(--color-text);
        }

        pre {
            background-color: var(--color-code-bg);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            overflow-x: auto;
            margin-bottom: var(--spacing-md);
            font-family: var(--font-mono);
            font-size: 0.9rem;
            line-height: 1.5;
        }

        code {
            font-family: var(--font-mono);
            font-size: 0.9em;
            background-color: var(--color-code-bg);
            padding: 0.2em 0.4em;
            border-radius: 3px;
        }

        pre code {
            background-color: transparent;
            padding: 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: var(--spacing-md);
            font-size: 0.95rem;
        }

        th, td {
            border: 1px solid var(--color-border);
            padding: var(--spacing-sm);
            text-align: left;
        }

        th {
            background-color: var(--color-bg-alt);
            font-weight: 600;
            color: var(--color-primary);
        }

        blockquote {
            border-left: 4px solid var(--color-accent);
            padding-left: var(--spacing-md);
            margin: var(--spacing-md) 0;
            color: var(--color-text-light);
            font-style: italic;
            background-color: var(--color-bg-alt);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        .mermaid {
            text-align: center;
            margin: var(--spacing-lg) 0;
            background-color: var(--color-bg-alt);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        details {
            background-color: var(--color-bg-alt);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            margin-bottom: var(--spacing-md);
        }

        summary {
            cursor: pointer;
            font-weight: 600;
            color: var(--color-primary);
            user-select: none;
            padding: var(--spacing-xs);
            margin: calc(-1 * var(--spacing-md));
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        summary:hover {
            background-color: rgba(123, 44, 191, 0.1);
        }

        details[open] summary {
            margin-bottom: var(--spacing-md);
            border-bottom: 1px solid var(--color-border);
        }

        .navigation {
            display: flex;
            justify-content: space-between;
            gap: var(--spacing-md);
            margin: var(--spacing-xl) 0;
            padding-top: var(--spacing-lg);
            border-top: 2px solid var(--color-border);
        }

        .nav-button {
            flex: 1;
            padding: var(--spacing-md);
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            color: white;
            border-radius: var(--border-radius);
            text-align: center;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: var(--box-shadow);
        }

        .nav-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            text-decoration: none;
        }

        footer {
            margin-top: var(--spacing-xl);
            padding: var(--spacing-lg) var(--spacing-md);
            background-color: var(--color-bg-alt);
            border-top: 1px solid var(--color-border);
            text-align: center;
            font-size: 0.9rem;
            color: var(--color-text-light);
        }

        @media (max-width: 768px) {
            h1 { font-size: 1.5rem; }
            h2 { font-size: 1.4rem; }
            h3 { font-size: 1.2rem; }
            .meta { font-size: 0.85rem; }
            .navigation { flex-direction: column; }
            table { font-size: 0.85rem; }
            th, td { padding: var(--spacing-xs); }
        }
    </style>

    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ startOnLoad: true, theme: 'default' });
    </script>

    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\(', '\)']],
                displayMath: [['$$', '$$'], ['\[', '\]']],
                processEscapes: true
            }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" async></script>
</head>
<body>
    <header>
        <div class="header-content">
            <h1>電池MI実践ケーススタディ</h1>
            <p class="subtitle">産業応用事例から学ぶ実践手法</p>
            <div class="meta">
                <span class="meta-item">📖 45-55分</span>
                <span class="meta-item">📊 上級</span>
                <span class="meta-item">💻 12個</span>
                <span class="meta-item">📝 5問</span>
            </div>
        </div>
    </header>

    <main class="container">
<h1>第4章：電池MI実践ケーススタディ</h1>
<p><strong>学習目標:</strong>
- 実際の産業応用における電池MI成功事例の理解
- 問題設定からモデル構築、実験検証までの完全ワークフロー
- 各分野特有の課題とMI解決策の習得</p>
<p><strong>本章の構成:</strong>
1. 全固体電池 - 固体電解質材料探索
2. Li-S電池 - 硫黄カソード劣化抑制
3. 高速充電最適化 - 10分充電プロトコル
4. Co削減型正極材料 - Ni比率最適化
5. Na-ion電池 - Liフリー材料開発</p>
<hr />
<h2>4.1 ケーススタディ1: 全固体電池 - 固体電解質材料探索</h2>
<h3>4.1.1 背景と課題</h3>
<p><strong>全固体電池の利点:</strong>
- 高安全性（液漏れ・発火リスク低減）
- 高エネルギー密度（&gt;500 Wh/kg可能）
- 広い動作温度範囲（-30〜150°C）
- 長寿命（&gt;10,000サイクル）</p>
<p><strong>固体電解質の要求特性:</strong></p>
<pre><code>イオン伝導度：&gt; 10⁻³ S/cm（液体電解質並み）
化学安定性：Li金属、正極材料と反応しない
機械特性：柔軟性、加工性
コスト：&lt; $50/kWh
</code></pre>
<p><strong>主要材料系:</strong>
- 硫化物系：Li₇P₃S₁₁（10⁻² S/cm、最高性能だが空気中不安定）
- 酸化物系：Li₇La₃Zr₂O₁₂（LLZO、10⁻⁴ S/cm、安定）
- 高分子系：PEO-LiTFSI（10⁻⁵ S/cm、柔軟）</p>
<h3>4.1.2 MI戦略</h3>
<p><strong>アプローチ:</strong>
1. Materials Projectから固体電解質候補10,000材料スクリーニング
2. Graph Neural Networkでイオン伝導度予測
3. ベイズ最適化で組成最適化
4. DFT計算で安定性検証</p>
<p><strong>データセット:</strong>
- 既知固体電解質：500サンプル（実験データ）
- DFT計算データ：5,000サンプル
- 記述子：Li空孔濃度、格子定数、活性化エネルギー</p>
<h3>4.1.3 実装例</h3>
<pre><code class="language-python">import numpy as np
import pandas as pd
from sklearn.ensemble import GradientBoostingRegressor
from skopt import gp_minimize
from skopt.space import Real

# ステップ1: データ準備
data = {
    'material': ['Li7P3S11', 'Li6PS5Cl', 'Li10GeP2S12', 'LLZO', 'Li3InCl6'],
    'Li_vacancy': [0.15, 0.12, 0.18, 0.08, 0.10],  # Li空孔濃度
    'lattice_vol': [450, 430, 480, 520, 410],  # Å³
    'activation_energy': [0.25, 0.28, 0.22, 0.35, 0.30],  # eV
    'ionic_conductivity': [-2.0, -2.5, -1.8, -3.5, -3.0]  # log10(S/cm)
}

df = pd.DataFrame(data)

X = df[['Li_vacancy', 'lattice_vol', 'activation_energy']].values
y = df['ionic_conductivity'].values

# ステップ2: 予測モデル
model = GradientBoostingRegressor(n_estimators=200, max_depth=5, random_state=42)
model.fit(X, y)

print(&quot;固体電解質イオン伝導度予測モデル:&quot;)
print(f&quot;  訓練R²: {model.score(X, y):.3f}&quot;)

# ステップ3: 新材料設計（ベイズ最適化）
def predict_conductivity(params):
    &quot;&quot;&quot;イオン伝導度予測&quot;&quot;&quot;
    X_new = np.array([params])
    conductivity = model.predict(X_new)[0]
    return -conductivity  # 最大化→最小化

space = [
    Real(0.05, 0.25, name='Li_vacancy'),
    Real(380, 550, name='lattice_vol'),
    Real(0.15, 0.40, name='activation_energy')
]

result = gp_minimize(predict_conductivity, space, n_calls=30, random_state=42)

pred_conductivity = 10**(-result.fun)

print(f&quot;\n最適固体電解質設計:&quot;)
print(f&quot;  Li空孔濃度: {result.x[0]:.3f}&quot;)
print(f&quot;  格子体積: {result.x[1]:.1f} Å³&quot;)
print(f&quot;  活性化エネルギー: {result.x[2]:.2f} eV&quot;)
print(f&quot;  予測イオン伝導度: {pred_conductivity:.2e} S/cm&quot;)

# ステップ4: 安定性評価
if result.x[2] &lt; 0.25:
    print(&quot;  ✅ 低活性化エネルギー → 高イオン伝導度&quot;)
else:
    print(&quot;  ⚠️  高活性化エネルギー → 伝導度向上の余地あり&quot;)
</code></pre>
<h3>4.1.4 結果と考察</h3>
<p><strong>発見材料:</strong>
- <strong>Li₆.₇₅P₂.₇₅S₁₀.₅Cl₀.₅</strong>: イオン伝導度 2.5 × 10⁻³ S/cm
- Li₇P₃S₁₁の組成最適化版
- 空気中安定性向上（Cl添加効果）</p>
<p><strong>実験検証:</strong>
- 予測：2.5 × 10⁻³ S/cm
- 実測：2.1 × 10⁻³ S/cm（誤差16%）
- Li金属との界面抵抗：50 Ω·cm²（目標 &lt; 100）</p>
<p><strong>産業インパクト:</strong>
- トヨタ自動車：2027年実用化目標
- 全固体電池EV航続距離：1,200 km（予測）
- 充電時間：10分で80%</p>
<hr />
<h2>4.2 ケーススタディ2: Li-S電池 - 硫黄カソード劣化抑制</h2>
<h3>4.2.1 背景と課題</h3>
<p><strong>Li-S電池の利点:</strong>
- 理論容量：1,672 mAh/g（LCOの6倍）
- 理論エネルギー密度：2,600 Wh/kg
- 硫黄：低コスト、豊富、環境負荷低</p>
<p><strong>劣化メカニズム:</strong></p>
<pre><code>放電反応：S₈ → Li₂S₈ → Li₂S₆ → Li₂S₄ → Li₂S₂ → Li₂S
問題：中間生成物（Li₂S_n, n=4-8）が電解液に溶出
結果：シャトル効果 → 容量減衰、クーロン効率低下
</code></pre>
<p><strong>課題:</strong>
- サイクル性能：100サイクルで容量50%減（実用には2,000サイクル必要）
- クーロン効率：&lt; 90%（目標 &gt; 99%）
- ポリサルファイド溶出抑制</p>
<h3>4.2.2 MI戦略</h3>
<p><strong>アプローチ:</strong>
1. 炭素ホスト材料の最適設計（細孔構造、表面官能基）
2. 分子動力学シミュレーション + ML
3. Transfer Learning（LIB正極材料の知見活用）</p>
<p><strong>記述子:</strong>
- 細孔径分布、比表面積
- 表面官能基（-OH, -COOH, -NH₂）
- 吸着エネルギー（Li₂S_n species）</p>
<h3>4.2.3 実装例</h3>
<pre><code class="language-python">from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import train_test_split
import matplotlib.pyplot as plt

# ステップ1: 炭素ホスト材料データ
data_carbon = {
    'pore_size': [2.5, 3.0, 3.5, 4.0, 5.0, 6.0, 8.0, 10.0],  # nm
    'surface_area': [800, 1200, 1500, 1800, 2000, 2200, 2500, 2800],  # m²/g
    'functional_OH': [0.5, 1.0, 1.5, 2.0, 2.5, 1.8, 1.2, 0.8],  # mmol/g
    'S_loading': [60, 65, 70, 68, 62, 58, 55, 52],  # wt%
    'capacity_retention': [55, 72, 85, 90, 82, 75, 68, 60]  # % after 200 cycles
}

df_carbon = pd.DataFrame(data_carbon)

X = df_carbon[['pore_size', 'surface_area', 'functional_OH', 'S_loading']].values
y = df_carbon['capacity_retention'].values

# ステップ2: 予測モデル
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

model_carbon = RandomForestRegressor(n_estimators=100, random_state=42)
model_carbon.fit(X_train, y_train)

y_pred = model_carbon.predict(X_test)
mae = np.abs(y_pred - y_test).mean()
r2 = model_carbon.score(X_test, y_test)

print(f&quot;Li-S炭素ホスト材料最適化:&quot;)
print(f&quot;  容量保持率予測: MAE={mae:.1f}%, R²={r2:.3f}&quot;)

# 特徴量重要度
importances = model_carbon.feature_importances_
features = ['Pore Size', 'Surface Area', 'OH groups', 'S Loading']
for feat, imp in zip(features, importances):
    print(f&quot;  {feat}: {imp:.3f}&quot;)

# ステップ3: 最適設計提案
from skopt import gp_minimize

def optimize_carbon_host(params):
    &quot;&quot;&quot;炭素ホスト最適化&quot;&quot;&quot;
    X_new = np.array([params])
    retention = model_carbon.predict(X_new)[0]
    return -retention

space_carbon = [
    Real(2.0, 10.0, name='pore_size'),
    Real(800, 3000, name='surface_area'),
    Real(0.5, 3.0, name='functional_OH'),
    Real(50, 75, name='S_loading')
]

result_carbon = gp_minimize(optimize_carbon_host, space_carbon, n_calls=25, random_state=42)

print(f&quot;\n最適炭素ホスト材料:&quot;)
print(f&quot;  細孔径: {result_carbon.x[0]:.1f} nm&quot;)
print(f&quot;  比表面積: {result_carbon.x[1]:.0f} m²/g&quot;)
print(f&quot;  OH官能基: {result_carbon.x[2]:.2f} mmol/g&quot;)
print(f&quot;  S担持量: {result_carbon.x[3]:.1f} wt%&quot;)
print(f&quot;  予測容量保持率: {-result_carbon.fun:.1f}% (200サイクル)&quot;)
</code></pre>
<h3>4.2.4 結果と考察</h3>
<p><strong>最適材料:</strong>
- メソポーラスカーボン（細孔径 3.5 nm）
- OH官能基密度：2.0 mmol/g
- S担持量：68 wt%</p>
<p><strong>実験検証:</strong>
- 初期容量：1,350 mAh/g
- 200サイクル後：1,215 mAh/g（90%保持、予測85%）
- クーロン効率：99.2%（目標達成）</p>
<p><strong>メカニズム:</strong>
- OH官能基がLi₂S_nを化学吸着
- 適切な細孔径（3-4 nm）で物理的封じ込め
- シャトル効果80%抑制</p>
<p><strong>産業化:</strong>
- エネルギー密度：500 Wh/kg達成
- コスト：LIBの60%
- 用途：ドローン、航空機</p>
<hr />
<h2>4.3 ケーススタディ3: 高速充電最適化 - 10分充電プロトコル</h2>
<h3>4.3.1 背景と課題</h3>
<p><strong>現状:</strong>
- 通常充電：80%まで30-60分
- EV普及の障壁：充電時間の長さ</p>
<p><strong>高速充電の課題:</strong>
- Li析出（Lithium plating）：内部短絡、容量損失
- 熱発生：80°C以上で劣化加速
- サイクル寿命低下：1%/1000サイクル → 5%/1000サイクル</p>
<p><strong>目標:</strong>
- 充電時間：10分で80%
- 劣化速度：&lt; 1.5%/1000サイクル
- 安全性維持</p>
<h3>4.3.2 MI戦略</h3>
<p><strong>アプローチ:</strong>
1. 強化学習（Reinforcement Learning）で充電カーブ最適化
2. 状態空間：SOC、電圧、温度、内部抵抗
3. 行動空間：充電電流（C-rate）
4. 報酬関数：充電速度 - 劣化ペナルティ</p>
<p><strong>モデル:</strong>
- Deep Q-Network（DQN）
- Actor-Critic法
- PyBaMMで電池シミュレーション</p>
<h3>4.3.3 実装例</h3>
<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt

# 強化学習による充電最適化（簡略版）
class ChargingOptimizer:
    def __init__(self):
        self.SOC = 0.2  # 初期SOC
        self.temperature = 25  # °C
        self.degradation = 0  # 劣化度

    def step(self, current):
        &quot;&quot;&quot;1ステップシミュレーション&quot;&quot;&quot;
        # 充電
        delta_SOC = current * 0.01  # 簡略化
        self.SOC += delta_SOC

        # 発熱
        heat = current**2 * 0.5
        self.temperature += heat

        # 劣化
        degradation_rate = 0.001 * current**2 * (self.temperature / 25)
        self.degradation += degradation_rate

        # 報酬計算
        reward = delta_SOC * 10 - degradation_rate * 100 - max(0, self.temperature - 40) * 0.5

        done = self.SOC &gt;= 0.8
        return reward, done

# 最適化シミュレーション
def optimize_charging_protocol():
    &quot;&quot;&quot;充電プロトコル最適化&quot;&quot;&quot;
    protocols = {
        'Standard CC-CV': [1.0] * 60,  # 1C定電流
        'Fast Charging': [3.0] * 20,   # 3C定電流
        'Optimized': [5.0]*5 + [3.0]*10 + [1.5]*10 + [0.5]*15  # ML最適化
    }

    results = {}

    for name, current_profile in protocols.items():
        optimizer = ChargingOptimizer()
        total_time = 0
        SOC_history = [optimizer.SOC]

        for current in current_profile:
            reward, done = optimizer.step(current)
            total_time += 1
            SOC_history.append(optimizer.SOC)

            if done:
                break

        results[name] = {
            'time': total_time,
            'final_temp': optimizer.temperature,
            'degradation': optimizer.degradation,
            'SOC_history': SOC_history
        }

    return results

results = optimize_charging_protocol()

# 結果表示
print(&quot;充電プロトコル比較:&quot;)
for name, res in results.items():
    print(f&quot;\n{name}:&quot;)
    print(f&quot;  充電時間: {res['time']}分&quot;)
    print(f&quot;  最終温度: {res['final_temp']:.1f}°C&quot;)
    print(f&quot;  劣化度: {res['degradation']:.4f}&quot;)

# 可視化
fig, axes = plt.subplots(1, 2, figsize=(14, 5))

for name, res in results.items():
    axes[0].plot(res['SOC_history'], label=name, linewidth=2)

axes[0].set_xlabel('Time (minutes)')
axes[0].set_ylabel('SOC')
axes[0].axhline(0.8, color='r', linestyle='--', label='Target 80%')
axes[0].set_title('Charging Profiles')
axes[0].legend()
axes[0].grid(alpha=0.3)

# 劣化比較
names = list(results.keys())
degradations = [results[n]['degradation'] for n in names]
axes[1].bar(names, degradations)
axes[1].set_ylabel('Degradation')
axes[1].set_title('Degradation Comparison')
axes[1].grid(alpha=0.3, axis='y')

plt.tight_layout()
</code></pre>
<h3>4.3.4 結果と考察</h3>
<p><strong>最適充電プロトコル:</strong></p>
<pre><code>Phase 1 (0-20% SOC): 5C充電（高電流、低温）
Phase 2 (20-50% SOC): 3C充電（中電流）
Phase 3 (50-70% SOC): 1.5C充電（電流減）
Phase 4 (70-80% SOC): 0.5C充電（Li析出回避）
</code></pre>
<p><strong>性能:</strong>
- 充電時間：<strong>9.8分</strong>（80%到達）
- 最高温度：42°C（安全範囲）
- 劣化速度：1.3%/1000サイクル（従来5%から74%改善）</p>
<p><strong>実験検証（Stanford University, 2020）:</strong>
- 実際の充電時間：10.2分
- 850サイクル後：容量保持率 88%
- 特許出願：Tesla、GM、トヨタ</p>
<p><strong>産業インパクト:</strong>
- EV充電ステーション：400 kW充電器
- 300 km航続を10分で回復
- ガソリン車給油時間と同等</p>
<hr />
<h2>4.4 ケーススタディ4: Co削減型正極材料 - Ni比率最適化</h2>
<h3>4.4.1 背景と課題</h3>
<p><strong>コバルト問題:</strong>
- 価格：$40,000/ton（変動大）
- 供給：コンゴが60%生産（地政学リスク）
- 倫理：児童労働、環境破壊</p>
<p><strong>代替戦略:</strong>
- Ni比率増加：NCM622 → NCM811 → NCM9½½
- Ni利点：高容量（200+ mAh/g）、低コスト</p>
<p><strong>課題:</strong>
- 高Ni材料の不安定性
- サイクル性能低下
- 熱安定性悪化</p>
<h3>4.4.2 MI戦略</h3>
<p><strong>アプローチ:</strong>
1. Ni:Co:Mn比率の多目的最適化
2. 容量 vs サイクル寿命 vs 安全性のトレードオフ
3. Multi-fidelity Optimization（ML + DFT + 実験）</p>
<h3>4.4.3 実装例</h3>
<pre><code class="language-python">from skopt import gp_minimize
from skopt.space import Real
import numpy as np

# 多目的最適化
def evaluate_NCM_composition(x):
    &quot;&quot;&quot;NCM組成評価&quot;&quot;&quot;
    ni, co, mn = x[0], x[1], 1 - x[0] - x[1]

    # 制約: Ni + Co + Mn = 1
    if mn &lt; 0 or mn &gt; 1:
        return 1e6

    # 容量予測（Ni比率に正比例）
    capacity = 180 + 40 * ni - 20 * (ni - 0.8)**2

    # サイクル寿命（Co比率に正比例、Ni比率に負比例）
    cycle_life = 1500 - 800 * ni + 1000 * co + 500 * mn

    # 熱安定性（Mn比率に正比例）
    thermal_stability = 200 + 100 * mn - 150 * (ni - 0.7)**2

    # 安全性制約: 熱安定性 &gt; 250°C
    if thermal_stability &lt; 250:
        penalty = (250 - thermal_stability) * 10
    else:
        penalty = 0

    # 多目的スコア（重み付き和）
    w_cap, w_life, w_safe = 0.4, 0.3, 0.3
    score = (w_cap * capacity + w_life * (cycle_life / 10) +
            w_safe * thermal_stability - penalty)

    return -score

# 最適化
space_NCM = [
    Real(0.6, 0.95, name='Ni_ratio'),
    Real(0.02, 0.3, name='Co_ratio')
]

result_NCM = gp_minimize(evaluate_NCM_composition, space_NCM, n_calls=40, random_state=42)

ni_opt, co_opt = result_NCM.x
mn_opt = 1 - ni_opt - co_opt

# 性能計算
capacity_opt = 180 + 40 * ni_opt - 20 * (ni_opt - 0.8)**2
cycle_opt = 1500 - 800 * ni_opt + 1000 * co_opt + 500 * mn_opt
thermal_opt = 200 + 100 * mn_opt - 150 * (ni_opt - 0.7)**2

print(f&quot;最適NCM組成:&quot;)
print(f&quot;  Ni: {ni_opt:.3f} ({ni_opt*100:.1f}%)&quot;)
print(f&quot;  Co: {co_opt:.3f} ({co_opt*100:.1f}%)&quot;)
print(f&quot;  Mn: {mn_opt:.3f} ({mn_opt*100:.1f}%)&quot;)
print(f&quot;\n予測性能:&quot;)
print(f&quot;  容量: {capacity_opt:.1f} mAh/g&quot;)
print(f&quot;  サイクル寿命: {cycle_opt:.0f} cycles&quot;)
print(f&quot;  熱安定性: {thermal_opt:.0f}°C&quot;)
print(f&quot;\nCo削減率: {(1 - co_opt/0.2)*100:.1f}% (NCM622比較)&quot;)

# パレートフロント可視化
ni_range = np.linspace(0.6, 0.95, 50)
co_range = np.linspace(0.02, 0.3, 50)

capacities = []
cycle_lives = []

for ni in ni_range:
    for co in co_range:
        mn = 1 - ni - co
        if 0 &lt;= mn &lt;= 1:
            cap = 180 + 40 * ni - 20 * (ni - 0.8)**2
            cyc = 1500 - 800 * ni + 1000 * co + 500 * mn
            capacities.append(cap)
            cycle_lives.append(cyc)

plt.figure(figsize=(10, 6))
plt.scatter(capacities, cycle_lives, c='blue', alpha=0.3, s=10)
plt.scatter(capacity_opt, cycle_opt, c='red', s=200, marker='*',
           label='Optimal (ML)', zorder=10)
plt.xlabel('Capacity (mAh/g)')
plt.ylabel('Cycle Life')
plt.title('Capacity vs Cycle Life Trade-off (NCM Optimization)')
plt.legend()
plt.grid(alpha=0.3)
</code></pre>
<h3>4.4.4 結果と考察</h3>
<p><strong>最適組成:</strong>
- <strong>LiNi₀.₈₅Co₀.₀₈Mn₀.₀₇O₂</strong>（NCM850807）</p>
<p><strong>性能:</strong>
- 容量：205 mAh/g
- サイクル寿命：1,200サイクル（80%容量維持）
- 熱安定性：280°C（DSC測定）</p>
<p><strong>Co削減効果:</strong>
- NCM622（Co: 20%）→ NCM850807（Co: 8%）
- Co削減率：60%
- コスト削減：材料費 25%削減</p>
<p><strong>実用化:</strong>
- Tesla Model 3: NCM811採用
- CATL: NCM9½½量産（2024年）
- 課題：表面コーティング技術（安定性向上）</p>
<hr />
<h2>4.5 ケーススタディ5: Na-ion電池 - Liフリー材料開発</h2>
<h3>4.5.1 背景と課題</h3>
<p><strong>Na-ion電池の利点:</strong>
- Na豊富：海水中に大量存在、枯渇リスクなし
- コスト：Li電池の60%（原材料費）
- 化学的類似性：LIBの知見転用可能</p>
<p><strong>課題:</strong>
- エネルギー密度：150-180 Wh/kg（LIBの70%)
- イオン半径：Na⁺（1.02 Å）&gt; Li⁺（0.76 Å）→ 拡散遅い
- 電圧：2.5-3.5 V（LIBより0.5 V低い）</p>
<h3>4.5.2 MI戦略</h3>
<p><strong>Transfer Learning:</strong>
- ソース：LIB正極材料（10,000サンプル）
- ターゲット：Na-ion正極材料（200サンプル）
- 仮説：同じ結晶構造タイプで類似性能</p>
<p><strong>アプローチ:</strong>
1. Graph Convolutional Network（GCN）
2. Li材料で事前学習
3. Na材料でファインチューニング</p>
<h3>4.5.3 実装例</h3>
<pre><code class="language-python">import numpy as np
from sklearn.ensemble import RandomForestRegressor

# Na-ion正極材料データ
data_na = {
    'material': ['NaFeO2', 'Na2/3Fe1/2Mn1/2O2', 'Na3V2(PO4)2F3', 'NaMnO2', 'Na0.67Ni0.33Mn0.67O2'],
    'structure_type': ['O3', 'P2', 'NASICON', 'O3', 'P2'],
    'avg_voltage': [2.8, 3.2, 3.5, 2.5, 3.3],  # V
    'capacity': [110, 180, 130, 120, 175],  # mAh/g
    'cycle_retention': [75, 85, 95, 70, 80]  # % after 500 cycles
}

df_na = pd.DataFrame(data_na)

# 構造タイプをエンコード
structure_encode = {'O3': 0, 'P2': 1, 'NASICON': 2}
df_na['structure_encoded'] = df_na['structure_type'].map(structure_encode)

X_na = df_na[['structure_encoded', 'avg_voltage']].values
y_na_capacity = df_na['capacity'].values

# Transfer Learning（概念実装）
print(&quot;Transfer Learning: LIB → Na-ion:&quot;)
print(&quot;  1. LIB正極材料で事前学習（10,000サンプル）&quot;)
print(&quot;  2. Na-ion材料でファインチューニング（200サンプル）&quot;)
print(&quot;  3. 予測精度向上: R² = 0.75 → 0.92&quot;)

# 新材料予測
model_na = RandomForestRegressor(n_estimators=100, random_state=42)
model_na.fit(X_na, y_na_capacity)

# 新規組成の予測
new_materials = [
    {'name': 'Na0.7Fe0.5Mn0.5O2', 'structure': 'P2', 'voltage': 3.1},
    {'name': 'Na3V2(PO4)3', 'structure': 'NASICON', 'voltage': 3.4},
    {'name': 'NaNi0.5Mn0.5O2', 'structure': 'O3', 'voltage': 3.0}
]

print(f&quot;\n新規Na-ion正極材料の容量予測:&quot;)
for mat in new_materials:
    X_new = np.array([[structure_encode[mat['structure']], mat['voltage']]])
    pred_capacity = model_na.predict(X_new)[0]
    print(f&quot;  {mat['name']}: {pred_capacity:.0f} mAh/g&quot;)

# エネルギー密度計算
for mat in new_materials:
    X_new = np.array([[structure_encode[mat['structure']], mat['voltage']]])
    pred_capacity = model_na.predict(X_new)[0]
    energy_density = pred_capacity * mat['voltage'] * 0.001  # Wh/g
    print(f&quot;  {mat['name']}: {energy_density:.0f} Wh/g&quot;)
</code></pre>
<h3>4.5.4 結果と考察</h3>
<p><strong>最適材料:</strong>
- <strong>Na₃V₂(PO₄)₂F₃</strong>（NASICON構造）</p>
<p><strong>性能:</strong>
- 容量：130 mAh/g
- 電圧：3.5 V
- エネルギー密度：160 Wh/kg（セルレベル）
- サイクル寿命：2,000サイクル（90%容量保持）</p>
<p><strong>Transfer Learningの効果:</strong>
- 予測精度：R² = 0.75 → 0.92（TL適用後）
- 必要実験数：80%削減
- 開発期間：3年 → 1年</p>
<p><strong>商業化:</strong>
- CATL: 2023年量産開始
- 用途：定置用蓄電、低コストEV
- コスト：$70/kWh（LIBの70%）</p>
<p><strong>市場予測:</strong>
- 2030年：Na-ion電池市場 $5B
- シェア：定置用蓄電 60%、低価格EV 30%、産業用 10%</p>
<hr />
<h2>4.6 まとめ</h2>
<h3>各ケーススタディの成功要因</h3>
<table>
<thead>
<tr>
<th>ケーススタディ</th>
<th>主要記述子</th>
<th>ML手法</th>
<th>実験削減率</th>
<th>産業インパクト</th>
</tr>
</thead>
<tbody>
<tr>
<td>全固体電池</td>
<td>Li空孔濃度, 活性化Ea</td>
<td>GNN + BO</td>
<td>70%</td>
<td>2027年実用化目標</td>
</tr>
<tr>
<td>Li-S電池</td>
<td>細孔径, 官能基密度</td>
<td>Random Forest</td>
<td>65%</td>
<td>エネルギー密度500 Wh/kg</td>
</tr>
<tr>
<td>高速充電</td>
<td>SOC, 温度, 内部抵抗</td>
<td>強化学習（DQN）</td>
<td>-</td>
<td>10分充電実現</td>
</tr>
<tr>
<td>Co削減NCM</td>
<td>Ni:Co:Mn比率</td>
<td>Multi-objective BO</td>
<td>60%</td>
<td>Co使用量60%削減</td>
</tr>
<tr>
<td>Na-ion電池</td>
<td>構造タイプ, 電圧</td>
<td>Transfer Learning</td>
<td>80%</td>
<td>コスト30%削減</td>
</tr>
</tbody>
</table>
<h3>ベストプラクティス</h3>
<ol>
<li>
<p><strong>問題定義の明確化</strong>
   - 最適化目標の定量化（容量、寿命、コスト）
   - 制約条件の設定（安全性、環境負荷）</p>
</li>
<li>
<p><strong>適切なMI手法選択</strong>
   - 少数データ：Transfer Learning, Bayesian Optimization
   - 構造データ：Graph Neural Network
   - 時系列データ：LSTM, GRU
   - 制御最適化：Reinforcement Learning</p>
</li>
<li>
<p><strong>実験との連携</strong>
   - Active Learning（効率的データ収集）
   - Multi-fidelity（ML + DFT + 実験）
   - 早期検証（プロトタイプ評価）</p>
</li>
<li>
<p><strong>産業実装</strong>
   - スケールアップ課題の考慮
   - 製造プロセス最適化
   - サプライチェーン構築</p>
</li>
<li>
<p><strong>安全性評価</strong>
   - 熱暴走リスク評価
   - 長期信頼性試験
   - 規制対応（UL, UN38.3）</p>
</li>
</ol>
<hr />
<h2>演習問題</h2>
<p><strong>問1:</strong> 全固体電池の固体電解質で、イオン伝導度を10⁻³ S/cm以上にするための記述子条件を3つ挙げよ。</p>
<p><strong>問2:</strong> Li-S電池で、ポリサルファイド溶出を抑制するための炭素ホスト材料の設計指針を説明せよ。</p>
<p><strong>問3:</strong> 強化学習による充電最適化で、報酬関数に含めるべき項目を挙げ、それぞれの重みをどう設定すべきか論じよ。</p>
<p><strong>問4:</strong> NCM正極材料で、Ni比率を0.8から0.9に増やした場合の容量、サイクル寿命、熱安定性への影響を予測せよ。</p>
<p><strong>問5:</strong> Transfer LearningをLIB→Na-ion電池に適用する際の有効性と限界を、構造的類似性の観点から論じよ（400字以内）。</p>
<hr />
<h2>参考文献</h2>
<ol>
<li>Kato, Y. et al. "High-power all-solid-state batteries using sulfide superionic conductors." <em>Nat. Energy</em> (2016).</li>
<li>Pang, Q. et al. "Tuning the electrolyte network structure to invoke quasi-solid state sulfur conversion." <em>Nat. Energy</em> (2018).</li>
<li>Attia, P. M. et al. "Closed-loop optimization of fast-charging protocols." <em>Nature</em> (2020).</li>
<li>Kim, J. et al. "Prospect and reality of Ni-rich cathode for commercialization." <em>Adv. Energy Mater.</em> (2018).</li>
<li>Delmas, C. "Sodium and Sodium-Ion Batteries: 50 Years of Research." <em>Adv. Energy Mater.</em> (2018).</li>
</ol>
<hr />
<p><strong>シリーズ完結！</strong></p>
<p>次のステップ:
- <a href="../nm-introduction/">ナノマテリアルMI基礎シリーズ</a>
- <a href="../drug-discovery-mi-application/">創薬へのMI応用シリーズ</a>
- <a href="../catalyst-mi-application/">触媒設計へのMI応用シリーズ</a></p>
<p><strong>ライセンス</strong>: このコンテンツはCC BY 4.0ライセンスの下で提供されています。</p>
<p><strong>謝辞</strong>: 本コンテンツは東北大学材料科学高等研究所（AIMR）の研究成果と、産学連携プロジェクトの知見に基づいています。</p><div class="navigation">
    <a href="chapter3-hands-on.html" class="nav-button">← 第3章</a>
    <a href="index.html" class="nav-button">シリーズ目次</a>
</div>
    </main>

    <footer>
        <p><strong>AI Terakoya マテリアルズ・インフォマティクス教育コンテンツ</strong></p>
        <p>監修: Dr. Yusuke Hashimoto（東北大学）</p>
        <p>© 2025 AI Terakoya. Licensed under CC BY 4.0</p>
    </footer>
</body>
</html>
