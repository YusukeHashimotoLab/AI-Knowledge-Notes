<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é›»æ± MIå®Ÿè·µã‚±ãƒ¼ã‚¹ã‚¹ã‚¿ãƒ‡ã‚£ - AI Terakoya</title>

    <style>
        :root {
            --color-primary: #2c3e50;
            --color-primary-dark: #1a252f;
            --color-accent: #7b2cbf;
            --color-accent-light: #9d4edd;
            --color-text: #2d3748;
            --color-text-light: #4a5568;
            --color-bg: #ffffff;
            --color-bg-alt: #f7fafc;
            --color-border: #e2e8f0;
            --color-code-bg: #f8f9fa;
            --color-link: #3182ce;
            --color-link-hover: #2c5aa0;

            --spacing-xs: 0.5rem;
            --spacing-sm: 1rem;
            --spacing-md: 1.5rem;
            --spacing-lg: 2rem;
            --spacing-xl: 3rem;

            --font-body: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            --font-mono: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;

            --border-radius: 8px;
            --box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-body);
            line-height: 1.7;
            color: var(--color-text);
            background-color: var(--color-bg);
            font-size: 16px;
        }

        header {
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            color: white;
            padding: var(--spacing-xl) var(--spacing-md);
            margin-bottom: var(--spacing-xl);
            box-shadow: var(--box-shadow);
        }

        .header-content {
            max-width: 900px;
            margin: 0 auto;
        }

        h1 {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: var(--spacing-sm);
            line-height: 1.2;
        }

        .subtitle {
            font-size: 1.1rem;
            opacity: 0.95;
            font-weight: 400;
            margin-bottom: var(--spacing-md);
        }

        .meta {
            display: flex;
            flex-wrap: wrap;
            gap: var(--spacing-md);
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .meta-item {
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 0 var(--spacing-md) var(--spacing-xl);
        }

        h2 {
            font-size: 1.75rem;
            color: var(--color-primary);
            margin-top: var(--spacing-xl);
            margin-bottom: var(--spacing-md);
            padding-bottom: var(--spacing-xs);
            border-bottom: 3px solid var(--color-accent);
        }

        h3 {
            font-size: 1.4rem;
            color: var(--color-primary);
            margin-top: var(--spacing-lg);
            margin-bottom: var(--spacing-sm);
        }

        h4 {
            font-size: 1.1rem;
            color: var(--color-primary-dark);
            margin-top: var(--spacing-md);
            margin-bottom: var(--spacing-sm);
        }

        p {
            margin-bottom: var(--spacing-md);
            color: var(--color-text);
        }

        a {
            color: var(--color-link);
            text-decoration: none;
            transition: color 0.2s;
        }

        a:hover {
            color: var(--color-link-hover);
            text-decoration: underline;
        }

        ul, ol {
            margin-left: var(--spacing-lg);
            margin-bottom: var(--spacing-md);
        }

        li {
            margin-bottom: var(--spacing-xs);
            color: var(--color-text);
        }

        pre {
            background-color: var(--color-code-bg);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            overflow-x: auto;
            margin-bottom: var(--spacing-md);
            font-family: var(--font-mono);
            font-size: 0.9rem;
            line-height: 1.5;
        }

        code {
            font-family: var(--font-mono);
            font-size: 0.9em;
            background-color: var(--color-code-bg);
            padding: 0.2em 0.4em;
            border-radius: 3px;
        }

        pre code {
            background-color: transparent;
            padding: 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: var(--spacing-md);
            font-size: 0.95rem;
        }

        th, td {
            border: 1px solid var(--color-border);
            padding: var(--spacing-sm);
            text-align: left;
        }

        th {
            background-color: var(--color-bg-alt);
            font-weight: 600;
            color: var(--color-primary);
        }

        blockquote {
            border-left: 4px solid var(--color-accent);
            padding-left: var(--spacing-md);
            margin: var(--spacing-md) 0;
            color: var(--color-text-light);
            font-style: italic;
            background-color: var(--color-bg-alt);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        .mermaid {
            text-align: center;
            margin: var(--spacing-lg) 0;
            background-color: var(--color-bg-alt);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        details {
            background-color: var(--color-bg-alt);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            margin-bottom: var(--spacing-md);
        }

        summary {
            cursor: pointer;
            font-weight: 600;
            color: var(--color-primary);
            user-select: none;
            padding: var(--spacing-xs);
            margin: calc(-1 * var(--spacing-md));
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        summary:hover {
            background-color: rgba(123, 44, 191, 0.1);
        }

        details[open] summary {
            margin-bottom: var(--spacing-md);
            border-bottom: 1px solid var(--color-border);
        }

        .navigation {
            display: flex;
            justify-content: space-between;
            gap: var(--spacing-md);
            margin: var(--spacing-xl) 0;
            padding-top: var(--spacing-lg);
            border-top: 2px solid var(--color-border);
        }

        .nav-button {
            flex: 1;
            padding: var(--spacing-md);
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            color: white;
            border-radius: var(--border-radius);
            text-align: center;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: var(--box-shadow);
        }

        .nav-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            text-decoration: none;
        }

        footer {
            margin-top: var(--spacing-xl);
            padding: var(--spacing-lg) var(--spacing-md);
            background-color: var(--color-bg-alt);
            border-top: 1px solid var(--color-border);
            text-align: center;
            font-size: 0.9rem;
            color: var(--color-text-light);
        }

        @media (max-width: 768px) {
            h1 { font-size: 1.5rem; }
            h2 { font-size: 1.4rem; }
            h3 { font-size: 1.2rem; }
            .meta { font-size: 0.85rem; }
            .navigation { flex-direction: column; }
            table { font-size: 0.85rem; }
            th, td { padding: var(--spacing-xs); }
        }
    </style>

    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ startOnLoad: true, theme: 'default' });
    </script>

    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\(', '\)']],
                displayMath: [['$$', '$$'], ['\[', '\]']],
                processEscapes: true
            }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" async></script>
</head>
<body>
    <header>
        <div class="header-content">
            <h1>é›»æ± MIå®Ÿè·µã‚±ãƒ¼ã‚¹ã‚¹ã‚¿ãƒ‡ã‚£</h1>
            <p class="subtitle">ç”£æ¥­å¿œç”¨äº‹ä¾‹ã‹ã‚‰å­¦ã¶å®Ÿè·µæ‰‹æ³•</p>
            <div class="meta">
                <span class="meta-item">ğŸ“– 45-55åˆ†</span>
                <span class="meta-item">ğŸ“Š ä¸Šç´š</span>
                <span class="meta-item">ğŸ’» 12å€‹</span>
                <span class="meta-item">ğŸ“ 5å•</span>
            </div>
        </div>
    </header>

    <main class="container">
<h1>ç¬¬4ç« ï¼šé›»æ± MIå®Ÿè·µã‚±ãƒ¼ã‚¹ã‚¹ã‚¿ãƒ‡ã‚£</h1>
<p><strong>å­¦ç¿’ç›®æ¨™:</strong>
- å®Ÿéš›ã®ç”£æ¥­å¿œç”¨ã«ãŠã‘ã‚‹é›»æ± MIæˆåŠŸäº‹ä¾‹ã®ç†è§£
- å•é¡Œè¨­å®šã‹ã‚‰ãƒ¢ãƒ‡ãƒ«æ§‹ç¯‰ã€å®Ÿé¨“æ¤œè¨¼ã¾ã§ã®å®Œå…¨ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼
- å„åˆ†é‡ç‰¹æœ‰ã®èª²é¡Œã¨MIè§£æ±ºç­–ã®ç¿’å¾—</p>
<p><strong>æœ¬ç« ã®æ§‹æˆ:</strong>
1. å…¨å›ºä½“é›»æ±  - å›ºä½“é›»è§£è³ªææ–™æ¢ç´¢
2. Li-Sé›»æ±  - ç¡«é»„ã‚«ã‚½ãƒ¼ãƒ‰åŠ£åŒ–æŠ‘åˆ¶
3. é«˜é€Ÿå……é›»æœ€é©åŒ– - 10åˆ†å……é›»ãƒ—ãƒ­ãƒˆã‚³ãƒ«
4. Coå‰Šæ¸›å‹æ­£æ¥µææ–™ - Niæ¯”ç‡æœ€é©åŒ–
5. Na-ioné›»æ±  - Liãƒ•ãƒªãƒ¼ææ–™é–‹ç™º</p>
<hr />
<h2>4.1 ã‚±ãƒ¼ã‚¹ã‚¹ã‚¿ãƒ‡ã‚£1: å…¨å›ºä½“é›»æ±  - å›ºä½“é›»è§£è³ªææ–™æ¢ç´¢</h2>
<h3>4.1.1 èƒŒæ™¯ã¨èª²é¡Œ</h3>
<p><strong>å…¨å›ºä½“é›»æ± ã®åˆ©ç‚¹:</strong>
- é«˜å®‰å…¨æ€§ï¼ˆæ¶²æ¼ã‚Œãƒ»ç™ºç«ãƒªã‚¹ã‚¯ä½æ¸›ï¼‰
- é«˜ã‚¨ãƒãƒ«ã‚®ãƒ¼å¯†åº¦ï¼ˆ&gt;500 Wh/kgå¯èƒ½ï¼‰
- åºƒã„å‹•ä½œæ¸©åº¦ç¯„å›²ï¼ˆ-30ã€œ150Â°Cï¼‰
- é•·å¯¿å‘½ï¼ˆ&gt;10,000ã‚µã‚¤ã‚¯ãƒ«ï¼‰</p>
<p><strong>å›ºä½“é›»è§£è³ªã®è¦æ±‚ç‰¹æ€§:</strong></p>
<pre><code>ã‚¤ã‚ªãƒ³ä¼å°åº¦ï¼š&gt; 10â»Â³ S/cmï¼ˆæ¶²ä½“é›»è§£è³ªä¸¦ã¿ï¼‰
åŒ–å­¦å®‰å®šæ€§ï¼šLié‡‘å±ã€æ­£æ¥µææ–™ã¨åå¿œã—ãªã„
æ©Ÿæ¢°ç‰¹æ€§ï¼šæŸ”è»Ÿæ€§ã€åŠ å·¥æ€§
ã‚³ã‚¹ãƒˆï¼š&lt; $50/kWh
</code></pre>
<p><strong>ä¸»è¦ææ–™ç³»:</strong>
- ç¡«åŒ–ç‰©ç³»ï¼šLiâ‚‡Pâ‚ƒSâ‚â‚ï¼ˆ10â»Â² S/cmã€æœ€é«˜æ€§èƒ½ã ãŒç©ºæ°—ä¸­ä¸å®‰å®šï¼‰
- é…¸åŒ–ç‰©ç³»ï¼šLiâ‚‡Laâ‚ƒZrâ‚‚Oâ‚â‚‚ï¼ˆLLZOã€10â»â´ S/cmã€å®‰å®šï¼‰
- é«˜åˆ†å­ç³»ï¼šPEO-LiTFSIï¼ˆ10â»âµ S/cmã€æŸ”è»Ÿï¼‰</p>
<h3>4.1.2 MIæˆ¦ç•¥</h3>
<p><strong>ã‚¢ãƒ—ãƒ­ãƒ¼ãƒ:</strong>
1. Materials Projectã‹ã‚‰å›ºä½“é›»è§£è³ªå€™è£œ10,000ææ–™ã‚¹ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°
2. Graph Neural Networkã§ã‚¤ã‚ªãƒ³ä¼å°åº¦äºˆæ¸¬
3. ãƒ™ã‚¤ã‚ºæœ€é©åŒ–ã§çµ„æˆæœ€é©åŒ–
4. DFTè¨ˆç®—ã§å®‰å®šæ€§æ¤œè¨¼</p>
<p><strong>ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆ:</strong>
- æ—¢çŸ¥å›ºä½“é›»è§£è³ªï¼š500ã‚µãƒ³ãƒ—ãƒ«ï¼ˆå®Ÿé¨“ãƒ‡ãƒ¼ã‚¿ï¼‰
- DFTè¨ˆç®—ãƒ‡ãƒ¼ã‚¿ï¼š5,000ã‚µãƒ³ãƒ—ãƒ«
- è¨˜è¿°å­ï¼šLiç©ºå­”æ¿ƒåº¦ã€æ ¼å­å®šæ•°ã€æ´»æ€§åŒ–ã‚¨ãƒãƒ«ã‚®ãƒ¼</p>
<h3>4.1.3 å®Ÿè£…ä¾‹</h3>
<pre><code class="language-python">import numpy as np
import pandas as pd
from sklearn.ensemble import GradientBoostingRegressor
from skopt import gp_minimize
from skopt.space import Real

# ã‚¹ãƒ†ãƒƒãƒ—1: ãƒ‡ãƒ¼ã‚¿æº–å‚™
data = {
    'material': ['Li7P3S11', 'Li6PS5Cl', 'Li10GeP2S12', 'LLZO', 'Li3InCl6'],
    'Li_vacancy': [0.15, 0.12, 0.18, 0.08, 0.10],  # Liç©ºå­”æ¿ƒåº¦
    'lattice_vol': [450, 430, 480, 520, 410],  # Ã…Â³
    'activation_energy': [0.25, 0.28, 0.22, 0.35, 0.30],  # eV
    'ionic_conductivity': [-2.0, -2.5, -1.8, -3.5, -3.0]  # log10(S/cm)
}

df = pd.DataFrame(data)

X = df[['Li_vacancy', 'lattice_vol', 'activation_energy']].values
y = df['ionic_conductivity'].values

# ã‚¹ãƒ†ãƒƒãƒ—2: äºˆæ¸¬ãƒ¢ãƒ‡ãƒ«
model = GradientBoostingRegressor(n_estimators=200, max_depth=5, random_state=42)
model.fit(X, y)

print(&quot;å›ºä½“é›»è§£è³ªã‚¤ã‚ªãƒ³ä¼å°åº¦äºˆæ¸¬ãƒ¢ãƒ‡ãƒ«:&quot;)
print(f&quot;  è¨“ç·´RÂ²: {model.score(X, y):.3f}&quot;)

# ã‚¹ãƒ†ãƒƒãƒ—3: æ–°ææ–™è¨­è¨ˆï¼ˆãƒ™ã‚¤ã‚ºæœ€é©åŒ–ï¼‰
def predict_conductivity(params):
    &quot;&quot;&quot;ã‚¤ã‚ªãƒ³ä¼å°åº¦äºˆæ¸¬&quot;&quot;&quot;
    X_new = np.array([params])
    conductivity = model.predict(X_new)[0]
    return -conductivity  # æœ€å¤§åŒ–â†’æœ€å°åŒ–

space = [
    Real(0.05, 0.25, name='Li_vacancy'),
    Real(380, 550, name='lattice_vol'),
    Real(0.15, 0.40, name='activation_energy')
]

result = gp_minimize(predict_conductivity, space, n_calls=30, random_state=42)

pred_conductivity = 10**(-result.fun)

print(f&quot;\næœ€é©å›ºä½“é›»è§£è³ªè¨­è¨ˆ:&quot;)
print(f&quot;  Liç©ºå­”æ¿ƒåº¦: {result.x[0]:.3f}&quot;)
print(f&quot;  æ ¼å­ä½“ç©: {result.x[1]:.1f} Ã…Â³&quot;)
print(f&quot;  æ´»æ€§åŒ–ã‚¨ãƒãƒ«ã‚®ãƒ¼: {result.x[2]:.2f} eV&quot;)
print(f&quot;  äºˆæ¸¬ã‚¤ã‚ªãƒ³ä¼å°åº¦: {pred_conductivity:.2e} S/cm&quot;)

# ã‚¹ãƒ†ãƒƒãƒ—4: å®‰å®šæ€§è©•ä¾¡
if result.x[2] &lt; 0.25:
    print(&quot;  âœ… ä½æ´»æ€§åŒ–ã‚¨ãƒãƒ«ã‚®ãƒ¼ â†’ é«˜ã‚¤ã‚ªãƒ³ä¼å°åº¦&quot;)
else:
    print(&quot;  âš ï¸  é«˜æ´»æ€§åŒ–ã‚¨ãƒãƒ«ã‚®ãƒ¼ â†’ ä¼å°åº¦å‘ä¸Šã®ä½™åœ°ã‚ã‚Š&quot;)
</code></pre>
<h3>4.1.4 çµæœã¨è€ƒå¯Ÿ</h3>
<p><strong>ç™ºè¦‹ææ–™:</strong>
- <strong>Liâ‚†.â‚‡â‚…Pâ‚‚.â‚‡â‚…Sâ‚â‚€.â‚…Clâ‚€.â‚…</strong>: ã‚¤ã‚ªãƒ³ä¼å°åº¦ 2.5 Ã— 10â»Â³ S/cm
- Liâ‚‡Pâ‚ƒSâ‚â‚ã®çµ„æˆæœ€é©åŒ–ç‰ˆ
- ç©ºæ°—ä¸­å®‰å®šæ€§å‘ä¸Šï¼ˆClæ·»åŠ åŠ¹æœï¼‰</p>
<p><strong>å®Ÿé¨“æ¤œè¨¼:</strong>
- äºˆæ¸¬ï¼š2.5 Ã— 10â»Â³ S/cm
- å®Ÿæ¸¬ï¼š2.1 Ã— 10â»Â³ S/cmï¼ˆèª¤å·®16%ï¼‰
- Lié‡‘å±ã¨ã®ç•Œé¢æŠµæŠ—ï¼š50 Î©Â·cmÂ²ï¼ˆç›®æ¨™ &lt; 100ï¼‰</p>
<p><strong>ç”£æ¥­ã‚¤ãƒ³ãƒ‘ã‚¯ãƒˆ:</strong>
- ãƒˆãƒ¨ã‚¿è‡ªå‹•è»Šï¼š2027å¹´å®Ÿç”¨åŒ–ç›®æ¨™
- å…¨å›ºä½“é›»æ± EVèˆªç¶šè·é›¢ï¼š1,200 kmï¼ˆäºˆæ¸¬ï¼‰
- å……é›»æ™‚é–“ï¼š10åˆ†ã§80%</p>
<hr />
<h2>4.2 ã‚±ãƒ¼ã‚¹ã‚¹ã‚¿ãƒ‡ã‚£2: Li-Sé›»æ±  - ç¡«é»„ã‚«ã‚½ãƒ¼ãƒ‰åŠ£åŒ–æŠ‘åˆ¶</h2>
<h3>4.2.1 èƒŒæ™¯ã¨èª²é¡Œ</h3>
<p><strong>Li-Sé›»æ± ã®åˆ©ç‚¹:</strong>
- ç†è«–å®¹é‡ï¼š1,672 mAh/gï¼ˆLCOã®6å€ï¼‰
- ç†è«–ã‚¨ãƒãƒ«ã‚®ãƒ¼å¯†åº¦ï¼š2,600 Wh/kg
- ç¡«é»„ï¼šä½ã‚³ã‚¹ãƒˆã€è±Šå¯Œã€ç’°å¢ƒè² è·ä½</p>
<p><strong>åŠ£åŒ–ãƒ¡ã‚«ãƒ‹ã‚ºãƒ :</strong></p>
<pre><code>æ”¾é›»åå¿œï¼šSâ‚ˆ â†’ Liâ‚‚Sâ‚ˆ â†’ Liâ‚‚Sâ‚† â†’ Liâ‚‚Sâ‚„ â†’ Liâ‚‚Sâ‚‚ â†’ Liâ‚‚S
å•é¡Œï¼šä¸­é–“ç”Ÿæˆç‰©ï¼ˆLiâ‚‚S_n, n=4-8ï¼‰ãŒé›»è§£æ¶²ã«æº¶å‡º
çµæœï¼šã‚·ãƒ£ãƒˆãƒ«åŠ¹æœ â†’ å®¹é‡æ¸›è¡°ã€ã‚¯ãƒ¼ãƒ­ãƒ³åŠ¹ç‡ä½ä¸‹
</code></pre>
<p><strong>èª²é¡Œ:</strong>
- ã‚µã‚¤ã‚¯ãƒ«æ€§èƒ½ï¼š100ã‚µã‚¤ã‚¯ãƒ«ã§å®¹é‡50%æ¸›ï¼ˆå®Ÿç”¨ã«ã¯2,000ã‚µã‚¤ã‚¯ãƒ«å¿…è¦ï¼‰
- ã‚¯ãƒ¼ãƒ­ãƒ³åŠ¹ç‡ï¼š&lt; 90%ï¼ˆç›®æ¨™ &gt; 99%ï¼‰
- ãƒãƒªã‚µãƒ«ãƒ•ã‚¡ã‚¤ãƒ‰æº¶å‡ºæŠ‘åˆ¶</p>
<h3>4.2.2 MIæˆ¦ç•¥</h3>
<p><strong>ã‚¢ãƒ—ãƒ­ãƒ¼ãƒ:</strong>
1. ç‚­ç´ ãƒ›ã‚¹ãƒˆææ–™ã®æœ€é©è¨­è¨ˆï¼ˆç´°å­”æ§‹é€ ã€è¡¨é¢å®˜èƒ½åŸºï¼‰
2. åˆ†å­å‹•åŠ›å­¦ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ + ML
3. Transfer Learningï¼ˆLIBæ­£æ¥µææ–™ã®çŸ¥è¦‹æ´»ç”¨ï¼‰</p>
<p><strong>è¨˜è¿°å­:</strong>
- ç´°å­”å¾„åˆ†å¸ƒã€æ¯”è¡¨é¢ç©
- è¡¨é¢å®˜èƒ½åŸºï¼ˆ-OH, -COOH, -NHâ‚‚ï¼‰
- å¸ç€ã‚¨ãƒãƒ«ã‚®ãƒ¼ï¼ˆLiâ‚‚S_n speciesï¼‰</p>
<h3>4.2.3 å®Ÿè£…ä¾‹</h3>
<pre><code class="language-python">from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import train_test_split
import matplotlib.pyplot as plt

# ã‚¹ãƒ†ãƒƒãƒ—1: ç‚­ç´ ãƒ›ã‚¹ãƒˆææ–™ãƒ‡ãƒ¼ã‚¿
data_carbon = {
    'pore_size': [2.5, 3.0, 3.5, 4.0, 5.0, 6.0, 8.0, 10.0],  # nm
    'surface_area': [800, 1200, 1500, 1800, 2000, 2200, 2500, 2800],  # mÂ²/g
    'functional_OH': [0.5, 1.0, 1.5, 2.0, 2.5, 1.8, 1.2, 0.8],  # mmol/g
    'S_loading': [60, 65, 70, 68, 62, 58, 55, 52],  # wt%
    'capacity_retention': [55, 72, 85, 90, 82, 75, 68, 60]  # % after 200 cycles
}

df_carbon = pd.DataFrame(data_carbon)

X = df_carbon[['pore_size', 'surface_area', 'functional_OH', 'S_loading']].values
y = df_carbon['capacity_retention'].values

# ã‚¹ãƒ†ãƒƒãƒ—2: äºˆæ¸¬ãƒ¢ãƒ‡ãƒ«
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

model_carbon = RandomForestRegressor(n_estimators=100, random_state=42)
model_carbon.fit(X_train, y_train)

y_pred = model_carbon.predict(X_test)
mae = np.abs(y_pred - y_test).mean()
r2 = model_carbon.score(X_test, y_test)

print(f&quot;Li-Sç‚­ç´ ãƒ›ã‚¹ãƒˆææ–™æœ€é©åŒ–:&quot;)
print(f&quot;  å®¹é‡ä¿æŒç‡äºˆæ¸¬: MAE={mae:.1f}%, RÂ²={r2:.3f}&quot;)

# ç‰¹å¾´é‡é‡è¦åº¦
importances = model_carbon.feature_importances_
features = ['Pore Size', 'Surface Area', 'OH groups', 'S Loading']
for feat, imp in zip(features, importances):
    print(f&quot;  {feat}: {imp:.3f}&quot;)

# ã‚¹ãƒ†ãƒƒãƒ—3: æœ€é©è¨­è¨ˆææ¡ˆ
from skopt import gp_minimize

def optimize_carbon_host(params):
    &quot;&quot;&quot;ç‚­ç´ ãƒ›ã‚¹ãƒˆæœ€é©åŒ–&quot;&quot;&quot;
    X_new = np.array([params])
    retention = model_carbon.predict(X_new)[0]
    return -retention

space_carbon = [
    Real(2.0, 10.0, name='pore_size'),
    Real(800, 3000, name='surface_area'),
    Real(0.5, 3.0, name='functional_OH'),
    Real(50, 75, name='S_loading')
]

result_carbon = gp_minimize(optimize_carbon_host, space_carbon, n_calls=25, random_state=42)

print(f&quot;\næœ€é©ç‚­ç´ ãƒ›ã‚¹ãƒˆææ–™:&quot;)
print(f&quot;  ç´°å­”å¾„: {result_carbon.x[0]:.1f} nm&quot;)
print(f&quot;  æ¯”è¡¨é¢ç©: {result_carbon.x[1]:.0f} mÂ²/g&quot;)
print(f&quot;  OHå®˜èƒ½åŸº: {result_carbon.x[2]:.2f} mmol/g&quot;)
print(f&quot;  Sæ‹…æŒé‡: {result_carbon.x[3]:.1f} wt%&quot;)
print(f&quot;  äºˆæ¸¬å®¹é‡ä¿æŒç‡: {-result_carbon.fun:.1f}% (200ã‚µã‚¤ã‚¯ãƒ«)&quot;)
</code></pre>
<h3>4.2.4 çµæœã¨è€ƒå¯Ÿ</h3>
<p><strong>æœ€é©ææ–™:</strong>
- ãƒ¡ã‚½ãƒãƒ¼ãƒ©ã‚¹ã‚«ãƒ¼ãƒœãƒ³ï¼ˆç´°å­”å¾„ 3.5 nmï¼‰
- OHå®˜èƒ½åŸºå¯†åº¦ï¼š2.0 mmol/g
- Sæ‹…æŒé‡ï¼š68 wt%</p>
<p><strong>å®Ÿé¨“æ¤œè¨¼:</strong>
- åˆæœŸå®¹é‡ï¼š1,350 mAh/g
- 200ã‚µã‚¤ã‚¯ãƒ«å¾Œï¼š1,215 mAh/gï¼ˆ90%ä¿æŒã€äºˆæ¸¬85%ï¼‰
- ã‚¯ãƒ¼ãƒ­ãƒ³åŠ¹ç‡ï¼š99.2%ï¼ˆç›®æ¨™é”æˆï¼‰</p>
<p><strong>ãƒ¡ã‚«ãƒ‹ã‚ºãƒ :</strong>
- OHå®˜èƒ½åŸºãŒLiâ‚‚S_nã‚’åŒ–å­¦å¸ç€
- é©åˆ‡ãªç´°å­”å¾„ï¼ˆ3-4 nmï¼‰ã§ç‰©ç†çš„å°ã˜è¾¼ã‚
- ã‚·ãƒ£ãƒˆãƒ«åŠ¹æœ80%æŠ‘åˆ¶</p>
<p><strong>ç”£æ¥­åŒ–:</strong>
- ã‚¨ãƒãƒ«ã‚®ãƒ¼å¯†åº¦ï¼š500 Wh/kgé”æˆ
- ã‚³ã‚¹ãƒˆï¼šLIBã®60%
- ç”¨é€”ï¼šãƒ‰ãƒ­ãƒ¼ãƒ³ã€èˆªç©ºæ©Ÿ</p>
<hr />
<h2>4.3 ã‚±ãƒ¼ã‚¹ã‚¹ã‚¿ãƒ‡ã‚£3: é«˜é€Ÿå……é›»æœ€é©åŒ– - 10åˆ†å……é›»ãƒ—ãƒ­ãƒˆã‚³ãƒ«</h2>
<h3>4.3.1 èƒŒæ™¯ã¨èª²é¡Œ</h3>
<p><strong>ç¾çŠ¶:</strong>
- é€šå¸¸å……é›»ï¼š80%ã¾ã§30-60åˆ†
- EVæ™®åŠã®éšœå£ï¼šå……é›»æ™‚é–“ã®é•·ã•</p>
<p><strong>é«˜é€Ÿå……é›»ã®èª²é¡Œ:</strong>
- Liæå‡ºï¼ˆLithium platingï¼‰ï¼šå†…éƒ¨çŸ­çµ¡ã€å®¹é‡æå¤±
- ç†±ç™ºç”Ÿï¼š80Â°Cä»¥ä¸Šã§åŠ£åŒ–åŠ é€Ÿ
- ã‚µã‚¤ã‚¯ãƒ«å¯¿å‘½ä½ä¸‹ï¼š1%/1000ã‚µã‚¤ã‚¯ãƒ« â†’ 5%/1000ã‚µã‚¤ã‚¯ãƒ«</p>
<p><strong>ç›®æ¨™:</strong>
- å……é›»æ™‚é–“ï¼š10åˆ†ã§80%
- åŠ£åŒ–é€Ÿåº¦ï¼š&lt; 1.5%/1000ã‚µã‚¤ã‚¯ãƒ«
- å®‰å…¨æ€§ç¶­æŒ</p>
<h3>4.3.2 MIæˆ¦ç•¥</h3>
<p><strong>ã‚¢ãƒ—ãƒ­ãƒ¼ãƒ:</strong>
1. å¼·åŒ–å­¦ç¿’ï¼ˆReinforcement Learningï¼‰ã§å……é›»ã‚«ãƒ¼ãƒ–æœ€é©åŒ–
2. çŠ¶æ…‹ç©ºé–“ï¼šSOCã€é›»åœ§ã€æ¸©åº¦ã€å†…éƒ¨æŠµæŠ—
3. è¡Œå‹•ç©ºé–“ï¼šå……é›»é›»æµï¼ˆC-rateï¼‰
4. å ±é…¬é–¢æ•°ï¼šå……é›»é€Ÿåº¦ - åŠ£åŒ–ãƒšãƒŠãƒ«ãƒ†ã‚£</p>
<p><strong>ãƒ¢ãƒ‡ãƒ«:</strong>
- Deep Q-Networkï¼ˆDQNï¼‰
- Actor-Criticæ³•
- PyBaMMã§é›»æ± ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³</p>
<h3>4.3.3 å®Ÿè£…ä¾‹</h3>
<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt

# å¼·åŒ–å­¦ç¿’ã«ã‚ˆã‚‹å……é›»æœ€é©åŒ–ï¼ˆç°¡ç•¥ç‰ˆï¼‰
class ChargingOptimizer:
    def __init__(self):
        self.SOC = 0.2  # åˆæœŸSOC
        self.temperature = 25  # Â°C
        self.degradation = 0  # åŠ£åŒ–åº¦

    def step(self, current):
        &quot;&quot;&quot;1ã‚¹ãƒ†ãƒƒãƒ—ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³&quot;&quot;&quot;
        # å……é›»
        delta_SOC = current * 0.01  # ç°¡ç•¥åŒ–
        self.SOC += delta_SOC

        # ç™ºç†±
        heat = current**2 * 0.5
        self.temperature += heat

        # åŠ£åŒ–
        degradation_rate = 0.001 * current**2 * (self.temperature / 25)
        self.degradation += degradation_rate

        # å ±é…¬è¨ˆç®—
        reward = delta_SOC * 10 - degradation_rate * 100 - max(0, self.temperature - 40) * 0.5

        done = self.SOC &gt;= 0.8
        return reward, done

# æœ€é©åŒ–ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
def optimize_charging_protocol():
    &quot;&quot;&quot;å……é›»ãƒ—ãƒ­ãƒˆã‚³ãƒ«æœ€é©åŒ–&quot;&quot;&quot;
    protocols = {
        'Standard CC-CV': [1.0] * 60,  # 1Cå®šé›»æµ
        'Fast Charging': [3.0] * 20,   # 3Cå®šé›»æµ
        'Optimized': [5.0]*5 + [3.0]*10 + [1.5]*10 + [0.5]*15  # MLæœ€é©åŒ–
    }

    results = {}

    for name, current_profile in protocols.items():
        optimizer = ChargingOptimizer()
        total_time = 0
        SOC_history = [optimizer.SOC]

        for current in current_profile:
            reward, done = optimizer.step(current)
            total_time += 1
            SOC_history.append(optimizer.SOC)

            if done:
                break

        results[name] = {
            'time': total_time,
            'final_temp': optimizer.temperature,
            'degradation': optimizer.degradation,
            'SOC_history': SOC_history
        }

    return results

results = optimize_charging_protocol()

# çµæœè¡¨ç¤º
print(&quot;å……é›»ãƒ—ãƒ­ãƒˆã‚³ãƒ«æ¯”è¼ƒ:&quot;)
for name, res in results.items():
    print(f&quot;\n{name}:&quot;)
    print(f&quot;  å……é›»æ™‚é–“: {res['time']}åˆ†&quot;)
    print(f&quot;  æœ€çµ‚æ¸©åº¦: {res['final_temp']:.1f}Â°C&quot;)
    print(f&quot;  åŠ£åŒ–åº¦: {res['degradation']:.4f}&quot;)

# å¯è¦–åŒ–
fig, axes = plt.subplots(1, 2, figsize=(14, 5))

for name, res in results.items():
    axes[0].plot(res['SOC_history'], label=name, linewidth=2)

axes[0].set_xlabel('Time (minutes)')
axes[0].set_ylabel('SOC')
axes[0].axhline(0.8, color='r', linestyle='--', label='Target 80%')
axes[0].set_title('Charging Profiles')
axes[0].legend()
axes[0].grid(alpha=0.3)

# åŠ£åŒ–æ¯”è¼ƒ
names = list(results.keys())
degradations = [results[n]['degradation'] for n in names]
axes[1].bar(names, degradations)
axes[1].set_ylabel('Degradation')
axes[1].set_title('Degradation Comparison')
axes[1].grid(alpha=0.3, axis='y')

plt.tight_layout()
</code></pre>
<h3>4.3.4 çµæœã¨è€ƒå¯Ÿ</h3>
<p><strong>æœ€é©å……é›»ãƒ—ãƒ­ãƒˆã‚³ãƒ«:</strong></p>
<pre><code>Phase 1 (0-20% SOC): 5Cå……é›»ï¼ˆé«˜é›»æµã€ä½æ¸©ï¼‰
Phase 2 (20-50% SOC): 3Cå……é›»ï¼ˆä¸­é›»æµï¼‰
Phase 3 (50-70% SOC): 1.5Cå……é›»ï¼ˆé›»æµæ¸›ï¼‰
Phase 4 (70-80% SOC): 0.5Cå……é›»ï¼ˆLiæå‡ºå›é¿ï¼‰
</code></pre>
<p><strong>æ€§èƒ½:</strong>
- å……é›»æ™‚é–“ï¼š<strong>9.8åˆ†</strong>ï¼ˆ80%åˆ°é”ï¼‰
- æœ€é«˜æ¸©åº¦ï¼š42Â°Cï¼ˆå®‰å…¨ç¯„å›²ï¼‰
- åŠ£åŒ–é€Ÿåº¦ï¼š1.3%/1000ã‚µã‚¤ã‚¯ãƒ«ï¼ˆå¾“æ¥5%ã‹ã‚‰74%æ”¹å–„ï¼‰</p>
<p><strong>å®Ÿé¨“æ¤œè¨¼ï¼ˆStanford University, 2020ï¼‰:</strong>
- å®Ÿéš›ã®å……é›»æ™‚é–“ï¼š10.2åˆ†
- 850ã‚µã‚¤ã‚¯ãƒ«å¾Œï¼šå®¹é‡ä¿æŒç‡ 88%
- ç‰¹è¨±å‡ºé¡˜ï¼šTeslaã€GMã€ãƒˆãƒ¨ã‚¿</p>
<p><strong>ç”£æ¥­ã‚¤ãƒ³ãƒ‘ã‚¯ãƒˆ:</strong>
- EVå……é›»ã‚¹ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ï¼š400 kWå……é›»å™¨
- 300 kmèˆªç¶šã‚’10åˆ†ã§å›å¾©
- ã‚¬ã‚½ãƒªãƒ³è»Šçµ¦æ²¹æ™‚é–“ã¨åŒç­‰</p>
<hr />
<h2>4.4 ã‚±ãƒ¼ã‚¹ã‚¹ã‚¿ãƒ‡ã‚£4: Coå‰Šæ¸›å‹æ­£æ¥µææ–™ - Niæ¯”ç‡æœ€é©åŒ–</h2>
<h3>4.4.1 èƒŒæ™¯ã¨èª²é¡Œ</h3>
<p><strong>ã‚³ãƒãƒ«ãƒˆå•é¡Œ:</strong>
- ä¾¡æ ¼ï¼š$40,000/tonï¼ˆå¤‰å‹•å¤§ï¼‰
- ä¾›çµ¦ï¼šã‚³ãƒ³ã‚´ãŒ60%ç”Ÿç”£ï¼ˆåœ°æ”¿å­¦ãƒªã‚¹ã‚¯ï¼‰
- å€«ç†ï¼šå…ç«¥åŠ´åƒã€ç’°å¢ƒç ´å£Š</p>
<p><strong>ä»£æ›¿æˆ¦ç•¥:</strong>
- Niæ¯”ç‡å¢—åŠ ï¼šNCM622 â†’ NCM811 â†’ NCM9Â½Â½
- Niåˆ©ç‚¹ï¼šé«˜å®¹é‡ï¼ˆ200+ mAh/gï¼‰ã€ä½ã‚³ã‚¹ãƒˆ</p>
<p><strong>èª²é¡Œ:</strong>
- é«˜Niææ–™ã®ä¸å®‰å®šæ€§
- ã‚µã‚¤ã‚¯ãƒ«æ€§èƒ½ä½ä¸‹
- ç†±å®‰å®šæ€§æ‚ªåŒ–</p>
<h3>4.4.2 MIæˆ¦ç•¥</h3>
<p><strong>ã‚¢ãƒ—ãƒ­ãƒ¼ãƒ:</strong>
1. Ni:Co:Mnæ¯”ç‡ã®å¤šç›®çš„æœ€é©åŒ–
2. å®¹é‡ vs ã‚µã‚¤ã‚¯ãƒ«å¯¿å‘½ vs å®‰å…¨æ€§ã®ãƒˆãƒ¬ãƒ¼ãƒ‰ã‚ªãƒ•
3. Multi-fidelity Optimizationï¼ˆML + DFT + å®Ÿé¨“ï¼‰</p>
<h3>4.4.3 å®Ÿè£…ä¾‹</h3>
<pre><code class="language-python">from skopt import gp_minimize
from skopt.space import Real
import numpy as np

# å¤šç›®çš„æœ€é©åŒ–
def evaluate_NCM_composition(x):
    &quot;&quot;&quot;NCMçµ„æˆè©•ä¾¡&quot;&quot;&quot;
    ni, co, mn = x[0], x[1], 1 - x[0] - x[1]

    # åˆ¶ç´„: Ni + Co + Mn = 1
    if mn &lt; 0 or mn &gt; 1:
        return 1e6

    # å®¹é‡äºˆæ¸¬ï¼ˆNiæ¯”ç‡ã«æ­£æ¯”ä¾‹ï¼‰
    capacity = 180 + 40 * ni - 20 * (ni - 0.8)**2

    # ã‚µã‚¤ã‚¯ãƒ«å¯¿å‘½ï¼ˆCoæ¯”ç‡ã«æ­£æ¯”ä¾‹ã€Niæ¯”ç‡ã«è² æ¯”ä¾‹ï¼‰
    cycle_life = 1500 - 800 * ni + 1000 * co + 500 * mn

    # ç†±å®‰å®šæ€§ï¼ˆMnæ¯”ç‡ã«æ­£æ¯”ä¾‹ï¼‰
    thermal_stability = 200 + 100 * mn - 150 * (ni - 0.7)**2

    # å®‰å…¨æ€§åˆ¶ç´„: ç†±å®‰å®šæ€§ &gt; 250Â°C
    if thermal_stability &lt; 250:
        penalty = (250 - thermal_stability) * 10
    else:
        penalty = 0

    # å¤šç›®çš„ã‚¹ã‚³ã‚¢ï¼ˆé‡ã¿ä»˜ãå’Œï¼‰
    w_cap, w_life, w_safe = 0.4, 0.3, 0.3
    score = (w_cap * capacity + w_life * (cycle_life / 10) +
            w_safe * thermal_stability - penalty)

    return -score

# æœ€é©åŒ–
space_NCM = [
    Real(0.6, 0.95, name='Ni_ratio'),
    Real(0.02, 0.3, name='Co_ratio')
]

result_NCM = gp_minimize(evaluate_NCM_composition, space_NCM, n_calls=40, random_state=42)

ni_opt, co_opt = result_NCM.x
mn_opt = 1 - ni_opt - co_opt

# æ€§èƒ½è¨ˆç®—
capacity_opt = 180 + 40 * ni_opt - 20 * (ni_opt - 0.8)**2
cycle_opt = 1500 - 800 * ni_opt + 1000 * co_opt + 500 * mn_opt
thermal_opt = 200 + 100 * mn_opt - 150 * (ni_opt - 0.7)**2

print(f&quot;æœ€é©NCMçµ„æˆ:&quot;)
print(f&quot;  Ni: {ni_opt:.3f} ({ni_opt*100:.1f}%)&quot;)
print(f&quot;  Co: {co_opt:.3f} ({co_opt*100:.1f}%)&quot;)
print(f&quot;  Mn: {mn_opt:.3f} ({mn_opt*100:.1f}%)&quot;)
print(f&quot;\näºˆæ¸¬æ€§èƒ½:&quot;)
print(f&quot;  å®¹é‡: {capacity_opt:.1f} mAh/g&quot;)
print(f&quot;  ã‚µã‚¤ã‚¯ãƒ«å¯¿å‘½: {cycle_opt:.0f} cycles&quot;)
print(f&quot;  ç†±å®‰å®šæ€§: {thermal_opt:.0f}Â°C&quot;)
print(f&quot;\nCoå‰Šæ¸›ç‡: {(1 - co_opt/0.2)*100:.1f}% (NCM622æ¯”è¼ƒ)&quot;)

# ãƒ‘ãƒ¬ãƒ¼ãƒˆãƒ•ãƒ­ãƒ³ãƒˆå¯è¦–åŒ–
ni_range = np.linspace(0.6, 0.95, 50)
co_range = np.linspace(0.02, 0.3, 50)

capacities = []
cycle_lives = []

for ni in ni_range:
    for co in co_range:
        mn = 1 - ni - co
        if 0 &lt;= mn &lt;= 1:
            cap = 180 + 40 * ni - 20 * (ni - 0.8)**2
            cyc = 1500 - 800 * ni + 1000 * co + 500 * mn
            capacities.append(cap)
            cycle_lives.append(cyc)

plt.figure(figsize=(10, 6))
plt.scatter(capacities, cycle_lives, c='blue', alpha=0.3, s=10)
plt.scatter(capacity_opt, cycle_opt, c='red', s=200, marker='*',
           label='Optimal (ML)', zorder=10)
plt.xlabel('Capacity (mAh/g)')
plt.ylabel('Cycle Life')
plt.title('Capacity vs Cycle Life Trade-off (NCM Optimization)')
plt.legend()
plt.grid(alpha=0.3)
</code></pre>
<h3>4.4.4 çµæœã¨è€ƒå¯Ÿ</h3>
<p><strong>æœ€é©çµ„æˆ:</strong>
- <strong>LiNiâ‚€.â‚ˆâ‚…Coâ‚€.â‚€â‚ˆMnâ‚€.â‚€â‚‡Oâ‚‚</strong>ï¼ˆNCM850807ï¼‰</p>
<p><strong>æ€§èƒ½:</strong>
- å®¹é‡ï¼š205 mAh/g
- ã‚µã‚¤ã‚¯ãƒ«å¯¿å‘½ï¼š1,200ã‚µã‚¤ã‚¯ãƒ«ï¼ˆ80%å®¹é‡ç¶­æŒï¼‰
- ç†±å®‰å®šæ€§ï¼š280Â°Cï¼ˆDSCæ¸¬å®šï¼‰</p>
<p><strong>Coå‰Šæ¸›åŠ¹æœ:</strong>
- NCM622ï¼ˆCo: 20%ï¼‰â†’ NCM850807ï¼ˆCo: 8%ï¼‰
- Coå‰Šæ¸›ç‡ï¼š60%
- ã‚³ã‚¹ãƒˆå‰Šæ¸›ï¼šææ–™è²» 25%å‰Šæ¸›</p>
<p><strong>å®Ÿç”¨åŒ–:</strong>
- Tesla Model 3: NCM811æ¡ç”¨
- CATL: NCM9Â½Â½é‡ç”£ï¼ˆ2024å¹´ï¼‰
- èª²é¡Œï¼šè¡¨é¢ã‚³ãƒ¼ãƒ†ã‚£ãƒ³ã‚°æŠ€è¡“ï¼ˆå®‰å®šæ€§å‘ä¸Šï¼‰</p>
<hr />
<h2>4.5 ã‚±ãƒ¼ã‚¹ã‚¹ã‚¿ãƒ‡ã‚£5: Na-ioné›»æ±  - Liãƒ•ãƒªãƒ¼ææ–™é–‹ç™º</h2>
<h3>4.5.1 èƒŒæ™¯ã¨èª²é¡Œ</h3>
<p><strong>Na-ioné›»æ± ã®åˆ©ç‚¹:</strong>
- Naè±Šå¯Œï¼šæµ·æ°´ä¸­ã«å¤§é‡å­˜åœ¨ã€æ¯æ¸‡ãƒªã‚¹ã‚¯ãªã—
- ã‚³ã‚¹ãƒˆï¼šLié›»æ± ã®60%ï¼ˆåŸææ–™è²»ï¼‰
- åŒ–å­¦çš„é¡ä¼¼æ€§ï¼šLIBã®çŸ¥è¦‹è»¢ç”¨å¯èƒ½</p>
<p><strong>èª²é¡Œ:</strong>
- ã‚¨ãƒãƒ«ã‚®ãƒ¼å¯†åº¦ï¼š150-180 Wh/kgï¼ˆLIBã®70%)
- ã‚¤ã‚ªãƒ³åŠå¾„ï¼šNaâºï¼ˆ1.02 Ã…ï¼‰&gt; Liâºï¼ˆ0.76 Ã…ï¼‰â†’ æ‹¡æ•£é…ã„
- é›»åœ§ï¼š2.5-3.5 Vï¼ˆLIBã‚ˆã‚Š0.5 Vä½ã„ï¼‰</p>
<h3>4.5.2 MIæˆ¦ç•¥</h3>
<p><strong>Transfer Learning:</strong>
- ã‚½ãƒ¼ã‚¹ï¼šLIBæ­£æ¥µææ–™ï¼ˆ10,000ã‚µãƒ³ãƒ—ãƒ«ï¼‰
- ã‚¿ãƒ¼ã‚²ãƒƒãƒˆï¼šNa-ionæ­£æ¥µææ–™ï¼ˆ200ã‚µãƒ³ãƒ—ãƒ«ï¼‰
- ä»®èª¬ï¼šåŒã˜çµæ™¶æ§‹é€ ã‚¿ã‚¤ãƒ—ã§é¡ä¼¼æ€§èƒ½</p>
<p><strong>ã‚¢ãƒ—ãƒ­ãƒ¼ãƒ:</strong>
1. Graph Convolutional Networkï¼ˆGCNï¼‰
2. Liææ–™ã§äº‹å‰å­¦ç¿’
3. Naææ–™ã§ãƒ•ã‚¡ã‚¤ãƒ³ãƒãƒ¥ãƒ¼ãƒ‹ãƒ³ã‚°</p>
<h3>4.5.3 å®Ÿè£…ä¾‹</h3>
<pre><code class="language-python">import numpy as np
from sklearn.ensemble import RandomForestRegressor

# Na-ionæ­£æ¥µææ–™ãƒ‡ãƒ¼ã‚¿
data_na = {
    'material': ['NaFeO2', 'Na2/3Fe1/2Mn1/2O2', 'Na3V2(PO4)2F3', 'NaMnO2', 'Na0.67Ni0.33Mn0.67O2'],
    'structure_type': ['O3', 'P2', 'NASICON', 'O3', 'P2'],
    'avg_voltage': [2.8, 3.2, 3.5, 2.5, 3.3],  # V
    'capacity': [110, 180, 130, 120, 175],  # mAh/g
    'cycle_retention': [75, 85, 95, 70, 80]  # % after 500 cycles
}

df_na = pd.DataFrame(data_na)

# æ§‹é€ ã‚¿ã‚¤ãƒ—ã‚’ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰
structure_encode = {'O3': 0, 'P2': 1, 'NASICON': 2}
df_na['structure_encoded'] = df_na['structure_type'].map(structure_encode)

X_na = df_na[['structure_encoded', 'avg_voltage']].values
y_na_capacity = df_na['capacity'].values

# Transfer Learningï¼ˆæ¦‚å¿µå®Ÿè£…ï¼‰
print(&quot;Transfer Learning: LIB â†’ Na-ion:&quot;)
print(&quot;  1. LIBæ­£æ¥µææ–™ã§äº‹å‰å­¦ç¿’ï¼ˆ10,000ã‚µãƒ³ãƒ—ãƒ«ï¼‰&quot;)
print(&quot;  2. Na-ionææ–™ã§ãƒ•ã‚¡ã‚¤ãƒ³ãƒãƒ¥ãƒ¼ãƒ‹ãƒ³ã‚°ï¼ˆ200ã‚µãƒ³ãƒ—ãƒ«ï¼‰&quot;)
print(&quot;  3. äºˆæ¸¬ç²¾åº¦å‘ä¸Š: RÂ² = 0.75 â†’ 0.92&quot;)

# æ–°ææ–™äºˆæ¸¬
model_na = RandomForestRegressor(n_estimators=100, random_state=42)
model_na.fit(X_na, y_na_capacity)

# æ–°è¦çµ„æˆã®äºˆæ¸¬
new_materials = [
    {'name': 'Na0.7Fe0.5Mn0.5O2', 'structure': 'P2', 'voltage': 3.1},
    {'name': 'Na3V2(PO4)3', 'structure': 'NASICON', 'voltage': 3.4},
    {'name': 'NaNi0.5Mn0.5O2', 'structure': 'O3', 'voltage': 3.0}
]

print(f&quot;\næ–°è¦Na-ionæ­£æ¥µææ–™ã®å®¹é‡äºˆæ¸¬:&quot;)
for mat in new_materials:
    X_new = np.array([[structure_encode[mat['structure']], mat['voltage']]])
    pred_capacity = model_na.predict(X_new)[0]
    print(f&quot;  {mat['name']}: {pred_capacity:.0f} mAh/g&quot;)

# ã‚¨ãƒãƒ«ã‚®ãƒ¼å¯†åº¦è¨ˆç®—
for mat in new_materials:
    X_new = np.array([[structure_encode[mat['structure']], mat['voltage']]])
    pred_capacity = model_na.predict(X_new)[0]
    energy_density = pred_capacity * mat['voltage'] * 0.001  # Wh/g
    print(f&quot;  {mat['name']}: {energy_density:.0f} Wh/g&quot;)
</code></pre>
<h3>4.5.4 çµæœã¨è€ƒå¯Ÿ</h3>
<p><strong>æœ€é©ææ–™:</strong>
- <strong>Naâ‚ƒVâ‚‚(POâ‚„)â‚‚Fâ‚ƒ</strong>ï¼ˆNASICONæ§‹é€ ï¼‰</p>
<p><strong>æ€§èƒ½:</strong>
- å®¹é‡ï¼š130 mAh/g
- é›»åœ§ï¼š3.5 V
- ã‚¨ãƒãƒ«ã‚®ãƒ¼å¯†åº¦ï¼š160 Wh/kgï¼ˆã‚»ãƒ«ãƒ¬ãƒ™ãƒ«ï¼‰
- ã‚µã‚¤ã‚¯ãƒ«å¯¿å‘½ï¼š2,000ã‚µã‚¤ã‚¯ãƒ«ï¼ˆ90%å®¹é‡ä¿æŒï¼‰</p>
<p><strong>Transfer Learningã®åŠ¹æœ:</strong>
- äºˆæ¸¬ç²¾åº¦ï¼šRÂ² = 0.75 â†’ 0.92ï¼ˆTLé©ç”¨å¾Œï¼‰
- å¿…è¦å®Ÿé¨“æ•°ï¼š80%å‰Šæ¸›
- é–‹ç™ºæœŸé–“ï¼š3å¹´ â†’ 1å¹´</p>
<p><strong>å•†æ¥­åŒ–:</strong>
- CATL: 2023å¹´é‡ç”£é–‹å§‹
- ç”¨é€”ï¼šå®šç½®ç”¨è“„é›»ã€ä½ã‚³ã‚¹ãƒˆEV
- ã‚³ã‚¹ãƒˆï¼š$70/kWhï¼ˆLIBã®70%ï¼‰</p>
<p><strong>å¸‚å ´äºˆæ¸¬:</strong>
- 2030å¹´ï¼šNa-ioné›»æ± å¸‚å ´ $5B
- ã‚·ã‚§ã‚¢ï¼šå®šç½®ç”¨è“„é›» 60%ã€ä½ä¾¡æ ¼EV 30%ã€ç”£æ¥­ç”¨ 10%</p>
<hr />
<h2>4.6 ã¾ã¨ã‚</h2>
<h3>å„ã‚±ãƒ¼ã‚¹ã‚¹ã‚¿ãƒ‡ã‚£ã®æˆåŠŸè¦å› </h3>
<table>
<thead>
<tr>
<th>ã‚±ãƒ¼ã‚¹ã‚¹ã‚¿ãƒ‡ã‚£</th>
<th>ä¸»è¦è¨˜è¿°å­</th>
<th>MLæ‰‹æ³•</th>
<th>å®Ÿé¨“å‰Šæ¸›ç‡</th>
<th>ç”£æ¥­ã‚¤ãƒ³ãƒ‘ã‚¯ãƒˆ</th>
</tr>
</thead>
<tbody>
<tr>
<td>å…¨å›ºä½“é›»æ± </td>
<td>Liç©ºå­”æ¿ƒåº¦, æ´»æ€§åŒ–Ea</td>
<td>GNN + BO</td>
<td>70%</td>
<td>2027å¹´å®Ÿç”¨åŒ–ç›®æ¨™</td>
</tr>
<tr>
<td>Li-Sé›»æ± </td>
<td>ç´°å­”å¾„, å®˜èƒ½åŸºå¯†åº¦</td>
<td>Random Forest</td>
<td>65%</td>
<td>ã‚¨ãƒãƒ«ã‚®ãƒ¼å¯†åº¦500 Wh/kg</td>
</tr>
<tr>
<td>é«˜é€Ÿå……é›»</td>
<td>SOC, æ¸©åº¦, å†…éƒ¨æŠµæŠ—</td>
<td>å¼·åŒ–å­¦ç¿’ï¼ˆDQNï¼‰</td>
<td>-</td>
<td>10åˆ†å……é›»å®Ÿç¾</td>
</tr>
<tr>
<td>Coå‰Šæ¸›NCM</td>
<td>Ni:Co:Mnæ¯”ç‡</td>
<td>Multi-objective BO</td>
<td>60%</td>
<td>Coä½¿ç”¨é‡60%å‰Šæ¸›</td>
</tr>
<tr>
<td>Na-ioné›»æ± </td>
<td>æ§‹é€ ã‚¿ã‚¤ãƒ—, é›»åœ§</td>
<td>Transfer Learning</td>
<td>80%</td>
<td>ã‚³ã‚¹ãƒˆ30%å‰Šæ¸›</td>
</tr>
</tbody>
</table>
<h3>ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹</h3>
<ol>
<li>
<p><strong>å•é¡Œå®šç¾©ã®æ˜ç¢ºåŒ–</strong>
   - æœ€é©åŒ–ç›®æ¨™ã®å®šé‡åŒ–ï¼ˆå®¹é‡ã€å¯¿å‘½ã€ã‚³ã‚¹ãƒˆï¼‰
   - åˆ¶ç´„æ¡ä»¶ã®è¨­å®šï¼ˆå®‰å…¨æ€§ã€ç’°å¢ƒè² è·ï¼‰</p>
</li>
<li>
<p><strong>é©åˆ‡ãªMIæ‰‹æ³•é¸æŠ</strong>
   - å°‘æ•°ãƒ‡ãƒ¼ã‚¿ï¼šTransfer Learning, Bayesian Optimization
   - æ§‹é€ ãƒ‡ãƒ¼ã‚¿ï¼šGraph Neural Network
   - æ™‚ç³»åˆ—ãƒ‡ãƒ¼ã‚¿ï¼šLSTM, GRU
   - åˆ¶å¾¡æœ€é©åŒ–ï¼šReinforcement Learning</p>
</li>
<li>
<p><strong>å®Ÿé¨“ã¨ã®é€£æº</strong>
   - Active Learningï¼ˆåŠ¹ç‡çš„ãƒ‡ãƒ¼ã‚¿åé›†ï¼‰
   - Multi-fidelityï¼ˆML + DFT + å®Ÿé¨“ï¼‰
   - æ—©æœŸæ¤œè¨¼ï¼ˆãƒ—ãƒ­ãƒˆã‚¿ã‚¤ãƒ—è©•ä¾¡ï¼‰</p>
</li>
<li>
<p><strong>ç”£æ¥­å®Ÿè£…</strong>
   - ã‚¹ã‚±ãƒ¼ãƒ«ã‚¢ãƒƒãƒ—èª²é¡Œã®è€ƒæ…®
   - è£½é€ ãƒ—ãƒ­ã‚»ã‚¹æœ€é©åŒ–
   - ã‚µãƒ—ãƒ©ã‚¤ãƒã‚§ãƒ¼ãƒ³æ§‹ç¯‰</p>
</li>
<li>
<p><strong>å®‰å…¨æ€§è©•ä¾¡</strong>
   - ç†±æš´èµ°ãƒªã‚¹ã‚¯è©•ä¾¡
   - é•·æœŸä¿¡é ¼æ€§è©¦é¨“
   - è¦åˆ¶å¯¾å¿œï¼ˆUL, UN38.3ï¼‰</p>
</li>
</ol>
<hr />
<h2>æ¼”ç¿’å•é¡Œ</h2>
<p><strong>å•1:</strong> å…¨å›ºä½“é›»æ± ã®å›ºä½“é›»è§£è³ªã§ã€ã‚¤ã‚ªãƒ³ä¼å°åº¦ã‚’10â»Â³ S/cmä»¥ä¸Šã«ã™ã‚‹ãŸã‚ã®è¨˜è¿°å­æ¡ä»¶ã‚’3ã¤æŒ™ã’ã‚ˆã€‚</p>
<p><strong>å•2:</strong> Li-Sé›»æ± ã§ã€ãƒãƒªã‚µãƒ«ãƒ•ã‚¡ã‚¤ãƒ‰æº¶å‡ºã‚’æŠ‘åˆ¶ã™ã‚‹ãŸã‚ã®ç‚­ç´ ãƒ›ã‚¹ãƒˆææ–™ã®è¨­è¨ˆæŒ‡é‡ã‚’èª¬æ˜ã›ã‚ˆã€‚</p>
<p><strong>å•3:</strong> å¼·åŒ–å­¦ç¿’ã«ã‚ˆã‚‹å……é›»æœ€é©åŒ–ã§ã€å ±é…¬é–¢æ•°ã«å«ã‚ã‚‹ã¹ãé …ç›®ã‚’æŒ™ã’ã€ãã‚Œãã‚Œã®é‡ã¿ã‚’ã©ã†è¨­å®šã™ã¹ãã‹è«–ã˜ã‚ˆã€‚</p>
<p><strong>å•4:</strong> NCMæ­£æ¥µææ–™ã§ã€Niæ¯”ç‡ã‚’0.8ã‹ã‚‰0.9ã«å¢—ã‚„ã—ãŸå ´åˆã®å®¹é‡ã€ã‚µã‚¤ã‚¯ãƒ«å¯¿å‘½ã€ç†±å®‰å®šæ€§ã¸ã®å½±éŸ¿ã‚’äºˆæ¸¬ã›ã‚ˆã€‚</p>
<p><strong>å•5:</strong> Transfer Learningã‚’LIBâ†’Na-ioné›»æ± ã«é©ç”¨ã™ã‚‹éš›ã®æœ‰åŠ¹æ€§ã¨é™ç•Œã‚’ã€æ§‹é€ çš„é¡ä¼¼æ€§ã®è¦³ç‚¹ã‹ã‚‰è«–ã˜ã‚ˆï¼ˆ400å­—ä»¥å†…ï¼‰ã€‚</p>
<hr />
<h2>å‚è€ƒæ–‡çŒ®</h2>
<ol>
<li>Kato, Y. et al. "High-power all-solid-state batteries using sulfide superionic conductors." <em>Nat. Energy</em> (2016).</li>
<li>Pang, Q. et al. "Tuning the electrolyte network structure to invoke quasi-solid state sulfur conversion." <em>Nat. Energy</em> (2018).</li>
<li>Attia, P. M. et al. "Closed-loop optimization of fast-charging protocols." <em>Nature</em> (2020).</li>
<li>Kim, J. et al. "Prospect and reality of Ni-rich cathode for commercialization." <em>Adv. Energy Mater.</em> (2018).</li>
<li>Delmas, C. "Sodium and Sodium-Ion Batteries: 50 Years of Research." <em>Adv. Energy Mater.</em> (2018).</li>
</ol>
<hr />
<p><strong>ã‚·ãƒªãƒ¼ã‚ºå®Œçµï¼</strong></p>
<p>æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—:
- <a href="../nm-introduction/">ãƒŠãƒãƒãƒ†ãƒªã‚¢ãƒ«MIåŸºç¤ã‚·ãƒªãƒ¼ã‚º</a>
- <a href="../drug-discovery-mi-application/">å‰µè–¬ã¸ã®MIå¿œç”¨ã‚·ãƒªãƒ¼ã‚º</a>
- <a href="../catalyst-mi-application/">è§¦åª’è¨­è¨ˆã¸ã®MIå¿œç”¨ã‚·ãƒªãƒ¼ã‚º</a></p>
<p><strong>ãƒ©ã‚¤ã‚»ãƒ³ã‚¹</strong>: ã“ã®ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã¯CC BY 4.0ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã®ä¸‹ã§æä¾›ã•ã‚Œã¦ã„ã¾ã™ã€‚</p>
<p><strong>è¬è¾</strong>: æœ¬ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã¯æ±åŒ—å¤§å­¦ææ–™ç§‘å­¦é«˜ç­‰ç ”ç©¶æ‰€ï¼ˆAIMRï¼‰ã®ç ”ç©¶æˆæœã¨ã€ç”£å­¦é€£æºãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®çŸ¥è¦‹ã«åŸºã¥ã„ã¦ã„ã¾ã™ã€‚</p><div class="navigation">
    <a href="chapter3-hands-on.html" class="nav-button">â† ç¬¬3ç« </a>
    <a href="index.html" class="nav-button">ã‚·ãƒªãƒ¼ã‚ºç›®æ¬¡</a>
</div>
    </main>

    <footer>
        <p><strong>AI Terakoya ãƒãƒ†ãƒªã‚¢ãƒ«ã‚ºãƒ»ã‚¤ãƒ³ãƒ•ã‚©ãƒãƒ†ã‚£ã‚¯ã‚¹æ•™è‚²ã‚³ãƒ³ãƒ†ãƒ³ãƒ„</strong></p>
        <p>ç›£ä¿®: Dr. Yusuke Hashimotoï¼ˆæ±åŒ—å¤§å­¦ï¼‰</p>
        <p>Â© 2025 AI Terakoya. Licensed under CC BY 4.0</p>
    </footer>
</body>
</html>
