---
title: ç¬¬3ç«  ãƒ—ãƒ­ã‚»ã‚¹æœ€é©åŒ–
chapter_title: ç¬¬3ç«  ãƒ—ãƒ­ã‚»ã‚¹æœ€é©åŒ–
---

ğŸŒ JP | [ğŸ‡¬ğŸ‡§ EN](<../../../en/PI/food-process-ai/chapter-3.html>) | Last sync: 2025-11-16

[AIå¯ºå­å±‹ãƒˆãƒƒãƒ—](<../../index.html>)â€º[ãƒ—ãƒ­ã‚»ã‚¹ãƒ»ã‚¤ãƒ³ãƒ•ã‚©ãƒãƒ†ã‚£ã‚¯ã‚¹](<../../PI/index.html>)â€º[Food Process Ai](<../../PI/food-process-ai/index.html>)â€ºChapter 3

## 3.1 é£Ÿå“ãƒ—ãƒ­ã‚»ã‚¹æœ€é©åŒ–ã®èª²é¡Œ

é£Ÿå“è£½é€ ãƒ—ãƒ­ã‚»ã‚¹ã®æœ€é©åŒ–ã¯ã€å“è³ªå‘ä¸Šã€ã‚³ã‚¹ãƒˆå‰Šæ¸›ã€ã‚¨ãƒãƒ«ã‚®ãƒ¼åŠ¹ç‡æ”¹å–„ã®è¦³ç‚¹ã‹ã‚‰æ¥µã‚ã¦é‡è¦ã§ã™ã€‚ ã—ã‹ã—ã€åŸææ–™ã®å¤‰å‹•æ€§ã€è¤‡é›‘ãªéç·šå½¢é–¢ä¿‚ã€å¤šç›®çš„æœ€é©åŒ–ã®å¿…è¦æ€§ãªã©ã€å¤šãã®èª²é¡ŒãŒã‚ã‚Šã¾ã™ã€‚ AIæŠ€è¡“ã€ç‰¹ã«ãƒ™ã‚¤ã‚ºæœ€é©åŒ–ã‚„éºä¼çš„ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã¯ã€ã“ã‚Œã‚‰ã®èª²é¡Œã«å¯¾å‡¦ã™ã‚‹å¼·åŠ›ãªæ‰‹æ³•ã§ã™ã€‚ 

### é£Ÿå“ãƒ—ãƒ­ã‚»ã‚¹æœ€é©åŒ–ã®ä¸»è¦ãªèª²é¡Œ

  * **å¤šå¤‰æ•°ãƒ»éç·šå½¢æ€§** : æ¸©åº¦ã€æ™‚é–“ã€pHã€é…åˆæ¯”ãªã©å¤šæ•°ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãŒè¤‡é›‘ã«ç›¸äº’ä½œç”¨
  * **è©•ä¾¡ã‚³ã‚¹ãƒˆã®é«˜ã•** : å®Ÿé¨“è©•ä¾¡ã«æ™‚é–“ã¨ã‚³ã‚¹ãƒˆãŒã‹ã‹ã‚‹ï¼ˆ1å®Ÿé¨“ã‚ãŸã‚Šæ•°æ™‚é–“ã€œæ•°æ—¥ï¼‰
  * **å¤šç›®çš„æœ€é©åŒ–** : å“è³ªã€ã‚³ã‚¹ãƒˆã€ã‚¨ãƒãƒ«ã‚®ãƒ¼åŠ¹ç‡ã‚’åŒæ™‚ã«æœ€é©åŒ–
  * **åˆ¶ç´„æ¡ä»¶** : é£Ÿå“å®‰å…¨åŸºæº–ï¼ˆHACCPï¼‰ã€è£…ç½®èƒ½åŠ›ã®åˆ¶ç´„
  * **ãƒãƒƒãƒé–“å¤‰å‹•** : åŸææ–™ã®å­£ç¯€å¤‰å‹•ã€ãƒ­ãƒƒãƒˆå·®

### ğŸ¯ æœ€é©åŒ–æ‰‹æ³•ã®é¸æŠã‚¬ã‚¤ãƒ‰

æ‰‹æ³• | é©ç”¨å ´é¢ | é•·æ‰€ | çŸ­æ‰€  
---|---|---|---  
**ãƒ™ã‚¤ã‚ºæœ€é©åŒ–** | è©•ä¾¡ã‚³ã‚¹ãƒˆãŒé«˜ã„ã€å°‘æ•°ã®å®Ÿé¨“ã§æœ€é©åŒ– | ã‚µãƒ³ãƒ—ãƒ«åŠ¹ç‡ãŒé«˜ã„ã€ä¸ç¢ºå®Ÿæ€§ã‚’è€ƒæ…® | è¨ˆç®—ã‚³ã‚¹ãƒˆã‚„ã‚„é«˜ã„  
**éºä¼çš„ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ** | å¤šç›®çš„æœ€é©åŒ–ã€é›¢æ•£å¤‰æ•°ã‚’å«ã‚€ | å¤§åŸŸçš„æœ€é©è§£æ¢ç´¢ã€å®Ÿè£…ãŒå®¹æ˜“ | åæŸã«æ™‚é–“ãŒã‹ã‹ã‚‹  
**å¿œç­”æ›²é¢æ³•ï¼ˆRSMï¼‰** | å®Ÿé¨“è¨ˆç”»æ³•ã¨çµ„ã¿åˆã‚ã› | çµ±è¨ˆçš„æ ¹æ‹ ã€å¯è¦–åŒ–ãŒå®¹æ˜“ | éç·šå½¢æ€§ãŒå¼·ã„ã¨ç²¾åº¦ä½ä¸‹  
**ç²’å­ç¾¤æœ€é©åŒ–ï¼ˆPSOï¼‰** | é€£ç¶šå¤‰æ•°ã®æœ€é©åŒ– | å®Ÿè£…ãŒç°¡å˜ã€ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿èª¿æ•´ãŒå°‘ãªã„ | å±€æ‰€è§£ã«é™¥ã‚Šã‚„ã™ã„  
  
ğŸ“Š ã‚³ãƒ¼ãƒ‰ä¾‹1: ãƒ™ã‚¤ã‚ºæœ€é©åŒ–ã«ã‚ˆã‚‹åŠ ç†±æ¡ä»¶ã®æœ€é©åŒ–
    
    
    import numpy as np
    import matplotlib.pyplot as plt
    from sklearn.gaussian_process import GaussianProcessRegressor
    from sklearn.gaussian_process.kernels import RBF, ConstantKernel as C
    from scipy.stats import norm
    import warnings
    warnings.filterwarnings('ignore')
    
    # é£Ÿå“åŠ ç†±ãƒ—ãƒ­ã‚»ã‚¹ã®ç›®çš„é–¢æ•°ï¼ˆå®Ÿéš›ã®ãƒ—ãƒ­ã‚»ã‚¹ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆï¼‰
    def food_processing_objective(temperature, time):
        """
        ç›®çš„é–¢æ•°: å“è³ªã‚¹ã‚³ã‚¢ã‚’æœ€å¤§åŒ–ï¼ˆæ¸©åº¦ã¨æ™‚é–“ã®é–¢æ•°ï¼‰
        æœ€é©ç‚¹ä»˜è¿‘: temperature=90Â°C, time=20åˆ†
        """
        # è¤‡é›‘ãªéç·šå½¢é–¢æ•°ï¼ˆå®Ÿéš›ã®é£Ÿå“ãƒ—ãƒ­ã‚»ã‚¹ã‚’æ¨¡æ“¬ï¼‰
        quality = (
            100 * np.exp(-0.5 * ((temperature - 90)/10)**2) * 
            np.exp(-0.5 * ((time - 20)/5)**2) +
            10 * np.sin(temperature / 10) * np.cos(time / 5) +
            np.random.normal(0, 2)  # æ¸¬å®šãƒã‚¤ã‚º
        )
        return quality
    
    # ãƒ™ã‚¤ã‚ºæœ€é©åŒ–ã®å®Ÿè£…
    class BayesianOptimizer:
        def __init__(self, bounds, n_init=5):
            self.bounds = np.array(bounds)
            self.n_init = n_init
            self.X_sample = []
            self.y_sample = []
            
            # ã‚¬ã‚¦ã‚¹éç¨‹å›å¸°ãƒ¢ãƒ‡ãƒ«
            kernel = C(1.0, (1e-3, 1e3)) * RBF([10, 10], (1e-2, 1e2))
            self.gp = GaussianProcessRegressor(kernel=kernel, n_restarts_optimizer=10,
                                               alpha=1e-6, normalize_y=True)
        
        def acquisition_function(self, X, xi=0.01):
            """
            ç²å¾—é–¢æ•°: Expected Improvement (EI)
            """
            mu, sigma = self.gp.predict(X, return_std=True)
            mu_sample_opt = np.max(self.y_sample)
            
            with np.errstate(divide='warn'):
                imp = mu - mu_sample_opt - xi
                Z = imp / sigma
                ei = imp * norm.cdf(Z) + sigma * norm.pdf(Z)
                ei[sigma == 0.0] = 0.0
            
            return ei
        
        def propose_location(self):
            """
            æ¬¡ã®è©•ä¾¡ç‚¹ã‚’ææ¡ˆï¼ˆEIã‚’æœ€å¤§åŒ–ï¼‰
            """
            dim = self.bounds.shape[0]
            min_val = float('inf')
            min_x = None
            
            # ãƒ©ãƒ³ãƒ€ãƒ ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚° + æœ€é©åŒ–
            n_restarts = 25
            for _ in range(n_restarts):
                x0 = np.random.uniform(self.bounds[:, 0], self.bounds[:, 1], size=dim)
                res = self._minimize_acquisition(x0)
                if res < min_val:
                    min_val = res
                    min_x = x0
            
            return min_x
        
        def _minimize_acquisition(self, x0):
            """
            ç²å¾—é–¢æ•°ã®æœ€å°åŒ–ï¼ˆè² ã®EIã‚’æœ€å°åŒ–ï¼‰
            """
            from scipy.optimize import minimize
            
            def objective(x):
                return -self.acquisition_function(x.reshape(1, -1))
            
            bounds_list = [(self.bounds[i, 0], self.bounds[i, 1]) 
                           for i in range(self.bounds.shape[0])]
            
            res = minimize(objective, x0, bounds=bounds_list, method='L-BFGS-B')
            return res.fun
        
        def optimize(self, objective_func, n_iter=20):
            """
            ãƒ™ã‚¤ã‚ºæœ€é©åŒ–ã®å®Ÿè¡Œ
            """
            # åˆæœŸãƒ©ãƒ³ãƒ€ãƒ ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°
            for _ in range(self.n_init):
                x = np.random.uniform(self.bounds[:, 0], self.bounds[:, 1], 
                                      size=self.bounds.shape[0])
                y = objective_func(x[0], x[1])
                self.X_sample.append(x)
                self.y_sample.append(y)
            
            # ãƒ™ã‚¤ã‚ºæœ€é©åŒ–ãƒ«ãƒ¼ãƒ—
            for i in range(n_iter):
                # GPãƒ¢ãƒ‡ãƒ«æ›´æ–°
                self.gp.fit(np.array(self.X_sample), np.array(self.y_sample))
                
                # æ¬¡ã®è©•ä¾¡ç‚¹ã‚’ææ¡ˆ
                x_next = self.propose_location()
                y_next = objective_func(x_next[0], x_next[1])
                
                self.X_sample.append(x_next)
                self.y_sample.append(y_next)
                
                if (i + 1) % 5 == 0:
                    print(f"Iteration {i+1}: Best quality = {np.max(self.y_sample):.2f} "
                          f"at T={self.X_sample[np.argmax(self.y_sample)][0]:.1f}Â°C, "
                          f"t={self.X_sample[np.argmax(self.y_sample)][1]:.1f}min")
            
            return np.array(self.X_sample), np.array(self.y_sample)
    
    # æœ€é©åŒ–å®Ÿè¡Œ
    bounds = [[75, 105], [10, 30]]  # [æ¸©åº¦ç¯„å›², æ™‚é–“ç¯„å›²]
    optimizer = BayesianOptimizer(bounds, n_init=5)
    X_sample, y_sample = optimizer.optimize(food_processing_objective, n_iter=25)
    
    # æœ€é©è§£
    best_idx = np.argmax(y_sample)
    best_temp, best_time = X_sample[best_idx]
    best_quality = y_sample[best_idx]
    
    print(f"\n=== æœ€é©åŒ–çµæœ ===")
    print(f"æœ€é©æ¸©åº¦: {best_temp:.2f}Â°C")
    print(f"æœ€é©æ™‚é–“: {best_time:.2f}åˆ†")
    print(f"æœ€å¤§å“è³ªã‚¹ã‚³ã‚¢: {best_quality:.2f}")
    print(f"ç·è©•ä¾¡å›æ•°: {len(X_sample)}")
    
    # å¯è¦–åŒ–
    fig = plt.figure(figsize=(16, 10))
    gs = fig.add_gridspec(2, 2, hspace=0.3, wspace=0.3)
    
    # 1. çœŸã®ç›®çš„é–¢æ•°ï¼ˆå‚è€ƒï¼‰
    ax1 = fig.add_subplot(gs[0, 0])
    T_grid = np.linspace(75, 105, 100)
    t_grid = np.linspace(10, 30, 100)
    T_mesh, t_mesh = np.meshgrid(T_grid, t_grid)
    quality_grid = np.zeros_like(T_mesh)
    for i in range(T_mesh.shape[0]):
        for j in range(T_mesh.shape[1]):
            quality_grid[i, j] = food_processing_objective(T_mesh[i, j], t_mesh[i, j])
    
    contour = ax1.contourf(T_mesh, t_mesh, quality_grid, levels=20, cmap='viridis', alpha=0.8)
    ax1.scatter(X_sample[:5, 0], X_sample[:5, 1], c='red', s=100, 
                marker='o', edgecolors='white', linewidth=2, label='åˆæœŸã‚µãƒ³ãƒ—ãƒ«', zorder=5)
    ax1.scatter(X_sample[5:, 0], X_sample[5:, 1], c='white', s=80, 
                marker='s', edgecolors='black', linewidth=1.5, label='BOææ¡ˆç‚¹', zorder=5)
    ax1.scatter(best_temp, best_time, c='gold', s=300, marker='*', 
                edgecolors='red', linewidth=2, label='æœ€é©è§£', zorder=10)
    ax1.set_xlabel('æ¸©åº¦ (Â°C)', fontsize=12)
    ax1.set_ylabel('æ™‚é–“ (åˆ†)', fontsize=12)
    ax1.set_title('ãƒ™ã‚¤ã‚ºæœ€é©åŒ–ã®æ¢ç´¢éç¨‹', fontsize=14, fontweight='bold')
    ax1.legend(fontsize=10)
    plt.colorbar(contour, ax=ax1, label='å“è³ªã‚¹ã‚³ã‚¢')
    
    # 2. å“è³ªã‚¹ã‚³ã‚¢ã®æ¨ç§»
    ax2 = fig.add_subplot(gs[0, 1])
    iterations = np.arange(1, len(y_sample) + 1)
    best_so_far = np.maximum.accumulate(y_sample)
    ax2.plot(iterations, y_sample, 'o-', color='#11998e', alpha=0.6, 
             linewidth=2, markersize=6, label='å„è©•ä¾¡ç‚¹ã®å“è³ª')
    ax2.plot(iterations, best_so_far, 'r-', linewidth=3, label='æœ€è‰¯å€¤ã®æ¨ç§»')
    ax2.axvline(x=5, color='gray', linestyle='--', alpha=0.5, label='åˆæœŸã‚µãƒ³ãƒ—ãƒ«çµ‚äº†')
    ax2.set_xlabel('è©•ä¾¡å›æ•°', fontsize=12)
    ax2.set_ylabel('å“è³ªã‚¹ã‚³ã‚¢', fontsize=12)
    ax2.set_title('æœ€é©åŒ–ã®åæŸéç¨‹', fontsize=14, fontweight='bold')
    ax2.legend(fontsize=10)
    ax2.grid(True, alpha=0.3)
    
    # 3. ã‚¬ã‚¦ã‚¹éç¨‹ã«ã‚ˆã‚‹äºˆæ¸¬ï¼ˆæ¸©åº¦æ–¹å‘ã®ã‚¹ãƒ©ã‚¤ã‚¹ã€æ™‚é–“=best_timeï¼‰
    ax3 = fig.add_subplot(gs[1, 0])
    T_test = np.linspace(75, 105, 200).reshape(-1, 1)
    t_test = np.full_like(T_test, best_time)
    X_test = np.hstack([T_test, t_test])
    
    mu, sigma = optimizer.gp.predict(X_test, return_std=True)
    
    ax3.plot(T_test, mu, 'b-', linewidth=2, label='GPäºˆæ¸¬å¹³å‡')
    ax3.fill_between(T_test.ravel(), mu - 1.96*sigma, mu + 1.96*sigma,
                     alpha=0.3, color='blue', label='95%ä¿¡é ¼åŒºé–“')
    ax3.scatter(X_sample[:, 0], y_sample, c='red', s=80, marker='o', 
                edgecolors='white', linewidth=1.5, label='è¦³æ¸¬ç‚¹', zorder=5)
    ax3.axvline(x=best_temp, color='green', linestyle='--', linewidth=2, label='æœ€é©æ¸©åº¦')
    ax3.set_xlabel('æ¸©åº¦ (Â°C)', fontsize=12)
    ax3.set_ylabel('å“è³ªã‚¹ã‚³ã‚¢', fontsize=12)
    ax3.set_title(f'ã‚¬ã‚¦ã‚¹éç¨‹äºˆæ¸¬ï¼ˆæ™‚é–“={best_time:.1f}åˆ†å›ºå®šï¼‰', fontsize=14, fontweight='bold')
    ax3.legend(fontsize=10)
    ax3.grid(True, alpha=0.3)
    
    # 4. ç²å¾—é–¢æ•°ï¼ˆExpected Improvementï¼‰
    ax4 = fig.add_subplot(gs[1, 1])
    ei = optimizer.acquisition_function(X_test)
    ax4.plot(T_test, ei, 'g-', linewidth=2)
    ax4.fill_between(T_test.ravel(), 0, ei, alpha=0.3, color='green')
    ax4.set_xlabel('æ¸©åº¦ (Â°C)', fontsize=12)
    ax4.set_ylabel('Expected Improvement', fontsize=12)
    ax4.set_title('ç²å¾—é–¢æ•°ï¼ˆæ¬¡ã®è©•ä¾¡ç‚¹ã®é¸æŠåŸºæº–ï¼‰', fontsize=14, fontweight='bold')
    ax4.grid(True, alpha=0.3)
    
    plt.savefig('bayesian_optimization_food.png', dpi=300, bbox_inches='tight')
    plt.show()

## 3.2 éºä¼çš„ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã«ã‚ˆã‚‹å¤šç›®çš„æœ€é©åŒ–

é£Ÿå“ãƒ—ãƒ­ã‚»ã‚¹ã§ã¯ã€å“è³ªã€ã‚³ã‚¹ãƒˆã€ã‚¨ãƒãƒ«ã‚®ãƒ¼åŠ¹ç‡ãªã©è¤‡æ•°ã®ç›®çš„ã‚’åŒæ™‚ã«æœ€é©åŒ–ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ éºä¼çš„ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ï¼ˆGAï¼‰ã€ç‰¹ã«NSGA-IIï¼ˆNon-dominated Sorting Genetic Algorithm IIï¼‰ã¯ã€ ãƒ‘ãƒ¬ãƒ¼ãƒˆæœ€é©è§£ã‚’åŠ¹ç‡çš„ã«æ¢ç´¢ã§ãã¾ã™ã€‚ 

ğŸ“Š ã‚³ãƒ¼ãƒ‰ä¾‹2: å¤šç›®çš„æœ€é©åŒ–ï¼ˆå“è³ª vs ã‚³ã‚¹ãƒˆï¼‰
    
    
    import numpy as np
    import matplotlib.pyplot as plt
    from scipy.optimize import differential_evolution
    
    # å¤šç›®çš„æœ€é©åŒ–å•é¡Œã®å®šç¾©
    class FoodProcessMultiObjective:
        def __init__(self):
            # ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ç¯„å›²
            self.bounds = [
                (75, 105),   # æ¸©åº¦ (Â°C)
                (10, 30),    # æ™‚é–“ (åˆ†)
                (3.0, 5.0),  # pH
                (50, 150),   # æµé‡ (L/min)
            ]
        
        def quality_objective(self, params):
            """
            ç›®çš„é–¢æ•°1: å“è³ªã‚¹ã‚³ã‚¢ã‚’æœ€å¤§åŒ–ï¼ˆæœ€å°åŒ–å•é¡Œãªã®ã§è² å€¤ï¼‰
            """
            temp, time, ph, flow = params
            
            # å“è³ªé–¢æ•°ï¼ˆéç·šå½¢ï¼‰
            quality = (
                100 * np.exp(-0.5 * ((temp - 90)/10)**2) *
                np.exp(-0.5 * ((time - 20)/5)**2) *
                np.exp(-0.5 * ((ph - 4.0)/0.5)**2) *
                (1 + 0.1 * np.sin(flow / 20))
            )
            
            return -quality  # æœ€å°åŒ–å•é¡Œã«å¤‰æ›
        
        def cost_objective(self, params):
            """
            ç›®çš„é–¢æ•°2: ã‚³ã‚¹ãƒˆã‚’æœ€å°åŒ–
            """
            temp, time, ph, flow = params
            
            # ã‚¨ãƒãƒ«ã‚®ãƒ¼ã‚³ã‚¹ãƒˆï¼ˆæ¸©åº¦ã¨æ™‚é–“ã«ä¾å­˜ï¼‰
            energy_cost = 0.1 * (temp - 70) * time
            
            # pHèª¿æ•´å‰¤ã‚³ã‚¹ãƒˆ
            ph_cost = 5 * abs(ph - 4.0)
            
            # ãƒãƒ³ãƒ—é‹è»¢ã‚³ã‚¹ãƒˆ
            pump_cost = 0.05 * flow * time
            
            total_cost = energy_cost + ph_cost + pump_cost
            
            return total_cost
        
        def constraints_check(self, params):
            """
            åˆ¶ç´„æ¡ä»¶ã®ãƒã‚§ãƒƒã‚¯ï¼ˆHACCPåŸºæº–ãªã©ï¼‰
            """
            temp, time, ph, flow = params
            
            # Få€¤ï¼ˆæ®ºèŒåŠ¹æœï¼‰ã®è¨ˆç®—: F0 = time * 10^((temp-121)/10)
            F0 = time * (10 ** ((temp - 121) / 10))
            
            # æœ€å°Få€¤è¦æ±‚ï¼ˆä¾‹: F0 >= 3ï¼‰
            if F0 < 3:
                return False
            
            # pHç¯„å›²åˆ¶ç´„
            if not (3.0 <= ph <= 5.0):
                return False
            
            return True
    
    # ç°¡æ˜“çš„ãªãƒ‘ãƒ¬ãƒ¼ãƒˆæœ€é©åŒ–ï¼ˆã‚°ãƒªãƒƒãƒ‰ã‚µãƒ¼ãƒ + ãƒ‘ãƒ¬ãƒ¼ãƒˆåˆ¤å®šï¼‰
    problem = FoodProcessMultiObjective()
    
    # ãƒ©ãƒ³ãƒ€ãƒ ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ã§ãƒ‘ãƒ¬ãƒ¼ãƒˆãƒ•ãƒ­ãƒ³ãƒˆè¿‘ä¼¼
    np.random.seed(42)
    n_samples = 1000
    
    # ãƒ©ãƒ³ãƒ€ãƒ ã‚µãƒ³ãƒ—ãƒ«ç”Ÿæˆ
    samples = []
    qualities = []
    costs = []
    
    for _ in range(n_samples):
        params = [
            np.random.uniform(low, high) 
            for low, high in problem.bounds
        ]
        
        if problem.constraints_check(params):
            quality = -problem.quality_objective(params)  # å…ƒã«æˆ»ã™ï¼ˆæœ€å¤§åŒ–ï¼‰
            cost = problem.cost_objective(params)
            
            samples.append(params)
            qualities.append(quality)
            costs.append(cost)
    
    samples = np.array(samples)
    qualities = np.array(qualities)
    costs = np.array(costs)
    
    # ãƒ‘ãƒ¬ãƒ¼ãƒˆæœ€é©è§£ã®åˆ¤å®š
    def is_pareto_efficient(costs_qualities):
        """
        ãƒ‘ãƒ¬ãƒ¼ãƒˆæœ€é©è§£ã‚’åˆ¤å®šï¼ˆ2ç›®çš„ã®å ´åˆï¼‰
        cost: æœ€å°åŒ–, quality: æœ€å¤§åŒ–
        """
        is_efficient = np.ones(costs_qualities.shape[0], dtype=bool)
        for i, c in enumerate(costs_qualities):
            if is_efficient[i]:
                # ä»–ã®è§£ãŒã“ã®è§£ã‚’æ”¯é…ã—ã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
                # æ”¯é…: cost <= c[0] ã‹ã¤ quality >= c[1] ã§ã©ã¡ã‚‰ã‹ãŒçœŸã«å„ªã‚Œã¦ã„ã‚‹
                dominated = np.logical_and(
                    costs_qualities[:, 0] <= c[0],  # ã‚³ã‚¹ãƒˆãŒåŒã˜ã‹å°‘ãªã„
                    costs_qualities[:, 1] >= c[1]   # å“è³ªãŒåŒã˜ã‹é«˜ã„
                )
                # çœŸã«å„ªã‚Œã¦ã„ã‚‹ï¼ˆç­‰ã—ããªã„ï¼‰
                strictly_better = np.logical_or(
                    costs_qualities[:, 0] < c[0],
                    costs_qualities[:, 1] > c[1]
                )
                dominated = np.logical_and(dominated, strictly_better)
                
                if np.any(dominated):
                    is_efficient[i] = False
        
        return is_efficient
    
    # ãƒ‘ãƒ¬ãƒ¼ãƒˆæœ€é©è§£ã®æŠ½å‡º
    costs_qualities = np.column_stack([costs, qualities])
    pareto_mask = is_pareto_efficient(costs_qualities)
    pareto_samples = samples[pareto_mask]
    pareto_costs = costs[pareto_mask]
    pareto_qualities = qualities[pareto_mask]
    
    # ãƒ‘ãƒ¬ãƒ¼ãƒˆãƒ•ãƒ­ãƒ³ãƒˆã‚’ã‚³ã‚¹ãƒˆã§ã‚½ãƒ¼ãƒˆ
    sorted_indices = np.argsort(pareto_costs)
    pareto_costs_sorted = pareto_costs[sorted_indices]
    pareto_qualities_sorted = pareto_qualities[sorted_indices]
    pareto_samples_sorted = pareto_samples[sorted_indices]
    
    # ä»£è¡¨çš„ãª3ã¤ã®è§£ã‚’é¸æŠ
    n_pareto = len(pareto_costs_sorted)
    representative_indices = [0, n_pareto // 2, n_pareto - 1]
    representative_solutions = []
    
    for idx in representative_indices:
        sol = {
            'params': pareto_samples_sorted[idx],
            'quality': pareto_qualities_sorted[idx],
            'cost': pareto_costs_sorted[idx],
            'label': ['ã‚³ã‚¹ãƒˆé‡è¦–', 'ãƒãƒ©ãƒ³ã‚¹å‹', 'å“è³ªé‡è¦–'][representative_indices.index(idx)]
        }
        representative_solutions.append(sol)
    
    # å¯è¦–åŒ–
    fig = plt.figure(figsize=(16, 10))
    gs = fig.add_gridspec(2, 2, hspace=0.3, wspace=0.3)
    
    # 1. ãƒ‘ãƒ¬ãƒ¼ãƒˆãƒ•ãƒ­ãƒ³ãƒˆ
    ax1 = fig.add_subplot(gs[0, :])
    ax1.scatter(costs, qualities, c='lightgray', alpha=0.4, s=30, label='å…¨ã‚µãƒ³ãƒ—ãƒ«')
    ax1.plot(pareto_costs_sorted, pareto_qualities_sorted, 'r-', linewidth=2.5, 
             label='ãƒ‘ãƒ¬ãƒ¼ãƒˆãƒ•ãƒ­ãƒ³ãƒˆ', zorder=10)
    ax1.scatter(pareto_costs_sorted, pareto_qualities_sorted, c='red', s=100, 
                marker='o', edgecolors='white', linewidth=2, label='ãƒ‘ãƒ¬ãƒ¼ãƒˆæœ€é©è§£', zorder=11)
    
    # ä»£è¡¨è§£ã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆ
    colors_rep = ['#1f77b4', '#ff7f0e', '#2ca02c']
    for i, sol in enumerate(representative_solutions):
        ax1.scatter(sol['cost'], sol['quality'], c=colors_rep[i], s=300, 
                    marker='*', edgecolors='black', linewidth=2, 
                    label=sol['label'], zorder=12)
        ax1.annotate(sol['label'], 
                    xy=(sol['cost'], sol['quality']),
                    xytext=(15, 15), textcoords='offset points',
                    fontsize=11, fontweight='bold',
                    bbox=dict(boxstyle='round,pad=0.5', fc=colors_rep[i], alpha=0.7),
                    arrowprops=dict(arrowstyle='->', connectionstyle='arc3,rad=0'))
    
    ax1.set_xlabel('ã‚³ã‚¹ãƒˆï¼ˆå††/ãƒãƒƒãƒï¼‰', fontsize=13)
    ax1.set_ylabel('å“è³ªã‚¹ã‚³ã‚¢', fontsize=13)
    ax1.set_title('å¤šç›®çš„æœ€é©åŒ–ï¼šãƒ‘ãƒ¬ãƒ¼ãƒˆãƒ•ãƒ­ãƒ³ãƒˆ', fontsize=15, fontweight='bold')
    ax1.legend(fontsize=11, loc='upper right')
    ax1.grid(True, alpha=0.3)
    
    # 2-4. ä»£è¡¨è§£ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿æ¯”è¼ƒ
    param_names = ['æ¸©åº¦ (Â°C)', 'æ™‚é–“ (åˆ†)', 'pH', 'æµé‡ (L/min)']
    axes = [fig.add_subplot(gs[1, 0]), fig.add_subplot(gs[1, 1])]
    
    # æ¸©åº¦ã¨æ™‚é–“
    ax2 = axes[0]
    x_pos = np.arange(len(representative_solutions))
    width = 0.35
    
    temp_values = [sol['params'][0] for sol in representative_solutions]
    time_values = [sol['params'][1] for sol in representative_solutions]
    
    ax2_twin = ax2.twinx()
    bars1 = ax2.bar(x_pos - width/2, temp_values, width, label='æ¸©åº¦', color='#ff6b6b', alpha=0.8)
    bars2 = ax2_twin.bar(x_pos + width/2, time_values, width, label='æ™‚é–“', color='#4ecdc4', alpha=0.8)
    
    ax2.set_xlabel('è§£ã®ã‚¿ã‚¤ãƒ—', fontsize=12)
    ax2.set_ylabel('æ¸©åº¦ (Â°C)', fontsize=12, color='#ff6b6b')
    ax2_twin.set_ylabel('æ™‚é–“ (åˆ†)', fontsize=12, color='#4ecdc4')
    ax2.set_title('ä»£è¡¨è§£ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿æ¯”è¼ƒï¼ˆæ¸©åº¦ãƒ»æ™‚é–“ï¼‰', fontsize=13, fontweight='bold')
    ax2.set_xticks(x_pos)
    ax2.set_xticklabels([sol['label'] for sol in representative_solutions])
    ax2.tick_params(axis='y', labelcolor='#ff6b6b')
    ax2_twin.tick_params(axis='y', labelcolor='#4ecdc4')
    ax2.grid(True, alpha=0.3, axis='y')
    
    # pH ã¨æµé‡
    ax3 = axes[1]
    ph_values = [sol['params'][2] for sol in representative_solutions]
    flow_values = [sol['params'][3] for sol in representative_solutions]
    
    ax3_twin = ax3.twinx()
    bars3 = ax3.bar(x_pos - width/2, ph_values, width, label='pH', color='#95e1d3', alpha=0.8)
    bars4 = ax3_twin.bar(x_pos + width/2, flow_values, width, label='æµé‡', color='#f38181', alpha=0.8)
    
    ax3.set_xlabel('è§£ã®ã‚¿ã‚¤ãƒ—', fontsize=12)
    ax3.set_ylabel('pH', fontsize=12, color='#95e1d3')
    ax3_twin.set_ylabel('æµé‡ (L/min)', fontsize=12, color='#f38181')
    ax3.set_title('ä»£è¡¨è§£ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿æ¯”è¼ƒï¼ˆpHãƒ»æµé‡ï¼‰', fontsize=13, fontweight='bold')
    ax3.set_xticks(x_pos)
    ax3.set_xticklabels([sol['label'] for sol in representative_solutions])
    ax3.tick_params(axis='y', labelcolor='#95e1d3')
    ax3_twin.tick_params(axis='y', labelcolor='#f38181')
    ax3.grid(True, alpha=0.3, axis='y')
    
    plt.savefig('multi_objective_optimization.png', dpi=300, bbox_inches='tight')
    plt.show()
    
    # ãƒ¬ãƒãƒ¼ãƒˆå‡ºåŠ›
    print("=== å¤šç›®çš„æœ€é©åŒ–çµæœ ===")
    print(f"ç·ã‚µãƒ³ãƒ—ãƒ«æ•°: {n_samples}")
    print(f"åˆ¶ç´„ã‚’æº€ãŸã™ã‚µãƒ³ãƒ—ãƒ«æ•°: {len(samples)}")
    print(f"ãƒ‘ãƒ¬ãƒ¼ãƒˆæœ€é©è§£æ•°: {len(pareto_samples)}")
    
    print("\n=== ä»£è¡¨çš„ãª3ã¤ã®è§£ ===")
    for i, sol in enumerate(representative_solutions):
        print(f"\n{i+1}. {sol['label']}")
        print(f"   æ¸©åº¦: {sol['params'][0]:.2f}Â°C")
        print(f"   æ™‚é–“: {sol['params'][1]:.2f}åˆ†")
        print(f"   pH: {sol['params'][2]:.2f}")
        print(f"   æµé‡: {sol['params'][3]:.2f} L/min")
        print(f"   å“è³ªã‚¹ã‚³ã‚¢: {sol['quality']:.2f}")
        print(f"   ã‚³ã‚¹ãƒˆ: {sol['cost']:.2f} å††/ãƒãƒƒãƒ")
        
        # Få€¤è¨ˆç®—
        F0 = sol['params'][1] * (10 ** ((sol['params'][0] - 121) / 10))
        print(f"   æ®ºèŒåŠ¹æœï¼ˆF0å€¤ï¼‰: {F0:.2f}")

## 3.3 å¿œç­”æ›²é¢æ³•ï¼ˆRSMï¼‰ã«ã‚ˆã‚‹æœ€é©åŒ–

å¿œç­”æ›²é¢æ³•ï¼ˆResponse Surface Methodology: RSMï¼‰ã¯ã€å®Ÿé¨“è¨ˆç”»æ³•ã¨çµ±è¨ˆãƒ¢ãƒ‡ãƒªãƒ³ã‚°ã‚’çµ„ã¿åˆã‚ã›ãŸæœ€é©åŒ–æ‰‹æ³•ã§ã™ã€‚ æ¯”è¼ƒçš„å°‘ãªã„å®Ÿé¨“å›æ•°ã§ã€ãƒ—ãƒ­ã‚»ã‚¹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¨å¿œç­”å¤‰æ•°ã®é–¢ä¿‚ã‚’2æ¬¡å¤šé …å¼ã§ãƒ¢ãƒ‡ãƒ«åŒ–ã—ã€æœ€é©æ¡ä»¶ã‚’æ¢ç´¢ã—ã¾ã™ã€‚ 

ğŸ“Š ã‚³ãƒ¼ãƒ‰ä¾‹3: å¿œç­”æ›²é¢æ³•ï¼ˆBox-Behnkenè¨ˆç”»ï¼‰
    
    
    import numpy as np
    import pandas as pd
    import matplotlib.pyplot as plt
    from sklearn.preprocessing import PolynomialFeatures
    from sklearn.linear_model import LinearRegression
    from mpl_toolkits.mplot3d import Axes3D
    
    # Box-Behnkenå®Ÿé¨“è¨ˆç”»ï¼ˆ3å› å­ï¼‰
    def box_behnken_design(factors):
        """
        Box-Behnkenå®Ÿé¨“è¨ˆç”»ã‚’ç”Ÿæˆï¼ˆ3å› å­ã®å ´åˆï¼‰
        """
        # ç¬¦å·åŒ–ãƒ¬ãƒ™ãƒ«: -1, 0, +1
        design = np.array([
            [-1, -1,  0], [1, -1,  0], [-1,  1,  0], [1,  1,  0],
            [-1,  0, -1], [1,  0, -1], [-1,  0,  1], [1,  0,  1],
            [ 0, -1, -1], [0,  1, -1], [ 0, -1,  1], [0,  1,  1],
            [ 0,  0,  0], [0,  0,  0], [ 0,  0,  0]  # ä¸­å¿ƒç‚¹ï¼ˆ3å›åå¾©ï¼‰
        ])
        
        # å®Ÿéš›ã®å€¤ã«å¤‰æ›
        actual_design = []
        for row in design:
            actual_row = []
            for i, level in enumerate(row):
                low, center, high = factors[i]
                if level == -1:
                    actual_row.append(low)
                elif level == 0:
                    actual_row.append(center)
                else:  # level == 1
                    actual_row.append(high)
            actual_design.append(actual_row)
        
        return np.array(actual_design)
    
    # å› å­ãƒ¬ãƒ™ãƒ«è¨­å®šï¼ˆä½ãƒ»ä¸­ãƒ»é«˜ï¼‰
    factors = [
        (80, 90, 100),   # æ¸©åº¦ (Â°C)
        (15, 20, 25),    # æ™‚é–“ (åˆ†)
        (3.5, 4.0, 4.5), # pH
    ]
    factor_names = ['æ¸©åº¦', 'æ™‚é–“', 'pH']
    
    # å®Ÿé¨“è¨ˆç”»ç”Ÿæˆ
    X_design = box_behnken_design(factors)
    
    # å¿œç­”å¤‰æ•°ï¼ˆå“è³ªã‚¹ã‚³ã‚¢ï¼‰ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ
    def response_function(temp, time, ph):
        """
        çœŸã®å¿œç­”é–¢æ•°ï¼ˆ2æ¬¡å¤šé …å¼ + äº¤äº’ä½œç”¨ + ãƒã‚¤ã‚ºï¼‰
        """
        response = (
            50 +
            2 * (temp - 90) + 0.5 * (time - 20) + 10 * (ph - 4.0) +
            -0.05 * (temp - 90)**2 - 0.1 * (time - 20)**2 - 15 * (ph - 4.0)**2 +
            0.02 * (temp - 90) * (time - 20) +
            0.5 * (temp - 90) * (ph - 4.0) +
            np.random.normal(0, 0.5)  # å®Ÿé¨“èª¤å·®
        )
        return response
    
    y_response = np.array([response_function(x[0], x[1], x[2]) for x in X_design])
    
    # ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ¬ãƒ¼ãƒ ä½œæˆ
    df_experiment = pd.DataFrame(X_design, columns=factor_names)
    df_experiment['å“è³ªã‚¹ã‚³ã‚¢'] = y_response
    
    print("=== Box-Behnkenå®Ÿé¨“è¨ˆç”» ===")
    print(df_experiment)
    
    # 2æ¬¡å¿œç­”æ›²é¢ãƒ¢ãƒ‡ãƒ«ã®æ§‹ç¯‰
    poly = PolynomialFeatures(degree=2, include_bias=True)
    X_poly = poly.fit_transform(X_design)
    model = LinearRegression()
    model.fit(X_poly, y_response)
    
    # ãƒ¢ãƒ‡ãƒ«æ€§èƒ½
    y_pred = model.predict(X_poly)
    r2_score = model.score(X_poly, y_response)
    print(f"\n=== å¿œç­”æ›²é¢ãƒ¢ãƒ‡ãƒ« ===")
    print(f"RÂ² ã‚¹ã‚³ã‚¢: {r2_score:.4f}")
    
    # ä¿‚æ•°ã®è¡¨ç¤º
    feature_names = poly.get_feature_names_out(factor_names)
    coefficients = pd.DataFrame({
        'é …': feature_names,
        'ä¿‚æ•°': model.coef_
    })
    print("\n=== ãƒ¢ãƒ‡ãƒ«ä¿‚æ•° ===")
    print(coefficients)
    
    # æœ€é©åŒ–ï¼šã‚°ãƒªãƒƒãƒ‰ã‚µãƒ¼ãƒã§æœ€å¤§å€¤ã‚’æ¢ç´¢
    temp_range = np.linspace(80, 100, 50)
    time_range = np.linspace(15, 25, 50)
    ph_fixed = 4.0  # pHã‚’å›ºå®š
    
    T_mesh, t_mesh = np.meshgrid(temp_range, time_range)
    response_mesh = np.zeros_like(T_mesh)
    
    for i in range(T_mesh.shape[0]):
        for j in range(T_mesh.shape[1]):
            X_test = np.array([[T_mesh[i, j], t_mesh[i, j], ph_fixed]])
            X_test_poly = poly.transform(X_test)
            response_mesh[i, j] = model.predict(X_test_poly)[0]
    
    # æœ€é©ç‚¹
    max_idx = np.unravel_index(np.argmax(response_mesh), response_mesh.shape)
    optimal_temp = T_mesh[max_idx]
    optimal_time = t_mesh[max_idx]
    optimal_response = response_mesh[max_idx]
    
    print(f"\n=== æœ€é©æ¡ä»¶ï¼ˆpH={ph_fixed}å›ºå®šï¼‰ ===")
    print(f"æœ€é©æ¸©åº¦: {optimal_temp:.2f}Â°C")
    print(f"æœ€é©æ™‚é–“: {optimal_time:.2f}åˆ†")
    print(f"äºˆæ¸¬å“è³ªã‚¹ã‚³ã‚¢: {optimal_response:.2f}")
    
    # å¯è¦–åŒ–
    fig = plt.figure(figsize=(16, 12))
    
    # 1. 3Då¿œç­”æ›²é¢
    ax1 = fig.add_subplot(2, 2, 1, projection='3d')
    surf = ax1.plot_surface(T_mesh, t_mesh, response_mesh, cmap='viridis', alpha=0.8)
    ax1.scatter(X_design[:, 0], X_design[:, 1], y_response, c='red', s=100, 
                marker='o', edgecolors='white', linewidth=2, label='å®Ÿé¨“ç‚¹')
    ax1.scatter(optimal_temp, optimal_time, optimal_response, c='gold', s=300, 
                marker='*', edgecolors='red', linewidth=2, label='æœ€é©ç‚¹')
    ax1.set_xlabel('æ¸©åº¦ (Â°C)', fontsize=11)
    ax1.set_ylabel('æ™‚é–“ (åˆ†)', fontsize=11)
    ax1.set_zlabel('å“è³ªã‚¹ã‚³ã‚¢', fontsize=11)
    ax1.set_title(f'å¿œç­”æ›²é¢ï¼ˆpH={ph_fixed}å›ºå®šï¼‰', fontsize=13, fontweight='bold')
    plt.colorbar(surf, ax=ax1, shrink=0.5, label='å“è³ªã‚¹ã‚³ã‚¢')
    
    # 2. ç­‰é«˜ç·šå›³
    ax2 = fig.add_subplot(2, 2, 2)
    contour = ax2.contourf(T_mesh, t_mesh, response_mesh, levels=15, cmap='viridis', alpha=0.9)
    contour_lines = ax2.contour(T_mesh, t_mesh, response_mesh, levels=10, colors='white', 
                                 linewidths=0.5, alpha=0.7)
    ax2.clabel(contour_lines, inline=True, fontsize=8, fmt='%.1f')
    ax2.scatter(X_design[:, 0], X_design[:, 1], c='red', s=100, 
                marker='o', edgecolors='white', linewidth=2, label='å®Ÿé¨“ç‚¹')
    ax2.scatter(optimal_temp, optimal_time, c='gold', s=300, 
                marker='*', edgecolors='red', linewidth=2, label='æœ€é©ç‚¹')
    ax2.set_xlabel('æ¸©åº¦ (Â°C)', fontsize=12)
    ax2.set_ylabel('æ™‚é–“ (åˆ†)', fontsize=12)
    ax2.set_title(f'ç­‰é«˜ç·šå›³ï¼ˆpH={ph_fixed}å›ºå®šï¼‰', fontsize=13, fontweight='bold')
    ax2.legend(fontsize=10)
    plt.colorbar(contour, ax=ax2, label='å“è³ªã‚¹ã‚³ã‚¢')
    
    # 3. äºˆæ¸¬vså®Ÿæ¸¬å€¤
    ax3 = fig.add_subplot(2, 2, 3)
    ax3.scatter(y_response, y_pred, c='#11998e', s=100, alpha=0.7, edgecolors='white', linewidth=1.5)
    ax3.plot([y_response.min(), y_response.max()], [y_response.min(), y_response.max()],
             'r--', linewidth=2, label='ç†æƒ³ãƒ©ã‚¤ãƒ³')
    ax3.set_xlabel('å®Ÿæ¸¬å€¤', fontsize=12)
    ax3.set_ylabel('äºˆæ¸¬å€¤', fontsize=12)
    ax3.set_title(f'äºˆæ¸¬ç²¾åº¦ï¼ˆRÂ²={r2_score:.4f}ï¼‰', fontsize=13, fontweight='bold')
    ax3.legend(fontsize=10)
    ax3.grid(True, alpha=0.3)
    
    # 4. ä¸»åŠ¹æœãƒ—ãƒ­ãƒƒãƒˆï¼ˆæ¸©åº¦ã®åŠ¹æœï¼‰
    ax4 = fig.add_subplot(2, 2, 4)
    temp_test = np.linspace(80, 100, 100)
    time_fixed = 20
    ph_test_fixed = 4.0
    
    response_temp_effect = []
    for t in temp_test:
        X_test = np.array([[t, time_fixed, ph_test_fixed]])
        X_test_poly = poly.transform(X_test)
        response_temp_effect.append(model.predict(X_test_poly)[0])
    
    ax4.plot(temp_test, response_temp_effect, linewidth=2.5, color='#11998e', label='äºˆæ¸¬å¿œç­”')
    ax4.scatter(X_design[:, 0], y_response, c='red', s=80, alpha=0.6, 
                edgecolors='white', linewidth=1.5, label='å®Ÿé¨“ç‚¹')
    ax4.axvline(x=optimal_temp, color='green', linestyle='--', linewidth=2, label='æœ€é©æ¸©åº¦')
    ax4.set_xlabel('æ¸©åº¦ (Â°C)', fontsize=12)
    ax4.set_ylabel('å“è³ªã‚¹ã‚³ã‚¢', fontsize=12)
    ax4.set_title(f'ä¸»åŠ¹æœãƒ—ãƒ­ãƒƒãƒˆï¼ˆæ™‚é–“={time_fixed}åˆ†, pH={ph_test_fixed}å›ºå®šï¼‰', 
                  fontsize=13, fontweight='bold')
    ax4.legend(fontsize=10)
    ax4.grid(True, alpha=0.3)
    
    plt.tight_layout()
    plt.savefig('response_surface_method.png', dpi=300, bbox_inches='tight')
    plt.show()

### âš ï¸ æœ€é©åŒ–å®Ÿè£…æ™‚ã®æ³¨æ„ç‚¹

  * **å±€æ‰€æœ€é©è§£** : éç·šå½¢æ€§ãŒå¼·ã„å ´åˆã€å±€æ‰€è§£ã«é™¥ã‚‹å¯èƒ½æ€§ã‚ã‚Šã€‚è¤‡æ•°ã®åˆæœŸå€¤ã‹ã‚‰æœ€é©åŒ–ã‚’å®Ÿè¡Œ
  * **åˆ¶ç´„æ¡ä»¶ã®å³å®ˆ** : é£Ÿå“å®‰å…¨åŸºæº–ï¼ˆHACCPã€Få€¤ï¼‰ã¯å¿…ãšæº€ãŸã™
  * **å®Ÿé¨“èª¤å·®ã®è€ƒæ…®** : ä¸­å¿ƒç‚¹ã‚’è¤‡æ•°å›ç¹°ã‚Šè¿”ã—ã¦ç´”èª¤å·®ã‚’æ¨å®š
  * **å¤–æŒ¿ã®å±é™ºæ€§** : å®Ÿé¨“ç¯„å›²å¤–ã§ã®äºˆæ¸¬ã¯ä¿¡é ¼æ€§ãŒä½ã„
  * **ãƒãƒƒãƒé–“å¤‰å‹•** : åŸææ–™å¤‰å‹•ã‚’è€ƒæ…®ã—ãŸãƒ­ãƒã‚¹ãƒˆæœ€é©åŒ–ãŒæœ›ã¾ã—ã„
  * **ã‚¹ã‚±ãƒ¼ãƒ«ã‚¢ãƒƒãƒ—** : ãƒ©ãƒœã‚¹ã‚±ãƒ¼ãƒ«ã®æœ€é©æ¡ä»¶ãŒå·¥å ´ã‚¹ã‚±ãƒ¼ãƒ«ã§å†ç¾ã•ã‚Œãªã„å ´åˆãŒã‚ã‚‹

## ã¾ã¨ã‚

æœ¬ç« ã§ã¯ã€é£Ÿå“ãƒ—ãƒ­ã‚»ã‚¹ã®æœ€é©åŒ–æ‰‹æ³•ã‚’å­¦ã³ã¾ã—ãŸï¼š

  * ãƒ™ã‚¤ã‚ºæœ€é©åŒ–ã«ã‚ˆã‚‹åŠ¹ç‡çš„ãªå®Ÿé¨“è¨ˆç”»ã¨æœ€é©æ¡ä»¶æ¢ç´¢
  * éºä¼çš„ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã«ã‚ˆã‚‹å¤šç›®çš„æœ€é©åŒ–ï¼ˆå“è³ªãƒ»ã‚³ã‚¹ãƒˆãƒ»ã‚¨ãƒãƒ«ã‚®ãƒ¼ï¼‰
  * å¿œç­”æ›²é¢æ³•ï¼ˆBox-Behnkenè¨ˆç”»ï¼‰ã«ã‚ˆã‚‹çµ±è¨ˆçš„æœ€é©åŒ–
  * åˆ¶ç´„æ¡ä»¶ï¼ˆHACCPã€é£Ÿå“å®‰å…¨åŸºæº–ï¼‰ã‚’è€ƒæ…®ã—ãŸå®Ÿç”¨çš„æœ€é©åŒ–

æ¬¡ç« ã§ã¯ã€äºˆçŸ¥ä¿å…¨ã¨ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã®å®Ÿè·µçš„æ‰‹æ³•ã‚’å­¦ã³ã¾ã™ã€‚

[â† ç¬¬2ç« : ãƒ—ãƒ­ã‚»ã‚¹ç›£è¦–ã¨å“è³ªç®¡ç†](<chapter-2.html>) ç¬¬4ç« : äºˆçŸ¥ä¿å…¨ã¨ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚° â†’ï¼ˆæº–å‚™ä¸­ï¼‰

### å…è²¬äº‹é …

  * æœ¬ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã¯æ•™è‚²ãƒ»ç ”ç©¶ãƒ»æƒ…å ±æä¾›ã®ã¿ã‚’ç›®çš„ã¨ã—ã¦ãŠã‚Šã€å°‚é–€çš„ãªåŠ©è¨€(æ³•å¾‹ãƒ»ä¼šè¨ˆãƒ»æŠ€è¡“çš„ä¿è¨¼ãªã©)ã‚’æä¾›ã™ã‚‹ã‚‚ã®ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚
  * æœ¬ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãŠã‚ˆã³ä»˜éšã™ã‚‹Code examplesã¯ã€Œç¾çŠ¶æœ‰å§¿(AS IS)ã€ã§æä¾›ã•ã‚Œã€æ˜ç¤ºã¾ãŸã¯é»™ç¤ºã‚’å•ã‚ãšã€å•†å“æ€§ã€ç‰¹å®šç›®çš„é©åˆæ€§ã€æ¨©åˆ©éä¾µå®³ã€æ­£ç¢ºæ€§ãƒ»å®Œå…¨æ€§ã€å‹•ä½œãƒ»å®‰å…¨æ€§ç­‰ã„ã‹ãªã‚‹ä¿è¨¼ã‚‚ã—ã¾ã›ã‚“ã€‚
  * å¤–éƒ¨ãƒªãƒ³ã‚¯ã€ç¬¬ä¸‰è€…ãŒæä¾›ã™ã‚‹ãƒ‡ãƒ¼ã‚¿ãƒ»ãƒ„ãƒ¼ãƒ«ãƒ»ãƒ©ã‚¤ãƒ–ãƒ©ãƒªç­‰ã®å†…å®¹ãƒ»å¯ç”¨æ€§ãƒ»å®‰å…¨æ€§ã«ã¤ã„ã¦ã€ä½œæˆè€…ãŠã‚ˆã³æ±åŒ—å¤§å­¦ã¯ä¸€åˆ‡ã®è²¬ä»»ã‚’è² ã„ã¾ã›ã‚“ã€‚
  * æœ¬ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®åˆ©ç”¨ãƒ»å®Ÿè¡Œãƒ»è§£é‡ˆã«ã‚ˆã‚Šç›´æ¥çš„ãƒ»é–“æ¥çš„ãƒ»ä»˜éšçš„ãƒ»ç‰¹åˆ¥ãƒ»çµæœçš„ãƒ»æ‡²ç½°çš„æå®³ãŒç”Ÿã˜ãŸå ´åˆã§ã‚‚ã€é©ç”¨æ³•ã§è¨±å®¹ã•ã‚Œã‚‹æœ€å¤§é™ã®ç¯„å›²ã§ã€ä½œæˆè€…ãŠã‚ˆã³æ±åŒ—å¤§å­¦ã¯è²¬ä»»ã‚’è² ã„ã¾ã›ã‚“ã€‚
  * æœ¬ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®å†…å®¹ã¯ã€äºˆå‘Šãªãå¤‰æ›´ãƒ»æ›´æ–°ãƒ»æä¾›åœæ­¢ã•ã‚Œã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚
  * æœ¬ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®è‘—ä½œæ¨©ãƒ»ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã¯æ˜è¨˜ã•ã‚ŒãŸæ¡ä»¶(ä¾‹: CC BY 4.0)ã«å¾“ã„ã¾ã™ã€‚å½“è©²ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã¯é€šå¸¸ã€ç„¡ä¿è¨¼æ¡é …ã‚’å«ã¿ã¾ã™ã€‚
