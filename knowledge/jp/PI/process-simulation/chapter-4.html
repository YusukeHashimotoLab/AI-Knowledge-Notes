<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="ç¬¬4ç« ï¼šãƒ—ãƒ­ã‚»ã‚¹ãƒ•ãƒ­ãƒ¼ã‚·ãƒ¼ãƒˆã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ - ãƒ—ãƒ­ã‚»ã‚¹ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å…¥é–€ã‚·ãƒªãƒ¼ã‚º">
    <title>ç¬¬4ç« ï¼šãƒ—ãƒ­ã‚»ã‚¹ãƒ•ãƒ­ãƒ¼ã‚·ãƒ¼ãƒˆã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ - ãƒ—ãƒ­ã‚»ã‚¹ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å…¥é–€ | PI Terakoya</title>

        <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            line-height: 1.8; color: #333; background: #f5f5f5;
        }
        header {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
            color: white; padding: 2rem 1rem; text-align: center;
        }
        h1 { font-size: 2rem; margin-bottom: 0.5rem; }
        .subtitle { opacity: 0.9; font-size: 1.1rem; }
        .container { max-width: 1200px; margin: 2rem auto; padding: 0 1rem; }
        .back-link {
            display: inline-block; margin-bottom: 2rem; padding: 0.5rem 1rem;
            background: white; color: #11998e; text-decoration: none;
            border-radius: 6px; font-weight: 600;
        }
        .content-box {
            background: white; padding: 2rem; border-radius: 12px;
            margin-bottom: 2rem; box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        h2 {
            color: #11998e; margin: 2rem 0 1rem 0;
            padding-bottom: 0.5rem; border-bottom: 3px solid #11998e;
        }
        h3 { color: #2c3e50; margin: 1.5rem 0 1rem 0; }
        h4 { color: #2c3e50; margin: 1rem 0 0.5rem 0; }
        p { margin-bottom: 1rem; }
        ul, ol { margin-left: 2rem; margin-bottom: 1rem; }
        li { margin-bottom: 0.5rem; }
        pre {
            background: #1e1e1e; color: #d4d4d4; padding: 1.5rem;
            border-radius: 8px; overflow-x: auto; margin: 1rem 0;
            border-left: 4px solid #11998e;
        }
        code {
            font-family: 'Courier New', monospace; font-size: 0.9rem;
        }
        .key-point {
            background: #e8f5e9; padding: 1rem; border-radius: 6px;
            border-left: 4px solid #4caf50; margin: 1rem 0;
        }
        .tech-note {
            background: #e3f2fd; padding: 1rem; border-radius: 6px;
            border-left: 4px solid #2196f3; margin: 1rem 0;
        }
        .formula {
            background: #f0f7ff; padding: 1rem; border-radius: 6px;
            margin: 1rem 0; overflow-x: auto;
        }
        table {
            width: 100%; border-collapse: collapse; margin: 1rem 0;
        }
        th, td {
            border: 1px solid #ddd; padding: 0.75rem; text-align: left;
        }
        th {
            background: #11998e; color: white; font-weight: 600;
        }
        tr:nth-child(even) { background: #f9f9f9; }
        .nav-buttons {
            display: flex; justify-content: space-between; margin-top: 3rem;
        }
        .nav-buttons a {
            padding: 0.75rem 1.5rem;
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
            color: white; text-decoration: none; border-radius: 6px;
            font-weight: 600;
        }
        footer {
            background: #2c3e50; color: white; text-align: center;
            padding: 2rem 1rem; margin-top: 4rem;
        }
        @media (max-width: 768px) {
            h1 { font-size: 1.6rem; }
            .container { padding: 0 0.5rem; }
            pre { padding: 1rem; }
        }
    
        
    
        /* Breadcrumb styles */
        .breadcrumb {
            background: #f7fafc;
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #e2e8f0;
            font-size: 0.9rem;
        }

        .breadcrumb-content {
            max-width: 900px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .breadcrumb a {
            color: #667eea;
            text-decoration: none;
            transition: color 0.2s;
        }

        .breadcrumb a:hover {
            color: #764ba2;
            text-decoration: underline;
        }

        .breadcrumb-separator {
            color: #a0aec0;
            margin: 0 0.25rem;
        }

        .breadcrumb-current {
            color: #4a5568;
            font-weight: 500;
        }
    </style>

    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <script>
        mermaid.initialize({ startOnLoad: true, theme: 'default', securityLevel: 'strict' });
    </script>

    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true,
                processEnvironments: true
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
                ignoreHtmlClass: 'mermaid'
            }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" id="MathJax-script" async></script>
</head>
<body>
            <nav class="breadcrumb">
        <div class="breadcrumb-content">
            <a href="../../index.html">AIå¯ºå­å±‹ãƒˆãƒƒãƒ—</a><span class="breadcrumb-separator">â€º</span><a href="../../PI/index.html">ãƒ—ãƒ­ã‚»ã‚¹ãƒ»ã‚¤ãƒ³ãƒ•ã‚©ãƒãƒ†ã‚£ã‚¯ã‚¹</a><span class="breadcrumb-separator">â€º</span><a href="../../PI/process-simulation/index.html">Process Simulation</a><span class="breadcrumb-separator">â€º</span><span class="breadcrumb-current">Chapter 4</span>
        </div>
    </nav>

        <header>
        <div class="container">
            <h1>ç¬¬4ç« ï¼šãƒ—ãƒ­ã‚»ã‚¹ãƒ•ãƒ­ãƒ¼ã‚·ãƒ¼ãƒˆã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³</h1>
            <p class="subtitle">è¤‡æ•°ãƒ¦ãƒ‹ãƒƒãƒˆã®çµ±åˆã€ãƒªã‚µã‚¤ã‚¯ãƒ«ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®åæŸã€æœ€é©åŒ–</p>
            <div class="meta">
                <span class="meta">ğŸ“– èª­äº†æ™‚é–“: 35-40åˆ†</span>
                <span class="meta">ğŸ“Š é›£æ˜“åº¦: ä¸­ç´š</span>
                <span class="meta">ğŸ’» ã‚³ãƒ¼ãƒ‰ä¾‹: 8å€‹</span>
            </div>
        </div>
    </header>

    <main class="container">

<div class="learning-objectives">
<h2>å­¦ç¿’ç›®æ¨™</h2>
<p>ã“ã®ç« ã‚’èª­ã‚€ã“ã¨ã§ã€ä»¥ä¸‹ã‚’ç¿’å¾—ã§ãã¾ã™ï¼š</p>
<ul>
<li>âœ… ãƒ•ãƒ­ãƒ¼ã‚·ãƒ¼ãƒˆã®ãƒˆãƒãƒ­ã‚¸ãƒ¼ã‚’ã‚°ãƒ©ãƒ•ç†è«–ã§è¡¨ç¾ã§ãã‚‹</li>
<li>âœ… é€æ¬¡è¨ˆç®—æ³•ã¨ãƒªã‚µã‚¤ã‚¯ãƒ«ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®åæŸè¨ˆç®—ã‚’å®Ÿè£…ã§ãã‚‹</li>
<li>âœ… è¤‡æ•°ãƒ¦ãƒ‹ãƒƒãƒˆã‚’çµ±åˆã—ãŸå®Œå…¨ãªãƒ—ãƒ­ã‚»ã‚¹ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’æ§‹ç¯‰ã§ãã‚‹</li>
<li>âœ… æ„Ÿåº¦åˆ†æã¨ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿æœ€é©åŒ–ã‚’å®Ÿè¡Œã§ãã‚‹</li>
<li>âœ… ãƒ’ãƒ¼ãƒˆã‚¤ãƒ³ãƒ†ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã®åŸºç¤ã‚’ç†è§£ã™ã‚‹</li>
</ul>
</div>

<hr />

<h2>4.1 ãƒ•ãƒ­ãƒ¼ã‚·ãƒ¼ãƒˆã®ãƒˆãƒãƒ­ã‚¸ãƒ¼è¡¨ç¾</h2>

<h3>ã‚°ãƒ©ãƒ•ç†è«–ã«ã‚ˆã‚‹ãƒ•ãƒ­ãƒ¼ã‚·ãƒ¼ãƒˆè¡¨ç¾</h3>

<p>åŒ–å­¦ãƒ—ãƒ­ã‚»ã‚¹ã®ãƒ•ãƒ­ãƒ¼ã‚·ãƒ¼ãƒˆã¯æœ‰å‘ã‚°ãƒ©ãƒ•ï¼ˆDirected Graphï¼‰ã¨ã—ã¦è¡¨ç¾ã§ãã¾ã™ã€‚å„ãƒ¦ãƒ‹ãƒƒãƒˆã¯ãƒãƒ¼ãƒ‰ã€ç‰©è³ªãƒ»ã‚¨ãƒãƒ«ã‚®ãƒ¼ã‚¹ãƒˆãƒªãƒ¼ãƒ ã¯ã‚¨ãƒƒã‚¸ã«å¯¾å¿œã—ã¾ã™ã€‚</p>

<pre><code class="language-python">"""
Example 1: Flowsheet Topology Representation
ãƒ•ãƒ­ãƒ¼ã‚·ãƒ¼ãƒˆãƒˆãƒãƒ­ã‚¸ãƒ¼ã®è¡¨ç¾ï¼ˆæœ‰å‘ã‚°ãƒ©ãƒ•ï¼‰
"""
import numpy as np
import networkx as nx
import matplotlib.pyplot as plt
from typing import Dict, List, Tuple

class FlowsheetTopology:
    """ãƒ•ãƒ­ãƒ¼ã‚·ãƒ¼ãƒˆã®ãƒˆãƒãƒ­ã‚¸ãƒ¼ã‚’ç®¡ç†ã™ã‚‹ã‚¯ãƒ©ã‚¹"""

    def __init__(self):
        self.graph = nx.DiGraph()
        self.streams = {}  # ã‚¹ãƒˆãƒªãƒ¼ãƒ æƒ…å ±

    def add_unit(self, unit_name: str, unit_type: str):
        """ãƒ¦ãƒ‹ãƒƒãƒˆã‚’è¿½åŠ """
        self.graph.add_node(unit_name, type=unit_type)

    def add_stream(self, from_unit: str, to_unit: str,
                   stream_name: str, stream_data: Dict = None):
        """ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’è¿½åŠ """
        self.graph.add_edge(from_unit, to_unit, name=stream_name)
        if stream_data:
            self.streams[stream_name] = stream_data

    def get_calculation_order(self) -> List[str]:
        """ãƒˆãƒãƒ­ã‚¸ã‚«ãƒ«ã‚½ãƒ¼ãƒˆã§è¨ˆç®—é †åºã‚’æ±ºå®š"""
        try:
            # ãƒªã‚µã‚¤ã‚¯ãƒ«ãŒãªã„å ´åˆã¯å˜ç´”ãªãƒˆãƒãƒ­ã‚¸ã‚«ãƒ«ã‚½ãƒ¼ãƒˆ
            return list(nx.topological_sort(self.graph))
        except nx.NetworkXError:
            # ã‚µã‚¤ã‚¯ãƒ«ï¼ˆãƒªã‚µã‚¤ã‚¯ãƒ«ï¼‰ãŒã‚ã‚‹å ´åˆ
            return self._handle_recycle()

    def _handle_recycle(self) -> List[str]:
        """ãƒªã‚µã‚¤ã‚¯ãƒ«ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’å«ã‚€è¨ˆç®—é †åºã®æ±ºå®š"""
        # æœ€ã‚‚å½±éŸ¿ã®å°ã•ã„ã‚¨ãƒƒã‚¸ã‚’åˆ‡æ–­ã—ã¦ãƒˆãƒãƒ­ã‚¸ã‚«ãƒ«ã‚½ãƒ¼ãƒˆ
        cycles = list(nx.simple_cycles(self.graph))
        print(f"Recycle loops detected: {cycles}")

        # ãƒªã‚µã‚¤ã‚¯ãƒ«ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ç‰¹å®šï¼ˆç°¡æ˜“ç‰ˆï¼šæœ€åˆã®ã‚µã‚¤ã‚¯ãƒ«ã®ã¿ï¼‰
        if cycles:
            recycle_edge = (cycles[0][-1], cycles[0][0])
            temp_graph = self.graph.copy()
            temp_graph.remove_edge(*recycle_edge)
            order = list(nx.topological_sort(temp_graph))
            print(f"Calculation order (with recycle): {order}")
            return order
        return []

    def visualize(self):
        """ãƒ•ãƒ­ãƒ¼ã‚·ãƒ¼ãƒˆã‚’å¯è¦–åŒ–"""
        plt.figure(figsize=(10, 6))
        pos = nx.spring_layout(self.graph, seed=42)

        # ãƒãƒ¼ãƒ‰ã®è‰²åˆ†ã‘ï¼ˆãƒ¦ãƒ‹ãƒƒãƒˆã‚¿ã‚¤ãƒ—åˆ¥ï¼‰
        node_colors = []
        for node in self.graph.nodes():
            unit_type = self.graph.nodes[node].get('type', 'unknown')
            colors = {'reactor': '#ff6b6b', 'separator': '#4ecdc4',
                     'heater': '#ffe66d', 'cooler': '#95e1d3'}
            node_colors.append(colors.get(unit_type, '#gray'))

        nx.draw(self.graph, pos, with_labels=True,
               node_color=node_colors, node_size=2000,
               font_size=10, font_weight='bold',
               arrows=True, arrowsize=20, edge_color='#666')

        # ã‚¨ãƒƒã‚¸ãƒ©ãƒ™ãƒ«ï¼ˆã‚¹ãƒˆãƒªãƒ¼ãƒ åï¼‰
        edge_labels = nx.get_edge_attributes(self.graph, 'name')
        nx.draw_networkx_edge_labels(self.graph, pos, edge_labels)

        plt.title("Process Flowsheet Topology")
        plt.axis('off')
        plt.tight_layout()
        plt.show()

# ä½¿ç”¨ä¾‹
flowsheet = FlowsheetTopology()

# ãƒ¦ãƒ‹ãƒƒãƒˆã‚’è¿½åŠ 
flowsheet.add_unit("FEED", "feed")
flowsheet.add_unit("R-101", "reactor")
flowsheet.add_unit("T-101", "separator")
flowsheet.add_unit("PRODUCT", "product")

# ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’è¿½åŠ 
flowsheet.add_stream("FEED", "R-101", "S-01")
flowsheet.add_stream("R-101", "T-101", "S-02")
flowsheet.add_stream("T-101", "PRODUCT", "S-03")
flowsheet.add_stream("T-101", "R-101", "S-04")  # Recycle

# è¨ˆç®—é †åºã‚’å–å¾—
calc_order = flowsheet.get_calculation_order()
print(f"Calculation order: {calc_order}")

# å¯è¦–åŒ–
flowsheet.visualize()
</code></pre>

<h3>è¨ˆç®—é †åºã®æ±ºå®š</h3>

<p>ãƒˆãƒãƒ­ã‚¸ã‚«ãƒ«ã‚½ãƒ¼ãƒˆï¼ˆTopological Sortï¼‰ã«ã‚ˆã‚Šã€ä¸Šæµã‹ã‚‰ä¸‹æµã¸ã®è¨ˆç®—é †åºãŒè‡ªå‹•çš„ã«æ±ºå®šã•ã‚Œã¾ã™ã€‚ãƒªã‚µã‚¤ã‚¯ãƒ«ã‚¹ãƒˆãƒªãƒ¼ãƒ ãŒã‚ã‚‹å ´åˆã¯åå¾©è¨ˆç®—ãŒå¿…è¦ã§ã™ã€‚</p>

<hr />

<h2>4.2 ãƒªã‚µã‚¤ã‚¯ãƒ«ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®åæŸè¨ˆç®—</h2>

<h3>é€æ¬¡ä»£å…¥æ³•ï¼ˆSuccessive Substitutionï¼‰</h3>

<p>ãƒªã‚µã‚¤ã‚¯ãƒ«ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’å«ã‚€ãƒ•ãƒ­ãƒ¼ã‚·ãƒ¼ãƒˆã§ã¯ã€ä»®å®šå€¤ã‹ã‚‰é–‹å§‹ã—ã¦åæŸã™ã‚‹ã¾ã§åå¾©è¨ˆç®—ã‚’è¡Œã„ã¾ã™ã€‚</p>

<pre><code class="language-python">"""
Example 2: Recycle Stream Convergence
ãƒªã‚µã‚¤ã‚¯ãƒ«ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®åæŸè¨ˆç®—ï¼ˆé€æ¬¡ä»£å…¥æ³•ï¼‰
"""
import numpy as np
from scipy.optimize import fsolve

class RecycleConvergence:
    """ãƒªã‚µã‚¤ã‚¯ãƒ«ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®åæŸè¨ˆç®—"""

    def __init__(self, max_iter=100, tol=1e-6):
        self.max_iter = max_iter
        self.tol = tol
        self.history = []

    def successive_substitution(self, flowsheet_func,
                                initial_guess, damping=0.5):
        """
        é€æ¬¡ä»£å…¥æ³•ã«ã‚ˆã‚‹åæŸè¨ˆç®—

        Args:
            flowsheet_func: ãƒ•ãƒ­ãƒ¼ã‚·ãƒ¼ãƒˆè¨ˆç®—é–¢æ•°ï¼ˆå…¥åŠ›â†’å‡ºåŠ›ï¼‰
            initial_guess: ãƒªã‚µã‚¤ã‚¯ãƒ«ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®åˆæœŸæ¨å®šå€¤
            damping: æ¸›è¡°ä¿‚æ•°ï¼ˆ0-1ã€åæŸå®‰å®šæ€§å‘ä¸Šï¼‰

        Returns:
            converged_value: åæŸå€¤
            iterations: åå¾©å›æ•°
        """
        x_old = np.array(initial_guess)

        for iteration in range(self.max_iter):
            # ãƒ•ãƒ­ãƒ¼ã‚·ãƒ¼ãƒˆè¨ˆç®—
            x_new = flowsheet_func(x_old)

            # æ¸›è¡°ï¼ˆåæŸæ€§å‘ä¸Šï¼‰
            x_damped = damping * x_new + (1 - damping) * x_old

            # åæŸåˆ¤å®š
            error = np.linalg.norm(x_damped - x_old)
            self.history.append({'iter': iteration, 'error': error,
                               'value': x_damped.copy()})

            print(f"Iter {iteration}: error = {error:.2e}")

            if error < self.tol:
                print(f"Converged in {iteration} iterations")
                return x_damped, iteration

            x_old = x_damped

        print("WARNING: Did not converge")
        return x_old, self.max_iter

    def wegstein_acceleration(self, flowsheet_func, initial_guess):
        """
        WegsteinåŠ é€Ÿæ³•ï¼ˆåæŸæ€§å‘ä¸Šï¼‰

        é€æ¬¡ä»£å…¥æ³•ã‚ˆã‚Šé«˜é€Ÿã«åæŸã™ã‚‹å ´åˆãŒå¤šã„
        """
        x0 = np.array(initial_guess)
        x1 = flowsheet_func(x0)

        for iteration in range(self.max_iter):
            x2 = flowsheet_func(x1)

            # WegsteinåŠ é€Ÿãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
            q = (x2 - x1) / (x1 - x0 + 1e-10)
            q_safe = np.clip(q, -5, 0)  # å®‰å®šåŒ–

            # åŠ é€Ÿ
            x_new = (q_safe * x1 - x0) / (q_safe - 1)

            # åæŸåˆ¤å®š
            error = np.linalg.norm(x_new - x1)
            self.history.append({'iter': iteration, 'error': error})

            if error < self.tol:
                print(f"Wegstein converged in {iteration} iterations")
                return x_new, iteration

            x0, x1 = x1, x_new

        return x1, self.max_iter

# ä½¿ç”¨ä¾‹ï¼šç°¡å˜ãªãƒªã‚µã‚¤ã‚¯ãƒ«ãƒ«ãƒ¼ãƒ—
def simple_recycle_flowsheet(recycle_flow):
    """
    ç°¡å˜ãªãƒªã‚µã‚¤ã‚¯ãƒ«ãƒ•ãƒ­ãƒ¼ã‚·ãƒ¼ãƒˆ
    recycle_flow: ãƒªã‚µã‚¤ã‚¯ãƒ«æµé‡ [kmol/h]
    returns: æ–°ã—ã„ãƒªã‚µã‚¤ã‚¯ãƒ«æµé‡
    """
    feed_flow = 100.0  # kmol/h
    conversion = 0.8

    total_feed = feed_flow + recycle_flow
    product = total_feed * conversion
    recycle_new = total_feed * (1 - conversion)

    return np.array([recycle_new])

# åæŸè¨ˆç®—
solver = RecycleConvergence(tol=1e-6)
initial = np.array([10.0])  # åˆæœŸæ¨å®šå€¤

# é€æ¬¡ä»£å…¥æ³•
recycle_conv, iters = solver.successive_substitution(
    simple_recycle_flowsheet, initial, damping=0.7
)
print(f"Converged recycle flow: {recycle_conv[0]:.2f} kmol/h")
</code></pre>

<hr />

<h2>4.3 å®Œå…¨ãƒ•ãƒ­ãƒ¼ã‚·ãƒ¼ãƒˆã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³</h2>

<h3>è’¸ç•™å¡”ï¼‹åå¿œå™¨ï¼‹åˆ†é›¢å™¨ã®çµ±åˆ</h3>

<p>å®Ÿç”¨çš„ãªãƒ•ãƒ­ãƒ¼ã‚·ãƒ¼ãƒˆã§ã¯ã€è¤‡æ•°ã®ãƒ¦ãƒ‹ãƒƒãƒˆãŒç›¸äº’ä½œç”¨ã—ã¾ã™ã€‚ã“ã“ã§ã¯è’¸ç•™å¡”ã§ç²¾è£½ã—ãŸåŸæ–™ã‚’åå¿œå™¨ã§åå¿œã•ã›ã€ç”Ÿæˆç‰©ã‚’åˆ†é›¢ã™ã‚‹ãƒ—ãƒ­ã‚»ã‚¹ã‚’æ§‹ç¯‰ã—ã¾ã™ã€‚</p>

<pre><code class="language-python">"""
Example 3: Complete Flowsheet Simulation
å®Œå…¨ãƒ•ãƒ­ãƒ¼ã‚·ãƒ¼ãƒˆã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆè’¸ç•™+åå¿œ+åˆ†é›¢+ãƒªã‚µã‚¤ã‚¯ãƒ«ï¼‰
"""
import numpy as np
from dataclasses import dataclass
from typing import Dict

@dataclass
class Stream:
    """ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®ãƒ‡ãƒ¼ã‚¿æ§‹é€ """
    flow: float  # kmol/h
    composition: Dict[str, float]  # mol fraction
    temperature: float  # K
    pressure: float  # bar

    def __repr__(self):
        return f"Stream(F={self.flow:.1f}, T={self.temperature:.1f}K)"

class CompleteFlowsheet:
    """å®Œå…¨ãªãƒ—ãƒ­ã‚»ã‚¹ãƒ•ãƒ­ãƒ¼ã‚·ãƒ¼ãƒˆ"""

    def __init__(self):
        self.streams = {}
        self.convergence_history = []

    def reactor(self, feed: Stream, conversion=0.75) -> Stream:
        """åå¿œå™¨: A â†’ B"""
        product = Stream(
            flow=feed.flow,
            composition={
                'A': feed.composition['A'] * (1 - conversion),
                'B': feed.composition['A'] * conversion + feed.composition.get('B', 0)
            },
            temperature=feed.temperature + 50,  # ç™ºç†±åå¿œ
            pressure=feed.pressure
        )
        return product

    def distillation(self, feed: Stream, recovery_A=0.95) -> Tuple[Stream, Stream]:
        """è’¸ç•™å¡”: Aã¨Bã‚’åˆ†é›¢"""
        # å¡”é ‚ï¼ˆA richï¼‰
        distillate_flow = feed.flow * feed.composition['A'] * recovery_A
        distillate = Stream(
            flow=distillate_flow,
            composition={'A': 0.98, 'B': 0.02},
            temperature=350,
            pressure=1.5
        )

        # å¡”åº•ï¼ˆB richï¼‰
        bottoms_flow = feed.flow - distillate_flow
        bottoms = Stream(
            flow=bottoms_flow,
            composition={'A': 0.05, 'B': 0.95},
            temperature=400,
            pressure=1.5
        )

        return distillate, bottoms

    def mixer(self, streams: List[Stream]) -> Stream:
        """ãƒŸã‚­ã‚µãƒ¼ï¼šè¤‡æ•°ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®æ··åˆ"""
        total_flow = sum(s.flow for s in streams)

        # ç‰©è³ªåæ”¯
        comp_A = sum(s.flow * s.composition['A'] for s in streams) / total_flow
        comp_B = sum(s.flow * s.composition['B'] for s in streams) / total_flow

        mixed = Stream(
            flow=total_flow,
            composition={'A': comp_A, 'B': comp_B},
            temperature=sum(s.flow * s.temperature for s in streams) / total_flow,
            pressure=min(s.pressure for s in streams)
        )
        return mixed

    def simulate(self, feed: Stream, recycle_ratio=0.5,
                max_iter=50, tol=1e-4):
        """
        å®Œå…¨ãƒ•ãƒ­ãƒ¼ã‚·ãƒ¼ãƒˆã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³

        ãƒ•ãƒ­ãƒ¼: Feed â†’ Mixer â†’ Reactor â†’ Distillation
                             â†‘              â†“
                             â† Recycle â†â”€â”€â”€ Distillate
        """
        # åˆæœŸãƒªã‚µã‚¤ã‚¯ãƒ«æ¨å®š
        recycle = Stream(
            flow=feed.flow * recycle_ratio,
            composition={'A': 0.98, 'B': 0.02},
            temperature=350,
            pressure=1.5
        )

        for iteration in range(max_iter):
            # 1. ãƒŸã‚­ã‚µãƒ¼
            mixed = self.mixer([feed, recycle])

            # 2. åå¿œå™¨
            reactor_out = self.reactor(mixed, conversion=0.75)

            # 3. è’¸ç•™å¡”
            distillate, bottoms = self.distillation(reactor_out, recovery_A=0.95)

            # 4. ãƒªã‚µã‚¤ã‚¯ãƒ«æ›´æ–°
            recycle_new = distillate

            # åæŸåˆ¤å®š
            error = abs(recycle_new.flow - recycle.flow)
            self.convergence_history.append(error)

            print(f"Iter {iteration}: Recycle flow error = {error:.2e} kmol/h")

            if error < tol:
                print(f"âœ“ Converged in {iteration} iterations")

                # çµæœä¿å­˜
                self.streams = {
                    'feed': feed,
                    'mixed': mixed,
                    'reactor_out': reactor_out,
                    'distillate': distillate,
                    'bottoms': bottoms,
                    'recycle': recycle_new
                }

                return self.streams

            recycle = recycle_new

        print("âš  Did not converge")
        return self.streams

    def print_results(self):
        """çµæœã®è¡¨ç¤º"""
        print("\n=== Flowsheet Simulation Results ===")
        for name, stream in self.streams.items():
            print(f"{name:15s}: {stream}")
            print(f"  Composition: A={stream.composition['A']:.3f}, "
                  f"B={stream.composition['B']:.3f}")

# ä½¿ç”¨ä¾‹
flowsheet = CompleteFlowsheet()

# ãƒ•ã‚£ãƒ¼ãƒ‰æ¡ä»¶
feed = Stream(
    flow=100.0,
    composition={'A': 1.0, 'B': 0.0},
    temperature=300,
    pressure=2.0
)

# ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å®Ÿè¡Œ
results = flowsheet.simulate(feed, recycle_ratio=0.3)
flowsheet.print_results()

# åæŸå±¥æ­´ã‚’ãƒ—ãƒ­ãƒƒãƒˆ
import matplotlib.pyplot as plt
plt.figure(figsize=(8, 5))
plt.semilogy(flowsheet.convergence_history, 'o-')
plt.xlabel('Iteration')
plt.ylabel('Recycle Flow Error [kmol/h]')
plt.title('Convergence History')
plt.grid(True, alpha=0.3)
plt.show()
</code></pre>

<hr />

<h2>4.4 æ„Ÿåº¦åˆ†æï¼ˆSensitivity Analysisï¼‰</h2>

<h3>ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å¤‰åŒ–ã®å½±éŸ¿è©•ä¾¡</h3>

<p>æ“ä½œæ¡ä»¶ã®å¤‰åŒ–ãŒè£½å“åç‡ã‚„ã‚¨ãƒãƒ«ã‚®ãƒ¼æ¶ˆè²»ã«ä¸ãˆã‚‹å½±éŸ¿ã‚’å®šé‡åŒ–ã—ã¾ã™ã€‚</p>

<pre><code class="language-python">"""
Example 4: Sensitivity Analysis
æ„Ÿåº¦åˆ†æï¼ˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å¤‰åŒ–ã®å½±éŸ¿è©•ä¾¡ï¼‰
"""
import numpy as np
import matplotlib.pyplot as plt

class SensitivityAnalyzer:
    """æ„Ÿåº¦åˆ†æãƒ„ãƒ¼ãƒ«"""

    def __init__(self, flowsheet):
        self.flowsheet = flowsheet

    def analyze_parameter(self, param_name, param_range,
                         output_metrics):
        """
        å˜ä¸€ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®æ„Ÿåº¦åˆ†æ

        Args:
            param_name: ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å
            param_range: ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®ç¯„å›²ï¼ˆarrayï¼‰
            output_metrics: å‡ºåŠ›æŒ‡æ¨™ã®ãƒªã‚¹ãƒˆ
        """
        results = {metric: [] for metric in output_metrics}

        for param_value in param_range:
            # ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿è¨­å®šã—ã¦ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
            # ï¼ˆå®Ÿè£…ã¯çœç•¥ï¼šflowsheetå†…ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’å¤‰æ›´ï¼‰

            # ä¾‹ï¼šåå¿œå™¨è»¢åŒ–ç‡ã®å½±éŸ¿
            conversion = param_value
            # ã“ã“ã§flowsheet.simulateã‚’å®Ÿè¡Œ

            # å‡ºåŠ›æŒ‡æ¨™ã‚’è¨ˆç®—
            yield_B = 0.75 * conversion  # ç°¡ç•¥åŒ–
            energy = 1000 + 500 * conversion  # kW

            results['yield'].append(yield_B)
            results['energy'].append(energy)

        return results

    def plot_sensitivity(self, param_name, param_range, results):
        """æ„Ÿåº¦åˆ†æçµæœã®ãƒ—ãƒ­ãƒƒãƒˆ"""
        fig, axes = plt.subplots(1, len(results), figsize=(12, 4))

        if len(results) == 1:
            axes = [axes]

        for ax, (metric, values) in zip(axes, results.items()):
            ax.plot(param_range, values, 'o-', linewidth=2)
            ax.set_xlabel(param_name)
            ax.set_ylabel(metric)
            ax.grid(True, alpha=0.3)
            ax.set_title(f'{metric} vs {param_name}')

        plt.tight_layout()
        plt.show()

    def tornado_plot(self, params_impact):
        """
        ãƒˆãƒ«ãƒãƒ¼ãƒ‰å›³ï¼ˆè¤‡æ•°ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®å½±éŸ¿åº¦æ¯”è¼ƒï¼‰

        Args:
            params_impact: {param_name: (min_value, max_value), ...}
        """
        params = list(params_impact.keys())
        impacts = [abs(max_val - min_val)
                  for min_val, max_val in params_impact.values()]

        # å½±éŸ¿åº¦é †ã«ã‚½ãƒ¼ãƒˆ
        sorted_idx = np.argsort(impacts)
        params_sorted = [params[i] for i in sorted_idx]
        impacts_sorted = [impacts[i] for i in sorted_idx]

        plt.figure(figsize=(8, 6))
        plt.barh(params_sorted, impacts_sorted, color='steelblue')
        plt.xlabel('Impact on Product Yield')
        plt.title('Tornado Diagram - Parameter Sensitivity')
        plt.grid(True, alpha=0.3, axis='x')
        plt.tight_layout()
        plt.show()

# ä½¿ç”¨ä¾‹
analyzer = SensitivityAnalyzer(flowsheet)

# åå¿œå™¨è»¢åŒ–ç‡ã®æ„Ÿåº¦åˆ†æ
conversion_range = np.linspace(0.5, 0.95, 10)
results = {
    'yield': 100 * conversion_range * 0.75,
    'energy': 1000 + 500 * conversion_range
}

# ãƒ—ãƒ­ãƒƒãƒˆ
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 4))

ax1.plot(conversion_range, results['yield'], 'o-', linewidth=2)
ax1.set_xlabel('Reactor Conversion')
ax1.set_ylabel('Product Yield [kmol/h]')
ax1.grid(True, alpha=0.3)

ax2.plot(conversion_range, results['energy'], 'o-',
        linewidth=2, color='orangered')
ax2.set_xlabel('Reactor Conversion')
ax2.set_ylabel('Energy Consumption [kW]')
ax2.grid(True, alpha=0.3)

plt.tight_layout()
plt.show()
</code></pre>

<hr />

<h2>4.5 æœ€é©åŒ–ï¼ˆOptimizationï¼‰</h2>

<h3>çµŒæ¸ˆæ€§ã¨ç’°å¢ƒè² è·ã®ãƒãƒ©ãƒ³ã‚¹</h3>

<p>åç›Šæœ€å¤§åŒ–ã€ã‚³ã‚¹ãƒˆæœ€å°åŒ–ã€ç’°å¢ƒè² è·ä½æ¸›ãªã©ã®ç›®çš„é–¢æ•°ã‚’æœ€é©åŒ–ã—ã¾ã™ã€‚</p>

<pre><code class="language-python">"""
Example 5: Flowsheet Optimization
ãƒ•ãƒ­ãƒ¼ã‚·ãƒ¼ãƒˆæœ€é©åŒ–ï¼ˆåç›Šæœ€å¤§åŒ–ï¼‰
"""
from scipy.optimize import minimize, differential_evolution
import numpy as np

class FlowsheetOptimizer:
    """ãƒ•ãƒ­ãƒ¼ã‚·ãƒ¼ãƒˆæœ€é©åŒ–"""

    def __init__(self, flowsheet):
        self.flowsheet = flowsheet

    def objective_profit(self, x):
        """
        ç›®çš„é–¢æ•°ï¼šåˆ©ç›Šæœ€å¤§åŒ– = åç›Š - ã‚³ã‚¹ãƒˆ

        Args:
            x: æ±ºå®šå¤‰æ•° [conversion, recycle_ratio]

        Returns:
            -profit (æœ€å°åŒ–å•é¡Œã«å¤‰æ›)
        """
        conversion, recycle_ratio = x

        # ãƒ•ãƒ­ãƒ¼ã‚·ãƒ¼ãƒˆã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆç°¡ç•¥åŒ–ï¼‰
        feed_flow = 100.0
        product_flow = feed_flow * conversion * 0.9

        # åç›Š
        product_price = 1000  # $/kmol
        revenue = product_flow * product_price

        # ã‚³ã‚¹ãƒˆ
        raw_material_cost = feed_flow * 500  # $/kmol
        energy_cost = (1000 + 500 * conversion) * 0.1  # $/kW
        recycle_cost = recycle_ratio * 1000

        total_cost = raw_material_cost + energy_cost + recycle_cost

        profit = revenue - total_cost

        return -profit  # æœ€å¤§åŒ– â†’ æœ€å°åŒ–

    def constraints(self, x):
        """åˆ¶ç´„æ¡ä»¶"""
        conversion, recycle_ratio = x

        # åˆ¶ç´„ï¼šè»¢åŒ–ç‡ã¯0.5-0.95ã€ãƒªã‚µã‚¤ã‚¯ãƒ«æ¯”ã¯0-0.8
        constraints = [
            conversion - 0.5,      # conversion >= 0.5
            0.95 - conversion,     # conversion <= 0.95
            recycle_ratio,         # recycle_ratio >= 0
            0.8 - recycle_ratio    # recycle_ratio <= 0.8
        ]

        return constraints

    def optimize_local(self, x0):
        """å±€æ‰€æœ€é©åŒ–ï¼ˆå‹¾é…æ³•ï¼‰"""
        bounds = [(0.5, 0.95), (0, 0.8)]

        result = minimize(
            self.objective_profit,
            x0,
            method='SLSQP',
            bounds=bounds,
            options={'disp': True}
        )

        return result

    def optimize_global(self):
        """å¤§åŸŸæœ€é©åŒ–ï¼ˆDifferential Evolutionï¼‰"""
        bounds = [(0.5, 0.95), (0, 0.8)]

        result = differential_evolution(
            self.objective_profit,
            bounds,
            maxiter=100,
            popsize=15,
            disp=True
        )

        return result

# ä½¿ç”¨ä¾‹
optimizer = FlowsheetOptimizer(flowsheet)

# åˆæœŸæ¨å®šå€¤
x0 = np.array([0.75, 0.3])

# å±€æ‰€æœ€é©åŒ–
print("=== Local Optimization ===")
result_local = optimizer.optimize_local(x0)
print(f"Optimal conversion: {result_local.x[0]:.4f}")
print(f"Optimal recycle ratio: {result_local.x[1]:.4f}")
print(f"Maximum profit: ${-result_local.fun:.2f}/h")

# å¤§åŸŸæœ€é©åŒ–
print("\n=== Global Optimization ===")
result_global = optimizer.optimize_global()
print(f"Optimal conversion: {result_global.x[0]:.4f}")
print(f"Optimal recycle ratio: {result_global.x[1]:.4f}")
print(f"Maximum profit: ${-result_global.fun:.2f}/h")
</code></pre>

<hr />

<h2>4.6 ãƒ’ãƒ¼ãƒˆã‚¤ãƒ³ãƒ†ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³åŸºç¤</h2>

<h3>Pinchè§£æã®å°å…¥</h3>

<p>ãƒ—ãƒ­ã‚»ã‚¹å†…ã®ç†±äº¤æ›ã‚’æœ€é©åŒ–ã—ã€ã‚¨ãƒãƒ«ã‚®ãƒ¼æ¶ˆè²»ã‚’å‰Šæ¸›ã—ã¾ã™ã€‚</p>

<pre><code class="language-python">"""
Example 6: Heat Integration Basics
ãƒ’ãƒ¼ãƒˆã‚¤ãƒ³ãƒ†ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³åŸºç¤ï¼ˆãƒ”ãƒ³ãƒè§£æï¼‰
"""
import numpy as np
import matplotlib.pyplot as plt
from dataclasses import dataclass
from typing import List

@dataclass
class HeatStream:
    """ç†±ã‚¹ãƒˆãƒªãƒ¼ãƒ """
    name: str
    type: str  # 'hot' or 'cold'
    T_supply: float  # K
    T_target: float  # K
    heat_capacity_flow: float  # kW/K

    @property
    def heat_load(self):
        """ç†±è² è· [kW]"""
        return abs(self.heat_capacity_flow * (self.T_target - self.T_supply))

class PinchAnalyzer:
    """Pinchè§£æãƒ„ãƒ¼ãƒ«"""

    def __init__(self, min_approach_temp=10):
        """
        Args:
            min_approach_temp: æœ€å°æ¥è¿‘æ¸©åº¦å·® [K]
        """
        self.dT_min = min_approach_temp
        self.hot_streams = []
        self.cold_streams = []

    def add_stream(self, stream: HeatStream):
        """ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’è¿½åŠ """
        if stream.type == 'hot':
            self.hot_streams.append(stream)
        else:
            self.cold_streams.append(stream)

    def calculate_composite_curves(self):
        """è¤‡åˆæ›²ç·šã‚’è¨ˆç®—"""
        # æ¸©åº¦é–“éš”ã®ä½œæˆ
        temps = []
        for stream in self.hot_streams + self.cold_streams:
            temps.extend([stream.T_supply, stream.T_target])
        temps = sorted(set(temps))

        # Hot composite curve
        hot_curve = []
        Q_hot = 0
        for T in sorted(temps, reverse=True):
            for stream in self.hot_streams:
                if stream.T_target <= T <= stream.T_supply:
                    dT = T - max(T - 1, stream.T_target)
                    Q_hot += stream.heat_capacity_flow * abs(dT)
            hot_curve.append((T, Q_hot))

        # Cold composite curve (shifted by dT_min)
        cold_curve = []
        Q_cold = 0
        for T in sorted(temps):
            for stream in self.cold_streams:
                if stream.T_supply <= T <= stream.T_target:
                    dT = min(T + 1, stream.T_target) - T
                    Q_cold += stream.heat_capacity_flow * abs(dT)
            cold_curve.append((T + self.dT_min, Q_cold))

        return hot_curve, cold_curve

    def find_pinch_point(self, hot_curve, cold_curve):
        """ãƒ”ãƒ³ãƒãƒã‚¤ãƒ³ãƒˆã‚’ç‰¹å®š"""
        # æœ€å°è·é›¢ã‚’æ¢ç´¢ï¼ˆç°¡ç•¥åŒ–ï¼‰
        min_distance = float('inf')
        pinch_temp = None

        for T_hot, Q_hot in hot_curve:
            for T_cold, Q_cold in cold_curve:
                if abs(T_hot - T_cold) < min_distance:
                    min_distance = abs(T_hot - T_cold)
                    pinch_temp = T_hot

        return pinch_temp, min_distance

    def calculate_utilities(self):
        """å¿…è¦ãªãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ï¼ˆåŠ ç†±ãƒ»å†·å´ï¼‰ã‚’è¨ˆç®—"""
        total_hot_load = sum(s.heat_load for s in self.hot_streams)
        total_cold_load = sum(s.heat_load for s in self.cold_streams)

        if total_hot_load > total_cold_load:
            heating_utility = 0
            cooling_utility = total_hot_load - total_cold_load
        else:
            heating_utility = total_cold_load - total_hot_load
            cooling_utility = 0

        return heating_utility, cooling_utility

    def plot_composite_curves(self):
        """è¤‡åˆæ›²ç·šã‚’ãƒ—ãƒ­ãƒƒãƒˆ"""
        hot_curve, cold_curve = self.calculate_composite_curves()

        plt.figure(figsize=(10, 6))

        # Hot composite curve
        T_hot, Q_hot = zip(*hot_curve)
        plt.plot(Q_hot, T_hot, 'r-', linewidth=2, label='Hot Composite')

        # Cold composite curve
        T_cold, Q_cold = zip(*cold_curve)
        plt.plot(Q_cold, T_cold, 'b-', linewidth=2, label='Cold Composite')

        plt.xlabel('Heat Load [kW]')
        plt.ylabel('Temperature [K]')
        plt.title('Composite Curves (Pinch Analysis)')
        plt.legend()
        plt.grid(True, alpha=0.3)
        plt.tight_layout()
        plt.show()

# ä½¿ç”¨ä¾‹
analyzer = PinchAnalyzer(min_approach_temp=10)

# ç†±ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’è¿½åŠ 
analyzer.add_stream(HeatStream('H1', 'hot', 450, 350, 20))
analyzer.add_stream(HeatStream('H2', 'hot', 400, 320, 15))
analyzer.add_stream(HeatStream('C1', 'cold', 300, 420, 18))
analyzer.add_stream(HeatStream('C2', 'cold', 330, 390, 12))

# ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£è¨ˆç®—
heating, cooling = analyzer.calculate_utilities()
print(f"Heating utility required: {heating:.1f} kW")
print(f"Cooling utility required: {cooling:.1f} kW")

# è¤‡åˆæ›²ç·šã‚’ãƒ—ãƒ­ãƒƒãƒˆ
analyzer.plot_composite_curves()
</code></pre>

<hr />

<h2>4.7 ã‚±ãƒ¼ã‚¹ã‚¹ã‚¿ãƒ‡ã‚£ï¼šåŒ–å­¦ãƒ—ãƒ©ãƒ³ãƒˆå…¨ä½“ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³</h2>

<h3>çµ±åˆãƒ—ãƒ­ã‚»ã‚¹è¨­è¨ˆ</h3>

<p>å®Ÿéš›ã®åŒ–å­¦ãƒ—ãƒ©ãƒ³ãƒˆè¨­è¨ˆã§ã¯ã€åå¿œã€åˆ†é›¢ã€ç†±äº¤æ›ã€ãƒªã‚µã‚¤ã‚¯ãƒ«ã‚’å…¨ã¦çµ±åˆã—ã¾ã™ã€‚</p>

<pre><code class="language-python">"""
Example 7: Complete Chemical Plant Simulation
åŒ–å­¦ãƒ—ãƒ©ãƒ³ãƒˆå…¨ä½“ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆçµ±åˆã‚±ãƒ¼ã‚¹ã‚¹ã‚¿ãƒ‡ã‚£ï¼‰
"""
import numpy as np
from dataclasses import dataclass, field
from typing import Dict, List

@dataclass
class PlantPerformance:
    """ãƒ—ãƒ©ãƒ³ãƒˆæ€§èƒ½æŒ‡æ¨™"""
    production_rate: float  # kmol/h
    yield_overall: float  # %
    energy_consumption: float  # kW
    raw_material_usage: float  # kmol/h
    profit_per_hour: float  # $/h

    def display(self):
        print("\n=== Plant Performance ===")
        print(f"Production rate:    {self.production_rate:.2f} kmol/h")
        print(f"Overall yield:      {self.yield_overall:.2f} %")
        print(f"Energy consumption: {self.energy_consumption:.1f} kW")
        print(f"Raw material usage: {self.raw_material_usage:.2f} kmol/h")
        print(f"Profit:            ${self.profit_per_hour:.2f}/h")

class ChemicalPlant:
    """åŒ–å­¦ãƒ—ãƒ©ãƒ³ãƒˆå…¨ä½“ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼"""

    def __init__(self, config: Dict):
        self.config = config
        self.streams = {}
        self.unit_operations = {}

    def simulate_full_plant(self, feed_rate=100.0,
                           optimization_mode=False):
        """
        ãƒ—ãƒ©ãƒ³ãƒˆå…¨ä½“ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³

        Process Flow:
        Feed â†’ Preheater â†’ Reactor â†’ Flash â†’ Distillation â†’ Product
                  â†‘           â†“                    â†“
              Heat Recovery   â†â”€â”€â”€â”€ Recycle â”€â”€â”€â”€â”€â”€â”€â”˜
        """
        # 1. ãƒ•ã‚£ãƒ¼ãƒ‰äºˆç†±å™¨
        feed_temp_in = 300  # K
        feed_temp_out = 400  # K
        preheat_duty = feed_rate * 2.5 * (feed_temp_out - feed_temp_in)

        # 2. åå¿œå™¨
        conversion = self.config.get('conversion', 0.80)
        reaction_temp = 450  # K
        reaction_heat = feed_rate * conversion * 50  # kJ/kmol

        product_from_reactor = feed_rate * conversion
        unreacted = feed_rate * (1 - conversion)

        # 3. ãƒ•ãƒ©ãƒƒã‚·ãƒ¥åˆ†é›¢å™¨
        vapor_frac = 0.3
        flash_vapor = (product_from_reactor + unreacted) * vapor_frac
        flash_liquid = (product_from_reactor + unreacted) * (1 - vapor_frac)

        # 4. è’¸ç•™å¡”
        distillate_purity = 0.98
        distillate_recovery = 0.95

        distillate = flash_liquid * distillate_recovery * distillate_purity
        bottoms = flash_liquid - distillate

        # 5. ãƒªã‚µã‚¤ã‚¯ãƒ«
        recycle_ratio = self.config.get('recycle_ratio', 0.5)
        recycle_flow = distillate * recycle_ratio

        # 6. ã‚¨ãƒãƒ«ã‚®ãƒ¼çµ±åˆ
        heat_recovery = 0.7 * reaction_heat  # 70%å›å
        heating_utility = preheat_duty - heat_recovery
        cooling_utility = reaction_heat - heat_recovery

        total_energy = heating_utility + cooling_utility

        # æ€§èƒ½æŒ‡æ¨™è¨ˆç®—
        performance = PlantPerformance(
            production_rate=distillate * (1 - recycle_ratio),
            yield_overall=100 * distillate * (1 - recycle_ratio) / feed_rate,
            energy_consumption=total_energy,
            raw_material_usage=feed_rate,
            profit_per_hour=self._calculate_profit(
                distillate * (1 - recycle_ratio),
                feed_rate,
                total_energy
            )
        )

        return performance

    def _calculate_profit(self, product, feed, energy):
        """åˆ©ç›Šè¨ˆç®—"""
        revenue = product * 1000  # $/kmol
        feed_cost = feed * 500
        energy_cost = energy * 0.1  # $/kW
        return revenue - feed_cost - energy_cost

    def optimize_operation(self):
        """é‹è»¢æœ€é©åŒ–"""
        from scipy.optimize import minimize

        def objective(x):
            conversion, recycle_ratio = x
            self.config['conversion'] = conversion
            self.config['recycle_ratio'] = recycle_ratio

            perf = self.simulate_full_plant()
            return -perf.profit_per_hour  # æœ€å¤§åŒ–â†’æœ€å°åŒ–

        result = minimize(
            objective,
            x0=[0.75, 0.4],
            bounds=[(0.6, 0.95), (0.2, 0.7)],
            method='SLSQP'
        )

        return result

# ä½¿ç”¨ä¾‹
config = {
    'conversion': 0.80,
    'recycle_ratio': 0.5,
    'min_approach_temp': 10
}

plant = ChemicalPlant(config)

# é€šå¸¸é‹è»¢
print("=== Normal Operation ===")
perf_normal = plant.simulate_full_plant(feed_rate=100.0)
perf_normal.display()

# æœ€é©åŒ–é‹è»¢
print("\n=== Optimized Operation ===")
result = plant.optimize_operation()
print(f"Optimal conversion: {result.x[0]:.4f}")
print(f"Optimal recycle ratio: {result.x[1]:.4f}")

perf_optimized = plant.simulate_full_plant(feed_rate=100.0)
perf_optimized.display()

# æ”¹å–„ç‡
improvement = (perf_optimized.profit_per_hour - perf_normal.profit_per_hour) / perf_normal.profit_per_hour * 100
print(f"\nProfit improvement: {improvement:.2f}%")
</code></pre>

<hr />

<h2>4.8 å‹•çš„ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å…¥é–€</h2>

<h3>æ™‚é–“å¤‰åŒ–ã‚’è€ƒæ…®ã—ãŸã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³</h3>

<p>èµ·å‹•ãƒ»åœæ­¢ã€å¤–ä¹±å¿œç­”ãªã©ã®å‹•çš„æŒ™å‹•ã‚’è§£æã—ã¾ã™ã€‚</p>

<pre><code class="language-python">"""
Example 8: Dynamic Simulation Introduction
å‹•çš„ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å…¥é–€ï¼ˆæ™‚é–“å¤‰åŒ–ã®è€ƒæ…®ï¼‰
"""
import numpy as np
from scipy.integrate import odeint
import matplotlib.pyplot as plt

class DynamicCSTR:
    """å‹•çš„é€£ç¶šæ§½å‹åå¿œå™¨ï¼ˆCSTRï¼‰"""

    def __init__(self, volume=10.0, k=0.5, rho=1000, Cp=4.18):
        """
        Args:
            volume: åå¿œå™¨å®¹ç© [mÂ³]
            k: åå¿œé€Ÿåº¦å®šæ•° [1/min]
            rho: å¯†åº¦ [kg/mÂ³]
            Cp: æ¯”ç†± [kJ/kg/K]
        """
        self.V = volume
        self.k = k
        self.rho = rho
        self.Cp = Cp

    def model(self, y, t, F_in, C_in, T_in, Q_heat):
        """
        å‹•çš„ãƒ¢ãƒ‡ãƒ«ï¼ˆå¾®åˆ†æ–¹ç¨‹å¼ï¼‰

        çŠ¶æ…‹å¤‰æ•°: y = [C, T]
        C: æ¿ƒåº¦ [kmol/mÂ³]
        T: æ¸©åº¦ [K]
        """
        C, T = y

        # ç‰©è³ªåæ”¯
        r = self.k * C  # åå¿œé€Ÿåº¦ [kmol/mÂ³/min]
        dC_dt = (F_in / self.V) * (C_in - C) - r

        # ã‚¨ãƒãƒ«ã‚®ãƒ¼åæ”¯
        dH_r = -50  # åå¿œç†± [kJ/kmol]
        Q_reaction = r * dH_r * self.V

        dT_dt = (F_in / self.V) * (T_in - T) + \
                (Q_heat + Q_reaction) / (self.rho * self.V * self.Cp)

        return [dC_dt, dT_dt]

    def simulate(self, t_span, y0, F_in, C_in, T_in, Q_heat):
        """
        å‹•çš„ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³

        Args:
            t_span: æ™‚é–“ç¯„å›² [min]
            y0: åˆæœŸçŠ¶æ…‹ [C0, T0]
            F_in: å…¥å£æµé‡ [mÂ³/min]ï¼ˆæ™‚é–“ã®é–¢æ•°ã‚‚å¯ï¼‰
            C_in: å…¥å£æ¿ƒåº¦ [kmol/mÂ³]
            T_in: å…¥å£æ¸©åº¦ [K]
            Q_heat: åŠ ç†±é‡ [kW]
        """
        solution = odeint(self.model, y0, t_span,
                         args=(F_in, C_in, T_in, Q_heat))

        return solution

# ä½¿ç”¨ä¾‹ï¼šèµ·å‹•ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
reactor = DynamicCSTR(volume=10.0, k=0.5)

# æ™‚é–“ç¯„å›²
t = np.linspace(0, 60, 300)  # 0-60åˆ†

# åˆæœŸæ¡ä»¶ï¼ˆç©ºã®åå¿œå™¨ï¼‰
y0 = [0.0, 300.0]  # [C0=0, T0=300K]

# é‹è»¢æ¡ä»¶
F_in = 1.0  # mÂ³/min
C_in = 2.0  # kmol/mÂ³
T_in = 320.0  # K
Q_heat = 50.0  # kW

# ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å®Ÿè¡Œ
solution = reactor.simulate(t, y0, F_in, C_in, T_in, Q_heat)

# çµæœãƒ—ãƒ­ãƒƒãƒˆ
fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(10, 8))

# æ¿ƒåº¦ã®æ™‚é–“å¤‰åŒ–
ax1.plot(t, solution[:, 0], 'b-', linewidth=2)
ax1.set_xlabel('Time [min]')
ax1.set_ylabel('Concentration [kmol/mÂ³]')
ax1.set_title('CSTR Startup: Concentration Profile')
ax1.grid(True, alpha=0.3)

# æ¸©åº¦ã®æ™‚é–“å¤‰åŒ–
ax2.plot(t, solution[:, 1], 'r-', linewidth=2)
ax2.set_xlabel('Time [min]')
ax2.set_ylabel('Temperature [K]')
ax2.set_title('CSTR Startup: Temperature Profile')
ax2.grid(True, alpha=0.3)

plt.tight_layout()
plt.show()

# å®šå¸¸çŠ¶æ…‹åˆ°é”æ™‚é–“
C_steady = solution[-1, 0]
idx_90 = np.where(solution[:, 0] >= 0.9 * C_steady)[0][0]
print(f"Time to reach 90% of steady state: {t[idx_90]:.2f} min")
</code></pre>

<hr />

<h2>å­¦ç¿’ç›®æ¨™ã®ç¢ºèª</h2>

<p>ã“ã®ç« ã‚’å®Œäº†ã™ã‚‹ã¨ã€ä»¥ä¸‹ãŒã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ï¼š</p>

<h3>åŸºæœ¬ç†è§£</h3>
<ul>
<li>âœ… ãƒ•ãƒ­ãƒ¼ã‚·ãƒ¼ãƒˆã‚’ã‚°ãƒ©ãƒ•ç†è«–ã§è¡¨ç¾ã—ã€è¨ˆç®—é †åºã‚’æ±ºå®šã§ãã‚‹</li>
<li>âœ… ãƒªã‚µã‚¤ã‚¯ãƒ«ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®åæŸè¨ˆç®—ã®åŸç†ã‚’ç†è§£ã™ã‚‹</li>
<li>âœ… ãƒ’ãƒ¼ãƒˆã‚¤ãƒ³ãƒ†ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã®åŸºç¤ï¼ˆPinchè§£æï¼‰ã‚’èª¬æ˜ã§ãã‚‹</li>
</ul>

<h3>å®Ÿè·µã‚¹ã‚­ãƒ«</h3>
<ul>
<li>âœ… NetworkXã‚’ä½¿ã£ã¦ãƒ•ãƒ­ãƒ¼ã‚·ãƒ¼ãƒˆãƒˆãƒãƒ­ã‚¸ãƒ¼ã‚’æ§‹ç¯‰ã§ãã‚‹</li>
<li>âœ… é€æ¬¡ä»£å…¥æ³•ã¨Wegsteinæ³•ã§ãƒªã‚µã‚¤ã‚¯ãƒ«è¨ˆç®—ã‚’å®Ÿè£…ã§ãã‚‹</li>
<li>âœ… è¤‡æ•°ãƒ¦ãƒ‹ãƒƒãƒˆã‚’çµ±åˆã—ãŸå®Œå…¨ãƒ•ãƒ­ãƒ¼ã‚·ãƒ¼ãƒˆã‚’æ§‹ç¯‰ã§ãã‚‹</li>
<li>âœ… æ„Ÿåº¦åˆ†æã¨ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿æœ€é©åŒ–ã‚’å®Ÿè¡Œã§ãã‚‹</li>
</ul>

<h3>å¿œç”¨åŠ›</h3>
<ul>
<li>âœ… å®Ÿãƒ—ãƒ©ãƒ³ãƒˆã®çµŒæ¸ˆæ€§ã‚’è©•ä¾¡ã—ã€æœ€é©é‹è»¢æ¡ä»¶ã‚’æ±ºå®šã§ãã‚‹</li>
<li>âœ… ã‚¨ãƒãƒ«ã‚®ãƒ¼çµ±åˆã§ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ã‚³ã‚¹ãƒˆã‚’å‰Šæ¸›ã§ãã‚‹</li>
<li>âœ… å‹•çš„ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã§èµ·å‹•ãƒ»å¤–ä¹±å¿œç­”ã‚’è§£æã§ãã‚‹</li>
</ul>

<hr />

<h2>ã¾ã¨ã‚</h2>

<p>ã“ã®ç« ã§ã¯ã€ãƒ—ãƒ­ã‚»ã‚¹ãƒ•ãƒ­ãƒ¼ã‚·ãƒ¼ãƒˆã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã®å®Ÿè·µçš„æ‰‹æ³•ã‚’ç¿’å¾—ã—ã¾ã—ãŸï¼š</p>

<ul>
<li><strong>ãƒˆãƒãƒ­ã‚¸ãƒ¼è¡¨ç¾</strong>ï¼šã‚°ãƒ©ãƒ•ç†è«–ã§è¨ˆç®—é †åºã‚’è‡ªå‹•æ±ºå®š</li>
<li><strong>ãƒªã‚µã‚¤ã‚¯ãƒ«åæŸ</strong>ï¼šé€æ¬¡ä»£å…¥æ³•ã¨WegsteinåŠ é€Ÿæ³•</li>
<li><strong>çµ±åˆã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³</strong>ï¼šåå¿œãƒ»åˆ†é›¢ãƒ»ç†±äº¤æ›ã®å…¨ä½“æœ€é©åŒ–</li>
<li><strong>æ„Ÿåº¦åˆ†æ</strong>ï¼šãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å¤‰åŒ–ã®å½±éŸ¿ã‚’å®šé‡è©•ä¾¡</li>
<li><strong>çµŒæ¸ˆæ€§æœ€é©åŒ–</strong>ï¼šåˆ©ç›Šæœ€å¤§åŒ–ã®é‹è»¢æ¡ä»¶æ±ºå®š</li>
<li><strong>ãƒ’ãƒ¼ãƒˆã‚¤ãƒ³ãƒ†ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³</strong>ï¼šPinchè§£æã§ã‚¨ãƒãƒ«ã‚®ãƒ¼å‰Šæ¸›</li>
<li><strong>å‹•çš„æŒ™å‹•</strong>ï¼šæ™‚é–“å¤‰åŒ–ã‚’è€ƒæ…®ã—ãŸèµ·å‹•ãƒ»å¤–ä¹±ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³</li>
</ul>

<p><strong>æ¬¡ç« ã®äºˆå‘Š</strong>ï¼šç¬¬5ç« ã§ã¯ã€Pythonã¨DWSIMç­‰ã®å•†ç”¨ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼ã‚’é€£æºã•ã›ã€ã‚ˆã‚Šé«˜åº¦ãªãƒ—ãƒ­ã‚»ã‚¹è¨­è¨ˆã‚’å®Ÿç¾ã—ã¾ã™ã€‚</p>

<hr />

<div class="navigation">
    <a href="chapter-3.html" class="nav-button">â† ç¬¬3ç« ï¼šå˜ä½æ“ä½œãƒ¢ãƒ‡ãƒªãƒ³ã‚°</a>
    <a href="chapter-5.html" class="nav-button">ç¬¬5ç« ï¼šPythonã¨ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼ã®é€£æº â†’</a>
</div>

<div class="disclaimer">
    <h3>å…è²¬äº‹é …</h3>
    <ul>
        <li>æœ¬ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã¯æ•™è‚²ç›®çš„ã§ä½œæˆã•ã‚Œã¦ãŠã‚Šã€å®Ÿãƒ—ãƒ©ãƒ³ãƒˆè¨­è¨ˆã«ã¯å°‚é–€å®¶ã®ç›£ä¿®ãŒå¿…è¦ã§ã™</li>
        <li>ã‚³ãƒ¼ãƒ‰ä¾‹ã¯æ¦‚å¿µç†è§£ã®ãŸã‚ã®ç°¡ç•¥åŒ–ãƒ¢ãƒ‡ãƒ«ã§ã‚ã‚Šã€å®Ÿã‚·ã‚¹ãƒ†ãƒ ã«ã¯è¿½åŠ æ¤œè¨¼ãŒå¿…è¦ã§ã™</li>
        <li>æ•°å€¤ä¾‹ã¯èª¬æ˜ç”¨ã§ã‚ã‚Šã€å®Ÿéš›ã®ãƒ—ãƒ­ã‚»ã‚¹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¨ã¯ç•°ãªã‚‹å ´åˆãŒã‚ã‚Šã¾ã™</li>
        <li>å®‰å…¨æ€§ãƒ»ç’°å¢ƒè¦åˆ¶ã¯å®Ÿéš›ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã§å¿…ãšå°‚é–€å®¶ã«ç¢ºèªã—ã¦ãã ã•ã„</li>
    </ul>
</div>

    </main>

    <footer>
        <p>&copy; 2025 PI Terakoya - Process Intelligence Education Platform</p>
        <p><a href="../index.html">ã‚·ãƒªãƒ¼ã‚ºç›®æ¬¡ã«æˆ»ã‚‹</a></p>
    </footer>

</body>
</html>
