<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="ç¬¬4ç« ï¼šãƒ—ãƒ­ã‚»ã‚¹ãƒ‡ãƒ¼ã‚¿ã®ç‰¹å¾´é‡ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ãƒªãƒ³ã‚° - ãƒ—ãƒ­ã‚»ã‚¹ãƒ‡ãƒ¼ã‚¿è§£æå®Ÿè·µã‚·ãƒªãƒ¼ã‚º">
    <title>ç¬¬4ç« ï¼šãƒ—ãƒ­ã‚»ã‚¹ãƒ‡ãƒ¼ã‚¿ã®ç‰¹å¾´é‡ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ãƒªãƒ³ã‚° - ãƒ—ãƒ­ã‚»ã‚¹ãƒ‡ãƒ¼ã‚¿è§£æå®Ÿè·µ | PI Terakoya</title>

        <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            line-height: 1.8; color: #333; background: #f5f5f5;
        }
        header {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
            color: white; padding: 2rem 1rem; text-align: center;
        }
        h1 { font-size: 2rem; margin-bottom: 0.5rem; }
        .subtitle { opacity: 0.9; font-size: 1.1rem; }
        .container { max-width: 1200px; margin: 2rem auto; padding: 0 1rem; }
        .back-link {
            display: inline-block; margin-bottom: 2rem; padding: 0.5rem 1rem;
            background: white; color: #11998e; text-decoration: none;
            border-radius: 6px; font-weight: 600;
        }
        .content-box {
            background: white; padding: 2rem; border-radius: 12px;
            margin-bottom: 2rem; box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        h2 {
            color: #11998e; margin: 2rem 0 1rem 0;
            padding-bottom: 0.5rem; border-bottom: 3px solid #11998e;
        }
        h3 { color: #2c3e50; margin: 1.5rem 0 1rem 0; }
        h4 { color: #2c3e50; margin: 1rem 0 0.5rem 0; }
        p { margin-bottom: 1rem; }
        ul, ol { margin-left: 2rem; margin-bottom: 1rem; }
        li { margin-bottom: 0.5rem; }
        pre {
            background: #1e1e1e; color: #d4d4d4; padding: 1.5rem;
            border-radius: 8px; overflow-x: auto; margin: 1rem 0;
            border-left: 4px solid #11998e;
        }
        code {
            font-family: 'Courier New', monospace; font-size: 0.9rem;
        }
        .key-point {
            background: #e8f5e9; padding: 1rem; border-radius: 6px;
            border-left: 4px solid #4caf50; margin: 1rem 0;
        }
        .tech-note {
            background: #e3f2fd; padding: 1rem; border-radius: 6px;
            border-left: 4px solid #2196f3; margin: 1rem 0;
        }
        .formula {
            background: #f0f7ff; padding: 1rem; border-radius: 6px;
            margin: 1rem 0; overflow-x: auto;
        }
        table {
            width: 100%; border-collapse: collapse; margin: 1rem 0;
        }
        th, td {
            border: 1px solid #ddd; padding: 0.75rem; text-align: left;
        }
        th {
            background: #11998e; color: white; font-weight: 600;
        }
        tr:nth-child(even) { background: #f9f9f9; }
        .nav-buttons {
            display: flex; justify-content: space-between; margin-top: 3rem;
        }
        .nav-buttons a {
            padding: 0.75rem 1.5rem;
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
            color: white; text-decoration: none; border-radius: 6px;
            font-weight: 600;
        }
        footer {
            background: #2c3e50; color: white; text-align: center;
            padding: 2rem 1rem; margin-top: 4rem;
        }
        @media (max-width: 768px) {
            h1 { font-size: 1.6rem; }
            .container { padding: 0 0.5rem; }
            pre { padding: 1rem; }
        }
    
        /* Breadcrumb styles */
        .breadcrumb {
            background: #f7fafc;
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #e2e8f0;
            font-size: 0.9rem;
        }

        .breadcrumb-content {
            max-width: 900px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .breadcrumb a {
            color: #667eea;
            text-decoration: none;
            transition: color 0.2s;
        }

        .breadcrumb a:hover {
            color: #764ba2;
            text-decoration: underline;
        }

        .breadcrumb-separator {
            color: #a0aec0;
            margin: 0 0.25rem;
        }

        .breadcrumb-current {
            color: #4a5568;
            font-weight: 500;
        }
    </style>
</head>
<body>
        <nav class="breadcrumb">
        <div class="breadcrumb-content">
            <a href="/wp/knowledge/jp/index.html">AIå¯ºå­å±‹ãƒˆãƒƒãƒ—</a><span class="breadcrumb-separator">â€º</span><a href="/wp/knowledge/jp/PI/index.html">ãƒ—ãƒ­ã‚»ã‚¹ãƒ»ã‚¤ãƒ³ãƒ•ã‚©ãƒãƒ†ã‚£ã‚¯ã‚¹</a><span class="breadcrumb-separator">â€º</span><a href="/wp/knowledge/jp/PI/process-data-analysis/index.html">Process Data Analysis</a><span class="breadcrumb-separator">â€º</span><span class="breadcrumb-current">Chapter 4</span>
        </div>
    </nav>

    <header>
        <div class="container">
            <h1>ç¬¬4ç« ï¼šãƒ—ãƒ­ã‚»ã‚¹ãƒ‡ãƒ¼ã‚¿ã®ç‰¹å¾´é‡ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ãƒªãƒ³ã‚°</h1>
            <p class="subtitle">æ™‚ç³»åˆ—ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰ä¾¡å€¤ã‚ã‚‹ç‰¹å¾´ã‚’æŠ½å‡ºã™ã‚‹æŠ€è¡“</p>
            <div class="meta">
                <span class="meta">ğŸ“– èª­äº†æ™‚é–“: 35-40åˆ†</span>
                <span class="meta">ğŸ“Š é›£æ˜“åº¦: ä¸­ç´š</span>
                <span class="meta">ğŸ’» ã‚³ãƒ¼ãƒ‰ä¾‹: 10å€‹</span>
            </div>
        </div>
    </header>

    <main class="container">

<div class="learning-objectives">
<h2>å­¦ç¿’ç›®æ¨™</h2>
<p>ã“ã®ç« ã‚’èª­ã‚€ã“ã¨ã§ã€ä»¥ä¸‹ã‚’ç¿’å¾—ã§ãã¾ã™ï¼š</p>
<ul>
<li>âœ… æ™‚é–“é ˜åŸŸç‰¹å¾´é‡ï¼ˆçµ±è¨ˆé‡ã€ãƒ¢ãƒ¼ãƒ¡ãƒ³ãƒˆï¼‰ã®è¨ˆç®—ã¨è§£é‡ˆãŒã§ãã‚‹</li>
<li>âœ… å‘¨æ³¢æ•°é ˜åŸŸç‰¹å¾´é‡ï¼ˆFFTã€ã‚¹ãƒšã‚¯ãƒˆãƒ«ã‚¨ãƒ³ãƒˆãƒ­ãƒ”ãƒ¼ï¼‰ã‚’æŠ½å‡ºã§ãã‚‹</li>
<li>âœ… ã‚¦ã‚§ãƒ¼ãƒ–ãƒ¬ãƒƒãƒˆå¤‰æ›ã«ã‚ˆã‚‹å¤šè§£åƒåº¦ç‰¹å¾´é‡ã‚’ç†è§£ã™ã‚‹</li>
<li>âœ… ãƒ‰ãƒ¡ã‚¤ãƒ³çŸ¥è­˜ã‚’æ´»ç”¨ã—ãŸç‰¹å¾´é‡è¨­è¨ˆãŒã§ãã‚‹</li>
<li>âœ… ç‰¹å¾´é‡é¸æŠæ‰‹æ³•ï¼ˆRFEã€LASSOã€ç›¸äº’æƒ…å ±é‡ï¼‰ã‚’å®Ÿè£…ã§ãã‚‹</li>
<li>âœ… tsfreshã«ã‚ˆã‚‹è‡ªå‹•ç‰¹å¾´é‡æŠ½å‡ºã‚’æ´»ç”¨ã§ãã‚‹</li>
</ul>
</div>

<hr />

<h2>4.1 ç‰¹å¾´é‡ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ãƒªãƒ³ã‚°ã®é‡è¦æ€§</h2>

<h3>ãªãœç‰¹å¾´é‡ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ãƒªãƒ³ã‚°ãŒé‡è¦ã‹</h3>

<p>ãƒ—ãƒ­ã‚»ã‚¹ãƒ‡ãƒ¼ã‚¿è§£æã«ãŠã„ã¦ã€<strong>ç‰¹å¾´é‡ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ãƒªãƒ³ã‚°</strong>ã¯æ©Ÿæ¢°å­¦ç¿’ãƒ¢ãƒ‡ãƒ«ã®æ€§èƒ½ã‚’æ±ºå®šã™ã‚‹æœ€ã‚‚é‡è¦ãªè¦ç´ ã§ã™ã€‚ç”Ÿã®æ™‚ç³»åˆ—ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰ã€ãƒ—ãƒ­ã‚»ã‚¹ã®çŠ¶æ…‹ã‚’é©åˆ‡ã«è¡¨ç¾ã™ã‚‹ç‰¹å¾´é‡ã‚’æŠ½å‡ºã™ã‚‹ã“ã¨ã§ã€äºˆæ¸¬ç²¾åº¦ãŒå¤§å¹…ã«å‘ä¸Šã—ã¾ã™ã€‚</p>

<table>
<thead>
<tr>
<th>ç‰¹å¾´é‡ã‚¿ã‚¤ãƒ—</th>
<th>æƒ…å ±å†…å®¹</th>
<th>é©ç”¨ä¾‹</th>
</tr>
</thead>
<tbody>
<tr>
<td>æ™‚é–“é ˜åŸŸç‰¹å¾´</td>
<td>çµ±è¨ˆçš„æ€§è³ªã€ãƒˆãƒ¬ãƒ³ãƒ‰</td>
<td>å¹³å‡æ¸©åº¦ã€æ¨™æº–åå·®ã€å‚¾ã</td>
</tr>
<tr>
<td>å‘¨æ³¢æ•°é ˜åŸŸç‰¹å¾´</td>
<td>å‘¨æœŸæ€§ã€æŒ¯å‹•æˆåˆ†</td>
<td>FFTä¿‚æ•°ã€ã‚¹ãƒšã‚¯ãƒˆãƒ«å¯†åº¦</td>
</tr>
<tr>
<td>ã‚¦ã‚§ãƒ¼ãƒ–ãƒ¬ãƒƒãƒˆç‰¹å¾´</td>
<td>æ™‚é–“-å‘¨æ³¢æ•°å±€åœ¨</td>
<td>éæ¸¡ç¾è±¡ã€çªç™ºã‚¤ãƒ™ãƒ³ãƒˆ</td>
</tr>
<tr>
<td>ãƒ‰ãƒ¡ã‚¤ãƒ³ç‰¹å¾´</td>
<td>ãƒ—ãƒ­ã‚»ã‚¹å›ºæœ‰ã®çŸ¥è­˜</td>
<td>æ»ç•™æ™‚é–“ã€è»¢åŒ–ç‡ã€åç‡</td>
</tr>
<tr>
<td>ç›¸äº’ä½œç”¨ç‰¹å¾´</td>
<td>å¤‰æ•°é–“ã®é–¢ä¿‚</td>
<td>æ¸©åº¦Ã—åœ§åŠ›ã€æ¯”ç‡ç‰¹å¾´</td>
</tr>
</tbody>
</table>

<hr />

<h2>4.2 æ™‚é–“é ˜åŸŸç‰¹å¾´é‡</h2>

<h3>ã‚³ãƒ¼ãƒ‰ä¾‹1: åŸºæœ¬çµ±è¨ˆé‡ç‰¹å¾´ã®æŠ½å‡º</h3>

<pre><code class="language-python">import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy import stats

def extract_time_domain_features(data, window_size=100):
    """
    æ™‚é–“é ˜åŸŸã®åŸºæœ¬çµ±è¨ˆç‰¹å¾´ã‚’æŠ½å‡º

    Parameters:
    -----------
    data : array-like
        æ™‚ç³»åˆ—ãƒ‡ãƒ¼ã‚¿
    window_size : int
        ç‰¹å¾´æŠ½å‡ºç”¨ã®ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚µã‚¤ã‚º

    Returns:
    --------
    features : dict
        æŠ½å‡ºã•ã‚ŒãŸç‰¹å¾´é‡ã®è¾æ›¸
    """
    features = {}

    # åŸºæœ¬çµ±è¨ˆé‡
    features['mean'] = np.mean(data)
    features['std'] = np.std(data)
    features['variance'] = np.var(data)
    features['min'] = np.min(data)
    features['max'] = np.max(data)
    features['range'] = features['max'] - features['min']
    features['median'] = np.median(data)

    # ãƒ‘ãƒ¼ã‚»ãƒ³ã‚¿ã‚¤ãƒ«
    features['q25'] = np.percentile(data, 25)
    features['q75'] = np.percentile(data, 75)
    features['iqr'] = features['q75'] - features['q25']

    # é«˜æ¬¡ãƒ¢ãƒ¼ãƒ¡ãƒ³ãƒˆ
    features['skewness'] = stats.skew(data)  # æ­ªåº¦
    features['kurtosis'] = stats.kurtosis(data)  # å°–åº¦

    # ã‚¨ãƒãƒ«ã‚®ãƒ¼ã¨ãƒ‘ãƒ¯ãƒ¼
    features['energy'] = np.sum(data ** 2)
    features['power'] = features['energy'] / len(data)
    features['rms'] = np.sqrt(features['power'])  # Root Mean Square

    # å¤‰å‹•ä¿‚æ•°
    features['cv'] = features['std'] / features['mean'] if features['mean'] != 0 else 0

    return features


# ã‚µãƒ³ãƒ—ãƒ«ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆï¼ˆåå¿œå™¨æ¸©åº¦ãƒ‡ãƒ¼ã‚¿ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰
np.random.seed(42)
time = np.linspace(0, 100, 1000)
temperature = 180 + 5 * np.sin(0.1 * time) + np.random.normal(0, 1, 1000)

# ç‰¹å¾´æŠ½å‡º
features = extract_time_domain_features(temperature)

# å¯è¦–åŒ–
fig, axes = plt.subplots(2, 2, figsize=(14, 10))

# æ™‚ç³»åˆ—ãƒ‡ãƒ¼ã‚¿
axes[0, 0].plot(time, temperature, color='#11998e', linewidth=1.5)
axes[0, 0].axhline(y=features['mean'], color='red', linestyle='--',
                    label=f"Mean: {features['mean']:.2f}")
axes[0, 0].axhline(y=features['mean'] + features['std'], color='orange',
                    linestyle='--', alpha=0.7, label=f"Â±1Ïƒ")
axes[0, 0].axhline(y=features['mean'] - features['std'], color='orange',
                    linestyle='--', alpha=0.7)
axes[0, 0].set_xlabel('Time [s]')
axes[0, 0].set_ylabel('Temperature [Â°C]')
axes[0, 0].set_title('Time Series with Statistical Features')
axes[0, 0].legend()
axes[0, 0].grid(alpha=0.3)

# ãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ 
axes[0, 1].hist(temperature, bins=50, color='#11998e', alpha=0.7, edgecolor='black')
axes[0, 1].axvline(x=features['mean'], color='red', linestyle='--',
                    linewidth=2, label=f"Mean: {features['mean']:.2f}")
axes[0, 1].axvline(x=features['median'], color='blue', linestyle='--',
                    linewidth=2, label=f"Median: {features['median']:.2f}")
axes[0, 1].set_xlabel('Temperature [Â°C]')
axes[0, 1].set_ylabel('Frequency')
axes[0, 1].set_title(f'Distribution (Skewness: {features["skewness"]:.2f})')
axes[0, 1].legend()
axes[0, 1].grid(alpha=0.3)

# ç‰¹å¾´é‡ã®å¯è¦–åŒ–
feature_names = ['mean', 'std', 'variance', 'range', 'iqr',
                 'skewness', 'kurtosis', 'rms']
feature_values = [features[name] for name in feature_names]

axes[1, 0].barh(feature_names, feature_values, color='#38ef7d', edgecolor='black')
axes[1, 0].set_xlabel('Feature Value')
axes[1, 0].set_title('Extracted Time-Domain Features')
axes[1, 0].grid(alpha=0.3, axis='x')

# ãƒœãƒƒã‚¯ã‚¹ãƒ—ãƒ­ãƒƒãƒˆ
axes[1, 1].boxplot(temperature, vert=True, patch_artist=True,
                   boxprops=dict(facecolor='#c8e6c9', color='black'),
                   medianprops=dict(color='red', linewidth=2),
                   whiskerprops=dict(color='black'),
                   capprops=dict(color='black'))
axes[1, 1].set_ylabel('Temperature [Â°C]')
axes[1, 1].set_title('Box Plot Summary')
axes[1, 1].grid(alpha=0.3, axis='y')

plt.tight_layout()
plt.show()

# ç‰¹å¾´é‡ã®å‡ºåŠ›
print("Extracted Time-Domain Features:")
print("=" * 50)
for key, value in features.items():
    print(f"{key:15s}: {value:10.4f}")
</code></pre>

<p><strong>å‡ºåŠ›ä¾‹:</strong></p>
<pre><code>Extracted Time-Domain Features:
==================================================
mean           :   179.9682
std            :     5.1558
variance       :    26.5824
min            :   164.9012
max            :   194.8533
range          :    29.9521
median         :   179.9449
q25            :   176.5168
q75            :   183.4302
iqr            :     6.9134
skewness       :     0.0187
kurtosis       :    -0.1023
energy         : 32405692.8145
power          : 32405.6928
rms            :   180.0158
cv             :     0.0286
</code></pre>

<p><strong>è§£èª¬:</strong> æ™‚é–“é ˜åŸŸç‰¹å¾´ã¯ã€ãƒ‡ãƒ¼ã‚¿ã®çµ±è¨ˆçš„æ€§è³ªã‚’æ‰ãˆã¾ã™ã€‚å¹³å‡ã¨æ¨™æº–åå·®ã¯ä¸­å¿ƒå‚¾å‘ã¨æ•£ã‚‰ã°ã‚Šã‚’ã€æ­ªåº¦ã¨å°–åº¦ã¯åˆ†å¸ƒã®å½¢çŠ¶ã‚’è¡¨ã—ã¾ã™ã€‚ã“ã‚Œã‚‰ã¯ç•°å¸¸æ¤œçŸ¥ã‚„çŠ¶æ…‹åˆ†é¡ã«æœ‰åŠ¹ã§ã™ã€‚</p>

<hr />

<h3>ã‚³ãƒ¼ãƒ‰ä¾‹2: ãƒ­ãƒ¼ãƒªãƒ³ã‚°çµ±è¨ˆç‰¹å¾´ã¨ãƒ©ã‚°ç‰¹å¾´</h3>

<pre><code class="language-python">import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

def create_rolling_features(data, windows=[10, 30, 60]):
    """
    ãƒ­ãƒ¼ãƒªãƒ³ã‚°çµ±è¨ˆç‰¹å¾´ã¨ãƒ©ã‚°ç‰¹å¾´ã‚’ç”Ÿæˆ

    Parameters:
    -----------
    data : pd.Series
        æ™‚ç³»åˆ—ãƒ‡ãƒ¼ã‚¿
    windows : list
        ãƒ­ãƒ¼ãƒªãƒ³ã‚°ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚µã‚¤ã‚ºã®ãƒªã‚¹ãƒˆ

    Returns:
    --------
    df : pd.DataFrame
        ç‰¹å¾´é‡ã‚’å«ã‚€DataFrame
    """
    df = pd.DataFrame({'original': data})

    for window in windows:
        # ãƒ­ãƒ¼ãƒªãƒ³ã‚°çµ±è¨ˆé‡
        df[f'rolling_mean_{window}'] = data.rolling(window=window).mean()
        df[f'rolling_std_{window}'] = data.rolling(window=window).std()
        df[f'rolling_min_{window}'] = data.rolling(window=window).min()
        df[f'rolling_max_{window}'] = data.rolling(window=window).max()
        df[f'rolling_median_{window}'] = data.rolling(window=window).median()

    # ãƒ©ã‚°ç‰¹å¾´ï¼ˆéå»ã®å€¤ï¼‰
    for lag in [1, 5, 10, 20]:
        df[f'lag_{lag}'] = data.shift(lag)

    # å·®åˆ†ç‰¹å¾´
    df['diff_1'] = data.diff(1)  # 1æ¬¡å·®åˆ†
    df['diff_2'] = data.diff(2)  # 2æ¬¡å·®åˆ†

    # å‹¾é…ï¼ˆå‚¾ãï¼‰
    df['gradient'] = np.gradient(data)

    return df


# ã‚µãƒ³ãƒ—ãƒ«ãƒ‡ãƒ¼ã‚¿ï¼ˆåå¿œå™¨åœ§åŠ›ã®ãƒˆãƒ¬ãƒ³ãƒ‰ä»˜ããƒ‡ãƒ¼ã‚¿ï¼‰
np.random.seed(42)
time = np.arange(500)
pressure = 2.5 + 0.001 * time + 0.1 * np.sin(0.05 * time) + np.random.normal(0, 0.05, 500)
pressure_series = pd.Series(pressure)

# ãƒ­ãƒ¼ãƒªãƒ³ã‚°ç‰¹å¾´ã®ç”Ÿæˆ
df_features = create_rolling_features(pressure_series)

# å¯è¦–åŒ–
fig, axes = plt.subplots(3, 1, figsize=(14, 10))

# ã‚ªãƒªã‚¸ãƒŠãƒ«ãƒ‡ãƒ¼ã‚¿ã¨ãƒ­ãƒ¼ãƒªãƒ³ã‚°å¹³å‡
axes[0].plot(time, df_features['original'], label='Original',
             color='gray', alpha=0.5, linewidth=1)
axes[0].plot(time, df_features['rolling_mean_10'], label='Rolling Mean (10)',
             color='#11998e', linewidth=2)
axes[0].plot(time, df_features['rolling_mean_30'], label='Rolling Mean (30)',
             color='#38ef7d', linewidth=2)
axes[0].plot(time, df_features['rolling_mean_60'], label='Rolling Mean (60)',
             color='orange', linewidth=2)
axes[0].set_xlabel('Time [s]')
axes[0].set_ylabel('Pressure [bar]')
axes[0].set_title('Rolling Mean Features')
axes[0].legend()
axes[0].grid(alpha=0.3)

# ãƒ­ãƒ¼ãƒªãƒ³ã‚°æ¨™æº–åå·®ï¼ˆå¤‰å‹•æ€§ã®æ¤œå‡ºï¼‰
axes[1].plot(time, df_features['rolling_std_10'], label='Rolling Std (10)',
             color='#11998e', linewidth=2)
axes[1].plot(time, df_features['rolling_std_30'], label='Rolling Std (30)',
             color='#38ef7d', linewidth=2)
axes[1].set_xlabel('Time [s]')
axes[1].set_ylabel('Std [bar]')
axes[1].set_title('Rolling Standard Deviation (Variability Detection)')
axes[1].legend()
axes[1].grid(alpha=0.3)

# å·®åˆ†ã¨ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆãƒˆãƒ¬ãƒ³ãƒ‰æ¤œå‡ºï¼‰
axes[2].plot(time, df_features['diff_1'], label='1st Difference',
             color='#11998e', alpha=0.7, linewidth=1)
axes[2].plot(time, df_features['gradient'], label='Gradient',
             color='orange', linewidth=2)
axes[2].axhline(y=0, color='red', linestyle='--', linewidth=1, alpha=0.5)
axes[2].set_xlabel('Time [s]')
axes[2].set_ylabel('Change Rate')
axes[2].set_title('Trend Detection Features')
axes[2].legend()
axes[2].grid(alpha=0.3)

plt.tight_layout()
plt.show()

# ç‰¹å¾´é‡ã®ä¸€éƒ¨ã‚’è¡¨ç¤º
print("\nSample of Rolling Features:")
print(df_features.iloc[60:70][['original', 'rolling_mean_30', 'rolling_std_30',
                                 'lag_10', 'diff_1', 'gradient']].to_string())
</code></pre>

<p><strong>è§£èª¬:</strong> ãƒ­ãƒ¼ãƒªãƒ³ã‚°çµ±è¨ˆã¯æ™‚é–“çš„ãªæ–‡è„ˆã‚’æ‰ãˆã€çŸ­æœŸçš„ãªå¤‰å‹•ã‚„é•·æœŸçš„ãªãƒˆãƒ¬ãƒ³ãƒ‰ã‚’æ¤œå‡ºã§ãã¾ã™ã€‚ãƒ©ã‚°ç‰¹å¾´ã¯æ™‚ç³»åˆ—ã®è‡ªå·±ç›¸é–¢ã‚’æ‰ãˆã€å·®åˆ†ç‰¹å¾´ã¯ãƒˆãƒ¬ãƒ³ãƒ‰ã‚„å¤‰åŒ–ç‚¹ã‚’å¼·èª¿ã—ã¾ã™ã€‚</p>

<hr />

<h2>4.3 å‘¨æ³¢æ•°é ˜åŸŸç‰¹å¾´é‡</h2>

<h3>ã‚³ãƒ¼ãƒ‰ä¾‹3: FFTï¼ˆé«˜é€Ÿãƒ•ãƒ¼ãƒªã‚¨å¤‰æ›ï¼‰ã«ã‚ˆã‚‹å‘¨æ³¢æ•°ç‰¹å¾´æŠ½å‡º</h3>

<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
from scipy.fft import fft, fftfreq
from scipy.signal import welch

def extract_frequency_features(signal, sampling_rate=1.0, n_coeffs=10):
    """
    FFTã«ã‚ˆã‚‹å‘¨æ³¢æ•°é ˜åŸŸç‰¹å¾´ã‚’æŠ½å‡º

    Parameters:
    -----------
    signal : array-like
        æ™‚ç³»åˆ—ä¿¡å·
    sampling_rate : float
        ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ãƒ¬ãƒ¼ãƒˆ [Hz]
    n_coeffs : int
        æŠ½å‡ºã™ã‚‹FFTä¿‚æ•°ã®æ•°

    Returns:
    --------
    features : dict
        å‘¨æ³¢æ•°é ˜åŸŸç‰¹å¾´
    """
    n = len(signal)

    # FFTè¨ˆç®—
    fft_vals = fft(signal)
    fft_magnitude = np.abs(fft_vals)[:n//2]  # æ­£ã®å‘¨æ³¢æ•°ã®ã¿
    fft_power = fft_magnitude ** 2
    frequencies = fftfreq(n, d=1/sampling_rate)[:n//2]

    features = {}

    # ä¸»è¦ãªFFTä¿‚æ•°ï¼ˆä½å‘¨æ³¢æˆåˆ†ï¼‰
    for i in range(n_coeffs):
        features[f'fft_coeff_{i}'] = fft_magnitude[i]

    # ã‚¹ãƒšã‚¯ãƒˆãƒ«ã‚¨ãƒãƒ«ã‚®ãƒ¼
    features['spectral_energy'] = np.sum(fft_power)

    # ã‚¹ãƒšã‚¯ãƒˆãƒ«é‡å¿ƒï¼ˆå‘¨æ³¢æ•°ã®é‡å¿ƒï¼‰
    features['spectral_centroid'] = np.sum(frequencies * fft_magnitude) / np.sum(fft_magnitude)

    # ã‚¹ãƒšã‚¯ãƒˆãƒ«åˆ†æ•£
    features['spectral_variance'] = np.sum(((frequencies - features['spectral_centroid']) ** 2) * fft_magnitude) / np.sum(fft_magnitude)

    # ã‚¹ãƒšã‚¯ãƒˆãƒ«ã‚¨ãƒ³ãƒˆãƒ­ãƒ”ãƒ¼
    psd_norm = fft_power / np.sum(fft_power)
    psd_norm = psd_norm[psd_norm > 0]  # ã‚¼ãƒ­ã‚’é™¤å»
    features['spectral_entropy'] = -np.sum(psd_norm * np.log2(psd_norm))

    # æ”¯é…çš„ãªå‘¨æ³¢æ•°ï¼ˆãƒ‘ãƒ¯ãƒ¼æœ€å¤§ã®ãƒ”ãƒ¼ã‚¯ï¼‰
    dominant_freq_idx = np.argmax(fft_magnitude[1:]) + 1  # DCæˆåˆ†ã‚’é™¤ã
    features['dominant_frequency'] = frequencies[dominant_freq_idx]
    features['dominant_power'] = fft_magnitude[dominant_freq_idx]

    return features, frequencies, fft_magnitude


# ã‚µãƒ³ãƒ—ãƒ«ãƒ‡ãƒ¼ã‚¿ï¼ˆå‘¨æœŸçš„ãªæŒ¯å‹•ã‚’å«ã‚€ä¿¡å·ï¼‰
np.random.seed(42)
sampling_rate = 100  # Hz
duration = 10  # ç§’
time = np.linspace(0, duration, sampling_rate * duration)

# è¤‡æ•°ã®å‘¨æ³¢æ•°æˆåˆ†ã‚’å«ã‚€ä¿¡å·
signal = (2.0 * np.sin(2 * np.pi * 5 * time) +    # 5 Hzæˆåˆ†
          1.0 * np.sin(2 * np.pi * 12 * time) +   # 12 Hzæˆåˆ†
          0.5 * np.sin(2 * np.pi * 25 * time) +   # 25 Hzæˆåˆ†
          0.3 * np.random.randn(len(time)))       # ãƒã‚¤ã‚º

# ç‰¹å¾´æŠ½å‡º
features, frequencies, fft_magnitude = extract_frequency_features(signal, sampling_rate)

# å¯è¦–åŒ–
fig, axes = plt.subplots(2, 1, figsize=(14, 10))

# æ™‚é–“é ˜åŸŸã®ä¿¡å·
axes[0].plot(time, signal, color='#11998e', linewidth=1.5)
axes[0].set_xlabel('Time [s]')
axes[0].set_ylabel('Amplitude')
axes[0].set_title('Time-Domain Signal (5Hz + 12Hz + 25Hz components)')
axes[0].grid(alpha=0.3)

# å‘¨æ³¢æ•°ã‚¹ãƒšã‚¯ãƒˆãƒ«
axes[1].plot(frequencies, fft_magnitude, color='#11998e', linewidth=2)
axes[1].axvline(x=features['dominant_frequency'], color='red', linestyle='--',
                linewidth=2, label=f"Dominant: {features['dominant_frequency']:.1f} Hz")
axes[1].axvline(x=features['spectral_centroid'], color='orange', linestyle='--',
                linewidth=2, label=f"Centroid: {features['spectral_centroid']:.1f} Hz")
axes[1].set_xlabel('Frequency [Hz]')
axes[1].set_ylabel('Magnitude')
axes[1].set_title('Frequency Spectrum (FFT)')
axes[1].set_xlim(0, 50)
axes[1].legend()
axes[1].grid(alpha=0.3)

plt.tight_layout()
plt.show()

# ç‰¹å¾´é‡ã®å‡ºåŠ›
print("\nExtracted Frequency-Domain Features:")
print("=" * 50)
for key in ['spectral_energy', 'spectral_centroid', 'spectral_variance',
            'spectral_entropy', 'dominant_frequency', 'dominant_power']:
    print(f"{key:25s}: {features[key]:12.4f}")

print("\nTop 5 FFT Coefficients:")
for i in range(5):
    print(f"fft_coeff_{i:2d}: {features[f'fft_coeff_{i}']:12.4f}")
</code></pre>

<p><strong>è§£èª¬:</strong> FFTã¯æ™‚ç³»åˆ—ãƒ‡ãƒ¼ã‚¿ã‚’å‘¨æ³¢æ•°æˆåˆ†ã«åˆ†è§£ã—ã€å‘¨æœŸçš„ãªãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æ¤œå‡ºã—ã¾ã™ã€‚ã‚¹ãƒšã‚¯ãƒˆãƒ«é‡å¿ƒã‚„ã‚¨ãƒ³ãƒˆãƒ­ãƒ”ãƒ¼ã¯ã€ä¿¡å·ã®å‘¨æ³¢æ•°ç‰¹æ€§ã‚’è¦ç´„ã™ã‚‹æœ‰ç”¨ãªç‰¹å¾´é‡ã§ã™ã€‚ãƒ—ãƒ­ã‚»ã‚¹ãƒ‡ãƒ¼ã‚¿ã§ã¯ã€ãƒãƒ³ãƒ—ã‚„ã‚³ãƒ³ãƒ—ãƒ¬ãƒƒã‚µãƒ¼ã®æŒ¯å‹•å‘¨æ³¢æ•°ã€åˆ¶å¾¡ãƒ«ãƒ¼ãƒ—ã®æŒ¯å‹•ãªã©ã‚’æ¤œå‡ºã§ãã¾ã™ã€‚</p>

<hr />

<h3>ã‚³ãƒ¼ãƒ‰ä¾‹4: ãƒ‘ãƒ¯ãƒ¼ã‚¹ãƒšã‚¯ãƒˆãƒ«å¯†åº¦ã¨ã‚¹ãƒšã‚¯ãƒˆãƒ­ã‚°ãƒ©ãƒ </h3>

<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import welch, spectrogram

def analyze_power_spectrum(signal, sampling_rate=1.0):
    """
    ãƒ‘ãƒ¯ãƒ¼ã‚¹ãƒšã‚¯ãƒˆãƒ«å¯†åº¦ã®è§£æ

    Parameters:
    -----------
    signal : array-like
        æ™‚ç³»åˆ—ä¿¡å·
    sampling_rate : float
        ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ãƒ¬ãƒ¼ãƒˆ [Hz]

    Returns:
    --------
    frequencies : array
        å‘¨æ³¢æ•°é…åˆ—
    psd : array
        ãƒ‘ãƒ¯ãƒ¼ã‚¹ãƒšã‚¯ãƒˆãƒ«å¯†åº¦
    """
    # Welchæ³•ã«ã‚ˆã‚‹ãƒ‘ãƒ¯ãƒ¼ã‚¹ãƒšã‚¯ãƒˆãƒ«å¯†åº¦æ¨å®š
    frequencies, psd = welch(signal, fs=sampling_rate, nperseg=256)

    # ãƒ‘ãƒ¯ãƒ¼ã®ç´¯ç©åˆ†å¸ƒ
    cumulative_power = np.cumsum(psd)
    total_power = cumulative_power[-1]

    # 90%ãƒ‘ãƒ¯ãƒ¼ã‚’å«ã‚€å‘¨æ³¢æ•°å¸¯åŸŸ
    freq_90 = frequencies[np.where(cumulative_power >= 0.9 * total_power)[0][0]]

    features = {
        'total_power': total_power,
        'freq_90_power': freq_90,
        'peak_frequency': frequencies[np.argmax(psd)]
    }

    return frequencies, psd, features


# éå®šå¸¸ä¿¡å·ã®ã‚µãƒ³ãƒ—ãƒ«ï¼ˆå‘¨æ³¢æ•°ãŒæ™‚é–“å¤‰åŒ–ï¼‰
sampling_rate = 200
duration = 5
time = np.linspace(0, duration, sampling_rate * duration)

# ãƒãƒ£ãƒ¼ãƒ—ä¿¡å·ï¼ˆå‘¨æ³¢æ•°ãŒæ™‚é–“ã¨ã¨ã‚‚ã«å¢—åŠ ï¼‰
frequency_sweep = np.linspace(5, 50, len(time))
signal_nonstationary = np.sin(2 * np.pi * frequency_sweep * time)

# ãƒ‘ãƒ¯ãƒ¼ã‚¹ãƒšã‚¯ãƒˆãƒ«è§£æ
frequencies, psd, psd_features = analyze_power_spectrum(signal_nonstationary, sampling_rate)

# ã‚¹ãƒšã‚¯ãƒˆãƒ­ã‚°ãƒ©ãƒ ï¼ˆæ™‚é–“-å‘¨æ³¢æ•°è§£æï¼‰
f_spec, t_spec, Sxx = spectrogram(signal_nonstationary, fs=sampling_rate,
                                   nperseg=128, noverlap=64)

# å¯è¦–åŒ–
fig, axes = plt.subplots(3, 1, figsize=(14, 12))

# æ™‚é–“é ˜åŸŸä¿¡å·
axes[0].plot(time, signal_nonstationary, color='#11998e', linewidth=1.5)
axes[0].set_xlabel('Time [s]')
axes[0].set_ylabel('Amplitude')
axes[0].set_title('Non-Stationary Signal (Frequency Sweep: 5-50 Hz)')
axes[0].grid(alpha=0.3)

# ãƒ‘ãƒ¯ãƒ¼ã‚¹ãƒšã‚¯ãƒˆãƒ«å¯†åº¦
axes[1].semilogy(frequencies, psd, color='#11998e', linewidth=2)
axes[1].axvline(x=psd_features['peak_frequency'], color='red', linestyle='--',
                linewidth=2, label=f"Peak: {psd_features['peak_frequency']:.1f} Hz")
axes[1].set_xlabel('Frequency [Hz]')
axes[1].set_ylabel('Power Spectral Density [VÂ²/Hz]')
axes[1].set_title('Power Spectral Density (Welch Method)')
axes[1].legend()
axes[1].grid(alpha=0.3)

# ã‚¹ãƒšã‚¯ãƒˆãƒ­ã‚°ãƒ©ãƒ 
im = axes[2].pcolormesh(t_spec, f_spec, 10 * np.log10(Sxx),
                         shading='gouraud', cmap='viridis')
axes[2].set_xlabel('Time [s]')
axes[2].set_ylabel('Frequency [Hz]')
axes[2].set_title('Spectrogram (Time-Frequency Analysis)')
axes[2].set_ylim(0, 60)
cbar = plt.colorbar(im, ax=axes[2])
cbar.set_label('Power [dB]')

plt.tight_layout()
plt.show()

print("\nPower Spectrum Features:")
print("=" * 50)
for key, value in psd_features.items():
    print(f"{key:20s}: {value:12.4f}")
</code></pre>

<p><strong>è§£èª¬:</strong> ãƒ‘ãƒ¯ãƒ¼ã‚¹ãƒšã‚¯ãƒˆãƒ«å¯†åº¦ï¼ˆPSDï¼‰ã¯å‘¨æ³¢æ•°ã”ã¨ã®ãƒ‘ãƒ¯ãƒ¼åˆ†å¸ƒã‚’ç¤ºã—ã€ã‚¹ãƒšã‚¯ãƒˆãƒ­ã‚°ãƒ©ãƒ ã¯æ™‚é–“å¤‰åŒ–ã™ã‚‹å‘¨æ³¢æ•°æˆåˆ†ã‚’å¯è¦–åŒ–ã—ã¾ã™ã€‚éå®šå¸¸ä¿¡å·ã®è§£æã«æœ‰åŠ¹ã§ã€ãƒ—ãƒ­ã‚»ã‚¹ã®å‹•çš„ãªæŒ™å‹•ã‚’æŠŠæ¡ã§ãã¾ã™ã€‚</p>

<hr />

<h2>4.4 ã‚¦ã‚§ãƒ¼ãƒ–ãƒ¬ãƒƒãƒˆå¤‰æ›ç‰¹å¾´</h2>

<h3>ã‚³ãƒ¼ãƒ‰ä¾‹5: ã‚¦ã‚§ãƒ¼ãƒ–ãƒ¬ãƒƒãƒˆå¤‰æ›ã«ã‚ˆã‚‹å¤šè§£åƒåº¦ç‰¹å¾´æŠ½å‡º</h3>

<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
import pywt

def extract_wavelet_features(signal, wavelet='db4', level=4):
    """
    ã‚¦ã‚§ãƒ¼ãƒ–ãƒ¬ãƒƒãƒˆå¤‰æ›ã«ã‚ˆã‚‹ç‰¹å¾´æŠ½å‡º

    Parameters:
    -----------
    signal : array-like
        æ™‚ç³»åˆ—ä¿¡å·
    wavelet : str
        ã‚¦ã‚§ãƒ¼ãƒ–ãƒ¬ãƒƒãƒˆé–¢æ•°ã®ç¨®é¡ ('db4', 'sym5', 'coif3'ãªã©)
    level : int
        åˆ†è§£ãƒ¬ãƒ™ãƒ«

    Returns:
    --------
    features : dict
        ã‚¦ã‚§ãƒ¼ãƒ–ãƒ¬ãƒƒãƒˆç‰¹å¾´
    coeffs : list
        ã‚¦ã‚§ãƒ¼ãƒ–ãƒ¬ãƒƒãƒˆä¿‚æ•°
    """
    # ã‚¦ã‚§ãƒ¼ãƒ–ãƒ¬ãƒƒãƒˆåˆ†è§£
    coeffs = pywt.wavedec(signal, wavelet, level=level)

    features = {}

    # å„ãƒ¬ãƒ™ãƒ«ã®ä¿‚æ•°ã‹ã‚‰ç‰¹å¾´ã‚’æŠ½å‡º
    for i, coeff in enumerate(coeffs):
        prefix = 'approx' if i == 0 else f'detail_{i}'

        # ã‚¨ãƒãƒ«ã‚®ãƒ¼
        features[f'{prefix}_energy'] = np.sum(coeff ** 2)

        # å¹³å‡çµ¶å¯¾å€¤
        features[f'{prefix}_mean_abs'] = np.mean(np.abs(coeff))

        # æ¨™æº–åå·®
        features[f'{prefix}_std'] = np.std(coeff)

        # ã‚¨ãƒ³ãƒˆãƒ­ãƒ”ãƒ¼
        coeff_norm = (coeff ** 2) / np.sum(coeff ** 2)
        coeff_norm = coeff_norm[coeff_norm > 0]
        features[f'{prefix}_entropy'] = -np.sum(coeff_norm * np.log2(coeff_norm))

    # å…¨ã‚¨ãƒãƒ«ã‚®ãƒ¼ã«å¯¾ã™ã‚‹å„ãƒ¬ãƒ™ãƒ«ã®æ¯”ç‡
    total_energy = sum([np.sum(c ** 2) for c in coeffs])
    for i, coeff in enumerate(coeffs):
        prefix = 'approx' if i == 0 else f'detail_{i}'
        features[f'{prefix}_energy_ratio'] = np.sum(coeff ** 2) / total_energy

    return features, coeffs


# ã‚µãƒ³ãƒ—ãƒ«ãƒ‡ãƒ¼ã‚¿ï¼ˆéæ¸¡ç¾è±¡ã‚’å«ã‚€ä¿¡å·ï¼‰
np.random.seed(42)
time = np.linspace(0, 10, 1000)

# ãƒ™ãƒ¼ã‚¹ä¿¡å· + çªç™ºã‚¤ãƒ™ãƒ³ãƒˆ
signal = np.sin(2 * np.pi * 2 * time) + 0.2 * np.random.randn(1000)
# 3ç§’ã¨7ç§’ã®ä½ç½®ã«çªç™ºã‚¤ãƒ™ãƒ³ãƒˆï¼ˆã‚¹ãƒ‘ã‚¤ã‚¯ï¼‰
signal[300:320] += 5 * np.exp(-0.5 * ((np.arange(20) - 10) / 3)**2)
signal[700:720] += -4 * np.exp(-0.5 * ((np.arange(20) - 10) / 3)**2)

# ã‚¦ã‚§ãƒ¼ãƒ–ãƒ¬ãƒƒãƒˆç‰¹å¾´æŠ½å‡º
features, coeffs = extract_wavelet_features(signal, wavelet='db4', level=4)

# å¯è¦–åŒ–
fig, axes = plt.subplots(6, 1, figsize=(14, 16))

# ã‚ªãƒªã‚¸ãƒŠãƒ«ä¿¡å·
axes[0].plot(time, signal, color='#11998e', linewidth=1.5)
axes[0].set_title('Original Signal with Transient Events', fontweight='bold')
axes[0].set_ylabel('Amplitude')
axes[0].grid(alpha=0.3)

# è¿‘ä¼¼ä¿‚æ•°ï¼ˆä½å‘¨æ³¢æˆåˆ†ï¼‰
axes[1].plot(coeffs[0], color='#11998e', linewidth=2)
axes[1].set_title(f'Approximation Coefficients (cA{len(coeffs)-1})', fontweight='bold')
axes[1].set_ylabel('Amplitude')
axes[1].grid(alpha=0.3)

# è©³ç´°ä¿‚æ•°ï¼ˆé«˜å‘¨æ³¢æˆåˆ†ã€ãƒ¬ãƒ™ãƒ«1-4ï¼‰
for i in range(1, 5):
    axes[i+1].plot(coeffs[i], color=f'C{i}', linewidth=1.5)
    axes[i+1].set_title(f'Detail Coefficients (cD{5-i})', fontweight='bold')
    axes[i+1].set_ylabel('Amplitude')
    axes[i+1].grid(alpha=0.3)

axes[5].set_xlabel('Coefficient Index')

plt.tight_layout()
plt.show()

# ã‚¨ãƒãƒ«ã‚®ãƒ¼æ¯”ç‡ã®å¯è¦–åŒ–
energy_ratios = [features[f'{("approx" if i==0 else f"detail_{i}")}_energy_ratio']
                 for i in range(len(coeffs))]
labels = ['Approx'] + [f'Detail {i}' for i in range(1, len(coeffs))]

fig, ax = plt.subplots(figsize=(10, 6))
ax.bar(labels, energy_ratios, color='#38ef7d', edgecolor='black', linewidth=1.5)
ax.set_ylabel('Energy Ratio')
ax.set_title('Wavelet Energy Distribution Across Levels', fontweight='bold')
ax.grid(alpha=0.3, axis='y')
plt.tight_layout()
plt.show()

# ç‰¹å¾´é‡ã®å‡ºåŠ›
print("\nWavelet Features (Energy and Entropy):")
print("=" * 60)
for level in ['approx'] + [f'detail_{i}' for i in range(1, 5)]:
    energy = features[f'{level}_energy']
    entropy = features[f'{level}_entropy']
    ratio = features[f'{level}_energy_ratio']
    print(f"{level:12s}: Energy={energy:10.2f}, Entropy={entropy:6.3f}, Ratio={ratio:6.4f}")
</code></pre>

<p><strong>è§£èª¬:</strong> ã‚¦ã‚§ãƒ¼ãƒ–ãƒ¬ãƒƒãƒˆå¤‰æ›ã¯ã€æ™‚é–“ã¨å‘¨æ³¢æ•°ã®ä¸¡æ–¹ã®æƒ…å ±ã‚’ä¿æŒã—ãªãŒã‚‰ä¿¡å·ã‚’åˆ†è§£ã—ã¾ã™ã€‚ç•°ãªã‚‹è§£åƒåº¦ãƒ¬ãƒ™ãƒ«ã§ã€ä½å‘¨æ³¢ã®ãƒˆãƒ¬ãƒ³ãƒ‰ã‹ã‚‰é«˜å‘¨æ³¢ã®çªç™ºã‚¤ãƒ™ãƒ³ãƒˆã¾ã§æ¤œå‡ºã§ãã¾ã™ã€‚ãƒ—ãƒ­ã‚»ã‚¹ã®ç•°å¸¸æ¤œçŸ¥ã‚„éæ¸¡ç¾è±¡ã®è§£æã«ç‰¹ã«æœ‰åŠ¹ã§ã™ã€‚</p>

<hr />

<h2>4.5 ãƒ‰ãƒ¡ã‚¤ãƒ³çŸ¥è­˜ã«åŸºã¥ãç‰¹å¾´é‡</h2>

<h3>ã‚³ãƒ¼ãƒ‰ä¾‹6: ãƒ—ãƒ­ã‚»ã‚¹ç‰¹æœ‰ã®ç‰¹å¾´é‡è¨­è¨ˆ</h3>

<pre><code class="language-python">import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

def calculate_process_features(df):
    """
    åŒ–å­¦ãƒ—ãƒ­ã‚»ã‚¹ç‰¹æœ‰ã®ç‰¹å¾´é‡ã‚’è¨ˆç®—

    Parameters:
    -----------
    df : pd.DataFrame
        ãƒ—ãƒ­ã‚»ã‚¹ãƒ‡ãƒ¼ã‚¿ï¼ˆæ¸©åº¦ã€åœ§åŠ›ã€æµé‡ã€æ¿ƒåº¦ãªã©ã‚’å«ã‚€ï¼‰

    Returns:
    --------
    df_features : pd.DataFrame
        è¿½åŠ ã•ã‚ŒãŸç‰¹å¾´é‡ã‚’å«ã‚€DataFrame
    """
    df_features = df.copy()

    # 1. æ»ç•™æ™‚é–“ï¼ˆResidence Timeï¼‰
    # æ»ç•™æ™‚é–“ = åå¿œå™¨å®¹ç© / æµé‡
    reactor_volume = 100  # ãƒªãƒƒãƒˆãƒ«
    df_features['residence_time'] = reactor_volume / df['flow_rate']

    # 2. ç©ºé–“é€Ÿåº¦ï¼ˆSpace Velocityï¼‰
    # LHSV (Liquid Hourly Space Velocity) = æµé‡ / åå¿œå™¨å®¹ç©
    df_features['space_velocity'] = df['flow_rate'] / reactor_volume

    # 3. è»¢åŒ–ç‡ï¼ˆConversionï¼‰
    # è»¢åŒ–ç‡ = (å…¥å£æ¿ƒåº¦ - å‡ºå£æ¿ƒåº¦) / å…¥å£æ¿ƒåº¦
    df_features['conversion'] = ((df['inlet_concentration'] - df['outlet_concentration']) /
                                  df['inlet_concentration'])

    # 4. åç‡ï¼ˆYieldï¼‰
    # åç‡ = ç›®çš„ç”Ÿæˆç‰©æ¿ƒåº¦ / å…¥å£åŸæ–™æ¿ƒåº¦
    df_features['yield'] = df['product_concentration'] / df['inlet_concentration']

    # 5. é¸æŠç‡ï¼ˆSelectivityï¼‰
    # é¸æŠç‡ = ç›®çš„ç”Ÿæˆç‰© / å…¨ç”Ÿæˆç‰©
    df_features['selectivity'] = (df['product_concentration'] /
                                  (df['product_concentration'] + df['byproduct_concentration']))

    # 6. ç†±åæ”¯é–¢é€£
    # åå¿œç†±ï¼ˆç°¡ç•¥åŒ–ãƒ¢ãƒ‡ãƒ«ï¼‰
    cp = 4.18  # æ¯”ç†± [kJ/(kgÂ·K)]
    df_features['heat_generation'] = (df['flow_rate'] * cp *
                                      (df['outlet_temperature'] - df['inlet_temperature']))

    # 7. åœ§åŠ›æå¤±
    df_features['pressure_drop'] = df['inlet_pressure'] - df['outlet_pressure']

    # 8. ã‚¨ãƒãƒ«ã‚®ãƒ¼åŠ¹ç‡
    # ã‚¨ãƒãƒ«ã‚®ãƒ¼åŠ¹ç‡ = è£½å“ä¾¡å€¤ / ã‚¨ãƒãƒ«ã‚®ãƒ¼æŠ•å…¥
    df_features['energy_efficiency'] = df['product_concentration'] / df['energy_input']

    # 9. æ¯”ç‡ç‰¹å¾´ï¼ˆç‰©è³ªåæ”¯ãƒã‚§ãƒƒã‚¯ï¼‰
    df_features['mass_balance_ratio'] = ((df['inlet_concentration'] * df['flow_rate']) /
                                         ((df['outlet_concentration'] + df['product_concentration']) * df['flow_rate']))

    # 10. æ¸©åº¦-åœ§åŠ›ç›¸é–¢æŒ‡æ¨™
    df_features['T_P_interaction'] = df['temperature'] * df['pressure']

    return df_features


# ã‚µãƒ³ãƒ—ãƒ«ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆï¼ˆåå¿œå™¨ã®é‹è»¢ãƒ‡ãƒ¼ã‚¿ï¼‰
np.random.seed(42)
n_samples = 200

process_data = pd.DataFrame({
    'timestamp': pd.date_range('2024-01-01', periods=n_samples, freq='h'),
    'flow_rate': 50 + 10 * np.random.randn(n_samples),  # L/h
    'temperature': 180 + 5 * np.random.randn(n_samples),  # Â°C
    'pressure': 3.0 + 0.2 * np.random.randn(n_samples),  # bar
    'inlet_temperature': 150 + 3 * np.random.randn(n_samples),  # Â°C
    'outlet_temperature': 185 + 5 * np.random.randn(n_samples),  # Â°C
    'inlet_pressure': 3.2 + 0.15 * np.random.randn(n_samples),  # bar
    'outlet_pressure': 2.8 + 0.15 * np.random.randn(n_samples),  # bar
    'inlet_concentration': 2.0 + 0.1 * np.random.randn(n_samples),  # mol/L
    'outlet_concentration': 0.5 + 0.1 * np.random.randn(n_samples),  # mol/L
    'product_concentration': 1.3 + 0.15 * np.random.randn(n_samples),  # mol/L
    'byproduct_concentration': 0.2 + 0.05 * np.random.randn(n_samples),  # mol/L
    'energy_input': 100 + 15 * np.random.randn(n_samples)  # kW
})

# ç‰¹å¾´é‡è¨ˆç®—
df_with_features = calculate_process_features(process_data)

# å¯è¦–åŒ–
fig, axes = plt.subplots(3, 2, figsize=(16, 12))

# æ»ç•™æ™‚é–“
axes[0, 0].plot(df_with_features.index, df_with_features['residence_time'],
                color='#11998e', linewidth=1.5)
axes[0, 0].set_ylabel('Residence Time [h]')
axes[0, 0].set_title('Residence Time', fontweight='bold')
axes[0, 0].grid(alpha=0.3)

# è»¢åŒ–ç‡
axes[0, 1].plot(df_with_features.index, df_with_features['conversion'] * 100,
                color='#38ef7d', linewidth=1.5)
axes[0, 1].set_ylabel('Conversion [%]')
axes[0, 1].set_title('Conversion Rate', fontweight='bold')
axes[0, 1].grid(alpha=0.3)

# åç‡
axes[1, 0].plot(df_with_features.index, df_with_features['yield'] * 100,
                color='orange', linewidth=1.5)
axes[1, 0].set_ylabel('Yield [%]')
axes[1, 0].set_title('Product Yield', fontweight='bold')
axes[1, 0].grid(alpha=0.3)

# é¸æŠç‡
axes[1, 1].plot(df_with_features.index, df_with_features['selectivity'] * 100,
                color='purple', linewidth=1.5)
axes[1, 1].set_ylabel('Selectivity [%]')
axes[1, 1].set_title('Product Selectivity', fontweight='bold')
axes[1, 1].grid(alpha=0.3)

# ã‚¨ãƒãƒ«ã‚®ãƒ¼åŠ¹ç‡
axes[2, 0].plot(df_with_features.index, df_with_features['energy_efficiency'],
                color='red', linewidth=1.5)
axes[2, 0].set_ylabel('Efficiency [molÂ·Lâ»Â¹/kW]')
axes[2, 0].set_title('Energy Efficiency', fontweight='bold')
axes[2, 0].set_xlabel('Sample Index')
axes[2, 0].grid(alpha=0.3)

# åœ§åŠ›æå¤±
axes[2, 1].plot(df_with_features.index, df_with_features['pressure_drop'],
                color='brown', linewidth=1.5)
axes[2, 1].set_ylabel('Pressure Drop [bar]')
axes[2, 1].set_title('Pressure Drop', fontweight='bold')
axes[2, 1].set_xlabel('Sample Index')
axes[2, 1].grid(alpha=0.3)

plt.tight_layout()
plt.show()

# çµ±è¨ˆã‚µãƒãƒªãƒ¼
print("\nProcess Feature Statistics:")
print("=" * 70)
feature_cols = ['residence_time', 'conversion', 'yield', 'selectivity',
                'energy_efficiency', 'pressure_drop']
print(df_with_features[feature_cols].describe().to_string())
</code></pre>

<p><strong>è§£èª¬:</strong> ãƒ—ãƒ­ã‚»ã‚¹å·¥å­¦ã®çŸ¥è­˜ã«åŸºã¥ãç‰¹å¾´é‡ã¯ã€ç‰©ç†çš„ãªæ„å‘³ã‚’æŒã¡è§£é‡ˆå¯èƒ½æ€§ãŒé«˜ã„ç‚¹ãŒé‡è¦ã§ã™ã€‚è»¢åŒ–ç‡ã€åç‡ã€é¸æŠç‡ãªã©ã¯ã€ãƒ—ãƒ­ã‚»ã‚¹ã®æ€§èƒ½ã‚’ç›´æ¥è¡¨ç¾ã—ã€ç•°å¸¸æ¤œçŸ¥ã‚„æœ€é©åŒ–ã«ãŠã„ã¦æ¥µã‚ã¦æœ‰ç”¨ã§ã™ã€‚</p>

<hr />

<h2>4.6 ç›¸äº’ä½œç”¨ç‰¹å¾´ã¨å¤šé …å¼ç‰¹å¾´</h2>

<h3>ã‚³ãƒ¼ãƒ‰ä¾‹7: ç›¸äº’ä½œç”¨ç‰¹å¾´ã®ç”Ÿæˆ</h3>

<pre><code class="language-python">import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.preprocessing import PolynomialFeatures
from itertools import combinations

def create_interaction_features(df, feature_cols, degree=2):
    """
    ç›¸äº’ä½œç”¨ç‰¹å¾´ã¨å¤šé …å¼ç‰¹å¾´ã‚’ç”Ÿæˆ

    Parameters:
    -----------
    df : pd.DataFrame
        å…ƒã®ãƒ‡ãƒ¼ã‚¿
    feature_cols : list
        ç‰¹å¾´é‡ã®ã‚«ãƒ©ãƒ åãƒªã‚¹ãƒˆ
    degree : int
        å¤šé …å¼ã®æ¬¡æ•°

    Returns:
    --------
    df_extended : pd.DataFrame
        ç›¸äº’ä½œç”¨ç‰¹å¾´ã‚’è¿½åŠ ã—ãŸDataFrame
    """
    df_extended = df.copy()

    # 1. ç©ï¼ˆProductï¼‰ç‰¹å¾´
    for col1, col2 in combinations(feature_cols, 2):
        df_extended[f'{col1}_x_{col2}'] = df[col1] * df[col2]

    # 2. æ¯”ç‡ï¼ˆRatioï¼‰ç‰¹å¾´
    for col1, col2 in combinations(feature_cols, 2):
        # ã‚¼ãƒ­é™¤ç®—ã‚’é¿ã‘ã‚‹
        df_extended[f'{col1}_div_{col2}'] = df[col1] / (df[col2] + 1e-8)

    # 3. å·®åˆ†ç‰¹å¾´
    for col1, col2 in combinations(feature_cols, 2):
        df_extended[f'{col1}_minus_{col2}'] = df[col1] - df[col2]

    # 4. å¤šé …å¼ç‰¹å¾´ï¼ˆsklearnä½¿ç”¨ï¼‰
    if degree >= 2:
        poly = PolynomialFeatures(degree=degree, include_bias=False)
        X_poly = poly.fit_transform(df[feature_cols])
        poly_feature_names = poly.get_feature_names_out(feature_cols)

        # æ–°ã—ã„ç‰¹å¾´ã®ã¿è¿½åŠ ï¼ˆå…ƒã®ç‰¹å¾´ã¯é™¤ãï¼‰
        for i, name in enumerate(poly_feature_names):
            if name not in feature_cols:
                df_extended[f'poly_{name}'] = X_poly[:, i]

    return df_extended


# ã‚µãƒ³ãƒ—ãƒ«ãƒ‡ãƒ¼ã‚¿
np.random.seed(42)
n_samples = 300

data = pd.DataFrame({
    'temperature': 180 + 10 * np.random.randn(n_samples),
    'pressure': 3.0 + 0.5 * np.random.randn(n_samples),
    'flow_rate': 50 + 8 * np.random.randn(n_samples)
})

# éç·šå½¢ãªç›®çš„å¤‰æ•°ï¼ˆæ¸©åº¦ã¨åœ§åŠ›ã®ç›¸äº’ä½œç”¨ã‚’å«ã‚€ï¼‰
data['product_quality'] = (0.5 * data['temperature'] +
                           2.0 * data['pressure'] +
                           0.01 * data['temperature'] * data['pressure'] +  # ç›¸äº’ä½œç”¨é …
                           0.002 * data['temperature']**2 +  # 2æ¬¡é …
                           np.random.randn(n_samples) * 5)

# ç›¸äº’ä½œç”¨ç‰¹å¾´ã®ç”Ÿæˆ
df_interaction = create_interaction_features(data,
                                             ['temperature', 'pressure', 'flow_rate'],
                                             degree=2)

# å¯è¦–åŒ–ï¼šç›¸é–¢åˆ†æ
import seaborn as sns

# ä¸»è¦ãªç‰¹å¾´é‡ã®ç›¸é–¢ãƒãƒˆãƒªãƒƒã‚¯ã‚¹
key_features = ['temperature', 'pressure', 'flow_rate',
                'temperature_x_pressure', 'poly_temperature^2',
                'temperature_div_pressure', 'product_quality']
correlation_matrix = df_interaction[key_features].corr()

fig, ax = plt.subplots(figsize=(12, 10))
sns.heatmap(correlation_matrix, annot=True, fmt='.2f', cmap='RdYlGn',
            center=0, square=True, linewidths=1, cbar_kws={"shrink": 0.8})
ax.set_title('Correlation Matrix with Interaction Features',
             fontweight='bold', fontsize=14)
plt.tight_layout()
plt.show()

# æ•£å¸ƒå›³è¡Œåˆ—
fig, axes = plt.subplots(2, 2, figsize=(14, 12))

# æ¸©åº¦ vs å“è³ª
axes[0, 0].scatter(df_interaction['temperature'], df_interaction['product_quality'],
                   alpha=0.5, color='#11998e', edgecolor='black', linewidth=0.5)
axes[0, 0].set_xlabel('Temperature [Â°C]')
axes[0, 0].set_ylabel('Product Quality')
axes[0, 0].set_title('Temperature vs Quality')
axes[0, 0].grid(alpha=0.3)

# åœ§åŠ› vs å“è³ª
axes[0, 1].scatter(df_interaction['pressure'], df_interaction['product_quality'],
                   alpha=0.5, color='#38ef7d', edgecolor='black', linewidth=0.5)
axes[0, 1].set_xlabel('Pressure [bar]')
axes[0, 1].set_ylabel('Product Quality')
axes[0, 1].set_title('Pressure vs Quality')
axes[0, 1].grid(alpha=0.3)

# æ¸©åº¦Ã—åœ§åŠ›ï¼ˆç›¸äº’ä½œç”¨ï¼‰ vs å“è³ª
axes[1, 0].scatter(df_interaction['temperature_x_pressure'],
                   df_interaction['product_quality'],
                   alpha=0.5, color='orange', edgecolor='black', linewidth=0.5)
axes[1, 0].set_xlabel('Temperature Ã— Pressure')
axes[1, 0].set_ylabel('Product Quality')
axes[1, 0].set_title('Interaction Feature vs Quality')
axes[1, 0].grid(alpha=0.3)

# æ¸©åº¦^2ï¼ˆ2æ¬¡é …ï¼‰ vs å“è³ª
axes[1, 1].scatter(df_interaction['poly_temperature^2'],
                   df_interaction['product_quality'],
                   alpha=0.5, color='purple', edgecolor='black', linewidth=0.5)
axes[1, 1].set_xlabel('TemperatureÂ²')
axes[1, 1].set_ylabel('Product Quality')
axes[1, 1].set_title('Polynomial Feature vs Quality')
axes[1, 1].grid(alpha=0.3)

plt.tight_layout()
plt.show()

print(f"\nOriginal features: {len(['temperature', 'pressure', 'flow_rate'])}")
print(f"Total features after interaction: {len(df_interaction.columns)}")
print(f"\nSample of new interaction features:")
interaction_cols = [col for col in df_interaction.columns if '_x_' in col or '_div_' in col or 'poly_' in col]
print(interaction_cols[:10])
</code></pre>

<p><strong>è§£èª¬:</strong> ç›¸äº’ä½œç”¨ç‰¹å¾´ã¯ã€å¤‰æ•°é–“ã®éç·šå½¢ãªé–¢ä¿‚ã‚’æ‰ãˆã¾ã™ã€‚æ¸©åº¦ã¨åœ§åŠ›ã®ç©é …ã¯ã€ä¸¡è€…ãŒåŒæ™‚ã«é«˜ã„å ´åˆã®åŠ¹æœã‚’è¡¨ç¾ã—ã€ç·šå½¢ãƒ¢ãƒ‡ãƒ«ã§ã‚‚éç·šå½¢ãªé–¢ä¿‚ã‚’ãƒ¢ãƒ‡ãƒ«åŒ–ã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚</p>

<hr />

<h2>4.7 ç‰¹å¾´é‡ã®æ­£è¦åŒ–ã¨ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°</h2>

<h3>ã‚³ãƒ¼ãƒ‰ä¾‹8: ç‰¹å¾´é‡ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°æ‰‹æ³•ã®æ¯”è¼ƒ</h3>

<pre><code class="language-python">import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.preprocessing import (StandardScaler, MinMaxScaler,
                                   RobustScaler, PowerTransformer)

# ã‚µãƒ³ãƒ—ãƒ«ãƒ‡ãƒ¼ã‚¿ï¼ˆã‚¹ã‚±ãƒ¼ãƒ«ã®ç•°ãªã‚‹ç‰¹å¾´é‡ï¼‰
np.random.seed(42)
n_samples = 300

data = pd.DataFrame({
    'temperature': 180 + 20 * np.random.randn(n_samples),  # å¹³å‡180, ã‚¹ã‚±ãƒ¼ãƒ«å¤§
    'pressure': 3.0 + 0.5 * np.random.randn(n_samples),    # å¹³å‡3, ã‚¹ã‚±ãƒ¼ãƒ«å°
    'flow_rate': 5000 + 500 * np.random.randn(n_samples)   # å¹³å‡5000, ã‚¹ã‚±ãƒ¼ãƒ«éå¸¸ã«å¤§
})

# å¤–ã‚Œå€¤ã‚’è¿½åŠ 
data.loc[10:15, 'temperature'] = 250  # ç•°å¸¸ã«é«˜ã„æ¸©åº¦
data.loc[50:55, 'pressure'] = 8.0     # ç•°å¸¸ã«é«˜ã„åœ§åŠ›

# å„ç¨®ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°æ‰‹æ³•ã‚’é©ç”¨
scalers = {
    'Original': None,
    'StandardScaler': StandardScaler(),
    'MinMaxScaler': MinMaxScaler(),
    'RobustScaler': RobustScaler(),
    'PowerTransformer': PowerTransformer(method='yeo-johnson')
}

scaled_data = {}
for name, scaler in scalers.items():
    if scaler is None:
        scaled_data[name] = data.copy()
    else:
        scaled_data[name] = pd.DataFrame(
            scaler.fit_transform(data),
            columns=data.columns
        )

# å¯è¦–åŒ–
fig, axes = plt.subplots(3, 5, figsize=(18, 12))

for i, feature in enumerate(data.columns):
    for j, (name, df) in enumerate(scaled_data.items()):
        axes[i, j].hist(df[feature], bins=30, color='#11998e',
                        alpha=0.7, edgecolor='black')
        axes[i, j].set_title(f'{name}\n{feature}', fontsize=10)
        axes[i, j].grid(alpha=0.3)

        if i == 0:
            axes[i, j].set_title(f'{name}\n{feature}', fontsize=10, fontweight='bold')

plt.tight_layout()
plt.show()

# çµ±è¨ˆé‡ã®æ¯”è¼ƒ
print("\nScaling Methods Comparison:")
print("=" * 80)
for name, df in scaled_data.items():
    print(f"\n{name}:")
    print(df.describe().loc[['mean', 'std', 'min', 'max']].to_string())
</code></pre>

<p><strong>è§£èª¬:</strong></p>
<ul>
<li><strong>StandardScaler</strong>: å¹³å‡0ã€æ¨™æº–åå·®1ã«æ­£è¦åŒ–ã€‚å¤–ã‚Œå€¤ã®å½±éŸ¿ã‚’å—ã‘ã‚„ã™ã„ã€‚</li>
<li><strong>MinMaxScaler</strong>: [0, 1]ã®ç¯„å›²ã«ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°ã€‚å¤–ã‚Œå€¤ã®å½±éŸ¿ã‚’æœ€ã‚‚å—ã‘ã‚„ã™ã„ã€‚</li>
<li><strong>RobustScaler</strong>: ä¸­å¤®å€¤ã¨å››åˆ†ä½ç¯„å›²ã‚’ä½¿ç”¨ã€‚å¤–ã‚Œå€¤ã«é ‘å¥ã€‚</li>
<li><strong>PowerTransformer</strong>: ãƒ‡ãƒ¼ã‚¿ã‚’æ­£è¦åˆ†å¸ƒã«è¿‘ã¥ã‘ã‚‹å¤‰æ›ã€‚æ­ªã‚“ã åˆ†å¸ƒã«æœ‰åŠ¹ã€‚</li>
</ul>

<hr />

<h2>4.8 ç‰¹å¾´é‡é¸æŠ</h2>

<h3>ã‚³ãƒ¼ãƒ‰ä¾‹9: ç‰¹å¾´é‡é¸æŠæ‰‹æ³•ï¼ˆç›¸äº’æƒ…å ±é‡ã€RFEã€LASSOï¼‰</h3>

<pre><code class="language-python">import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.feature_selection import (mutual_info_regression, RFE,
                                       SelectFromModel)
from sklearn.linear_model import Lasso, Ridge
from sklearn.ensemble import RandomForestRegressor

# ã‚µãƒ³ãƒ—ãƒ«ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆ
np.random.seed(42)
n_samples = 500
n_features = 20

# ç‰¹å¾´é‡ç”Ÿæˆï¼ˆä¸€éƒ¨ã¯ç›®çš„å¤‰æ•°ã¨ç„¡é–¢ä¿‚ï¼‰
X = np.random.randn(n_samples, n_features)

# ç›®çš„å¤‰æ•°ï¼ˆä¸€éƒ¨ã®ç‰¹å¾´é‡ã®ã¿ã«ä¾å­˜ï¼‰
y = (3 * X[:, 0] +      # é‡è¦ãªç‰¹å¾´
     2 * X[:, 1] +      # é‡è¦ãªç‰¹å¾´
     1.5 * X[:, 2] +    # ã‚„ã‚„é‡è¦
     0.5 * X[:, 5] +    # ã‚ãšã‹ã«é‡è¦
     np.random.randn(n_samples) * 0.5)  # ãƒã‚¤ã‚º
# X[:, 3], X[:, 4], X[:, 6-19]ã¯ç„¡é–¢ä¿‚

feature_names = [f'Feature_{i}' for i in range(n_features)]
df = pd.DataFrame(X, columns=feature_names)
df['target'] = y


# 1. ç›¸äº’æƒ…å ±é‡ï¼ˆMutual Informationï¼‰
mi_scores = mutual_info_regression(X, y, random_state=42)
mi_scores = pd.Series(mi_scores, index=feature_names).sort_values(ascending=False)

# 2. RFEï¼ˆRecursive Feature Eliminationï¼‰
rf_model = RandomForestRegressor(n_estimators=50, random_state=42)
rfe = RFE(estimator=rf_model, n_features_to_select=10)
rfe.fit(X, y)
rfe_ranking = pd.Series(rfe.ranking_, index=feature_names).sort_values()

# 3. LASSOï¼ˆL1æ­£å‰‡åŒ–ï¼‰
lasso = Lasso(alpha=0.1, random_state=42)
lasso.fit(X, y)
lasso_coefs = pd.Series(np.abs(lasso.coef_), index=feature_names).sort_values(ascending=False)

# 4. Random Forestã®ç‰¹å¾´é‡è¦åº¦
rf_model.fit(X, y)
rf_importances = pd.Series(rf_model.feature_importances_,
                           index=feature_names).sort_values(ascending=False)


# å¯è¦–åŒ–
fig, axes = plt.subplots(2, 2, figsize=(16, 12))

# ç›¸äº’æƒ…å ±é‡
axes[0, 0].barh(mi_scores.index[:10], mi_scores.values[:10],
                color='#11998e', edgecolor='black')
axes[0, 0].set_xlabel('Mutual Information Score')
axes[0, 0].set_title('Mutual Information (Top 10 Features)', fontweight='bold')
axes[0, 0].invert_yaxis()
axes[0, 0].grid(alpha=0.3, axis='x')

# RFEãƒ©ãƒ³ã‚­ãƒ³ã‚°
selected_features_rfe = rfe_ranking[rfe_ranking == 1].index.tolist()
axes[0, 1].barh(rfe_ranking.index[:10], rfe_ranking.values[:10],
                color='#38ef7d', edgecolor='black')
axes[0, 1].set_xlabel('RFE Ranking (1 = selected)')
axes[0, 1].set_title(f'RFE Ranking (Selected: {len(selected_features_rfe)})',
                     fontweight='bold')
axes[0, 1].invert_yaxis()
axes[0, 1].grid(alpha=0.3, axis='x')

# LASSOä¿‚æ•°
axes[1, 0].barh(lasso_coefs.index[:10], lasso_coefs.values[:10],
                color='orange', edgecolor='black')
axes[1, 0].set_xlabel('|LASSO Coefficient|')
axes[1, 0].set_title('LASSO Feature Selection (Top 10)', fontweight='bold')
axes[1, 0].invert_yaxis()
axes[1, 0].grid(alpha=0.3, axis='x')

# Random Foresté‡è¦åº¦
axes[1, 1].barh(rf_importances.index[:10], rf_importances.values[:10],
                color='purple', edgecolor='black')
axes[1, 1].set_xlabel('Feature Importance')
axes[1, 1].set_title('Random Forest Importances (Top 10)', fontweight='bold')
axes[1, 1].invert_yaxis()
axes[1, 1].grid(alpha=0.3, axis='x')

plt.tight_layout()
plt.show()

# ç‰¹å¾´é¸æŠçµæœã®æ¯”è¼ƒ
print("\nFeature Selection Results Comparison:")
print("=" * 70)
print("\nTop 5 Features by Each Method:")
print(f"\nMutual Information:\n{mi_scores.head(5).to_string()}")
print(f"\nRFE Selected Features:\n{selected_features_rfe[:5]}")
print(f"\nLASSO:\n{lasso_coefs.head(5).to_string()}")
print(f"\nRandom Forest:\n{rf_importances.head(5).to_string()}")

# çœŸã«é‡è¦ãªç‰¹å¾´ï¼ˆFeature_0, Feature_1, Feature_2, Feature_5ï¼‰ã¨ã®æ¯”è¼ƒ
true_important = ['Feature_0', 'Feature_1', 'Feature_2', 'Feature_5']
print(f"\n\nTrue Important Features: {true_important}")
print(f"MI correctly identified: {[f for f in mi_scores.head(5).index if f in true_important]}")
print(f"LASSO correctly identified: {[f for f in lasso_coefs.head(5).index if f in true_important]}")
print(f"RF correctly identified: {[f for f in rf_importances.head(5).index if f in true_important]}")
</code></pre>

<p><strong>è§£èª¬:</strong></p>
<ul>
<li><strong>ç›¸äº’æƒ…å ±é‡</strong>: éç·šå½¢ãªé–¢ä¿‚ã‚‚æ¤œå‡ºå¯èƒ½ã€‚è¨ˆç®—ã‚³ã‚¹ãƒˆãŒé«˜ã„ã€‚</li>
<li><strong>RFE</strong>: ãƒ¢ãƒ‡ãƒ«ãƒ™ãƒ¼ã‚¹ã®é¸æŠã€‚åå¾©çš„ã«é‡è¦åº¦ã®ä½ã„ç‰¹å¾´ã‚’é™¤å»ã€‚</li>
<li><strong>LASSO</strong>: L1æ­£å‰‡åŒ–ã«ã‚ˆã‚Šè‡ªå‹•çš„ã«ä¸è¦ãªç‰¹å¾´ã®ä¿‚æ•°ã‚’ã‚¼ãƒ­ã«ã€‚ç·šå½¢é–¢ä¿‚ã‚’å‰æã€‚</li>
<li><strong>Random Forest</strong>: éç·šå½¢é–¢ä¿‚ã‚’æ‰ãˆã‚‹ã€‚ã‚¢ãƒ³ã‚µãƒ³ãƒ–ãƒ«ãƒ¢ãƒ‡ãƒ«ã®å‰¯ç”£ç‰©ã¨ã—ã¦å¾—ã‚‰ã‚Œã‚‹ã€‚</li>
</ul>

<hr />

<h2>4.9 è‡ªå‹•ç‰¹å¾´é‡æŠ½å‡ºï¼ˆtsfreshï¼‰</h2>

<h3>ã‚³ãƒ¼ãƒ‰ä¾‹10: tsfreshã«ã‚ˆã‚‹åŒ…æ‹¬çš„ç‰¹å¾´é‡æŠ½å‡º</h3>

<pre><code class="language-python">import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from tsfresh import extract_features
from tsfresh.feature_extraction import ComprehensiveFCParameters
from tsfresh.utilities.dataframe_functions import impute

# ã‚µãƒ³ãƒ—ãƒ«æ™‚ç³»åˆ—ãƒ‡ãƒ¼ã‚¿ï¼ˆè¤‡æ•°ã®ã‚»ãƒ³ã‚µãƒ¼ã€è¤‡æ•°ã®æ™‚ç³»åˆ—ã‚»ã‚°ãƒ¡ãƒ³ãƒˆï¼‰
np.random.seed(42)
n_segments = 50  # ã‚»ã‚°ãƒ¡ãƒ³ãƒˆæ•°ï¼ˆãƒãƒƒãƒæ•°ï¼‰
n_timesteps = 100  # å„ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã®æ™‚ç³»åˆ—é•·

data_list = []

for seg_id in range(n_segments):
    # å„ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã¯ç•°ãªã‚‹ç‰¹æ€§ã‚’æŒã¤
    time = np.arange(n_timesteps)

    # ãƒ©ãƒ™ãƒ«ï¼ˆå“è³ªï¼šè‰¯å“=1ã€ä¸è‰¯å“=0ï¼‰
    label = np.random.choice([0, 1], p=[0.3, 0.7])

    # è‰¯å“ã¨ä¸è‰¯å“ã§çµ±è¨ˆçš„ç‰¹æ€§ã‚’å¤‰ãˆã‚‹
    if label == 1:  # è‰¯å“
        temperature = 180 + 2 * np.sin(0.1 * time) + np.random.randn(n_timesteps) * 0.5
        pressure = 3.0 + 0.1 * np.cos(0.08 * time) + np.random.randn(n_timesteps) * 0.1
    else:  # ä¸è‰¯å“ï¼ˆã‚ˆã‚Šä¸è¦å‰‡ï¼‰
        temperature = 180 + 5 * np.sin(0.1 * time) + np.random.randn(n_timesteps) * 2.0
        pressure = 3.0 + 0.3 * np.cos(0.08 * time) + np.random.randn(n_timesteps) * 0.5

    for t in range(n_timesteps):
        data_list.append({
            'segment_id': seg_id,
            'time': t,
            'temperature': temperature[t],
            'pressure': pressure[t],
            'label': label
        })

df_timeseries = pd.DataFrame(data_list)

# tsfreshã§ç‰¹å¾´é‡æŠ½å‡º
print("Extracting features with tsfresh...")
extraction_settings = ComprehensiveFCParameters()

# ç‰¹å¾´é‡æŠ½å‡ºï¼ˆsegment_idã”ã¨ã«é›†ç´„ï¼‰
df_features = extract_features(
    df_timeseries[['segment_id', 'time', 'temperature', 'pressure']],
    column_id='segment_id',
    column_sort='time',
    default_fc_parameters=extraction_settings,
    impute_function=impute,
    n_jobs=4
)

# ãƒ©ãƒ™ãƒ«æƒ…å ±ã‚’è¿½åŠ 
df_labels = df_timeseries.groupby('segment_id')['label'].first()
df_features = df_features.join(df_labels)

print(f"\nExtracted {len(df_features.columns)-1} features from {n_segments} segments")
print(f"Feature examples:\n{df_features.columns[:10].tolist()}")

# ç‰¹å¾´é‡ã®é‡è¦åº¦åˆ†æï¼ˆç°¡æ˜“ç‰ˆï¼šåˆ†æ•£ã«åŸºã¥ãï¼‰
feature_variance = df_features.drop('label', axis=1).var().sort_values(ascending=False)

# å¯è¦–åŒ–
fig, axes = plt.subplots(2, 2, figsize=(16, 12))

# 1. ã‚µãƒ³ãƒ—ãƒ«æ™‚ç³»åˆ—ï¼ˆè‰¯å“ vs ä¸è‰¯å“ï¼‰
good_example = df_timeseries[df_timeseries['label'] == 1]['segment_id'].iloc[0]
bad_example = df_timeseries[df_timeseries['label'] == 0]['segment_id'].iloc[0]

good_data = df_timeseries[df_timeseries['segment_id'] == good_example]
bad_data = df_timeseries[df_timeseries['segment_id'] == bad_example]

axes[0, 0].plot(good_data['time'], good_data['temperature'],
                color='green', linewidth=2, label='Good Product')
axes[0, 0].plot(bad_data['time'], bad_data['temperature'],
                color='red', linewidth=2, alpha=0.7, label='Defective Product')
axes[0, 0].set_xlabel('Time')
axes[0, 0].set_ylabel('Temperature [Â°C]')
axes[0, 0].set_title('Example Time Series (Temperature)', fontweight='bold')
axes[0, 0].legend()
axes[0, 0].grid(alpha=0.3)

# 2. åœ§åŠ›ã®æ¯”è¼ƒ
axes[0, 1].plot(good_data['time'], good_data['pressure'],
                color='green', linewidth=2, label='Good Product')
axes[0, 1].plot(bad_data['time'], bad_data['pressure'],
                color='red', linewidth=2, alpha=0.7, label='Defective Product')
axes[0, 1].set_xlabel('Time')
axes[0, 1].set_ylabel('Pressure [bar]')
axes[0, 1].set_title('Example Time Series (Pressure)', fontweight='bold')
axes[0, 1].legend()
axes[0, 1].grid(alpha=0.3)

# 3. åˆ†æ•£ãŒå¤§ãã„ç‰¹å¾´é‡ãƒˆãƒƒãƒ—20
axes[1, 0].barh(range(20), feature_variance.head(20).values,
                color='#11998e', edgecolor='black')
axes[1, 0].set_yticks(range(20))
axes[1, 0].set_yticklabels([name[:40] + '...' if len(name) > 40 else name
                            for name in feature_variance.head(20).index], fontsize=8)
axes[1, 0].set_xlabel('Variance')
axes[1, 0].set_title('Top 20 Features by Variance', fontweight='bold')
axes[1, 0].invert_yaxis()
axes[1, 0].grid(alpha=0.3, axis='x')

# 4. ç‰¹å¾´é‡ã®åˆ†å¸ƒï¼ˆè‰¯å“ vs ä¸è‰¯å“ï¼‰
# åˆ†æ•£ãŒæœ€å¤§ã®ç‰¹å¾´ã‚’é¸æŠ
top_feature = feature_variance.index[0]
axes[1, 1].hist(df_features[df_features['label'] == 1][top_feature].dropna(),
                bins=20, alpha=0.6, color='green', edgecolor='black', label='Good')
axes[1, 1].hist(df_features[df_features['label'] == 0][top_feature].dropna(),
                bins=20, alpha=0.6, color='red', edgecolor='black', label='Defective')
axes[1, 1].set_xlabel('Feature Value')
axes[1, 1].set_ylabel('Frequency')
axes[1, 1].set_title(f'Feature Distribution: {top_feature[:50]}...', fontweight='bold')
axes[1, 1].legend()
axes[1, 1].grid(alpha=0.3)

plt.tight_layout()
plt.show()

# çµ±è¨ˆã‚µãƒãƒªãƒ¼
print("\nFeature Extraction Summary:")
print("=" * 70)
print(f"Number of segments: {n_segments}")
print(f"Timesteps per segment: {n_timesteps}")
print(f"Total extracted features: {len(df_features.columns)-1}")
print(f"\nSample features:\n{df_features.iloc[0, :5].to_string()}")
</code></pre>

<p><strong>è§£èª¬:</strong> tsfreshã¯æ™‚ç³»åˆ—ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰æ•°ç™¾ã€œæ•°åƒã®çµ±è¨ˆçš„ç‰¹å¾´é‡ã‚’è‡ªå‹•çš„ã«æŠ½å‡ºã™ã‚‹ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã§ã™ã€‚ãƒ•ãƒ¼ãƒªã‚¨å¤‰æ›ä¿‚æ•°ã€è‡ªå·±ç›¸é–¢ã€ã‚¨ãƒ³ãƒˆãƒ­ãƒ”ãƒ¼ã€ãƒˆãƒ¬ãƒ³ãƒ‰æŒ‡æ¨™ãªã©ã€åŒ…æ‹¬çš„ãªç‰¹å¾´ã‚»ãƒƒãƒˆã‚’ç”Ÿæˆã—ã€ç‰¹å¾´é¸æŠæ©Ÿèƒ½ã‚‚æä¾›ã—ã¾ã™ã€‚ãƒ—ãƒ­ã‚»ã‚¹ãƒ‡ãƒ¼ã‚¿ã®ç•°å¸¸æ¤œçŸ¥ã‚„å“è³ªäºˆæ¸¬ã«ãŠã„ã¦å¼·åŠ›ãªãƒ„ãƒ¼ãƒ«ã§ã™ã€‚</p>

<hr />

<h2>4.10 æœ¬ç« ã®ã¾ã¨ã‚</h2>

<h3>å­¦ã‚“ã ã“ã¨</h3>

<ol>
<li><strong>æ™‚é–“é ˜åŸŸç‰¹å¾´é‡</strong>
<ul>
<li>åŸºæœ¬çµ±è¨ˆé‡ï¼ˆå¹³å‡ã€æ¨™æº–åå·®ã€æ­ªåº¦ã€å°–åº¦ï¼‰</li>
<li>ãƒ­ãƒ¼ãƒªãƒ³ã‚°çµ±è¨ˆã¨ãƒ©ã‚°ç‰¹å¾´</li>
<li>å·®åˆ†ã¨å‹¾é…ã«ã‚ˆã‚‹å¤‰åŒ–æ¤œå‡º</li>
</ul>
</li>
<li><strong>å‘¨æ³¢æ•°é ˜åŸŸç‰¹å¾´é‡</strong>
<ul>
<li>FFTã«ã‚ˆã‚‹å‘¨æ³¢æ•°æˆåˆ†æŠ½å‡º</li>
<li>ã‚¹ãƒšã‚¯ãƒˆãƒ«é‡å¿ƒã€ã‚¨ãƒ³ãƒˆãƒ­ãƒ”ãƒ¼</li>
<li>ãƒ‘ãƒ¯ãƒ¼ã‚¹ãƒšã‚¯ãƒˆãƒ«å¯†åº¦ã¨ã‚¹ãƒšã‚¯ãƒˆãƒ­ã‚°ãƒ©ãƒ </li>
</ul>
</li>
<li><strong>ã‚¦ã‚§ãƒ¼ãƒ–ãƒ¬ãƒƒãƒˆç‰¹å¾´é‡</strong>
<ul>
<li>å¤šè§£åƒåº¦åˆ†è§£</li>
<li>éæ¸¡ç¾è±¡ã¨çªç™ºã‚¤ãƒ™ãƒ³ãƒˆã®æ¤œå‡º</li>
</ul>
</li>
<li><strong>ãƒ‰ãƒ¡ã‚¤ãƒ³çŸ¥è­˜ã«åŸºã¥ãç‰¹å¾´é‡</strong>
<ul>
<li>æ»ç•™æ™‚é–“ã€è»¢åŒ–ç‡ã€åç‡ã€é¸æŠç‡</li>
<li>ç†±åæ”¯ã€ç‰©è³ªåæ”¯æŒ‡æ¨™</li>
</ul>
</li>
<li><strong>ç›¸äº’ä½œç”¨ç‰¹å¾´ã¨å¤šé …å¼ç‰¹å¾´</strong>
<ul>
<li>å¤‰æ•°é–“ã®éç·šå½¢é–¢ä¿‚ã®ãƒ¢ãƒ‡ãƒ«åŒ–</li>
</ul>
</li>
<li><strong>ç‰¹å¾´é‡é¸æŠ</strong>
<ul>
<li>ç›¸äº’æƒ…å ±é‡ã€RFEã€LASSOã€Random Foresté‡è¦åº¦</li>
</ul>
</li>
<li><strong>è‡ªå‹•ç‰¹å¾´é‡æŠ½å‡º</strong>
<ul>
<li>tsfreshã«ã‚ˆã‚‹åŒ…æ‹¬çš„ãªç‰¹å¾´ç”Ÿæˆ</li>
</ul>
</li>
</ol>

<h3>é‡è¦ãªãƒã‚¤ãƒ³ãƒˆ</h3>

<ul>
<li>ç‰¹å¾´é‡ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ãƒªãƒ³ã‚°ã¯æ©Ÿæ¢°å­¦ç¿’ãƒ¢ãƒ‡ãƒ«ã®æ€§èƒ½ã‚’æ±ºå®šã™ã‚‹æœ€é‡è¦ã‚¹ãƒ†ãƒƒãƒ—</li>
<li>æ™‚é–“é ˜åŸŸã¨å‘¨æ³¢æ•°é ˜åŸŸã®ç‰¹å¾´ã¯ç›¸è£œçš„ãªæƒ…å ±ã‚’æä¾›ã™ã‚‹</li>
<li>ãƒ—ãƒ­ã‚»ã‚¹çŸ¥è­˜ã«åŸºã¥ãç‰¹å¾´ã¯è§£é‡ˆå¯èƒ½æ€§ãŒé«˜ãã€å®Ÿç”¨çš„</li>
<li>ç›¸äº’ä½œç”¨ç‰¹å¾´ã«ã‚ˆã‚Šã€ç·šå½¢ãƒ¢ãƒ‡ãƒ«ã§ã‚‚éç·šå½¢é–¢ä¿‚ã‚’æ‰ãˆã‚‰ã‚Œã‚‹</li>
<li>é©åˆ‡ãªç‰¹å¾´é¸æŠã«ã‚ˆã‚Šã€ãƒ¢ãƒ‡ãƒ«ã®æ±åŒ–æ€§èƒ½ã¨è¨ˆç®—åŠ¹ç‡ãŒå‘ä¸Š</li>
<li>tsfreshãªã©ã®è‡ªå‹•åŒ–ãƒ„ãƒ¼ãƒ«ã¯æ¢ç´¢çš„åˆ†æã«æœ‰ç”¨ã ãŒã€ãƒ‰ãƒ¡ã‚¤ãƒ³çŸ¥è­˜ã‚‚é‡è¦</li>
</ul>

<h3>æ¬¡ã®ç« ã¸</h3>

<p>ç¬¬5ç« ã§ã¯ã€<strong>ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ‡ãƒ¼ã‚¿è§£æã¨å¯è¦–åŒ–</strong>ã‚’å­¦ã³ã¾ã™ï¼š</p>
<ul>
<li>ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ãƒ‡ãƒ¼ã‚¿å‡¦ç†</li>
<li>ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ çµ±è¨ˆãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°</li>
<li>ã‚ªãƒ³ãƒ©ã‚¤ãƒ³æ©Ÿæ¢°å­¦ç¿’ãƒ¢ãƒ‡ãƒ«</li>
<li>ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰æ§‹ç¯‰</li>
<li>æœ¬ç•ªç’°å¢ƒã§ã®ç›£è¦–ã‚·ã‚¹ãƒ†ãƒ å®Ÿè£…</li>
</ul>

<div class="navigation">
    <a href="chapter-3.html" class="nav-button">â† å‰ã®ç« </a>
    <a href="chapter-5.html" class="nav-button">æ¬¡ã®ç«  â†’</a>
</div>

    </main>

    <section class="disclaimer">
        <h3>å…è²¬äº‹é …</h3>
        <ul>
            <li>æœ¬ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã¯æ•™è‚²ãƒ»ç ”ç©¶ãƒ»æƒ…å ±æä¾›ã®ã¿ã‚’ç›®çš„ã¨ã—ã¦ãŠã‚Šã€å°‚é–€çš„ãªåŠ©è¨€(æ³•å¾‹ãƒ»ä¼šè¨ˆãƒ»æŠ€è¡“çš„ä¿è¨¼ãªã©)ã‚’æä¾›ã™ã‚‹ã‚‚ã®ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚</li>
            <li>æœ¬ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãŠã‚ˆã³ä»˜éšã™ã‚‹ã‚³ãƒ¼ãƒ‰ä¾‹ã¯ã€Œç¾çŠ¶æœ‰å§¿(AS IS)ã€ã§æä¾›ã•ã‚Œã€æ˜ç¤ºã¾ãŸã¯é»™ç¤ºã‚’å•ã‚ãšã€å•†å“æ€§ã€ç‰¹å®šç›®çš„é©åˆæ€§ã€æ¨©åˆ©éä¾µå®³ã€æ­£ç¢ºæ€§ãƒ»å®Œå…¨æ€§ã€å‹•ä½œãƒ»å®‰å…¨æ€§ç­‰ã„ã‹ãªã‚‹ä¿è¨¼ã‚‚ã—ã¾ã›ã‚“ã€‚</li>
            <li>å¤–éƒ¨ãƒªãƒ³ã‚¯ã€ç¬¬ä¸‰è€…ãŒæä¾›ã™ã‚‹ãƒ‡ãƒ¼ã‚¿ãƒ»ãƒ„ãƒ¼ãƒ«ãƒ»ãƒ©ã‚¤ãƒ–ãƒ©ãƒªç­‰ã®å†…å®¹ãƒ»å¯ç”¨æ€§ãƒ»å®‰å…¨æ€§ã«ã¤ã„ã¦ã€ä½œæˆè€…ãŠã‚ˆã³æ±åŒ—å¤§å­¦ã¯ä¸€åˆ‡ã®è²¬ä»»ã‚’è² ã„ã¾ã›ã‚“ã€‚</li>
            <li>æœ¬ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®åˆ©ç”¨ãƒ»å®Ÿè¡Œãƒ»è§£é‡ˆã«ã‚ˆã‚Šç›´æ¥çš„ãƒ»é–“æ¥çš„ãƒ»ä»˜éšçš„ãƒ»ç‰¹åˆ¥ãƒ»çµæœçš„ãƒ»æ‡²ç½°çš„æå®³ãŒç”Ÿã˜ãŸå ´åˆã§ã‚‚ã€é©ç”¨æ³•ã§è¨±å®¹ã•ã‚Œã‚‹æœ€å¤§é™ã®ç¯„å›²ã§ã€ä½œæˆè€…ãŠã‚ˆã³æ±åŒ—å¤§å­¦ã¯è²¬ä»»ã‚’è² ã„ã¾ã›ã‚“ã€‚</li>
            <li>æœ¬ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®å†…å®¹ã¯ã€äºˆå‘Šãªãå¤‰æ›´ãƒ»æ›´æ–°ãƒ»æä¾›åœæ­¢ã•ã‚Œã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚</li>
            <li>æœ¬ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®è‘—ä½œæ¨©ãƒ»ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã¯æ˜è¨˜ã•ã‚ŒãŸæ¡ä»¶(ä¾‹: CC BY 4.0)ã«å¾“ã„ã¾ã™ã€‚å½“è©²ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã¯é€šå¸¸ã€ç„¡ä¿è¨¼æ¡é …ã‚’å«ã¿ã¾ã™ã€‚</li>
        </ul>
    </section>

    <footer>
        <p><strong>ä½œæˆè€…</strong>: PI Knowledge Hub Content Team</p>
        <p><strong>ãƒãƒ¼ã‚¸ãƒ§ãƒ³</strong>: 1.0 | <strong>ä½œæˆæ—¥</strong>: 2025-10-26</p>
        <p><strong>ãƒ©ã‚¤ã‚»ãƒ³ã‚¹</strong>: Creative Commons BY 4.0</p>
        <p>&copy; 2025 PI Terakoya. All rights reserved.</p>
    </footer>
</body>
</html>
