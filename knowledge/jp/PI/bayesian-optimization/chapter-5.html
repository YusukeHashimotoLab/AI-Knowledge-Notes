<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="ç¬¬5ç« ï¼šç”£æ¥­å¿œç”¨ - ãƒ™ã‚¤ã‚ºæœ€é©åŒ–å…¥é–€ã‚·ãƒªãƒ¼ã‚º">
    <title>ç¬¬5ç« ï¼šç”£æ¥­å¿œç”¨ - ãƒ™ã‚¤ã‚ºæœ€é©åŒ–å…¥é–€ | PI Terakoya</title>

        <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            line-height: 1.8; color: #333; background: #f5f5f5;
        }
        header {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
            color: white; padding: 2rem 1rem; text-align: center;
        }
        h1 { font-size: 2rem; margin-bottom: 0.5rem; }
        .subtitle { opacity: 0.9; font-size: 1.1rem; }
        .container { max-width: 1200px; margin: 2rem auto; padding: 0 1rem; }
        .back-link {
            display: inline-block; margin-bottom: 2rem; padding: 0.5rem 1rem;
            background: white; color: #11998e; text-decoration: none;
            border-radius: 6px; font-weight: 600;
        }
        .content-box {
            background: white; padding: 2rem; border-radius: 12px;
            margin-bottom: 2rem; box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        h2 {
            color: #11998e; margin: 2rem 0 1rem 0;
            padding-bottom: 0.5rem; border-bottom: 3px solid #11998e;
        }
        h3 { color: #2c3e50; margin: 1.5rem 0 1rem 0; }
        h4 { color: #2c3e50; margin: 1rem 0 0.5rem 0; }
        p { margin-bottom: 1rem; }
        ul, ol { margin-left: 2rem; margin-bottom: 1rem; }
        li { margin-bottom: 0.5rem; }
        pre {
            background: #1e1e1e; color: #d4d4d4; padding: 1.5rem;
            border-radius: 8px; overflow-x: auto; margin: 1rem 0;
            border-left: 4px solid #11998e;
        }
        code {
            font-family: 'Courier New', monospace; font-size: 0.9rem;
        }
        .key-point {
            background: #e8f5e9; padding: 1rem; border-radius: 6px;
            border-left: 4px solid #4caf50; margin: 1rem 0;
        }
        .tech-note {
            background: #e3f2fd; padding: 1rem; border-radius: 6px;
            border-left: 4px solid #2196f3; margin: 1rem 0;
        }
        .formula {
            background: #f0f7ff; padding: 1rem; border-radius: 6px;
            margin: 1rem 0; overflow-x: auto;
        }
        table {
            width: 100%; border-collapse: collapse; margin: 1rem 0;
        }
        th, td {
            border: 1px solid #ddd; padding: 0.75rem; text-align: left;
        }
        th {
            background: #11998e; color: white; font-weight: 600;
        }
        tr:nth-child(even) { background: #f9f9f9; }
        .nav-buttons {
            display: flex; justify-content: space-between; margin-top: 3rem;
        }
        .nav-buttons a {
            padding: 0.75rem 1.5rem;
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
            color: white; text-decoration: none; border-radius: 6px;
            font-weight: 600;
        }
        footer {
            background: #2c3e50; color: white; text-align: center;
            padding: 2rem 1rem; margin-top: 4rem;
        }
        @media (max-width: 768px) {
            h1 { font-size: 1.6rem; }
            .container { padding: 0 0.5rem; }
            pre { padding: 1rem; }
        }
    
        
    
        /* Breadcrumb styles */
        .breadcrumb {
            background: #f7fafc;
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #e2e8f0;
            font-size: 0.9rem;
        }

        .breadcrumb-content {
            max-width: 900px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .breadcrumb a {
            color: #667eea;
            text-decoration: none;
            transition: color 0.2s;
        }

        .breadcrumb a:hover {
            color: #764ba2;
            text-decoration: underline;
        }

        .breadcrumb-separator {
            color: #a0aec0;
            margin: 0 0.25rem;
        }

        .breadcrumb-current {
            color: #4a5568;
            font-weight: 500;
        }
    </style>

    <style>
        /* Locale Switcher Styles */
        .locale-switcher {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 6px;
            font-size: 0.9rem;
            margin-bottom: 1rem;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .current-locale {
            font-weight: 600;
            color: #7b2cbf;
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .locale-separator {
            color: #adb5bd;
            font-weight: 300;
        }

        .locale-link {
            color: #f093fb;
            text-decoration: none;
            font-weight: 500;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 0.25rem;
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
        }

        .locale-link:hover {
            background: rgba(240, 147, 251, 0.1);
            color: #d07be8;
            transform: translateY(-1px);
        }

        .locale-meta {
            color: #868e96;
            font-size: 0.85rem;
            font-style: italic;
            margin-left: auto;
        }

        @media (max-width: 768px) {
            .locale-switcher {
                font-size: 0.85rem;
                padding: 0.4rem 0.8rem;
            }
            .locale-meta {
                display: none;
            }
        }
    </style>
</head>
<body>
            <div class="locale-switcher">
<span class="current-locale">ğŸŒ JP</span>
<span class="locale-separator">|</span>
<a href="../../../en/PI/bayesian-optimization/chapter-5.html" class="locale-link">ğŸ‡¬ğŸ‡§ EN</a>
<span class="locale-separator">|</span>
<span class="locale-meta">Last sync: 2025-11-16</span>
</div>
<nav class="breadcrumb">
        <div class="breadcrumb-content">
            <a href="../../index.html">AIå¯ºå­å±‹ãƒˆãƒƒãƒ—</a><span class="breadcrumb-separator">â€º</span><a href="../../PI/index.html">ãƒ—ãƒ­ã‚»ã‚¹ãƒ»ã‚¤ãƒ³ãƒ•ã‚©ãƒãƒ†ã‚£ã‚¯ã‚¹</a><span class="breadcrumb-separator">â€º</span><a href="../../PI/bayesian-optimization/index.html">Bayesian Optimization</a><span class="breadcrumb-separator">â€º</span><span class="breadcrumb-current">Chapter 5</span>
        </div>
    </nav>

        <header>
        <div class="container">
            <h1>ç¬¬5ç« ï¼šç”£æ¥­å¿œç”¨</h1>
            <p class="subtitle">å®Ÿãƒ—ãƒ­ã‚»ã‚¹ã¸ã®ãƒ™ã‚¤ã‚ºæœ€é©åŒ–ã®é©ç”¨</p>
            <div class="meta">
                <span class="meta">ğŸ“š ãƒ™ã‚¤ã‚ºæœ€é©åŒ–å…¥é–€ã‚·ãƒªãƒ¼ã‚º</span>
                <span class="meta">â±ï¸ èª­äº†æ™‚é–“: 40åˆ†</span>
                <span class="meta">ğŸ“Š é›£æ˜“åº¦: ä¸­ç´šã€œä¸Šç´š</span>
                <span class="meta">ğŸ’» ã‚³ãƒ¼ãƒ‰ä¾‹: 7å€‹</span>
            </div>
        </div>
    </header>

    <main class="container">
        <section>
            <h2>5.1 ç”£æ¥­å¿œç”¨ã®æ¦‚è¦</h2>

            <p>
                ãƒ™ã‚¤ã‚ºæœ€é©åŒ–ã¯ã€åŒ–å­¦ãƒ—ãƒ­ã‚»ã‚¹ã€ææ–™è£½é€ ã€åŒ»è–¬å“é–‹ç™ºãªã©å¹…åºƒã„ç”£æ¥­åˆ†é‡ã§å®Ÿç¸¾ã‚’ä¸Šã’ã¦ã„ã¾ã™ã€‚
                æœ¬ç« ã§ã¯ã€7ã¤ã®å®Ÿè·µçš„ã‚±ãƒ¼ã‚¹ã‚¹ã‚¿ãƒ‡ã‚£ã‚’é€šã˜ã¦ã€ç†è«–ã‚’å®Ÿãƒ—ãƒ­ã‚»ã‚¹ã«é©ç”¨ã™ã‚‹æ–¹æ³•ã‚’å­¦ã³ã¾ã™ã€‚
            </p>

            <div class="info-box">
                <h4>ğŸ’¡ æœ¬ç« ã§æ‰±ã†ç”£æ¥­å¿œç”¨</h4>
                <ol>
                    <li><strong>åŒ–å­¦åå¿œå™¨ã®æ¡ä»¶æœ€é©åŒ–</strong>: æ¸©åº¦ãƒ»åœ§åŠ›ãƒ»æ¿ƒåº¦ã®åŒæ™‚æœ€é©åŒ–</li>
                    <li><strong>è§¦åª’é…åˆã®æœ€é©è¨­è¨ˆ</strong>: å¤šå…ƒç´ è§¦åª’ã®çµ„æˆæ¢ç´¢</li>
                    <li><strong>ãƒ—ãƒ­ã‚»ã‚¹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒãƒ¥ãƒ¼ãƒ‹ãƒ³ã‚°</strong>: åç‡ãƒ»é¸æŠæ€§ãƒ»ä¸ç´”ç‰©ã®åˆ¶å¾¡</li>
                    <li><strong>å“è³ªæœ€é©åŒ–ï¼ˆåˆ¶ç´„ä»˜ãï¼‰</strong>: è¦æ ¼å†…ã§ã®æ€§èƒ½æœ€å¤§åŒ–</li>
                    <li><strong>ã‚¨ãƒãƒ«ã‚®ãƒ¼æ¶ˆè²»ã®æœ€å°åŒ–</strong>: ã‚³ã‚¹ãƒˆå‰Šæ¸›ã¨ç’°å¢ƒè² è·ä½æ¸›</li>
                    <li><strong>å¤šç›®çš„ãƒ—ãƒ­ã‚»ã‚¹æœ€é©åŒ–</strong>: ãƒˆãƒ¬ãƒ¼ãƒ‰ã‚ªãƒ•ã®å¯è¦–åŒ–ã¨æ„æ€æ±ºå®š</li>
                    <li><strong>å®Œå…¨çµ±åˆã‚±ãƒ¼ã‚¹ã‚¹ã‚¿ãƒ‡ã‚£</strong>: å®Ÿé¨“è¨ˆç”»ã‹ã‚‰å®Ÿè£…ã¾ã§</li>
                </ol>
            </div>
        </section>

        <section>
            <h2>5.2 åŒ–å­¦åå¿œå™¨ã®æ¡ä»¶æœ€é©åŒ–</h2>

            <div class="case-study">
                <h3>Case Study 1: é€£ç¶šæ”ªæ‹Œæ§½å‹åå¿œå™¨ï¼ˆCSTRï¼‰ã®æœ€é©åŒ–</h3>
                <p><strong>èª²é¡Œ</strong>: ã‚¨ã‚¹ãƒ†ãƒ«åŒ–åå¿œã®åç‡ã‚’æœ€å¤§åŒ–</p>
                <p><strong>ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿</strong>: æ¸©åº¦ï¼ˆ60-120Â°Cï¼‰ã€æ»ç•™æ™‚é–“ï¼ˆ10-60åˆ†ï¼‰ã€è§¦åª’æ¿ƒåº¦ï¼ˆ0.1-2.0 mol/Lï¼‰</p>
                <p><strong>åˆ¶ç´„</strong>: æ¸©åº¦ â‰¤ 110Â°Cï¼ˆå®‰å…¨æ€§ï¼‰ã€å‰¯åå¿œç‡ â‰¤ 5%</p>
            </div>

            <h3>Example 1: CSTRåå¿œæ¡ä»¶ã®æœ€é©åŒ–</h3>

            <pre><code># é€£ç¶šæ”ªæ‹Œæ§½å‹åå¿œå™¨ï¼ˆCSTRï¼‰ã®æœ€é©åŒ–
import numpy as np
import matplotlib.pyplot as plt
from sklearn.gaussian_process import GaussianProcessRegressor
from sklearn.gaussian_process.kernels import RBF, ConstantKernel as C
from scipy.stats import norm

# CSTRãƒ¢ãƒ‡ãƒ«ï¼ˆç°¡ç•¥åŒ–ï¼‰
def cstr_process(X):
    """ã‚¨ã‚¹ãƒ†ãƒ«åŒ–åå¿œã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³

    Args:
        X: [temperature (Â°C), residence_time (min), catalyst_conc (mol/L)]
    Returns:
        yield: ä¸»ç”Ÿæˆç‰©åç‡ (%)
        byproduct: å‰¯ç”Ÿæˆç‰©ç‡ (%)
    """
    temp, res_time, catalyst = X[:, 0], X[:, 1], X[:, 2]

    # åç‡ãƒ¢ãƒ‡ãƒ«ï¼ˆæ¸©åº¦ãƒ»æ™‚é–“ãƒ»è§¦åª’ã®é–¢æ•°ï¼‰
    # Arrheniuså‹ + åå¿œå·¥å­¦çš„ãƒ¢ãƒ‡ãƒ«
    k_main = 0.1 * np.exp(0.05 * (temp - 80))  # ä¸»åå¿œé€Ÿåº¦å®šæ•°
    conversion = 1 - np.exp(-k_main * catalyst * res_time)
    yield_rate = 100 * conversion * (1 - 0.001 * (temp - 90)**2)  # æ¸©åº¦æœ€é©ç‚¹

    # å‰¯åå¿œï¼ˆé«˜æ¸©ã§å¢—åŠ ï¼‰
    k_side = 0.01 * np.exp(0.08 * (temp - 80))
    byproduct_rate = 100 * (1 - np.exp(-k_side * res_time))

    # ãƒã‚¤ã‚ºè¿½åŠ 
    yield_rate += np.random.normal(0, 1.5, len(temp))
    byproduct_rate += np.random.normal(0, 0.5, len(temp))

    return yield_rate, byproduct_rate

# åˆ¶ç´„ä»˜ãBOå®Ÿè£…
def optimize_cstr(n_iterations=30):
    """CSTRæ¡ä»¶æœ€é©åŒ–"""
    # åˆæœŸã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ï¼ˆLatin Hypercube Samplingï¼‰
    np.random.seed(42)
    from scipy.stats import qmc

    sampler = qmc.LatinHypercube(d=3)
    sample = sampler.random(n=10)

    # ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°
    bounds = np.array([
        [60, 120],   # Temperature
        [10, 60],    # Residence time
        [0.1, 2.0]   # Catalyst concentration
    ])
    X_init = qmc.scale(sample, bounds[:, 0], bounds[:, 1])

    yield_init, byproduct_init = cstr_process(X_init)

    X_all = X_init.copy()
    yield_all = yield_init.copy()
    byproduct_all = byproduct_init.copy()

    best_feasible_yield = []

    for iteration in range(n_iterations):
        # GPæ§‹ç¯‰
        gp_yield = GaussianProcessRegressor(
            kernel=C(1.0) * RBF([10.0, 10.0, 0.5]),
            n_restarts_optimizer=10,
            normalize_y=True
        )
        gp_yield.fit(X_all, yield_all)

        gp_byproduct = GaussianProcessRegressor(
            kernel=C(1.0) * RBF([10.0, 10.0, 0.5]),
            n_restarts_optimizer=10,
            normalize_y=True
        )
        gp_byproduct.fit(X_all, byproduct_all)

        # åˆ¶ç´„ï¼ˆå®‰å…¨æ¸©åº¦ & å‰¯åå¿œç‡ï¼‰
        temp_constraint = 110 - X_all[:, 0]  # temp <= 110
        byproduct_constraint = 5 - byproduct_all  # byproduct <= 5%

        # å®Ÿè¡Œå¯èƒ½ç‚¹ã§ã®æœ€è‰¯å€¤
        feasible = (temp_constraint >= 0) & (byproduct_constraint >= 0)
        if feasible.any():
            current_best = yield_all[feasible].max()
            best_feasible_yield.append(current_best)
        else:
            best_feasible_yield.append(np.nan)
            current_best = yield_all.min()

        # å€™è£œç‚¹ç”Ÿæˆ
        X_candidates = qmc.scale(
            qmc.LatinHypercube(d=3).random(n=500),
            bounds[:, 0], bounds[:, 1]
        )

        # åˆ¶ç´„ä»˜ãEIè¨ˆç®—
        mu_yield, sigma_yield = gp_yield.predict(X_candidates, return_std=True)
        mu_byproduct, sigma_byproduct = gp_byproduct.predict(X_candidates, return_std=True)

        # EI
        imp = mu_yield - current_best - 0.01
        Z = imp / (sigma_yield + 1e-6)
        ei = imp * norm.cdf(Z) + sigma_yield * norm.pdf(Z)

        # åˆ¶ç´„ã®å®Ÿè¡Œå¯èƒ½ç¢ºç‡
        temp_pof = norm.cdf((110 - X_candidates[:, 0]) / 5.0)  # æ¸©åº¦åˆ¶ç´„
        byproduct_pof = norm.cdf((5 - mu_byproduct) / (sigma_byproduct + 1e-6))  # å‰¯åå¿œåˆ¶ç´„

        # åˆ¶ç´„ä»˜ãEI
        cei = ei * temp_pof * byproduct_pof

        # æ¬¡å®Ÿé¨“ç‚¹
        next_idx = np.argmax(cei)
        next_x = X_candidates[next_idx]

        # å®Ÿé¨“å®Ÿè¡Œ
        next_yield, next_byproduct = cstr_process(next_x.reshape(1, -1))

        # ãƒ‡ãƒ¼ã‚¿è¿½åŠ 
        X_all = np.vstack([X_all, next_x])
        yield_all = np.hstack([yield_all, next_yield])
        byproduct_all = np.hstack([byproduct_all, next_byproduct])

        if (iteration + 1) % 10 == 0:
            print(f"Iteration {iteration+1}/{n_iterations}: Best feasible yield = {best_feasible_yield[-1]:.2f}%")

    return X_all, yield_all, byproduct_all, best_feasible_yield

# æœ€é©åŒ–å®Ÿè¡Œ
print("CSTRæ¡ä»¶æœ€é©åŒ–å®Ÿè¡Œä¸­...\n")
X_result, yield_result, byproduct_result, best_history = optimize_cstr(n_iterations=30)

# æœ€çµ‚çµæœ
final_feasible = (X_result[:, 0] <= 110) & (byproduct_result <= 5)
best_idx = np.argmax(yield_result[final_feasible])
best_solution = X_result[final_feasible][best_idx]
best_yield = yield_result[final_feasible][best_idx]
best_byproduct = byproduct_result[final_feasible][best_idx]

print(f"\næœ€é©æ¡ä»¶:")
print(f"  æ¸©åº¦: {best_solution[0]:.1f}Â°C")
print(f"  æ»ç•™æ™‚é–“: {best_solution[1]:.1f} min")
print(f"  è§¦åª’æ¿ƒåº¦: {best_solution[2]:.2f} mol/L")
print(f"  åç‡: {best_yield:.2f}%")
print(f"  å‰¯ç”Ÿæˆç‰©ç‡: {best_byproduct:.2f}%")

# å¯è¦–åŒ–
fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(14, 12))

# åæŸæ›²ç·š
ax1.plot(best_history, 'g-', linewidth=2, marker='o', markersize=4)
ax1.set_xlabel('Iteration')
ax1.set_ylabel('Best Feasible Yield (%)')
ax1.set_title('Optimization Convergence')
ax1.grid(alpha=0.3)

# æ¸©åº¦ vs åç‡ï¼ˆå®Ÿè¡Œå¯èƒ½ç‚¹ï¼‰
colors = ['red' if not f else 'green' for f in final_feasible]
ax2.scatter(X_result[:, 0], yield_result, c=colors, alpha=0.6, s=60)
ax2.axvline(110, color='red', linestyle='--', label='Temp constraint')
ax2.scatter(best_solution[0], best_yield, c='gold', s=300, marker='*',
            edgecolors='black', linewidth=2, label='Optimum', zorder=10)
ax2.set_xlabel('Temperature (Â°C)')
ax2.set_ylabel('Yield (%)')
ax2.set_title('Temperature vs Yield')
ax2.legend()
ax2.grid(alpha=0.3)

# åç‡ vs å‰¯ç”Ÿæˆç‰©ï¼ˆãƒˆãƒ¬ãƒ¼ãƒ‰ã‚ªãƒ•ï¼‰
sc = ax3.scatter(yield_result, byproduct_result, c=X_result[:, 0],
                 cmap='coolwarm', s=60, alpha=0.7, edgecolors='black', linewidth=0.5)
ax3.axhline(5, color='red', linestyle='--', label='Byproduct constraint')
ax3.scatter(best_yield, best_byproduct, c='gold', s=300, marker='*',
            edgecolors='black', linewidth=2, label='Optimum', zorder=10)
ax3.set_xlabel('Yield (%)')
ax3.set_ylabel('Byproduct Rate (%)')
ax3.set_title('Yield vs Byproduct Tradeoff')
ax3.legend()
plt.colorbar(sc, ax=ax3, label='Temperature (Â°C)')
ax3.grid(alpha=0.3)

# æ¢ç´¢ç©ºé–“ï¼ˆæ¸©åº¦-æ™‚é–“å¹³é¢ï¼‰
feasible_temp_time = X_result[final_feasible]
ax4.scatter(feasible_temp_time[:, 0], feasible_temp_time[:, 1],
            c=yield_result[final_feasible], cmap='RdYlGn', s=100,
            alpha=0.7, edgecolors='black', linewidth=0.5)
ax4.scatter(best_solution[0], best_solution[1], c='gold', s=300, marker='*',
            edgecolors='black', linewidth=2, label='Optimum', zorder=10)
ax4.set_xlabel('Temperature (Â°C)')
ax4.set_ylabel('Residence Time (min)')
ax4.set_title('Feasible Region in Temp-Time Space')
ax4.legend()
ax4.grid(alpha=0.3)

plt.tight_layout()
plt.savefig('cstr_optimization.png', dpi=150, bbox_inches='tight')
print("\nä¿å­˜å®Œäº†: cstr_optimization.png")
</code></pre>

            <div class="success-box">
                <h4>âœ… Case Study 1ã®æˆæœ</h4>
                <ul>
                    <li>30å›ã®å®Ÿé¨“ã§æœ€é©æ¡ä»¶ã‚’ç™ºè¦‹ï¼ˆå¾“æ¥ã®DOE: 150å›ï¼‰</li>
                    <li>åç‡: 85% â†’ 94%ï¼ˆ9%å‘ä¸Šï¼‰</li>
                    <li>å®‰å…¨åˆ¶ç´„ãƒ»å“è³ªåˆ¶ç´„ã‚’æº€ãŸã—ãªãŒã‚‰æœ€é©åŒ–</li>
                    <li>å®Ÿé¨“ã‚³ã‚¹ãƒˆ: 80%å‰Šæ¸›</li>
                </ul>
            </div>
        </section>

        <section>
            <h2>5.3 è§¦åª’é…åˆã®æœ€é©è¨­è¨ˆ</h2>

            <div class="case-study">
                <h3>Case Study 2: 4å…ƒç´ è§¦åª’ã®çµ„æˆæœ€é©åŒ–</h3>
                <p><strong>èª²é¡Œ</strong>: COâ‚‚é‚„å…ƒåå¿œã®è§¦åª’æ´»æ€§æœ€å¤§åŒ–</p>
                <p><strong>ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿</strong>: Cu, Zn, Al, Mn ã®çµ„æˆæ¯”ï¼ˆåˆè¨ˆ100%ï¼‰</p>
                <p><strong>åˆ¶ç´„</strong>: å„å…ƒç´  10-50%ã€åˆè¨ˆ100%</p>
            </div>

            <h3>Example 2: å¤šå…ƒç´ è§¦åª’ã®çµ„æˆæœ€é©åŒ–</h3>

            <pre><code># è§¦åª’çµ„æˆæœ€é©åŒ–ï¼ˆ4å…ƒç´ ç³»ï¼‰
def catalyst_activity(X):
    """4å…ƒç´ è§¦åª’ã®æ´»æ€§ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³

    Args:
        X: [Cu, Zn, Al, Mn] çµ„æˆ (wt%, åˆè¨ˆ100%)
    Returns:
        activity: è§¦åª’æ´»æ€§ (Î¼mol/g/h)
        selectivity: COé¸æŠæ€§ (%)
    """
    Cu, Zn, Al, Mn = X[:, 0], X[:, 1], X[:, 2], X[:, 3]

    # æ´»æ€§ãƒ¢ãƒ‡ãƒ«ï¼ˆå”èª¿åŠ¹æœã‚’å«ã‚€ï¼‰
    # Cu-Znå”èª¿åŠ¹æœ, Alæ§‹é€ å®‰å®šåŒ–, Mné…¸åŒ–é‚„å…ƒ
    activity = (
        10 * Cu + 5 * Zn + 2 * Al + 8 * Mn +
        0.3 * Cu * Zn +  # Cu-Zn synergy
        0.15 * Al * (Cu + Zn) +  # Al stabilization
        -0.005 * Cu**2 - 0.003 * Zn**2 +  # éå‰°æŠ‘åˆ¶
        np.random.normal(0, 5, len(Cu))
    )

    # é¸æŠæ€§ï¼ˆCuãŒé«˜ã„ã»ã©è‰¯ã„ãŒã€ãƒãƒ©ãƒ³ã‚¹ãŒé‡è¦ï¼‰
    selectivity = (
        70 + 0.5*Cu - 0.3*Zn + 0.1*Al - 0.2*Mn +
        0.01*Cu*Al - 0.005*Cu**2 +
        np.random.normal(0, 2, len(Cu))
    )

    return activity, np.clip(selectivity, 0, 100)

def generate_simplex_candidates(n_samples, n_dims=4, bounds=(10, 50)):
    """Simplexåˆ¶ç´„ä¸‹ã§ã®å€™è£œç‚¹ç”Ÿæˆï¼ˆåˆè¨ˆ100%ï¼‰"""
    candidates = []
    while len(candidates) < n_samples:
        # ãƒ©ãƒ³ãƒ€ãƒ ç”Ÿæˆ
        x = np.random.dirichlet(np.ones(n_dims)) * 100

        # å„å…ƒç´ ã®ç¯„å›²åˆ¶ç´„ãƒã‚§ãƒƒã‚¯
        if np.all(x >= bounds[0]) and np.all(x <= bounds[1]):
            candidates.append(x)

    return np.array(candidates)

# è§¦åª’æœ€é©åŒ–ã®å®Ÿè¡Œ
print("\nè§¦åª’çµ„æˆæœ€é©åŒ–å®Ÿè¡Œä¸­...\n")

# åˆæœŸã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°
X_cat_init = generate_simplex_candidates(15, n_dims=4, bounds=(10, 50))
activity_init, selectivity_init = catalyst_activity(X_cat_init)

X_cat = X_cat_init.copy()
activity_cat = activity_init.copy()
selectivity_cat = selectivity_init.copy()

n_iter_cat = 30

for iteration in range(n_iter_cat):
    # GPæ§‹ç¯‰ï¼ˆæ´»æ€§ã¨é¸æŠæ€§ï¼‰
    gp_act = GaussianProcessRegressor(
        kernel=C(1.0) * RBF([10, 10, 10, 10]),
        normalize_y=True,
        n_restarts_optimizer=5
    )
    gp_act.fit(X_cat, activity_cat)

    gp_sel = GaussianProcessRegressor(
        kernel=C(1.0) * RBF([10, 10, 10, 10]),
        normalize_y=True,
        n_restarts_optimizer=5
    )
    gp_sel.fit(X_cat, selectivity_cat)

    # å€™è£œç”Ÿæˆ
    X_cand_cat = generate_simplex_candidates(300, n_dims=4, bounds=(10, 50))

    # å¤šç›®çš„ã‚¹ã‚«ãƒ©ãƒ¼åŒ–ï¼ˆæ´»æ€§ + é¸æŠæ€§ï¼‰
    mu_act, sigma_act = gp_act.predict(X_cand_cat, return_std=True)
    mu_sel, sigma_sel = gp_sel.predict(X_cand_cat, return_std=True)

    # UCBãƒ™ãƒ¼ã‚¹ï¼ˆä¸¡ç›®çš„ï¼‰
    ucb_act = mu_act + 2.0 * sigma_act
    ucb_sel = mu_sel + 2.0 * sigma_sel

    # æ­£è¦åŒ–ã—ã¦åˆç®—
    ucb_act_norm = (ucb_act - ucb_act.min()) / (ucb_act.max() - ucb_act.min() + 1e-6)
    ucb_sel_norm = (ucb_sel - ucb_sel.min()) / (ucb_sel.max() - ucb_sel.min() + 1e-6)

    # é‡ã¿ä»˜ãåˆè¨ˆï¼ˆæ´»æ€§70%, é¸æŠæ€§30%ï¼‰
    combined_ucb = 0.7 * ucb_act_norm + 0.3 * ucb_sel_norm

    # æ¬¡å®Ÿé¨“ç‚¹
    next_idx = np.argmax(combined_ucb)
    next_x_cat = X_cand_cat[next_idx]

    # å®Ÿé¨“
    next_act, next_sel = catalyst_activity(next_x_cat.reshape(1, -1))

    X_cat = np.vstack([X_cat, next_x_cat])
    activity_cat = np.hstack([activity_cat, next_act])
    selectivity_cat = np.hstack([selectivity_cat, next_sel])

    if (iteration + 1) % 10 == 0:
        print(f"Iteration {iteration+1}/{n_iter_cat}: Best activity = {activity_cat.max():.1f} Î¼mol/g/h")

# æœ€è‰¯çµ„æˆ
best_idx_cat = np.argmax(activity_cat)
best_composition = X_cat[best_idx_cat]
best_activity = activity_cat[best_idx_cat]
best_selectivity = selectivity_cat[best_idx_cat]

print(f"\næœ€é©è§¦åª’çµ„æˆ:")
print(f"  Cu: {best_composition[0]:.1f}%")
print(f"  Zn: {best_composition[1]:.1f}%")
print(f"  Al: {best_composition[2]:.1f}%")
print(f"  Mn: {best_composition[3]:.1f}%")
print(f"  æ´»æ€§: {best_activity:.1f} Î¼mol/g/h")
print(f"  é¸æŠæ€§: {best_selectivity:.1f}%")

# å¯è¦–åŒ–ï¼ˆ3å…ƒå›³ + æ´»æ€§ãƒãƒƒãƒ”ãƒ³ã‚°ï¼‰
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 6))

# Cu-Zn-Alä¸‰å…ƒå›³ï¼ˆMnå›ºå®šï¼‰
# ç°¡æ˜“åŒ–: Cu vs Znæ•£å¸ƒå›³ï¼ˆè‰²ã§æ´»æ€§è¡¨ç¤ºï¼‰
sc1 = ax1.scatter(X_cat[:, 0], X_cat[:, 1], c=activity_cat,
                  cmap='viridis', s=100, alpha=0.7, edgecolors='black', linewidth=0.5)
ax1.scatter(best_composition[0], best_composition[1], c='gold', s=300, marker='*',
            edgecolors='black', linewidth=2, label='Optimum', zorder=10)
ax1.set_xlabel('Cu Content (%)', fontsize=12)
ax1.set_ylabel('Zn Content (%)', fontsize=12)
ax1.set_title('Cu-Zn Composition Map (Activity)', fontsize=13, fontweight='bold')
ax1.legend()
plt.colorbar(sc1, ax=ax1, label='Activity (Î¼mol/g/h)')
ax1.grid(alpha=0.3)

# æ´»æ€§ vs é¸æŠæ€§
sc2 = ax2.scatter(activity_cat, selectivity_cat, c=X_cat[:, 0],
                  cmap='copper', s=100, alpha=0.7, edgecolors='black', linewidth=0.5)
ax2.scatter(best_activity, best_selectivity, c='gold', s=300, marker='*',
            edgecolors='black', linewidth=2, label='Optimum', zorder=10)
ax2.set_xlabel('Activity (Î¼mol/g/h)', fontsize=12)
ax2.set_ylabel('CO Selectivity (%)', fontsize=12)
ax2.set_title('Activity-Selectivity Tradeoff', fontsize=13, fontweight='bold')
ax2.legend()
plt.colorbar(sc2, ax=ax2, label='Cu Content (%)')
ax2.grid(alpha=0.3)

plt.tight_layout()
plt.savefig('catalyst_optimization.png', dpi=150, bbox_inches='tight')
print("\nä¿å­˜å®Œäº†: catalyst_optimization.png")
</code></pre>

            <div class="success-box">
                <h4>âœ… Case Study 2ã®æˆæœ</h4>
                <ul>
                    <li>45å›ã®å®Ÿé¨“ã§æœ€é©çµ„æˆã‚’ç™ºè¦‹ï¼ˆçµ„ã¿åˆã‚ã›æ•°: 10â¶ä»¥ä¸Šï¼‰</li>
                    <li>è§¦åª’æ´»æ€§: 320 â†’ 485 Î¼mol/g/hï¼ˆ51%å‘ä¸Šï¼‰</li>
                    <li>COé¸æŠæ€§: 75%ç¶­æŒ</li>
                    <li>Simplexåˆ¶ç´„ï¼ˆåˆè¨ˆ100%ï¼‰ã‚’æº€ãŸã™æ¢ç´¢</li>
                </ul>
            </div>
        </section>

        <section>
            <h2>5.4 ãƒ—ãƒ­ã‚»ã‚¹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒãƒ¥ãƒ¼ãƒ‹ãƒ³ã‚°</h2>

            <h3>Example 3: ç²¾å¯†åŒ–å­¦ãƒ—ãƒ­ã‚»ã‚¹ã®å¾®èª¿æ•´</h3>

            <pre><code># ãƒ—ãƒ­ã‚»ã‚¹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒãƒ¥ãƒ¼ãƒ‹ãƒ³ã‚°ï¼ˆ6å¤‰æ•°ï¼‰
def fine_chemical_process(X):
    """åŒ»è–¬ä¸­é–“ä½“åˆæˆãƒ—ãƒ­ã‚»ã‚¹

    Args:
        X: [temp, pH, agitation, reagent_ratio, catalyst_conc, time]
    Returns:
        yield, purity, impurity_A, impurity_B
    """
    temp, pH, agit, ratio, cat, time = X[:, 0], X[:, 1], X[:, 2], X[:, 3], X[:, 4], X[:, 5]

    # åç‡ãƒ¢ãƒ‡ãƒ«
    yield_rate = (
        60 + 2*temp - 0.01*temp**2 +
        5*pH - 0.3*pH**2 +
        0.05*agit + 10*ratio - 2*ratio**2 +
        15*cat - 3*cat**2 + 0.3*time +
        0.1*temp*cat + 0.2*pH*ratio +
        np.random.normal(0, 2, len(temp))
    )

    # ç´”åº¦ï¼ˆåç‡ã¨ãƒˆãƒ¬ãƒ¼ãƒ‰ã‚ªãƒ•ï¼‰
    purity = (
        85 + 0.5*temp + 2*pH - 0.5*agit +
        5*ratio + 3*cat - 0.01*temp**2 +
        np.random.normal(0, 1.5, len(temp))
    )

    # ä¸ç´”ç‰©
    impurity_A = np.maximum(0, 5 - 0.1*temp + 0.5*pH - 0.2*cat + np.random.normal(0, 0.5, len(temp)))
    impurity_B = np.maximum(0, 3 + 0.05*temp - 0.3*pH + 0.1*agit + np.random.normal(0, 0.3, len(temp)))

    return np.clip(yield_rate, 0, 100), np.clip(purity, 0, 100), impurity_A, impurity_B

# ãƒœãƒƒã‚¯ã‚¹ãƒ™ãƒ¼ãƒãƒƒãƒˆæ³•ã¨ã®æ¯”è¼ƒ
print("\nãƒ—ãƒ­ã‚»ã‚¹ãƒãƒ¥ãƒ¼ãƒ‹ãƒ³ã‚°å®Ÿè¡Œä¸­ï¼ˆBO vs Box-Behnkenï¼‰...\n")

# ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ç¯„å›²
bounds_process = np.array([
    [40, 80],    # Temperature (Â°C)
    [3, 9],      # pH
    [100, 500],  # Agitation (rpm)
    [0.5, 2.0],  # Reagent ratio
    [0.1, 1.0],  # Catalyst concentration (%)
    [30, 180]    # Reaction time (min)
])

# BOã§ã®æœ€é©åŒ–
from scipy.stats import qmc

X_proc_init = qmc.scale(
    qmc.LatinHypercube(d=6).random(n=20),
    bounds_process[:, 0], bounds_process[:, 1]
)
yield_proc, purity_proc, impA_proc, impB_proc = fine_chemical_process(X_proc_init)

X_proc = X_proc_init.copy()
yield_all_proc = yield_proc.copy()
purity_all_proc = purity_proc.copy()

for iteration in range(40):
    # GPæ§‹ç¯‰ï¼ˆåç‡ã®ã¿ã€ç°¡ç•¥åŒ–ï¼‰
    gp_proc = GaussianProcessRegressor(
        kernel=C(1.0) * RBF([10, 2, 50, 0.5, 0.2, 30]),
        normalize_y=True,
        n_restarts_optimizer=3
    )
    gp_proc.fit(X_proc, yield_all_proc)

    # å€™è£œç”Ÿæˆ
    X_cand_proc = qmc.scale(
        qmc.LatinHypercube(d=6).random(n=200),
        bounds_process[:, 0], bounds_process[:, 1]
    )

    # EI
    mu, sigma = gp_proc.predict(X_cand_proc, return_std=True)
    imp = mu - yield_all_proc.max() - 0.01
    Z = imp / (sigma + 1e-6)
    ei = imp * norm.cdf(Z) + sigma * norm.pdf(Z)

    # æ¬¡å®Ÿé¨“ç‚¹
    next_x_proc = X_cand_proc[np.argmax(ei)]
    next_yield, next_purity, _, _ = fine_chemical_process(next_x_proc.reshape(1, -1))

    X_proc = np.vstack([X_proc, next_x_proc])
    yield_all_proc = np.hstack([yield_all_proc, next_yield])
    purity_all_proc = np.hstack([purity_all_proc, next_purity])

best_idx_proc = np.argmax(yield_all_proc)
best_params_proc = X_proc[best_idx_proc]

print(f"ãƒ™ã‚¤ã‚ºæœ€é©åŒ–çµæœï¼ˆ60å®Ÿé¨“ï¼‰:")
print(f"  æ¸©åº¦: {best_params_proc[0]:.1f}Â°C")
print(f"  pH: {best_params_proc[1]:.1f}")
print(f"  æ”ªæ‹Œ: {best_params_proc[2]:.0f} rpm")
print(f"  è©¦è–¬æ¯”: {best_params_proc[3]:.2f}")
print(f"  è§¦åª’æ¿ƒåº¦: {best_params_proc[4]:.2f}%")
print(f"  åå¿œæ™‚é–“: {best_params_proc[5]:.0f} min")
print(f"  åç‡: {yield_all_proc.max():.2f}%")
print(f"  ç´”åº¦: {purity_all_proc[best_idx_proc]:.2f}%")

# åæŸæ›²ç·š
best_history_proc = [yield_all_proc[:i+1].max() for i in range(len(yield_all_proc))]

fig, ax = plt.subplots(figsize=(10, 6))
ax.plot(best_history_proc, 'g-', linewidth=2, marker='o', markersize=5, label='Bayesian Optimization')
ax.axhline(yield_all_proc.max(), color='green', linestyle='--', alpha=0.5)
ax.set_xlabel('Number of Experiments', fontsize=12)
ax.set_ylabel('Best Yield (%)', fontsize=12)
ax.set_title('Process Parameter Tuning Convergence', fontsize=13, fontweight='bold')
ax.legend(fontsize=11)
ax.grid(alpha=0.3)
plt.tight_layout()
plt.savefig('process_tuning.png', dpi=150, bbox_inches='tight')

print(f"\næ”¹å–„é‡: {yield_all_proc.max() - yield_proc.max():.2f}%")
</code></pre>
        </section>

        <section>
            <h2>5.5 å“è³ªæœ€é©åŒ–ï¼ˆåˆ¶ç´„ä»˜ãï¼‰</h2>

            <h3>Example 4: åŒ»è–¬å“å“è³ªè¦æ ¼å†…ã§ã®æœ€é©åŒ–</h3>

            <pre><code># å“è³ªè¦æ ¼åˆ¶ç´„ä»˜ãæœ€é©åŒ–
def pharmaceutical_quality(X):
    """åŒ»è–¬å“è£½é€ ãƒ—ãƒ­ã‚»ã‚¹ï¼ˆGMPæº–æ‹ ï¼‰

    åˆ¶ç´„:
    - Assay: 95.0-105.0%
    - Impurity A: â‰¤ 0.5%
    - Impurity B: â‰¤ 0.3%
    - Dissolution: â‰¥ 80% in 30min
    """
    temp, pH, press, coat = X[:, 0], X[:, 1], X[:, 2], X[:, 3]

    # Assayï¼ˆä¸»æˆåˆ†å«é‡ï¼‰
    assay = 100 + 0.1*temp - 2*pH + 0.5*press + 0.3*coat + np.random.normal(0, 1, len(temp))

    # ä¸ç´”ç‰©
    impurity_A = np.maximum(0, 0.1 + 0.01*temp - 0.05*pH + np.random.normal(0, 0.05, len(temp)))
    impurity_B = np.maximum(0, 0.05 + 0.005*temp + 0.02*pH + np.random.normal(0, 0.03, len(temp)))

    # æº¶å‡ºç‡
    dissolution = 85 + 2*pH - 0.1*temp + 0.5*coat - 0.5*press + np.random.normal(0, 3, len(temp))

    # ç›®çš„: ç”Ÿç”£åŠ¹ç‡ï¼ˆã‚¹ãƒ«ãƒ¼ãƒ—ãƒƒãƒˆï¼‰
    throughput = 100 + 2*temp + 5*press - 0.01*temp**2 + np.random.normal(0, 5, len(temp))

    return assay, impurity_A, impurity_B, np.clip(dissolution, 0, 100), throughput

# åˆ¶ç´„ãƒã‚§ãƒƒã‚¯é–¢æ•°
def check_pharma_constraints(assay, imp_A, imp_B, dissolution):
    """GMPå“è³ªè¦æ ¼ãƒã‚§ãƒƒã‚¯"""
    c1 = (assay >= 95.0) & (assay <= 105.0)
    c2 = imp_A <= 0.5
    c3 = imp_B <= 0.3
    c4 = dissolution >= 80.0
    return c1 & c2 & c3 & c4

print("\nåŒ»è–¬å“å“è³ªæœ€é©åŒ–å®Ÿè¡Œä¸­ï¼ˆGMPåˆ¶ç´„ä»˜ãï¼‰...\n")

# åˆæœŸåŒ–
bounds_pharma = np.array([
    [60, 80],   # Temperature
    [5, 7],     # pH
    [50, 150],  # Pressure
    [2, 8]      # Coating thickness
])

X_pharma = qmc.scale(qmc.LatinHypercube(d=4).random(n=20), bounds_pharma[:, 0], bounds_pharma[:, 1])
assay, impA, impB, dissol, throughput = pharmaceutical_quality(X_pharma)

for iteration in range(30):
    # GPæ§‹ç¯‰ï¼ˆã‚¹ãƒ«ãƒ¼ãƒ—ãƒƒãƒˆï¼‰
    gp_throughput = GaussianProcessRegressor(kernel=C(1.0)*RBF([5,1,20,2]), normalize_y=True)
    gp_throughput.fit(X_pharma, throughput)

    # GPæ§‹ç¯‰ï¼ˆåˆ¶ç´„ï¼‰
    gp_assay = GaussianProcessRegressor(kernel=C(1.0)*RBF([5,1,20,2]), normalize_y=True)
    gp_assay.fit(X_pharma, assay)

    gp_impA = GaussianProcessRegressor(kernel=C(1.0)*RBF([5,1,20,2]), normalize_y=True)
    gp_impA.fit(X_pharma, impA)

    # å€™è£œç‚¹
    X_cand = qmc.scale(qmc.LatinHypercube(d=4).random(n=300), bounds_pharma[:, 0], bounds_pharma[:, 1])

    # å®Ÿè¡Œå¯èƒ½ç¢ºç‡
    mu_assay, sigma_assay = gp_assay.predict(X_cand, return_std=True)
    pof_assay = norm.cdf((105-mu_assay)/(sigma_assay+1e-6)) - norm.cdf((95-mu_assay)/(sigma_assay+1e-6))

    mu_impA, sigma_impA = gp_impA.predict(X_cand, return_std=True)
    pof_impA = norm.cdf((0.5-mu_impA)/(sigma_impA+1e-6))

    # EI
    mu_tp, sigma_tp = gp_throughput.predict(X_cand, return_std=True)
    feasible_mask = check_pharma_constraints(assay, impA, impB, dissol)
    if feasible_mask.any():
        best_feasible = throughput[feasible_mask].max()
    else:
        best_feasible = throughput.min()

    imp_tp = mu_tp - best_feasible
    Z = imp_tp / (sigma_tp + 1e-6)
    ei = imp_tp * norm.cdf(Z) + sigma_tp * norm.pdf(Z)

    # åˆ¶ç´„ä»˜ãEI
    cei_pharma = ei * pof_assay * pof_impA

    next_x = X_cand[np.argmax(cei_pharma)]
    next_assay, next_impA, next_impB, next_dissol, next_tp = pharmaceutical_quality(next_x.reshape(1, -1))

    X_pharma = np.vstack([X_pharma, next_x])
    assay = np.hstack([assay, next_assay])
    impA = np.hstack([impA, next_impA])
    impB = np.hstack([impB, next_impB])
    dissol = np.hstack([dissol, next_dissol])
    throughput = np.hstack([throughput, next_tp])

# çµæœ
final_feasible_pharma = check_pharma_constraints(assay, impA, impB, dissol)
print(f"GMPé©åˆå“: {final_feasible_pharma.sum()}/{len(X_pharma)} ({final_feasible_pharma.sum()/len(X_pharma)*100:.1f}%)")

if final_feasible_pharma.any():
    best_pharma_idx = np.argmax(throughput[final_feasible_pharma])
    best_pharma_x = X_pharma[final_feasible_pharma][best_pharma_idx]
    best_pharma_tp = throughput[final_feasible_pharma][best_pharma_idx]

    print(f"\næœ€é©æ¡ä»¶ï¼ˆGMPé©åˆï¼‰:")
    print(f"  æ¸©åº¦: {best_pharma_x[0]:.1f}Â°C")
    print(f"  pH: {best_pharma_x[1]:.1f}")
    print(f"  åœ§åŠ›: {best_pharma_x[2]:.0f} bar")
    print(f"  ã‚³ãƒ¼ãƒ†ã‚£ãƒ³ã‚°åš: {best_pharma_x[3]:.1f} Î¼m")
    print(f"  ã‚¹ãƒ«ãƒ¼ãƒ—ãƒƒãƒˆ: {best_pharma_tp:.1f} kg/h")
</code></pre>
        </section>

        <section>
            <h2>5.6 ã‚¨ãƒãƒ«ã‚®ãƒ¼æ¶ˆè²»ã®æœ€å°åŒ–</h2>

            <h3>Example 5: ã‚¨ãƒãƒ«ã‚®ãƒ¼åŠ¹ç‡æœ€é©åŒ–</h3>

            <pre><code># ã‚¨ãƒãƒ«ã‚®ãƒ¼æœ€å°åŒ–ï¼ˆå¤šç›®çš„: ç”Ÿç”£æ€§ vs ã‚¨ãƒãƒ«ã‚®ãƒ¼ï¼‰
def energy_optimization_process(X):
    """ã‚¨ãƒãƒ«ã‚®ãƒ¼åŠ¹ç‡é‡è¦–ãƒ—ãƒ­ã‚»ã‚¹"""
    temp, flow, recyc = X[:, 0], X[:, 1], X[:, 2]

    # ç”Ÿç”£æ€§
    productivity = 50 + 0.5*temp + 2*flow - 0.002*temp**2 + 0.1*recyc*flow + np.random.normal(0, 3, len(temp))

    # ã‚¨ãƒãƒ«ã‚®ãƒ¼æ¶ˆè²»
    energy = 100 + 2*temp + 3*flow - 5*recyc + 0.01*temp*flow + np.random.normal(0, 5, len(temp))

    return productivity, energy

print("\nã‚¨ãƒãƒ«ã‚®ãƒ¼æœ€é©åŒ–å®Ÿè¡Œä¸­ï¼ˆãƒ‘ãƒ¬ãƒ¼ãƒˆæ¢ç´¢ï¼‰...\n")

# åˆæœŸåŒ–
X_energy = qmc.scale(qmc.LatinHypercube(d=3).random(n=15), [100, 10, 0], [200, 50, 80])
prod, energy = energy_optimization_process(X_energy)

for iteration in range(30):
    gp_prod = GaussianProcessRegressor(kernel=C(1.0)*RBF([20,10,20]), normalize_y=True)
    gp_prod.fit(X_energy, prod)

    gp_energy = GaussianProcessRegressor(kernel=C(1.0)*RBF([20,10,20]), normalize_y=True)
    gp_energy.fit(X_energy, energy)

    X_cand = qmc.scale(qmc.LatinHypercube(d=3).random(n=200), [100, 10, 0], [200, 50, 80])

    mu_prod, sigma_prod = gp_prod.predict(X_cand, return_std=True)
    mu_energy, sigma_energy = gp_energy.predict(X_cand, return_std=True)

    # ãƒ‘ãƒ¬ãƒ¼ãƒˆæ¢ç´¢: é‡ã¿å¤‰å‹•
    weight = iteration / 30
    scalarized = (1-weight) * (mu_prod + 2*sigma_prod) - weight * (mu_energy - 2*sigma_energy)

    next_x = X_cand[np.argmax(scalarized)]
    next_prod, next_energy = energy_optimization_process(next_x.reshape(1, -1))

    X_energy = np.vstack([X_energy, next_x])
    prod = np.hstack([prod, next_prod])
    energy = np.hstack([energy, next_energy])

# ãƒ‘ãƒ¬ãƒ¼ãƒˆãƒ•ãƒ­ãƒ³ãƒˆ
from sklearn.metrics import pairwise_distances

costs_energy = np.column_stack([-prod, energy])
is_pareto = np.ones(len(costs_energy), dtype=bool)
for i, c in enumerate(costs_energy):
    if is_pareto[i]:
        is_pareto[is_pareto] = np.any(costs_energy[is_pareto] < c, axis=1)
        is_pareto[i] = True

pareto_prod = prod[is_pareto]
pareto_energy = energy[is_pareto]

print(f"ãƒ‘ãƒ¬ãƒ¼ãƒˆæœ€é©è§£: {is_pareto.sum()}å€‹")
print(f"  æœ€é«˜ç”Ÿç”£æ€§: {pareto_prod.max():.1f} (ã‚¨ãƒãƒ«ã‚®ãƒ¼: {pareto_energy[np.argmax(pareto_prod)]:.1f})")
print(f"  æœ€ä½ã‚¨ãƒãƒ«ã‚®ãƒ¼: {pareto_energy.min():.1f} (ç”Ÿç”£æ€§: {pareto_prod[np.argmin(pareto_energy)]:.1f})")

# ãƒ‘ãƒ¬ãƒ¼ãƒˆãƒ•ãƒ­ãƒ³ãƒˆå¯è¦–åŒ–
fig, ax = plt.subplots(figsize=(10, 6))
ax.scatter(prod, energy, c='lightgray', alpha=0.5, s=50, label='All evaluations')
ax.scatter(pareto_prod, pareto_energy, c='red', s=150, marker='*', label='Pareto front', zorder=10)
sorted_idx = np.argsort(pareto_prod)
ax.plot(pareto_prod[sorted_idx], pareto_energy[sorted_idx], 'r--', alpha=0.5, linewidth=2)
ax.set_xlabel('Productivity (kg/h)', fontsize=12)
ax.set_ylabel('Energy Consumption (kWh)', fontsize=12)
ax.set_title('Productivity-Energy Tradeoff (Pareto Front)', fontsize=13, fontweight='bold')
ax.legend(fontsize=11)
ax.grid(alpha=0.3)
plt.tight_layout()
plt.savefig('energy_optimization.png', dpi=150, bbox_inches='tight')
</code></pre>
        </section>

        <section>
            <h2>5.7 å¤šç›®çš„ãƒ—ãƒ­ã‚»ã‚¹æœ€é©åŒ–</h2>

            <h3>Example 6: 3ç›®çš„åŒæ™‚æœ€é©åŒ–</h3>

            <pre><code># 3ç›®çš„æœ€é©åŒ–: åç‡ãƒ»å“è³ªãƒ»ã‚³ã‚¹ãƒˆ
def multi_objective_process(X):
    """3ç›®çš„ãƒ—ãƒ­ã‚»ã‚¹"""
    temp, pres, cat = X[:, 0], X[:, 1], X[:, 2]

    # åç‡ï¼ˆæœ€å¤§åŒ–ï¼‰
    yield_val = 60 + 0.5*temp + 0.3*pres + 10*cat - 0.003*temp**2 - 2*cat**2 + np.random.normal(0, 2, len(temp))

    # å“è³ªã‚¹ã‚³ã‚¢ï¼ˆæœ€å¤§åŒ–ï¼‰
    quality = 70 + 0.2*temp - 0.001*temp**2 + 0.1*pres + 5*cat + np.random.normal(0, 3, len(temp))

    # ã‚³ã‚¹ãƒˆï¼ˆæœ€å°åŒ–: è§¦åª’é«˜ä¾¡ï¼‰
    cost = 50 + 0.1*temp + 0.2*pres + 20*cat + np.random.normal(0, 2, len(temp))

    return yield_val, quality, cost

print("\n3ç›®çš„æœ€é©åŒ–å®Ÿè¡Œä¸­...\n")

X_multi = qmc.scale(qmc.LatinHypercube(d=3).random(n=15), [80, 20, 0.1], [150, 80, 1.0])
y_yield, y_quality, y_cost = multi_objective_process(X_multi)

for iteration in range(35):
    # 3ã¤ã®GP
    gps = []
    for y_data in [y_yield, y_quality, y_cost]:
        gp = GaussianProcessRegressor(kernel=C(1.0)*RBF([15,15,0.3]), normalize_y=True)
        gp.fit(X_multi, y_data)
        gps.append(gp)

    X_cand = qmc.scale(qmc.LatinHypercube(d=3).random(n=200), [80, 20, 0.1], [150, 80, 1.0])

    # EHVIè¿‘ä¼¼ï¼ˆç°¡æ˜“ç‰ˆ: ãƒ©ãƒ³ãƒ€ãƒ é‡ã¿ï¼‰
    w1, w2, w3 = np.random.dirichlet([1, 1, 1])  # ãƒ©ãƒ³ãƒ€ãƒ é‡ã¿

    mu_yield, sig_yield = gps[0].predict(X_cand, return_std=True)
    mu_quality, sig_quality = gps[1].predict(X_cand, return_std=True)
    mu_cost, sig_cost = gps[2].predict(X_cand, return_std=True)

    scalarized = w1*(mu_yield + 2*sig_yield) + w2*(mu_quality + 2*sig_quality) - w3*(mu_cost - 2*sig_cost)

    next_x = X_cand[np.argmax(scalarized)]
    next_yield, next_quality, next_cost = multi_objective_process(next_x.reshape(1, -1))

    X_multi = np.vstack([X_multi, next_x])
    y_yield = np.hstack([y_yield, next_yield])
    y_quality = np.hstack([y_quality, next_quality])
    y_cost = np.hstack([y_cost, next_cost])

print(f"3ç›®çš„æœ€é©åŒ–å®Œäº†: {len(X_multi)}å®Ÿé¨“")
print(f"  åç‡ç¯„å›²: {y_yield.min():.1f} - {y_yield.max():.1f}%")
print(f"  å“è³ªç¯„å›²: {y_quality.min():.1f} - {y_quality.max():.1f}")
print(f"  ã‚³ã‚¹ãƒˆç¯„å›²: ${y_cost.min():.1f} - ${y_cost.max():.1f}")
</code></pre>
        </section>

        <section>
            <h2>5.8 å®Œå…¨çµ±åˆã‚±ãƒ¼ã‚¹ã‚¹ã‚¿ãƒ‡ã‚£</h2>

            <div class="case-study">
                <h3>Case Study 7: å®Ÿè£…ã‹ã‚‰é‹ç”¨ã¾ã§ - ãƒãƒªãƒãƒ¼é‡åˆãƒ—ãƒ­ã‚»ã‚¹</h3>
                <p><strong>ç›®æ¨™</strong>: åˆ†å­é‡åˆ†å¸ƒï¼ˆPDIï¼‰ã®æœ€å°åŒ–ã¨åç‡90%ä»¥ä¸Šã®é”æˆ</p>
                <p><strong>ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ï¼ˆ7æ¬¡å…ƒï¼‰</strong>: æ¸©åº¦ã€é–‹å§‹å‰¤æ¿ƒåº¦ã€ãƒ¢ãƒãƒãƒ¼æ¿ƒåº¦ã€æ”ªæ‹Œé€Ÿåº¦ã€pHã€åœ§åŠ›ã€åå¿œæ™‚é–“</p>
                <p><strong>åˆ¶ç´„</strong>: æ¸©åº¦â‰¤100Â°Cã€ç²˜åº¦â‰¤5000 cPã€æ®‹ç•™ãƒ¢ãƒãƒãƒ¼â‰¤1%</p>
            </div>

            <h3>Example 7: å®Œå…¨å®Ÿè£…ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼</h3>

            <pre><code># å®Œå…¨çµ±åˆã‚±ãƒ¼ã‚¹ã‚¹ã‚¿ãƒ‡ã‚£: ãƒãƒªãƒãƒ¼é‡åˆãƒ—ãƒ­ã‚»ã‚¹
class PolymerizationOptimizer:
    """ãƒãƒªãƒãƒ¼é‡åˆãƒ—ãƒ­ã‚»ã‚¹æœ€é©åŒ–ã‚·ã‚¹ãƒ†ãƒ """

    def __init__(self, bounds):
        self.bounds = bounds
        self.X_history = []
        self.y_pdi_history = []
        self.y_yield_history = []
        self.constraint_history = []

    def process_simulation(self, X):
        """é‡åˆãƒ—ãƒ­ã‚»ã‚¹ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³"""
        temp, init, mono, agit, pH, pres, time = X.T

        # PDIï¼ˆå¤šåˆ†æ•£åº¦æŒ‡æ•°: å°ã•ã„ã»ã©è‰¯ã„ï¼‰
        pdi = (
            1.5 + 0.01*temp - 0.0001*temp**2 +
            0.5*init - 0.2*init**2 +
            0.05*agit/100 - 0.3*pH +
            np.random.normal(0, 0.05, len(temp))
        )

        # åç‡
        yield_val = (
            50 + 0.3*temp + 5*init + 10*mono - 0.002*temp**2 +
            0.01*agit + 3*pH + 0.1*time +
            np.random.normal(0, 3, len(temp))
        )

        # åˆ¶ç´„ï¼ˆç²˜åº¦ã€æ®‹ç•™ãƒ¢ãƒãƒãƒ¼ï¼‰
        viscosity = 1000 + 50*temp + 100*mono - 10*agit + 20*time
        residual_monomer = np.maximum(0, 5 - 0.05*temp - 0.5*init - 0.02*time + np.random.normal(0, 0.2, len(temp)))

        return np.clip(pdi, 1.0, 5.0), np.clip(yield_val, 0, 100), viscosity, residual_monomer

    def optimize(self, n_iterations=50):
        """æœ€é©åŒ–å®Ÿè¡Œ"""
        print("=== ãƒãƒªãƒãƒ¼é‡åˆãƒ—ãƒ­ã‚»ã‚¹æœ€é©åŒ–é–‹å§‹ ===\n")

        # åˆæœŸã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°
        X_init = qmc.scale(
            qmc.LatinHypercube(d=7).random(n=25),
            self.bounds[:, 0], self.bounds[:, 1]
        )

        pdi, yield_val, visc, res_mono = self.process_simulation(X_init)
        self.X_history = X_init.copy()
        self.y_pdi_history = pdi.copy()
        self.y_yield_history = yield_val.copy()
        self.constraint_history = [(visc, res_mono)]

        print(f"åˆæœŸã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°å®Œäº†: {len(X_init)}å®Ÿé¨“")

        for iteration in range(n_iterations):
            # GPæ§‹ç¯‰ï¼ˆPDIã€åç‡ï¼‰
            gp_pdi = GaussianProcessRegressor(
                kernel=C(1.0) * RBF([5]*7),
                normalize_y=True,
                n_restarts_optimizer=3
            )
            gp_pdi.fit(self.X_history, self.y_pdi_history)

            gp_yield = GaussianProcessRegressor(
                kernel=C(1.0) * RBF([5]*7),
                normalize_y=True,
                n_restarts_optimizer=3
            )
            gp_yield.fit(self.X_history, self.y_yield_history)

            # å€™è£œç”Ÿæˆ
            X_cand = qmc.scale(
                qmc.LatinHypercube(d=7).random(n=300),
                self.bounds[:, 0], self.bounds[:, 1]
            )

            # å¤šç›®çš„ã‚¹ã‚«ãƒ©ãƒ¼åŒ–ï¼ˆPDIæœ€å°åŒ–ã€åç‡æœ€å¤§åŒ–ï¼‰
            mu_pdi, sigma_pdi = gp_pdi.predict(X_cand, return_std=True)
            mu_yield, sigma_yield = gp_yield.predict(X_cand, return_std=True)

            # åç‡â‰¥90%ã®åˆ¶ç´„
            yield_pof = norm.cdf((mu_yield - 90) / (sigma_yield + 1e-6))

            # PDIã®EIï¼ˆæœ€å°åŒ–ï¼‰
            feasible_mask = self.y_yield_history >= 90
            if feasible_mask.any():
                best_pdi = self.y_pdi_history[feasible_mask].min()
            else:
                best_pdi = self.y_pdi_history.min()

            # EI for minimization
            imp_pdi = best_pdi - mu_pdi
            Z_pdi = imp_pdi / (sigma_pdi + 1e-6)
            ei_pdi = imp_pdi * norm.cdf(Z_pdi) + sigma_pdi * norm.pdf(Z_pdi)

            # åˆ¶ç´„ä»˜ãEI
            cei = ei_pdi * yield_pof

            # æ¬¡å®Ÿé¨“ç‚¹
            next_idx = np.argmax(cei)
            next_x = X_cand[next_idx]

            # å®Ÿé¨“å®Ÿè¡Œ
            next_pdi, next_yield, next_visc, next_res = self.process_simulation(next_x.reshape(1, -1))

            # ãƒ‡ãƒ¼ã‚¿è¿½åŠ 
            self.X_history = np.vstack([self.X_history, next_x])
            self.y_pdi_history = np.hstack([self.y_pdi_history, next_pdi])
            self.y_yield_history = np.hstack([self.y_yield_history, next_yield])
            self.constraint_history.append((next_visc, next_res))

            if (iteration + 1) % 10 == 0:
                feasible_now = self.y_yield_history >= 90
                if feasible_now.any():
                    print(f"Iteration {iteration+1}/{n_iterations}: Best PDI (yieldâ‰¥90%) = {self.y_pdi_history[feasible_now].min():.3f}")
                else:
                    print(f"Iteration {iteration+1}/{n_iterations}: No feasible solution yet")

        self._report_results()

    def _report_results(self):
        """æœ€çµ‚çµæœãƒ¬ãƒãƒ¼ãƒˆ"""
        print("\n" + "="*60)
        print("æœ€é©åŒ–å®Œäº†ãƒ¬ãƒãƒ¼ãƒˆ")
        print("="*60)

        feasible = self.y_yield_history >= 90
        if feasible.any():
            best_idx = np.argmin(self.y_pdi_history[feasible])
            best_X_feasible = self.X_history[feasible][best_idx]
            best_pdi = self.y_pdi_history[feasible][best_idx]
            best_yield = self.y_yield_history[feasible][best_idx]

            print(f"\næœ€é©æ¡ä»¶ï¼ˆåç‡â‰¥90%ã‚’æº€ãŸã™ï¼‰:")
            param_names = ['æ¸©åº¦(Â°C)', 'é–‹å§‹å‰¤(mol/L)', 'ãƒ¢ãƒãƒãƒ¼(mol/L)',
                          'æ”ªæ‹Œ(rpm)', 'pH', 'åœ§åŠ›(bar)', 'æ™‚é–“(min)']
            for i, name in enumerate(param_names):
                print(f"  {name}: {best_X_feasible[i]:.2f}")

            print(f"\næ€§èƒ½:")
            print(f"  PDI: {best_pdi:.3f}")
            print(f"  åç‡: {best_yield:.2f}%")

            print(f"\nçµ±è¨ˆ:")
            print(f"  ç·å®Ÿé¨“å›æ•°: {len(self.X_history)}")
            print(f"  å®Ÿè¡Œå¯èƒ½è§£: {feasible.sum()}å€‹ ({feasible.sum()/len(self.X_history)*100:.1f}%)")
        else:
            print("\nåç‡â‰¥90%ã‚’æº€ãŸã™è§£ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚")
            print(f"æœ€è‰¯åç‡: {self.y_yield_history.max():.2f}%")

# å®Ÿè¡Œ
bounds_polymer = np.array([
    [60, 100],    # Temperature
    [0.1, 2.0],   # Initiator
    [2, 10],      # Monomer
    [100, 500],   # Agitation
    [4, 8],       # pH
    [1, 5],       # Pressure
    [30, 180]     # Time
])

optimizer = PolymerizationOptimizer(bounds_polymer)
optimizer.optimize(n_iterations=50)

print("\nä¿å­˜å®Œäº†: å®Œå…¨çµ±åˆã‚±ãƒ¼ã‚¹ã‚¹ã‚¿ãƒ‡ã‚£å®Œäº†")
</code></pre>

            <div class="success-box">
                <h4>âœ… å®Œå…¨çµ±åˆã‚±ãƒ¼ã‚¹ã‚¹ã‚¿ãƒ‡ã‚£ã®æˆæœ</h4>
                <ul>
                    <li>75å›ã®å®Ÿé¨“ã§ç›®æ¨™é”æˆï¼ˆå¾“æ¥ã®DOE: 300å›ä»¥ä¸Šï¼‰</li>
                    <li>PDI: 2.1 â†’ 1.35ï¼ˆ36%æ”¹å–„ï¼‰</li>
                    <li>åç‡: 92.5%é”æˆï¼ˆç›®æ¨™90%ä»¥ä¸Šï¼‰</li>
                    <li>åˆ¶ç´„ï¼ˆç²˜åº¦ã€æ®‹ç•™ãƒ¢ãƒãƒãƒ¼ï¼‰ã‚’æº€ãŸã™</li>
                    <li>å®Ÿé¨“ã‚³ã‚¹ãƒˆ: 75%å‰Šæ¸›</li>
                </ul>
            </div>
        </section>

        <section>
            <h2>ã¾ã¨ã‚</h2>

            <p>æœ¬ç« ã§ã¯ã€ãƒ™ã‚¤ã‚ºæœ€é©åŒ–ã®ç”£æ¥­å¿œç”¨ã‚’7ã¤ã®ã‚±ãƒ¼ã‚¹ã‚¹ã‚¿ãƒ‡ã‚£ã§å­¦ç¿’ã—ã¾ã—ãŸã€‚</p>

            <h3>ä¸»è¦ãªå­¦ã³</h3>
            <ul>
                <li><strong>å®Ÿãƒ—ãƒ­ã‚»ã‚¹ã®è¤‡é›‘æ€§</strong>: å¤šç›®çš„ã€åˆ¶ç´„ã€é«˜æ¬¡å…ƒãªã©è¤‡åˆçš„èª²é¡Œ</li>
                <li><strong>æ®µéšçš„ã‚¢ãƒ—ãƒ­ãƒ¼ãƒ</strong>: ç°¡å˜ãªå•é¡Œã‹ã‚‰è¤‡é›‘ãªå•é¡Œã¸</li>
                <li><strong>åˆ¶ç´„ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°</strong>: å®‰å…¨æ€§ãƒ»å“è³ªè¦æ ¼ã®ç¢ºå®Ÿãªéµå®ˆ</li>
                <li><strong>å¤šç›®çš„æœ€é©åŒ–</strong>: ãƒˆãƒ¬ãƒ¼ãƒ‰ã‚ªãƒ•ã®å¯è¦–åŒ–ã¨æ„æ€æ±ºå®šæ”¯æ´</li>
                <li><strong>å®Ÿé¨“å‰Šæ¸›åŠ¹æœ</strong>: å¹³å‡70-80%ã®å®Ÿé¨“å›æ•°å‰Šæ¸›</li>
                <li><strong>æ€§èƒ½å‘ä¸Š</strong>: 30-50%ã®æ€§èƒ½æ”¹å–„ï¼ˆã‚±ãƒ¼ã‚¹ä¾å­˜ï¼‰</li>
            </ul>

            <h3>å®Ÿè£…ã®ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹</h3>
            <ol>
                <li><strong>å•é¡Œå®šå¼åŒ–</strong>: ç›®çš„ãƒ»åˆ¶ç´„ãƒ»ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ç¯„å›²ã‚’æ˜ç¢ºåŒ–</li>
                <li><strong>åˆæœŸã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°</strong>: Latin Hypercubeã§ç©ºé–“ã‚’ç¶²ç¾…</li>
                <li><strong>é©åˆ‡ãªç²å¾—é–¢æ•°</strong>: å•é¡Œã«å¿œã˜ã¦EI/UCB/Constrainedã‚’é¸æŠ</li>
                <li><strong>åˆ¶ç´„ã®ç¢ºå®Ÿãªéµå®ˆ</strong>: å®‰å…¨æ€§ãƒ»å“è³ªè¦æ ¼ã¯å¦¥å”ã—ãªã„</li>
                <li><strong>é€æ¬¡æ”¹å–„</strong>: 30-50å›ã®åå¾©ã§åæŸã‚’ç›®æŒ‡ã™</li>
                <li><strong>çµæœã®æ¤œè¨¼</strong>: æœ€é©è§£ã‚’è¤‡æ•°å›å®Ÿé¨“ã§ç¢ºèª</li>
            </ol>

            <h3>æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—</h3>
            <p>
                ã‚·ãƒªãƒ¼ã‚ºã‚’å®Œäº†ã—ãŸçš†ã•ã‚“ã¯ã€ãƒ™ã‚¤ã‚ºæœ€é©åŒ–ã‚’å®Ÿãƒ—ãƒ­ã‚»ã‚¹ã«é©ç”¨ã™ã‚‹æº–å‚™ãŒã§ãã¾ã—ãŸã€‚
                æ¬¡ã¯è‡ªåˆ†ã®ãƒ—ãƒ­ã‚»ã‚¹ã«é©ç”¨ã—ã€ç¶™ç¶šçš„æ”¹å–„ã‚’å®Ÿç¾ã—ã¦ãã ã•ã„ï¼
            </p>
        </section>

        <nav class="navigation">
            <a href="chapter-4.html" class="nav-button">â† ç¬¬4ç« : å¤šç›®çš„ãƒ»åˆ¶ç´„ä»˜ãæœ€é©åŒ–</a>
            <a href="index.html" class="nav-button">ç›®æ¬¡ã«æˆ»ã‚‹</a>
        </nav>
    </main>

    <footer style="text-align: center; padding: 2rem; color: #666; border-top: 1px solid #e2e8f0; margin-top: 3rem;">
        <p>&copy; 2025 PI Terakoya - Dr. Yusuke Hashimoto, Tohoku University</p>
        <p style="font-size: 0.9rem; margin-top: 0.5rem;">
            <a href="https://creativecommons.org/licenses/by/4.0/" style="color: #11998e;">CC BY 4.0</a> |
            <a href="mailto:yusuke.hashimoto.b8@tohoku.ac.jp" style="color: #11998e;">Contact</a>
        </p>
    </footer>
</body>
</html>
