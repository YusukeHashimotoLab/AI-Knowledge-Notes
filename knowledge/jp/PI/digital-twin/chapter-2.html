<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="ç¬¬2ç« ï¼šãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ‡ãƒ¼ã‚¿é€£æº - Digital Twinã¨IoTã‚»ãƒ³ã‚µãƒ¼ã®çµ±åˆæ‰‹æ³•">
    <title>ç¬¬2ç« ï¼šãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ‡ãƒ¼ã‚¿é€£æº - PI Terakoya</title>

        <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            line-height: 1.8; color: #333; background: #f5f5f5;
        }
        header {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
            color: white; padding: 2rem 1rem; text-align: center;
        }
        h1 { font-size: 2rem; margin-bottom: 0.5rem; }
        .subtitle { opacity: 0.9; font-size: 1.1rem; }
        .container { max-width: 1200px; margin: 2rem auto; padding: 0 1rem; }
        .back-link {
            display: inline-block; margin-bottom: 2rem; padding: 0.5rem 1rem;
            background: white; color: #11998e; text-decoration: none;
            border-radius: 6px; font-weight: 600;
        }
        .content-box {
            background: white; padding: 2rem; border-radius: 12px;
            margin-bottom: 2rem; box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        h2 {
            color: #11998e; margin: 2rem 0 1rem 0;
            padding-bottom: 0.5rem; border-bottom: 3px solid #11998e;
        }
        h3 { color: #2c3e50; margin: 1.5rem 0 1rem 0; }
        h4 { color: #2c3e50; margin: 1rem 0 0.5rem 0; }
        p { margin-bottom: 1rem; }
        ul, ol { margin-left: 2rem; margin-bottom: 1rem; }
        li { margin-bottom: 0.5rem; }
        pre {
            background: #1e1e1e; color: #d4d4d4; padding: 1.5rem;
            border-radius: 8px; overflow-x: auto; margin: 1rem 0;
            border-left: 4px solid #11998e;
        }
        code {
            font-family: 'Courier New', monospace; font-size: 0.9rem;
        }
        .key-point {
            background: #e8f5e9; padding: 1rem; border-radius: 6px;
            border-left: 4px solid #4caf50; margin: 1rem 0;
        }
        .tech-note {
            background: #e3f2fd; padding: 1rem; border-radius: 6px;
            border-left: 4px solid #2196f3; margin: 1rem 0;
        }
        .formula {
            background: #f0f7ff; padding: 1rem; border-radius: 6px;
            margin: 1rem 0; overflow-x: auto;
        }
        table {
            width: 100%; border-collapse: collapse; margin: 1rem 0;
        }
        th, td {
            border: 1px solid #ddd; padding: 0.75rem; text-align: left;
        }
        th {
            background: #11998e; color: white; font-weight: 600;
        }
        tr:nth-child(even) { background: #f9f9f9; }
        .nav-buttons {
            display: flex; justify-content: space-between; margin-top: 3rem;
        }
        .nav-buttons a {
            padding: 0.75rem 1.5rem;
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
            color: white; text-decoration: none; border-radius: 6px;
            font-weight: 600;
        }
        footer {
            background: #2c3e50; color: white; text-align: center;
            padding: 2rem 1rem; margin-top: 4rem;
        }
        @media (max-width: 768px) {
            h1 { font-size: 1.6rem; }
            .container { padding: 0 0.5rem; }
            pre { padding: 1rem; }
        }
    
        /* Breadcrumb styles */
        .breadcrumb {
            background: #f7fafc;
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #e2e8f0;
            font-size: 0.9rem;
        }

        .breadcrumb-content {
            max-width: 900px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .breadcrumb a {
            color: #667eea;
            text-decoration: none;
            transition: color 0.2s;
        }

        .breadcrumb a:hover {
            color: #764ba2;
            text-decoration: underline;
        }

        .breadcrumb-separator {
            color: #a0aec0;
            margin: 0 0.25rem;
        }

        .breadcrumb-current {
            color: #4a5568;
            font-weight: 500;
        }
    </style>
</head>
<body>
        <nav class="breadcrumb">
        <div class="breadcrumb-content">
            <a href="/wp/knowledge/jp/index.html">AIå¯ºå­å±‹ãƒˆãƒƒãƒ—</a><span class="breadcrumb-separator">â€º</span><a href="/wp/knowledge/jp/PI/index.html">ãƒ—ãƒ­ã‚»ã‚¹ãƒ»ã‚¤ãƒ³ãƒ•ã‚©ãƒãƒ†ã‚£ã‚¯ã‚¹</a><span class="breadcrumb-separator">â€º</span><a href="/wp/knowledge/jp/PI/digital-twin/index.html">Digital Twin</a><span class="breadcrumb-separator">â€º</span><span class="breadcrumb-current">Chapter 2</span>
        </div>
    </nav>

    <header>
        <div class="container">
            <h1>ç¬¬2ç« ï¼šãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ‡ãƒ¼ã‚¿é€£æº</h1>
            <p class="subtitle">Digital Twinã¨IoTã‚»ãƒ³ã‚µãƒ¼ã®çµ±åˆã«ã‚ˆã‚Šã€ç‰©ç†ã‚·ã‚¹ãƒ†ãƒ ã¨ãƒ‡ã‚¸ã‚¿ãƒ«ç©ºé–“ã‚’åŒæœŸã™ã‚‹å®Ÿè£…æŠ€è¡“</p>
            <div class="meta">
                <span class="meta">ğŸ“š Digital Twinå…¥é–€ã‚·ãƒªãƒ¼ã‚º</span>
                <span class="meta">â±ï¸ èª­äº†æ™‚é–“: 35åˆ†</span>
                <span class="meta">ğŸ’¡ é›£æ˜“åº¦: ä¸­ç´š</span>
            </div>
        </div>
    </header>

    <div class="container">
        <h2>2.1 ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ‡ãƒ¼ã‚¿é€£æºã®é‡è¦æ€§</h2>

        <p>Digital Twinã®ç²¾åº¦ã¨å®Ÿç”¨æ€§ã¯ã€ç‰©ç†ã‚·ã‚¹ãƒ†ãƒ ã¨ãƒ‡ã‚¸ã‚¿ãƒ«ãƒ¢ãƒ‡ãƒ«ã®åŒæœŸç²¾åº¦ã«å¤§ããä¾å­˜ã—ã¾ã™ã€‚æœ¬ç« ã§ã¯ã€IoTã‚»ãƒ³ã‚µãƒ¼ã‹ã‚‰å¾—ã‚‰ã‚Œã‚‹ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ‡ãƒ¼ã‚¿ã‚’Digital Twinã«çµ±åˆã™ã‚‹7ã¤ã®å®Ÿè·µçš„ãªæ‰‹æ³•ã‚’å­¦ã³ã¾ã™ã€‚</p>

        <h3>2.1.1 ãƒ‡ãƒ¼ã‚¿é€£æºã®èª²é¡Œ</h3>

        <p>ãƒ—ãƒ­ã‚»ã‚¹ç”£æ¥­ã«ãŠã‘ã‚‹ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ‡ãƒ¼ã‚¿é€£æºã§ã¯ã€ä»¥ä¸‹ã®èª²é¡Œã«å¯¾å‡¦ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ï¼š</p>

        <ul>
            <li><strong>ãƒ‡ãƒ¼ã‚¿ã®å¤šæ§˜æ€§</strong>ï¼šæ¸©åº¦ã€åœ§åŠ›ã€æµé‡ãªã©ç•°ãªã‚‹ç‰©ç†é‡ã¨å˜ä½ç³»</li>
            <li><strong>é€šä¿¡ãƒ—ãƒ­ãƒˆã‚³ãƒ«</strong>ï¼šMQTTã€OPC UAã€Modbusç­‰ã®æ¨™æº–è¦æ ¼ã¸ã®å¯¾å¿œ</li>
            <li><strong>ãƒ‡ãƒ¼ã‚¿å“è³ª</strong>ï¼šã‚»ãƒ³ã‚µãƒ¼ãƒã‚¤ã‚ºã€æ¬ æå€¤ã€å¤–ã‚Œå€¤ã®æ¤œå‡ºã¨å‡¦ç†</li>
            <li><strong>æ™‚ç³»åˆ—ç®¡ç†</strong>ï¼šã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã®åŒæœŸã¨é«˜é€Ÿãªæ™‚ç³»åˆ—ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹</li>
            <li><strong>ã‚¹ã‚±ãƒ¼ãƒ©ãƒ“ãƒªãƒ†ã‚£</strong>ï¼šæ•°ç™¾ã€œæ•°åƒã®ã‚»ãƒ³ã‚µãƒ¼ã‹ã‚‰ã®ãƒ‡ãƒ¼ã‚¿ã‚¹ãƒˆãƒªãƒ¼ãƒ å‡¦ç†</li>
        </ul>

        <div class="note">
            <strong>ğŸ’¡ ç”£æ¥­ç•Œã®å®Ÿä¾‹</strong><br>
            åŒ–å­¦ãƒ—ãƒ©ãƒ³ãƒˆã§ã¯1000ç‚¹ä»¥ä¸Šã®ã‚»ãƒ³ã‚µãƒ¼ãŒ1ç§’é–“éš”ã§ãƒ‡ãƒ¼ã‚¿ã‚’é€ä¿¡ã—ã¾ã™ã€‚1æ—¥ã‚ãŸã‚Š86.4Mï¼ˆ8640ä¸‡ï¼‰ã®ãƒ‡ãƒ¼ã‚¿ãƒã‚¤ãƒ³ãƒˆãŒç”Ÿæˆã•ã‚Œã€ã“ã‚Œã‚’ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã«å‡¦ç†ã—ã¦Digital Twinã«åæ˜ ã•ã›ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚
        </div>

        <h2>2.2 å®Ÿè£…ä¾‹1ï¼šMQTTé€šä¿¡ã«ã‚ˆã‚‹IoTã‚»ãƒ³ã‚µãƒ¼ãƒ‡ãƒ¼ã‚¿å–å¾—</h2>

        <p>MQTTã¯è»½é‡ã§ä¿¡é ¼æ€§ã®é«˜ã„ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ³ã‚°ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã§ã€IoTãƒ‡ãƒã‚¤ã‚¹ã¨ã®é€šä¿¡ã«åºƒãä½¿ã‚ã‚Œã¦ã„ã¾ã™ã€‚</p>

        <pre><code>"""
Example 1: MQTTé€šä¿¡ã«ã‚ˆã‚‹ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã‚»ãƒ³ã‚µãƒ¼ãƒ‡ãƒ¼ã‚¿å–å¾—
åŒ–å­¦åå¿œå™¨ã®æ¸©åº¦ãƒ»åœ§åŠ›ã‚»ãƒ³ã‚µãƒ¼ã‹ã‚‰MQTTçµŒç”±ã§ãƒ‡ãƒ¼ã‚¿ã‚’å—ä¿¡
"""

import paho.mqtt.client as mqtt
import json
from datetime import datetime
from typing import Dict, Callable
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class MQTTSensorClient:
    """MQTTãƒ—ãƒ­ãƒˆã‚³ãƒ«ã§IoTã‚»ãƒ³ã‚µãƒ¼ã¨é€šä¿¡ã™ã‚‹ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ

    åŒ–å­¦ãƒ—ãƒ©ãƒ³ãƒˆã®åå¿œå™¨ã‚»ãƒ³ã‚µãƒ¼ï¼ˆæ¸©åº¦ã€åœ§åŠ›ã€æµé‡ï¼‰ã‹ã‚‰
    ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã—ã€Digital Twinã«é€ä¿¡ã—ã¾ã™ã€‚
    """

    def __init__(self, broker_address: str, port: int = 1883):
        """
        Args:
            broker_address: MQTTãƒ–ãƒ­ãƒ¼ã‚«ãƒ¼ã®IPã‚¢ãƒ‰ãƒ¬ã‚¹/ãƒ›ã‚¹ãƒˆå
            port: MQTTãƒãƒ¼ãƒˆç•ªå·ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ1883ï¼‰
        """
        self.client = mqtt.Client(client_id="digital_twin_client")
        self.broker_address = broker_address
        self.port = port
        self.data_callbacks: Dict[str, Callable] = {}

        # ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°ã®ç™»éŒ²
        self.client.on_connect = self._on_connect
        self.client.on_message = self._on_message
        self.client.on_disconnect = self._on_disconnect

    def _on_connect(self, client, userdata, flags, rc):
        """æ¥ç¶šç¢ºç«‹æ™‚ã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯"""
        if rc == 0:
            logger.info(f"MQTTãƒ–ãƒ­ãƒ¼ã‚«ãƒ¼ã«æ¥ç¶šæˆåŠŸ: {self.broker_address}")
            # åå¿œå™¨ã®ã™ã¹ã¦ã®ã‚»ãƒ³ã‚µãƒ¼ãƒˆãƒ”ãƒƒã‚¯ã‚’ã‚µãƒ–ã‚¹ã‚¯ãƒ©ã‚¤ãƒ–
            self.client.subscribe("reactor/+/sensor/#")
        else:
            logger.error(f"æ¥ç¶šå¤±æ•—: return code {rc}")

    def _on_message(self, client, userdata, msg):
        """ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å—ä¿¡æ™‚ã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯"""
        try:
            # JSONãƒšã‚¤ãƒ­ãƒ¼ãƒ‰ã‚’ãƒ‘ãƒ¼ã‚¹
            payload = json.loads(msg.payload.decode())
            topic = msg.topic

            # ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã®è¿½åŠ ï¼ˆã‚»ãƒ³ã‚µãƒ¼ãƒ‡ãƒ¼ã‚¿ã«å«ã¾ã‚Œãªã„å ´åˆï¼‰
            if 'timestamp' not in payload:
                payload['timestamp'] = datetime.now().isoformat()

            logger.info(f"å—ä¿¡: {topic} - {payload}")

            # ç™»éŒ²ã•ã‚ŒãŸã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°ã‚’å®Ÿè¡Œ
            for callback in self.data_callbacks.values():
                callback(topic, payload)

        except json.JSONDecodeError as e:
            logger.error(f"JSON parse error: {e}")
        except Exception as e:
            logger.error(f"ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å‡¦ç†ã‚¨ãƒ©ãƒ¼: {e}")

    def _on_disconnect(self, client, userdata, rc):
        """åˆ‡æ–­æ™‚ã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯"""
        if rc != 0:
            logger.warning(f"äºˆæœŸã—ãªã„åˆ‡æ–­: return code {rc}")
            logger.info("å†æ¥ç¶šã‚’è©¦è¡Œä¸­...")

    def register_callback(self, name: str, callback: Callable):
        """ãƒ‡ãƒ¼ã‚¿å—ä¿¡æ™‚ã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°ã‚’ç™»éŒ²

        Args:
            name: ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã®è­˜åˆ¥å
            callback: å®Ÿè¡Œã™ã‚‹é–¢æ•° callback(topic: str, payload: dict)
        """
        self.data_callbacks[name] = callback

    def connect(self):
        """MQTTãƒ–ãƒ­ãƒ¼ã‚«ãƒ¼ã«æ¥ç¶š"""
        self.client.connect(self.broker_address, self.port, 60)
        self.client.loop_start()

    def disconnect(self):
        """MQTTãƒ–ãƒ­ãƒ¼ã‚«ãƒ¼ã‹ã‚‰åˆ‡æ–­"""
        self.client.loop_stop()
        self.client.disconnect()


# ä½¿ç”¨ä¾‹
def process_sensor_data(topic: str, payload: dict):
    """å—ä¿¡ã—ãŸã‚»ãƒ³ã‚µãƒ¼ãƒ‡ãƒ¼ã‚¿ã‚’Digital Twinã«é€ä¿¡"""
    reactor_id = topic.split('/')[1]
    sensor_type = topic.split('/')[-1]

    print(f"Reactor {reactor_id} - {sensor_type}: {payload['value']} {payload['unit']}")

    # Digital Twinãƒ¢ãƒ‡ãƒ«ã«åæ˜ ï¼ˆå¾Œè¿°ï¼‰
    # digital_twin.update_sensor_value(reactor_id, sensor_type, payload)


if __name__ == "__main__":
    # MQTTã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã®åˆæœŸåŒ–
    mqtt_client = MQTTSensorClient(broker_address="192.168.1.100")

    # ãƒ‡ãƒ¼ã‚¿å‡¦ç†ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã®ç™»éŒ²
    mqtt_client.register_callback("process_data", process_sensor_data)

    # æ¥ç¶šé–‹å§‹
    mqtt_client.connect()

    try:
        # ç¶™ç¶šçš„ã«ãƒ‡ãƒ¼ã‚¿ã‚’å—ä¿¡ï¼ˆCtrl+Cã§çµ‚äº†ï¼‰
        import time
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        mqtt_client.disconnect()
        print("\næ¥ç¶šã‚’çµ‚äº†ã—ã¾ã—ãŸ")

# æœŸå¾…ã•ã‚Œã‚‹å‡ºåŠ›ä¾‹:
# INFO:__main__:MQTTãƒ–ãƒ­ãƒ¼ã‚«ãƒ¼ã«æ¥ç¶šæˆåŠŸ: 192.168.1.100
# INFO:__main__:å—ä¿¡: reactor/R101/sensor/temperature - {'value': 85.3, 'unit': 'degC', 'timestamp': '2025-10-26T10:30:15'}
# Reactor R101 - temperature: 85.3 degC
# INFO:__main__:å—ä¿¡: reactor/R101/sensor/pressure - {'value': 2.45, 'unit': 'MPa', 'timestamp': '2025-10-26T10:30:15'}
# Reactor R101 - pressure: 2.45 MPa
</code></pre>

        <h2>2.3 å®Ÿè£…ä¾‹2ï¼šOPC UAçµ±åˆã«ã‚ˆã‚‹ç”£æ¥­æ©Ÿå™¨ãƒ‡ãƒ¼ã‚¿å–å¾—</h2>

        <p>OPC UAï¼ˆOPC Unified Architectureï¼‰ã¯ç”£æ¥­ã‚ªãƒ¼ãƒˆãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åˆ†é‡ã®æ¨™æº–é€šä¿¡ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã§ã€PLCã‚„DCSã¨ã®æ¥ç¶šã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚</p>

        <pre><code>"""
Example 2: OPC UAé€šä¿¡ã«ã‚ˆã‚‹ç”£æ¥­æ©Ÿå™¨ãƒ‡ãƒ¼ã‚¿å–å¾—
PLCã‹ã‚‰åå¿œå™¨ã®åˆ¶å¾¡ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¨æ¸¬å®šå€¤ã‚’å–å¾—
"""

from opcua import Client, ua
from typing import List, Dict
import time
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class OPCUAReactorClient:
    """OPC UAã§åå¿œå™¨ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã™ã‚‹ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ

    DCSï¼ˆåˆ†æ•£åˆ¶å¾¡ã‚·ã‚¹ãƒ†ãƒ ï¼‰ã‚„PLCã‹ã‚‰è¨­å®šå€¤ï¼ˆSVï¼‰ã¨
    æ¸¬å®šå€¤ï¼ˆPVï¼‰ã‚’ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã«å–å¾—ã—ã¾ã™ã€‚
    """

    def __init__(self, server_url: str):
        """
        Args:
            server_url: OPC UAã‚µãƒ¼ãƒãƒ¼ã®URLï¼ˆä¾‹: "opc.tcp://192.168.1.50:4840"ï¼‰
        """
        self.client = Client(server_url)
        self.server_url = server_url
        self.subscriptions = []

    def connect(self):
        """OPC UAã‚µãƒ¼ãƒãƒ¼ã«æ¥ç¶š"""
        try:
            self.client.connect()
            logger.info(f"OPC UAã‚µãƒ¼ãƒãƒ¼ã«æ¥ç¶š: {self.server_url}")

            # ã‚µãƒ¼ãƒãƒ¼æƒ…å ±ã®å–å¾—
            server_info = self.client.get_server_node()
            logger.info(f"ã‚µãƒ¼ãƒãƒ¼å: {server_info.get_browse_name()}")

        except Exception as e:
            logger.error(f"æ¥ç¶šã‚¨ãƒ©ãƒ¼: {e}")
            raise

    def read_node(self, node_id: str) -> Dict:
        """OPC UAãƒãƒ¼ãƒ‰ã‹ã‚‰å€¤ã‚’èª­ã¿å–ã‚Š

        Args:
            node_id: ãƒãƒ¼ãƒ‰IDï¼ˆä¾‹: "ns=2;s=Reactor.R101.Temperature"ï¼‰

        Returns:
            {'value': 85.3, 'quality': 'Good', 'timestamp': '2025-10-26T10:30:15'}
        """
        try:
            node = self.client.get_node(node_id)
            data_value = node.get_data_value()

            return {
                'value': data_value.Value.Value,
                'quality': str(data_value.StatusCode),
                'timestamp': data_value.SourceTimestamp.isoformat(),
                'node_id': node_id
            }
        except Exception as e:
            logger.error(f"ãƒãƒ¼ãƒ‰èª­ã¿å–ã‚Šã‚¨ãƒ©ãƒ¼ ({node_id}): {e}")
            return None

    def read_multiple_nodes(self, node_ids: List[str]) -> Dict[str, Dict]:
        """è¤‡æ•°ãƒãƒ¼ãƒ‰ã‚’ä¸€æ‹¬èª­ã¿å–ã‚Šï¼ˆåŠ¹ç‡çš„ï¼‰

        Args:
            node_ids: ãƒãƒ¼ãƒ‰IDã®ãƒªã‚¹ãƒˆ

        Returns:
            {node_id: {'value': ..., 'quality': ..., 'timestamp': ...}}
        """
        results = {}
        nodes = [self.client.get_node(nid) for nid in node_ids]

        # ä¸€æ‹¬èª­ã¿å–ã‚Šï¼ˆãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹å‘ä¸Šï¼‰
        data_values = self.client.get_values(nodes)

        for node_id, data_value in zip(node_ids, data_values):
            results[node_id] = {
                'value': data_value,
                'quality': 'Good',  # ç°¡ç•¥åŒ–ï¼ˆå®Ÿéš›ã¯StatusCodeã‚’ç¢ºèªï¼‰
                'timestamp': time.time()
            }

        return results

    def subscribe_to_changes(self, node_id: str, callback):
        """ãƒãƒ¼ãƒ‰ã®å¤‰åŒ–ã‚’ã‚µãƒ–ã‚¹ã‚¯ãƒ©ã‚¤ãƒ–ï¼ˆå¤‰æ›´æ™‚ã®ã¿é€šçŸ¥ï¼‰

        Args:
            node_id: ç›£è¦–ã™ã‚‹ãƒãƒ¼ãƒ‰ID
            callback: å¤‰æ›´æ™‚ã«å‘¼ã°ã‚Œã‚‹é–¢æ•° callback(node_id, value)
        """
        try:
            # ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ã®ä½œæˆï¼ˆ100msé–“éš”ï¼‰
            subscription = self.client.create_subscription(100, callback)
            node = self.client.get_node(node_id)

            # ãƒ‡ãƒ¼ã‚¿å¤‰æ›´ã®ç›£è¦–é–‹å§‹
            handle = subscription.subscribe_data_change(node)
            self.subscriptions.append((subscription, handle))

            logger.info(f"ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³é–‹å§‹: {node_id}")

        except Exception as e:
            logger.error(f"ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ã‚¨ãƒ©ãƒ¼: {e}")

    def disconnect(self):
        """OPC UAã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰åˆ‡æ–­"""
        # ã™ã¹ã¦ã®ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ã‚’å‰Šé™¤
        for subscription, handle in self.subscriptions:
            subscription.unsubscribe(handle)
            subscription.delete()

        self.client.disconnect()
        logger.info("OPC UAã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰åˆ‡æ–­")


# ä½¿ç”¨ä¾‹
if __name__ == "__main__":
    # OPC UAã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã®åˆæœŸåŒ–
    opcua_client = OPCUAReactorClient(server_url="opc.tcp://192.168.1.50:4840")
    opcua_client.connect()

    # åå¿œå™¨R101ã®ç›£è¦–ãƒãƒ¼ãƒ‰
    reactor_nodes = [
        "ns=2;s=Reactor.R101.Temperature.PV",    # æ¸©åº¦æ¸¬å®šå€¤
        "ns=2;s=Reactor.R101.Temperature.SV",    # æ¸©åº¦è¨­å®šå€¤
        "ns=2;s=Reactor.R101.Pressure.PV",       # åœ§åŠ›æ¸¬å®šå€¤
        "ns=2;s=Reactor.R101.Pressure.SV",       # åœ§åŠ›è¨­å®šå€¤
        "ns=2;s=Reactor.R101.FlowRate.PV",       # æµé‡æ¸¬å®šå€¤
    ]

    try:
        # è¤‡æ•°ãƒãƒ¼ãƒ‰ã‚’ä¸€æ‹¬èª­ã¿å–ã‚Š
        data = opcua_client.read_multiple_nodes(reactor_nodes)

        for node_id, values in data.items():
            print(f"{node_id}: {values['value']}")

        # é€£ç¶šç›£è¦–ï¼ˆ10ç§’é–“ï¼‰
        print("\né€£ç¶šç›£è¦–ã‚’é–‹å§‹...")
        for _ in range(10):
            data = opcua_client.read_multiple_nodes(reactor_nodes)
            temp_pv = data["ns=2;s=Reactor.R101.Temperature.PV"]['value']
            pres_pv = data["ns=2;s=Reactor.R101.Pressure.PV"]['value']

            print(f"Temperature: {temp_pv:.1f}Â°C, Pressure: {pres_pv:.2f} MPa")
            time.sleep(1)

    finally:
        opcua_client.disconnect()

# æœŸå¾…ã•ã‚Œã‚‹å‡ºåŠ›ä¾‹:
# INFO:__main__:OPC UAã‚µãƒ¼ãƒãƒ¼ã«æ¥ç¶š: opc.tcp://192.168.1.50:4840
# ns=2;s=Reactor.R101.Temperature.PV: 85.3
# ns=2;s=Reactor.R101.Temperature.SV: 85.0
# ns=2;s=Reactor.R101.Pressure.PV: 2.45
# ns=2;s=Reactor.R101.Pressure.SV: 2.50
# ns=2;s=Reactor.R101.FlowRate.PV: 120.5
#
# é€£ç¶šç›£è¦–ã‚’é–‹å§‹...
# Temperature: 85.3Â°C, Pressure: 2.45 MPa
# Temperature: 85.5Â°C, Pressure: 2.46 MPa
# Temperature: 85.4Â°C, Pressure: 2.45 MPa
</code></pre>

        <h2>2.4 å®Ÿè£…ä¾‹3ï¼šæ™‚ç³»åˆ—ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ï¼ˆInfluxDBï¼‰çµ±åˆ</h2>

        <p>InfluxDBã¯é«˜æ€§èƒ½ãªæ™‚ç³»åˆ—ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã§ã€ã‚»ãƒ³ã‚µãƒ¼ãƒ‡ãƒ¼ã‚¿ã®é•·æœŸä¿å­˜ã¨ã‚¯ã‚¨ãƒªã«æœ€é©ã§ã™ã€‚</p>

        <pre><code>"""
Example 3: InfluxDBæ™‚ç³»åˆ—ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹çµ±åˆ
ã‚»ãƒ³ã‚µãƒ¼ãƒ‡ãƒ¼ã‚¿ã®åŠ¹ç‡çš„ãªä¿å­˜ã¨é«˜é€Ÿã‚¯ã‚¨ãƒª
"""

from influxdb_client import InfluxDBClient, Point
from influxdb_client.client.write_api import SYNCHRONOUS
from datetime import datetime, timedelta
import pandas as pd
from typing import List, Dict


class ReactorDataStore:
    """InfluxDBã‚’ä½¿ã£ãŸåå¿œå™¨ãƒ‡ãƒ¼ã‚¿ã®ä¿å­˜ãƒ»å–å¾—

    ã‚»ãƒ³ã‚µãƒ¼ãƒ‡ãƒ¼ã‚¿ã‚’æ™‚ç³»åˆ—ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«ä¿å­˜ã—ã€
    Digital Twinç”¨ã®é«˜é€Ÿã‚¯ã‚¨ãƒªã‚’å®Ÿç¾ã—ã¾ã™ã€‚
    """

    def __init__(self, url: str, token: str, org: str, bucket: str):
        """
        Args:
            url: InfluxDBã®URLï¼ˆä¾‹: "http://localhost:8086"ï¼‰
            token: èªè¨¼ãƒˆãƒ¼ã‚¯ãƒ³
            org: çµ„ç¹”å
            bucket: ãƒã‚±ãƒƒãƒˆåï¼ˆãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹åã«ç›¸å½“ï¼‰
        """
        self.client = InfluxDBClient(url=url, token=token, org=org)
        self.org = org
        self.bucket = bucket
        self.write_api = self.client.write_api(write_options=SYNCHRONOUS)
        self.query_api = self.client.query_api()

    def write_sensor_data(self, reactor_id: str, sensor_type: str,
                         value: float, unit: str, quality: str = "Good"):
        """ã‚»ãƒ³ã‚µãƒ¼ãƒ‡ãƒ¼ã‚¿ã‚’æ›¸ãè¾¼ã¿

        Args:
            reactor_id: åå¿œå™¨IDï¼ˆä¾‹: "R101"ï¼‰
            sensor_type: ã‚»ãƒ³ã‚µãƒ¼ã‚¿ã‚¤ãƒ—ï¼ˆä¾‹: "temperature"ï¼‰
            value: æ¸¬å®šå€¤
            unit: å˜ä½ï¼ˆä¾‹: "degC"ï¼‰
            quality: ãƒ‡ãƒ¼ã‚¿å“è³ªï¼ˆ"Good", "Bad", "Uncertain"ï¼‰
        """
        point = (
            Point("reactor_sensor")
            .tag("reactor_id", reactor_id)
            .tag("sensor_type", sensor_type)
            .tag("unit", unit)
            .tag("quality", quality)
            .field("value", value)
            .time(datetime.utcnow())
        )

        self.write_api.write(bucket=self.bucket, record=point)

    def write_batch_data(self, data_points: List[Dict]):
        """è¤‡æ•°ãƒ‡ãƒ¼ã‚¿ãƒã‚¤ãƒ³ãƒˆã‚’ãƒãƒƒãƒæ›¸ãè¾¼ã¿ï¼ˆé«˜é€ŸåŒ–ï¼‰

        Args:
            data_points: [{'reactor_id': 'R101', 'sensor_type': 'temperature', ...}]
        """
        points = []
        for dp in data_points:
            point = (
                Point("reactor_sensor")
                .tag("reactor_id", dp['reactor_id'])
                .tag("sensor_type", dp['sensor_type'])
                .tag("unit", dp.get('unit', ''))
                .field("value", dp['value'])
                .time(dp.get('timestamp', datetime.utcnow()))
            )
            points.append(point)

        self.write_api.write(bucket=self.bucket, record=points)

    def query_latest_value(self, reactor_id: str, sensor_type: str) -> Dict:
        """æœ€æ–°ã®ã‚»ãƒ³ã‚µãƒ¼å€¤ã‚’å–å¾—

        Args:
            reactor_id: åå¿œå™¨ID
            sensor_type: ã‚»ãƒ³ã‚µãƒ¼ã‚¿ã‚¤ãƒ—

        Returns:
            {'time': '2025-10-26T10:30:15', 'value': 85.3, 'unit': 'degC'}
        """
        query = f'''
        from(bucket: "{self.bucket}")
          |> range(start: -1h)
          |> filter(fn: (r) => r._measurement == "reactor_sensor")
          |> filter(fn: (r) => r.reactor_id == "{reactor_id}")
          |> filter(fn: (r) => r.sensor_type == "{sensor_type}")
          |> last()
        '''

        result = self.query_api.query(query=query, org=self.org)

        if result and len(result) > 0 and len(result[0].records) > 0:
            record = result[0].records[0]
            return {
                'time': record.get_time().isoformat(),
                'value': record.get_value(),
                'unit': record.values.get('unit', ''),
                'quality': record.values.get('quality', 'Unknown')
            }
        return None

    def query_time_range(self, reactor_id: str, sensor_type: str,
                        start: datetime, end: datetime) -> pd.DataFrame:
        """æŒ‡å®šæœŸé–“ã®ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã—ã¦DataFrameã«å¤‰æ›

        Args:
            reactor_id: åå¿œå™¨ID
            sensor_type: ã‚»ãƒ³ã‚µãƒ¼ã‚¿ã‚¤ãƒ—
            start: é–‹å§‹æ™‚åˆ»
            end: çµ‚äº†æ™‚åˆ»

        Returns:
            pd.DataFrame with columns ['time', 'value', 'unit']
        """
        query = f'''
        from(bucket: "{self.bucket}")
          |> range(start: {start.isoformat()}Z, stop: {end.isoformat()}Z)
          |> filter(fn: (r) => r._measurement == "reactor_sensor")
          |> filter(fn: (r) => r.reactor_id == "{reactor_id}")
          |> filter(fn: (r) => r.sensor_type == "{sensor_type}")
        '''

        result = self.query_api.query_data_frame(query=query, org=self.org)

        if not result.empty:
            # å¿…è¦ãªåˆ—ã®ã¿æŠ½å‡º
            df = result[['_time', '_value', 'unit']].copy()
            df.columns = ['time', 'value', 'unit']
            return df

        return pd.DataFrame(columns=['time', 'value', 'unit'])

    def query_aggregated_data(self, reactor_id: str, sensor_type: str,
                             window: str = "1m") -> pd.DataFrame:
        """é›†è¨ˆãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ï¼ˆå¹³å‡ã€æœ€å¤§ã€æœ€å°ï¼‰

        Args:
            reactor_id: åå¿œå™¨ID
            sensor_type: ã‚»ãƒ³ã‚µãƒ¼ã‚¿ã‚¤ãƒ—
            window: é›†è¨ˆã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ï¼ˆä¾‹: "1m", "5m", "1h"ï¼‰

        Returns:
            pd.DataFrame with columns ['time', 'mean', 'max', 'min']
        """
        query = f'''
        from(bucket: "{self.bucket}")
          |> range(start: -24h)
          |> filter(fn: (r) => r._measurement == "reactor_sensor")
          |> filter(fn: (r) => r.reactor_id == "{reactor_id}")
          |> filter(fn: (r) => r.sensor_type == "{sensor_type}")
          |> aggregateWindow(every: {window}, fn: mean, createEmpty: false)
        '''

        result = self.query_api.query_data_frame(query=query, org=self.org)

        if not result.empty:
            df = result[['_time', '_value']].copy()
            df.columns = ['time', 'mean']
            return df

        return pd.DataFrame(columns=['time', 'mean'])

    def close(self):
        """ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶šã‚’ã‚¯ãƒ­ãƒ¼ã‚º"""
        self.client.close()


# ä½¿ç”¨ä¾‹
if __name__ == "__main__":
    # InfluxDBã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã®åˆæœŸåŒ–
    db = ReactorDataStore(
        url="http://localhost:8086",
        token="your_influxdb_token",
        org="your_org",
        bucket="reactor_data"
    )

    try:
        # å˜ä¸€ãƒ‡ãƒ¼ã‚¿ãƒã‚¤ãƒ³ãƒˆã®æ›¸ãè¾¼ã¿
        db.write_sensor_data(
            reactor_id="R101",
            sensor_type="temperature",
            value=85.3,
            unit="degC"
        )

        # ãƒãƒƒãƒæ›¸ãè¾¼ã¿ï¼ˆåŠ¹ç‡çš„ï¼‰
        batch_data = [
            {'reactor_id': 'R101', 'sensor_type': 'temperature', 'value': 85.5, 'unit': 'degC'},
            {'reactor_id': 'R101', 'sensor_type': 'pressure', 'value': 2.45, 'unit': 'MPa'},
            {'reactor_id': 'R101', 'sensor_type': 'flow_rate', 'value': 120.5, 'unit': 'L/min'},
        ]
        db.write_batch_data(batch_data)

        # æœ€æ–°å€¤ã®å–å¾—
        latest = db.query_latest_value("R101", "temperature")
        print(f"æœ€æ–°æ¸©åº¦: {latest['value']} {latest['unit']} at {latest['time']}")

        # éå»1æ™‚é–“ã®ãƒ‡ãƒ¼ã‚¿å–å¾—
        end_time = datetime.utcnow()
        start_time = end_time - timedelta(hours=1)

        df = db.query_time_range("R101", "temperature", start_time, end_time)
        print(f"\néå»1æ™‚é–“ã®ãƒ‡ãƒ¼ã‚¿ãƒã‚¤ãƒ³ãƒˆæ•°: {len(df)}")
        print(df.head())

        # 1åˆ†é–“éš”ã®é›†è¨ˆãƒ‡ãƒ¼ã‚¿
        agg_df = db.query_aggregated_data("R101", "temperature", window="1m")
        print(f"\n1åˆ†å¹³å‡ãƒ‡ãƒ¼ã‚¿ï¼ˆç›´è¿‘24æ™‚é–“ï¼‰:")
        print(agg_df.tail())

    finally:
        db.close()

# æœŸå¾…ã•ã‚Œã‚‹å‡ºåŠ›ä¾‹:
# æœ€æ–°æ¸©åº¦: 85.5 degC at 2025-10-26T10:30:15.123456
#
# éå»1æ™‚é–“ã®ãƒ‡ãƒ¼ã‚¿ãƒã‚¤ãƒ³ãƒˆæ•°: 3600
#                       time  value  unit
# 0 2025-10-26 09:30:15.123   85.1  degC
# 1 2025-10-26 09:30:16.234   85.2  degC
# 2 2025-10-26 09:30:17.345   85.3  degC
#
# 1åˆ†å¹³å‡ãƒ‡ãƒ¼ã‚¿ï¼ˆç›´è¿‘24æ™‚é–“ï¼‰:
#                       time   mean
# 1436 2025-10-26 10:26:00  85.2
# 1437 2025-10-26 10:27:00  85.3
# 1438 2025-10-26 10:28:00  85.4
# 1439 2025-10-26 10:29:00  85.5
# 1440 2025-10-26 10:30:00  85.5
</code></pre>

        <h2>2.5 å®Ÿè£…ä¾‹4ï¼šãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ‡ãƒ¼ã‚¿æ¤œè¨¼ã¨ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°</h2>

        <p>ã‚»ãƒ³ã‚µãƒ¼ãƒ‡ãƒ¼ã‚¿ã«ã¯å¿…ãšãƒã‚¤ã‚ºã‚„ç•°å¸¸å€¤ãŒå«ã¾ã‚Œã¾ã™ã€‚Digital Twinã«é€ã‚‹å‰ã«å“è³ªãƒã‚§ãƒƒã‚¯ãŒå¿…è¦ã§ã™ã€‚</p>

        <pre><code>"""
Example 4: ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ‡ãƒ¼ã‚¿æ¤œè¨¼ã¨ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°
ã‚»ãƒ³ã‚µãƒ¼ãƒ‡ãƒ¼ã‚¿ã®å“è³ªãƒã‚§ãƒƒã‚¯ã€ç•°å¸¸å€¤æ¤œå‡ºã€æ¬ æå€¤è£œå®Œ
"""

import numpy as np
import pandas as pd
from typing import Optional, Dict, Tuple
from dataclasses import dataclass
from enum import Enum


class DataQuality(Enum):
    """ãƒ‡ãƒ¼ã‚¿å“è³ªãƒ¬ãƒ™ãƒ«"""
    GOOD = "Good"           # æ­£å¸¸ãƒ‡ãƒ¼ã‚¿
    UNCERTAIN = "Uncertain" # ä¸ç¢ºå®Ÿï¼ˆè£œæ­£æ¸ˆã¿ï¼‰
    BAD = "Bad"            # ç•°å¸¸ãƒ‡ãƒ¼ã‚¿ï¼ˆä½¿ç”¨ä¸å¯ï¼‰


@dataclass
class SensorReading:
    """ã‚»ãƒ³ã‚µãƒ¼èª­ã¿å–ã‚Šå€¤"""
    reactor_id: str
    sensor_type: str
    value: float
    unit: str
    timestamp: str
    quality: DataQuality = DataQuality.GOOD


class DataValidator:
    """ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ‡ãƒ¼ã‚¿æ¤œè¨¼ãƒ»ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°

    ç‰©ç†çš„åˆ¶ç´„ãƒã‚§ãƒƒã‚¯ã€çµ±è¨ˆçš„å¤–ã‚Œå€¤æ¤œå‡ºã€
    æ¬ æå€¤è£œå®Œã‚’å®Ÿè¡Œã—ã¦ãƒ‡ãƒ¼ã‚¿å“è³ªã‚’ä¿è¨¼ã—ã¾ã™ã€‚
    """

    def __init__(self):
        # ã‚»ãƒ³ã‚µãƒ¼ã”ã¨ã®ç‰©ç†çš„ç¯„å›²ï¼ˆãƒ—ãƒ­ã‚»ã‚¹çŸ¥è­˜ã«åŸºã¥ãï¼‰
        self.physical_ranges = {
            'temperature': {'min': -50, 'max': 400, 'unit': 'degC'},
            'pressure': {'min': 0, 'max': 10, 'unit': 'MPa'},
            'flow_rate': {'min': 0, 'max': 500, 'unit': 'L/min'},
            'ph': {'min': 0, 'max': 14, 'unit': ''},
        }

        # ç§»å‹•å¹³å‡ç”¨ã®å±¥æ­´ãƒ‡ãƒ¼ã‚¿ï¼ˆæœ€å¤§100ãƒã‚¤ãƒ³ãƒˆï¼‰
        self.history: Dict[str, list] = {}
        self.max_history = 100

    def validate_physical_range(self, reading: SensorReading) -> Tuple[bool, str]:
        """ç‰©ç†çš„ç¯„å›²ãƒã‚§ãƒƒã‚¯

        Args:
            reading: ã‚»ãƒ³ã‚µãƒ¼èª­ã¿å–ã‚Šå€¤

        Returns:
            (is_valid, message)
        """
        if reading.sensor_type not in self.physical_ranges:
            return True, "Range not defined"

        range_info = self.physical_ranges[reading.sensor_type]
        value = reading.value

        if value < range_info['min'] or value > range_info['max']:
            msg = (f"{reading.sensor_type}ãŒç‰©ç†çš„ç¯„å›²å¤–: {value} "
                   f"(è¨±å®¹ç¯„å›²: {range_info['min']}-{range_info['max']} {range_info['unit']})")
            return False, msg

        return True, "OK"

    def detect_outlier_zscore(self, reading: SensorReading,
                             threshold: float = 3.0) -> Tuple[bool, str]:
        """Z-scoreã«ã‚ˆã‚‹çµ±è¨ˆçš„å¤–ã‚Œå€¤æ¤œå‡º

        Args:
            reading: ã‚»ãƒ³ã‚µãƒ¼èª­ã¿å–ã‚Šå€¤
            threshold: Z-scoreã®ã—ãã„å€¤ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ3.0ï¼‰

        Returns:
            (is_outlier, message)
        """
        key = f"{reading.reactor_id}_{reading.sensor_type}"

        # å±¥æ­´ãƒ‡ãƒ¼ã‚¿ã«è¿½åŠ 
        if key not in self.history:
            self.history[key] = []

        self.history[key].append(reading.value)

        # å±¥æ­´ãŒå°‘ãªã„å ´åˆã¯åˆ¤å®šä¸å¯
        if len(self.history[key]) < 10:
            return False, "Insufficient history"

        # æœ€æ–°100ãƒã‚¤ãƒ³ãƒˆã®ã¿ä¿æŒ
        if len(self.history[key]) > self.max_history:
            self.history[key] = self.history[key][-self.max_history:]

        # Z-scoreè¨ˆç®—
        values = np.array(self.history[key])
        mean = np.mean(values)
        std = np.std(values)

        if std < 1e-6:  # æ¨™æº–åå·®ãŒã‚¼ãƒ­ã«è¿‘ã„å ´åˆ
            return False, "Constant values"

        z_score = abs((reading.value - mean) / std)

        if z_score > threshold:
            msg = f"å¤–ã‚Œå€¤æ¤œå‡º: Z-score={z_score:.2f} (threshold={threshold})"
            return True, msg

        return False, f"OK (Z-score={z_score:.2f})"

    def detect_spike(self, reading: SensorReading,
                    max_change_rate: float = 0.2) -> Tuple[bool, str]:
        """æ€¥æ¿€ãªå¤‰åŒ–ï¼ˆã‚¹ãƒ‘ã‚¤ã‚¯ï¼‰ã®æ¤œå‡º

        Args:
            reading: ã‚»ãƒ³ã‚µãƒ¼èª­ã¿å–ã‚Šå€¤
            max_change_rate: è¨±å®¹å¤‰åŒ–ç‡ï¼ˆä¾‹: 0.2 = 20%ï¼‰

        Returns:
            (is_spike, message)
        """
        key = f"{reading.reactor_id}_{reading.sensor_type}"

        if key not in self.history or len(self.history[key]) == 0:
            return False, "No previous value"

        previous_value = self.history[key][-1]

        # ã‚¼ãƒ­é™¤ç®—ã‚’é¿ã‘ã‚‹
        if abs(previous_value) < 1e-6:
            return False, "Previous value near zero"

        # å¤‰åŒ–ç‡ã‚’è¨ˆç®—
        change_rate = abs((reading.value - previous_value) / previous_value)

        if change_rate > max_change_rate:
            msg = f"æ€¥æ¿€ãªå¤‰åŒ–æ¤œå‡º: {change_rate*100:.1f}% (è¨±å®¹: {max_change_rate*100:.1f}%)"
            return True, msg

        return False, f"OK (å¤‰åŒ–ç‡: {change_rate*100:.1f}%)"

    def interpolate_missing_value(self, reactor_id: str,
                                 sensor_type: str) -> Optional[float]:
        """æ¬ æå€¤ã‚’ç·šå½¢è£œé–“

        Args:
            reactor_id: åå¿œå™¨ID
            sensor_type: ã‚»ãƒ³ã‚µãƒ¼ã‚¿ã‚¤ãƒ—

        Returns:
            è£œé–“å€¤ï¼ˆå±¥æ­´ãŒãªã„å ´åˆã¯Noneï¼‰
        """
        key = f"{reactor_id}_{sensor_type}"

        if key not in self.history or len(self.history[key]) < 2:
            return None

        # æœ€æ–°2ç‚¹ã®å¹³å‡å€¤ã§è£œé–“ï¼ˆç°¡æ˜“çš„ï¼‰
        recent_values = self.history[key][-2:]
        interpolated = np.mean(recent_values)

        return interpolated

    def validate(self, reading: SensorReading) -> SensorReading:
        """ç·åˆæ¤œè¨¼ã‚’å®Ÿè¡Œã—ã¦ãƒ‡ãƒ¼ã‚¿å“è³ªã‚’åˆ¤å®š

        Args:
            reading: ã‚»ãƒ³ã‚µãƒ¼èª­ã¿å–ã‚Šå€¤

        Returns:
            å“è³ªãƒ•ãƒ©ã‚°ã‚’æ›´æ–°ã—ãŸSensorReading
        """
        # 1. ç‰©ç†çš„ç¯„å›²ãƒã‚§ãƒƒã‚¯
        is_valid, msg = self.validate_physical_range(reading)
        if not is_valid:
            print(f"[BAD] {msg}")
            reading.quality = DataQuality.BAD
            return reading

        # 2. å¤–ã‚Œå€¤æ¤œå‡º
        is_outlier, msg = self.detect_outlier_zscore(reading)
        if is_outlier:
            print(f"[UNCERTAIN] {msg}")
            reading.quality = DataQuality.UNCERTAIN

        # 3. ã‚¹ãƒ‘ã‚¤ã‚¯æ¤œå‡º
        is_spike, msg = self.detect_spike(reading)
        if is_spike:
            print(f"[UNCERTAIN] {msg}")
            reading.quality = DataQuality.UNCERTAIN

        return reading


# ä½¿ç”¨ä¾‹
if __name__ == "__main__":
    validator = DataValidator()

    # æ­£å¸¸ãƒ‡ãƒ¼ã‚¿ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
    print("=== æ­£å¸¸ãƒ‡ãƒ¼ã‚¿ ===")
    for i in range(5):
        reading = SensorReading(
            reactor_id="R101",
            sensor_type="temperature",
            value=85.0 + np.random.normal(0, 0.5),  # å¹³å‡85â„ƒã€æ¨™æº–åå·®0.5â„ƒ
            unit="degC",
            timestamp=f"2025-10-26T10:30:{i:02d}"
        )
        validated = validator.validate(reading)
        print(f"Time {i}: {validated.value:.2f}Â°C - Quality: {validated.quality.value}")

    # ç‰©ç†çš„ç¯„å›²å¤–ã®ãƒ‡ãƒ¼ã‚¿
    print("\n=== ç‰©ç†çš„ç¯„å›²å¤–ãƒ‡ãƒ¼ã‚¿ ===")
    bad_reading = SensorReading(
        reactor_id="R101",
        sensor_type="temperature",
        value=500.0,  # ç¯„å›²å¤–ï¼ˆmax 400â„ƒï¼‰
        unit="degC",
        timestamp="2025-10-26T10:30:10"
    )
    validated = validator.validate(bad_reading)
    print(f"Value: {validated.value}Â°C - Quality: {validated.quality.value}")

    # å¤–ã‚Œå€¤ï¼ˆã‚¹ãƒ‘ã‚¤ã‚¯ï¼‰
    print("\n=== ã‚¹ãƒ‘ã‚¤ã‚¯ãƒ‡ãƒ¼ã‚¿ ===")
    spike_reading = SensorReading(
        reactor_id="R101",
        sensor_type="temperature",
        value=120.0,  # æ€¥æ¿€ãªä¸Šæ˜‡
        unit="degC",
        timestamp="2025-10-26T10:30:15"
    )
    validated = validator.validate(spike_reading)
    print(f"Value: {validated.value}Â°C - Quality: {validated.quality.value}")

    # æ¬ æå€¤ã®è£œé–“
    print("\n=== æ¬ æå€¤è£œé–“ ===")
    interpolated = validator.interpolate_missing_value("R101", "temperature")
    if interpolated:
        print(f"è£œé–“å€¤: {interpolated:.2f}Â°C")

# æœŸå¾…ã•ã‚Œã‚‹å‡ºåŠ›ä¾‹:
# === æ­£å¸¸ãƒ‡ãƒ¼ã‚¿ ===
# Time 0: 85.23Â°C - Quality: Good
# Time 1: 84.87Â°C - Quality: Good
# Time 2: 85.41Â°C - Quality: Good
# Time 3: 85.12Â°C - Quality: Good
# Time 4: 84.95Â°C - Quality: Good
#
# === ç‰©ç†çš„ç¯„å›²å¤–ãƒ‡ãƒ¼ã‚¿ ===
# [BAD] temperatureãŒç‰©ç†çš„ç¯„å›²å¤–: 500.0 (è¨±å®¹ç¯„å›²: -50-400 degC)
# Value: 500.0Â°C - Quality: Bad
#
# === ã‚¹ãƒ‘ã‚¤ã‚¯ãƒ‡ãƒ¼ã‚¿ ===
# [UNCERTAIN] æ€¥æ¿€ãªå¤‰åŒ–æ¤œå‡º: 41.2% (è¨±å®¹: 20.0%)
# Value: 120.0Â°C - Quality: Uncertain
#
# === æ¬ æå€¤è£œé–“ ===
# è£œé–“å€¤: 85.04Â°C
</code></pre>

        <h2>2.6 å®Ÿè£…ä¾‹5ï¼šãƒ‡ãƒ¼ã‚¿ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³</h2>

        <p>Kafkaé¢¨ã®ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°å‡¦ç†ã§ã€è¤‡æ•°ã®ã‚»ãƒ³ã‚µãƒ¼ã‹ã‚‰ã®ãƒ‡ãƒ¼ã‚¿ã‚’çµ±åˆçš„ã«å‡¦ç†ã—ã¾ã™ã€‚</p>

        <pre><code>"""
Example 5: ãƒ‡ãƒ¼ã‚¿ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³
è¤‡æ•°ã‚»ãƒ³ã‚µãƒ¼ã‹ã‚‰ã®ãƒ‡ãƒ¼ã‚¿ã‚’ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã«å‡¦ç†ãƒ»é…ä¿¡
"""

from queue import Queue
from threading import Thread, Event
from typing import Callable, List
import time
from datetime import datetime
import json


class DataStream:
    """ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ‡ãƒ¼ã‚¿ã‚¹ãƒˆãƒªãƒ¼ãƒ 

    ã‚»ãƒ³ã‚µãƒ¼ãƒ‡ãƒ¼ã‚¿ã‚’ã‚­ãƒ¥ãƒ¼ã§å—ã‘å–ã‚Šã€è¤‡æ•°ã®å‡¦ç†ã‚’
    ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³å½¢å¼ã§å®Ÿè¡Œã—ã¾ã™ã€‚
    """

    def __init__(self, name: str, buffer_size: int = 1000):
        """
        Args:
            name: ã‚¹ãƒˆãƒªãƒ¼ãƒ å
            buffer_size: ãƒãƒƒãƒ•ã‚¡ã‚µã‚¤ã‚ºï¼ˆã‚­ãƒ¥ãƒ¼ã®æœ€å¤§é•·ï¼‰
        """
        self.name = name
        self.queue = Queue(maxsize=buffer_size)
        self.processors: List[Callable] = []
        self.is_running = Event()
        self.worker_thread = None

    def add_processor(self, processor: Callable):
        """ãƒ‡ãƒ¼ã‚¿å‡¦ç†é–¢æ•°ã‚’è¿½åŠ 

        Args:
            processor: ãƒ‡ãƒ¼ã‚¿ã‚’å—ã‘å–ã£ã¦å‡¦ç†ã™ã‚‹é–¢æ•° processor(data)
        """
        self.processors.append(processor)

    def publish(self, data: dict):
        """ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¹ãƒˆãƒªãƒ¼ãƒ ã«é€ä¿¡

        Args:
            data: ã‚»ãƒ³ã‚µãƒ¼ãƒ‡ãƒ¼ã‚¿è¾æ›¸
        """
        try:
            self.queue.put(data, timeout=1)
        except Exception as e:
            print(f"[{self.name}] ã‚­ãƒ¥ãƒ¼ãŒãƒ•ãƒ«: {e}")

    def _process_loop(self):
        """ãƒ‡ãƒ¼ã‚¿å‡¦ç†ãƒ«ãƒ¼ãƒ—ï¼ˆåˆ¥ã‚¹ãƒ¬ãƒƒãƒ‰ã§å®Ÿè¡Œï¼‰"""
        while self.is_running.is_set():
            try:
                # ã‚­ãƒ¥ãƒ¼ã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ï¼ˆ1ç§’ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆï¼‰
                data = self.queue.get(timeout=1)

                # ã™ã¹ã¦ã®å‡¦ç†é–¢æ•°ã‚’é †æ¬¡å®Ÿè¡Œ
                for processor in self.processors:
                    try:
                        data = processor(data)
                        if data is None:  # å‡¦ç†ã§ãƒ•ã‚£ãƒ«ã‚¿ã•ã‚ŒãŸå ´åˆ
                            break
                    except Exception as e:
                        print(f"[{self.name}] å‡¦ç†ã‚¨ãƒ©ãƒ¼: {e}")
                        break

            except Exception:
                # ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆï¼ˆãƒ‡ãƒ¼ã‚¿ãªã—ï¼‰â†’ ç¶™ç¶š
                continue

    def start(self):
        """ã‚¹ãƒˆãƒªãƒ¼ãƒ å‡¦ç†ã‚’é–‹å§‹"""
        if self.worker_thread and self.worker_thread.is_alive():
            print(f"[{self.name}] æ—¢ã«å®Ÿè¡Œä¸­ã§ã™")
            return

        self.is_running.set()
        self.worker_thread = Thread(target=self._process_loop, daemon=True)
        self.worker_thread.start()
        print(f"[{self.name}] ã‚¹ãƒˆãƒªãƒ¼ãƒ å‡¦ç†ã‚’é–‹å§‹")

    def stop(self):
        """ã‚¹ãƒˆãƒªãƒ¼ãƒ å‡¦ç†ã‚’åœæ­¢"""
        self.is_running.clear()
        if self.worker_thread:
            self.worker_thread.join(timeout=5)
        print(f"[{self.name}] ã‚¹ãƒˆãƒªãƒ¼ãƒ å‡¦ç†ã‚’åœæ­¢")


class StreamingPipeline:
    """è¤‡æ•°ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ç®¡ç†ã™ã‚‹ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³"""

    def __init__(self):
        self.streams = {}

    def create_stream(self, name: str) -> DataStream:
        """æ–°ã—ã„ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ä½œæˆ

        Args:
            name: ã‚¹ãƒˆãƒªãƒ¼ãƒ å

        Returns:
            DataStreamã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
        """
        stream = DataStream(name)
        self.streams[name] = stream
        return stream

    def start_all(self):
        """ã™ã¹ã¦ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’é–‹å§‹"""
        for stream in self.streams.values():
            stream.start()

    def stop_all(self):
        """ã™ã¹ã¦ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’åœæ­¢"""
        for stream in self.streams.values():
            stream.stop()


# ãƒ‡ãƒ¼ã‚¿å‡¦ç†é–¢æ•°ã®ä¾‹
def enrich_with_metadata(data: dict) -> dict:
    """ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’è¿½åŠ """
    data['processed_at'] = datetime.now().isoformat()
    data['pipeline'] = 'streaming_v1'
    return data


def filter_bad_quality(data: dict) -> dict:
    """å“è³ªãŒæ‚ªã„ãƒ‡ãƒ¼ã‚¿ã‚’ãƒ•ã‚£ãƒ«ã‚¿"""
    if data.get('quality') == 'Bad':
        print(f"ä¸è‰¯ãƒ‡ãƒ¼ã‚¿ã‚’ãƒ•ã‚£ãƒ«ã‚¿: {data}")
        return None  # None = ã“ã®ãƒ‡ãƒ¼ã‚¿ã¯ç ´æ£„
    return data


def aggregate_1sec_window(data: dict) -> dict:
    """1ç§’ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã§é›†è¨ˆï¼ˆç°¡æ˜“ç‰ˆï¼‰"""
    # å®Ÿéš›ã¯æ™‚é–“çª“ã§è¤‡æ•°ãƒ‡ãƒ¼ã‚¿ã‚’é›†è¨ˆ
    data['aggregation'] = '1sec_mean'
    return data


def send_to_digital_twin(data: dict) -> dict:
    """Digital Twinãƒ¢ãƒ‡ãƒ«ã«é€ä¿¡"""
    print(f"Digital Twinã«é€ä¿¡: {data['reactor_id']}.{data['sensor_type']} = {data['value']}")
    # å®Ÿéš›ã¯Digital Twinã®APIã‚’å‘¼ã³å‡ºã—
    return data


def save_to_database(data: dict) -> dict:
    """ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«ä¿å­˜"""
    # å®Ÿéš›ã¯InfluxDBç­‰ã«ä¿å­˜
    print(f"DBã«ä¿å­˜: {json.dumps(data, ensure_ascii=False)}")
    return data


# ä½¿ç”¨ä¾‹
if __name__ == "__main__":
    # ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®ä½œæˆ
    pipeline = StreamingPipeline()

    # æ¸©åº¦ãƒ‡ãƒ¼ã‚¿ã‚¹ãƒˆãƒªãƒ¼ãƒ 
    temp_stream = pipeline.create_stream("temperature_stream")
    temp_stream.add_processor(enrich_with_metadata)
    temp_stream.add_processor(filter_bad_quality)
    temp_stream.add_processor(aggregate_1sec_window)
    temp_stream.add_processor(send_to_digital_twin)
    temp_stream.add_processor(save_to_database)

    # åœ§åŠ›ãƒ‡ãƒ¼ã‚¿ã‚¹ãƒˆãƒªãƒ¼ãƒ 
    pres_stream = pipeline.create_stream("pressure_stream")
    pres_stream.add_processor(enrich_with_metadata)
    pres_stream.add_processor(filter_bad_quality)
    pres_stream.add_processor(send_to_digital_twin)

    # ã™ã¹ã¦ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’é–‹å§‹
    pipeline.start_all()

    try:
        # ã‚»ãƒ³ã‚µãƒ¼ãƒ‡ãƒ¼ã‚¿ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
        for i in range(10):
            # æ¸©åº¦ãƒ‡ãƒ¼ã‚¿
            temp_data = {
                'reactor_id': 'R101',
                'sensor_type': 'temperature',
                'value': 85.0 + i * 0.1,
                'unit': 'degC',
                'quality': 'Good' if i < 8 else 'Bad',  # 8ç•ªç›®ä»¥é™ã¯ä¸è‰¯
                'timestamp': datetime.now().isoformat()
            }
            temp_stream.publish(temp_data)

            # åœ§åŠ›ãƒ‡ãƒ¼ã‚¿
            pres_data = {
                'reactor_id': 'R101',
                'sensor_type': 'pressure',
                'value': 2.45 + i * 0.01,
                'unit': 'MPa',
                'quality': 'Good',
                'timestamp': datetime.now().isoformat()
            }
            pres_stream.publish(pres_data)

            time.sleep(0.5)  # 0.5ç§’é–“éš”ã§ãƒ‡ãƒ¼ã‚¿é€ä¿¡

        # å‡¦ç†ãŒå®Œäº†ã™ã‚‹ã¾ã§å¾…æ©Ÿ
        time.sleep(2)

    finally:
        # ã™ã¹ã¦ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’åœæ­¢
        pipeline.stop_all()

# æœŸå¾…ã•ã‚Œã‚‹å‡ºåŠ›ä¾‹:
# [temperature_stream] ã‚¹ãƒˆãƒªãƒ¼ãƒ å‡¦ç†ã‚’é–‹å§‹
# [pressure_stream] ã‚¹ãƒˆãƒªãƒ¼ãƒ å‡¦ç†ã‚’é–‹å§‹
# Digital Twinã«é€ä¿¡: R101.temperature = 85.0
# DBã«ä¿å­˜: {"reactor_id": "R101", "sensor_type": "temperature", "value": 85.0, ...}
# Digital Twinã«é€ä¿¡: R101.pressure = 2.45
# Digital Twinã«é€ä¿¡: R101.temperature = 85.1
# DBã«ä¿å­˜: {"reactor_id": "R101", "sensor_type": "temperature", "value": 85.1, ...}
# ...
# ä¸è‰¯ãƒ‡ãƒ¼ã‚¿ã‚’ãƒ•ã‚£ãƒ«ã‚¿: {'reactor_id': 'R101', 'sensor_type': 'temperature', 'value': 85.8, 'quality': 'Bad'}
# ä¸è‰¯ãƒ‡ãƒ¼ã‚¿ã‚’ãƒ•ã‚£ãƒ«ã‚¿: {'reactor_id': 'R101', 'sensor_type': 'temperature', 'value': 85.9, 'quality': 'Bad'}
# [temperature_stream] ã‚¹ãƒˆãƒªãƒ¼ãƒ å‡¦ç†ã‚’åœæ­¢
# [pressure_stream] ã‚¹ãƒˆãƒªãƒ¼ãƒ å‡¦ç†ã‚’åœæ­¢
</code></pre>

        <h2>2.7 å®Ÿè£…ä¾‹6ï¼šã‚«ãƒ«ãƒãƒ³ãƒ•ã‚£ãƒ«ã‚¿ã«ã‚ˆã‚‹çŠ¶æ…‹æ¨å®š</h2>

        <p>ãƒã‚¤ã‚ºã‚’å«ã‚€ã‚»ãƒ³ã‚µãƒ¼ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰ã€çœŸã®çŠ¶æ…‹ã‚’æ¨å®šã™ã‚‹ã‚«ãƒ«ãƒãƒ³ãƒ•ã‚£ãƒ«ã‚¿ã®å®Ÿè£…ã§ã™ã€‚</p>

        <pre><code>"""
Example 6: ã‚«ãƒ«ãƒãƒ³ãƒ•ã‚£ãƒ«ã‚¿ã«ã‚ˆã‚‹çŠ¶æ…‹æ¨å®š
ãƒã‚¤ã‚ºã‚’å«ã‚€ã‚»ãƒ³ã‚µãƒ¼ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰åå¿œå™¨ã®çœŸã®çŠ¶æ…‹ã‚’æ¨å®š
"""

import numpy as np
from dataclasses import dataclass
from typing import Tuple


@dataclass
class KalmanState:
    """ã‚«ãƒ«ãƒãƒ³ãƒ•ã‚£ãƒ«ã‚¿ã®çŠ¶æ…‹"""
    x: np.ndarray      # çŠ¶æ…‹ãƒ™ã‚¯ãƒˆãƒ« [æ¸©åº¦, æ¸©åº¦å¤‰åŒ–ç‡]
    P: np.ndarray      # èª¤å·®å…±åˆ†æ•£è¡Œåˆ—


class ReactorKalmanFilter:
    """åå¿œå™¨çŠ¶æ…‹æ¨å®šç”¨ã‚«ãƒ«ãƒãƒ³ãƒ•ã‚£ãƒ«ã‚¿

    æ¸©åº¦ã‚»ãƒ³ã‚µãƒ¼ã®ãƒã‚¤ã‚ºã‚’é™¤å»ã—ã€çœŸã®æ¸©åº¦ã¨
    æ¸©åº¦å¤‰åŒ–ç‡ã‚’æ¨å®šã—ã¾ã™ã€‚
    """

    def __init__(self,
                 initial_temp: float,
                 process_noise: float = 0.01,
                 measurement_noise: float = 0.5):
        """
        Args:
            initial_temp: åˆæœŸæ¸©åº¦ [â„ƒ]
            process_noise: ãƒ—ãƒ­ã‚»ã‚¹ãƒã‚¤ã‚ºï¼ˆã‚·ã‚¹ãƒ†ãƒ ã®ä¸ç¢ºå®Ÿæ€§ï¼‰
            measurement_noise: æ¸¬å®šãƒã‚¤ã‚ºï¼ˆã‚»ãƒ³ã‚µãƒ¼ãƒã‚¤ã‚ºï¼‰
        """
        # çŠ¶æ…‹ãƒ™ã‚¯ãƒˆãƒ«: [æ¸©åº¦, æ¸©åº¦å¤‰åŒ–ç‡]
        self.state = KalmanState(
            x=np.array([initial_temp, 0.0]),  # [â„ƒ, â„ƒ/s]
            P=np.eye(2) * 1.0                  # åˆæœŸèª¤å·®å…±åˆ†æ•£
        )

        # ã‚·ã‚¹ãƒ†ãƒ ãƒ¢ãƒ‡ãƒ«: x(k+1) = F * x(k) + w
        # dt = 1ç§’ã¨ä»®å®š
        dt = 1.0
        self.F = np.array([
            [1.0, dt],   # æ¸©åº¦(k+1) = æ¸©åº¦(k) + å¤‰åŒ–ç‡(k) * dt
            [0.0, 1.0]   # å¤‰åŒ–ç‡(k+1) = å¤‰åŒ–ç‡(k) ï¼ˆä¸€å®šã¨ä»®å®šï¼‰
        ])

        # è¦³æ¸¬ãƒ¢ãƒ‡ãƒ«: z(k) = H * x(k) + v
        # æ¸©åº¦ã®ã¿è¦³æ¸¬å¯èƒ½
        self.H = np.array([[1.0, 0.0]])

        # ãƒ—ãƒ­ã‚»ã‚¹ãƒã‚¤ã‚ºå…±åˆ†æ•£
        self.Q = np.array([
            [process_noise, 0.0],
            [0.0, process_noise]
        ])

        # æ¸¬å®šãƒã‚¤ã‚ºå…±åˆ†æ•£
        self.R = np.array([[measurement_noise]])

    def predict(self) -> Tuple[float, float]:
        """äºˆæ¸¬ã‚¹ãƒ†ãƒƒãƒ—ï¼ˆã‚·ã‚¹ãƒ†ãƒ ãƒ¢ãƒ‡ãƒ«ã«åŸºã¥ãçŠ¶æ…‹äºˆæ¸¬ï¼‰

        Returns:
            (predicted_temp, predicted_rate) äºˆæ¸¬æ¸©åº¦ã¨å¤‰åŒ–ç‡
        """
        # çŠ¶æ…‹äºˆæ¸¬: x_pred = F * x
        x_pred = self.F @ self.state.x

        # èª¤å·®å…±åˆ†æ•£äºˆæ¸¬: P_pred = F * P * F^T + Q
        P_pred = self.F @ self.state.P @ self.F.T + self.Q

        # äºˆæ¸¬çŠ¶æ…‹ã‚’æ›´æ–°
        self.state.x = x_pred
        self.state.P = P_pred

        return self.state.x[0], self.state.x[1]

    def update(self, measurement: float) -> Tuple[float, float]:
        """æ›´æ–°ã‚¹ãƒ†ãƒƒãƒ—ï¼ˆæ¸¬å®šå€¤ã§çŠ¶æ…‹ã‚’è£œæ­£ï¼‰

        Args:
            measurement: ã‚»ãƒ³ã‚µãƒ¼æ¸¬å®šå€¤ï¼ˆæ¸©åº¦ï¼‰[â„ƒ]

        Returns:
            (estimated_temp, estimated_rate) æ¨å®šæ¸©åº¦ã¨å¤‰åŒ–ç‡
        """
        # ã‚¤ãƒãƒ™ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆäºˆæ¸¬ã¨æ¸¬å®šã®å·®ï¼‰: y = z - H * x_pred
        z = np.array([measurement])
        y = z - self.H @ self.state.x

        # ã‚¤ãƒãƒ™ãƒ¼ã‚·ãƒ§ãƒ³å…±åˆ†æ•£: S = H * P_pred * H^T + R
        S = self.H @ self.state.P @ self.H.T + self.R

        # ã‚«ãƒ«ãƒãƒ³ã‚²ã‚¤ãƒ³: K = P_pred * H^T * S^-1
        K = self.state.P @ self.H.T @ np.linalg.inv(S)

        # çŠ¶æ…‹æ›´æ–°: x = x_pred + K * y
        self.state.x = self.state.x + K @ y

        # èª¤å·®å…±åˆ†æ•£æ›´æ–°: P = (I - K * H) * P_pred
        I = np.eye(2)
        self.state.P = (I - K @ self.H) @ self.state.P

        return self.state.x[0], self.state.x[1]

    def estimate(self, measurement: float) -> Tuple[float, float]:
        """äºˆæ¸¬â†’æ›´æ–°ã®1ã‚µã‚¤ã‚¯ãƒ«ã‚’å®Ÿè¡Œ

        Args:
            measurement: ã‚»ãƒ³ã‚µãƒ¼æ¸¬å®šå€¤ [â„ƒ]

        Returns:
            (estimated_temp, estimated_rate) æ¨å®šæ¸©åº¦ã¨å¤‰åŒ–ç‡
        """
        # äºˆæ¸¬
        self.predict()

        # æ›´æ–°
        return self.update(measurement)


# ä½¿ç”¨ä¾‹
if __name__ == "__main__":
    # ã‚«ãƒ«ãƒãƒ³ãƒ•ã‚£ãƒ«ã‚¿ã®åˆæœŸåŒ–
    kf = ReactorKalmanFilter(
        initial_temp=85.0,
        process_noise=0.01,      # ãƒ—ãƒ­ã‚»ã‚¹ã¯å®‰å®š
        measurement_noise=0.5    # ã‚»ãƒ³ã‚µãƒ¼ãƒã‚¤ã‚ºã¯ä¸­ç¨‹åº¦
    )

    # çœŸã®æ¸©åº¦ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆãƒ©ãƒ³ãƒ—åŠ ç†±: 85â„ƒ â†’ 95â„ƒï¼‰
    time_steps = 50
    true_temps = np.linspace(85.0, 95.0, time_steps)

    # ã‚»ãƒ³ã‚µãƒ¼æ¸¬å®šå€¤ï¼ˆãƒã‚¤ã‚ºã‚ã‚Šï¼‰
    np.random.seed(42)
    noise = np.random.normal(0, 0.5, time_steps)  # æ¨™æº–åå·®0.5â„ƒ
    measured_temps = true_temps + noise

    print("Time\tTrue\tMeasured\tEstimated\tRate")
    print("-" * 60)

    estimated_temps = []
    estimated_rates = []

    for t in range(time_steps):
        # ã‚«ãƒ«ãƒãƒ³ãƒ•ã‚£ãƒ«ã‚¿ã§æ¨å®š
        est_temp, est_rate = kf.estimate(measured_temps[t])
        estimated_temps.append(est_temp)
        estimated_rates.append(est_rate)

        if t % 5 == 0:  # 5ç§’ã”ã¨ã«è¡¨ç¤º
            print(f"{t}\t{true_temps[t]:.2f}\t{measured_temps[t]:.2f}\t\t{est_temp:.2f}\t\t{est_rate:.3f}")

    # ç²¾åº¦è©•ä¾¡
    mse_raw = np.mean((measured_temps - true_temps) ** 2)
    mse_filtered = np.mean((np.array(estimated_temps) - true_temps) ** 2)

    print(f"\n=== ç²¾åº¦è©•ä¾¡ ===")
    print(f"ç”Ÿãƒ‡ãƒ¼ã‚¿ã®MSE: {mse_raw:.4f}")
    print(f"ãƒ•ã‚£ãƒ«ã‚¿å¾Œã®MSE: {mse_filtered:.4f}")
    print(f"ç²¾åº¦æ”¹å–„ç‡: {(1 - mse_filtered/mse_raw) * 100:.1f}%")

# æœŸå¾…ã•ã‚Œã‚‹å‡ºåŠ›ä¾‹:
# Time    True    Measured        Estimated       Rate
# ------------------------------------------------------------
# 0       85.00   85.25           85.13           0.051
# 5       86.02   85.78           85.96           0.192
# 10      87.04   86.92           87.01           0.204
# 15      88.06   88.31           88.08           0.206
# 20      89.08   89.23           89.10           0.204
# 25      90.10   90.35           90.13           0.203
# 30      91.12   90.98           91.14           0.204
# 35      92.14   92.45           92.17           0.203
# 40      93.16   93.08           93.18           0.204
# 45      94.18   94.52           94.21           0.203
#
# === ç²¾åº¦è©•ä¾¡ ===
# ç”Ÿãƒ‡ãƒ¼ã‚¿ã®MSE: 0.2435
# ãƒ•ã‚£ãƒ«ã‚¿å¾Œã®MSE: 0.0089
# ç²¾åº¦æ”¹å–„ç‡: 96.3%
</code></pre>

        <h2>2.8 å®Ÿè£…ä¾‹7ï¼šDigital TwinåŒæœŸãƒ«ãƒ¼ãƒ—</h2>

        <p>ã™ã¹ã¦ã®è¦ç´ ã‚’çµ±åˆã—ã€Digital Twinã¨ã®ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ åŒæœŸã‚’å®Ÿç¾ã™ã‚‹å®Œå…¨ãªå®Ÿè£…ã§ã™ã€‚</p>

        <pre><code>"""
Example 7: Digital TwinåŒæœŸãƒ«ãƒ¼ãƒ—
ã‚»ãƒ³ã‚µãƒ¼ãƒ‡ãƒ¼ã‚¿å–å¾—â†’æ¤œè¨¼â†’çŠ¶æ…‹æ¨å®šâ†’ãƒ¢ãƒ‡ãƒ«æ›´æ–°ã®å®Œå…¨ã‚µã‚¤ã‚¯ãƒ«
"""

import time
from datetime import datetime
from typing import Dict, Optional
import numpy as np


class DigitalTwinModel:
    """Digital Twinã®ç°¡æ˜“ç‰©ç†ãƒ¢ãƒ‡ãƒ«

    åå¿œå™¨ã®ç†±ãƒãƒ©ãƒ³ã‚¹ãƒ¢ãƒ‡ãƒ«ã§ã€æ¸©åº¦ãƒ»åœ§åŠ›ãƒ»æµé‡ã‹ã‚‰
    åå¿œé€²è¡Œåº¦ã‚’è¨ˆç®—ã—ã¾ã™ã€‚
    """

    def __init__(self, reactor_id: str):
        self.reactor_id = reactor_id

        # ãƒ¢ãƒ‡ãƒ«ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
        self.heat_capacity = 4200  # J/(kgÂ·K)
        self.mass = 1000           # kg
        self.heat_transfer_coeff = 500  # W/(mÂ²Â·K)
        self.area = 10             # mÂ²

        # çŠ¶æ…‹å¤‰æ•°
        self.state = {
            'temperature': 85.0,    # â„ƒ
            'pressure': 2.5,        # MPa
            'flow_rate': 120.0,     # L/min
            'conversion': 0.0,      # åå¿œé€²è¡Œåº¦ (0-1)
            'last_update': datetime.now()
        }

    def update_from_sensors(self, sensor_data: Dict[str, float]):
        """ã‚»ãƒ³ã‚µãƒ¼ãƒ‡ãƒ¼ã‚¿ã§ãƒ¢ãƒ‡ãƒ«ã‚’æ›´æ–°

        Args:
            sensor_data: {'temperature': 85.3, 'pressure': 2.45, 'flow_rate': 120.5}
        """
        # ã‚»ãƒ³ã‚µãƒ¼å€¤ã§ãƒ¢ãƒ‡ãƒ«çŠ¶æ…‹ã‚’æ›´æ–°
        if 'temperature' in sensor_data:
            self.state['temperature'] = sensor_data['temperature']

        if 'pressure' in sensor_data:
            self.state['pressure'] = sensor_data['pressure']

        if 'flow_rate' in sensor_data:
            self.state['flow_rate'] = sensor_data['flow_rate']

        self.state['last_update'] = datetime.now()

    def calculate_reaction_conversion(self) -> float:
        """åå¿œé€²è¡Œåº¦ã‚’è¨ˆç®—ï¼ˆç°¡æ˜“ãƒ¢ãƒ‡ãƒ«ï¼‰

        Arrheniuså¼ã«åŸºã¥ãåå¿œé€Ÿåº¦ã®ç©åˆ†

        Returns:
            åå¿œé€²è¡Œåº¦ (0-1)
        """
        T = self.state['temperature'] + 273.15  # K
        P = self.state['pressure'] * 1e6        # Pa

        # ã‚¢ãƒ¬ãƒ‹ã‚¦ã‚¹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ï¼ˆä»®æƒ³å€¤ï¼‰
        A = 1e10      # é »åº¦å› å­
        Ea = 80000    # æ´»æ€§åŒ–ã‚¨ãƒãƒ«ã‚®ãƒ¼ [J/mol]
        R = 8.314     # æ°—ä½“å®šæ•° [J/(molÂ·K)]

        # åå¿œé€Ÿåº¦å®šæ•°
        k = A * np.exp(-Ea / (R * T))

        # åœ§åŠ›è£œæ­£ï¼ˆç°¡æ˜“çš„ï¼‰
        k_eff = k * (P / 2.5e6) ** 0.5

        # åå¿œé€²è¡Œåº¦ï¼ˆæ™‚é–“ç©åˆ†ã®è¿‘ä¼¼ï¼‰
        dt = 1.0  # 1ç§’
        dX = k_eff * (1 - self.state['conversion']) * dt

        new_conversion = min(self.state['conversion'] + dX, 1.0)
        self.state['conversion'] = new_conversion

        return new_conversion

    def predict_next_state(self, time_horizon: float = 60) -> Dict:
        """å°†æ¥ã®çŠ¶æ…‹ã‚’äºˆæ¸¬

        Args:
            time_horizon: äºˆæ¸¬æ™‚é–“ [ç§’]

        Returns:
            äºˆæ¸¬çŠ¶æ…‹è¾æ›¸
        """
        # ç¾åœ¨ã®åå¿œé€Ÿåº¦ã‹ã‚‰å°†æ¥ã®å¤‰æ›ç‡ã‚’äºˆæ¸¬
        predicted_conversion = min(
            self.state['conversion'] + 0.01 * time_horizon,
            1.0
        )

        # ç™ºç†±åå¿œã®å ´åˆã€æ¸©åº¦ä¸Šæ˜‡ã‚’äºˆæ¸¬
        heat_released = predicted_conversion * 100000  # J (ä»®æƒ³å€¤)
        temp_rise = heat_released / (self.mass * self.heat_capacity)
        predicted_temp = self.state['temperature'] + temp_rise

        return {
            'temperature': predicted_temp,
            'conversion': predicted_conversion,
            'time_horizon': time_horizon
        }

    def get_state(self) -> Dict:
        """ç¾åœ¨ã®çŠ¶æ…‹ã‚’å–å¾—"""
        return self.state.copy()


class DigitalTwinSyncLoop:
    """Digital TwinåŒæœŸãƒ«ãƒ¼ãƒ—

    ã‚»ãƒ³ã‚µãƒ¼ãƒ‡ãƒ¼ã‚¿å–å¾—â†’æ¤œè¨¼â†’çŠ¶æ…‹æ¨å®šâ†’ãƒ¢ãƒ‡ãƒ«æ›´æ–°ã‚’
    ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã«å®Ÿè¡Œã—ã¾ã™ã€‚
    """

    def __init__(self, reactor_id: str, update_interval: float = 1.0):
        """
        Args:
            reactor_id: åå¿œå™¨ID
            update_interval: æ›´æ–°é–“éš” [ç§’]
        """
        self.reactor_id = reactor_id
        self.update_interval = update_interval

        # Digital Twinãƒ¢ãƒ‡ãƒ«
        self.twin_model = DigitalTwinModel(reactor_id)

        # ã‚«ãƒ«ãƒãƒ³ãƒ•ã‚£ãƒ«ã‚¿ï¼ˆæ¸©åº¦ç”¨ï¼‰
        self.temp_filter = ReactorKalmanFilter(
            initial_temp=85.0,
            process_noise=0.01,
            measurement_noise=0.5
        )

        # ãƒ‡ãƒ¼ã‚¿ãƒãƒªãƒ‡ãƒ¼ã‚¿
        self.validator = DataValidator()

        self.is_running = False
        self.cycle_count = 0

    def fetch_sensor_data(self) -> Dict[str, float]:
        """ã‚»ãƒ³ã‚µãƒ¼ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ï¼ˆå®Ÿéš›ã¯MQTT/OPC UAã‹ã‚‰ï¼‰

        Returns:
            {'temperature': 85.3, 'pressure': 2.45, 'flow_rate': 120.5}
        """
        # ã“ã“ã§ã¯æ¨¡æ“¬ãƒ‡ãƒ¼ã‚¿ã‚’ç”Ÿæˆ
        # å®Ÿéš›ã¯MQTTã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚„OPC UAã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‹ã‚‰å–å¾—

        base_temp = 85.0 + self.cycle_count * 0.1  # ã‚†ã£ãã‚Šæ˜‡æ¸©
        noise = np.random.normal(0, 0.5)

        return {
            'temperature': base_temp + noise,
            'pressure': 2.5 + np.random.normal(0, 0.02),
            'flow_rate': 120.0 + np.random.normal(0, 1.0)
        }

    def run_single_cycle(self):
        """åŒæœŸãƒ«ãƒ¼ãƒ—ã®1ã‚µã‚¤ã‚¯ãƒ«ã‚’å®Ÿè¡Œ"""
        cycle_start = time.time()

        # 1. ã‚»ãƒ³ã‚µãƒ¼ãƒ‡ãƒ¼ã‚¿å–å¾—
        raw_sensor_data = self.fetch_sensor_data()

        # 2. ãƒ‡ãƒ¼ã‚¿æ¤œè¨¼
        temp_reading = SensorReading(
            reactor_id=self.reactor_id,
            sensor_type="temperature",
            value=raw_sensor_data['temperature'],
            unit="degC",
            timestamp=datetime.now().isoformat()
        )
        validated_reading = self.validator.validate(temp_reading)

        # 3. ã‚«ãƒ«ãƒãƒ³ãƒ•ã‚£ãƒ«ã‚¿ã§çŠ¶æ…‹æ¨å®š
        if validated_reading.quality != DataQuality.BAD:
            est_temp, est_rate = self.temp_filter.estimate(validated_reading.value)
            filtered_data = {
                'temperature': est_temp,
                'pressure': raw_sensor_data['pressure'],
                'flow_rate': raw_sensor_data['flow_rate']
            }
        else:
            # ä¸è‰¯ãƒ‡ãƒ¼ã‚¿ã®å ´åˆã¯å‰å›å€¤ã‚’ä½¿ç”¨
            filtered_data = None

        # 4. Digital Twinãƒ¢ãƒ‡ãƒ«æ›´æ–°
        if filtered_data:
            self.twin_model.update_from_sensors(filtered_data)

        # 5. åå¿œé€²è¡Œåº¦è¨ˆç®—
        conversion = self.twin_model.calculate_reaction_conversion()

        # 6. å°†æ¥äºˆæ¸¬
        prediction = self.twin_model.predict_next_state(time_horizon=60)

        # 7. çµæœè¡¨ç¤º
        state = self.twin_model.get_state()
        cycle_time = (time.time() - cycle_start) * 1000  # ms

        print(f"[Cycle {self.cycle_count}] "
              f"Temp: {state['temperature']:.2f}Â°C "
              f"(filtered: {est_temp:.2f}Â°C), "
              f"Pressure: {state['pressure']:.2f} MPa, "
              f"Conversion: {conversion*100:.1f}%, "
              f"Prediction(60s): {prediction['conversion']*100:.1f}% "
              f"({cycle_time:.1f}ms)")

        self.cycle_count += 1

    def run(self, duration: Optional[float] = None):
        """åŒæœŸãƒ«ãƒ¼ãƒ—ã‚’é–‹å§‹

        Args:
            duration: å®Ÿè¡Œæ™‚é–“ [ç§’] (Noneã®å ´åˆã¯ç„¡é™ãƒ«ãƒ¼ãƒ—)
        """
        self.is_running = True
        start_time = time.time()

        print(f"=== Digital TwinåŒæœŸãƒ«ãƒ¼ãƒ—é–‹å§‹ ===")
        print(f"Reactor ID: {self.reactor_id}")
        print(f"Update Interval: {self.update_interval}s")
        print("-" * 80)

        try:
            while self.is_running:
                # 1ã‚µã‚¤ã‚¯ãƒ«å®Ÿè¡Œ
                self.run_single_cycle()

                # çµ‚äº†æ¡ä»¶ãƒã‚§ãƒƒã‚¯
                if duration and (time.time() - start_time) >= duration:
                    break

                # æ¬¡ã®æ›´æ–°ã¾ã§å¾…æ©Ÿ
                time.sleep(self.update_interval)

        except KeyboardInterrupt:
            print("\n\nã‚­ãƒ¼ãƒœãƒ¼ãƒ‰å‰²ã‚Šè¾¼ã¿ã§åœæ­¢")

        finally:
            self.is_running = False
            print(f"\n=== åŒæœŸãƒ«ãƒ¼ãƒ—çµ‚äº† ===")
            print(f"ç·ã‚µã‚¤ã‚¯ãƒ«æ•°: {self.cycle_count}")
            print(f"å®Ÿè¡Œæ™‚é–“: {time.time() - start_time:.1f}ç§’")


# ä½¿ç”¨ä¾‹
if __name__ == "__main__":
    # Digital TwinåŒæœŸãƒ«ãƒ¼ãƒ—ã®ä½œæˆ
    sync_loop = DigitalTwinSyncLoop(
        reactor_id="R101",
        update_interval=1.0  # 1ç§’ã”ã¨ã«æ›´æ–°
    )

    # 30ç§’é–“å®Ÿè¡Œ
    sync_loop.run(duration=30)

# æœŸå¾…ã•ã‚Œã‚‹å‡ºåŠ›ä¾‹:
# === Digital TwinåŒæœŸãƒ«ãƒ¼ãƒ—é–‹å§‹ ===
# Reactor ID: R101
# Update Interval: 1.0s
# --------------------------------------------------------------------------------
# [Cycle 0] Temp: 85.23Â°C (filtered: 85.13Â°C), Pressure: 2.51 MPa, Conversion: 0.2%, Prediction(60s): 0.8% (2.3ms)
# [Cycle 1] Temp: 85.34Â°C (filtered: 85.28Â°C), Pressure: 2.49 MPa, Conversion: 0.4%, Prediction(60s): 1.0% (1.8ms)
# [Cycle 2] Temp: 85.41Â°C (filtered: 85.39Â°C), Pressure: 2.52 MPa, Conversion: 0.6%, Prediction(60s): 1.2% (1.7ms)
# ...
# [Cycle 29] Temp: 88.12Â°C (filtered: 88.09Â°C), Pressure: 2.48 MPa, Conversion: 6.2%, Prediction(60s): 6.8% (1.9ms)
#
# === åŒæœŸãƒ«ãƒ¼ãƒ—çµ‚äº† ===
# ç·ã‚µã‚¤ã‚¯ãƒ«æ•°: 30
# å®Ÿè¡Œæ™‚é–“: 30.1ç§’
</code></pre>

        <div class="tip">
            <strong>ğŸ’¡ å®Ÿè£…ã®ãƒã‚¤ãƒ³ãƒˆ</strong><br>
            <ul>
                <li><strong>éåŒæœŸå‡¦ç†</strong>ï¼šã‚»ãƒ³ã‚µãƒ¼èª­ã¿å–ã‚Šã¨ãƒ¢ãƒ‡ãƒ«è¨ˆç®—ã‚’ä¸¦åˆ—åŒ–ã—ã¦ã‚µã‚¤ã‚¯ãƒ«æ™‚é–“ã‚’çŸ­ç¸®</li>
                <li><strong>ã‚¨ãƒ©ãƒ¼ãƒªã‚«ãƒãƒª</strong>ï¼šã‚»ãƒ³ã‚µãƒ¼é€šä¿¡ã‚¨ãƒ©ãƒ¼æ™‚ã¯å‰å›å€¤ã‚„ã‚«ãƒ«ãƒãƒ³ãƒ•ã‚£ãƒ«ã‚¿ã®äºˆæ¸¬å€¤ã‚’ä½¿ç”¨</li>
                <li><strong>ã‚¹ã‚±ãƒ¼ãƒ©ãƒ“ãƒªãƒ†ã‚£</strong>ï¼šè¤‡æ•°åå¿œå™¨ã«å¯¾å¿œã™ã‚‹å ´åˆã¯ãƒãƒ«ãƒã‚¹ãƒ¬ãƒƒãƒ‰/ãƒãƒ«ãƒãƒ—ãƒ­ã‚»ã‚¹åŒ–</li>
                <li><strong>ãƒ­ã‚°è¨˜éŒ²</strong>ï¼šã™ã¹ã¦ã®ã‚µã‚¤ã‚¯ãƒ«ã®ãƒ‡ãƒ¼ã‚¿ã‚’InfluxDBã«ä¿å­˜ã—ã¦å¾Œã‹ã‚‰åˆ†æå¯èƒ½ã«</li>
            </ul>
        </div>

        <h2>å­¦ç¿’ç›®æ¨™ã®ç¢ºèª</h2>

        <p>ã“ã®ç« ã‚’å®Œäº†ã™ã‚‹ã¨ã€ä»¥ä¸‹ã‚’å®Ÿè£…ã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ï¼š</p>

        <h3>åŸºæœ¬ç†è§£</h3>
        <ul>
            <li>âœ… MQTTã€OPC UAã®é€šä¿¡ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã®é•ã„ã¨ç”¨é€”ã‚’èª¬æ˜ã§ãã‚‹</li>
            <li>âœ… æ™‚ç³»åˆ—ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®å¿…è¦æ€§ã¨é¸æŠåŸºæº–ã‚’ç†è§£ã§ãã‚‹</li>
            <li>âœ… ã‚»ãƒ³ã‚µãƒ¼ãƒ‡ãƒ¼ã‚¿å“è³ªç®¡ç†ã®é‡è¦æ€§ã‚’èª¬æ˜ã§ãã‚‹</li>
        </ul>

        <h3>å®Ÿè·µã‚¹ã‚­ãƒ«</h3>
        <ul>
            <li>âœ… MQTTã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚’å®Ÿè£…ã—ã¦IoTã‚»ãƒ³ã‚µãƒ¼ã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã§ãã‚‹</li>
            <li>âœ… OPC UAã§ç”£æ¥­æ©Ÿå™¨ï¼ˆPLC/DCSï¼‰ã¨é€šä¿¡ã§ãã‚‹</li>
            <li>âœ… InfluxDBã§æ™‚ç³»åˆ—ãƒ‡ãƒ¼ã‚¿ã‚’åŠ¹ç‡çš„ã«ä¿å­˜ãƒ»ã‚¯ã‚¨ãƒªã§ãã‚‹</li>
            <li>âœ… ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ‡ãƒ¼ã‚¿æ¤œè¨¼ã¨ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°ã‚’å®Ÿè£…ã§ãã‚‹</li>
            <li>âœ… ã‚«ãƒ«ãƒãƒ³ãƒ•ã‚£ãƒ«ã‚¿ã§ã‚»ãƒ³ã‚µãƒ¼ãƒã‚¤ã‚ºã‚’é™¤å»ã§ãã‚‹</li>
            <li>âœ… ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚’æ§‹ç¯‰ã§ãã‚‹</li>
            <li>âœ… Digital TwinåŒæœŸãƒ«ãƒ¼ãƒ—ã‚’å®Ÿè£…ã§ãã‚‹</li>
        </ul>

        <h3>å¿œç”¨åŠ›</h3>
        <ul>
            <li>âœ… åŒ–å­¦ãƒ—ãƒ©ãƒ³ãƒˆã®ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ç›£è¦–ã‚·ã‚¹ãƒ†ãƒ ã‚’è¨­è¨ˆã§ãã‚‹</li>
            <li>âœ… ãƒ‡ãƒ¼ã‚¿å“è³ªã«å¿œã˜ãŸé©å¿œçš„ãªå‡¦ç†ã‚’å®Ÿè£…ã§ãã‚‹</li>
            <li>âœ… ã‚¹ã‚±ãƒ¼ãƒ©ãƒ–ãƒ«ãªãƒ‡ãƒ¼ã‚¿ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚’æ§‹ç¯‰ã§ãã‚‹</li>
        </ul>

        <h2>æ¼”ç¿’å•é¡Œ</h2>

        <h3>Easyï¼ˆåŸºç¤ç¢ºèªï¼‰</h3>

        <div class="example-box">
            <p><strong>Q1:</strong> MQTTã¨OPC UAã®ä¸»ãªé•ã„ã¯ä½•ã§ã™ã‹ï¼Ÿæœ€ã‚‚é©åˆ‡ãªã‚‚ã®ã‚’é¸ã‚“ã§ãã ã•ã„ã€‚</p>
            <p>a) MQTTã¯ç”£æ¥­ç”¨ã€OPC UAã¯IoTç”¨<br>
            b) MQTTã¯è»½é‡ã§IoTå‘ãã€OPC UAã¯ç”£æ¥­ã‚ªãƒ¼ãƒˆãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ¨™æº–<br>
            c) MQTTã¯æœ‰æ–™ã€OPC UAã¯ç„¡æ–™<br>
            d) MQTTã¯å¤ã„è¦æ ¼ã€OPC UAã¯æ–°ã—ã„è¦æ ¼</p>

            <details>
                <summary>è§£ç­”ã‚’è¦‹ã‚‹</summary>
                <p><strong>æ­£è§£:</strong> b) MQTTã¯è»½é‡ã§IoTå‘ãã€OPC UAã¯ç”£æ¥­ã‚ªãƒ¼ãƒˆãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ¨™æº–</p>
                <p><strong>è§£èª¬:</strong></p>
                <ul>
                    <li>MQTT: è»½é‡ãªãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ³ã‚°ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã€IoTãƒ‡ãƒã‚¤ã‚¹ã«æœ€é©ã€Publish/Subscribeå‹</li>
                    <li>OPC UA: ç”£æ¥­ã‚ªãƒ¼ãƒˆãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ¨™æº–ã€PLC/DCSæ¥ç¶šã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ/ã‚µãƒ¼ãƒãƒ¼å‹</li>
                    <li>ã©ã¡ã‚‰ã‚‚ã‚ªãƒ¼ãƒ—ãƒ³è¦æ ¼ã§ç„¡æ–™ã§ä½¿ç”¨å¯èƒ½</li>
                </ul>
            </details>
        </div>

        <h3>Mediumï¼ˆå¿œç”¨ï¼‰</h3>

        <div class="example-box">
            <p><strong>Q2:</strong> ã‚»ãƒ³ã‚µãƒ¼ãƒ‡ãƒ¼ã‚¿ã®Z-scoreãŒ3.5ã®å ´åˆã€ã“ã®ãƒ‡ãƒ¼ã‚¿ã¯å¤–ã‚Œå€¤ã¨ã—ã¦æ‰±ã†ã¹ãã§ã™ã‹ï¼ŸZ-scoreã®ã—ãã„å€¤ã‚’3.0ã¨ã—ãŸå ´åˆã®åˆ¤æ–­ã¨ã€ãã®ç†ç”±ã‚’èª¬æ˜ã—ã¦ãã ã•ã„ã€‚</p>

            <details>
                <summary>è§£ç­”ã‚’è¦‹ã‚‹</summary>
                <p><strong>æ­£è§£:</strong> ã¯ã„ã€å¤–ã‚Œå€¤ã¨ã—ã¦æ‰±ã†ã¹ãã§ã™ã€‚</p>
                <p><strong>ç†ç”±:</strong></p>
                <ul>
                    <li>Z-score = 3.5ã¯ã—ãã„å€¤3.0ã‚’è¶…ãˆã¦ã„ã‚‹</li>
                    <li>æ­£è¦åˆ†å¸ƒã®å ´åˆã€Z-score > 3.0ã®ãƒ‡ãƒ¼ã‚¿ã¯å…¨ä½“ã®0.3%ä»¥ä¸‹ï¼ˆéå¸¸ã«ç¨€ï¼‰</li>
                    <li>ã‚»ãƒ³ã‚µãƒ¼ãƒã‚¤ã‚ºã‚„ã‚¹ãƒ‘ã‚¤ã‚¯ã®å¯èƒ½æ€§ãŒé«˜ã„</li>
                </ul>
                <p><strong>å®Ÿå‹™çš„ãªå¯¾å¿œ:</strong></p>
                <ul>
                    <li>ãƒ‡ãƒ¼ã‚¿å“è³ªã‚’"Uncertain"ã¨ã—ã¦ãƒ•ãƒ©ã‚°ä»˜ã‘</li>
                    <li>ã‚«ãƒ«ãƒãƒ³ãƒ•ã‚£ãƒ«ã‚¿ã‚„ç§»å‹•å¹³å‡ã§è£œæ­£</li>
                    <li>å®Œå…¨ã«é™¤å¤–ã›ãšã€å±¥æ­´ã¨ã—ã¦ä¿å­˜ï¼ˆå¾Œã‹ã‚‰åŸå› åˆ†æï¼‰</li>
                </ul>
            </details>
        </div>

        <h3>Hardï¼ˆç™ºå±•ï¼‰</h3>

        <div class="example-box">
            <p><strong>Q3:</strong> 1000å€‹ã®ã‚»ãƒ³ã‚µãƒ¼ãŒ1ç§’é–“éš”ã§ãƒ‡ãƒ¼ã‚¿ã‚’é€ä¿¡ã™ã‚‹åŒ–å­¦ãƒ—ãƒ©ãƒ³ãƒˆã§ã€Digital TwinåŒæœŸãƒ«ãƒ¼ãƒ—ã®æ›´æ–°é–“éš”ã‚’1ç§’ã«è¨­å®šã—ã¦ã„ã¾ã™ã€‚å„ã‚µã‚¤ã‚¯ãƒ«ã®å‡¦ç†æ™‚é–“ãŒå¹³å‡800msã®å ´åˆã€ã‚·ã‚¹ãƒ†ãƒ ã¯å®‰å®šå‹•ä½œã—ã¾ã™ã‹ï¼Ÿã‚‚ã—å•é¡ŒãŒã‚ã‚Œã°ã€3ã¤ã®æ”¹å–„ç­–ã‚’ææ¡ˆã—ã¦ãã ã•ã„ã€‚</p>

            <details>
                <summary>è§£ç­”ã‚’è¦‹ã‚‹</summary>
                <p><strong>æ­£è§£:</strong> ä¸å®‰å®šã«ãªã‚‹å¯èƒ½æ€§ãŒé«˜ã„ï¼ˆå‡¦ç†æ™‚é–“ 800ms â‰ˆ æ›´æ–°é–“éš” 1000msã§ãƒãƒ¼ã‚¸ãƒ³ãŒä¸ååˆ†ï¼‰</p>

                <p><strong>å•é¡Œç‚¹:</strong></p>
                <ul>
                    <li>å‡¦ç†æ™‚é–“ã®å¤‰å‹•ï¼ˆæœ€æ‚ªã‚±ãƒ¼ã‚¹ï¼‰ã§1000msã‚’è¶…ãˆã‚‹å¯èƒ½æ€§</li>
                    <li>ãƒ‡ãƒ¼ã‚¿é…å»¶ãŒè“„ç©ã—ã¦ãƒãƒƒãƒ•ã‚¡ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼</li>
                    <li>ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ€§ã®å–ªå¤±</li>
                </ul>

                <p><strong>æ”¹å–„ç­–:</strong></p>
                <ol>
                    <li><strong>ä¸¦åˆ—å‡¦ç†ã®å°å…¥</strong>
                        <ul>
                            <li>ã‚»ãƒ³ã‚µãƒ¼ç¾¤ã‚’ã‚°ãƒ«ãƒ¼ãƒ—åŒ–ã—ã¦ä¸¦åˆ—å‡¦ç†ï¼ˆãƒãƒ«ãƒã‚¹ãƒ¬ãƒƒãƒ‰/ãƒãƒ«ãƒãƒ—ãƒ­ã‚»ã‚¹ï¼‰</li>
                            <li>æœŸå¾…åŠ¹æœ: å‡¦ç†æ™‚é–“ã‚’1/4ã«çŸ­ç¸®ï¼ˆ4ã‚³ã‚¢ä½¿ç”¨æ™‚ï¼‰</li>
                        </ul>
                    </li>
                    <li><strong>ãƒãƒƒãƒå‡¦ç†ã®æœ€é©åŒ–</strong>
                        <ul>
                            <li>ã‚»ãƒ³ã‚µãƒ¼ãƒ‡ãƒ¼ã‚¿ã‚’ä¸€æ‹¬èª­ã¿å–ã‚Šï¼ˆOPC UAã®read_multiple_nodesä½¿ç”¨ï¼‰</li>
                            <li>ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ›¸ãè¾¼ã¿ã‚‚ãƒãƒƒãƒåŒ–</li>
                            <li>æœŸå¾…åŠ¹æœ: é€šä¿¡ã‚ªãƒ¼ãƒãƒ¼ãƒ˜ãƒƒãƒ‰ã‚’90%å‰Šæ¸›</li>
                        </ul>
                    </li>
                    <li><strong>æ›´æ–°é »åº¦ã®éšå±¤åŒ–</strong>
                        <ul>
                            <li>é‡è¦ã‚»ãƒ³ã‚µãƒ¼ï¼ˆæ¸©åº¦ã€åœ§åŠ›ï¼‰: 1ç§’é–“éš”</li>
                            <li>è£œåŠ©ã‚»ãƒ³ã‚µãƒ¼ï¼ˆæµé‡ã€æ¶²ä½ï¼‰: 5ç§’é–“éš”</li>
                            <li>åˆ†æè¨ˆ: 60ç§’é–“éš”</li>
                            <li>æœŸå¾…åŠ¹æœ: å‡¦ç†è² è·ã‚’60%å‰Šæ¸›</li>
                        </ul>
                    </li>
                </ol>

                <p><strong>å®Ÿè£…ä¾‹ï¼ˆä¸¦åˆ—å‡¦ç†ï¼‰:</strong></p>
                <pre><code>from concurrent.futures import ThreadPoolExecutor

def process_sensor_group(sensor_ids):
    # ã‚»ãƒ³ã‚µãƒ¼ã‚°ãƒ«ãƒ¼ãƒ—ã®å‡¦ç†
    pass

# 1000ã‚»ãƒ³ã‚µãƒ¼ã‚’4ã‚°ãƒ«ãƒ¼ãƒ—ã«åˆ†å‰²
groups = [sensors[i:i+250] for i in range(0, 1000, 250)]

with ThreadPoolExecutor(max_workers=4) as executor:
    results = executor.map(process_sensor_group, groups)
# å‡¦ç†æ™‚é–“: 800ms â†’ 200ms</code></pre>
            </details>
        </div>

        <h2>æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—</h2>

        <p>ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ‡ãƒ¼ã‚¿é€£æºã®åŸºç›¤ãŒã§ããŸã‚‰ã€æ¬¡ã¯Digital Twinã®ãƒ¢ãƒ‡ãƒªãƒ³ã‚°æ‰‹æ³•ã‚’å­¦ã³ã¾ã™ã€‚ç‰©ç†ãƒ¢ãƒ‡ãƒ«ï¼ˆç¬¬ä¸€åŸç†ï¼‰ã¨ãƒ‡ãƒ¼ã‚¿é§†å‹•ãƒ¢ãƒ‡ãƒ«ï¼ˆæ©Ÿæ¢°å­¦ç¿’ï¼‰ã‚’çµ„ã¿åˆã‚ã›ãŸãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰ãƒ¢ãƒ‡ãƒªãƒ³ã‚°ã«ã‚ˆã‚Šã€é«˜ç²¾åº¦ãªäºˆæ¸¬ã¨åˆ¶å¾¡ã‚’å®Ÿç¾ã—ã¾ã™ã€‚</p>

        <div class="nav-buttons">
            <a href="index.html" class="nav-button">â† ã‚·ãƒªãƒ¼ã‚ºç›®æ¬¡</a>
            <a href="chapter-3.html" class="nav-button">ç¬¬3ç« ï¼šãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰ãƒ¢ãƒ‡ãƒªãƒ³ã‚° â†’</a>
        </div>

        <h2>å‚è€ƒæ–‡çŒ®</h2>
        <ol>
            <li>Eclipse Pahoâ„¢ MQTT Python Client. (2024). <em>paho-mqtt Documentation</em>. https://www.eclipse.org/paho/</li>
            <li>OPC Foundation. (2023). <em>OPC Unified Architecture Specification Part 1: Overview and Concepts</em>. https://opcfoundation.org/</li>
            <li>InfluxData. (2024). <em>InfluxDB Python Client Library</em>. https://docs.influxdata.com/influxdb/</li>
            <li>Welch, G., & Bishop, G. (2006). <em>An Introduction to the Kalman Filter</em>. UNC-Chapel Hill, TR 95-041.</li>
            <li>Kritzinger, W., et al. (2018). "Digital Twin in manufacturing: A categorical literature review and classification." <em>IFAC-PapersOnLine</em>, 51(11), 1016-1022.</li>
        </ol>
    </div>
</body>
</html>