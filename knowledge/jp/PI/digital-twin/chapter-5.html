<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="ç¬¬5ç« ï¼šãƒ‡ã‚¸ã‚¿ãƒ«ãƒ„ã‚¤ãƒ³ã®ãƒ‡ãƒ—ãƒ­ã‚¤ - ãƒ‡ã‚¸ã‚¿ãƒ«ãƒ„ã‚¤ãƒ³å…¥é–€ã‚·ãƒªãƒ¼ã‚º">
    <title>ç¬¬5ç« ï¼šãƒ‡ã‚¸ã‚¿ãƒ«ãƒ„ã‚¤ãƒ³ã®ãƒ‡ãƒ—ãƒ­ã‚¤ - ãƒ‡ã‚¸ã‚¿ãƒ«ãƒ„ã‚¤ãƒ³å…¥é–€ | PI Terakoya</title>

        <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            line-height: 1.8; color: #333; background: #f5f5f5;
        }
        header {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
            color: white; padding: 2rem 1rem; text-align: center;
        }
        h1 { font-size: 2rem; margin-bottom: 0.5rem; }
        .subtitle { opacity: 0.9; font-size: 1.1rem; }
        .container { max-width: 1200px; margin: 2rem auto; padding: 0 1rem; }
        .back-link {
            display: inline-block; margin-bottom: 2rem; padding: 0.5rem 1rem;
            background: white; color: #11998e; text-decoration: none;
            border-radius: 6px; font-weight: 600;
        }
        .content-box {
            background: white; padding: 2rem; border-radius: 12px;
            margin-bottom: 2rem; box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        h2 {
            color: #11998e; margin: 2rem 0 1rem 0;
            padding-bottom: 0.5rem; border-bottom: 3px solid #11998e;
        }
        h3 { color: #2c3e50; margin: 1.5rem 0 1rem 0; }
        h4 { color: #2c3e50; margin: 1rem 0 0.5rem 0; }
        p { margin-bottom: 1rem; }
        ul, ol { margin-left: 2rem; margin-bottom: 1rem; }
        li { margin-bottom: 0.5rem; }
        pre {
            background: #1e1e1e; color: #d4d4d4; padding: 1.5rem;
            border-radius: 8px; overflow-x: auto; margin: 1rem 0;
            border-left: 4px solid #11998e;
        }
        code {
            font-family: 'Courier New', monospace; font-size: 0.9rem;
        }
        .key-point {
            background: #e8f5e9; padding: 1rem; border-radius: 6px;
            border-left: 4px solid #4caf50; margin: 1rem 0;
        }
        .tech-note {
            background: #e3f2fd; padding: 1rem; border-radius: 6px;
            border-left: 4px solid #2196f3; margin: 1rem 0;
        }
        .formula {
            background: #f0f7ff; padding: 1rem; border-radius: 6px;
            margin: 1rem 0; overflow-x: auto;
        }
        table {
            width: 100%; border-collapse: collapse; margin: 1rem 0;
        }
        th, td {
            border: 1px solid #ddd; padding: 0.75rem; text-align: left;
        }
        th {
            background: #11998e; color: white; font-weight: 600;
        }
        tr:nth-child(even) { background: #f9f9f9; }
        .nav-buttons {
            display: flex; justify-content: space-between; margin-top: 3rem;
        }
        .nav-buttons a {
            padding: 0.75rem 1.5rem;
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
            color: white; text-decoration: none; border-radius: 6px;
            font-weight: 600;
        }
        footer {
            background: #2c3e50; color: white; text-align: center;
            padding: 2rem 1rem; margin-top: 4rem;
        }
        @media (max-width: 768px) {
            h1 { font-size: 1.6rem; }
            .container { padding: 0 0.5rem; }
            pre { padding: 1rem; }
        }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <h1>ç¬¬5ç« ï¼šãƒ‡ã‚¸ã‚¿ãƒ«ãƒ„ã‚¤ãƒ³ã®ãƒ‡ãƒ—ãƒ­ã‚¤</h1>
            <p class="subtitle">ç ”ç©¶ã‹ã‚‰æœ¬ç•ªé‹ç”¨ã¸ï¼šå®Ÿè·µçš„ãªãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆæˆ¦ç•¥</p>
            <div class="meta">
                <span class="meta">ğŸ“š é›£æ˜“åº¦: ä¸­ç´šï½ä¸Šç´š</span>
                <span class="meta">â±ï¸ èª­äº†æ™‚é–“: 35-40åˆ†</span>
                <span class="meta">ğŸ”§ Pythonå®Ÿè£…: 7ä¾‹</span>
            </div>
        </div>
    </header>

    <main class="container">
        <section>
            <h2>5.1 ã‚¨ãƒƒã‚¸ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ãƒ‡ãƒ—ãƒ­ã‚¤</h2>

            <p>ãƒ—ãƒ©ãƒ³ãƒˆç¾å ´ã§ã®ä½ãƒ¬ã‚¤ãƒ†ãƒ³ã‚·ãƒ¼ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ¨è«–ã‚’å®Ÿç¾ã™ã‚‹ãŸã‚ã€ã‚¨ãƒƒã‚¸ãƒ‡ãƒã‚¤ã‚¹ä¸Šã§ãƒ‡ã‚¸ã‚¿ãƒ«ãƒ„ã‚¤ãƒ³ã‚’ç¨¼åƒã•ã›ã¾ã™ã€‚</p>

            <h3>5.1.1 è»½é‡ãƒ¢ãƒ‡ãƒ«ã®ãƒ‡ãƒ—ãƒ­ã‚¤</h3>

<pre><code>import pickle
import numpy as np
from pathlib import Path
import json
import time

class EdgeDigitalTwin:
    """ã‚¨ãƒƒã‚¸ãƒ‡ãƒã‚¤ã‚¹ç”¨è»½é‡ãƒ‡ã‚¸ã‚¿ãƒ«ãƒ„ã‚¤ãƒ³"""

    def __init__(self, model_path):
        self.model = None
        self.scaler = None
        self.config = {}
        self.load_model(model_path)

    def load_model(self, model_path):
        """ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿"""
        model_dir = Path(model_path)

        # ãƒ¢ãƒ‡ãƒ«æœ¬ä½“
        with open(model_dir / 'model.pkl', 'rb') as f:
            self.model = pickle.load(f)

        # ã‚¹ã‚±ãƒ¼ãƒ©ãƒ¼
        with open(model_dir / 'scaler.pkl', 'rb') as f:
            self.scaler = pickle.load(f)

        # è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«
        with open(model_dir / 'config.json', 'r') as f:
            self.config = json.load(f)

        print(f"Model loaded: {self.config['model_type']}")
        print(f"Features: {self.config['features']}")

    def predict(self, sensor_data):
        """ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ¨è«–

        Args:
            sensor_data: {feature_name: value}ã®è¾æ›¸

        Returns:
            äºˆæ¸¬çµæœã¨ä¿¡é ¼åŒºé–“
        """
        start_time = time.time()

        # ç‰¹å¾´é‡æŠ½å‡º
        X = np.array([[sensor_data[f] for f in self.config['features']]])

        # å‰å‡¦ç†
        X_scaled = self.scaler.transform(X)

        # æ¨è«–
        prediction = self.model.predict(X_scaled)[0]

        # ä¿¡é ¼åŒºé–“ï¼ˆã‚¢ãƒ³ã‚µãƒ³ãƒ–ãƒ«ãƒ¢ãƒ‡ãƒ«ã®å ´åˆï¼‰
        if hasattr(self.model, 'estimators_'):
            predictions = [est.predict(X_scaled)[0]
                          for est in self.model.estimators_]
            confidence_interval = (
                np.percentile(predictions, 5),
                np.percentile(predictions, 95)
            )
        else:
            confidence_interval = None

        inference_time = (time.time() - start_time) * 1000  # ms

        return {
            'prediction': prediction,
            'confidence_interval': confidence_interval,
            'inference_time_ms': inference_time,
            'timestamp': time.time()
        }

    def validate_input(self, sensor_data):
        """å…¥åŠ›ãƒ‡ãƒ¼ã‚¿æ¤œè¨¼"""
        missing_features = [f for f in self.config['features']
                           if f not in sensor_data]

        if missing_features:
            return False, f"Missing features: {missing_features}"

        # ç¯„å›²ãƒã‚§ãƒƒã‚¯
        for feature, value in sensor_data.items():
            if feature in self.config.get('valid_ranges', {}):
                min_val, max_val = self.config['valid_ranges'][feature]
                if not (min_val <= value <= max_val):
                    return False, f"{feature}={value} out of range [{min_val}, {max_val}]"

        return True, "OK"

    def get_model_info(self):
        """ãƒ¢ãƒ‡ãƒ«æƒ…å ±å–å¾—"""
        return {
            'type': self.config['model_type'],
            'version': self.config.get('version', 'unknown'),
            'features': self.config['features'],
            'trained_date': self.config.get('trained_date', 'unknown')
        }

# ãƒ¢ãƒ‡ãƒ«ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ãƒ³ã‚°é–¢æ•°
def package_model_for_edge(model, scaler, features, output_dir,
                           valid_ranges=None):
    """ã‚¨ãƒƒã‚¸ç”¨ãƒ¢ãƒ‡ãƒ«ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ãƒ³ã‚°"""
    output_path = Path(output_dir)
    output_path.mkdir(parents=True, exist_ok=True)

    # ãƒ¢ãƒ‡ãƒ«ä¿å­˜
    with open(output_path / 'model.pkl', 'wb') as f:
        pickle.dump(model, f)

    # ã‚¹ã‚±ãƒ¼ãƒ©ãƒ¼ä¿å­˜
    with open(output_path / 'scaler.pkl', 'wb') as f:
        pickle.dump(scaler, f)

    # è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«
    config = {
        'model_type': type(model).__name__,
        'features': features,
        'version': '1.0.0',
        'trained_date': time.strftime('%Y-%m-%d'),
        'valid_ranges': valid_ranges or {}
    }

    with open(output_path / 'config.json', 'w') as f:
        json.dump(config, f, indent=2)

    print(f"Model packaged to {output_path}")

# ä½¿ç”¨ä¾‹
from sklearn.ensemble import RandomForestRegressor
from sklearn.preprocessing import StandardScaler

# ãƒ¢ãƒ‡ãƒ«è¨“ç·´ï¼ˆç°¡æ˜“ä¾‹ï¼‰
np.random.seed(42)
X_train = np.random.rand(100, 3)
y_train = X_train[:, 0] * 10 + X_train[:, 1] * 5 + np.random.randn(100)

scaler = StandardScaler()
X_scaled = scaler.fit_transform(X_train)

model = RandomForestRegressor(n_estimators=10, max_depth=5, random_state=42)
model.fit(X_scaled, y_train)

# ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ãƒ³ã‚°
package_model_for_edge(
    model, scaler,
    features=['temp', 'pressure', 'flow'],
    output_dir='./edge_model',
    valid_ranges={'temp': (300, 400), 'pressure': (1, 10), 'flow': (50, 150)}
)

# ã‚¨ãƒƒã‚¸ãƒ‡ãƒã‚¤ã‚¹ã§ã®ä½¿ç”¨
edge_twin = EdgeDigitalTwin('./edge_model')

# ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ¨è«–
sensor_reading = {'temp': 350, 'pressure': 5.5, 'flow': 100}
result = edge_twin.predict(sensor_reading)

print(f"Prediction: {result['prediction']:.2f}")
print(f"Inference Time: {result['inference_time_ms']:.2f} ms")
if result['confidence_interval']:
    print(f"90% CI: [{result['confidence_interval'][0]:.2f}, "
          f"{result['confidence_interval'][1]:.2f}]")
</code></pre>

            <div class="callout callout-tip">
                <strong>ğŸ’¡ ã‚¨ãƒƒã‚¸ãƒ‡ãƒ—ãƒ­ã‚¤ã®ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹:</strong>
                <ul>
                    <li>ãƒ¢ãƒ‡ãƒ«ã‚µã‚¤ã‚ºã‚’æœ€å°åŒ–ï¼ˆé‡å­åŒ–ã€æåˆˆã‚Šï¼‰</li>
                    <li>æ¨è«–æ™‚é–“ã‚’1ç§’ä»¥å†…ã«ï¼ˆãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ åˆ¶ç´„ï¼‰</li>
                    <li>å…¥åŠ›æ¤œè¨¼ã‚’å¿…ãšå®Ÿæ–½ï¼ˆç•°å¸¸å€¤å¯¾ç­–ï¼‰</li>
                    <li>ãƒ•ã‚§ã‚¤ãƒ«ã‚»ãƒ¼ãƒ•ãƒ¢ãƒ¼ãƒ‰ã‚’ç”¨æ„</li>
                </ul>
            </div>

            <h2>5.2 ã‚¯ãƒ©ã‚¦ãƒ‰ãƒ‡ãƒ—ãƒ­ã‚¤ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£</h2>

            <p>ã‚¹ã‚±ãƒ¼ãƒ©ãƒ–ãƒ«ãªã‚¯ãƒ©ã‚¦ãƒ‰ç’°å¢ƒã§ãƒ‡ã‚¸ã‚¿ãƒ«ãƒ„ã‚¤ãƒ³ã‚’ãƒ›ã‚¹ãƒ†ã‚£ãƒ³ã‚°ã—ã€è¤‡æ•°ãƒ—ãƒ©ãƒ³ãƒˆã‹ã‚‰ã®ã‚¢ã‚¯ã‚»ã‚¹ã‚’å¯èƒ½ã«ã—ã¾ã™ã€‚</p>

            <h3>5.2.1 ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£</h3>

<pre><code>from flask import Flask, request, jsonify
from functools import wraps
import logging
from datetime import datetime

class DigitalTwinMicroservice:
    """ãƒ‡ã‚¸ã‚¿ãƒ«ãƒ„ã‚¤ãƒ³ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹"""

    def __init__(self, model_path, service_name='digital-twin'):
        self.app = Flask(service_name)
        self.model = EdgeDigitalTwin(model_path)
        self.request_count = 0

        # ãƒ­ã‚®ãƒ³ã‚°è¨­å®š
        logging.basicConfig(level=logging.INFO)
        self.logger = logging.getLogger(service_name)

        self._setup_routes()

    def _setup_routes(self):
        """APIã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆè¨­å®š"""

        @self.app.route('/health', methods=['GET'])
        def health_check():
            """ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯"""
            return jsonify({
                'status': 'healthy',
                'service': 'digital-twin',
                'model_version': self.model.config.get('version', 'unknown'),
                'timestamp': datetime.now().isoformat()
            })

        @self.app.route('/predict', methods=['POST'])
        @self._log_request
        def predict():
            """æ¨è«–ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ"""
            try:
                data = request.get_json()

                # å…¥åŠ›æ¤œè¨¼
                valid, message = self.model.validate_input(data)
                if not valid:
                    return jsonify({'error': message}), 400

                # æ¨è«–å®Ÿè¡Œ
                result = self.model.predict(data)

                self.request_count += 1

                return jsonify({
                    'success': True,
                    'result': result,
                    'request_id': self.request_count
                })

            except Exception as e:
                self.logger.error(f"Prediction error: {str(e)}")
                return jsonify({'error': str(e)}), 500

        @self.app.route('/model/info', methods=['GET'])
        def model_info():
            """ãƒ¢ãƒ‡ãƒ«æƒ…å ±"""
            return jsonify(self.model.get_model_info())

        @self.app.route('/metrics', methods=['GET'])
        def metrics():
            """ãƒ¡ãƒˆãƒªã‚¯ã‚¹"""
            return jsonify({
                'total_requests': self.request_count,
                'model_version': self.model.config.get('version'),
                'uptime_seconds': self._get_uptime()
            })

    def _log_request(self, f):
        """ãƒªã‚¯ã‚¨ã‚¹ãƒˆãƒ­ã‚°ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿"""
        @wraps(f)
        def decorated_function(*args, **kwargs):
            self.logger.info(f"Request: {request.method} {request.path}")
            response = f(*args, **kwargs)
            self.logger.info(f"Response: {response[1] if isinstance(response, tuple) else 200}")
            return response
        return decorated_function

    def _get_uptime(self):
        """ç¨¼åƒæ™‚é–“ï¼ˆç°¡æ˜“ç‰ˆï¼‰"""
        return 0  # å®Ÿè£…ã¯çœç•¥

    def run(self, host='0.0.0.0', port=5000, debug=False):
        """ã‚µãƒ¼ãƒ“ã‚¹èµ·å‹•"""
        self.logger.info(f"Starting Digital Twin Microservice on {host}:{port}")
        self.app.run(host=host, port=port, debug=debug)

# ä½¿ç”¨ä¾‹ï¼ˆå®Ÿè¡Œæ™‚ï¼‰
# service = DigitalTwinMicroservice('./edge_model')
# service.run(port=5000)

# ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´ã®ä½¿ç”¨ä¾‹
import requests

def call_digital_twin_api(sensor_data, api_url='http://localhost:5000'):
    """ãƒ‡ã‚¸ã‚¿ãƒ«ãƒ„ã‚¤ãƒ³APIå‘¼ã³å‡ºã—"""
    try:
        # æ¨è«–ãƒªã‚¯ã‚¨ã‚¹ãƒˆ
        response = requests.post(
            f"{api_url}/predict",
            json=sensor_data,
            timeout=5.0
        )

        if response.status_code == 200:
            return response.json()
        else:
            print(f"Error: {response.status_code}")
            return None

    except requests.exceptions.RequestException as e:
        print(f"Request failed: {e}")
        return None

# APIå‘¼ã³å‡ºã—ä¾‹
sensor_data = {'temp': 360, 'pressure': 6.0, 'flow': 100}
result = call_digital_twin_api(sensor_data)

if result and result['success']:
    print(f"Prediction: {result['result']['prediction']:.2f}")
    print(f"Inference time: {result['result']['inference_time_ms']:.2f} ms")
</code></pre>

            <h2>5.3 Dockerã‚³ãƒ³ãƒ†ãƒŠåŒ–</h2>

            <p>ãƒ‡ã‚¸ã‚¿ãƒ«ãƒ„ã‚¤ãƒ³ã‚’ã‚³ãƒ³ãƒ†ãƒŠåŒ–ã—ã€ç’°å¢ƒéä¾å­˜ã‹ã¤å®¹æ˜“ã«ãƒ‡ãƒ—ãƒ­ã‚¤ã§ãã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚</p>

<pre><code># Dockerfile ã®ä½œæˆä¾‹ï¼ˆPython ã‚³ãƒ¼ãƒ‰å†…ã§ãƒ†ã‚­ã‚¹ãƒˆã¨ã—ã¦è¡¨ç¤ºï¼‰

DOCKERFILE_CONTENT = """
# ãƒ™ãƒ¼ã‚¹ã‚¤ãƒ¡ãƒ¼ã‚¸
FROM python:3.9-slim

# ä½œæ¥­ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª
WORKDIR /app

# ã‚·ã‚¹ãƒ†ãƒ ä¾å­˜é–¢ä¿‚
RUN apt-get update && apt-get install -y \\
    gcc \\
    && rm -rf /var/lib/apt/lists/*

# Pythonä¾å­˜é–¢ä¿‚
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚³ãƒ¼ãƒ‰
COPY ./digital_twin /app/digital_twin
COPY ./edge_model /app/edge_model

# érootãƒ¦ãƒ¼ã‚¶ãƒ¼ã§å®Ÿè¡Œ
RUN useradd -m -u 1000 dtuser && chown -R dtuser:dtuser /app
USER dtuser

# ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \\
    CMD python -c "import requests; requests.get('http://localhost:5000/health')"

# ãƒãƒ¼ãƒˆå…¬é–‹
EXPOSE 5000

# èµ·å‹•ã‚³ãƒãƒ³ãƒ‰
CMD ["python", "-m", "digital_twin.service"]
"""

# requirements.txt ã®å†…å®¹
REQUIREMENTS_CONTENT = """
flask==2.3.0
numpy==1.24.0
scikit-learn==1.3.0
requests==2.31.0
gunicorn==21.0.0
"""

# Docker compose è¨­å®š
DOCKER_COMPOSE_CONTENT = """
version: '3.8'

services:
  digital-twin:
    build: .
    ports:
      - "5000:5000"
    environment:
      - MODEL_PATH=/app/edge_model
      - LOG_LEVEL=INFO
    volumes:
      - ./logs:/app/logs
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:5000/health"]
      interval: 30s
      timeout: 5s
      retries: 3

  # ãƒ­ãƒ¼ãƒ‰ãƒãƒ©ãƒ³ã‚µãƒ¼ï¼ˆè¤‡æ•°ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ç”¨ï¼‰
  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
    depends_on:
      - digital-twin
    restart: unless-stopped
"""

# Docker ãƒ“ãƒ«ãƒ‰ãƒ»å®Ÿè¡Œã‚¹ã‚¯ãƒªãƒ—ãƒˆ
class DockerDeployment:
    """Docker ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆç®¡ç†"""

    @staticmethod
    def create_dockerfile(output_dir='.'):
        """Dockerfile ä½œæˆ"""
        with open(f"{output_dir}/Dockerfile", 'w') as f:
            f.write(DOCKERFILE_CONTENT)
        print("Dockerfile created")

    @staticmethod
    def create_requirements(output_dir='.'):
        """requirements.txt ä½œæˆ"""
        with open(f"{output_dir}/requirements.txt", 'w') as f:
            f.write(REQUIREMENTS_CONTENT)
        print("requirements.txt created")

    @staticmethod
    def create_docker_compose(output_dir='.'):
        """docker-compose.yml ä½œæˆ"""
        with open(f"{output_dir}/docker-compose.yml", 'w') as f:
            f.write(DOCKER_COMPOSE_CONTENT)
        print("docker-compose.yml created")

    @staticmethod
    def build_image(tag='digital-twin:latest'):
        """Docker ã‚¤ãƒ¡ãƒ¼ã‚¸ãƒ“ãƒ«ãƒ‰"""
        import subprocess
        cmd = f"docker build -t {tag} ."
        subprocess.run(cmd, shell=True)
        print(f"Image built: {tag}")

    @staticmethod
    def run_container(tag='digital-twin:latest', port=5000):
        """ã‚³ãƒ³ãƒ†ãƒŠèµ·å‹•"""
        import subprocess
        cmd = f"docker run -d -p {port}:5000 --name dt-service {tag}"
        subprocess.run(cmd, shell=True)
        print(f"Container started on port {port}")

# ä½¿ç”¨ä¾‹
# deployment = DockerDeployment()
# deployment.create_dockerfile()
# deployment.create_requirements()
# deployment.create_docker_compose()
# deployment.build_image()
# deployment.run_container()

print("Docker deployment files ready")
print("To build: docker build -t digital-twin .")
print("To run: docker-compose up -d")
</code></pre>

            <h2>5.4 RESTful APIè¨­è¨ˆ</h2>

            <p>æ¨™æº–çš„ãªRESTful APIã‚’é€šã˜ã¦ãƒ‡ã‚¸ã‚¿ãƒ«ãƒ„ã‚¤ãƒ³ã¸ã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚</p>

<pre><code>from flask import Flask, request, jsonify, make_response
from functools import wraps
import jwt
import datetime

class SecureDigitalTwinAPI:
    """ã‚»ã‚­ãƒ¥ã‚¢ãªãƒ‡ã‚¸ã‚¿ãƒ«ãƒ„ã‚¤ãƒ³API"""

    def __init__(self, model_path, secret_key):
        self.app = Flask(__name__)
        self.app.config['SECRET_KEY'] = secret_key
        self.model = EdgeDigitalTwin(model_path)
        self._setup_secure_routes()

    def _token_required(self, f):
        """JWTèªè¨¼ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿"""
        @wraps(f)
        def decorated(*args, **kwargs):
            token = request.headers.get('Authorization')

            if not token:
                return jsonify({'message': 'Token is missing'}), 401

            try:
                # "Bearer <token>" å½¢å¼
                token = token.split()[1] if ' ' in token else token
                data = jwt.decode(token, self.app.config['SECRET_KEY'],
                                 algorithms=['HS256'])
                current_user = data['user']
            except:
                return jsonify({'message': 'Token is invalid'}), 401

            return f(current_user, *args, **kwargs)

        return decorated

    def _setup_secure_routes(self):
        """ã‚»ã‚­ãƒ¥ã‚¢ãªAPIã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ"""

        @self.app.route('/api/v1/auth/login', methods=['POST'])
        def login():
            """èªè¨¼ï¼ˆãƒˆãƒ¼ã‚¯ãƒ³ç™ºè¡Œï¼‰"""
            auth = request.get_json()

            # å®Ÿéš›ã¯ DB ã§ãƒ¦ãƒ¼ã‚¶ãƒ¼æ¤œè¨¼
            if auth.get('username') == 'admin' and auth.get('password') == 'secret':
                token = jwt.encode({
                    'user': auth['username'],
                    'exp': datetime.datetime.utcnow() + datetime.timedelta(hours=24)
                }, self.app.config['SECRET_KEY'], algorithm='HS256')

                return jsonify({'token': token})

            return jsonify({'message': 'Invalid credentials'}), 401

        @self.app.route('/api/v1/twin/predict', methods=['POST'])
        @self._token_required
        def predict(current_user):
            """æ¨è«–ï¼ˆèªè¨¼å¿…é ˆï¼‰"""
            data = request.get_json()

            valid, message = self.model.validate_input(data)
            if not valid:
                return jsonify({'error': message}), 400

            result = self.model.predict(data)

            return jsonify({
                'user': current_user,
                'prediction': result['prediction'],
                'confidence_interval': result['confidence_interval'],
                'timestamp': result['timestamp']
            })

        @self.app.route('/api/v1/twin/batch', methods=['POST'])
        @self._token_required
        def batch_predict(current_user):
            """ãƒãƒƒãƒæ¨è«–"""
            data = request.get_json()
            inputs = data.get('inputs', [])

            if len(inputs) > 100:
                return jsonify({'error': 'Batch size limit: 100'}), 400

            results = []
            for inp in inputs:
                valid, _ = self.model.validate_input(inp)
                if valid:
                    result = self.model.predict(inp)
                    results.append({
                        'input': inp,
                        'prediction': result['prediction']
                    })

            return jsonify({
                'user': current_user,
                'total': len(inputs),
                'successful': len(results),
                'results': results
            })

        @self.app.route('/api/v1/twin/status', methods=['GET'])
        @self._token_required
        def status(current_user):
            """ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ç¢ºèª"""
            return jsonify({
                'status': 'operational',
                'model_info': self.model.get_model_info(),
                'user': current_user
            })

# ä½¿ç”¨ä¾‹ï¼ˆã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´ï¼‰
class DigitalTwinClient:
    """ãƒ‡ã‚¸ã‚¿ãƒ«ãƒ„ã‚¤ãƒ³APIã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ"""

    def __init__(self, api_url, username, password):
        self.api_url = api_url
        self.token = None
        self._authenticate(username, password)

    def _authenticate(self, username, password):
        """èªè¨¼"""
        response = requests.post(
            f"{self.api_url}/api/v1/auth/login",
            json={'username': username, 'password': password}
        )

        if response.status_code == 200:
            self.token = response.json()['token']
            print("Authenticated successfully")
        else:
            raise Exception("Authentication failed")

    def predict(self, sensor_data):
        """æ¨è«–ãƒªã‚¯ã‚¨ã‚¹ãƒˆ"""
        headers = {'Authorization': f'Bearer {self.token}'}

        response = requests.post(
            f"{self.api_url}/api/v1/twin/predict",
            json=sensor_data,
            headers=headers
        )

        if response.status_code == 200:
            return response.json()
        else:
            raise Exception(f"Prediction failed: {response.status_code}")

    def batch_predict(self, inputs_list):
        """ãƒãƒƒãƒæ¨è«–"""
        headers = {'Authorization': f'Bearer {self.token}'}

        response = requests.post(
            f"{self.api_url}/api/v1/twin/batch",
            json={'inputs': inputs_list},
            headers=headers
        )

        if response.status_code == 200:
            return response.json()
        else:
            raise Exception(f"Batch prediction failed: {response.status_code}")

# ä½¿ç”¨ä¾‹
# client = DigitalTwinClient('http://localhost:5000', 'admin', 'secret')
# result = client.predict({'temp': 360, 'pressure': 6.0, 'flow': 100})
# print(f"Prediction: {result['prediction']}")

print("Secure API implementation ready")
</code></pre>

            <h2>5.5 å¯è¦–åŒ–ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰</h2>

            <p>Plotly Dashã‚’ä½¿ã£ã¦ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ã‚’æ§‹ç¯‰ã—ã¾ã™ã€‚</p>

<pre><code>import dash
from dash import dcc, html
from dash.dependencies import Input, Output, State
import plotly.graph_objs as go
import pandas as pd
from collections import deque
import threading
import time

class DigitalTwinDashboard:
    """ãƒ‡ã‚¸ã‚¿ãƒ«ãƒ„ã‚¤ãƒ³ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰"""

    def __init__(self, digital_twin_api_url):
        self.api_url = digital_twin_api_url
        self.app = dash.Dash(__name__)

        # ãƒ‡ãƒ¼ã‚¿ãƒãƒƒãƒ•ã‚¡ï¼ˆæœ€æ–°100ãƒã‚¤ãƒ³ãƒˆï¼‰
        self.time_buffer = deque(maxlen=100)
        self.prediction_buffer = deque(maxlen=100)
        self.temp_buffer = deque(maxlen=100)
        self.pressure_buffer = deque(maxlen=100)

        self._setup_layout()
        self._setup_callbacks()

    def _setup_layout(self):
        """ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆè¨­å®š"""
        self.app.layout = html.Div([
            html.H1("Digital Twin Dashboard",
                   style={'textAlign': 'center', 'color': '#2c3e50'}),

            html.Div([
                html.Div([
                    html.H3("Current Status"),
                    html.Div(id='status-display',
                            style={'fontSize': '24px', 'fontWeight': 'bold'})
                ], style={'width': '48%', 'display': 'inline-block'}),

                html.Div([
                    html.H3("Model Info"),
                    html.Div(id='model-info')
                ], style={'width': '48%', 'float': 'right',
                         'display': 'inline-block'})
            ]),

            html.Div([
                html.H3("Input Controls"),
                html.Label("Temperature (Â°C):"),
                dcc.Slider(id='temp-slider', min=340, max=380, value=360,
                          marks={i: str(i) for i in range(340, 381, 10)}),

                html.Label("Pressure (bar):"),
                dcc.Slider(id='pressure-slider', min=4, max=8, value=6,
                          step=0.5,
                          marks={i: str(i) for i in range(4, 9)}),

                html.Label("Flow (kg/h):"),
                dcc.Slider(id='flow-slider', min=80, max=120, value=100,
                          marks={i: str(i) for i in range(80, 121, 10)}),

                html.Button('Predict', id='predict-button', n_clicks=0)
            ], style={'margin': '20px'}),

            html.Div([
                dcc.Graph(id='prediction-time-series'),
                dcc.Graph(id='process-conditions')
            ]),

            dcc.Interval(id='interval-component', interval=2000, n_intervals=0)
        ])

    def _setup_callbacks(self):
        """ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯è¨­å®š"""

        @self.app.callback(
            Output('status-display', 'children'),
            Output('prediction-time-series', 'figure'),
            Output('process-conditions', 'figure'),
            Input('predict-button', 'n_clicks'),
            Input('interval-component', 'n_intervals'),
            State('temp-slider', 'value'),
            State('pressure-slider', 'value'),
            State('flow-slider', 'value')
        )
        def update_dashboard(n_clicks, n_intervals, temp, pressure, flow):
            # æ¨è«–å®Ÿè¡Œï¼ˆãƒœã‚¿ãƒ³ã‚¯ãƒªãƒƒã‚¯æ™‚ã¾ãŸã¯ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«ï¼‰
            if n_clicks > 0 or n_intervals > 0:
                sensor_data = {
                    'temp': temp,
                    'pressure': pressure,
                    'flow': flow
                }

                # APIå‘¼ã³å‡ºã—ï¼ˆå®Ÿéš›ã®å®Ÿè£…ï¼‰
                # result = call_digital_twin_api(sensor_data, self.api_url)
                # ç°¡æ˜“ç‰ˆ: ãƒ­ãƒ¼ã‚«ãƒ«è¨ˆç®—
                prediction = 85 - 0.05*(temp-360)**2 - 2*(pressure-6)**2

                # ãƒãƒƒãƒ•ã‚¡æ›´æ–°
                self.time_buffer.append(time.time())
                self.prediction_buffer.append(prediction)
                self.temp_buffer.append(temp)
                self.pressure_buffer.append(pressure)

            # ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¡¨ç¤º
            if len(self.prediction_buffer) > 0:
                status = f"Latest Prediction: {self.prediction_buffer[-1]:.2f}%"
            else:
                status = "No data"

            # äºˆæ¸¬å€¤æ™‚ç³»åˆ—ã‚°ãƒ©ãƒ•
            time_series_fig = go.Figure()
            if len(self.time_buffer) > 0:
                time_series_fig.add_trace(go.Scatter(
                    x=list(range(len(self.prediction_buffer))),
                    y=list(self.prediction_buffer),
                    mode='lines+markers',
                    name='Yield Prediction',
                    line=dict(color='#11998e', width=2)
                ))

            time_series_fig.update_layout(
                title='Yield Prediction Over Time',
                xaxis_title='Sample',
                yaxis_title='Yield (%)',
                template='plotly_white',
                height=400
            )

            # ãƒ—ãƒ­ã‚»ã‚¹æ¡ä»¶ã‚°ãƒ©ãƒ•
            conditions_fig = go.Figure()
            if len(self.temp_buffer) > 0:
                conditions_fig.add_trace(go.Scatter(
                    x=list(range(len(self.temp_buffer))),
                    y=list(self.temp_buffer),
                    mode='lines',
                    name='Temperature',
                    yaxis='y1'
                ))
                conditions_fig.add_trace(go.Scatter(
                    x=list(range(len(self.pressure_buffer))),
                    y=list(self.pressure_buffer),
                    mode='lines',
                    name='Pressure',
                    yaxis='y2'
                ))

            conditions_fig.update_layout(
                title='Process Conditions',
                xaxis=dict(title='Sample'),
                yaxis=dict(title='Temperature (Â°C)', side='left'),
                yaxis2=dict(title='Pressure (bar)', side='right',
                           overlaying='y'),
                template='plotly_white',
                height=400
            )

            return status, time_series_fig, conditions_fig

    def run(self, host='0.0.0.0', port=8050, debug=False):
        """ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰èµ·å‹•"""
        self.app.run_server(host=host, port=port, debug=debug)

# ä½¿ç”¨ä¾‹
# dashboard = DigitalTwinDashboard('http://localhost:5000')
# dashboard.run(port=8050)

print("Dashboard implementation ready")
print("Access at: http://localhost:8050")
</code></pre>

            <h2>5.6 ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã¨ã‚¢ã‚¯ã‚»ã‚¹åˆ¶å¾¡</h2>

            <p>æœ¬ç•ªç’°å¢ƒã§ã¯é©åˆ‡ãªã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å¯¾ç­–ãŒä¸å¯æ¬ ã§ã™ã€‚</p>

<pre><code>import hashlib
import secrets
from datetime import datetime, timedelta
import json

class SecurityManager:
    """ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ """

    def __init__(self):
        self.users = {}  # å®Ÿéš›ã¯ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹
        self.api_keys = {}
        self.access_log = []

    def create_user(self, username, password, role='user'):
        """ãƒ¦ãƒ¼ã‚¶ãƒ¼ä½œæˆ"""
        # ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒãƒƒã‚·ãƒ¥åŒ–
        salt = secrets.token_hex(16)
        password_hash = self._hash_password(password, salt)

        self.users[username] = {
            'password_hash': password_hash,
            'salt': salt,
            'role': role,
            'created_at': datetime.now().isoformat(),
            'active': True
        }

        return True

    def _hash_password(self, password, salt):
        """ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒãƒƒã‚·ãƒ¥"""
        return hashlib.pbkdf2_hmac(
            'sha256',
            password.encode('utf-8'),
            salt.encode('utf-8'),
            100000
        ).hex()

    def verify_password(self, username, password):
        """ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰æ¤œè¨¼"""
        if username not in self.users:
            return False

        user = self.users[username]
        password_hash = self._hash_password(password, user['salt'])

        return password_hash == user['password_hash']

    def generate_api_key(self, username, expiry_days=365):
        """APIã‚­ãƒ¼ç”Ÿæˆ"""
        if username not in self.users:
            return None

        api_key = secrets.token_urlsafe(32)
        expiry = datetime.now() + timedelta(days=expiry_days)

        self.api_keys[api_key] = {
            'username': username,
            'created_at': datetime.now().isoformat(),
            'expires_at': expiry.isoformat(),
            'active': True
        }

        return api_key

    def verify_api_key(self, api_key):
        """APIã‚­ãƒ¼æ¤œè¨¼"""
        if api_key not in self.api_keys:
            return False, "Invalid API key"

        key_info = self.api_keys[api_key]

        if not key_info['active']:
            return False, "API key deactivated"

        expiry = datetime.fromisoformat(key_info['expires_at'])
        if datetime.now() > expiry:
            return False, "API key expired"

        return True, key_info['username']

    def log_access(self, username, action, resource, success=True):
        """ã‚¢ã‚¯ã‚»ã‚¹ãƒ­ã‚°"""
        self.access_log.append({
            'timestamp': datetime.now().isoformat(),
            'username': username,
            'action': action,
            'resource': resource,
            'success': success
        })

    def get_access_log(self, username=None, limit=100):
        """ã‚¢ã‚¯ã‚»ã‚¹ãƒ­ã‚°å–å¾—"""
        logs = self.access_log[-limit:]

        if username:
            logs = [log for log in logs if log['username'] == username]

        return logs

    def check_rate_limit(self, username, max_requests=100, window_minutes=60):
        """ãƒ¬ãƒ¼ãƒˆåˆ¶é™ãƒã‚§ãƒƒã‚¯"""
        cutoff_time = datetime.now() - timedelta(minutes=window_minutes)

        recent_requests = [
            log for log in self.access_log
            if (log['username'] == username and
                datetime.fromisoformat(log['timestamp']) > cutoff_time)
        ]

        return len(recent_requests) < max_requests

# ä½¿ç”¨ä¾‹
security = SecurityManager()

# ãƒ¦ãƒ¼ã‚¶ãƒ¼ä½œæˆ
security.create_user('operator1', 'secure_password', role='operator')
security.create_user('admin1', 'admin_password', role='admin')

# èªè¨¼
is_valid = security.verify_password('operator1', 'secure_password')
print(f"Authentication: {is_valid}")

# APIã‚­ãƒ¼ç™ºè¡Œ
api_key = security.generate_api_key('operator1', expiry_days=90)
print(f"API Key: {api_key[:20]}...")

# APIã‚­ãƒ¼æ¤œè¨¼
valid, username = security.verify_api_key(api_key)
print(f"API Key Valid: {valid}, User: {username}")

# ã‚¢ã‚¯ã‚»ã‚¹ãƒ­ã‚°
security.log_access('operator1', 'PREDICT', '/api/v1/twin/predict', success=True)
security.log_access('operator1', 'PREDICT', '/api/v1/twin/predict', success=True)

# ãƒ¬ãƒ¼ãƒˆåˆ¶é™ãƒã‚§ãƒƒã‚¯
within_limit = security.check_rate_limit('operator1', max_requests=100)
print(f"Within rate limit: {within_limit}")

# ã‚¢ã‚¯ã‚»ã‚¹ãƒ­ã‚°ç¢ºèª
logs = security.get_access_log('operator1')
print(f"Access log entries: {len(logs)}")
</code></pre>

            <div class="callout callout-warning">
                <strong>âš ï¸ ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ:</strong>
                <ul>
                    <li>HTTPSé€šä¿¡ã®å¼·åˆ¶ï¼ˆTLS 1.2ä»¥ä¸Šï¼‰</li>
                    <li>èªè¨¼ãƒ»èªå¯ã®å®Ÿè£…ï¼ˆJWT, OAuth2.0ï¼‰</li>
                    <li>ãƒ¬ãƒ¼ãƒˆåˆ¶é™ã¨DDoSå¯¾ç­–</li>
                    <li>å…¥åŠ›æ¤œè¨¼ã¨SQLã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³å¯¾ç­–</li>
                    <li>ã‚¢ã‚¯ã‚»ã‚¹ãƒ­ã‚°ã®ä¿å­˜ã¨ç›£è¦–</li>
                    <li>å®šæœŸçš„ãªã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ç›£æŸ»</li>
                </ul>
            </div>

            <h2>5.7 æœ¬ç•ªã‚·ã‚¹ãƒ†ãƒ çµ±åˆä¾‹</h2>

            <p>ã™ã¹ã¦ã®è¦ç´ ã‚’çµ±åˆã—ãŸå®Œå…¨ãªæœ¬ç•ªã‚·ã‚¹ãƒ†ãƒ ã®ä¾‹ã§ã™ã€‚</p>

<pre><code>import logging
from pathlib import Path

class ProductionDigitalTwinSystem:
    """æœ¬ç•ªãƒ‡ã‚¸ã‚¿ãƒ«ãƒ„ã‚¤ãƒ³ã‚·ã‚¹ãƒ†ãƒ """

    def __init__(self, config_path):
        self.config = self._load_config(config_path)
        self.logger = self._setup_logging()

        # ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆåˆæœŸåŒ–
        self.edge_twin = EdgeDigitalTwin(self.config['model_path'])
        self.security = SecurityManager()
        self.api_service = None  # å®Ÿéš›ã¯Flaskã‚¢ãƒ—ãƒª

        self.logger.info("Production Digital Twin System initialized")

    def _load_config(self, config_path):
        """è¨­å®šèª­ã¿è¾¼ã¿"""
        with open(config_path, 'r') as f:
            return json.load(f)

    def _setup_logging(self):
        """ãƒ­ã‚®ãƒ³ã‚°è¨­å®š"""
        log_dir = Path(self.config.get('log_dir', './logs'))
        log_dir.mkdir(exist_ok=True)

        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler(log_dir / 'digital_twin.log'),
                logging.StreamHandler()
            ]
        )

        return logging.getLogger('DigitalTwinSystem')

    def start(self):
        """ã‚·ã‚¹ãƒ†ãƒ èµ·å‹•"""
        self.logger.info("Starting Digital Twin System")

        # ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯
        if not self._health_check():
            self.logger.error("Health check failed")
            return False

        # API ã‚µãƒ¼ãƒ“ã‚¹èµ·å‹•ï¼ˆå®Ÿéš›ã®å®Ÿè£…ï¼‰
        # self.api_service = DigitalTwinMicroservice(...)
        # self.api_service.run()

        self.logger.info("System started successfully")
        return True

    def _health_check(self):
        """èµ·å‹•æ™‚ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯"""
        checks = {
            'model_loaded': hasattr(self.edge_twin, 'model'),
            'config_valid': 'model_path' in self.config,
            'security_ready': self.security is not None
        }

        all_healthy = all(checks.values())

        for check, status in checks.items():
            self.logger.info(f"Health check - {check}: {'OK' if status else 'FAIL'}")

        return all_healthy

    def predict_with_monitoring(self, sensor_data, user):
        """ç›£è¦–ä»˜ãæ¨è«–"""
        try:
            # ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒã‚§ãƒƒã‚¯
            if not self.security.check_rate_limit(user):
                self.logger.warning(f"Rate limit exceeded for user: {user}")
                return {'error': 'Rate limit exceeded'}, 429

            # æ¨è«–å®Ÿè¡Œ
            result = self.edge_twin.predict(sensor_data)

            # ãƒ­ã‚°è¨˜éŒ²
            self.security.log_access(user, 'PREDICT', 'twin/predict', True)
            self.logger.info(f"Prediction successful - User: {user}, "
                           f"Time: {result['inference_time_ms']:.2f}ms")

            return result, 200

        except Exception as e:
            self.logger.error(f"Prediction error: {str(e)}")
            self.security.log_access(user, 'PREDICT', 'twin/predict', False)
            return {'error': 'Internal server error'}, 500

    def shutdown(self):
        """ã‚·ã‚¹ãƒ†ãƒ åœæ­¢"""
        self.logger.info("Shutting down Digital Twin System")

        # ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å‡¦ç†
        # - ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶šã‚¯ãƒ­ãƒ¼ã‚º
        # - ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã®ãƒ•ãƒ©ãƒƒã‚·ãƒ¥
        # - ãƒªã‚½ãƒ¼ã‚¹è§£æ”¾

        self.logger.info("System shutdown complete")

# è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ä¾‹
PRODUCTION_CONFIG = {
    "model_path": "/app/models/production_v1.0",
    "log_dir": "/var/log/digital_twin",
    "api_port": 5000,
    "max_requests_per_hour": 1000,
    "enable_monitoring": True,
    "database": {
        "host": "localhost",
        "port": 5432,
        "name": "digital_twin_db"
    }
}

# ä½¿ç”¨ä¾‹
# system = ProductionDigitalTwinSystem('config.json')
# system.start()

# æ¨è«–å®Ÿè¡Œ
# result, status = system.predict_with_monitoring(
#     {'temp': 360, 'pressure': 6.0, 'flow': 100},
#     user='operator1'
# )

print("Production system implementation complete")
</code></pre>

            <div class="callout callout-info">
                <strong>ğŸ“Š ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆæˆåŠŸäº‹ä¾‹:</strong>
                <ul>
                    <li><strong>Siemens:</strong> ã‚¯ãƒ©ã‚¦ãƒ‰ãƒ™ãƒ¼ã‚¹ã®ãƒ‡ã‚¸ã‚¿ãƒ«ãƒ„ã‚¤ãƒ³ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã§100+ãƒ—ãƒ©ãƒ³ãƒˆã‚’ç®¡ç†</li>
                    <li><strong>Shell:</strong> ã‚¨ãƒƒã‚¸+ã‚¯ãƒ©ã‚¦ãƒ‰ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰æ§‹æˆã§1msæœªæº€ã®ãƒ¬ã‚¤ãƒ†ãƒ³ã‚·ãƒ¼ã‚’é”æˆ</li>
                    <li><strong>BASF:</strong> ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã§99.99%ã®å¯ç”¨æ€§ã‚’å®Ÿç¾</li>
                </ul>
            </div>

            <h2>å­¦ç¿’ç›®æ¨™ã®ç¢ºèª</h2>

            <p>ã“ã®ç« ã‚’å®Œäº†ã™ã‚‹ã¨ã€ä»¥ä¸‹ã‚’èª¬æ˜ãƒ»å®Ÿè£…ã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ï¼š</p>

            <h3>åŸºæœ¬ç†è§£</h3>
            <ul>
                <li>âœ… ã‚¨ãƒƒã‚¸ã¨ã‚¯ãƒ©ã‚¦ãƒ‰ã®ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆã®é•ã„ã‚’èª¬æ˜ã§ãã‚‹</li>
                <li>âœ… ã‚³ãƒ³ãƒ†ãƒŠåŒ–ã®åˆ©ç‚¹ã‚’ç†è§£ã—ã¦ã„ã‚‹</li>
                <li>âœ… RESTful APIã®è¨­è¨ˆåŸå‰‡ã‚’ç†è§£ã—ã¦ã„ã‚‹</li>
                <li>âœ… æœ¬ç•ªã‚·ã‚¹ãƒ†ãƒ ã«å¿…è¦ãªã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¦ä»¶ã‚’èª¬æ˜ã§ãã‚‹</li>
            </ul>

            <h3>å®Ÿè·µã‚¹ã‚­ãƒ«</h3>
            <ul>
                <li>âœ… è»½é‡ãƒ¢ãƒ‡ãƒ«ã‚’ã‚¨ãƒƒã‚¸ãƒ‡ãƒã‚¤ã‚¹ç”¨ã«ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ãƒ³ã‚°ã§ãã‚‹</li>
                <li>âœ… Flaskã§RESTful APIã‚’å®Ÿè£…ã§ãã‚‹</li>
                <li>âœ… Dockerfileã‚’ä½œæˆã—ã‚³ãƒ³ãƒ†ãƒŠåŒ–ã§ãã‚‹</li>
                <li>âœ… Plotly Dashã§ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ã‚’æ§‹ç¯‰ã§ãã‚‹</li>
                <li>âœ… åŸºæœ¬çš„ãªã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£æ©Ÿèƒ½ã‚’å®Ÿè£…ã§ãã‚‹</li>
            </ul>

            <h3>å¿œç”¨åŠ›</h3>
            <ul>
                <li>âœ… è¦ä»¶ã«å¿œã˜ãŸé©åˆ‡ãªãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆæˆ¦ç•¥ã‚’é¸æŠã§ãã‚‹</li>
                <li>âœ… ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã‚’è¨­è¨ˆã§ãã‚‹</li>
                <li>âœ… æœ¬ç•ªç’°å¢ƒã®ç›£è¦–ã¨ãƒ­ã‚°æˆ¦ç•¥ã‚’ç«‹æ¡ˆã§ãã‚‹</li>
                <li>âœ… ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒªã‚¹ã‚¯ã‚’è©•ä¾¡ã—å¯¾ç­–ã‚’è¬›ã˜ã‚‰ã‚Œã‚‹</li>
            </ul>

            <h2>æ¼”ç¿’å•é¡Œ</h2>

            <h3>Easyï¼ˆåŸºç¤ç¢ºèªï¼‰</h3>

            <p><strong>Q1:</strong> ã‚¨ãƒƒã‚¸ãƒ‡ãƒ—ãƒ­ã‚¤ã¨ã‚¯ãƒ©ã‚¦ãƒ‰ãƒ‡ãƒ—ãƒ­ã‚¤ã®ä¸»ãªé•ã„ã‚’3ã¤æŒ™ã’ã¦ãã ã•ã„ã€‚</p>

            <details>
                <summary>è§£ç­”ã‚’è¦‹ã‚‹</summary>

                <p><strong>æ­£è§£:</strong></p>
                <table>
                    <tr>
                        <th>é …ç›®</th>
                        <th>ã‚¨ãƒƒã‚¸ãƒ‡ãƒ—ãƒ­ã‚¤</th>
                        <th>ã‚¯ãƒ©ã‚¦ãƒ‰ãƒ‡ãƒ—ãƒ­ã‚¤</th>
                    </tr>
                    <tr>
                        <td>ãƒ¬ã‚¤ãƒ†ãƒ³ã‚·ãƒ¼</td>
                        <td>ä½ï¼ˆ<1mså¯èƒ½ï¼‰</td>
                        <td>é«˜ï¼ˆ10-100msï¼‰</td>
                    </tr>
                    <tr>
                        <td>è¨ˆç®—ãƒªã‚½ãƒ¼ã‚¹</td>
                        <td>åˆ¶é™ã‚ã‚Š</td>
                        <td>ã‚¹ã‚±ãƒ¼ãƒ©ãƒ–ãƒ«</td>
                    </tr>
                    <tr>
                        <td>ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ä¾å­˜</td>
                        <td>ä½ï¼ˆã‚ªãƒ•ãƒ©ã‚¤ãƒ³å‹•ä½œå¯ï¼‰</td>
                        <td>é«˜ï¼ˆå¸¸æ™‚æ¥ç¶šå¿…è¦ï¼‰</td>
                    </tr>
                </table>

                <p><strong>è§£èª¬:</strong> ã‚¨ãƒƒã‚¸ãƒ‡ãƒ—ãƒ­ã‚¤ã¯ä½ãƒ¬ã‚¤ãƒ†ãƒ³ã‚·ãƒ¼ãŒå¿…è¦ãªãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ åˆ¶å¾¡ã«ã€ã‚¯ãƒ©ã‚¦ãƒ‰ãƒ‡ãƒ—ãƒ­ã‚¤ã¯è¤‡é›‘ãªåˆ†æã‚„è¤‡æ•°æ‹ ç‚¹ã‹ã‚‰ã®ã‚¢ã‚¯ã‚»ã‚¹ã«é©ã—ã¦ã„ã¾ã™ã€‚å®Ÿå‹™ã§ã¯ä¸¡è€…ã‚’çµ„ã¿åˆã‚ã›ãŸãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰æ§‹æˆãŒä¸€èˆ¬çš„ã§ã™ã€‚</p>
            </details>

            <h3>Mediumï¼ˆå¿œç”¨ï¼‰</h3>

            <p><strong>Q2:</strong> æœ¬ç•ªç’°å¢ƒã®ãƒ‡ã‚¸ã‚¿ãƒ«ãƒ„ã‚¤ãƒ³ã‚·ã‚¹ãƒ†ãƒ ã§å¿…é ˆã®ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å¯¾ç­–ã‚’5ã¤æŒ™ã’ã¦ãã ã•ã„ã€‚</p>

            <details>
                <summary>è§£ç­”ã‚’è¦‹ã‚‹</summary>

                <p><strong>æ­£è§£:</strong></p>
                <ol>
                    <li><strong>èªè¨¼ãƒ»èªå¯:</strong> JWTã€OAuth2.0ã«ã‚ˆã‚‹ãƒ¦ãƒ¼ã‚¶ãƒ¼èªè¨¼</li>
                    <li><strong>æš—å·åŒ–é€šä¿¡:</strong> HTTPS (TLS 1.2ä»¥ä¸Š) ã®å¼·åˆ¶</li>
                    <li><strong>å…¥åŠ›æ¤œè¨¼:</strong> SQLã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³ã€XSSå¯¾ç­–</li>
                    <li><strong>ãƒ¬ãƒ¼ãƒˆåˆ¶é™:</strong> DDoSæ”»æ’ƒå¯¾ç­–</li>
                    <li><strong>ç›£æŸ»ãƒ­ã‚°:</strong> ã™ã¹ã¦ã®ã‚¢ã‚¯ã‚»ã‚¹ã‚’è¨˜éŒ²ãƒ»ç›£è¦–</li>
                </ol>

                <p><strong>è¿½åŠ æ¨å¥¨äº‹é …:</strong></p>
                <ul>
                    <li>APIã‚­ãƒ¼ã®ãƒ­ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³</li>
                    <li>æœ€å°æ¨©é™ã®åŸå‰‡</li>
                    <li>å®šæœŸçš„ãªã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ç›£æŸ»</li>
                    <li>è„†å¼±æ€§ã‚¹ã‚­ãƒ£ãƒ³</li>
                </ul>
            </details>

            <h3>Hardï¼ˆç™ºå±•ï¼‰</h3>

            <p><strong>Q3:</strong> æä¾›ã•ã‚ŒãŸProductionDigitalTwinSystemã‚¯ãƒ©ã‚¹ã‚’æ‹¡å¼µã—ã€ä»¥ä¸‹ã®æ©Ÿèƒ½ã‚’è¿½åŠ ã—ã¦ãã ã•ã„ï¼š
            <ol>
                <li>ãƒ¢ãƒ‡ãƒ«ã®A/Bãƒ†ã‚¹ãƒˆæ©Ÿèƒ½ï¼ˆ2ã¤ã®ãƒ¢ãƒ‡ãƒ«ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«åˆ‡ã‚Šæ›¿ãˆï¼‰</li>
                <li>äºˆæ¸¬çµæœã®ã‚­ãƒ£ãƒƒã‚·ãƒ³ã‚°ï¼ˆåŒã˜å…¥åŠ›ã¸ã®å†è¨ˆç®—ã‚’é˜²ãï¼‰</li>
                <li>ç•°å¸¸æ¤œçŸ¥ã‚¢ãƒ©ãƒ¼ãƒˆï¼ˆäºˆæ¸¬å€¤ãŒç•°å¸¸ç¯„å›²ã®å ´åˆã«é€šçŸ¥ï¼‰</li>
            </ol>
            </p>

            <details>
                <summary>è§£ç­”ä¾‹ã‚’è¦‹ã‚‹</summary>

<pre><code>import hashlib
from collections import OrderedDict
import random

class AdvancedProductionSystem(ProductionDigitalTwinSystem):
    """æ‹¡å¼µæœ¬ç•ªã‚·ã‚¹ãƒ†ãƒ """

    def __init__(self, config_path):
        super().__init__(config_path)

        # A/Bãƒ†ã‚¹ãƒˆç”¨ã«2ã¤ã®ãƒ¢ãƒ‡ãƒ«
        self.model_a = EdgeDigitalTwin(self.config['model_path_a'])
        self.model_b = EdgeDigitalTwin(self.config['model_path_b'])
        self.ab_ratio = 0.5  # 50/50åˆ†å‰²

        # ã‚­ãƒ£ãƒƒã‚·ãƒ¥ï¼ˆæœ€å¤§1000ã‚¨ãƒ³ãƒˆãƒªã€LRUï¼‰
        self.cache = OrderedDict()
        self.cache_max_size = 1000

        # ç•°å¸¸æ¤œçŸ¥ã—ãã„å€¤
        self.alert_thresholds = {
            'min': 70,
            'max': 95
        }

    def _get_cache_key(self, sensor_data):
        """ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚­ãƒ¼ç”Ÿæˆ"""
        # ã‚»ãƒ³ã‚µãƒ¼ãƒ‡ãƒ¼ã‚¿ã‚’ã‚½ãƒ¼ãƒˆã—ã¦ä¸€æ„ãªã‚­ãƒ¼ã‚’ç”Ÿæˆ
        sorted_data = json.dumps(sensor_data, sort_keys=True)
        return hashlib.md5(sorted_data.encode()).hexdigest()

    def predict_with_cache(self, sensor_data, user):
        """ã‚­ãƒ£ãƒƒã‚·ãƒ¥ä»˜ãæ¨è«–"""
        cache_key = self._get_cache_key(sensor_data)

        # ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ’ãƒƒãƒˆ
        if cache_key in self.cache:
            self.logger.info(f"Cache hit for user: {user}")
            result = self.cache[cache_key]
            result['from_cache'] = True
            return result, 200

        # A/Bãƒ†ã‚¹ãƒˆ: ãƒ¢ãƒ‡ãƒ«é¸æŠ
        use_model_a = random.random() < self.ab_ratio
        model = self.model_a if use_model_a else self.model_b
        model_version = 'A' if use_model_a else 'B'

        # æ¨è«–å®Ÿè¡Œ
        result = model.predict(sensor_data)
        result['model_version'] = model_version
        result['from_cache'] = False

        # ç•°å¸¸æ¤œçŸ¥
        if self._is_anomaly(result['prediction']):
            self._send_alert(user, sensor_data, result)

        # ã‚­ãƒ£ãƒƒã‚·ãƒ¥ä¿å­˜ï¼ˆLRUï¼‰
        self.cache[cache_key] = result
        if len(self.cache) > self.cache_max_size:
            self.cache.popitem(last=False)  # æœ€å¤ã‚’å‰Šé™¤

        # ãƒ­ã‚°è¨˜éŒ²
        self.security.log_access(user, 'PREDICT', 'twin/predict', True)
        self.logger.info(f"Prediction - User: {user}, Model: {model_version}, "
                        f"Result: {result['prediction']:.2f}")

        return result, 200

    def _is_anomaly(self, prediction):
        """ç•°å¸¸åˆ¤å®š"""
        return (prediction < self.alert_thresholds['min'] or
                prediction > self.alert_thresholds['max'])

    def _send_alert(self, user, sensor_data, result):
        """ã‚¢ãƒ©ãƒ¼ãƒˆé€ä¿¡"""
        alert_message = (
            f"ANOMALY DETECTED\\n"
            f"User: {user}\\n"
            f"Prediction: {result['prediction']:.2f}\\n"
            f"Sensor Data: {sensor_data}\\n"
            f"Expected Range: [{self.alert_thresholds['min']}, "
            f"{self.alert_thresholds['max']}]"
        )

        self.logger.warning(alert_message)

        # å®Ÿéš›ã¯ email/Slack/SMS é€šçŸ¥
        print(f"ğŸš¨ ALERT: {alert_message}")

    def get_ab_test_stats(self):
        """A/Bãƒ†ã‚¹ãƒˆçµ±è¨ˆ"""
        # å®Ÿéš›ã¯ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‹ã‚‰é›†è¨ˆ
        return {
            'model_a_count': 0,
            'model_b_count': 0,
            'cache_hit_rate': 0.0
        }

# ä½¿ç”¨ä¾‹
# config = {
#     'model_path_a': './models/v1.0',
#     'model_path_b': './models/v1.1',
#     'log_dir': './logs'
# }
# system = AdvancedProductionSystem('config.json')
# result, status = system.predict_with_cache(
#     {'temp': 360, 'pressure': 6.0, 'flow': 100},
#     'operator1'
# )
# print(f"Prediction: {result['prediction']:.2f}")
# print(f"Model: {result['model_version']}, Cache: {result['from_cache']}")

print("Advanced production system implementation complete")
</code></pre>

                <p><strong>è§£èª¬:</strong> ã“ã®å®Ÿè£…ã§ã¯ã€A/Bãƒ†ã‚¹ãƒˆã§ãƒ¢ãƒ‡ãƒ«æ€§èƒ½ã‚’æ¯”è¼ƒã—ã€ã‚­ãƒ£ãƒƒã‚·ãƒ³ã‚°ã§è¨ˆç®—ã‚³ã‚¹ãƒˆã‚’å‰Šæ¸›ã—ã€ç•°å¸¸æ¤œçŸ¥ã§é‹è»¢å“¡ã«å³åº§ã«ã‚¢ãƒ©ãƒ¼ãƒˆã‚’é€ä¿¡ã—ã¾ã™ã€‚æœ¬ç•ªã‚·ã‚¹ãƒ†ãƒ ã§ã¯ã“ã‚Œã‚‰ã®æ©Ÿèƒ½ãŒé‹ç”¨åŠ¹ç‡ã‚’å¤§ããå‘ä¸Šã•ã›ã¾ã™ã€‚</p>
            </details>

            <h2>ã¾ã¨ã‚</h2>

            <p>ç¬¬5ç« ã§ã¯ã€ãƒ‡ã‚¸ã‚¿ãƒ«ãƒ„ã‚¤ãƒ³ã®æœ¬ç•ªãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆã«ã¤ã„ã¦å­¦ã³ã¾ã—ãŸã€‚ã‚¨ãƒƒã‚¸ã‹ã‚‰ã‚¯ãƒ©ã‚¦ãƒ‰ã¾ã§ã€ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‹ã‚‰ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°ã¾ã§ã€å®Ÿç”¨çš„ãªå®Ÿè£…ä¾‹ã‚’é€šã˜ã¦ç†è§£ã‚’æ·±ã‚ã¾ã—ãŸã€‚</p>

            <p>ã“ã®ã‚·ãƒªãƒ¼ã‚ºã‚’é€šã˜ã¦ã€ãƒ‡ã‚¸ã‚¿ãƒ«ãƒ„ã‚¤ãƒ³ã®åŸºç¤ã‹ã‚‰å¿œç”¨ã€å®Ÿè£…ã€ãƒ‡ãƒ—ãƒ­ã‚¤ã¾ã§ã®å…¨ä½“åƒã‚’ç¿’å¾—ã—ã¾ã—ãŸã€‚æ¬¡ã¯ã€å®Ÿéš›ã®ãƒ—ãƒ­ã‚»ã‚¹ã«é©ç”¨ã—ã€ç¶™ç¶šçš„ã«æ”¹å–„ã—ã¦ã„ããƒ•ã‚§ãƒ¼ã‚ºã§ã™ã€‚</p>

            <div class="callout callout-tip">
                <strong>ğŸ“ æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—:</strong>
                <ul>
                    <li>è‡ªç¤¾ãƒ—ãƒ­ã‚»ã‚¹ã§ã®å°è¦æ¨¡PoCï¼ˆæ¦‚å¿µå®Ÿè¨¼ï¼‰ã‚’å®Ÿæ–½</li>
                    <li>æ®µéšçš„ã«æ©Ÿèƒ½ã‚’æ‹¡å¼µï¼ˆãƒ¢ãƒ‡ãƒ«ç²¾åº¦å‘ä¸Šã€æœ€é©åŒ–æ©Ÿèƒ½è¿½åŠ ï¼‰</li>
                    <li>é‹ç”¨ãƒ‡ãƒ¼ã‚¿ã‚’è“„ç©ã—ã€ç¶™ç¶šçš„ãªæ”¹å–„ã‚µã‚¤ã‚¯ãƒ«ã‚’ç¢ºç«‹</li>
                    <li>ä»–ã®ãƒ‡ã‚¸ã‚¿ãƒ«åŒ–æ–½ç­–ï¼ˆMESã€ERPãªã©ï¼‰ã¨ã®çµ±åˆã‚’æ¤œè¨</li>
                </ul>
            </div>

            <div class="nav-buttons">
                <a href="chapter-4.html" class="nav-button">â† ç¬¬4ç« : ä»®æƒ³æœ€é©åŒ–</a>
                <a href="index.html" class="nav-button">ã‚·ãƒªãƒ¼ã‚ºç›®æ¬¡ã¸</a>
            </div>
        </section>
    </main>

    <footer style="background-color: var(--color-bg-alt); padding: var(--spacing-lg); text-align: center; margin-top: var(--spacing-xl); border-top: 1px solid var(--color-border);">
        <p><a href="index.html">ã‚·ãƒªãƒ¼ã‚ºç›®æ¬¡ã«æˆ»ã‚‹</a> | <a href="../index.html">PIãƒŠãƒ¬ãƒƒã‚¸ãƒ™ãƒ¼ã‚¹ãƒˆãƒƒãƒ—</a></p>
        <p style="margin-top: var(--spacing-sm); color: var(--color-text-light); font-size: 0.9rem;">
            &copy; 2025 PI Terakoya | æ±åŒ—å¤§å­¦ æ©‹æœ¬é›„ä»‹ç ”ç©¶å®¤
        </p>
    </footer>
</body>
</html>
