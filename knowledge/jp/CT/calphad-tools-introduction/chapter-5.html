<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 5: Pythonå®Ÿè·µï¼špycalphadæ´»ç”¨ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ | CALPHAD Toolså…¥é–€</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', 'Hiragino Sans', 'Hiragino Kaku Gothic ProN', Meiryo, sans-serif;
            line-height: 1.8;
            color: #2c3e50;
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            background: white;
            padding: 40px;
            border-radius: 10px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.1);
        }

        h1 {
            color: #11998e;
            font-size: 2.5em;
            margin-bottom: 30px;
            border-bottom: 3px solid #38ef7d;
            padding-bottom: 15px;
        }

        h2 {
            color: #0d7f75;
            font-size: 1.8em;
            margin-top: 40px;
            margin-bottom: 20px;
            border-left: 5px solid #38ef7d;
            padding-left: 15px;
        }

        h3 {
            color: #16a085;
            font-size: 1.3em;
            margin-top: 30px;
            margin-bottom: 15px;
        }

        p {
            margin-bottom: 15px;
            text-align: justify;
        }

        .math {
            overflow-x: auto;
            margin: 20px 0;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
        }

        pre {
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 20px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 20px 0;
        }

        code {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.9em;
        }

        .info-box {
            background: #e8f8f5;
            border-left: 4px solid #16a085;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .warning-box {
            background: #fef5e7;
            border-left: 4px solid #f39c12;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .exercise-box {
            background: #eafaf1;
            border: 2px solid #27ae60;
            padding: 20px;
            margin: 30px 0;
            border-radius: 8px;
        }

        .exercise-box h4 {
            color: #27ae60;
            margin-bottom: 15px;
        }

        .solution {
            background: #e8f8f5;
            padding: 15px;
            margin-top: 15px;
            border-radius: 5px;
            display: none;
        }

        .solution.show {
            display: block;
        }

        .toggle-solution {
            background: #27ae60;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 10px;
        }

        .toggle-solution:hover {
            background: #229954;
        }

        ul, ol {
            margin-left: 30px;
            margin-bottom: 15px;
        }

        li {
            margin-bottom: 8px;
        }

        .nav-buttons {
            display: flex;
            justify-content: space-between;
            margin-top: 50px;
            padding-top: 30px;
            border-top: 2px solid #38ef7d;
        }

        .nav-button {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
            color: white;
            padding: 12px 24px;
            text-decoration: none;
            border-radius: 5px;
            transition: transform 0.2s;
        }

        .nav-button:hover {
            transform: translateY(-2px);
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }

        th, td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }

        th {
            background: #11998e;
            color: white;
        }

        tr:nth-child(even) {
            background: #f8f9fa;
        }

        .learning-objectives {
            background: #eafaf1;
            border: 2px solid #27ae60;
            border-radius: 8px;
            padding: 20px;
            margin: 30px 0;
        }

        .learning-objectives h3 {
            color: #27ae60;
            margin-top: 0;
        }

        .objective-list {
            list-style: none;
            margin-left: 0;
        }

        .objective-list li {
            padding-left: 30px;
            position: relative;
            margin-bottom: 12px;
        }

        .objective-list li:before {
            content: "âœ“";
            position: absolute;
            left: 0;
            color: #27ae60;
            font-weight: bold;
            font-size: 1.2em;
        }

        footer {
            margin-top: 50px;
            padding-top: 20px;
            border-top: 2px solid #ecf0f1;
            text-align: center;
            color: #7f8c8d;
        }

        .mermaid {
            background: white;
            padding: 20px;
            border-radius: 5px;
            margin: 20px 0;
        }



        /* Breadcrumb styles */
        .breadcrumb {
            background: #f7fafc;
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #e2e8f0;
            font-size: 0.9rem;
        }

        .breadcrumb-content {
            max-width: 900px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .breadcrumb a {
            color: #11998e;
            text-decoration: none;
            transition: color 0.2s;
        }

        .breadcrumb a:hover {
            color: #0d7f75;
            text-decoration: underline;
        }

        .breadcrumb-separator {
            color: #a0aec0;
            margin: 0 0.25rem;
        }

        .breadcrumb-current {
            color: #4a5568;
            font-weight: 500;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
    <script>mermaid.initialize({startOnLoad:true});</script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
            <nav class="breadcrumb">
        <div class="breadcrumb-content">
            <a href="/AI-Knowledge-Notes/knowledge/jp/index.html">AIå¯ºå­å±‹ãƒˆãƒƒãƒ—</a><span class="breadcrumb-separator">â€º</span><a href="/AI-Knowledge-Notes/knowledge/jp/CT/index.html">è¨ˆç®—ç†±åŠ›å­¦ãƒ„ãƒ¼ãƒ«</a><span class="breadcrumb-separator">â€º</span><a href="/AI-Knowledge-Notes/knowledge/jp/CT/calphad-tools-introduction/index.html">CALPHAD Toolså…¥é–€</a><span class="breadcrumb-separator">â€º</span><span class="breadcrumb-current">Chapter 5</span>
        </div>
    </nav>
<div class="container">
        <h1>Chapter 5: Pythonå®Ÿè·µï¼špycalphadæ´»ç”¨ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼</h1>
        <p><strong>è‡ªå‹•åŒ–ã•ã‚ŒãŸCALPHADè¨ˆç®—ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã¨ææ–™ã‚¹ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°</strong></p>

        <div class="learning-objectives">
            <h3>ğŸ¯ ã“ã®ç« ã®å­¦ç¿’ç›®æ¨™</h3>
            <ul class="objective-list">
                <li><strong>ãƒ¬ãƒ™ãƒ«1ï¼ˆåŸºæœ¬ç†è§£ï¼‰</strong>: pycalphadãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã®åŸºæœ¬æ§‹é€ ï¼ˆãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹èª­ã¿è¾¼ã¿â†’è¨ˆç®—â†’å¯è¦–åŒ–ï¼‰ã‚’ç†è§£ã™ã‚‹</li>
                <li><strong>ãƒ¬ãƒ™ãƒ«1ï¼ˆåŸºæœ¬ç†è§£ï¼‰</strong>: ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ç®¡ç†ã¨ä¾å­˜æ€§ã®é‡è¦æ€§ã‚’èª¬æ˜ã§ãã‚‹</li>
                <li><strong>ãƒ¬ãƒ™ãƒ«1ï¼ˆåŸºæœ¬ç†è§£ï¼‰</strong>: ãƒãƒƒãƒè¨ˆç®—ã«ãŠã‘ã‚‹ä¸¦åˆ—åŒ–ã¨ãƒªã‚½ãƒ¼ã‚¹ç®¡ç†ã®å¿…è¦æ€§ã‚’ç†è§£ã™ã‚‹</li>
                <li><strong>ãƒ¬ãƒ™ãƒ«1ï¼ˆåŸºæœ¬ç†è§£ï¼‰</strong>: pymatgenã€ASEã¨ã®é€£æºã«ã‚ˆã‚‹ææ–™ç§‘å­¦ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã®å…¨ä½“åƒã‚’æŠŠæ¡ã™ã‚‹</li>
                <li><strong>ãƒ¬ãƒ™ãƒ«2ï¼ˆå®Ÿè·µã‚¹ã‚­ãƒ«ï¼‰</strong>: TDBãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚’å®Ÿè£…ã—ã€ãƒãƒ¼ã‚¸ãƒ§ãƒ³ç®¡ç†ã¨æ¤œè¨¼ãŒã§ãã‚‹</li>
                <li><strong>ãƒ¬ãƒ™ãƒ«2ï¼ˆå®Ÿè·µã‚¹ã‚­ãƒ«ï¼‰</strong>: ãƒãƒƒãƒç›¸å›³è¨ˆç®—ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚’æ§‹ç¯‰ã—ã€è¤‡æ•°ç³»ã®è‡ªå‹•å‡¦ç†ãŒã§ãã‚‹</li>
                <li><strong>ãƒ¬ãƒ™ãƒ«2ï¼ˆå®Ÿè·µã‚¹ã‚­ãƒ«ï¼‰</strong>: ã‚«ã‚¹ã‚¿ãƒ å¯è¦–åŒ–é–¢æ•°ã‚’å®Ÿè£…ã—ã€å‡ºç‰ˆå“è³ªã®ã‚°ãƒ©ãƒ•ã‚’ç”Ÿæˆã§ãã‚‹</li>
                <li><strong>ãƒ¬ãƒ™ãƒ«2ï¼ˆå®Ÿè·µã‚¹ã‚­ãƒ«ï¼‰</strong>: pymatgenã¨é€£æºã—ã€Materials Project APIã‹ã‚‰ç†±åŠ›å­¦ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã§ãã‚‹</li>
                <li><strong>ãƒ¬ãƒ™ãƒ«2ï¼ˆå®Ÿè·µã‚¹ã‚­ãƒ«ï¼‰</strong>: ASEã¨é€£æºã—ã€åŸå­æ§‹é€ ã¨ç†±åŠ›å­¦ãƒ‡ãƒ¼ã‚¿ã‚’çµ±åˆã§ãã‚‹</li>
                <li><strong>ãƒ¬ãƒ™ãƒ«2ï¼ˆå®Ÿè·µã‚¹ã‚­ãƒ«ï¼‰</strong>: ææ–™ã‚¹ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚’æ§‹ç¯‰ã—ã€ç›®çš„ã«å¿œã˜ãŸå€™è£œææ–™ã‚’æŠ½å‡ºã§ãã‚‹</li>
                <li><strong>ãƒ¬ãƒ™ãƒ«3ï¼ˆå¿œç”¨åŠ›ï¼‰</strong>: è¤‡é›‘ãªå¤šæˆåˆ†ç³»ã®è‡ªå‹•è§£æãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã‚’è¨­è¨ˆãƒ»å®Ÿè£…ã§ãã‚‹</li>
                <li><strong>ãƒ¬ãƒ™ãƒ«3ï¼ˆå¿œç”¨åŠ›ï¼‰</strong>: ç¬¬ä¸€åŸç†è¨ˆç®—ã¨CALPHADã‚’é€£æºã•ã›ãŸãƒãƒ«ãƒã‚¹ã‚±ãƒ¼ãƒ«è§£æãŒã§ãã‚‹</li>
                <li><strong>ãƒ¬ãƒ™ãƒ«3ï¼ˆå¿œç”¨åŠ›ï¼‰</strong>: å®Ÿé¨“ãƒ‡ãƒ¼ã‚¿ã¨ã®æ¯”è¼ƒæ¤œè¨¼ã‚’è‡ªå‹•åŒ–ã—ã€ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®ä¿¡é ¼æ€§ã‚’è©•ä¾¡ã§ãã‚‹</li>
            </ul>
        </div>

        <h2>5.1 å®Œå…¨è‡ªå‹•åŒ–ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®æ§‹ç¯‰</h2>

        <p>
            å®Ÿéš›ã®ææ–™é–‹ç™ºã§ã¯ã€å˜ä¸€ã®ç›¸å›³è¨ˆç®—ã§ã¯ãªãã€<strong>æ•°ç™¾ï½æ•°åƒã®è¨ˆç®—ã‚’ä½“ç³»çš„ã«å®Ÿè¡Œ</strong>ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚æœ¬ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã§ã¯ã€ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ç®¡ç†ã‹ã‚‰ãƒãƒƒãƒè¨ˆç®—ã€å¯è¦–åŒ–ã€çµæœã®é›†ç´„ã¾ã§ã‚’è‡ªå‹•åŒ–ã™ã‚‹ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚’æ§‹ç¯‰ã—ã¾ã™ã€‚
        </p>

        <h3>ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®å…¨ä½“åƒ</h3>

        <div class="mermaid">
        flowchart TD
            A[TDBãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ç®¡ç†] --> B[è¨ˆç®—æ¡ä»¶å®šç¾©YAML/JSON]
            B --> C[ãƒãƒƒãƒè¨ˆç®—ã‚¨ãƒ³ã‚¸ãƒ³]
            C --> D{ä¸¦åˆ—åŒ–æˆ¦ç•¥}
            D -->|multiprocessing| E[ãƒ­ãƒ¼ã‚«ãƒ«ä¸¦åˆ—å®Ÿè¡Œ]
            D -->|dask| F[åˆ†æ•£ä¸¦åˆ—å®Ÿè¡Œ]
            D -->|HPC| G[ã‚¯ãƒ©ã‚¹ã‚¿æŠ•å…¥]
            E --> H[çµæœãƒ‡ãƒ¼ã‚¿é›†ç´„CSV/HDF5]
            F --> H
            G --> H
            H --> I[è‡ªå‹•å¯è¦–åŒ–matplotlib/plotly]
            I --> J[ãƒ¬ãƒãƒ¼ãƒˆç”ŸæˆPDF/HTML]
            J --> K[ææ–™ã‚¹ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°]

            style A fill:#e8f8f5
            style C fill:#aed6f1
            style H fill:#f9e79f
            style K fill:#abebc6
        </div>

        <h3>ã‚³ãƒ¼ãƒ‰ä¾‹1: TDBãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼</h3>

        <pre><code class="language-python">import os
import json
import hashlib
from pathlib import Path
from datetime import datetime
from typing import Dict, List, Optional
from pycalphad import Database

class TDBManager:
    """
    TDBãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ç®¡ç†ã¨ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿è¿½è·¡

    Features:
    - ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®ãƒãƒƒã‚·ãƒ¥ãƒ™ãƒ¼ã‚¹å¤‰æ›´æ¤œå‡º
    - ä½¿ç”¨å±¥æ­´ã®ãƒ­ã‚°è¨˜éŒ²
    - ä¾å­˜ã™ã‚‹ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³è¨˜éŒ²
    - ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®æ•´åˆæ€§æ¤œè¨¼
    """

    def __init__(self, database_dir: str = "./databases"):
        self.database_dir = Path(database_dir)
        self.database_dir.mkdir(parents=True, exist_ok=True)
        self.metadata_file = self.database_dir / "metadata.json"
        self.metadata = self._load_metadata()

    def _load_metadata(self) -> Dict:
        """ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿"""
        if self.metadata_file.exists():
            with open(self.metadata_file, 'r') as f:
                return json.load(f)
        return {"databases": {}, "usage_history": []}

    def _save_metadata(self):
        """ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ãƒ•ã‚¡ã‚¤ãƒ«ã®ä¿å­˜"""
        with open(self.metadata_file, 'w') as f:
            json.dump(self.metadata, f, indent=2)

    def _compute_hash(self, file_path: Path) -> str:
        """ãƒ•ã‚¡ã‚¤ãƒ«ã®SHA256ãƒãƒƒã‚·ãƒ¥è¨ˆç®—"""
        sha256 = hashlib.sha256()
        with open(file_path, 'rb') as f:
            for chunk in iter(lambda: f.read(4096), b""):
                sha256.update(chunk)
        return sha256.hexdigest()

    def register_database(self, tdb_path: str, name: str,
                          description: str = "", source: str = ""):
        """
        æ–°ã—ã„ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®ç™»éŒ²

        Parameters:
        -----------
        tdb_path : str
            TDBãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹
        name : str
            ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®è­˜åˆ¥å
        description : str
            ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®èª¬æ˜
        source : str
            ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®å‡ºå…¸ï¼ˆè«–æ–‡ã€ã‚¦ã‚§ãƒ–ã‚µã‚¤ãƒˆç­‰ï¼‰
        """
        tdb_path = Path(tdb_path)
        if not tdb_path.exists():
            raise FileNotFoundError(f"TDB file not found: {tdb_path}")

        # ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®æ¤œè¨¼ï¼ˆpycalphadã§ã®èª­ã¿è¾¼ã¿ç¢ºèªï¼‰
        try:
            db = Database(str(tdb_path))
        except Exception as e:
            raise ValueError(f"Invalid TDB file: {e}")

        # ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«ã‚³ãƒ”ãƒ¼
        dest_path = self.database_dir / tdb_path.name
        import shutil
        shutil.copy(tdb_path, dest_path)

        # ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã®è¨˜éŒ²
        file_hash = self._compute_hash(dest_path)
        self.metadata["databases"][name] = {
            "filename": tdb_path.name,
            "path": str(dest_path),
            "hash": file_hash,
            "description": description,
            "source": source,
            "registered_at": datetime.now().isoformat(),
            "elements": sorted(db.elements),
            "phases": sorted(db.phases.keys())
        }
        self._save_metadata()
        print(f"âœ“ Database '{name}' registered successfully")
        print(f"  Elements: {', '.join(db.elements)}")
        print(f"  Phases: {', '.join(db.phases.keys())}")

    def load_database(self, name: str) -> Database:
        """
        ç™»éŒ²ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®èª­ã¿è¾¼ã¿ã¨ä½¿ç”¨å±¥æ­´ã®è¨˜éŒ²

        Parameters:
        -----------
        name : str
            ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹è­˜åˆ¥å

        Returns:
        --------
        Database
            pycalphad Databaseã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
        """
        if name not in self.metadata["databases"]:
            raise ValueError(f"Database '{name}' not found. Available: "
                             f"{list(self.metadata['databases'].keys())}")

        db_info = self.metadata["databases"][name]
        db_path = Path(db_info["path"])

        # ãƒãƒƒã‚·ãƒ¥æ¤œè¨¼ï¼ˆãƒ•ã‚¡ã‚¤ãƒ«ã®æ”¹ã–ã‚“æ¤œå‡ºï¼‰
        current_hash = self._compute_hash(db_path)
        if current_hash != db_info["hash"]:
            raise ValueError(f"Database '{name}' has been modified! "
                             f"Hash mismatch detected.")

        # ä½¿ç”¨å±¥æ­´ã®è¨˜éŒ²
        self.metadata["usage_history"].append({
            "database": name,
            "timestamp": datetime.now().isoformat(),
            "pycalphad_version": self._get_pycalphad_version()
        })
        self._save_metadata()

        return Database(str(db_path))

    def _get_pycalphad_version(self) -> str:
        """pycalphadã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³å–å¾—"""
        import pycalphad
        return pycalphad.__version__

    def list_databases(self) -> Dict:
        """ç™»éŒ²ã•ã‚Œã¦ã„ã‚‹ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®ãƒªã‚¹ãƒˆè¡¨ç¤º"""
        return self.metadata["databases"]

    def verify_integrity(self) -> bool:
        """å…¨ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®æ•´åˆæ€§æ¤œè¨¼"""
        all_valid = True
        for name, db_info in self.metadata["databases"].items():
            db_path = Path(db_info["path"])
            if not db_path.exists():
                print(f"âœ— Database '{name}': File not found")
                all_valid = False
                continue

            current_hash = self._compute_hash(db_path)
            if current_hash != db_info["hash"]:
                print(f"âœ— Database '{name}': Hash mismatch")
                all_valid = False
            else:
                print(f"âœ“ Database '{name}': OK")

        return all_valid

# ä½¿ç”¨ä¾‹
if __name__ == "__main__":
    # ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã®åˆæœŸåŒ–
    manager = TDBManager("./my_databases")

    # AlNiç³»ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®ç™»éŒ²
    manager.register_database(
        tdb_path="AlNi_Dupin_2001.tdb",
        name="AlNi-Dupin2001",
        description="Al-Ni binary system",
        source="N. Dupin et al., Calphad 25(2), 279-298 (2001)"
    )

    # ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®èª­ã¿è¾¼ã¿
    db = manager.load_database("AlNi-Dupin2001")

    # æ•´åˆæ€§æ¤œè¨¼
    manager.verify_integrity()

    # ç™»éŒ²ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®ãƒªã‚¹ãƒˆè¡¨ç¤º
    import pprint
    pprint.pprint(manager.list_databases())
</code></pre>

        <div class="info-box">
            <strong>ğŸ’¡ ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ç®¡ç†ã®ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹</strong><br>
            CALPHADãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã¯é »ç¹ã«æ›´æ–°ã•ã‚Œã€åŒã˜ç³»ã§ã‚‚è¤‡æ•°ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãŒå­˜åœ¨ã—ã¾ã™ã€‚SHA256ãƒãƒƒã‚·ãƒ¥ã«ã‚ˆã‚‹å¤‰æ›´æ¤œå‡ºã¨ä½¿ç”¨å±¥æ­´ã®è¨˜éŒ²ã«ã‚ˆã‚Šã€<strong>å†ç¾æ€§</strong>ãŒä¿è¨¼ã•ã‚Œã¾ã™ã€‚è«–æ–‡åŸ·ç­†æ™‚ã«ã¯ã€ä½¿ç”¨ã—ãŸãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¨ãƒãƒƒã‚·ãƒ¥å€¤ã‚’è¨˜è¼‰ã™ã‚‹ã“ã¨ã§ã€ä»–ã®ç ”ç©¶è€…ãŒå®Œå…¨ã«åŒã˜è¨ˆç®—ã‚’å†ç¾ã§ãã¾ã™ã€‚
        </div>

        <h3>ã‚³ãƒ¼ãƒ‰ä¾‹2: ãƒãƒƒãƒç›¸å›³è¨ˆç®—ã‚¨ãƒ³ã‚¸ãƒ³</h3>

        <pre><code class="language-python">import multiprocessing as mp
from concurrent.futures import ProcessPoolExecutor
import pandas as pd
import numpy as np
from pycalphad import Database, equilibrium, variables as v
from pathlib import Path
import yaml
from typing import List, Dict
import time

class BatchPhaseDiagramCalculator:
    """
    ãƒãƒƒãƒç›¸å›³è¨ˆç®—ã‚¨ãƒ³ã‚¸ãƒ³ï¼ˆä¸¦åˆ—åŒ–å¯¾å¿œï¼‰

    Features:
    - YAMLè¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã«ã‚ˆã‚‹è¨ˆç®—æ¡ä»¶ç®¡ç†
    - multiprocessingã«ã‚ˆã‚‹ä¸¦åˆ—åŒ–
    - é€²æ—çŠ¶æ³ã®ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ è¡¨ç¤º
    - ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã¨éƒ¨åˆ†çµæœã®ä¿å­˜
    """

    def __init__(self, config_file: str, db_manager: TDBManager):
        self.config = self._load_config(config_file)
        self.db_manager = db_manager
        self.results = []

    def _load_config(self, config_file: str) -> Dict:
        """YAMLè¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿"""
        with open(config_file, 'r') as f:
            return yaml.safe_load(f)

    def _single_calculation(self, task: Dict) -> Dict:
        """
        å˜ä¸€ã®ç›¸å›³è¨ˆç®—ã‚¿ã‚¹ã‚¯

        Parameters:
        -----------
        task : Dict
            è¨ˆç®—ã‚¿ã‚¹ã‚¯è¨­å®šï¼ˆçµ„æˆã€æ¸©åº¦ç¯„å›²ç­‰ï¼‰

        Returns:
        --------
        Dict
            è¨ˆç®—çµæœï¼ˆç›¸å¹³è¡¡ã€çµ„æˆã€æ¸©åº¦ï¼‰
        """
        try:
            # ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹èª­ã¿è¾¼ã¿
            db = self.db_manager.load_database(task['database'])

            # çµ„æˆæ¡ä»¶ã®è¨­å®š
            components = task['components']
            conditions = {
                v.T: task['temperature_range'],
                v.P: task.get('pressure', 101325),
                v.X(task['varying_component']): task['composition_range']
            }

            # å¹³è¡¡è¨ˆç®—
            eq = equilibrium(db, components, task['phases'], conditions)

            # çµæœã®æŠ½å‡º
            result = {
                'system': '-'.join(components),
                'temperature': eq.T.values,
                'composition': eq.X.sel(component=task['varying_component']).values,
                'phases': eq.Phase.values,
                'stable_phases': self._extract_stable_phases(eq),
                'success': True,
                'error': None
            }

            return result

        except Exception as e:
            return {
                'system': '-'.join(task['components']),
                'success': False,
                'error': str(e)
            }

    def _extract_stable_phases(self, eq_result) -> List[str]:
        """å®‰å®šç›¸ã®æŠ½å‡º"""
        # å„ç‚¹ã§ç›¸åˆ†ç‡ > 0.01 ã®ç›¸ã‚’æŠ½å‡º
        stable = []
        for phase in eq_result.Phase.values:
            if (eq_result.NP.sel(Phase=phase).values > 0.01).any():
                stable.append(phase)
        return stable

    def run_batch(self, n_workers: int = None):
        """
        ãƒãƒƒãƒè¨ˆç®—ã®å®Ÿè¡Œï¼ˆä¸¦åˆ—åŒ–ï¼‰

        Parameters:
        -----------
        n_workers : int
            ä¸¦åˆ—ãƒ¯ãƒ¼ã‚«ãƒ¼æ•°ï¼ˆNoneã®å ´åˆã¯CPUã‚³ã‚¢æ•°ï¼‰
        """
        tasks = self.config['calculations']
        if n_workers is None:
            n_workers = mp.cpu_count()

        print(f"Starting batch calculation: {len(tasks)} tasks, {n_workers} workers")
        start_time = time.time()

        with ProcessPoolExecutor(max_workers=n_workers) as executor:
            futures = [executor.submit(self._single_calculation, task)
                       for task in tasks]

            # é€²æ—è¡¨ç¤º
            for i, future in enumerate(futures):
                result = future.result()
                self.results.append(result)

                if result['success']:
                    print(f"âœ“ [{i+1}/{len(tasks)}] {result['system']} completed")
                else:
                    print(f"âœ— [{i+1}/{len(tasks)}] {result['system']} failed: {result['error']}")

        elapsed = time.time() - start_time
        success_count = sum(1 for r in self.results if r['success'])
        print(f"\n{'='*60}")
        print(f"Batch calculation completed in {elapsed:.1f} seconds")
        print(f"Success: {success_count}/{len(tasks)}")
        print(f"{'='*60}")

    def save_results(self, output_dir: str = "./results"):
        """
        çµæœã®ä¿å­˜ï¼ˆCSV + HDF5ï¼‰

        Parameters:
        -----------
        output_dir : str
            å‡ºåŠ›ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª
        """
        output_path = Path(output_dir)
        output_path.mkdir(parents=True, exist_ok=True)

        # ã‚µãƒãƒªãƒ¼CSVã®ä½œæˆ
        summary_data = []
        for result in self.results:
            summary_data.append({
                'system': result['system'],
                'success': result['success'],
                'stable_phases': ', '.join(result.get('stable_phases', [])),
                'error': result.get('error', '')
            })

        summary_df = pd.DataFrame(summary_data)
        summary_df.to_csv(output_path / "batch_summary.csv", index=False)
        print(f"âœ“ Summary saved to {output_path / 'batch_summary.csv'}")

        # å€‹åˆ¥çµæœã®HDF5ä¿å­˜
        for result in self.results:
            if result['success']:
                system_name = result['system'].replace('-', '')
                hdf_file = output_path / f"{system_name}_phase_diagram.h5"

                df = pd.DataFrame({
                    'temperature': result['temperature'].flatten(),
                    'composition': result['composition'].flatten()
                })
                df.to_hdf(hdf_file, key='phase_diagram', mode='w')
                print(f"âœ“ {result['system']} data saved to {hdf_file}")

# YAMLè¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ä¾‹ (batch_config.yaml)
"""
calculations:
  - database: "AlNi-Dupin2001"
    components: ["AL", "NI"]
    phases: ["LIQUID", "FCC_A1", "BCC_A2"]
    varying_component: "NI"
    composition_range: [0.0, 1.0, 0.01]
    temperature_range: [300, 2000, 10]
    pressure: 101325

  - database: "FeCr-Andersson1987"
    components: ["FE", "CR"]
    phases: ["LIQUID", "BCC_A2", "FCC_A1", "SIGMA"]
    varying_component: "CR"
    composition_range: [0.0, 1.0, 0.01]
    temperature_range: [300, 2200, 10]
    pressure: 101325
"""

# ä½¿ç”¨ä¾‹
if __name__ == "__main__":
    # ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã®åˆæœŸåŒ–
    manager = TDBManager("./my_databases")

    # ãƒãƒƒãƒè¨ˆç®—ã®å®Ÿè¡Œ
    calculator = BatchPhaseDiagramCalculator("batch_config.yaml", manager)
    calculator.run_batch(n_workers=4)
    calculator.save_results("./batch_results")
</code></pre>

        <div class="warning-box">
            <strong>âš ï¸ ä¸¦åˆ—è¨ˆç®—ã®æ³¨æ„ç‚¹</strong><br>
            pycalphadã®å¹³è¡¡è¨ˆç®—ã¯è¨ˆç®—è² è·ãŒé«˜ã„ãŸã‚ã€multiprocessingã«ã‚ˆã‚‹ä¸¦åˆ—åŒ–ãŒæœ‰åŠ¹ã§ã™ã€‚ãŸã ã—ã€<strong>ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡</strong>ã«æ³¨æ„ãŒå¿…è¦ã§ã™ã€‚å„ãƒ¯ãƒ¼ã‚«ãƒ¼ãŒãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹å…¨ä½“ã‚’ãƒ¡ãƒ¢ãƒªã«å±•é–‹ã™ã‚‹ãŸã‚ã€å¤§è¦æ¨¡ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚„å¤šæ•°ã®ãƒ¯ãƒ¼ã‚«ãƒ¼ã§ã¯ãƒ¡ãƒ¢ãƒªä¸è¶³ã«ãªã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚å®Ÿè¡Œå‰ã«ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ã‚’è¦‹ç©ã‚‚ã‚Šã€é©åˆ‡ãªãƒ¯ãƒ¼ã‚«ãƒ¼æ•°ã‚’è¨­å®šã—ã¦ãã ã•ã„ã€‚
        </div>

        <h2>5.2 ã‚«ã‚¹ã‚¿ãƒ å¯è¦–åŒ–ã¨ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆ</h2>

        <p>
            è¨ˆç®—çµæœã‚’åŠ¹æœçš„ã«ä¼ãˆã‚‹ã«ã¯ã€<strong>å‡ºç‰ˆå“è³ªã®å¯è¦–åŒ–</strong>ãŒä¸å¯æ¬ ã§ã™ã€‚æœ¬ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã§ã¯ã€matplotlibã¨plotlyã‚’ç”¨ã„ãŸã‚«ã‚¹ã‚¿ãƒ å¯è¦–åŒ–é–¢æ•°ã‚’å®Ÿè£…ã—ã¾ã™ã€‚
        </p>

        <h3>ã‚³ãƒ¼ãƒ‰ä¾‹3: å‡ºç‰ˆå“è³ªã®ç›¸å›³å¯è¦–åŒ–</h3>

        <pre><code class="language-python">import matplotlib.pyplot as plt
import matplotlib.patches as mpatches
from matplotlib.colors import LinearSegmentedColormap
import numpy as np
from typing import Dict, List, Optional

class PhaseDiagramVisualizer:
    """
    å‡ºç‰ˆå“è³ªã®ç›¸å›³å¯è¦–åŒ–ãƒ„ãƒ¼ãƒ«

    Features:
    - ã‚«ã‚¹ã‚¿ãƒ ã‚«ãƒ©ãƒ¼ãƒãƒƒãƒ—
    - ç›¸é ˜åŸŸã®è‡ªå‹•ãƒ©ãƒ™ãƒªãƒ³ã‚°
    - SVG/PDFå‡ºåŠ›
    - ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–plotlyãƒãƒ¼ã‚¸ãƒ§ãƒ³
    """

    def __init__(self, style: str = 'publication'):
        self.style = style
        self._setup_style()

    def _setup_style(self):
        """matplotlibã‚¹ã‚¿ã‚¤ãƒ«ã®è¨­å®š"""
        plt.rcParams.update({
            'font.family': 'sans-serif',
            'font.sans-serif': ['Arial', 'Helvetica'],
            'font.size': 12,
            'axes.labelsize': 14,
            'axes.titlesize': 16,
            'xtick.labelsize': 12,
            'ytick.labelsize': 12,
            'legend.fontsize': 11,
            'figure.figsize': (8, 6),
            'figure.dpi': 100,
            'savefig.dpi': 300,
            'savefig.bbox': 'tight',
            'axes.linewidth': 1.5,
            'xtick.major.width': 1.5,
            'ytick.major.width': 1.5,
            'lines.linewidth': 2.0
        })

    def plot_binary_phase_diagram(self,
                                   temperature: np.ndarray,
                                   composition: np.ndarray,
                                   phase_map: np.ndarray,
                                   phase_names: List[str],
                                   component_names: List[str],
                                   title: Optional[str] = None,
                                   save_path: Optional[str] = None):
        """
        2å…ƒç³»ç›¸å›³ã®ãƒ—ãƒ­ãƒƒãƒˆ

        Parameters:
        -----------
        temperature : np.ndarray
            æ¸©åº¦é…åˆ— [K]
        composition : np.ndarray
            çµ„æˆé…åˆ— [mol fraction]
        phase_map : np.ndarray
            å„ç‚¹ã®ç›¸ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ (shape: len(temperature) x len(composition))
        phase_names : List[str]
            ç›¸åã®ãƒªã‚¹ãƒˆ
        component_names : List[str]
            æˆåˆ†å [component1, component2]
        title : str
            ã‚°ãƒ©ãƒ•ã‚¿ã‚¤ãƒˆãƒ«
        save_path : str
            ä¿å­˜ãƒ‘ã‚¹ï¼ˆ.svg, .pdf, .pngå¯¾å¿œï¼‰
        """
        # ã‚«ãƒ©ãƒ¼ãƒãƒƒãƒ—ã®ä½œæˆï¼ˆç›¸ã”ã¨ã«ç•°ãªã‚‹è‰²ï¼‰
        n_phases = len(phase_names)
        colors = plt.cm.Set3(np.linspace(0, 1, n_phases))
        cmap = LinearSegmentedColormap.from_list('phases', colors, N=n_phases)

        fig, ax = plt.subplots(figsize=(10, 7))

        # ç›¸å›³ã®ãƒ—ãƒ­ãƒƒãƒˆ
        im = ax.contourf(composition, temperature, phase_map,
                         levels=n_phases, cmap=cmap, alpha=0.8)

        # ç›¸å¢ƒç•Œç·šã®è¿½åŠ 
        ax.contour(composition, temperature, phase_map,
                   levels=n_phases, colors='black', linewidths=1.5, alpha=0.5)

        # è»¸ãƒ©ãƒ™ãƒ«
        ax.set_xlabel(f'Mole Fraction {component_names[1]}', fontsize=14, fontweight='bold')
        ax.set_ylabel('Temperature (K)', fontsize=14, fontweight='bold')

        if title:
            ax.set_title(title, fontsize=16, fontweight='bold', pad=15)
        else:
            ax.set_title(f'{component_names[0]}-{component_names[1]} Phase Diagram',
                         fontsize=16, fontweight='bold', pad=15)

        # å‡¡ä¾‹ã®ä½œæˆï¼ˆç›¸åï¼‰
        patches = [mpatches.Patch(color=colors[i], label=phase_names[i])
                   for i in range(n_phases)]
        ax.legend(handles=patches, loc='best', frameon=True,
                  fancybox=True, shadow=True, fontsize=11)

        # ã‚°ãƒªãƒƒãƒ‰
        ax.grid(True, linestyle='--', alpha=0.3)

        # è»¸ã®ç¯„å›²è¨­å®š
        ax.set_xlim(composition.min(), composition.max())
        ax.set_ylim(temperature.min(), temperature.max())

        plt.tight_layout()

        if save_path:
            plt.savefig(save_path, dpi=300, bbox_inches='tight')
            print(f"âœ“ Phase diagram saved to {save_path}")

        plt.show()

    def plot_property_map(self,
                          temperature: np.ndarray,
                          composition: np.ndarray,
                          property_values: np.ndarray,
                          property_name: str,
                          property_unit: str,
                          component_names: List[str],
                          save_path: Optional[str] = None):
        """
        ç†±åŠ›å­¦ç‰©æ€§ãƒãƒƒãƒ—ã®ãƒ—ãƒ­ãƒƒãƒˆï¼ˆãƒ’ãƒ¼ãƒˆãƒãƒƒãƒ—ï¼‰

        Parameters:
        -----------
        property_values : np.ndarray
            ç‰©æ€§å€¤é…åˆ—ï¼ˆä¾‹: Gibbs energy, enthalpyï¼‰
        property_name : str
            ç‰©æ€§åï¼ˆä¾‹: "Gibbs Energy"ï¼‰
        property_unit : str
            å˜ä½ï¼ˆä¾‹: "J/mol"ï¼‰
        """
        fig, ax = plt.subplots(figsize=(10, 7))

        # ãƒ’ãƒ¼ãƒˆãƒãƒƒãƒ—
        im = ax.contourf(composition, temperature, property_values,
                         levels=50, cmap='RdYlBu_r')

        # ã‚«ãƒ©ãƒ¼ãƒãƒ¼
        cbar = plt.colorbar(im, ax=ax)
        cbar.set_label(f'{property_name} ({property_unit})',
                       fontsize=12, fontweight='bold')

        # è»¸ãƒ©ãƒ™ãƒ«
        ax.set_xlabel(f'Mole Fraction {component_names[1]}',
                      fontsize=14, fontweight='bold')
        ax.set_ylabel('Temperature (K)', fontsize=14, fontweight='bold')
        ax.set_title(f'{property_name} Map: {component_names[0]}-{component_names[1]}',
                     fontsize=16, fontweight='bold', pad=15)

        # ã‚°ãƒªãƒƒãƒ‰
        ax.grid(True, linestyle='--', alpha=0.3, color='white')

        plt.tight_layout()

        if save_path:
            plt.savefig(save_path, dpi=300, bbox_inches='tight')
            print(f"âœ“ Property map saved to {save_path}")

        plt.show()

    def create_interactive_plot(self,
                                temperature: np.ndarray,
                                composition: np.ndarray,
                                phase_map: np.ndarray,
                                phase_names: List[str],
                                component_names: List[str],
                                save_html: Optional[str] = None):
        """
        plotlyã«ã‚ˆã‚‹ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–ç›¸å›³

        Parameters:
        -----------
        save_html : str
            HTMLä¿å­˜ãƒ‘ã‚¹
        """
        import plotly.graph_objects as go

        fig = go.Figure(data=go.Contour(
            z=phase_map,
            x=composition,
            y=temperature,
            colorscale='Viridis',
            contours=dict(
                start=0,
                end=len(phase_names),
                size=1,
                showlabels=True,
                labelfont=dict(size=12, color='white')
            ),
            colorbar=dict(
                title="Phase Index",
                tickvals=list(range(len(phase_names))),
                ticktext=phase_names
            )
        ))

        fig.update_layout(
            title=f'{component_names[0]}-{component_names[1]} Phase Diagram (Interactive)',
            xaxis_title=f'Mole Fraction {component_names[1]}',
            yaxis_title='Temperature (K)',
            font=dict(family="Arial, sans-serif", size=14),
            hovermode='closest'
        )

        if save_html:
            fig.write_html(save_html)
            print(f"âœ“ Interactive plot saved to {save_html}")

        fig.show()

# ä½¿ç”¨ä¾‹
if __name__ == "__main__":
    # ãƒ€ãƒŸãƒ¼ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆ
    T = np.linspace(300, 2000, 100)
    X = np.linspace(0, 1, 100)
    T_grid, X_grid = np.meshgrid(T, X)

    # ã‚·ãƒ³ãƒ—ãƒ«ãªç›¸å›³ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆå®Ÿéš›ã¯pycalphadã‹ã‚‰å–å¾—ï¼‰
    phase_map = np.zeros_like(T_grid)
    phase_map[(T_grid > 1500)] = 0  # LIQUID
    phase_map[(T_grid < 1500) & (X_grid < 0.5)] = 1  # FCC_A1
    phase_map[(T_grid < 1500) & (X_grid >= 0.5)] = 2  # BCC_A2

    # å¯è¦–åŒ–
    viz = PhaseDiagramVisualizer()
    viz.plot_binary_phase_diagram(
        temperature=T_grid.T,
        composition=X_grid.T,
        phase_map=phase_map.T,
        phase_names=['LIQUID', 'FCC_A1', 'BCC_A2'],
        component_names=['Al', 'Ni'],
        save_path='AlNi_phase_diagram.svg'
    )
</code></pre>

        <h2>5.3 pymatgené€£æº: Materials Projectçµ±åˆ</h2>

        <p>
            <strong>pymatgen</strong>ï¼ˆPython Materials Genomicsï¼‰ã¯ã€Materials Project APIã‚’é€šã˜ã¦ç¬¬ä¸€åŸç†è¨ˆç®—ãƒ‡ãƒ¼ã‚¿ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã§ã™ã€‚pycalphadã¨çµ„ã¿åˆã‚ã›ã‚‹ã“ã¨ã§ã€CALPHADãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«ãªã„ç³»ã®äºˆæ¸¬ã‚„ã€å®Ÿé¨“çš„æ¤œè¨¼ãŒå¯èƒ½ã«ãªã‚Šã¾ã™ã€‚
        </p>

        <h3>é€£æºãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼</h3>

        <div class="mermaid">
        flowchart LR
            A[Materials Project API] -->|pymatgen| B[çµæ™¶æ§‹é€ ãƒ‡ãƒ¼ã‚¿]
            A -->|pymatgen| C[çŠ¶æ…‹å›³ãƒ‡ãƒ¼ã‚¿]
            A -->|pymatgen| D[ç†±åŠ›å­¦ãƒ‡ãƒ¼ã‚¿]
            B --> E[pycalphadå…¥åŠ›æº–å‚™]
            C --> E
            D --> E
            E --> F[CALPHADè¨ˆç®—]
            F --> G[çµæœæ¯”è¼ƒãƒ»æ¤œè¨¼]

            style A fill:#aed6f1
            style E fill:#f9e79f
            style F fill:#abebc6
        </div>

        <h3>ã‚³ãƒ¼ãƒ‰ä¾‹4: pymatgen-pycalphadçµ±åˆ</h3>

        <pre><code class="language-python">from pymatgen.ext.matproj import MPRester
from pymatgen.analysis.phase_diagram import PhaseDiagram, PDPlotter
from pycalphad import Database, equilibrium, variables as v
import numpy as np
import matplotlib.pyplot as plt

class PymatgenPycalphadIntegrator:
    """
    pymatgenã¨pycalphadã®çµ±åˆãƒ„ãƒ¼ãƒ«

    Features:
    - Materials Projectã‹ã‚‰ã®ç†±åŠ›å­¦ãƒ‡ãƒ¼ã‚¿å–å¾—
    - pycalphadè¨ˆç®—çµæœã¨ã®æ¯”è¼ƒ
    - ç¬¬ä¸€åŸç† vs CALPHAD ã®æ¤œè¨¼
    """

    def __init__(self, mp_api_key: str):
        """
        Parameters:
        -----------
        mp_api_key : str
            Materials Project APIã‚­ãƒ¼ï¼ˆhttps://materialsproject.org/api ã§å–å¾—ï¼‰
        """
        self.mpr = MPRester(mp_api_key)

    def get_mp_phase_diagram(self, elements: List[str]) -> PhaseDiagram:
        """
        Materials Projectã‹ã‚‰ç›¸å›³ãƒ‡ãƒ¼ã‚¿å–å¾—

        Parameters:
        -----------
        elements : List[str]
            å…ƒç´ ãƒªã‚¹ãƒˆï¼ˆä¾‹: ['Fe', 'Cr']ï¼‰

        Returns:
        --------
        PhaseDiagram
            pymatgenç›¸å›³ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
        """
        # Materials Projectã‹ã‚‰åŒ–åˆç‰©ãƒ‡ãƒ¼ã‚¿å–å¾—
        entries = self.mpr.get_entries_in_chemsys(elements)
        print(f"âœ“ Retrieved {len(entries)} entries from Materials Project")

        # ç›¸å›³ã®æ§‹ç¯‰
        pd = PhaseDiagram(entries)
        return pd

    def compare_with_calphad(self,
                             elements: List[str],
                             db: Database,
                             phases: List[str],
                             temperature: float = 298.15):
        """
        Materials Project vs CALPHAD ã®æ¯”è¼ƒ

        Parameters:
        -----------
        elements : List[str]
            å…ƒç´ ãƒªã‚¹ãƒˆ
        db : Database
            pycalphad Databaseã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
        phases : List[str]
            è€ƒæ…®ã™ã‚‹ç›¸ã®ãƒªã‚¹ãƒˆ
        temperature : float
            æ¯”è¼ƒæ¸©åº¦ [K]ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: 298.15 Kï¼‰
        """
        # Materials Projectãƒ‡ãƒ¼ã‚¿å–å¾—
        mp_pd = self.get_mp_phase_diagram(elements)

        # Materials Projectç›¸å›³ã®ãƒ—ãƒ­ãƒƒãƒˆ
        plotter = PDPlotter(mp_pd)
        plotter.show()

        # CALPHADè¨ˆç®—
        print(f"\nRunning CALPHAD calculation at {temperature} K...")

        # çµ„æˆç¯„å›²ã®è¨­å®šï¼ˆ2å…ƒç³»ã®å ´åˆï¼‰
        if len(elements) == 2:
            comp_range = np.linspace(0, 1, 50)
            conditions = {
                v.T: temperature,
                v.P: 101325,
                v.X(elements[1]): comp_range
            }

            eq = equilibrium(db, elements, phases, conditions)

            # å®‰å®šç›¸ã®æŠ½å‡º
            stable_phases = []
            for i, x in enumerate(comp_range):
                phase_fractions = eq.NP.isel(X=i).values
                stable = [phases[j] for j, frac in enumerate(phase_fractions) if frac > 0.01]
                stable_phases.append(stable)

            # çµæœã®å¯è¦–åŒ–
            self._plot_comparison(comp_range, stable_phases, elements, temperature)

    def _plot_comparison(self, composition, stable_phases, elements, temperature):
        """CALPHADçµæœã®ãƒ—ãƒ­ãƒƒãƒˆ"""
        fig, ax = plt.subplots(figsize=(10, 6))

        # å„çµ„æˆç‚¹ã§ã®å®‰å®šç›¸ã‚’è¡¨ç¤º
        unique_phases = sorted(set([p for phases in stable_phases for p in phases]))
        phase_to_idx = {phase: i for i, phase in enumerate(unique_phases)}

        y_values = []
        for phases in stable_phases:
            if len(phases) == 1:
                y_values.append(phase_to_idx[phases[0]])
            else:
                y_values.append(-0.5)  # 2ç›¸é ˜åŸŸ

        ax.plot(composition, y_values, 'o-', markersize=4)
        ax.set_xlabel(f'Mole Fraction {elements[1]}', fontsize=14)
        ax.set_ylabel('Stable Phase', fontsize=14)
        ax.set_title(f'CALPHAD Stability at {temperature} K: {"-".join(elements)}',
                     fontsize=16, fontweight='bold')
        ax.set_yticks(range(len(unique_phases)))
        ax.set_yticklabels(unique_phases)
        ax.grid(True, alpha=0.3)

        plt.tight_layout()
        plt.show()

    def fetch_formation_energies(self, formula: str) -> Dict:
        """
        ç‰¹å®šåŒ–åˆç‰©ã®ç”Ÿæˆã‚¨ãƒãƒ«ã‚®ãƒ¼å–å¾—

        Parameters:
        -----------
        formula : str
            åŒ–å­¦å¼ï¼ˆä¾‹: "Fe2O3"ï¼‰

        Returns:
        --------
        Dict
            ç”Ÿæˆã‚¨ãƒãƒ«ã‚®ãƒ¼ãƒ‡ãƒ¼ã‚¿
        """
        entries = self.mpr.get_entries(formula)

        results = []
        for entry in entries:
            results.append({
                'formula': entry.composition.reduced_formula,
                'formation_energy_per_atom': entry.energy_per_atom,
                'spacegroup': entry.data.get('spacegroup', {}).get('symbol', 'Unknown'),
                'band_gap': entry.data.get('band_gap', None)
            })

        return results

# ä½¿ç”¨ä¾‹
if __name__ == "__main__":
    # Materials Project APIã‚­ãƒ¼ï¼ˆå„è‡ªã§å–å¾—ï¼‰
    API_KEY = "your_api_key_here"

    # Integratorã®åˆæœŸåŒ–
    integrator = PymatgenPycalphadIntegrator(API_KEY)

    # Fe-Crç³»ã®æ¯”è¼ƒ
    # ï¼ˆpycalphadãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãŒå¿…è¦ï¼‰
    # db = Database("FeCr_database.tdb")
    # integrator.compare_with_calphad(
    #     elements=['Fe', 'Cr'],
    #     db=db,
    #     phases=['BCC_A2', 'FCC_A1', 'SIGMA'],
    #     temperature=1000
    # )

    # Al2O3ã®ç”Ÿæˆã‚¨ãƒãƒ«ã‚®ãƒ¼å–å¾—
    energies = integrator.fetch_formation_energies("Al2O3")
    for e in energies:
        print(f"Formula: {e['formula']}")
        print(f"  Formation Energy: {e['formation_energy_per_atom']:.3f} eV/atom")
        print(f"  Spacegroup: {e['spacegroup']}")
        print(f"  Band Gap: {e['band_gap']} eV\n")
</code></pre>

        <div class="info-box">
            <strong>ğŸ’¡ Materials Projectã®æ´»ç”¨</strong><br>
            Materials Projectã¯150,000ä»¥ä¸Šã®ææ–™ã®ç¬¬ä¸€åŸç†è¨ˆç®—ãƒ‡ãƒ¼ã‚¿ã‚’å…¬é–‹ã—ã¦ã„ã¾ã™ã€‚pycalphadã§è¨ˆç®—ã—ãŸç›¸å¹³è¡¡ã¨ã€MPã®0 Kç”Ÿæˆã‚¨ãƒãƒ«ã‚®ãƒ¼ã‚’æ¯”è¼ƒã™ã‚‹ã“ã¨ã§ã€<strong>ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®æ¤œè¨¼</strong>ã‚„<strong>æœªçŸ¥ç³»ã®äºˆæ¸¬</strong>ãŒå¯èƒ½ã§ã™ã€‚ç‰¹ã«ã€CALPHADãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãŒæœªæ•´å‚™ã®ç³»ï¼ˆå¸ŒåœŸé¡ã€è¤‡é›‘é…¸åŒ–ç‰©ç­‰ï¼‰ã§ã¯ã€MPãƒ‡ãƒ¼ã‚¿ãŒè²´é‡ãªæ¤œè¨¼ã‚½ãƒ¼ã‚¹ã¨ãªã‚Šã¾ã™ã€‚
        </div>

        <h2>5.4 ASEé€£æº: åŸå­æ§‹é€ ã¨ç†±åŠ›å­¦ã®çµ±åˆ</h2>

        <p>
            <strong>ASE</strong>ï¼ˆAtomic Simulation Environmentï¼‰ã¯ã€åŸå­æ§‹é€ ã®æ“ä½œã¨å¯è¦–åŒ–ã®ãŸã‚ã®Pythonãƒ©ã‚¤ãƒ–ãƒ©ãƒªã§ã™ã€‚pycalphadã¨çµ„ã¿åˆã‚ã›ã‚‹ã“ã¨ã§ã€å¹³è¡¡è¨ˆç®—ã‹ã‚‰å¾—ã‚‰ã‚ŒãŸç›¸ã®çµæ™¶æ§‹é€ ã‚’ç”Ÿæˆã—ã€ç¬¬ä¸€åŸç†è¨ˆç®—ã‚„åˆ†å­å‹•åŠ›å­¦ã¸ã¨ã‚·ãƒ¼ãƒ ãƒ¬ã‚¹ã«æ¥ç¶šã§ãã¾ã™ã€‚
        </p>

        <h3>ã‚³ãƒ¼ãƒ‰ä¾‹5: ASE-pycalphadçµ±åˆ</h3>

        <pre><code class="language-python">from ase import Atoms
from ase.visualize import view
from ase.io import write
from ase.build import bulk
from pycalphad import Database, equilibrium, variables as v
import numpy as np

class ASEPycalphadConnector:
    """
    ASEã¨pycalphadã®é€£æºãƒ„ãƒ¼ãƒ«

    Features:
    - å¹³è¡¡ç›¸ã®çµæ™¶æ§‹é€ ç”Ÿæˆ
    - ASE Atomsã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®å¤‰æ›
    - VASP/QEå…¥åŠ›ãƒ•ã‚¡ã‚¤ãƒ«ç”Ÿæˆ
    """

    def __init__(self, db: Database):
        self.db = db

    def equilibrium_to_structure(self,
                                  elements: List[str],
                                  phases: List[str],
                                  conditions: Dict,
                                  phase_of_interest: str) -> Atoms:
        """
        å¹³è¡¡è¨ˆç®—ã‹ã‚‰ç‰¹å®šç›¸ã®çµæ™¶æ§‹é€ ã‚’ç”Ÿæˆ

        Parameters:
        -----------
        elements : List[str]
            å…ƒç´ ãƒªã‚¹ãƒˆ
        phases : List[str]
            è€ƒæ…®ã™ã‚‹ç›¸
        conditions : Dict
            ç†±åŠ›å­¦æ¡ä»¶ï¼ˆæ¸©åº¦ã€åœ§åŠ›ã€çµ„æˆï¼‰
        phase_of_interest : str
            æ§‹é€ ã‚’ç”Ÿæˆã™ã‚‹ç›¸

        Returns:
        --------
        Atoms
            ASE Atomsã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
        """
        # å¹³è¡¡è¨ˆç®—
        eq = equilibrium(self.db, elements, phases, conditions)

        # ç›¸åˆ†ç‡ã®ç¢ºèª
        phase_fraction = eq.NP.sel(Phase=phase_of_interest).values[0]
        if phase_fraction < 0.01:
            raise ValueError(f"Phase '{phase_of_interest}' is not stable at given conditions")

        # å¹³è¡¡çµ„æˆã®å–å¾—
        composition = {}
        for elem in elements:
            composition[elem] = eq.X.sel(component=elem, Phase=phase_of_interest).values[0]

        print(f"âœ“ Equilibrium composition of {phase_of_interest}:")
        for elem, x in composition.items():
            print(f"  {elem}: {x:.4f}")

        # çµæ™¶æ§‹é€ ã®ç”Ÿæˆï¼ˆç°¡ç•¥ç‰ˆ: ç›¸ã‚¿ã‚¤ãƒ—ã‹ã‚‰æ¨å®šï¼‰
        structure = self._create_structure_from_phase(
            phase_of_interest, composition, elements
        )

        return structure

    def _create_structure_from_phase(self, phase: str, composition: Dict, elements: List[str]) -> Atoms:
        """
        ç›¸ã‚¿ã‚¤ãƒ—ã‹ã‚‰çµæ™¶æ§‹é€ ã‚’ç”Ÿæˆ

        Note: å®Ÿéš›ã®CALPHADãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«ã¯çµæ™¶æ§‹é€ æƒ…å ±ã¯å«ã¾ã‚Œã¦ã„ãªã„ãŸã‚ã€
              ç›¸ã‚¿ã‚¤ãƒ—ï¼ˆFCC, BCCç­‰ï¼‰ã‹ã‚‰æ¨™æº–æ§‹é€ ã‚’ç”Ÿæˆã™ã‚‹
        """
        # ç›¸ã‚¿ã‚¤ãƒ—ã®æ¨å®š
        if 'FCC' in phase:
            lattice_type = 'fcc'
            a = 4.05  # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆæ ¼å­å®šæ•° [Ã…]ï¼ˆå®Ÿéš›ã¯Vegardå‰‡ã§è¨ˆç®—ã™ã¹ãï¼‰
        elif 'BCC' in phase:
            lattice_type = 'bcc'
            a = 2.87
        elif 'HCP' in phase:
            lattice_type = 'hcp'
            a = 3.21
        else:
            raise ValueError(f"Unknown structure type for phase '{phase}'")

        # ä¸»æˆåˆ†ã®æ±ºå®šï¼ˆæœ€å¤§çµ„æˆã®å…ƒç´ ï¼‰
        primary_element = max(composition, key=composition.get)

        # ãƒãƒ«ã‚¯æ§‹é€ ã®ç”Ÿæˆ
        atoms = bulk(primary_element, lattice_type, a=a, cubic=True)

        # åˆé‡‘åŒ–ï¼ˆç°¡ç•¥ç‰ˆ: ãƒ©ãƒ³ãƒ€ãƒ ç½®æ›ï¼‰
        if len(elements) > 1:
            atoms = self._create_random_alloy(atoms, composition, elements)

        return atoms

    def _create_random_alloy(self, atoms: Atoms, composition: Dict, elements: List[str]) -> Atoms:
        """
        ãƒ©ãƒ³ãƒ€ãƒ åˆé‡‘æ§‹é€ ã®ç”Ÿæˆï¼ˆSQS: Special Quasirandom Structures ã®ç°¡ç•¥ç‰ˆï¼‰

        Parameters:
        -----------
        atoms : Atoms
            ãƒ™ãƒ¼ã‚¹æ§‹é€ 
        composition : Dict
            ç›®æ¨™çµ„æˆ
        elements : List[str]
            å…ƒç´ ãƒªã‚¹ãƒˆ

        Returns:
        --------
        Atoms
            åˆé‡‘åŒ–ã•ã‚ŒãŸAtoms
        """
        n_atoms = len(atoms)
        symbols = atoms.get_chemical_symbols()

        # å„å…ƒç´ ã®åŸå­æ•°ã‚’è¨ˆç®—
        target_counts = {elem: int(n_atoms * composition[elem]) for elem in elements}

        # ãƒ©ãƒ³ãƒ€ãƒ é…ç½®
        new_symbols = []
        for elem, count in target_counts.items():
            new_symbols.extend([elem] * count)

        # ä½™ã£ãŸåŸå­ã¯ä¸»æˆåˆ†ã§åŸ‹ã‚ã‚‹
        while len(new_symbols) < n_atoms:
            primary = max(composition, key=composition.get)
            new_symbols.append(primary)

        # ãƒ©ãƒ³ãƒ€ãƒ ã‚·ãƒ£ãƒƒãƒ•ãƒ«
        np.random.shuffle(new_symbols)
        atoms.set_chemical_symbols(new_symbols[:n_atoms])

        return atoms

    def export_to_vasp(self, atoms: Atoms, output_dir: str = "./vasp_input"):
        """
        VASPå…¥åŠ›ãƒ•ã‚¡ã‚¤ãƒ«ã®ç”Ÿæˆ

        Parameters:
        -----------
        atoms : Atoms
            çµæ™¶æ§‹é€ 
        output_dir : str
            å‡ºåŠ›ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª
        """
        from pathlib import Path
        output_path = Path(output_dir)
        output_path.mkdir(parents=True, exist_ok=True)

        # POSCARï¼ˆæ§‹é€ ãƒ•ã‚¡ã‚¤ãƒ«ï¼‰ã®ç”Ÿæˆ
        write(output_path / 'POSCAR', atoms, format='vasp')

        # INCARï¼ˆè¨ˆç®—è¨­å®šï¼‰ã®ç”Ÿæˆï¼ˆãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆï¼‰
        incar_content = """SYSTEM = CALPHAD-derived structure
ISTART = 0
ICHARG = 2
ENCUT = 500
ISMEAR = 1
SIGMA = 0.2
EDIFF = 1E-6
NSW = 0
IBRION = -1
"""
        with open(output_path / 'INCAR', 'w') as f:
            f.write(incar_content)

        # KPOINTSï¼ˆkç‚¹ãƒ¡ãƒƒã‚·ãƒ¥ï¼‰ã®ç”Ÿæˆ
        kpoints_content = """Automatic mesh
0
Gamma
8 8 8
0 0 0
"""
        with open(output_path / 'KPOINTS', 'w') as f:
            f.write(kpoints_content)

        print(f"âœ“ VASP input files generated in {output_dir}")
        print(f"  - POSCAR: {len(atoms)} atoms")
        print(f"  - Formula: {atoms.get_chemical_formula()}")

# ä½¿ç”¨ä¾‹
if __name__ == "__main__":
    # ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹èª­ã¿è¾¼ã¿
    db = Database("AlNi_Dupin_2001.tdb")

    # ASEé€£æºã®åˆæœŸåŒ–
    connector = ASEPycalphadConnector(db)

    # å¹³è¡¡æ¡ä»¶ã®è¨­å®š
    conditions = {
        v.T: 1000,  # K
        v.P: 101325,  # Pa
        v.X('NI'): 0.5  # Al-50at%Ni
    }

    # FCCç›¸ã®æ§‹é€ ç”Ÿæˆ
    try:
        fcc_structure = connector.equilibrium_to_structure(
            elements=['AL', 'NI'],
            phases=['LIQUID', 'FCC_A1', 'BCC_A2'],
            conditions=conditions,
            phase_of_interest='FCC_A1'
        )

        # æ§‹é€ ã®å¯è¦–åŒ–
        view(fcc_structure)

        # VASPå…¥åŠ›ãƒ•ã‚¡ã‚¤ãƒ«ç”Ÿæˆ
        connector.export_to_vasp(fcc_structure, output_dir="./AlNi_FCC_vasp")

    except ValueError as e:
        print(f"Error: {e}")
</code></pre>

        <h2>5.5 ææ–™ã‚¹ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³</h2>

        <p>
            æœ€å¾Œã«ã€pycalphadã‚’ç”¨ã„ãŸ<strong>ãƒã‚¤ã‚¹ãƒ«ãƒ¼ãƒ—ãƒƒãƒˆææ–™ã‚¹ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°</strong>ã®ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚’æ§‹ç¯‰ã—ã¾ã™ã€‚ç›®çš„ã¯ã€å¤šæ•°ã®åˆé‡‘çµ„æˆã‹ã‚‰ã€ç‰¹å®šã®ç‰¹æ€§ï¼ˆèç‚¹ã€ç›¸å®‰å®šæ€§ã€å˜ç›¸é ˜åŸŸç­‰ï¼‰ã‚’æº€ãŸã™å€™è£œææ–™ã‚’è‡ªå‹•æŠ½å‡ºã™ã‚‹ã“ã¨ã§ã™ã€‚
        </p>

        <h3>ã‚¹ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼</h3>

        <div class="mermaid">
        flowchart TD
            A[æ¢ç´¢ç©ºé–“å®šç¾©] --> B[ãƒãƒƒãƒå¹³è¡¡è¨ˆç®—]
            B --> C[ç‰¹æ€§æŠ½å‡º]
            C --> D{ã‚¹ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°åŸºæº–}
            D -->|èç‚¹ > 1500 K| E1[é«˜èç‚¹åˆé‡‘]
            D -->|å˜ç›¸ FCC| E2[FCCå˜ç›¸åˆé‡‘]
            D -->|ä½å¯†åº¦ <math>&rho;</math> < 5 g/cmÂ³| E3[è»½é‡åˆé‡‘]
            E1 --> F[å€™è£œææ–™ãƒªã‚¹ãƒˆ]
            E2 --> F
            E3 --> F
            F --> G[è©³ç´°è§£æãƒ»å®Ÿé¨“æ¤œè¨¼]

            style A fill:#e8f8f5
            style C fill:#f9e79f
            style F fill:#abebc6
        </div>

        <h3>ã‚³ãƒ¼ãƒ‰ä¾‹6: ãƒã‚¤ã‚¹ãƒ«ãƒ¼ãƒ—ãƒƒãƒˆææ–™ã‚¹ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°</h3>

        <pre><code class="language-python">import numpy as np
import pandas as pd
from pycalphad import Database, equilibrium, variables as v
from typing import List, Dict, Callable
from dataclasses import dataclass

@dataclass
class ScreeningCriteria:
    """ã‚¹ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°åŸºæº–ã®å®šç¾©"""
    name: str
    condition: Callable
    description: str

class MaterialScreeningPipeline:
    """
    ææ–™ã‚¹ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³

    Features:
    - å¤šæ¬¡å…ƒçµ„æˆç©ºé–“ã®æ¢ç´¢
    - ã‚«ã‚¹ã‚¿ãƒ è©•ä¾¡é–¢æ•°
    - å€™è£œææ–™ã®ãƒ©ãƒ³ã‚­ãƒ³ã‚°
    - çµæœã®ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
    """

    def __init__(self, db: Database, elements: List[str], phases: List[str]):
        self.db = db
        self.elements = elements
        self.phases = phases
        self.results = []

    def generate_composition_space(self, n_samples: int, method: str = 'grid') -> np.ndarray:
        """
        çµ„æˆç©ºé–“ã®ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°

        Parameters:
        -----------
        n_samples : int
            ã‚µãƒ³ãƒ—ãƒ«æ•°
        method : str
            ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°æ–¹æ³•ï¼ˆ'grid', 'random', 'latin_hypercube'ï¼‰

        Returns:
        --------
        np.ndarray
            çµ„æˆé…åˆ— (shape: n_samples x n_elements)
        """
        n_elements = len(self.elements)

        if method == 'grid':
            # ã‚°ãƒªãƒƒãƒ‰ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ï¼ˆ2å…ƒç³»ã®ã¿ï¼‰
            if n_elements == 2:
                x = np.linspace(0, 1, n_samples)
                compositions = np.column_stack([1 - x, x])
            else:
                raise ValueError("Grid sampling only supports binary systems")

        elif method == 'random':
            # ãƒ©ãƒ³ãƒ€ãƒ ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ï¼ˆDirichletåˆ†å¸ƒï¼‰
            compositions = np.random.dirichlet(np.ones(n_elements), n_samples)

        elif method == 'latin_hypercube':
            # Latin Hypercube Sampling
            from scipy.stats import qmc
            sampler = qmc.LatinHypercube(d=n_elements-1)
            samples = sampler.random(n=n_samples)

            # çµ„æˆåˆ¶ç´„ï¼ˆåˆè¨ˆ=1ï¼‰ã‚’æº€ãŸã™ã‚ˆã†ã«å¤‰æ›
            compositions = np.zeros((n_samples, n_elements))
            compositions[:, :-1] = samples
            compositions[:, -1] = 1 - samples.sum(axis=1)

        else:
            raise ValueError(f"Unknown sampling method: {method}")

        return compositions

    def evaluate_composition(self, composition: np.ndarray, temperature: float) -> Dict:
        """
        ç‰¹å®šçµ„æˆã®è©•ä¾¡

        Parameters:
        -----------
        composition : np.ndarray
            çµ„æˆé…åˆ—ï¼ˆåˆè¨ˆ=1ï¼‰
        temperature : float
            è©•ä¾¡æ¸©åº¦ [K]

        Returns:
        --------
        Dict
            è©•ä¾¡çµæœï¼ˆç›¸ã€Gibbs energyç­‰ï¼‰
        """
        # å¹³è¡¡è¨ˆç®—ã®æ¡ä»¶è¨­å®š
        conditions = {v.T: temperature, v.P: 101325}
        for i, elem in enumerate(self.elements[1:], start=1):
            conditions[v.X(elem)] = composition[i]

        try:
            eq = equilibrium(self.db, self.elements, self.phases, conditions)

            # å®‰å®šç›¸ã®æŠ½å‡º
            stable_phases = []
            phase_fractions = {}
            for phase in self.phases:
                frac = eq.NP.sel(Phase=phase).values[0]
                if frac > 0.01:
                    stable_phases.append(phase)
                    phase_fractions[phase] = frac

            # Gibbs energyã®å–å¾—
            gibbs = eq.GM.values[0]

            result = {
                'composition': composition,
                'temperature': temperature,
                'stable_phases': stable_phases,
                'phase_fractions': phase_fractions,
                'gibbs_energy': gibbs,
                'success': True
            }

        except Exception as e:
            result = {
                'composition': composition,
                'temperature': temperature,
                'success': False,
                'error': str(e)
            }

        return result

    def screen_materials(self,
                         compositions: np.ndarray,
                         temperature: float,
                         criteria: List[ScreeningCriteria]) -> pd.DataFrame:
        """
        ææ–™ã‚¹ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°ã®å®Ÿè¡Œ

        Parameters:
        -----------
        compositions : np.ndarray
            è©•ä¾¡ã™ã‚‹çµ„æˆã®é…åˆ—
        temperature : float
            è©•ä¾¡æ¸©åº¦ [K]
        criteria : List[ScreeningCriteria]
            ã‚¹ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°åŸºæº–ã®ãƒªã‚¹ãƒˆ

        Returns:
        --------
        pd.DataFrame
            ã‚¹ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°çµæœ
        """
        results = []

        for i, comp in enumerate(compositions):
            print(f"Evaluating composition {i+1}/{len(compositions)}...", end='\r')

            eval_result = self.evaluate_composition(comp, temperature)

            if eval_result['success']:
                # å„åŸºæº–ã‚’è©•ä¾¡
                passes_criteria = {}
                for criterion in criteria:
                    passes_criteria[criterion.name] = criterion.condition(eval_result)

                # çµæœã®è¨˜éŒ²
                result_entry = {
                    'composition': '-'.join([f"{self.elements[j]}{comp[j]:.2f}"
                                             for j in range(len(self.elements))]),
                    'stable_phases': ', '.join(eval_result['stable_phases']),
                    'gibbs_energy': eval_result['gibbs_energy'],
                    **passes_criteria
                }
                results.append(result_entry)

        print("\nâœ“ Screening completed")
        return pd.DataFrame(results)

    def rank_candidates(self, screening_df: pd.DataFrame,
                        ranking_criteria: List[str]) -> pd.DataFrame:
        """
        å€™è£œææ–™ã®ãƒ©ãƒ³ã‚­ãƒ³ã‚°

        Parameters:
        -----------
        screening_df : pd.DataFrame
            ã‚¹ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°çµæœ
        ranking_criteria : List[str]
            ãƒ©ãƒ³ã‚­ãƒ³ã‚°ã«ä½¿ç”¨ã™ã‚‹åŸºæº–ã®ã‚«ãƒ©ãƒ å

        Returns:
        --------
        pd.DataFrame
            ãƒ©ãƒ³ã‚­ãƒ³ã‚°çµæœ
        """
        # å„åŸºæº–ã‚’æº€ãŸã™æ•°ã§ã‚¹ã‚³ã‚¢è¨ˆç®—
        screening_df['score'] = screening_df[ranking_criteria].sum(axis=1)

        # ã‚¹ã‚³ã‚¢ã§ã‚½ãƒ¼ãƒˆ
        ranked = screening_df.sort_values('score', ascending=False)

        return ranked

# ä½¿ç”¨ä¾‹
if __name__ == "__main__":
    # ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹èª­ã¿è¾¼ã¿
    db = Database("AlNi_Dupin_2001.tdb")

    # ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®åˆæœŸåŒ–
    pipeline = MaterialScreeningPipeline(
        db=db,
        elements=['AL', 'NI'],
        phases=['LIQUID', 'FCC_A1', 'BCC_A2']
    )

    # çµ„æˆç©ºé–“ã®ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°
    compositions = pipeline.generate_composition_space(n_samples=100, method='grid')

    # ã‚¹ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°åŸºæº–ã®å®šç¾©
    criteria = [
        ScreeningCriteria(
            name='single_phase_FCC',
            condition=lambda r: len(r['stable_phases']) == 1 and 'FCC_A1' in r['stable_phases'],
            description='FCC single phase'
        ),
        ScreeningCriteria(
            name='low_gibbs',
            condition=lambda r: r['gibbs_energy'] < -30000,
            description='Low Gibbs energy (< -30 kJ/mol)'
        ),
        ScreeningCriteria(
            name='no_liquid',
            condition=lambda r: 'LIQUID' not in r['stable_phases'],
            description='No liquid phase'
        )
    ]

    # ã‚¹ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°ã®å®Ÿè¡Œ
    screening_results = pipeline.screen_materials(
        compositions=compositions,
        temperature=1000,  # K
        criteria=criteria
    )

    # ãƒ©ãƒ³ã‚­ãƒ³ã‚°
    ranked = pipeline.rank_candidates(
        screening_results,
        ranking_criteria=['single_phase_FCC', 'low_gibbs', 'no_liquid']
    )

    # ä¸Šä½10å€™è£œã®è¡¨ç¤º
    print("\n=== Top 10 Candidate Materials ===")
    print(ranked.head(10))

    # çµæœã®ä¿å­˜
    ranked.to_csv("screening_results.csv", index=False)
    print("\nâœ“ Results saved to screening_results.csv")
</code></pre>

        <div class="info-box">
            <strong>ğŸ’¡ ã‚¹ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°ã®å®Ÿä¾‹</strong><br>
            å®Ÿéš›ã®ææ–™é–‹ç™ºã§ã¯ã€ä»¥ä¸‹ã®ã‚ˆã†ãªåŸºæº–ã§ã‚¹ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°ãŒè¡Œã‚ã‚Œã¾ã™ï¼š<br>
            â€¢ <strong>è€ç†±åˆé‡‘</strong>: èç‚¹ > 1500 Kã€é«˜æ¸©ã§ã®å˜ç›¸å®‰å®šæ€§ã€ã‚¯ãƒªãƒ¼ãƒ—å¼·åº¦<br>
            â€¢ <strong>è»½é‡æ§‹é€ æ</strong>: å¯†åº¦ < 5 g/cmÂ³ã€å¼·åº¦ > 300 MPaã€å»¶æ€§ > 10%<br>
            â€¢ <strong>ç†±é›»ææ–™</strong>: ã‚¼ãƒ¼ãƒ™ãƒƒã‚¯ä¿‚æ•° > 200 Î¼V/Kã€ä½ç†±ä¼å°ç‡<br>
            pycalphadã«ã‚ˆã‚‹ç›¸å®‰å®šæ€§ã‚¹ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°ã¯ã€ã“ã‚Œã‚‰ã®ç¬¬ä¸€æ®µéšãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã¨ã—ã¦æ¥µã‚ã¦æœ‰åŠ¹ã§ã™ã€‚
        </div>

        <h2>5.6 æ¼”ç¿’å•é¡Œ</h2>

        <div class="exercise-box">
            <h4>æ¼”ç¿’1: TDBãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã®æ‹¡å¼µï¼ˆEasyï¼‰</h4>
            <p>
                æä¾›ã•ã‚Œã¦ã„ã‚‹<code>TDBManager</code>ã‚¯ãƒ©ã‚¹ã«ã€ä»¥ä¸‹ã®æ©Ÿèƒ½ã‚’è¿½åŠ ã—ã¦ãã ã•ã„ï¼š
            </p>
            <ol>
                <li><code>delete_database(name: str)</code>ãƒ¡ã‚½ãƒƒãƒ‰: ç™»éŒ²ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚’å‰Šé™¤ã™ã‚‹</li>
                <li><code>search_by_element(element: str)</code>ãƒ¡ã‚½ãƒƒãƒ‰: æŒ‡å®šå…ƒç´ ã‚’å«ã‚€ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚’æ¤œç´¢ã™ã‚‹</li>
                <li><code>export_metadata(output_path: str)</code>ãƒ¡ã‚½ãƒƒãƒ‰: ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’Markdownå½¢å¼ã§ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã™ã‚‹</li>
            </ol>

            <button class="toggle-solution" onclick="this.nextElementSibling.classList.toggle('show')">è§£ç­”ã‚’è¡¨ç¤º</button>
            <div class="solution">
                <pre><code class="language-python">def delete_database(self, name: str):
    """ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®å‰Šé™¤"""
    if name not in self.metadata["databases"]:
        raise ValueError(f"Database '{name}' not found")

    db_info = self.metadata["databases"][name]
    db_path = Path(db_info["path"])

    # ãƒ•ã‚¡ã‚¤ãƒ«ã®å‰Šé™¤
    if db_path.exists():
        db_path.unlink()

    # ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰å‰Šé™¤
    del self.metadata["databases"][name]
    self._save_metadata()
    print(f"âœ“ Database '{name}' deleted")

def search_by_element(self, element: str) -> List[str]:
    """å…ƒç´ ã§æ¤œç´¢"""
    results = []
    for name, db_info in self.metadata["databases"].items():
        if element.upper() in [e.upper() for e in db_info["elements"]]:
            results.append(name)
    return results

def export_metadata(self, output_path: str):
    """ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã®Markdownã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ"""
    with open(output_path, 'w') as f:
        f.write("# TDB Database Metadata\n\n")
        for name, db_info in self.metadata["databases"].items():
            f.write(f"## {name}\n\n")
            f.write(f"- **Description**: {db_info['description']}\n")
            f.write(f"- **Source**: {db_info['source']}\n")
            f.write(f"- **Elements**: {', '.join(db_info['elements'])}\n")
            f.write(f"- **Phases**: {', '.join(db_info['phases'])}\n")
            f.write(f"- **Registered**: {db_info['registered_at']}\n\n")
    print(f"âœ“ Metadata exported to {output_path}")
</code></pre>
            </div>
        </div>

        <div class="exercise-box">
            <h4>æ¼”ç¿’2: ãƒãƒƒãƒè¨ˆç®—ã®ã‚¨ãƒ©ãƒ¼ãƒªã‚«ãƒãƒªï¼ˆMediumï¼‰</h4>
            <p>
                <code>BatchPhaseDiagramCalculator</code>ã‚’æ‹¡å¼µã—ã€ä»¥ä¸‹ã®æ©Ÿèƒ½ã‚’å®Ÿè£…ã—ã¦ãã ã•ã„ï¼š
            </p>
            <ol>
                <li>è¨ˆç®—å¤±æ•—æ™‚ã«è‡ªå‹•ãƒªãƒˆãƒ©ã‚¤ï¼ˆæœ€å¤§3å›ï¼‰</li>
                <li>å¤±æ•—ã—ãŸã‚¿ã‚¹ã‚¯ã‚’åˆ¥ãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆ<code>failed_tasks.yaml</code>ï¼‰ã«ä¿å­˜</li>
                <li>ä¸­æ–­æ™‚ã®ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆä¿å­˜ã¨å†é–‹æ©Ÿèƒ½</li>
            </ol>

            <button class="toggle-solution" onclick="this.nextElementSibling.classList.toggle('show')">è§£ç­”ã‚’è¡¨ç¤º</button>
            <div class="solution">
                <pre><code class="language-python">def _single_calculation_with_retry(self, task: Dict, max_retries: int = 3) -> Dict:
    """ãƒªãƒˆãƒ©ã‚¤ä»˜ãè¨ˆç®—"""
    for attempt in range(max_retries):
        try:
            result = self._single_calculation(task)
            if result['success']:
                return result
        except Exception as e:
            if attempt == max_retries - 1:
                return {'success': False, 'error': str(e), 'task': task}
            time.sleep(1)  # ãƒªãƒˆãƒ©ã‚¤å‰ã«å¾…æ©Ÿ

    return {'success': False, 'error': 'Max retries exceeded', 'task': task}

def save_checkpoint(self, checkpoint_file: str = "./checkpoint.pkl"):
    """ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆä¿å­˜"""
    import pickle
    with open(checkpoint_file, 'wb') as f:
        pickle.dump(self.results, f)
    print(f"âœ“ Checkpoint saved to {checkpoint_file}")

def resume_from_checkpoint(self, checkpoint_file: str = "./checkpoint.pkl"):
    """ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆã‹ã‚‰å†é–‹"""
    import pickle
    if Path(checkpoint_file).exists():
        with open(checkpoint_file, 'rb') as f:
            self.results = pickle.load(f)
        print(f"âœ“ Resumed from checkpoint: {len(self.results)} completed tasks")
    else:
        print("No checkpoint found, starting fresh")

def save_failed_tasks(self, output_file: str = "./failed_tasks.yaml"):
    """å¤±æ•—ã‚¿ã‚¹ã‚¯ã®ä¿å­˜"""
    failed = [r['task'] for r in self.results if not r['success']]
    with open(output_file, 'w') as f:
        yaml.dump({'calculations': failed}, f)
    print(f"âœ“ {len(failed)} failed tasks saved to {output_file}")
</code></pre>
            </div>
        </div>

        <div class="exercise-box">
            <h4>æ¼”ç¿’3: pymatgenã¨ã®é«˜åº¦ãªé€£æºï¼ˆHardï¼‰</h4>
            <p>
                Materials Projectã¨pycalphadã®ãƒ‡ãƒ¼ã‚¿ã‚’çµ±åˆã—ã€ä»¥ä¸‹ã‚’å®Ÿç¾ã™ã‚‹é–¢æ•°ã‚’ä½œæˆã—ã¦ãã ã•ã„ï¼š
            </p>
            <ol>
                <li>Materials Projectã‹ã‚‰å–å¾—ã—ãŸ0 Kç”Ÿæˆã‚¨ãƒãƒ«ã‚®ãƒ¼ã¨ã€pycalphadã®298 Kç”Ÿæˆã‚¨ãƒãƒ«ã‚®ãƒ¼ã‚’æ¯”è¼ƒ</li>
                <li>æ¸©åº¦å¤–æŒ¿ã«ã‚ˆã‚‹èª¤å·®ã‚’å®šé‡è©•ä¾¡ï¼ˆMPãƒ‡ãƒ¼ã‚¿ã‚’åŸºæº–ã¨ã—ã¦%èª¤å·®ã‚’è¨ˆç®—ï¼‰</li>
                <li>ä¿¡é ¼æ€§ã‚¹ã‚³ã‚¢ã‚’è¨ˆç®—ã—ã€ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®å“è³ªã‚’è©•ä¾¡</li>
            </ol>

            <button class="toggle-solution" onclick="this.nextElementSibling.classList.toggle('show')">è§£ç­”ã‚’è¡¨ç¤º</button>
            <div class="solution">
                <pre><code class="language-python">def validate_database_with_mp(self,
                                db: Database,
                                elements: List[str],
                                phases: List[str],
                                compounds: List[str]) -> pd.DataFrame:
    """
    Materials Projectãƒ‡ãƒ¼ã‚¿ã¨ã®æ¯”è¼ƒæ¤œè¨¼

    Parameters:
    -----------
    compounds : List[str]
        æ¤œè¨¼ã™ã‚‹åŒ–åˆç‰©ã®ãƒªã‚¹ãƒˆï¼ˆä¾‹: ['Al3Ni', 'AlNi', 'AlNi3']ï¼‰

    Returns:
    --------
    pd.DataFrame
        æ¤œè¨¼çµæœï¼ˆåŒ–åˆç‰©ã”ã¨ã®èª¤å·®ï¼‰
    """
    results = []

    for compound in compounds:
        # Materials Projectã‹ã‚‰0 Kç”Ÿæˆã‚¨ãƒãƒ«ã‚®ãƒ¼å–å¾—
        mp_entries = self.fetch_formation_energies(compound)
        if not mp_entries:
            continue
        mp_energy = mp_entries[0]['formation_energy_per_atom']

        # pycalphadã§298 Kç”Ÿæˆã‚¨ãƒãƒ«ã‚®ãƒ¼è¨ˆç®—
        # ï¼ˆåŒ–åˆç‰©ã®åŒ–å­¦é‡è«–æ¯”ã‹ã‚‰çµ„æˆã‚’æ±ºå®šï¼‰
        stoichiometry = self._parse_formula(compound, elements)
        conditions = {
            v.T: 298.15,
            v.P: 101325,
            v.X(elements[1]): stoichiometry[elements[1]]
        }

        try:
            eq = equilibrium(db, elements, phases, conditions)
            calphad_energy = eq.GM.values[0] / sum(stoichiometry.values())

            # eVã‹ã‚‰J/molã¸å¤‰æ›ï¼ˆMP: eV/atom â†’ CALPHAD: J/molï¼‰
            mp_energy_j = mp_energy * 96485.3  # eV/atom â†’ J/mol

            # èª¤å·®è¨ˆç®—
            error_percent = abs(calphad_energy - mp_energy_j) / abs(mp_energy_j) * 100

            results.append({
                'compound': compound,
                'mp_energy_eV_per_atom': mp_energy,
                'calphad_energy_J_per_mol': calphad_energy,
                'error_percent': error_percent,
                'reliable': error_percent < 10  # 10%ä»¥å†…ãªã‚‰ä¿¡é ¼æ€§é«˜
            })

        except Exception as e:
            results.append({
                'compound': compound,
                'error': str(e)
            })

    return pd.DataFrame(results)

def _parse_formula(self, formula: str, elements: List[str]) -> Dict[str, float]:
    """åŒ–å­¦å¼ã‹ã‚‰åŒ–å­¦é‡è«–æ¯”ã‚’æŠ½å‡º"""
    import re
    stoichiometry = {elem: 0 for elem in elements}

    for elem in elements:
        match = re.search(f"{elem}(\\d*)", formula)
        if match:
            count = match.group(1)
            stoichiometry[elem] = float(count) if count else 1.0

    # ãƒ¢ãƒ«åˆ†ç‡ã«æ­£è¦åŒ–
    total = sum(stoichiometry.values())
    return {k: v/total for k, v in stoichiometry.items()}
</code></pre>
            </div>
        </div>

        <div class="exercise-box">
            <h4>æ¼”ç¿’4: ã‚«ã‚¹ã‚¿ãƒ å¯è¦–åŒ–ã®å®Ÿè£…ï¼ˆMediumï¼‰</h4>
            <p>
                <code>PhaseDiagramVisualizer</code>ã«ã€ä»¥ä¸‹ã®å¯è¦–åŒ–æ©Ÿèƒ½ã‚’è¿½åŠ ã—ã¦ãã ã•ã„ï¼š
            </p>
            <ol>
                <li>3å…ƒç³»ç›¸å›³ã®ç­‰æ¸©æ–­é¢ï¼ˆisothermal sectionï¼‰ãƒ—ãƒ­ãƒƒãƒˆ</li>
                <li>ç›¸åˆ†ç‡ã®å¤‰åŒ–ã‚’ç¤ºã™ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆæ¸©åº¦ã‚¹ã‚­ãƒ£ãƒ³ï¼‰</li>
                <li>è¤‡æ•°ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹çµæœã®é‡ã­åˆã‚ã›æ¯”è¼ƒ</li>
            </ol>

            <button class="toggle-solution" onclick="this.nextElementSibling.classList.toggle('show')">è§£ç­”ã‚’è¡¨ç¤º</button>
            <div class="solution">
                <pre><code class="language-python">def plot_ternary_isothermal(self,
                              composition_triangle: np.ndarray,
                              phase_map: np.ndarray,
                              phase_names: List[str],
                              component_names: List[str],
                              temperature: float,
                              save_path: Optional[str] = None):
    """3å…ƒç³»ç­‰æ¸©æ–­é¢ã®ãƒ—ãƒ­ãƒƒãƒˆ"""
    import plotly.graph_objects as go

    # ä¸‰è§’åº§æ¨™ã¸ã®å¤‰æ›
    x = composition_triangle[:, 1] + 0.5 * composition_triangle[:, 2]
    y = 0.866 * composition_triangle[:, 2]

    fig = go.Figure()

    # å„ç›¸é ˜åŸŸã‚’ç•°ãªã‚‹è‰²ã§ãƒ—ãƒ­ãƒƒãƒˆ
    for i, phase in enumerate(phase_names):
        mask = phase_map == i
        fig.add_trace(go.Scatter(
            x=x[mask],
            y=y[mask],
            mode='markers',
            name=phase,
            marker=dict(size=5)
        ))

    fig.update_layout(
        title=f'{"-".join(component_names)} at {temperature} K',
        xaxis_title=f'{component_names[1]}',
        yaxis_title=f'{component_names[2]}',
        showlegend=True
    )

    if save_path:
        fig.write_html(save_path)

    fig.show()

def create_temperature_animation(self,
                                  temperature_range: np.ndarray,
                                  composition: np.ndarray,
                                  phase_fractions_sequence: List[np.ndarray],
                                  phase_names: List[str],
                                  save_path: Optional[str] = None):
    """æ¸©åº¦ã‚¹ã‚­ãƒ£ãƒ³ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³"""
    from matplotlib.animation import FuncAnimation

    fig, ax = plt.subplots(figsize=(10, 6))

    def update(frame):
        ax.clear()
        ax.stackplot(composition, phase_fractions_sequence[frame].T,
                     labels=phase_names, alpha=0.8)
        ax.set_title(f'Phase Fractions at T = {temperature_range[frame]:.0f} K')
        ax.set_xlabel('Composition')
        ax.set_ylabel('Phase Fraction')
        ax.legend(loc='upper right')
        ax.set_ylim(0, 1)

    anim = FuncAnimation(fig, update, frames=len(temperature_range), interval=100)

    if save_path:
        anim.save(save_path, writer='pillow', fps=10)

    plt.show()
</code></pre>
            </div>
        </div>

        <div class="exercise-box">
            <h4>æ¼”ç¿’5: ASEé€£æºã®æ‹¡å¼µï¼ˆHardï¼‰</h4>
            <p>
                <code>ASEPycalphadConnector</code>ã‚’æ‹¡å¼µã—ã€ä»¥ä¸‹ã‚’å®Ÿè£…ã—ã¦ãã ã•ã„ï¼š
            </p>
            <ol>
                <li>Special Quasirandom Structures (SQS)ã®å³å¯†ãªç”Ÿæˆï¼ˆmcsqsãƒ„ãƒ¼ãƒ«é€£æºï¼‰</li>
                <li>Quantum ESPRESSOã®å…¥åŠ›ãƒ•ã‚¡ã‚¤ãƒ«ç”Ÿæˆ</li>
                <li>ç”Ÿæˆã—ãŸæ§‹é€ ã®å¦¥å½“æ€§æ¤œè¨¼ï¼ˆåŸå­é–“è·é›¢ãƒã‚§ãƒƒã‚¯ã€ã‚¨ãƒãƒ«ã‚®ãƒ¼æœ€å°åŒ–ï¼‰</li>
            </ol>

            <button class="toggle-solution" onclick="this.nextElementSibling.classList.toggle('show')">è§£ç­”ã‚’è¡¨ç¤º</button>
            <div class="solution">
                <pre><code class="language-python">def generate_sqs(self, base_structure: Atoms,
                 composition: Dict[str, float],
                 supercell_size: tuple = (2, 2, 2)) -> Atoms:
    """
    SQSæ§‹é€ ã®ç”Ÿæˆï¼ˆmcsqsãƒ„ãƒ¼ãƒ«ã‚’ä½¿ç”¨ï¼‰

    Note: ATAT (Alloy Theoretic Automated Toolkit) ãŒå¿…è¦
    """
    from ase.build import make_supercell
    import subprocess

    # ã‚¹ãƒ¼ãƒ‘ãƒ¼ã‚»ãƒ«ã®ä½œæˆ
    supercell = make_supercell(base_structure,
                               [[supercell_size[0], 0, 0],
                                [0, supercell_size[1], 0],
                                [0, 0, supercell_size[2]]])

    # lat.in ãƒ•ã‚¡ã‚¤ãƒ«ã®ç”Ÿæˆï¼ˆATATå½¢å¼ï¼‰
    self._write_atat_lat(supercell, composition, 'lat.in')

    # mcsqså®Ÿè¡Œ
    subprocess.run(['mcsqs', '-n', str(len(supercell))], check=True)

    # bestsqs.out ã‹ã‚‰æ§‹é€ ã‚’èª­ã¿è¾¼ã¿
    sqs_structure = self._read_atat_bestsqs('bestsqs.out')

    return sqs_structure

def export_to_quantum_espresso(self, atoms: Atoms,
                                output_dir: str = "./qe_input",
                                ecutwfc: float = 60.0,
                                kpoints: tuple = (8, 8, 8)):
    """Quantum ESPRESSOå…¥åŠ›ãƒ•ã‚¡ã‚¤ãƒ«ç”Ÿæˆ"""
    from pathlib import Path
    output_path = Path(output_dir)
    output_path.mkdir(parents=True, exist_ok=True)

    # PWscfå…¥åŠ›ãƒ•ã‚¡ã‚¤ãƒ«
    with open(output_path / 'pw.in', 'w') as f:
        f.write(f"""&CONTROL
  calculation = 'scf'
  prefix = 'calphad'
  outdir = './tmp'
  pseudo_dir = './pseudo'
/
&SYSTEM
  ibrav = 0
  nat = {len(atoms)}
  ntyp = {len(set(atoms.get_chemical_symbols()))}
  ecutwfc = {ecutwfc}
/
&ELECTRONS
  conv_thr = 1.0d-8
/
ATOMIC_SPECIES
""")
        # å…ƒç´ ã¨æ“¬ãƒãƒ†ãƒ³ã‚·ãƒ£ãƒ«ã®è¨˜è¼‰
        unique_elements = set(atoms.get_chemical_symbols())
        for elem in unique_elements:
            f.write(f"{elem} 1.0 {elem}.UPF\n")

        # åŸå­åº§æ¨™
        f.write("\nATOMIC_POSITIONS (angstrom)\n")
        for atom in atoms:
            f.write(f"{atom.symbol} {atom.position[0]:.6f} {atom.position[1]:.6f} {atom.position[2]:.6f}\n")

        # Kç‚¹ãƒ¡ãƒƒã‚·ãƒ¥
        f.write(f"\nK_POINTS automatic\n")
        f.write(f"{kpoints[0]} {kpoints[1]} {kpoints[2]} 0 0 0\n")

    print(f"âœ“ Quantum ESPRESSO input generated in {output_dir}")

def validate_structure(self, atoms: Atoms,
                       min_distance: float = 1.5) -> bool:
    """æ§‹é€ ã®å¦¥å½“æ€§æ¤œè¨¼"""
    from ase.neighborlist import NeighborList

    # åŸå­é–“è·é›¢ãƒã‚§ãƒƒã‚¯
    nl = NeighborList([min_distance/2]*len(atoms),
                       self_interaction=False, bothways=True)
    nl.update(atoms)

    for i in range(len(atoms)):
        indices, offsets = nl.get_neighbors(i)
        if len(indices) == 0:
            print(f"Warning: Atom {i} has no neighbors within {min_distance} Ã…")
            return False

    print("âœ“ Structure validation passed")
    return True
</code></pre>
            </div>
        </div>

        <div class="exercise-box">
            <h4>æ¼”ç¿’6: ã‚¹ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°ã®æœ€é©åŒ–ï¼ˆHardï¼‰</h4>
            <p>
                <code>MaterialScreeningPipeline</code>ã‚’æœ€é©åŒ–ã—ã€ä»¥ä¸‹ã‚’å®Ÿç¾ã—ã¦ãã ã•ã„ï¼š
            </p>
            <ol>
                <li>ãƒ™ã‚¤ã‚ºæœ€é©åŒ–ã«ã‚ˆã‚‹åŠ¹ç‡çš„ãªã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ï¼ˆscikit-optimizeä½¿ç”¨ï¼‰</li>
                <li>å¤šç›®çš„æœ€é©åŒ–ï¼ˆPareto frontæŠ½å‡ºï¼‰</li>
                <li>æ©Ÿæ¢°å­¦ç¿’ä»£ç†ãƒ¢ãƒ‡ãƒ«ï¼ˆsurrogate modelï¼‰ã®æ§‹ç¯‰ã«ã‚ˆã‚‹é«˜é€ŸåŒ–</li>
            </ol>

            <button class="toggle-solution" onclick="this.nextElementSibling.classList.toggle('show')">è§£ç­”ã‚’è¡¨ç¤º</button>
            <div class="solution">
                <pre><code class="language-python">from skopt import gp_minimize
from skopt.space import Real
from sklearn.gaussian_process import GaussianProcessRegressor
import numpy as np

def bayesian_optimization_sampling(self,
                                   n_initial: int = 20,
                                   n_iterations: int = 50,
                                   objective: str = 'minimize_gibbs') -> np.ndarray:
    """
    ãƒ™ã‚¤ã‚ºæœ€é©åŒ–ã«ã‚ˆã‚‹åŠ¹ç‡çš„ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°

    Parameters:
    -----------
    n_initial : int
        åˆæœŸãƒ©ãƒ³ãƒ€ãƒ ã‚µãƒ³ãƒ—ãƒ«æ•°
    n_iterations : int
        ãƒ™ã‚¤ã‚ºæœ€é©åŒ–ã®åå¾©å›æ•°
    objective : str
        æœ€é©åŒ–ç›®çš„ï¼ˆ'minimize_gibbs', 'maximize_stability'ç­‰ï¼‰
    """
    # æ¢ç´¢ç©ºé–“ã®å®šç¾©ï¼ˆ2å…ƒç³»ã®å ´åˆï¼‰
    space = [Real(0.0, 1.0, name=f'x_{elem}')
             for elem in self.elements[1:]]

    def objective_function(x):
        """ç›®çš„é–¢æ•°ï¼ˆGibbs energyã®æœ€å°åŒ–ï¼‰"""
        composition = np.array([1 - sum(x)] + list(x))
        result = self.evaluate_composition(composition, temperature=1000)

        if result['success']:
            return result['gibbs_energy']
        else:
            return 1e10  # ãƒšãƒŠãƒ«ãƒ†ã‚£

    # ãƒ™ã‚¤ã‚ºæœ€é©åŒ–å®Ÿè¡Œ
    res = gp_minimize(objective_function, space,
                      n_calls=n_iterations, n_initial_points=n_initial,
                      random_state=42)

    # æœ€é©çµ„æˆã®å–å¾—
    optimal_compositions = np.array(res.x_iters)

    return optimal_compositions

def extract_pareto_front(self, screening_df: pd.DataFrame,
                         objectives: List[str],
                         maximize: List[bool]) -> pd.DataFrame:
    """
    å¤šç›®çš„æœ€é©åŒ–ã®Pareto frontæŠ½å‡º

    Parameters:
    -----------
    objectives : List[str]
        ç›®çš„é–¢æ•°ã®ã‚«ãƒ©ãƒ åãƒªã‚¹ãƒˆ
    maximize : List[bool]
        å„ç›®çš„é–¢æ•°ã‚’æœ€å¤§åŒ–ã™ã‚‹ã‹ï¼ˆTrueï¼‰æœ€å°åŒ–ã™ã‚‹ã‹ï¼ˆFalseï¼‰
    """
    from scipy.spatial import ConvexHull

    # ç›®çš„é–¢æ•°ã®å€¤ã‚’æŠ½å‡º
    obj_values = screening_df[objectives].values

    # æœ€å°åŒ–å•é¡Œã«çµ±ä¸€ï¼ˆmaximizeã®å ´åˆã¯ç¬¦å·åè»¢ï¼‰
    for i, is_max in enumerate(maximize):
        if is_max:
            obj_values[:, i] = -obj_values[:, i]

    # Paretoæ”¯é…é–¢ä¿‚ã®è¨ˆç®—
    is_pareto = np.ones(len(obj_values), dtype=bool)
    for i, point in enumerate(obj_values):
        if is_pareto[i]:
            # ã“ã®ãƒã‚¤ãƒ³ãƒˆãŒä»–ã®ãƒã‚¤ãƒ³ãƒˆã«æ”¯é…ã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª
            is_pareto[is_pareto] = np.any(obj_values[is_pareto] < point, axis=1)
            is_pareto[i] = True

    pareto_df = screening_df[is_pareto].copy()
    print(f"âœ“ Extracted {len(pareto_df)} Pareto optimal solutions")

    return pareto_df

def build_surrogate_model(self, training_data: pd.DataFrame,
                          features: List[str], target: str):
    """
    ä»£ç†ãƒ¢ãƒ‡ãƒ«ã®æ§‹ç¯‰ï¼ˆGaussian Processï¼‰

    Parameters:
    -----------
    training_data : pd.DataFrame
        è¨“ç·´ãƒ‡ãƒ¼ã‚¿
    features : List[str]
        ç‰¹å¾´é‡ã®ã‚«ãƒ©ãƒ å
    target : str
        äºˆæ¸¬å¯¾è±¡ã®ã‚«ãƒ©ãƒ å
    """
    X = training_data[features].values
    y = training_data[target].values

    # Gaussian Process Regressorã®è¨“ç·´
    gp = GaussianProcessRegressor(random_state=42)
    gp.fit(X, y)

    print(f"âœ“ Surrogate model trained: RÂ² = {gp.score(X, y):.3f}")

    return gp
</code></pre>
            </div>
        </div>

        <div class="exercise-box">
            <h4>æ¼”ç¿’7: ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼çµ±åˆï¼ˆVery Hardï¼‰</h4>
            <p>
                æœ¬ç« ã§å­¦ã‚“ã ã™ã¹ã¦ã®è¦ç´ ã‚’çµ±åˆã—ã€ä»¥ä¸‹ã®å®Œå…¨è‡ªå‹•åŒ–ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã‚’æ§‹ç¯‰ã—ã¦ãã ã•ã„ï¼š
            </p>
            <ol>
                <li>TDBãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ç®¡ç† â†’ ãƒãƒƒãƒè¨ˆç®— â†’ ææ–™ã‚¹ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚° â†’ pymatgenæ¤œè¨¼ â†’ ASEæ§‹é€ ç”Ÿæˆ â†’ VASP/QEå…¥åŠ›ãƒ•ã‚¡ã‚¤ãƒ«ç”Ÿæˆ</li>
                <li>å…¨ãƒ—ãƒ­ã‚»ã‚¹ã‚’YAMLè¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã§åˆ¶å¾¡</li>
                <li>å®Ÿè¡Œãƒ­ã‚°ã¨ãƒ¬ãƒãƒ¼ãƒˆï¼ˆPDFï¼‰ã®è‡ªå‹•ç”Ÿæˆ</li>
            </ol>

            <button class="toggle-solution" onclick="this.nextElementSibling.classList.toggle('show')">è§£ç­”ã‚’è¡¨ç¤º</button>
            <div class="solution">
                <pre><code class="language-python">class IntegratedCALPHADWorkflow:
    """
    çµ±åˆCALPHADãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼

    YAMLè¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰å…¨ãƒ—ãƒ­ã‚»ã‚¹ã‚’è‡ªå‹•å®Ÿè¡Œ
    """

    def __init__(self, config_file: str):
        with open(config_file, 'r') as f:
            self.config = yaml.safe_load(f)

        self.db_manager = TDBManager(self.config['database_dir'])
        self.results = {}

    def run_workflow(self):
        """ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å…¨ä½“ã®å®Ÿè¡Œ"""
        print("="*60)
        print("CALPHAD Integrated Workflow Started")
        print("="*60)

        # Step 1: ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ç®¡ç†
        self._setup_databases()

        # Step 2: ãƒãƒƒãƒè¨ˆç®—
        batch_results = self._run_batch_calculations()

        # Step 3: ã‚¹ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°
        candidates = self._screen_materials(batch_results)

        # Step 4: pymatgenæ¤œè¨¼
        validated = self._validate_with_mp(candidates)

        # Step 5: ASEæ§‹é€ ç”Ÿæˆ
        structures = self._generate_structures(validated)

        # Step 6: DFTå…¥åŠ›ç”Ÿæˆ
        self._export_dft_inputs(structures)

        # Step 7: ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆ
        self._generate_report()

        print("\n" + "="*60)
        print("Workflow Completed Successfully")
        print("="*60)

    def _setup_databases(self):
        """ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—"""
        for db_config in self.config['databases']:
            self.db_manager.register_database(**db_config)

    def _run_batch_calculations(self):
        """ãƒãƒƒãƒè¨ˆç®—ã®å®Ÿè¡Œ"""
        calculator = BatchPhaseDiagramCalculator(
            self.config['batch_config'], self.db_manager
        )
        calculator.run_batch(n_workers=self.config.get('n_workers', 4))
        calculator.save_results(self.config['output_dir'])
        return calculator.results

    def _screen_materials(self, batch_results):
        """ææ–™ã‚¹ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°"""
        # ã‚¹ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°åŸºæº–ã®æ§‹ç¯‰
        criteria = [ScreeningCriteria(**c) for c in self.config['screening_criteria']]

        # ã‚¹ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°å®Ÿè¡Œ
        pipeline = MaterialScreeningPipeline(
            db=self.db_manager.load_database(self.config['primary_database']),
            elements=self.config['elements'],
            phases=self.config['phases']
        )

        results = pipeline.screen_materials(
            compositions=batch_results,
            temperature=self.config['screening_temperature'],
            criteria=criteria
        )

        return results

    def _validate_with_mp(self, candidates):
        """Materials Projectã§ã®æ¤œè¨¼"""
        integrator = PymatgenPycalphadIntegrator(self.config['mp_api_key'])
        # æ¤œè¨¼ãƒ­ã‚¸ãƒƒã‚¯
        return candidates

    def _generate_structures(self, validated):
        """ASEæ§‹é€ ç”Ÿæˆ"""
        connector = ASEPycalphadConnector(
            self.db_manager.load_database(self.config['primary_database'])
        )
        # æ§‹é€ ç”Ÿæˆãƒ­ã‚¸ãƒƒã‚¯
        return []

    def _export_dft_inputs(self, structures):
        """DFTå…¥åŠ›ãƒ•ã‚¡ã‚¤ãƒ«ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ"""
        for i, struct in enumerate(structures):
            connector = ASEPycalphadConnector(None)
            connector.export_to_vasp(struct, f"./dft_inputs/structure_{i}")

    def _generate_report(self):
        """ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆï¼ˆMarkdown â†’ PDFï¼‰"""
        report_md = f"""# CALPHAD Workflow Report

## Configuration
- Elements: {self.config['elements']}
- Temperature: {self.config['screening_temperature']} K
- Databases: {list(self.db_manager.list_databases().keys())}

## Results Summary
- Total calculations: {len(self.results)}
- Candidates found: {len(self.results.get('candidates', []))}

## Next Steps
1. Run DFT calculations
2. Validate predictions
3. Experimental verification
"""
        with open(self.config['output_dir'] + '/report.md', 'w') as f:
            f.write(report_md)

        print(f"âœ“ Report generated")

# å®Ÿè¡Œ
workflow = IntegratedCALPHADWorkflow('workflow_config.yaml')
workflow.run_workflow()
</code></pre>
            </div>
        </div>

        <div class="exercise-box">
            <h4>æ¼”ç¿’8: æ€§èƒ½ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯ï¼ˆMediumï¼‰</h4>
            <p>
                ãƒãƒƒãƒè¨ˆç®—ã®æ€§èƒ½ã‚’ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯ã—ã€ä»¥ä¸‹ã‚’æ¸¬å®šã—ã¦ãã ã•ã„ï¼š
            </p>
            <ol>
                <li>ãƒ¯ãƒ¼ã‚«ãƒ¼æ•°ï¼ˆ1, 2, 4, 8, 16ï¼‰ã”ã¨ã®å®Ÿè¡Œæ™‚é–“</li>
                <li>ã‚¹ãƒ”ãƒ¼ãƒ‰ã‚¢ãƒƒãƒ—ç‡ã¨ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°åŠ¹ç‡</li>
                <li>ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ã®å¤‰åŒ–</li>
            </ol>

            <button class="toggle-solution" onclick="this.nextElementSibling.classList.toggle('show')">è§£ç­”ã‚’è¡¨ç¤º</button>
            <div class="solution">
                <pre><code class="language-python">import time
import psutil
import matplotlib.pyplot as plt

def benchmark_batch_calculation(n_tasks: int = 100):
    """ãƒãƒƒãƒè¨ˆç®—ã®ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯"""
    worker_counts = [1, 2, 4, 8, 16]
    execution_times = []
    memory_usages = []

    for n_workers in worker_counts:
        # ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ã®åˆæœŸå€¤
        process = psutil.Process()
        mem_before = process.memory_info().rss / 1024 / 1024  # MB

        # è¨ˆç®—å®Ÿè¡Œ
        calculator = BatchPhaseDiagramCalculator("batch_config.yaml", manager)

        start_time = time.time()
        calculator.run_batch(n_workers=n_workers)
        elapsed = time.time() - start_time

        mem_after = process.memory_info().rss / 1024 / 1024  # MB

        execution_times.append(elapsed)
        memory_usages.append(mem_after - mem_before)

        print(f"Workers: {n_workers}, Time: {elapsed:.1f}s, Memory: {mem_after-mem_before:.1f}MB")

    # ã‚¹ãƒ”ãƒ¼ãƒ‰ã‚¢ãƒƒãƒ—ç‡ã®è¨ˆç®—
    speedup = [execution_times[0] / t for t in execution_times]
    efficiency = [s / w for s, w in zip(speedup, worker_counts)]

    # å¯è¦–åŒ–
    fig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(15, 4))

    # å®Ÿè¡Œæ™‚é–“
    ax1.plot(worker_counts, execution_times, 'o-')
    ax1.set_xlabel('Number of Workers')
    ax1.set_ylabel('Execution Time (s)')
    ax1.set_title('Execution Time vs Workers')
    ax1.grid(True)

    # ã‚¹ãƒ”ãƒ¼ãƒ‰ã‚¢ãƒƒãƒ—
    ax2.plot(worker_counts, speedup, 'o-', label='Actual')
    ax2.plot(worker_counts, worker_counts, '--', label='Ideal')
    ax2.set_xlabel('Number of Workers')
    ax2.set_ylabel('Speedup')
    ax2.set_title('Speedup vs Workers')
    ax2.legend()
    ax2.grid(True)

    # ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡
    ax3.plot(worker_counts, memory_usages, 'o-')
    ax3.set_xlabel('Number of Workers')
    ax3.set_ylabel('Memory Usage (MB)')
    ax3.set_title('Memory Usage vs Workers')
    ax3.grid(True)

    plt.tight_layout()
    plt.savefig('benchmark_results.png', dpi=300)
    plt.show()

    print(f"\n=== Benchmark Summary ===")
    print(f"Optimal workers: {worker_counts[execution_times.index(min(execution_times))]}")
    print(f"Max speedup: {max(speedup):.2f}x")
    print(f"Efficiency at 16 workers: {efficiency[-1]*100:.1f}%")

benchmark_batch_calculation()
</code></pre>
            </div>
        </div>

        <h2>å‚è€ƒæ–‡çŒ®</h2>
        <ol>
            <li>Otis, R., & Liu, Z.-K. (2017). "pycalphad: CALPHAD-based Computational Thermodynamics in Python." <em>Journal of Open Research Software</em>, 5(1), 1. DOI: 10.5334/jors.140</li>
            <li>Bocklund, B., et al. (2019). "ESPEI for efficient thermodynamic database development, modification, and uncertainty quantification: application to Cuâ€“Mg." <em>MRS Communications</em>, 9(2), 618-627. DOI: 10.1557/mrc.2019.59</li>
            <li>Ong, S. P., et al. (2013). "Python Materials Genomics (pymatgen): A robust, open-source python library for materials analysis." <em>Computational Materials Science</em>, 68, 314-319. DOI: 10.1016/j.commatsci.2012.10.028</li>
            <li>Jain, A., et al. (2013). "Commentary: The Materials Project: A materials genome approach to accelerating materials innovation." <em>APL Materials</em>, 1(1), 011002. DOI: 10.1063/1.4812323</li>
            <li>Larsen, A. H., et al. (2017). "The atomic simulation environmentâ€”a Python library for working with atoms." <em>Journal of Physics: Condensed Matter</em>, 29(27), 273002. DOI: 10.1088/1361-648X/aa680e</li>
            <li>Sundman, B., Kattner, U. R., et al. (2015). "The OpenCalphad thermodynamic software interface." <em>Computational Materials Science</em>, 125, 188-196. DOI: 10.1016/j.commatsci.2016.08.045</li>
            <li>Van de Walle, A., et al. (2013). "Efficient stochastic generation of special quasirandom structures." <em>Calphad</em>, 42, 13-18. DOI: 10.1016/j.calphad.2013.06.006</li>
        </ol>

        <footer>
            <p>&copy; 2025 AIå¯ºå­å±‹ - CALPHAD Toolså…¥é–€ã‚·ãƒªãƒ¼ã‚º | <a href="mailto:yusuke.hashimoto.b8@tohoku.ac.jp">ãŠå•ã„åˆã‚ã›</a></p>
        </footer>

        <div class="nav-buttons">
            <a href="chapter-4.html" class="nav-button">â† å‰ã®ç« ã¸</a>
            <a href="index.html" class="nav-button">ç›®æ¬¡ã«æˆ»ã‚‹</a>
        </div>
    </div>

    <script>
        // è§£ç­”è¡¨ç¤ºãƒˆã‚°ãƒ«æ©Ÿèƒ½
        document.querySelectorAll('.toggle-solution').forEach(button => {
            button.addEventListener('click', function() {
                const solution = this.nextElementSibling;
                if (solution.classList.contains('show')) {
                    solution.classList.remove('show');
                    this.textContent = 'è§£ç­”ã‚’è¡¨ç¤º';
                } else {
                    solution.classList.add('show');
                    this.textContent = 'è§£ç­”ã‚’éš ã™';
                }
            });
        });
    </script>
</body>
</html>
