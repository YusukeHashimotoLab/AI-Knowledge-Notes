<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 5: 界面・欠陥シミュレーション | LAMMPS入門</title>
    <meta name="description" content="LAMMPSを用いた界面・欠陥シミュレーションの手法を学びます。粒界、転位、き裂、ナノ粒子の生成と解析、OVITO可視化ツールの活用方法を実践的に習得します。">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <style>
        :root {
            --primary-color: #11998e;
            --secondary-color: #38ef7d;
            --accent-color: #0d7377;
            --text-primary: #2c3e50;
            --text-secondary: #34495e;
            --bg-primary: #ffffff;
            --bg-secondary: #f8f9fa;
            --bg-code: #2d2d2d;
            --border-color: #e1e8ed;
            --shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.8;
            color: var(--text-primary);
            background: linear-gradient(135deg, var(--primary-color) 0%, var(--secondary-color) 100%);
            padding: 2rem 1rem;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            background: var(--bg-primary);
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.15);
            overflow: hidden;
        }

        header {
            background: linear-gradient(135deg, var(--primary-color) 0%, var(--secondary-color) 100%);
            color: white;
            padding: 3rem 2rem;
            text-align: center;
        }

        h1 {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 1rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }

        .subtitle {
            font-size: 1.2rem;
            opacity: 0.95;
            font-weight: 300;
        }

        main {
            padding: 3rem 2rem;
        }

        h2 {
            color: var(--primary-color);
            font-size: 2rem;
            margin: 3rem 0 1.5rem 0;
            padding-bottom: 0.5rem;
            border-bottom: 3px solid var(--secondary-color);
        }

        h3 {
            color: var(--accent-color);
            font-size: 1.5rem;
            margin: 2rem 0 1rem 0;
        }

        p {
            margin-bottom: 1.2rem;
            text-align: justify;
        }

        .info-box {
            background: linear-gradient(135deg, #e3f2fd 0%, #f0f9ff 100%);
            border-left: 4px solid var(--primary-color);
            padding: 1.5rem;
            margin: 2rem 0;
            border-radius: 8px;
        }

        .warning-box {
            background: linear-gradient(135deg, #fff3e0 0%, #fffbf5 100%);
            border-left: 4px solid #ff9800;
            padding: 1.5rem;
            margin: 2rem 0;
            border-radius: 8px;
        }

        .code-block {
            background: var(--bg-code);
            border-radius: 12px;
            padding: 1.5rem;
            margin: 2rem 0;
            overflow-x: auto;
            box-shadow: var(--shadow);
        }

        pre {
            margin: 0;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.95rem;
            line-height: 1.6;
        }

        code {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.9em;
            background: rgba(17, 153, 142, 0.1);
            padding: 0.2em 0.4em;
            border-radius: 4px;
        }

        .equation {
            overflow-x: auto;
            padding: 1.5rem;
            margin: 2rem 0;
            background: var(--bg-secondary);
            border-radius: 8px;
            text-align: center;
        }

        ul, ol {
            margin-left: 2rem;
            margin-bottom: 1.2rem;
        }

        li {
            margin-bottom: 0.5rem;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 2rem 0;
            box-shadow: var(--shadow);
            border-radius: 8px;
            overflow: hidden;
        }

        th {
            background: linear-gradient(135deg, var(--primary-color) 0%, var(--secondary-color) 100%);
            color: white;
            padding: 1rem;
            text-align: left;
            font-weight: 600;
        }

        td {
            padding: 1rem;
            border-bottom: 1px solid var(--border-color);
        }

        tr:last-child td {
            border-bottom: none;
        }

        tr:nth-child(even) {
            background: var(--bg-secondary);
        }

        .exercise {
            background: linear-gradient(135deg, #f3e5f5 0%, #faf8ff 100%);
            border-left: 4px solid #9c27b0;
            padding: 2rem;
            margin: 2rem 0;
            border-radius: 8px;
        }

        .exercise h4 {
            color: #9c27b0;
            margin-bottom: 1rem;
        }

        .learning-objectives {
            background: linear-gradient(135deg, #e8f5e9 0%, #f9fff9 100%);
            border-left: 4px solid #4caf50;
            padding: 2rem;
            margin: 2rem 0;
            border-radius: 8px;
        }

        .mermaid {
            text-align: center;
            margin: 2rem 0;
            padding: 2rem;
            background: var(--bg-secondary);
            border-radius: 8px;
        }

        @media (max-width: 768px) {
            body {
                padding: 1rem 0.5rem;
            }

            h1 {
                font-size: 1.8rem;
            }

            h2 {
                font-size: 1.5rem;
            }

            main {
                padding: 2rem 1.5rem;
            }

            .code-block {
                padding: 1rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Chapter 5: 界面・欠陥シミュレーション</h1>
            <p class="subtitle">Interface and Defect Simulations</p>
        </header>

        <main>
            <section id="introduction">
                <h2>5.1 界面・欠陥の重要性</h2>

                <p>材料の機械的性質、電気的性質、化学的性質は、結晶粒界、転位、空孔、き裂などの欠陥構造に大きく依存します。これらの欠陥は、材料の強度、延性、破壊靱性、拡散係数、電気伝導度などに影響を与えます。分子動力学シミュレーションは、原子スケールで欠陥の構造と動力学を直接観察できるため、欠陥研究において強力な手段となっています。</p>

                <p>本章では、LAMMPSを用いて以下の界面・欠陥シミュレーションを実施する方法を学びます：</p>

                <ul>
                    <li><strong>結晶粒界（Grain Boundary）</strong>：多結晶材料における結晶粒間の界面</li>
                    <li><strong>転位（Dislocation）</strong>：結晶構造の線欠陥、塑性変形の担い手</li>
                    <li><strong>き裂（Crack）</strong>：材料の破壊力学における重要な欠陥</li>
                    <li><strong>ナノ粒子（Nanoparticle）</strong>：表面エネルギーと量子効果が支配的な系</li>
                </ul>

                <div class="info-box">
                    <strong>欠陥研究におけるMDシミュレーションの利点：</strong>
                    <ul>
                        <li><strong>原子分解能</strong>：欠陥コアの原子配置を直接観察</li>
                        <li><strong>動的挙動</strong>：転位の運動、き裂の伝播など時間発展を追跡</li>
                        <li><strong>制御性</strong>：欠陥タイプ、密度、配置を自由に設定</li>
                        <li><strong>極限条件</strong>：実験困難な高温・高圧・高速変形条件でのシミュレーション</li>
                    </ul>
                </div>

                <h3>5.1.1 欠陥の分類</h3>

                <p>結晶欠陥は、その次元性により以下のように分類されます：</p>

                <table>
                    <thead>
                        <tr>
                            <th>次元</th>
                            <th>欠陥タイプ</th>
                            <th>例</th>
                            <th>主な影響</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>0次元（点欠陥）</td>
                            <td>空孔、格子間原子、不純物</td>
                            <td>Schottky欠陥、Frenkel欠陥</td>
                            <td>拡散、電気伝導</td>
                        </tr>
                        <tr>
                            <td>1次元（線欠陥）</td>
                            <td>刃状転位、らせん転位</td>
                            <td>Burgers vector \(\mathbf{b}\)で特徴付け</td>
                            <td>塑性変形、強度</td>
                        </tr>
                        <tr>
                            <td>2次元（面欠陥）</td>
                            <td>結晶粒界、積層欠陥、双晶境界</td>
                            <td>対称傾角粒界（Σ5、Σ13等）</td>
                            <td>粒界強化、粒界拡散</td>
                        </tr>
                        <tr>
                            <td>3次元（体積欠陥）</td>
                            <td>析出物、ボイド、き裂</td>
                            <td>Guinier-Preston zones、微細気孔</td>
                            <td>析出強化、破壊</td>
                        </tr>
                    </tbody>
                </table>

                <h3>5.1.2 Coincidence Site Lattice（CSL）理論</h3>

                <p>結晶粒界の幾何学的構造は、CSL（一致格子点）理論により体系的に分類されます。2つの結晶格子を回転させたとき、共通の格子点を持つ場合、その粒界はΣ値で特徴付けられます：</p>

                <div class="equation">
                    \[
                    \Sigma = \frac{V_{\text{CSL}}}{V_{\text{primitive}}}
                    \]
                </div>

                <p>ここで、\(V_{\text{CSL}}\)は一致格子の体積、\(V_{\text{primitive}}\)は基本格子の体積です。Σ値が小さいほど、粒界の周期性が高く、一般に低エネルギーで安定です。</p>

                <p>代表的な対称傾角粒界（STGB: Symmetric Tilt Grain Boundary）の例：</p>

                <ul>
                    <li><strong>Σ3 (60°, {111})</strong>：双晶境界、非常に低エネルギー</li>
                    <li><strong>Σ5 (36.87°, {100})</strong>：FCC金属でよく研究される粒界</li>
                    <li><strong>Σ13 (22.62°, {100})</strong>：中程度のエネルギー</li>
                </ul>
            </section>

            <section id="grain-boundary">
                <h2>5.2 結晶粒界シミュレーション</h2>

                <p>結晶粒界は、多結晶材料において隣接する結晶粒間に形成される界面です。粒界は、材料の機械的性質（Hall-Petch則による粒界強化）、拡散特性（粒界拡散）、腐食挙動などに重要な役割を果たします。</p>

                <h3>5.2.1 対称傾角粒界の生成</h3>

                <p>LAMMPSでΣ5対称傾角粒界を生成する方法を示します。まず、2つの結晶を回転させて接合します。</p>

                <div class="code-block">
                    <strong>Code Example 1: Σ5対称傾角粒界の生成（LAMMPS）</strong>
                    <pre><code class="language-bash"># LAMMPSスクリプト：Σ5対称傾角粒界（Cu、[100]傾角軸）

# 初期化
units           metal
dimension       3
boundary        p p p
atom_style      atomic

# Cu FCC格子定数
variable        a equal 3.615

# 結晶方位の定義
# 下側結晶：[100]軸周りに-18.435°回転
# 上側結晶：[100]軸周りに+18.435°回転
# 合計36.87°でΣ5粒界

# 下側結晶の生成
lattice         fcc ${a} orient x 1 0 0 orient y 0 1 0 orient z 0 0 1
region          lower block 0 10 0 20 0 5
create_box      1 lower
create_atoms    1 region lower

# 上側結晶の生成（[100]軸周りに36.87°回転）
lattice         fcc ${a} orient x 1 0 0 orient y 0 0.8 0.6 orient z 0 -0.6 0.8
region          upper block 0 10 20 40 0 5
create_atoms    1 region upper

# 質量設定（Cu）
mass            1 63.546

# EAMポテンシャル
pair_style      eam/alloy
pair_coeff      * * Cu_u3.eam Cu

# 粒界エネルギー緩和
fix             1 all box/relax iso 0.0  # 0気圧緩和
minimize        1.0e-6 1.0e-8 10000 100000

# 粒界構造の安定化（NVT）
velocity        all create 300.0 482756
fix             2 all nvt temp 300.0 300.0 100.0
timestep        0.001  # 1 fs
run             50000  # 50 ps

# 粒界原子の同定（Common Neighbor Analysis）
compute         cna all cna/atom 3.2
dump            1 all custom 1000 gb_sigma5.lammpstrj id type x y z c_cna

run             50000  # さらに50 ps

write_data      gb_sigma5_final.data
</code></pre>
                </div>

                <h3>5.2.2 粒界エネルギーの計算</h3>

                <p>粒界エネルギー\(\gamma_{\text{GB}}\)は、単位面積あたりの過剰エネルギーとして定義されます：</p>

                <div class="equation">
                    \[
                    \gamma_{\text{GB}} = \frac{E_{\text{GB}} - E_{\text{bulk}}}{2A}
                    \]
                </div>

                <p>ここで、\(E_{\text{GB}}\)は粒界を含む系の全エネルギー、\(E_{\text{bulk}}\)は同数原子のバルク結晶のエネルギー、\(A\)は粒界面積（周期境界条件により2つの粒界が存在するため2で割る）です。</p>

                <div class="code-block">
                    <strong>Code Example 2: 粒界エネルギーの計算（Python）</strong>
                    <pre><code class="language-python">import numpy as np

def calculate_gb_energy(E_gb_system, N_atoms, E_cohesive, A_gb):
    """
    粒界エネルギーを計算

    Parameters:
    -----------
    E_gb_system : float
        粒界系の全エネルギー [eV]
    N_atoms : int
        原子数
    E_cohesive : float
        凝集エネルギー（バルク1原子あたり） [eV/atom]
    A_gb : float
        粒界面積 [Ų]

    Returns:
    --------
    gamma_gb : float
        粒界エネルギー [J/m²]
    """
    # バルクエネルギー
    E_bulk = N_atoms * E_cohesive

    # 過剰エネルギー（2つの粒界が存在）
    E_excess = E_gb_system - E_bulk

    # 粒界エネルギー [eV/Ų]
    gamma_gb_eV_A2 = E_excess / (2.0 * A_gb)

    # 単位変換：eV/Ų → J/m²
    # 1 eV = 1.60218e-19 J
    # 1 Ų = 1e-20 m²
    # 1 eV/Ų = 1.60218e-19 / 1e-20 = 16.0218 J/m²
    gamma_gb_J_m2 = gamma_gb_eV_A2 * 16.0218

    return gamma_gb_J_m2

# 使用例：Cu Σ5粒界
E_gb = -12500.0  # 粒界系の全エネルギー [eV]（LAMMPSから取得）
N = 4000  # 原子数
E_coh = -3.54  # Cuの凝集エネルギー [eV/atom]
A = 100.0 * 50.0  # 粒界面積 [Ų]（10 nm × 5 nm）

gamma = calculate_gb_energy(E_gb, N, E_coh, A)
print(f"Σ5粒界エネルギー: {gamma:.3f} J/m²")
# 期待値：約0.8-1.2 J/m²（Cuの実験値・DFT計算値と比較）

# 複数のΣ値でエネルギーを比較
sigma_energies = {
    'Σ3 (60°)': 0.3,
    'Σ5 (36.87°)': 1.0,
    'Σ13 (22.62°)': 1.5,
    'Random': 2.0
}

import matplotlib.pyplot as plt

fig, ax = plt.subplots(figsize=(10, 6))
ax.bar(sigma_energies.keys(), sigma_energies.values(), color='#11998e')
ax.set_ylabel('Grain Boundary Energy (J/m²)', fontsize=14)
ax.set_title('Grain Boundary Energy vs. Σ Value (Cu)', fontsize=16)
ax.grid(True, alpha=0.3, axis='y')
plt.xticks(rotation=15)
plt.tight_layout()
plt.savefig('gb_energy_sigma.png', dpi=150)

# 一般的な傾向：Σ値が小さい → 粒界エネルギーが低い</code></pre>
                </div>

                <h3>5.2.3 粒界構造の解析：Common Neighbor Analysis (CNA)</h3>

                <p>粒界原子を同定するために、Common Neighbor Analysis（CNA）が広く用いられます。CNAは、各原子の局所的な結晶構造を分類する手法で、以下のように定義されます：</p>

                <ul>
                    <li><strong>FCC: 421</strong>（12個の最近接原子）</li>
                    <li><strong>HCP: 422</strong>（12個の最近接原子）</li>
                    <li><strong>BCC: 666</strong>（14個の最近接原子）</li>
                    <li><strong>その他: 000</strong>（粒界、表面、アモルファス）</li>
                </ul>

                <p>LAMMPSでは、<code>compute cna/atom</code>コマンドで自動的に計算できます。</p>
            </section>

            <section id="dislocation">
                <h2>5.3 転位シミュレーション</h2>

                <p>転位は、結晶構造における1次元の線欠陥で、塑性変形の主要な担い手です。転位の運動により、材料は永久的な変形を起こします。転位は、Burgersベクトル\(\mathbf{b}\)と転位線ベクトル\(\boldsymbol{\xi}\)により特徴付けられます。</p>

                <h3>5.3.1 刃状転位（Edge Dislocation）</h3>

                <p>刃状転位は、Burgersベクトル\(\mathbf{b}\)が転位線ベクトル\(\boldsymbol{\xi}\)に垂直な転位です（\(\mathbf{b} \perp \boldsymbol{\xi}\)）。刃状転位の周囲の変位場は、弾性論により以下のように記述されます：</p>

                <div class="equation">
                    \[
                    \begin{aligned}
                    u_x &= \frac{b}{2\pi} \left[ \tan^{-1}\left(\frac{y}{x}\right) + \frac{xy}{2(1-\nu)(x^2 + y^2)} \right] \\
                    u_y &= -\frac{b}{2\pi} \left[ \frac{1-2\nu}{4(1-\nu)}\ln(x^2 + y^2) + \frac{x^2 - y^2}{4(1-\nu)(x^2 + y^2)} \right]
                    \end{aligned}
                    \]
                </div>

                <p>ここで、\(b\)はBurgersベクトルの大きさ、\(\nu\)はPoisson比です。</p>

                <h3>5.3.2 LAMMPSでの刃状転位の導入</h3>

                <p>刃状転位を導入するには、上記の変位場を初期配置に適用します。</p>

                <div class="code-block">
                    <strong>Code Example 3: 刃状転位の導入（Python + LAMMPS）</strong>
                    <pre><code class="language-python">import numpy as np

def edge_dislocation_displacement(x, y, b, nu):
    """
    刃状転位の変位場を計算

    Parameters:
    -----------
    x, y : ndarray
        原子の座標 [Å]
    b : float
        Burgersベクトルの大きさ [Å]
    nu : float
        Poisson比

    Returns:
    --------
    u_x, u_y : ndarray
        x, y方向の変位 [Å]
    """
    r2 = x**2 + y**2
    # ゼロ除算を回避
    r2 = np.where(r2 < 1e-10, 1e-10, r2)

    # x方向変位
    u_x = (b / (2.0 * np.pi)) * (
        np.arctan2(y, x) + (x * y) / (2.0 * (1.0 - nu) * r2)
    )

    # y方向変位
    u_y = -(b / (2.0 * np.pi)) * (
        ((1.0 - 2.0 * nu) / (4.0 * (1.0 - nu))) * np.log(r2) +
        (x**2 - y**2) / (4.0 * (1.0 - nu) * r2)
    )

    return u_x, u_y

# 使用例：Cu FCC結晶に刃状転位を導入
# Burgersベクトル：b = a/2 <110>（FCC）
a = 3.615  # Cu格子定数 [Å]
b = a / np.sqrt(2)  # |b| = a/√2 ≈ 2.556 Å
nu = 0.343  # CuのPoisson比

# 結晶の生成（100 × 100 × 10 Å³）
Lx, Ly, Lz = 100.0, 100.0, 10.0
n_x, n_y, n_z = 28, 28, 3  # 格子点数
x = np.linspace(0, Lx, n_x)
y = np.linspace(0, Ly, n_y)
z = np.linspace(0, Lz, n_z)
X, Y, Z = np.meshgrid(x, y, z, indexing='ij')

# 転位中心（系の中央）
x0, y0 = Lx / 2.0, Ly / 2.0

# 変位の計算
u_x, u_y = edge_dislocation_displacement(X - x0, Y - y0, b, nu)

# 変位を適用
X_displaced = X + u_x
Y_displaced = Y + u_y
Z_displaced = Z  # z方向は変位なし

# LAMMPSデータファイルに書き出し
positions = np.column_stack((
    X_displaced.flatten(),
    Y_displaced.flatten(),
    Z_displaced.flatten()
))

with open('dislocation_edge.data', 'w') as f:
    N = len(positions)
    f.write(f"# Cu FCC with edge dislocation\n\n")
    f.write(f"{N} atoms\n")
    f.write(f"1 atom types\n\n")
    f.write(f"0.0 {Lx} xlo xhi\n")
    f.write(f"0.0 {Ly} ylo yhi\n")
    f.write(f"0.0 {Lz} zlo zhi\n\n")
    f.write(f"Masses\n\n")
    f.write(f"1 63.546\n\n")  # Cu
    f.write(f"Atoms\n\n")

    for i, pos in enumerate(positions):
        f.write(f"{i+1} 1 {pos[0]:.6f} {pos[1]:.6f} {pos[2]:.6f}\n")

print(f"転位入り結晶を保存: dislocation_edge.data ({N}原子)")</code></pre>
                </div>

                <h3>5.3.3 Dislocation Extraction Algorithm (DXA)</h3>

                <p>転位線の抽出と可視化には、Dislocation Extraction Algorithm（DXA）が用いられます。DXAは、原子配置から転位の位置、Burgersベクトル、転位線の形状を自動的に抽出します。OVITOには、DXA機能が組み込まれています。</p>

                <div class="code-block">
                    <strong>Code Example 4: OVITOによる転位解析（Python）</strong>
                    <pre><code class="language-python"># OVITOのPythonインターフェースを使用した転位解析
from ovito.io import import_file
from ovito.modifiers import DislocationAnalysisModifier
from ovito.pipeline import StaticSource, Pipeline
import matplotlib.pyplot as plt

# LAMMPSダンプファイルの読み込み
pipeline = import_file('dump.lammpstrj')

# Dislocation Analysis Modifier (DXA)
dxa = DislocationAnalysisModifier()
dxa.input_crystal_structure = DislocationAnalysisModifier.Lattice.FCC
pipeline.modifiers.append(dxa)

# 解析実行
data = pipeline.compute()

# 転位情報の取得
dislocations = data.dislocations
total_length = dislocations.segments['Length'].sum()
burgers_vectors = dislocations.segments['Burgers Vector']

print(f"検出された転位セグメント数: {len(dislocations.segments)}")
print(f"総転位線長: {total_length:.2f} Å")

# Burgersベクトルの分類
from collections import Counter
burgers_types = Counter([tuple(b) for b in burgers_vectors])

print("\nBurgersベクトル分布:")
for bv, count in burgers_types.items():
    print(f"  {bv}: {count} segments")

# 転位密度の計算（単位体積あたりの転位線長）
cell_volume = data.cell.volume  # [Ų]
cell_volume_cm3 = cell_volume * 1e-24  # [cm³]
dislocation_density = total_length / cell_volume  # [Å/Ų] = [10^10 m/m³]
dislocation_density_cm2 = dislocation_density * 1e8  # [cm^-2]

print(f"\n転位密度: {dislocation_density_cm2:.2e} cm^-2")

# 転位線の可視化（OVITOでレンダリング）
import ovito.vis as vis
pipeline.add_to_scene()
vp = vis.Viewport()
vp.type = vis.Viewport.Type.Perspective
vp.camera_pos = (150, 150, 150)
vp.camera_dir = (-1, -1, -1)
vp.fov = 60
vp.render_image(filename='dislocation_3d.png', size=(1920, 1080),
                 renderer=vis.TachyonRenderer())</code></pre>
                </div>
            </section>

            <section id="crack">
                <h2>5.4 き裂シミュレーション</h2>

                <p>き裂は、材料の破壊現象において重要な役割を果たします。き裂先端では応力が集中し、臨界値に達すると破壊が進展します。MDシミュレーションでは、き裂先端の原子スケール構造と破壊機構を直接観察できます。</p>

                <h3>5.4.1 破壊力学の基礎</h3>

                <p>き裂先端の応力場は、Westergaard解により以下のように記述されます：</p>

                <div class="equation">
                    \[
                    \sigma_{ij} = \frac{K_I}{\sqrt{2\pi r}} f_{ij}(\theta) + O(1)
                    \]
                </div>

                <p>ここで、\(K_I\)は応力拡大係数（モードI）、\(r\)はき裂先端からの距離、\(\theta\)は角度、\(f_{ij}\)は角度関数です。\(K_I\)が臨界値\(K_{Ic}\)（破壊靱性）を超えると、き裂が伝播します。</p>

                <h3>5.4.2 LAMMPSでのき裂導入と引張シミュレーション</h3>

                <div class="code-block">
                    <strong>Code Example 5: き裂伝播シミュレーション（LAMMPS）</strong>
                    <pre><code class="language-bash"># LAMMPSスクリプト：モードIき裂伝播（Si結晶）

units           metal
dimension       3
boundary        p s p  # x: 周期、y: 固定、z: 周期
atom_style      atomic

# Si結晶（ダイヤモンド構造）
lattice         diamond 5.43
region          box block 0 100 0 100 0 10
create_box      1 box
create_atoms    1 box

mass            1 28.0855  # Si

# Tersoffポテンシャル（共有結合）
pair_style      tersoff
pair_coeff      * * Si.tersoff Si

# 初期き裂の導入（y = 50 Å、x = 0-30 Åの領域）
region          crack block 0 30 49 51 INF INF
delete_atoms    region crack

# 境界条件：上下端を固定、中央を引張
region          bottom block INF INF 0 10 INF INF
region          top block INF INF 90 100 INF INF
group           bottom region bottom
group           top region top
group           mobile subtract all bottom top

# 初期緩和（0 K）
minimize        1.0e-6 1.0e-8 10000 100000

# 温度設定（300 K）
velocity        mobile create 300.0 482736
fix             1 mobile nvt temp 300.0 300.0 100.0

# 引張変形（y方向に0.1%ひずみ/ns）
variable        strain_rate equal 1.0e-4  # [1/fs] = 1e11 [1/s]
fix             2 top move linear 0.0 ${strain_rate} 0.0
fix             3 bottom move linear 0.0 -${strain_rate} 0.0

# 応力計算
compute         stress all stress/atom NULL
compute         avg_stress all reduce ave c_stress[2]  # σ_yy

# 出力
thermo          1000
thermo_style    custom step temp press c_avg_stress
dump            1 all custom 1000 crack.lammpstrj id type x y z c_stress[2]

timestep        0.001  # 1 fs
run             100000  # 100 ps

# 最終状態
write_data      crack_final.data
</code></pre>
                </div>

                <h3>5.4.3 き裂先端応力場の解析</h3>

                <div class="code-block">
                    <strong>Code Example 6: き裂先端応力場の解析（Python）</strong>
                    <pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt

def crack_tip_stress_field(r, theta, K_I, mu, nu):
    """
    き裂先端周囲の応力場（モードI）

    Parameters:
    -----------
    r : float or ndarray
        き裂先端からの距離 [Å]
    theta : float or ndarray
        角度 [rad]
    K_I : float
        応力拡大係数 [MPa·√m]
    mu : float
        せん断弾性率 [GPa]
    nu : float
        Poisson比

    Returns:
    --------
    sigma_xx, sigma_yy, sigma_xy : ndarray
        応力成分 [MPa]
    """
    # K_Iの単位変換：MPa·√m → eV/Ų·√Å
    # 1 MPa = 6.2415e-6 eV/Ų
    # 1 √m = 100 √Å
    K_I_eV = K_I * 6.2415e-6 * 100

    # Westergaard解
    cos_half = np.cos(theta / 2.0)
    sin_half = np.sin(theta / 2.0)
    sin_3half = np.sin(3.0 * theta / 2.0)

    sigma_xx = (K_I_eV / np.sqrt(2.0 * np.pi * r)) * cos_half * (
        1.0 - sin_half * sin_3half
    )

    sigma_yy = (K_I_eV / np.sqrt(2.0 * np.pi * r)) * cos_half * (
        1.0 + sin_half * sin_3half
    )

    sigma_xy = (K_I_eV / np.sqrt(2.0 * np.pi * r)) * cos_half * sin_half * cos_half

    return sigma_xx, sigma_yy, sigma_xy

# パラメータ（Si）
K_I = 0.8  # 応力拡大係数 [MPa·√m]
mu = 60.0  # せん断弾性率 [GPa]
nu = 0.22  # Poisson比

# き裂先端からの距離（5-50 Å）
r = np.linspace(5, 50, 100)
theta = 0.0  # θ = 0°（き裂前方）

sigma_xx, sigma_yy, sigma_xy = crack_tip_stress_field(r, theta, K_I, mu, nu)

# プロット
fig, ax = plt.subplots(figsize=(10, 6))
ax.plot(r, sigma_xx, label='σ_xx', linewidth=2)
ax.plot(r, sigma_yy, label='σ_yy', linewidth=2)
ax.plot(r, sigma_xy, label='σ_xy', linewidth=2)
ax.set_xlabel('Distance from crack tip r (Å)', fontsize=14)
ax.set_ylabel('Stress (eV/Ų)', fontsize=14)
ax.set_title(f'Crack Tip Stress Field (K_I = {K_I} MPa√m)', fontsize=16)
ax.legend(fontsize=12)
ax.grid(True, alpha=0.3)
plt.tight_layout()
plt.savefig('crack_tip_stress.png', dpi=150)

# 1/√r依存性の確認
fig2, ax2 = plt.subplots(figsize=(10, 6))
ax2.plot(1.0 / np.sqrt(r), sigma_yy, 'o-', linewidth=2, label='σ_yy')
ax2.set_xlabel('1/√r (Å^(-1/2))', fontsize=14)
ax2.set_ylabel('σ_yy (eV/Ų)', fontsize=14)
ax2.set_title('Verification of 1/√r Dependence', fontsize=16)
ax2.legend()
ax2.grid(True, alpha=0.3)
plt.tight_layout()
plt.savefig('crack_scaling.png', dpi=150)

# 期待される結果：
# - σ_yyがき裂前方（θ=0）で最大
# - 1/√r依存性が線形（理論通り）</code></pre>
                </div>
            </section>

            <section id="nanoparticle">
                <h2>5.5 ナノ粒子シミュレーション</h2>

                <p>ナノ粒子は、表面原子の割合が高く、表面エネルギーが支配的となる系です。ナノ粒子の融点、機械的性質、触媒活性などは、バルク材料とは大きく異なります。</p>

                <h3>5.5.1 球状ナノ粒子の生成</h3>

                <div class="code-block">
                    <strong>Code Example 7: 球状Auナノ粒子の生成（LAMMPS）</strong>
                    <pre><code class="language-bash"># LAMMPSスクリプト：球状Auナノ粒子

units           metal
dimension       3
boundary        f f f  # 自由境界（非周期）
atom_style      atomic

# FCC Au格子
lattice         fcc 4.08
region          box block -50 50 -50 50 -50 50
create_box      1 box

# 球状領域にAu原子を生成（半径30 Å）
region          sphere sphere 0 0 0 30
create_atoms    1 region sphere

mass            1 196.97  # Au

# EAMポテンシャル
pair_style      eam/alloy
pair_coeff      * * Au_u3.eam Au

# 表面原子の同定（配位数 < 12）
compute         coord all coord/atom cutoff 3.0
variable        surf atom c_coord<12
group           surface variable surf

# 原子数カウント
variable        N_total equal count(all)
variable        N_surface equal count(surface)
variable        ratio equal v_N_surface/v_N_total

print           "Total atoms: ${N_total}"
print           "Surface atoms: ${N_surface}"
print           "Surface ratio: ${ratio}"

# 構造緩和（0 K）
minimize        1.0e-6 1.0e-8 10000 100000

# 融点測定（加熱シミュレーション）
velocity        all create 300.0 482756
fix             1 all nvt temp 300.0 1500.0 100.0  # 300→1500 K

compute         msd all msd
thermo          1000
thermo_style    custom step temp pe ke etotal c_msd[4]

timestep        0.002  # 2 fs
run             500000  # 1 ns（加熱速度 1.2 K/ps）

write_data      nanoparticle_final.data
</code></pre>
                </div>

                <h3>5.5.2 表面エネルギーの計算</h3>

                <p>ナノ粒子の表面エネルギー\(\gamma\)は、球状ナノ粒子の全エネルギーから推定できます：</p>

                <div class="equation">
                    \[
                    E_{\text{NP}} = N E_{\text{bulk}} + 4\pi r^2 \gamma
                    \]
                </div>

                <p>ここで、\(N\)は原子数、\(E_{\text{bulk}}\)はバルクの1原子あたりエネルギー、\(r\)は粒子半径です。複数の半径で計算し、\(E_{\text{NP}}\)を\(N\)と\(r^2\)の関数としてフィットすることで、\(\gamma\)を求めます。</p>

                <div class="code-block">
                    <strong>Code Example 8: ナノ粒子の表面エネルギー推定（Python）</strong>
                    <pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit

# データ：複数の半径でのナノ粒子エネルギー
# (半径 [Å], 原子数, 全エネルギー [eV])
data = np.array([
    [10.0, 321, -1145.0],
    [15.0, 1035, -3710.0],
    [20.0, 2406, -8655.0],
    [25.0, 4681, -16875.0],
    [30.0, 8013, -28920.0],
])

radii = data[:, 0]
N_atoms = data[:, 1]
E_total = data[:, 2]

# バルクエネルギー（Auの凝集エネルギー）
E_bulk = -3.93  # eV/atom

# 表面エネルギーのフィッティング
def nanoparticle_energy(N, E_bulk, gamma):
    """
    E_NP = N * E_bulk + 4πr² * γ
    r を N から推定：r = r_s * N^(1/3)（球状粒子）
    """
    r_s = (3.0 / (4.0 * np.pi * 0.0856))**(1.0 / 3.0)  # Au原子密度から
    r = r_s * N**(1.0 / 3.0)
    return N * E_bulk + 4.0 * np.pi * r**2 * gamma

# フィッティング
popt, pcov = curve_fit(
    lambda N, gamma: nanoparticle_energy(N, E_bulk, gamma),
    N_atoms, E_total, p0=[1.0]
)

gamma_fitted = popt[0]
gamma_error = np.sqrt(pcov[0, 0])

print(f"推定表面エネルギー: {gamma_fitted:.4f} ± {gamma_error:.4f} eV/Ų")
print(f"                  = {gamma_fitted * 16.0218:.4f} J/m²")

# プロット
N_fit = np.linspace(N_atoms.min(), N_atoms.max(), 100)
E_fit = nanoparticle_energy(N_fit, E_bulk, gamma_fitted)

fig, ax = plt.subplots(figsize=(10, 6))
ax.plot(N_atoms, E_total, 'o', markersize=10, label='MD data')
ax.plot(N_fit, E_fit, '-', linewidth=2,
        label=f'Fit: γ = {gamma_fitted:.3f} eV/Ų')
ax.set_xlabel('Number of atoms N', fontsize=14)
ax.set_ylabel('Total Energy (eV)', fontsize=14)
ax.set_title('Surface Energy Estimation from Nanoparticle Energies', fontsize=16)
ax.legend(fontsize=12)
ax.grid(True, alpha=0.3)
plt.tight_layout()
plt.savefig('nanoparticle_surface_energy.png', dpi=150)

# 期待される結果：
# Au表面エネルギー：約1.5 J/m² (実験値・DFT計算値と比較)</code></pre>
                </div>
            </section>

            <section id="ovito">
                <h2>5.6 OVITO可視化ツール</h2>

                <p>OVITO（Open Visualization Tool）は、原子シミュレーションの可視化・解析に特化したソフトウェアです。LAMMPSのダンプファイルを読み込み、結晶構造、欠陥、応力分布などを高品質な画像・動画として出力できます。</p>

                <h3>5.6.1 OVITO Pythonインターフェース</h3>

                <p>OVITOは、Pythonインターフェースを提供しており、スクリプトによる自動解析が可能です。</p>

                <div class="code-block">
                    <strong>Code Example 9: OVITOによる粒界可視化（Python）</strong>
                    <pre><code class="language-python"># OVITOのPythonスクリプト例：粒界可視化

from ovito.io import import_file
from ovito.modifiers import *
from ovito.vis import *
import ovito

# LAMMPSダンプファイルの読み込み
pipeline = import_file('gb_sigma5.lammpstrj')

# Common Neighbor Analysis（結晶構造の同定）
cna = CommonNeighborAnalysisModifier()
pipeline.modifiers.append(cna)

# 色分け（FCC: 緑、その他: 赤）
pipeline.modifiers.append(ColorCodingModifier(
    particle_property='Structure Type',
    gradient=ColorCodingModifier.Viridis()
))

# 粒界原子のみ表示
pipeline.modifiers.append(ExpressionSelectionModifier(
    expression='StructureType != 1'  # FCC以外を選択
))
pipeline.modifiers.append(DeleteSelectedModifier())

# レンダリング設定
pipeline.add_to_scene()
vp = Viewport()
vp.type = Viewport.Type.Perspective
vp.camera_pos = (50, 50, 150)
vp.camera_dir = (-0.3, -0.3, -1)
vp.fov = 40

# 高品質レンダリング
vp.render_image(
    filename='grain_boundary_visualization.png',
    size=(1920, 1080),
    renderer=TachyonRenderer(
        ambient_occlusion=True,
        antialiasing=True,
        direct_light=True,
        shadows=True
    )
)

print("粒界可視化完了: grain_boundary_visualization.png")</code></pre>
                </div>

                <h3>5.6.2 応力分布の可視化</h3>

                <div class="code-block">
                    <pre><code class="language-python"># OVITOで応力分布を可視化

from ovito.io import import_file
from ovito.modifiers import ComputePropertyModifier, ColorCodingModifier

# ダンプファイル読み込み（応力成分含む）
pipeline = import_file('crack.lammpstrj')

# von Mises応力の計算
pipeline.modifiers.append(ComputePropertyModifier(
    output_property='vonMises',
    expressions=[
        'sqrt(0.5*((c_stress[1]-c_stress[2])^2 + ' +
        '(c_stress[2]-c_stress[3])^2 + (c_stress[3]-c_stress[1])^2 + ' +
        '6*(c_stress[4]^2 + c_stress[5]^2 + c_stress[6]^2)))'
    ]
))

# 応力で色分け
pipeline.modifiers.append(ColorCodingModifier(
    particle_property='vonMises',
    gradient=ColorCodingModifier.Hot(),
    start_value=0.0,
    end_value=5.0  # eV/Ų
))

# レンダリング
vp = Viewport()
vp.type = Viewport.Type.Perspective
vp.render_image(filename='stress_distribution.png', size=(1920, 1080),
                 renderer=TachyonRenderer())</code></pre>
                </div>
            </section>

            <section id="exercises">
                <h2>演習問題</h2>

                <div class="exercise">
                    <h4>Exercise 1: Σ3双晶境界の粒界エネルギー計算（Easy）</h4>
                    <p><strong>問題：</strong> Cu FCC結晶において、Σ3双晶境界（60°, {111}回転軸）の粒界エネルギーを計算してください。系サイズは50×50×50 ų、EAMポテンシャルを使用します。Σ5粒界（Code Example 1, 2）と比較し、Σ3の方が低エネルギーであることを確認してください。</p>

                    <details>
                        <summary><strong>解答例</strong>（クリックで表示）</summary>
                        <p>（解答は省略：Σ3粒界生成LAMMPSスクリプト + Pythonエネルギー計算、期待値：γ(Σ3) ≈ 0.2-0.4 J/m² < γ(Σ5) ≈ 0.8-1.2 J/m²）</p>
                    </details>
                </div>

                <div class="exercise">
                    <h4>Exercise 2: 刃状転位の応力場解析（Medium）</h4>
                    <p><strong>問題：</strong> Code Example 3で生成した刃状転位入りCu結晶について、LAMMPSでNVT緩和（300 K、100 ps）後、各原子の応力テンソル\(\sigma_{ij}\)を計算してください。転位中心から距離\(r\)の関数として応力成分\(\sigma_{yy}\)をプロットし、理論式（Code Example 6）と比較してください。</p>

                    <details>
                        <summary><strong>解答例</strong>（クリックで表示）</summary>
                        <p>（解答は省略：LAMMPS stress/atom計算 + Python解析、\(\sigma_{yy} \propto 1/r\)の確認、MD vs 理論の一致度評価）</p>
                    </details>
                </div>

                <div class="exercise">
                    <h4>Exercise 3: ナノ粒子の融点降下（Hard）</h4>
                    <p><strong>問題：</strong> Code Example 7のAuナノ粒子について、半径10, 20, 30, 40, 50 Åの5種類を生成し、それぞれの融点を求めてください。融点は、加熱シミュレーション（300 K → 1500 K、1 K/ps）でのMSD（mean square displacement）の急増点として定義します。半径\(r\)と融点\(T_m\)の関係をプロットし、Gibbs-Thomson式：\(T_m(r) = T_m^{\infty}(1 - 2\gamma / (r \rho \Delta H_f))\)と比較してください。ここで、\(T_m^{\infty} = 1337\) K（Auバルク融点）、\(\gamma \approx 1.5\) J/m²、\(\rho = 19.3\) g/cm³、\(\Delta H_f = 12.55\) kJ/mol です。</p>

                    <details>
                        <summary><strong>解答例</strong>（クリックで表示）</summary>
                        <p>（解答は省略：5サイズのナノ粒子生成・加熱シミュレーション、MSD解析による融点決定、Gibbs-Thomson式との比較プロット、小粒子ほど融点が低下することの確認）</p>
                    </details>
                </div>
            </section>

            <section id="learning-objectives">
                <h2>学習目標の確認</h2>

                <div class="learning-objectives">
                    <h3>Chapter 5の学習目標</h3>
                    <p>以下の項目について、自己評価を行ってください。各項目について、「理解できた」「概ね理解」「要復習」の3段階で評価しましょう。</p>

                    <h4>レベル1：基本理解</h4>
                    <ol>
                        <li>結晶欠陥の分類（点・線・面・体積欠陥）を説明できる</li>
                        <li>結晶粒界のCSL理論とΣ値の意味を理解している</li>
                        <li>転位のBurgersベクトルと転位線の関係を説明できる</li>
                        <li>き裂先端の応力集中と応力拡大係数\(K_I\)の概念を理解している</li>
                        <li>ナノ粒子における表面エネルギーの重要性を説明できる</li>
                    </ol>

                    <h4>レベル2：実践スキル</h4>
                    <ol start="6">
                        <li>LAMMPSで対称傾角粒界（Σ5等）を生成できる</li>
                        <li>粒界エネルギーを計算し、Σ値との関係を評価できる</li>
                        <li>刃状転位を導入し、変位場を可視化できる</li>
                        <li>き裂シミュレーションで応力拡大係数を推定できる</li>
                        <li>OVITOを用いて欠陥構造を可視化・解析できる</li>
                    </ol>

                    <h4>レベル3：応用力</h4>
                    <ol start="11">
                        <li>Common Neighbor AnalysisやDXAで欠陥を自動抽出できる</li>
                        <li>転位密度を計算し、材料強度との関係を議論できる</li>
                        <li>き裂伝播シミュレーションから破壊靱性を推定できる</li>
                        <li>ナノ粒子の融点降下をGibbs-Thomson式で説明できる</li>
                        <li>複数の欠陥が共存する系（粒界+転位等）をシミュレーションできる</li>
                    </ol>
                </div>
            </section>

            <section id="references">
                <h2>参考文献</h2>
                <ol>
                    <li>Hull, D., Bacon, D.J. (2011). <em>Introduction to Dislocations</em>, 5th ed., Butterworth-Heinemann, pp. 1-90.</li>
                    <li>Sutton, A.P., Balluffi, R.W. (1995). <em>Interfaces in Crystalline Materials</em>, Oxford University Press, pp. 1-120.</li>
                    <li>Anderson, T.L. (2017). <em>Fracture Mechanics: Fundamentals and Applications</em>, 4th ed., CRC Press, pp. 35-120.</li>
                    <li>Stukowski, A., Bulatov, V.V., Arsenlis, A. (2012). "Automated identification and indexing of dislocations in crystal interfaces," <em>Modelling Simul. Mater. Sci. Eng.</em>, 20, 085007, pp. 1-16.</li>
                    <li>Stukowski, A. (2010). "Visualization and analysis of atomistic simulation data with OVITO–the Open Visualization Tool," <em>Modelling Simul. Mater. Sci. Eng.</em>, 18, 015012, pp. 1-7.</li>
                    <li>Tschopp, M.A., McDowell, D.L. (2007). "Asymmetric tilt grain boundary structure and energy in copper and aluminium," <em>Phil. Mag.</em>, 87, 3871-3892.</li>
                    <li>Yamakov, V., et al. (2002). "Dislocation processes in the deformation of nanocrystalline aluminium by molecular-dynamics simulation," <em>Nature Mater.</em>, 1, 45-48.</li>
                </ol>
            </section>
        </main>
    </div>

    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            }
        };

        mermaid.initialize({ startOnLoad: true, theme: 'default' });

        document.addEventListener('DOMContentLoaded', function() {
            mermaid.init(undefined, document.querySelectorAll('.mermaid'));
        });
    </script>
</body>
</html>