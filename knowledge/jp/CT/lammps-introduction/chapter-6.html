<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 6: Python実践：LAMMPS自動化ワークフロー | LAMMPS入門</title>
    <meta name="description" content="PyLAMMPSを用いたLAMMPSシミュレーションの自動化、パラメータスイープ、MPI並列実行、機械学習統合、HPC最適化の実践的な手法を学びます。">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <style>
        :root {
            --primary-color: #11998e;
            --secondary-color: #38ef7d;
            --accent-color: #0d7377;
            --text-primary: #2c3e50;
            --text-secondary: #34495e;
            --bg-primary: #ffffff;
            --bg-secondary: #f8f9fa;
            --bg-code: #2d2d2d;
            --border-color: #e1e8ed;
            --shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.8;
            color: var(--text-primary);
            background: linear-gradient(135deg, var(--primary-color) 0%, var(--secondary-color) 100%);
            padding: 2rem 1rem;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            background: var(--bg-primary);
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.15);
            overflow: hidden;
        }

        header {
            background: linear-gradient(135deg, var(--primary-color) 0%, var(--secondary-color) 100%);
            color: white;
            padding: 3rem 2rem;
            text-align: center;
        }

        h1 {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 1rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }

        .subtitle {
            font-size: 1.2rem;
            opacity: 0.95;
            font-weight: 300;
        }

        main {
            padding: 3rem 2rem;
        }

        h2 {
            color: var(--primary-color);
            font-size: 2rem;
            margin: 3rem 0 1.5rem 0;
            padding-bottom: 0.5rem;
            border-bottom: 3px solid var(--secondary-color);
        }

        h3 {
            color: var(--accent-color);
            font-size: 1.5rem;
            margin: 2rem 0 1rem 0;
        }

        p {
            margin-bottom: 1.2rem;
            text-align: justify;
        }

        .info-box {
            background: linear-gradient(135deg, #e3f2fd 0%, #f0f9ff 100%);
            border-left: 4px solid var(--primary-color);
            padding: 1.5rem;
            margin: 2rem 0;
            border-radius: 8px;
        }

        .warning-box {
            background: linear-gradient(135deg, #fff3e0 0%, #fffbf5 100%);
            border-left: 4px solid #ff9800;
            padding: 1.5rem;
            margin: 2rem 0;
            border-radius: 8px;
        }

        .code-block {
            background: var(--bg-code);
            border-radius: 12px;
            padding: 1.5rem;
            margin: 2rem 0;
            overflow-x: auto;
            box-shadow: var(--shadow);
        }

        pre {
            margin: 0;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.95rem;
            line-height: 1.6;
        }

        code {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.9em;
            background: rgba(17, 153, 142, 0.1);
            padding: 0.2em 0.4em;
            border-radius: 4px;
        }

        .equation {
            overflow-x: auto;
            padding: 1.5rem;
            margin: 2rem 0;
            background: var(--bg-secondary);
            border-radius: 8px;
            text-align: center;
        }

        ul, ol {
            margin-left: 2rem;
            margin-bottom: 1.2rem;
        }

        li {
            margin-bottom: 0.5rem;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 2rem 0;
            box-shadow: var(--shadow);
            border-radius: 8px;
            overflow: hidden;
        }

        th {
            background: linear-gradient(135deg, var(--primary-color) 0%, var(--secondary-color) 100%);
            color: white;
            padding: 1rem;
            text-align: left;
            font-weight: 600;
        }

        td {
            padding: 1rem;
            border-bottom: 1px solid var(--border-color);
        }

        tr:last-child td {
            border-bottom: none;
        }

        tr:nth-child(even) {
            background: var(--bg-secondary);
        }

        .exercise {
            background: linear-gradient(135deg, #f3e5f5 0%, #faf8ff 100%);
            border-left: 4px solid #9c27b0;
            padding: 2rem;
            margin: 2rem 0;
            border-radius: 8px;
        }

        .exercise h4 {
            color: #9c27b0;
            margin-bottom: 1rem;
        }

        .learning-objectives {
            background: linear-gradient(135deg, #e8f5e9 0%, #f9fff9 100%);
            border-left: 4px solid #4caf50;
            padding: 2rem;
            margin: 2rem 0;
            border-radius: 8px;
        }

        .mermaid {
            text-align: center;
            margin: 2rem 0;
            padding: 2rem;
            background: var(--bg-secondary);
            border-radius: 8px;
        }

        @media (max-width: 768px) {
            body {
                padding: 1rem 0.5rem;
            }

            h1 {
                font-size: 1.8rem;
            }

            h2 {
                font-size: 1.5rem;
            }

            main {
                padding: 2rem 1.5rem;
            }

            .code-block {
                padding: 1rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Chapter 6: Python実践：LAMMPS自動化ワークフロー</h1>
            <p class="subtitle">Python Practice: LAMMPS Automation Workflows</p>
        </header>

        <main>
            <section id="introduction">
                <h2>6.1 PyLAMMPSの基礎</h2>

                <p>PyLAMMPSは、LAMMPSをPythonから直接制御するためのインターフェースです。Pythonの強力なデータ解析・可視化ライブラリ（NumPy、pandas、matplotlib等）と組み合わせることで、シミュレーションの自動化、パラメータスイープ、大規模データ解析を効率的に実行できます。</p>

                <h3>6.1.1 PyLAMMPSのインストールと基本操作</h3>

                <p>PyLAMMPSは、LAMMPSのPythonバインディングとして提供されています。condaまたはソースコンパイルでインストールできます：</p>

                <div class="code-block">
                    <pre><code class="language-bash"># condaでのインストール
conda install -c conda-forge lammps

# またはソースコンパイル（Pythonサポート有効化）
cd lammps/src
make yes-python
make mpi
make install-python</code></pre>
                </div>

                <div class="code-block">
                    <strong>Code Example 1: PyLAMMPS基本操作</strong>
                    <pre><code class="language-python">from lammps import lammps
import numpy as np

# LAMMPSインスタンスの作成
lmp = lammps()

# コマンドの実行（文字列で渡す）
lmp.command('units metal')
lmp.command('atom_style atomic')
lmp.command('lattice fcc 3.615')
lmp.command('region box block 0 10 0 10 0 10')
lmp.command('create_box 1 box')
lmp.command('create_atoms 1 box')
lmp.command('mass 1 63.546')  # Cu

# ポテンシャル設定
lmp.command('pair_style eam/alloy')
lmp.command('pair_coeff * * Cu_u3.eam Cu')

# 初期速度（300 K）
lmp.command('velocity all create 300.0 482736')

# NVTアンサンブル
lmp.command('fix 1 all nvt temp 300.0 300.0 100.0')
lmp.command('timestep 0.001')

# シミュレーション実行
lmp.command('thermo 100')
lmp.command('run 1000')

# データ取得（Pythonから直接アクセス）
natoms = lmp.get_natoms()
temp = lmp.extract_compute('thermo_temp', 0, 0)

print(f"原子数: {natoms}")
print(f"温度: {temp:.2f} K")

# 座標の取得
coords = lmp.gather_atoms('x', 1, 3)  # 3D座標
coords = np.array(coords).reshape(-1, 3)
print(f"座標形状: {coords.shape}")

# LAMMPSインスタンスのクリーンアップ
lmp.close()</code></pre>
                </div>

                <h3>6.1.2 LAMMPSスクリプト vs PyLAMMPS</h3>

                <table>
                    <thead>
                        <tr>
                            <th>機能</th>
                            <th>LAMMPSスクリプト</th>
                            <th>PyLAMMPS</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>実行方法</td>
                            <td><code>lmp -in in.lammps</code></td>
                            <td>Python スクリプト実行</td>
                        </tr>
                        <tr>
                            <td>パラメータ変更</td>
                            <td>変数・ループ機能（制限あり）</td>
                            <td>Pythonの制御構文（柔軟）</td>
                        </tr>
                        <tr>
                            <td>データ取得</td>
                            <td>ファイル出力→後処理</td>
                            <td>リアルタイムアクセス</td>
                        </tr>
                        <tr>
                            <td>可視化</td>
                            <td>外部ツール（OVITO等）</td>
                            <td>matplotlib等で即座可視化</td>
                        </tr>
                        <tr>
                            <td>並列化</td>
                            <td>MPI（LAMMPS内部）</td>
                            <td>MPI + Pythonマルチプロセス</td>
                        </tr>
                        <tr>
                            <td>適用場面</td>
                            <td>単一シミュレーション</td>
                            <td>パラメータスイープ、自動化</td>
                        </tr>
                    </tbody>
                </table>

                <div class="info-box">
                    <strong>PyLAMMPSの利点：</strong>
                    <ul>
                        <li><strong>動的制御</strong>：実行中にパラメータを変更、条件分岐</li>
                        <li><strong>データ解析統合</strong>：NumPy、pandas、scikit-learnとシームレス連携</li>
                        <li><strong>自動化</strong>：複数条件の系統的探索を自動実行</li>
                        <li><strong>再現性</strong>：Pythonスクリプトで全工程を記録</li>
                    </ul>
                </div>
            </section>

            <section id="parameter-sweep">
                <h2>6.2 パラメータスイープ自動化</h2>

                <p>材料設計や物性予測では、温度、圧力、組成などのパラメータを系統的に変化させ、物性の依存性を調べる必要があります。PyLAMMPSを用いることで、このようなパラメータスイープを完全自動化できます。</p>

                <h3>6.2.1 温度スイープによる拡散係数計算</h3>

                <div class="code-block">
                    <strong>Code Example 2: 温度スイープ自動化</strong>
                    <pre><code class="language-python">from lammps import lammps
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

def run_diffusion_simulation(temperature, nsteps=100000):
    """
    指定温度でNVTシミュレーションを実行し、拡散係数を計算

    Parameters:
    -----------
    temperature : float
        温度 [K]
    nsteps : int
        ステップ数

    Returns:
    --------
    D : float
        拡散係数 [cm²/s]
    """
    lmp = lammps(cmdargs=['-screen', 'none'])  # 画面出力を抑制

    # 系の設定（Cu FCC）
    lmp.command('units metal')
    lmp.command('atom_style atomic')
    lmp.command('lattice fcc 3.615')
    lmp.command('region box block 0 10 0 10 0 10')
    lmp.command('create_box 1 box')
    lmp.command('create_atoms 1 box')
    lmp.command('mass 1 63.546')

    # ポテンシャル
    lmp.command('pair_style eam/alloy')
    lmp.command('pair_coeff * * Cu_u3.eam Cu')

    # 初期速度
    lmp.command(f'velocity all create {temperature} 482736')

    # NVTアンサンブル
    lmp.command(f'fix 1 all nvt temp {temperature} {temperature} 100.0')
    lmp.command('timestep 0.001')

    # MSD計算
    lmp.command('compute msd all msd')
    lmp.command('fix msd_output all ave/time 100 1 100 c_msd[4] file msd_{}.dat'.format(int(temperature)))

    # 平衡化
    lmp.command('run 10000')

    # 生成期間
    lmp.command('run {}'.format(nsteps))

    # MSDデータの読み込み
    msd_data = np.loadtxt(f'msd_{int(temperature)}.dat')
    time_steps = msd_data[:, 0]
    msd = msd_data[:, 1]

    # 拡散係数の計算（Einstein関係式）
    # D = <r²> / (6t)
    # 線形フィッティング（後半50%のデータ）
    idx_start = len(msd) // 2
    time_ps = time_steps[idx_start:] * 0.001  # fs → ps
    msd_fit = msd[idx_start:]

    # 線形フィット
    slope, intercept = np.polyfit(time_ps, msd_fit, 1)
    D_angstrom = slope / 6.0  # Ų/ps
    D_cm2s = D_angstrom * 1e-8 * 1e12 / 1e4  # cm²/s変換

    lmp.close()

    return D_cm2s

# 温度スイープ（300 K - 1200 K、100 K刻み）
temperatures = np.arange(300, 1300, 100)
diffusion_coefficients = []

print("温度スイープ開始...")
for T in temperatures:
    print(f"  T = {T} K 実行中...")
    D = run_diffusion_simulation(T, nsteps=50000)
    diffusion_coefficients.append(D)
    print(f"    D = {D:.3e} cm²/s")

# 結果をDataFrameに格納
df = pd.DataFrame({
    'Temperature (K)': temperatures,
    'Diffusion Coefficient (cm²/s)': diffusion_coefficients
})

# CSV保存
df.to_csv('diffusion_vs_temperature.csv', index=False)

# アレニウスプロット
fig, ax = plt.subplots(figsize=(10, 6))
ax.semilogy(1000.0 / temperatures, diffusion_coefficients, 'o-', linewidth=2, markersize=8)
ax.set_xlabel('1000/T (K⁻¹)', fontsize=14)
ax.set_ylabel('Diffusion Coefficient (cm²/s)', fontsize=14)
ax.set_title('Arrhenius Plot: Cu Self-Diffusion', fontsize=16)
ax.grid(True, alpha=0.3)
plt.tight_layout()
plt.savefig('arrhenius_plot.png', dpi=150)
print("\nアレニウスプロット保存: arrhenius_plot.png")</code></pre>
                </div>

                <h3>6.2.2 Arrhenius式による活性化エネルギー推定</h3>

                <p>拡散係数の温度依存性は、Arrhenius式で記述されます：</p>

                <div class="equation">
                    \[
                    D = D_0 \exp\left(-\frac{Q}{RT}\right)
                    \]
                </div>

                <p>ここで、\(D_0\)は頻度因子、\(Q\)は活性化エネルギー、\(R\)は気体定数、\(T\)は温度です。両辺の対数を取ると：</p>

                <div class="equation">
                    \[
                    \ln D = \ln D_0 - \frac{Q}{R} \cdot \frac{1}{T}
                    \]
                </div>

                <p>\(\ln D\)を\(1/T\)に対してプロットすると、傾きから活性化エネルギー\(Q\)を求めることができます。</p>

                <div class="code-block">
                    <strong>Code Example 3: 活性化エネルギーの推定</strong>
                    <pre><code class="language-python">import numpy as np
from scipy.optimize import curve_fit

# Arrhenius式のフィッティング関数
def arrhenius(T, D0, Q):
    """
    Arrhenius式: D = D0 * exp(-Q / (R * T))

    Parameters:
    -----------
    T : ndarray
        温度 [K]
    D0 : float
        頻度因子 [cm²/s]
    Q : float
        活性化エネルギー [kJ/mol]

    Returns:
    --------
    D : ndarray
        拡散係数 [cm²/s]
    """
    R = 8.314  # J/(mol·K)
    return D0 * np.exp(-Q * 1000.0 / (R * T))

# データ読み込み
df = pd.read_csv('diffusion_vs_temperature.csv')
T_data = df['Temperature (K)'].values
D_data = df['Diffusion Coefficient (cm²/s)'].values

# フィッティング
popt, pcov = curve_fit(arrhenius, T_data, D_data, p0=[1e-4, 200.0])
D0_fit, Q_fit = popt
D0_err, Q_err = np.sqrt(np.diag(pcov))

print(f"フィッティング結果:")
print(f"  D0 = {D0_fit:.3e} ± {D0_err:.3e} cm²/s")
print(f"  Q  = {Q_fit:.2f} ± {Q_err:.2f} kJ/mol")

# フィット曲線
T_fit = np.linspace(T_data.min(), T_data.max(), 100)
D_fit = arrhenius(T_fit, D0_fit, Q_fit)

# プロット
fig, ax = plt.subplots(figsize=(10, 6))
ax.semilogy(1000.0 / T_data, D_data, 'o', markersize=10, label='MD Simulation')
ax.semilogy(1000.0 / T_fit, D_fit, '-', linewidth=2,
            label=f'Arrhenius Fit: Q = {Q_fit:.1f} kJ/mol')
ax.set_xlabel('1000/T (K⁻¹)', fontsize=14)
ax.set_ylabel('Diffusion Coefficient (cm²/s)', fontsize=14)
ax.set_title('Activation Energy Estimation', fontsize=16)
ax.legend(fontsize=12)
ax.grid(True, alpha=0.3)
plt.tight_layout()
plt.savefig('activation_energy.png', dpi=150)

# 実験値との比較（Cu自己拡散：Q ≈ 200 kJ/mol）
print(f"\n実験値（Cu自己拡散）: Q ≈ 200 kJ/mol")
print(f"相対誤差: {abs(Q_fit - 200.0) / 200.0 * 100:.1f} %")</code></pre>
                </div>
            </section>

            <section id="mpi-parallel">
                <h2>6.3 MPI並列実行</h2>

                <p>パラメータスイープでは、各条件が独立しているため、並列実行により計算時間を大幅に短縮できます。Pythonのmpi4pyライブラリを用いて、複数のLAMMPSシミュレーションを並列実行します。</p>

                <h3>6.3.1 mpi4pyによる並列パラメータスイープ</h3>

                <div class="code-block">
                    <strong>Code Example 4: MPI並列パラメータスイープ</strong>
                    <pre><code class="language-python">from mpi4py import MPI
from lammps import lammps
import numpy as np

def run_simulation_mpi(temperature):
    """MPI並列でLAMMPSシミュレーションを実行"""
    lmp = lammps(cmdargs=['-screen', 'none'])

    # 系の設定（簡略版）
    lmp.command('units metal')
    lmp.command('atom_style atomic')
    lmp.command('lattice fcc 3.615')
    lmp.command('region box block 0 10 0 10 0 10')
    lmp.command('create_box 1 box')
    lmp.command('create_atoms 1 box')
    lmp.command('mass 1 63.546')
    lmp.command('pair_style eam/alloy')
    lmp.command('pair_coeff * * Cu_u3.eam Cu')

    # 温度設定
    lmp.command(f'velocity all create {temperature} 482736')
    lmp.command(f'fix 1 all nvt temp {temperature} {temperature} 100.0')
    lmp.command('timestep 0.001')

    # MSD計算
    lmp.command('compute msd all msd')

    # 実行
    lmp.command('run 10000')  # 平衡化
    lmp.command('run 50000')  # 生成

    # MSD取得
    msd = lmp.extract_compute('msd', 0, 1)
    msd_value = msd[3]  # <r²>

    lmp.close()

    return msd_value

# MPIの初期化
comm = MPI.COMM_WORLD
rank = comm.Get_rank()
size = comm.Get_size()

# 温度リスト
temperatures = np.arange(300, 1300, 100)

# ランク0がタスクを分配
if rank == 0:
    # タスク分割（各ランクに割り当てる温度）
    tasks_per_rank = np.array_split(temperatures, size)
else:
    tasks_per_rank = None

# 各ランクにタスクを配布
my_tasks = comm.scatter(tasks_per_rank, root=0)

# 各ランクが担当する温度でシミュレーション実行
my_results = []
for T in my_tasks:
    if rank == 0:
        print(f"Rank {rank}: T = {T} K 実行中...")
    msd = run_simulation_mpi(T)
    my_results.append((T, msd))

# 結果を収集
all_results = comm.gather(my_results, root=0)

# ランク0が結果を集約・出力
if rank == 0:
    # 全結果をフラット化
    results_flat = [item for sublist in all_results for item in sublist]
    results_flat.sort(key=lambda x: x[0])  # 温度でソート

    # 拡散係数計算
    df_results = []
    for T, msd in results_flat:
        D = msd / (6.0 * 50000 * 0.001)  # 簡易計算
        D_cm2s = D * 1e-8 * 1e12 / 1e4
        df_results.append({'Temperature': T, 'MSD': msd, 'Diffusion': D_cm2s})

    import pandas as pd
    df = pd.DataFrame(df_results)
    df.to_csv('mpi_results.csv', index=False)
    print("\nMPI並列計算完了!")
    print(df)

# 実行方法：
# mpirun -np 4 python mpi_parameter_sweep.py</code></pre>
                </div>

                <h3>6.3.2 負荷分散とスケーラビリティ</h3>

                <p>MPI並列では、タスク数がプロセス数で割り切れない場合、負荷が不均衡になります。動的負荷分散を実装することで、効率を向上できます：</p>

                <div class="code-block">
                    <strong>Code Example 5: 動的負荷分散</strong>
                    <pre><code class="language-python">from mpi4py import MPI
import numpy as np

def master_worker_pattern(tasks, worker_func):
    """
    マスター・ワーカーパターンによる動的負荷分散

    Parameters:
    -----------
    tasks : list
        タスクのリスト（例：温度のリスト）
    worker_func : callable
        各タスクを実行する関数

    Returns:
    --------
    results : list
        全タスクの結果
    """
    comm = MPI.COMM_WORLD
    rank = comm.Get_rank()
    size = comm.Get_size()

    if rank == 0:
        # マスタープロセス：タスク分配
        results = []
        task_queue = list(tasks)
        active_workers = size - 1
        finished_workers = 0

        # 初期タスク配布（各ワーカーに1タスク）
        for worker_rank in range(1, size):
            if task_queue:
                task = task_queue.pop(0)
                comm.send(task, dest=worker_rank, tag=1)
            else:
                comm.send(None, dest=worker_rank, tag=0)  # タスク終了シグナル

        # ワーカーから結果を受信、新しいタスクを送信
        while finished_workers < active_workers:
            status = MPI.Status()
            result = comm.recv(source=MPI.ANY_SOURCE, tag=MPI.ANY_TAG, status=status)
            worker_rank = status.Get_source()

            if result is not None:
                results.append(result)

            # 次のタスクを送信
            if task_queue:
                task = task_queue.pop(0)
                comm.send(task, dest=worker_rank, tag=1)
            else:
                comm.send(None, dest=worker_rank, tag=0)
                finished_workers += 1

        return results

    else:
        # ワーカープロセス：タスク実行
        while True:
            status = MPI.Status()
            task = comm.recv(source=0, status=status)

            if status.Get_tag() == 0:  # 終了シグナル
                break

            # タスク実行
            result = worker_func(task)
            comm.send(result, dest=0, tag=1)

# 使用例
def simulate_temperature(T):
    """簡略化されたシミュレーション関数"""
    # run_simulation_mpi(T) の代わりに簡易版
    import time
    time.sleep(0.1)  # シミュレーションを模擬
    return (T, np.random.rand() * 1e-5)

if __name__ == '__main__':
    temperatures = np.arange(300, 1300, 50)
    results = master_worker_pattern(temperatures, simulate_temperature)

    if MPI.COMM_WORLD.Get_rank() == 0:
        print(f"全タスク完了: {len(results)} 件")
        for T, D in sorted(results):
            print(f"  T = {T} K, D = {D:.3e}")</code></pre>
                </div>
            </section>

            <section id="ml-integration">
                <h2>6.4 機械学習統合</h2>

                <p>MDシミュレーションで得られた大量のデータを機械学習により解析することで、材料特性の予測モデルを構築できます。</p>

                <h3>6.4.1 特性予測モデルの構築</h3>

                <div class="code-block">
                    <strong>Code Example 6: 機械学習による拡散係数予測</strong>
                    <pre><code class="language-python">import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import r2_score, mean_absolute_error
import matplotlib.pyplot as plt

# データ読み込み
df = pd.read_csv('diffusion_vs_temperature.csv')

# 特徴量とターゲット
# 特徴量：温度、1/T（Arrhenius）
df['1/T'] = 1000.0 / df['Temperature (K)']
df['log_T'] = np.log(df['Temperature (K)'])

X = df[['Temperature (K)', '1/T', 'log_T']].values
y = np.log(df['Diffusion Coefficient (cm²/s)'].values)  # 対数変換

# 訓練・テストデータ分割
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, random_state=42
)

# Random Forest回帰モデル
model = RandomForestRegressor(
    n_estimators=100,
    max_depth=10,
    random_state=42
)

model.fit(X_train, y_train)

# 予測
y_pred_train = model.predict(X_train)
y_pred_test = model.predict(X_test)

# 性能評価
r2_train = r2_score(y_train, y_pred_train)
r2_test = r2_score(y_test, y_pred_test)
mae_test = mean_absolute_error(y_test, y_pred_test)

print(f"訓練データ R²: {r2_train:.4f}")
print(f"テストデータ R²: {r2_test:.4f}")
print(f"テストデータ MAE: {mae_test:.4f}")

# 特徴量重要度
feature_names = ['Temperature', '1/T', 'log(T)']
importances = model.feature_importances_
indices = np.argsort(importances)[::-1]

print("\n特徴量重要度:")
for i in indices:
    print(f"  {feature_names[i]}: {importances[i]:.4f}")

# 予測 vs 実測プロット
fig, axes = plt.subplots(1, 2, figsize=(14, 6))

# 訓練データ
axes[0].scatter(y_train, y_pred_train, alpha=0.6, s=50)
axes[0].plot([y_train.min(), y_train.max()],
             [y_train.min(), y_train.max()], 'r--', lw=2)
axes[0].set_xlabel('Actual log(D)', fontsize=12)
axes[0].set_ylabel('Predicted log(D)', fontsize=12)
axes[0].set_title(f'Training Set (R² = {r2_train:.4f})', fontsize=14)
axes[0].grid(True, alpha=0.3)

# テストデータ
axes[1].scatter(y_test, y_pred_test, alpha=0.6, s=50, color='orange')
axes[1].plot([y_test.min(), y_test.max()],
             [y_test.min(), y_test.max()], 'r--', lw=2)
axes[1].set_xlabel('Actual log(D)', fontsize=12)
axes[1].set_ylabel('Predicted log(D)', fontsize=12)
axes[1].set_title(f'Test Set (R² = {r2_test:.4f})', fontsize=14)
axes[1].grid(True, alpha=0.3)

plt.tight_layout()
plt.savefig('ml_prediction.png', dpi=150)

# モデルの保存
import joblib
joblib.dump(model, 'diffusion_predictor.pkl')
print("\nモデル保存: diffusion_predictor.pkl")</code></pre>
                </div>

                <h3>6.4.2 ハイパーパラメータ最適化</h3>

                <div class="code-block">
                    <strong>Code Example 7: Grid Searchによるハイパーパラメータ最適化</strong>
                    <pre><code class="language-python">from sklearn.model_selection import GridSearchCV
from sklearn.ensemble import RandomForestRegressor

# パラメータグリッド
param_grid = {
    'n_estimators': [50, 100, 200],
    'max_depth': [5, 10, 20, None],
    'min_samples_split': [2, 5, 10],
    'min_samples_leaf': [1, 2, 4]
}

# Grid Search（5-fold交差検証）
grid_search = GridSearchCV(
    RandomForestRegressor(random_state=42),
    param_grid,
    cv=5,
    scoring='r2',
    n_jobs=-1,
    verbose=2
)

grid_search.fit(X_train, y_train)

# 最適パラメータ
print("最適パラメータ:")
for param, value in grid_search.best_params_.items():
    print(f"  {param}: {value}")

print(f"\n最良CV R²スコア: {grid_search.best_score_:.4f}")

# 最適モデルで予測
best_model = grid_search.best_estimator_
y_pred_best = best_model.predict(X_test)
r2_best = r2_score(y_test, y_pred_best)

print(f"テストデータ R² (最適モデル): {r2_best:.4f}")</code></pre>
                </div>
            </section>

            <section id="hpc">
                <h2>6.5 HPC環境での実行</h2>

                <p>大規模なパラメータスイープや長時間シミュレーションは、HPC（High Performance Computing）環境で実行します。ジョブスケジューラ（Slurm、PBS等）を用いてリソースを効率的に管理します。</p>

                <h3>6.5.1 Slurmジョブスクリプト</h3>

                <div class="code-block">
                    <strong>Code Example 8: Slurmジョブスクリプト例</strong>
                    <pre><code class="language-bash">#!/bin/bash
#SBATCH --job-name=lammps_sweep
#SBATCH --output=lammps_%j.out
#SBATCH --error=lammps_%j.err
#SBATCH --nodes=4
#SBATCH --ntasks-per-node=16
#SBATCH --time=24:00:00
#SBATCH --partition=compute

# モジュールロード
module load python/3.9
module load lammps/2023
module load mpi/openmpi

# 仮想環境アクティベート
source ~/myenv/bin/activate

# MPIジョブ実行（64プロセス = 4ノード × 16タスク）
mpirun -np 64 python mpi_parameter_sweep.py

# 結果の後処理
python analyze_results.py

echo "ジョブ完了"</code></pre>
                </div>

                <h3>6.5.2 配列ジョブによるタスク並列化</h3>

                <p>独立したタスクを配列ジョブとして並列実行することで、ジョブスケジューラの負荷を軽減できます：</p>

                <div class="code-block">
                    <pre><code class="language-bash">#!/bin/bash
#SBATCH --job-name=lammps_array
#SBATCH --output=lammps_%A_%a.out
#SBATCH --error=lammps_%A_%a.err
#SBATCH --array=0-9          # 10タスク（温度300-1200 K、100 K刻み）
#SBATCH --ntasks=1
#SBATCH --cpus-per-task=16
#SBATCH --time=02:00:00

# タスクIDから温度を計算
TEMPERATURE=$((300 + 100 * SLURM_ARRAY_TASK_ID))

echo "Task ${SLURM_ARRAY_TASK_ID}: Temperature = ${TEMPERATURE} K"

# Pythonスクリプト実行
python run_single_simulation.py --temperature ${TEMPERATURE} --output result_${TEMPERATURE}K.csv

echo "Task ${SLURM_ARRAY_TASK_ID} 完了"</code></pre>
                </div>
            </section>

            <section id="workflow">
                <h2>6.6 完全自動化ワークフロー</h2>

                <p>実用的な材料設計では、シミュレーション実行から結果解析、可視化、レポート生成までを一貫して自動化する必要があります。</p>

                <h3>6.6.1 End-to-Endパイプライン</h3>

                <div class="mermaid">
                flowchart TD
                    A[パラメータ設定<br/>YAML/JSON] --> B[LAMMPSシミュレーション<br/>PyLAMMPS]
                    B --> C[データ収集<br/>HDF5/CSV]
                    C --> D[統計解析<br/>pandas/NumPy]
                    D --> E[機械学習<br/>scikit-learn]
                    E --> F[可視化<br/>matplotlib]
                    F --> G[レポート生成<br/>Jupyter/HTML]
                    G --> H[データベース保存<br/>SQLite/MongoDB]
                </div>

                <div class="code-block">
                    <strong>Code Example 9: 完全自動化ワークフロー</strong>
                    <pre><code class="language-python">import yaml
import logging
from pathlib import Path
import pandas as pd
import numpy as np
from lammps import lammps
import matplotlib.pyplot as plt
from sklearn.ensemble import RandomForestRegressor
import joblib

# ロギング設定
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('workflow.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

class LAMMPSWorkflow:
    """LAMMPS自動化ワークフローのメインクラス"""

    def __init__(self, config_file):
        """
        Parameters:
        -----------
        config_file : str
            設定ファイルのパス（YAML）
        """
        with open(config_file, 'r') as f:
            self.config = yaml.safe_load(f)

        self.output_dir = Path(self.config['output_dir'])
        self.output_dir.mkdir(exist_ok=True)

        logger.info(f"ワークフロー初期化: {config_file}")

    def run_simulations(self):
        """パラメータスイープ実行"""
        logger.info("シミュレーション開始")

        temperatures = self.config['parameters']['temperatures']
        results = []

        for T in temperatures:
            logger.info(f"  温度 {T} K 実行中...")
            try:
                result = self._run_single_simulation(T)
                results.append(result)
                logger.info(f"    完了: D = {result['diffusion']:.3e}")
            except Exception as e:
                logger.error(f"    エラー: {e}")
                continue

        # 結果保存
        df = pd.DataFrame(results)
        csv_path = self.output_dir / 'simulation_results.csv'
        df.to_csv(csv_path, index=False)
        logger.info(f"結果保存: {csv_path}")

        return df

    def _run_single_simulation(self, temperature):
        """単一温度でのシミュレーション"""
        lmp = lammps(cmdargs=['-screen', 'none'])

        # LAMMPSコマンド（簡略版）
        lmp.command('units metal')
        lmp.command('atom_style atomic')
        lmp.command('lattice fcc 3.615')
        lmp.command('region box block 0 10 0 10 0 10')
        lmp.command('create_box 1 box')
        lmp.command('create_atoms 1 box')
        lmp.command('mass 1 63.546')
        lmp.command('pair_style eam/alloy')
        lmp.command('pair_coeff * * Cu_u3.eam Cu')
        lmp.command(f'velocity all create {temperature} 482736')
        lmp.command(f'fix 1 all nvt temp {temperature} {temperature} 100.0')
        lmp.command('timestep 0.001')
        lmp.command('compute msd all msd')
        lmp.command('run 10000')  # 平衡化
        lmp.command('run 50000')  # 生成

        # MSD取得
        msd = lmp.extract_compute('msd', 0, 1)[3]
        D = msd / (6.0 * 50000 * 0.001) * 1e-8 * 1e12 / 1e4

        lmp.close()

        return {'temperature': temperature, 'msd': msd, 'diffusion': D}

    def analyze_data(self, df):
        """データ解析"""
        logger.info("データ解析開始")

        # Arrheniusフィット
        from scipy.optimize import curve_fit

        def arrhenius(T, D0, Q):
            R = 8.314
            return D0 * np.exp(-Q * 1000.0 / (R * T))

        T_data = df['temperature'].values
        D_data = df['diffusion'].values

        popt, _ = curve_fit(arrhenius, T_data, D_data, p0=[1e-4, 200.0])
        D0, Q = popt

        logger.info(f"  D0 = {D0:.3e} cm²/s")
        logger.info(f"  Q  = {Q:.2f} kJ/mol")

        return {'D0': D0, 'Q': Q}

    def train_ml_model(self, df):
        """機械学習モデル訓練"""
        logger.info("ML モデル訓練開始")

        df['1/T'] = 1000.0 / df['temperature']
        X = df[['temperature', '1/T']].values
        y = np.log(df['diffusion'].values)

        model = RandomForestRegressor(n_estimators=100, random_state=42)
        model.fit(X, y)

        model_path = self.output_dir / 'ml_model.pkl'
        joblib.dump(model, model_path)
        logger.info(f"モデル保存: {model_path}")

        return model

    def visualize(self, df, analysis_results):
        """可視化"""
        logger.info("可視化開始")

        fig, ax = plt.subplots(figsize=(10, 6))
        ax.semilogy(1000.0 / df['temperature'], df['diffusion'], 'o', markersize=10)
        ax.set_xlabel('1000/T (K⁻¹)', fontsize=14)
        ax.set_ylabel('Diffusion Coefficient (cm²/s)', fontsize=14)
        ax.set_title(f"Arrhenius Plot (Q = {analysis_results['Q']:.1f} kJ/mol)", fontsize=16)
        ax.grid(True, alpha=0.3)

        plot_path = self.output_dir / 'arrhenius_plot.png'
        plt.savefig(plot_path, dpi=150)
        logger.info(f"プロット保存: {plot_path}")

    def run(self):
        """ワークフロー全体を実行"""
        logger.info("=== ワークフロー実行開始 ===")

        # 1. シミュレーション実行
        df = self.run_simulations()

        # 2. データ解析
        analysis_results = self.analyze_data(df)

        # 3. ML モデル訓練
        model = self.train_ml_model(df)

        # 4. 可視化
        self.visualize(df, analysis_results)

        logger.info("=== ワークフロー完了 ===")

        return df, analysis_results, model

# 設定ファイル例（config.yaml）
config_example = """
output_dir: ./results
parameters:
  temperatures: [300, 400, 500, 600, 700, 800, 900, 1000, 1100, 1200]
  nsteps: 50000
simulation:
  lattice: fcc
  lattice_constant: 3.615
  potential: Cu_u3.eam
"""

# 実行例
if __name__ == '__main__':
    # 設定ファイル作成
    with open('config.yaml', 'w') as f:
        f.write(config_example)

    # ワークフロー実行
    workflow = LAMMPSWorkflow('config.yaml')
    df, analysis, model = workflow.run()

    print("\n=== 最終結果 ===")
    print(f"活性化エネルギー: {analysis['Q']:.2f} kJ/mol")
    print(f"データ件数: {len(df)}")</code></pre>
                </div>
            </section>

            <section id="exercises">
                <h2>演習問題</h2>

                <div class="exercise">
                    <h4>Exercise 1: PyLAMMPSでのNVTシミュレーション自動化（Easy）</h4>
                    <p><strong>問題：</strong> PyLAMMPSを用いて、Ar液体（密度1.374 g/cm³、温度94.4 K）のNVTシミュレーションを実行し、温度の時間発展をプロットしてください。100 psのシミュレーション中、温度が94.4 ± 2 K以内に安定することを確認してください。</p>

                    <details>
                        <summary><strong>解答例</strong>（クリックで表示）</summary>
                        <div class="code-block">
                            <pre><code class="language-python"># 解答は省略：PyLAMMPS初期化、Ar系設定（LJポテンシャル）、NVT実行、
# thermo_temp抽出、matplotlibプロット、94.4±2K範囲確認</code></pre>
                        </div>
                    </details>
                </div>

                <div class="exercise">
                    <h4>Exercise 2: 複数温度での拡散係数計算と自動プロット（Medium）</h4>
                    <p><strong>問題：</strong> Cu FCC結晶について、温度500, 700, 900, 1100 Kの4条件でNVTシミュレーションを実行し、各温度での拡散係数をEinstein関係式（MSD法）により計算してください。Arrheniusプロット（log D vs 1/T）を作成し、活性化エネルギーを推定してください。実験値（Cu自己拡散：Q ≈ 200 kJ/mol）と比較し、誤差を評価してください。</p>

                    <details>
                        <summary><strong>解答例</strong>（クリックで表示）</summary>
                        <p>（解答は省略：4温度ループ、各温度でMSD計算、Einstein式でD算出、Arrheniusプロット作成、線形フィットでQ推定、実験値比較、誤差評価）</p>
                    </details>
                </div>

                <div class="exercise">
                    <h4>Exercise 3: ML統合による材料特性予測パイプライン（Hard）</h4>
                    <p><strong>問題：</strong> 複数の金属（Cu, Ag, Au, Ni, Al）について、温度300-1200 Kで拡散係数を計算し、機械学習モデル（Random Forest）を訓練してください。特徴量として、温度、原子量、融点、格子定数を使用し、拡散係数を予測してください。5-fold交差検証でモデル性能を評価し、R²スコアが0.9以上となるようハイパーパラメータを最適化してください。さらに、未知の金属（Pt）について拡散係数を予測し、実際のシミュレーション結果と比較してください。</p>

                    <details>
                        <summary><strong>解答例</strong>（クリックで表示）</summary>
                        <p>（解答は省略：5金属×10温度のデータ生成、特徴量エンジニアリング、Random Forestモデル、GridSearchCV、5-fold CV、R²評価、Pt予測、実測比較、誤差評価）</p>
                    </details>
                </div>
            </section>

            <section id="learning-objectives">
                <h2>学習目標の確認</h2>

                <div class="learning-objectives">
                    <h3>Chapter 6の学習目標</h3>
                    <p>以下の項目について、自己評価を行ってください。各項目について、「理解できた」「概ね理解」「要復習」の3段階で評価しましょう。</p>

                    <h4>レベル1：基本理解</h4>
                    <ol>
                        <li>PyLAMMPSの基本的な使用法を説明できる</li>
                        <li>LAMMPSスクリプトとPyLAMMPSの違いを理解している</li>
                        <li>パラメータスイープの利点と用途を説明できる</li>
                        <li>MPI並列化の基本概念を理解している</li>
                        <li>機械学習とMDシミュレーションの統合の意義を説明できる</li>
                    </ol>

                    <h4>レベル2：実践スキル</h4>
                    <ol start="6">
                        <li>PyLAMMPSでNVT/NPTシミュレーションを実行できる</li>
                        <li>温度・密度スイープを自動化できる</li>
                        <li>シミュレーション結果をpandas DataFrameに格納・解析できる</li>
                        <li>mpi4pyを用いて並列パラメータスイープを実装できる</li>
                        <li>scikit-learnで材料特性予測モデルを構築できる</li>
                    </ol>

                    <h4>レベル3：応用力</h4>
                    <ol start="11">
                        <li>Arrheniusプロットから活性化エネルギーを推定できる</li>
                        <li>動的負荷分散を実装し、並列効率を最適化できる</li>
                        <li>Grid SearchでMLモデルのハイパーパラメータを最適化できる</li>
                        <li>HPC環境でSlurmジョブスクリプトを作成・実行できる</li>
                        <li>End-to-Endの自動化ワークフロー（シミュレーション→解析→ML→可視化）を構築できる</li>
                    </ol>
                </div>
            </section>

            <section id="references">
                <h2>参考文献</h2>
                <ol>
                    <li>LAMMPS Documentation (2025). <em>Python Interface to LAMMPS</em>, Sandia National Laboratories, <a href="https://docs.lammps.org/Python_head.html" target="_blank">https://docs.lammps.org/Python_head.html</a>, pp. 1-25.</li>
                    <li>Dalcín, L., et al. (2011). "Parallel distributed computing using Python," <em>Advances in Water Resources</em>, 34(9), 1124-1139.</li>
                    <li>Pedregosa, F., et al. (2011). "Scikit-learn: Machine Learning in Python," <em>Journal of Machine Learning Research</em>, 12, 2825-2830.</li>
                    <li>McKinney, W. (2017). <em>Python for Data Analysis</em>, 2nd ed., O'Reilly Media, pp. 125-250.</li>
                    <li>Rapaport, D.C. (2004). <em>The Art of Molecular Dynamics Simulation</em>, 2nd ed., Cambridge University Press, pp. 370-420.</li>
                    <li>Curtarolo, S., et al. (2013). "The high-throughput highway to computational materials design," <em>Nature Materials</em>, 12, 191-201.</li>
                    <li>Himanen, L., et al. (2019). "DScribe: Library of descriptors for machine learning in materials science," <em>Computer Physics Communications</em>, 247, 106949, pp. 1-15.</li>
                </ol>
            </section>
        </main>
    </div>

    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            }
        };

        mermaid.initialize({ startOnLoad: true, theme: 'default' });

        document.addEventListener('DOMContentLoaded', function() {
            mermaid.init(undefined, document.querySelectorAll('.mermaid'));
        });
    </script>
</body>
</html>