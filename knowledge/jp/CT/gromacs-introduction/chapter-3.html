<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 3: å¹³è¡¡åŒ–ã¨ãƒ—ãƒ­ãƒ€ã‚¯ã‚·ãƒ§ãƒ³MD - GROMACSå…¥é–€</title>

    <!-- MathJax 3.x -->
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <!-- Mermaid -->
    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>

    <!-- Prism.js -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>

    <style>
        :root {
            --ct-gradient-start: #11998e;
            --ct-gradient-end: #38ef7d;
            --text-primary: #2c3e50;
            --text-secondary: #546e7a;
            --bg-light: #f8f9fa;
            --border-color: #e0e0e0;
            --code-bg: #1e1e1e;
            --shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            line-height: 1.8;
            color: var(--text-primary);
            background: linear-gradient(135deg, var(--ct-gradient-start), var(--ct-gradient-end));
            min-height: 100vh;
            padding: 2rem 1rem;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            background: white;
            padding: 3rem;
            border-radius: 16px;
            box-shadow: var(--shadow);
        }

        h1, h2, h3 {
            background: linear-gradient(135deg, var(--ct-gradient-start), var(--ct-gradient-end));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin: 2rem 0 1rem 0;
        }

        h1 { font-size: 2.5rem; border-bottom: 3px solid var(--ct-gradient-end); padding-bottom: 0.5rem; }
        h2 { font-size: 2rem; margin-top: 3rem; }
        h3 { font-size: 1.5rem; margin-top: 2rem; }

        p { margin: 1rem 0; color: var(--text-secondary); }

        pre {
            background: var(--code-bg);
            padding: 1.5rem;
            border-radius: 8px;
            overflow-x: auto;
            margin: 1.5rem 0;
            box-shadow: var(--shadow);
        }

        code {
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.9rem;
        }

        .info-box {
            background: linear-gradient(135deg, rgba(17,153,142,0.1), rgba(56,239,125,0.1));
            border-left: 4px solid var(--ct-gradient-start);
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-radius: 0 8px 8px 0;
        }

        .warning-box {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-radius: 0 8px 8px 0;
        }

        .mermaid {
            background: white;
            padding: 2rem;
            border-radius: 8px;
            margin: 2rem 0;
            box-shadow: var(--shadow);
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 2rem 0;
            box-shadow: var(--shadow);
            border-radius: 8px;
            overflow: hidden;
        }

        th, td {
            padding: 1rem;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
        }

        th {
            background: linear-gradient(135deg, var(--ct-gradient-start), var(--ct-gradient-end));
            color: white;
            font-weight: 600;
        }

        tr:hover {
            background: var(--bg-light);
        }

        .nav-buttons {
            display: flex;
            justify-content: space-between;
            margin-top: 3rem;
            padding-top: 2rem;
            border-top: 2px solid var(--border-color);
        }

        .btn {
            padding: 0.8rem 2rem;
            background: linear-gradient(135deg, var(--ct-gradient-start), var(--ct-gradient-end));
            color: white;
            text-decoration: none;
            border-radius: 8px;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: var(--shadow);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }

        @media (max-width: 768px) {
            .container { padding: 1.5rem; }
            h1 { font-size: 2rem; }
            h2 { font-size: 1.5rem; }
            table { font-size: 0.9rem; }
            .nav-buttons { flex-direction: column; gap: 1rem; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Chapter 3: å¹³è¡¡åŒ–ã¨ãƒ—ãƒ­ãƒ€ã‚¯ã‚·ãƒ§ãƒ³MD</h1>

        <div class="info-box">
            <strong>å­¦ç¿’ç›®æ¨™</strong>
            <ul>
                <li>ã‚¨ãƒãƒ«ã‚®ãƒ¼æœ€å°åŒ–ï¼ˆEMï¼‰ã®åŸç†ã¨å®Ÿè·µæ–¹æ³•ã‚’ç†è§£ã™ã‚‹</li>
                <li>NVTãƒ»NPTå¹³è¡¡åŒ–ã®ç›®çš„ã¨æ‰‹é †ã‚’ç¿’å¾—ã™ã‚‹</li>
                <li>ãƒ—ãƒ­ãƒ€ã‚¯ã‚·ãƒ§ãƒ³MDã®è¨­å®šã¨å®Ÿè¡Œã‚’å­¦ã¶</li>
                <li>Pythonã«ã‚ˆã‚‹å¹³è¡¡åŒ–å“è³ªã®è©•ä¾¡æ‰‹æ³•ã‚’ç¿’å¾—ã™ã‚‹</li>
            </ul>
        </div>

        <h2>3.1 ã‚¨ãƒãƒ«ã‚®ãƒ¼æœ€å°åŒ–ï¼ˆEMï¼‰ã®å¿…è¦æ€§</h2>

        <p>
        åˆ†å­å‹•åŠ›å­¦ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å‰ã«ã¯å¿…ãš<strong>ã‚¨ãƒãƒ«ã‚®ãƒ¼æœ€å°åŒ–ï¼ˆEnergy Minimization, EMï¼‰</strong>ãŒå¿…è¦ã§ã™ã€‚
        PDBã‹ã‚‰æ§‹ç¯‰ã—ãŸåˆæœŸæ§‹é€ ã«ã¯åŸå­é–“ã®è·é›¢ãŒä¸è‡ªç„¶ã«è¿‘ã„ç®‡æ‰€ï¼ˆã‚¹ãƒ†ãƒªãƒƒã‚¯ã‚¯ãƒ©ãƒƒã‚·ãƒ¥ï¼‰ã‚„ã€
        æ°´åˆ†å­ãƒ»ã‚¤ã‚ªãƒ³ã®é…ç½®ãŒæœ€é©ã§ãªã„ç®‡æ‰€ãŒå­˜åœ¨ã™ã‚‹ãŸã‚ã§ã™ã€‚
        </p>

        <p>
        EMã§ã¯ãƒãƒ†ãƒ³ã‚·ãƒ£ãƒ«ã‚¨ãƒãƒ«ã‚®ãƒ¼ \( V \) ã‚’æœ€å°åŒ–ã™ã‚‹ã“ã¨ã§ã€ç³»ã‚’åŠ›å­¦çš„ã«å®‰å®šãªçŠ¶æ…‹ã«å°ãã¾ã™ï¼š
        </p>

        <p>
        \[
        V(\mathbf{r}_1, \mathbf{r}_2, \ldots, \mathbf{r}_N) \to \min
        \]
        </p>

        <p>
        GROMACSã§ã¯<strong>Steepest Descentæ³•</strong>ï¼ˆSDï¼‰ã¨<strong>Conjugate Gradientæ³•</strong>ï¼ˆCGï¼‰ã®2ã¤ã®æœ€å°åŒ–ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ãŒä¸»ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚
        </p>

        <table>
            <thead>
                <tr>
                    <th>ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ </th>
                    <th>ç‰¹å¾´</th>
                    <th>é©ç”¨å ´é¢</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Steepest Descent (SD)</td>
                    <td>å˜ç´”ã€ãƒ­ãƒã‚¹ãƒˆã€åˆæœŸåæŸé€Ÿã„</td>
                    <td>åˆæœŸæ§‹é€ ã®ç²—ã„æœ€é©åŒ–</td>
                </tr>
                <tr>
                    <td>Conjugate Gradient (CG)</td>
                    <td>é«˜ç²¾åº¦ã€åæŸé€Ÿåº¦é€Ÿã„ï¼ˆå¾ŒåŠï¼‰</td>
                    <td>SDå¾Œã®ç²¾å¯†æœ€é©åŒ–</td>
                </tr>
            </tbody>
        </table>

        <h3>3.1.1 Steepest Descentæ³•ã®mdpãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿</h3>

        <pre><code class="language-bash">; em_steep.mdp - Steepest Descent Energy Minimization
integrator               = steep
nsteps                   = 50000
emtol                    = 1000.0         ; åæŸåˆ¤å®š: Fmax < 1000 kJ/mol/nm
emstep                   = 0.01           ; åˆæœŸã‚¹ãƒ†ãƒƒãƒ—ã‚µã‚¤ã‚º (nm)

; Neighbor searching
cutoff-scheme            = Verlet
nstlist                  = 10
ns_type                  = grid
pbc                      = xyz

; Electrostatics
coulombtype              = PME
rcoulomb                 = 1.0

; van der Waals
vdwtype                  = Cut-off
rvdw                     = 1.0

; Output control
nstxout                  = 0
nstvout                  = 0
nstenergy                = 500
nstlog                   = 500</code></pre>

        <div class="warning-box">
            <strong>âš ï¸ åæŸåˆ¤å®šã®é‡è¦æ€§</strong><br>
            <code>emtol = 1000.0</code>ã¯æœ€å¤§åŠ›ãŒ1000 kJ/mol/nmæœªæº€ã«ãªã‚‹ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚
            ã‚¿ãƒ³ãƒ‘ã‚¯è³ªç³»ã§ã¯é€šå¸¸10ã€œ1000ç¨‹åº¦ã§åæŸã—ã¾ã™ãŒã€è†œç³»ã‚„ãƒªã‚¬ãƒ³ãƒ‰çµåˆç³»ã§ã¯å³ã—ã„åŸºæº–ï¼ˆ10ã€œ100ï¼‰ãŒå¿…è¦ãªå ´åˆãŒã‚ã‚Šã¾ã™ã€‚
        </div>

        <h3>3.1.2 ã‚¨ãƒãƒ«ã‚®ãƒ¼æœ€å°åŒ–ã®å®Ÿè¡Œã¨ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°</h3>

        <pre><code class="language-bash"># EMã®å®Ÿè¡Œ
gmx grompp -f em_steep.mdp -c solvated_ions.gro -p topol.top -o em.tpr
gmx mdrun -v -deffnm em

# ã‚¨ãƒãƒ«ã‚®ãƒ¼æŠ½å‡º
echo "10 0" | gmx energy -f em.edr -o potential.xvg

# çµæœç¢ºèª
tail em.log
# Expected output:
# Steepest Descents converged to Fmax < 1000 in 1234 steps
# Potential Energy  = -8.1234567e+05
# Maximum force     =  9.8765432e+02 on atom 4567</code></pre>

        <h3>3.1.3 Pythonã«ã‚ˆã‚‹ã‚¨ãƒãƒ«ã‚®ãƒ¼åæŸãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°</h3>

        <pre><code class="language-python">#!/usr/bin/env python3
"""
ã‚¨ãƒãƒ«ã‚®ãƒ¼æœ€å°åŒ–ã®åæŸãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°
- Potential energyã®æ¨ç§»ã‚’ãƒ—ãƒ­ãƒƒãƒˆ
- åæŸåˆ¤å®šï¼ˆFmax < emtolï¼‰ã®ç¢ºèª
"""
import numpy as np
import matplotlib.pyplot as plt
import re

def parse_energy_log(log_file):
    """
    GROMACSãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ã‚¨ãƒãƒ«ã‚®ãƒ¼ã¨æœ€å¤§åŠ›ã‚’æŠ½å‡º
    """
    steps = []
    energies = []
    fmax_values = []

    with open(log_file, 'r') as f:
        for line in f:
            # "Step= 100  Time= 0.100  Lambda= 0.00000" å½¢å¼
            step_match = re.search(r'Step=\s+(\d+)', line)
            if step_match:
                steps.append(int(step_match.group(1)))

            # "Potential Energy  = -1.2345e+05" å½¢å¼
            energy_match = re.search(r'Potential Energy\s+=\s+([-\d.e+]+)', line)
            if energy_match:
                energies.append(float(energy_match.group(1)))

            # "Maximum force     =  1.234e+03" å½¢å¼
            fmax_match = re.search(r'Maximum force\s+=\s+([-\d.e+]+)', line)
            if fmax_match:
                fmax_values.append(float(fmax_match.group(1)))

    return np.array(steps), np.array(energies), np.array(fmax_values)

def plot_em_convergence(log_file, emtol=1000.0, output='em_convergence.png'):
    """
    ã‚¨ãƒãƒ«ã‚®ãƒ¼æœ€å°åŒ–ã®åæŸã‚’ãƒ—ãƒ­ãƒƒãƒˆ
    """
    steps, energies, fmax = parse_energy_log(log_file)

    fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(10, 8), sharex=True)

    # Potential energy
    ax1.plot(steps, energies, 'b-', linewidth=2, label='Potential Energy')
    ax1.set_ylabel('Potential Energy (kJ/mol)', fontsize=12)
    ax1.legend()
    ax1.grid(True, alpha=0.3)

    # Maximum force
    ax2.plot(steps, fmax, 'r-', linewidth=2, label='Maximum Force')
    ax2.axhline(y=emtol, color='g', linestyle='--', linewidth=2,
                label=f'emtol = {emtol} kJ/mol/nm')
    ax2.set_xlabel('Step', fontsize=12)
    ax2.set_ylabel('Maximum Force (kJ/mol/nm)', fontsize=12)
    ax2.set_yscale('log')
    ax2.legend()
    ax2.grid(True, alpha=0.3)

    plt.tight_layout()
    plt.savefig(output, dpi=300, bbox_inches='tight')
    print(f"âœ… åæŸãƒ—ãƒ­ãƒƒãƒˆä¿å­˜: {output}")

    # æœ€çµ‚å€¤ã®å ±å‘Š
    final_energy = energies[-1]
    final_fmax = fmax[-1]
    converged = final_fmax < emtol

    print(f"\nğŸ“Š ã‚¨ãƒãƒ«ã‚®ãƒ¼æœ€å°åŒ–çµæœ:")
    print(f"   æœ€çµ‚ã‚¹ãƒ†ãƒƒãƒ—: {steps[-1]}")
    print(f"   æœ€çµ‚ã‚¨ãƒãƒ«ã‚®ãƒ¼: {final_energy:.2e} kJ/mol")
    print(f"   æœ€å¤§åŠ›: {final_fmax:.2e} kJ/mol/nm")
    print(f"   åæŸåˆ¤å®š: {'âœ… æˆåŠŸ' if converged else 'âŒ å¤±æ•—'}")

if __name__ == "__main__":
    import sys

    if len(sys.argv) < 2:
        print("Usage: python em_monitor.py em.log [emtol]")
        sys.exit(1)

    log_file = sys.argv[1]
    emtol = float(sys.argv[2]) if len(sys.argv) > 2 else 1000.0

    plot_em_convergence(log_file, emtol)</code></pre>

        <div class="mermaid">
flowchart TD
    A[åˆæœŸæ§‹é€ <br/>solvated_ions.gro] --> B[EMæº–å‚™<br/>grompp]
    B --> C[Steepest Descent<br/>50,000 steps]
    C --> D{Fmax < emtol?}
    D -->|Yes| E[åæŸæˆåŠŸ<br/>em.gro]
    D -->|No| F[Conjugate Gradient<br/>è¿½åŠ æœ€é©åŒ–]
    F --> E
    E --> G[NVTå¹³è¡¡åŒ–ã¸]
        </div>

        <h2>3.2 NVTå¹³è¡¡åŒ–ï¼ˆæ¸©åº¦å¹³è¡¡åŒ–ï¼‰</h2>

        <p>
        ã‚¨ãƒãƒ«ã‚®ãƒ¼æœ€å°åŒ–å¾Œã€ç³»ã‚’ç›®çš„æ¸©åº¦ï¼ˆé€šå¸¸300 Kï¼‰ã¾ã§åŠ ç†±ã™ã‚‹<strong>NVTå¹³è¡¡åŒ–</strong>ã‚’è¡Œã„ã¾ã™ã€‚
        NVTã‚¢ãƒ³ã‚µãƒ³ãƒ–ãƒ«ã§ã¯ç²’å­æ•°ï¼ˆNï¼‰ã€ä½“ç©ï¼ˆVï¼‰ã€æ¸©åº¦ï¼ˆTï¼‰ã‚’ä¸€å®šã«ä¿ã¡ã¾ã™ã€‚
        </p>

        <p>
        GROMACSã§ã¯<strong>V-rescaleç†±æµ´</strong>ãŒæ¨™æº–çš„ã«ä½¿ç”¨ã•ã‚Œã¾ã™ï¼ˆBerendsenç†±æµ´ã‚ˆã‚Šçµ±è¨ˆåŠ›å­¦çš„ã«æ­£ç¢ºï¼‰ï¼š
        </p>

        <p>
        \[
        \frac{dT}{dt} = \frac{T_0 - T}{\tau_T} + \text{noise}
        \]
        </p>

        <p>
        ã“ã“ã§ \( T_0 \) ã¯ç›®æ¨™æ¸©åº¦ã€\( \tau_T \) ã¯æ¸©åº¦ç·©å’Œæ™‚é–“ã§ã™ã€‚
        </p>

        <h3>3.2.1 NVTå¹³è¡¡åŒ–ã®mdpãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿</h3>

        <pre><code class="language-bash">; nvt.mdp - NVT Equilibration (100 ps)
define                   = -DPOSRES       ; ã‚¿ãƒ³ãƒ‘ã‚¯è³ªä½ç½®æ‹˜æŸ
integrator               = md
dt                       = 0.002          ; 2 fs
nsteps                   = 50000          ; 100 ps (50000 * 2 fs)
nstlog                   = 5000
nstenergy                = 5000
nstxout-compressed       = 5000

; Neighbor searching
cutoff-scheme            = Verlet
nstlist                  = 10
pbc                      = xyz

; Electrostatics
coulombtype              = PME
rcoulomb                 = 1.0
pme_order                = 4
fourierspacing           = 0.16

; van der Waals
vdwtype                  = Cut-off
rvdw                     = 1.0
DispCorr                 = EnerPres

; Temperature coupling (V-rescale)
tcoupl                   = V-rescale
tc-grps                  = Protein Non-Protein
tau_t                    = 0.1    0.1
ref_t                    = 300    300

; Pressure coupling
pcoupl                   = no

; Velocity generation
gen_vel                  = yes
gen_temp                 = 300
gen_seed                 = -1           ; ãƒ©ãƒ³ãƒ€ãƒ ã‚·ãƒ¼ãƒ‰

; Constraints
constraints              = h-bonds
constraint_algorithm     = lincs
lincs_iter               = 1
lincs_order              = 4</code></pre>

        <div class="info-box">
            <strong>ğŸ’¡ ä½ç½®æ‹˜æŸï¼ˆPOSRESï¼‰ã®å½¹å‰²</strong><br>
            <code>define = -DPOSRES</code>ã«ã‚ˆã‚Šã€ã‚¿ãƒ³ãƒ‘ã‚¯è³ªã®é‡åŸå­ï¼ˆbackboneï¼‰ã‚’å¼±ã„èª¿å’Œãƒãƒ†ãƒ³ã‚·ãƒ£ãƒ«ã§æ‹˜æŸã—ã¾ã™ã€‚
            ã“ã‚Œã«ã‚ˆã‚Šã€æ°´åˆ†å­ãƒ»ã‚¤ã‚ªãƒ³ãŒè‡ªç”±ã«å‹•ãä¸€æ–¹ã§ã€ã‚¿ãƒ³ãƒ‘ã‚¯è³ªæ§‹é€ ã®æ€¥æ¿€ãªå¤‰åŒ–ã‚’é˜²ãã¾ã™ã€‚
            æ‹˜æŸå¼·åº¦ã¯<code>posre.itp</code>ã§å®šç¾©ã•ã‚Œã€é€šå¸¸1000 kJ/mol/nmÂ²ãŒä½¿ç”¨ã•ã‚Œã¾ã™ã€‚
        </div>

        <h3>3.2.2 NVTå¹³è¡¡åŒ–ã®å®Ÿè¡Œ</h3>

        <pre><code class="language-bash"># NVTå¹³è¡¡åŒ–ã®å®Ÿè¡Œ
gmx grompp -f nvt.mdp -c em.gro -r em.gro -p topol.top -o nvt.tpr
gmx mdrun -deffnm nvt

# æ¸©åº¦æŠ½å‡º
echo "16 0" | gmx energy -f nvt.edr -o temperature.xvg</code></pre>

        <h3>3.2.3 Pythonã«ã‚ˆã‚‹æ¸©åº¦å¹³è¡¡åŒ–ã®è©•ä¾¡</h3>

        <pre><code class="language-python">#!/usr/bin/env python3
"""
NVTå¹³è¡¡åŒ–ã®å“è³ªè©•ä¾¡
- æ¸©åº¦ã®æ™‚é–“ç™ºå±•ã¨å®‰å®šæ€§ã‚’è©•ä¾¡
- ãƒ–ãƒ­ãƒƒã‚¯å¹³å‡ã«ã‚ˆã‚‹çµ±è¨ˆèª¤å·®æ¨å®š
"""
import numpy as np
import matplotlib.pyplot as plt
from scipy import stats

def parse_xvg(xvg_file):
    """
    GROMACSã®XVGãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ‘ãƒ¼ã‚¹
    """
    time = []
    values = []

    with open(xvg_file, 'r') as f:
        for line in f:
            if line.startswith('#') or line.startswith('@'):
                continue
            parts = line.split()
            if len(parts) >= 2:
                time.append(float(parts[0]))
                values.append(float(parts[1]))

    return np.array(time), np.array(values)

def block_average(data, block_size=10):
    """
    ãƒ–ãƒ­ãƒƒã‚¯å¹³å‡ã«ã‚ˆã‚‹çµ±è¨ˆèª¤å·®æ¨å®š
    """
    n_blocks = len(data) // block_size
    blocks = data[:n_blocks * block_size].reshape(n_blocks, block_size)
    block_means = blocks.mean(axis=1)

    overall_mean = block_means.mean()
    block_std = block_means.std(ddof=1)
    sem = block_std / np.sqrt(n_blocks)

    return overall_mean, sem

def analyze_nvt_equilibration(xvg_file, target_temp=300.0,
                               equilibration_time=50.0, output='nvt_analysis.png'):
    """
    NVTå¹³è¡¡åŒ–ã®å“è³ªã‚’è©•ä¾¡

    Parameters
    ----------
    xvg_file : str
        temperature.xvgãƒ•ã‚¡ã‚¤ãƒ«
    target_temp : float
        ç›®æ¨™æ¸©åº¦ (K)
    equilibration_time : float
        å¹³è¡¡åŒ–ã«ä½¿ã†æ™‚é–“ (ps)ã€ã“ã‚Œä»¥é™ã®ãƒ‡ãƒ¼ã‚¿ã§çµ±è¨ˆè§£æ
    """
    time, temp = parse_xvg(xvg_file)

    # å¹³è¡¡åŒ–æœŸé–“ã¨è§£ææœŸé–“ã‚’åˆ†é›¢
    equil_mask = time < equilibration_time
    analysis_mask = time >= equilibration_time

    equil_time = time[equil_mask]
    equil_temp = temp[equil_mask]

    analysis_time = time[analysis_mask]
    analysis_temp = temp[analysis_mask]

    # çµ±è¨ˆè§£æ
    mean_temp, sem = block_average(analysis_temp, block_size=10)

    # ãƒ—ãƒ­ãƒƒãƒˆ
    fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 8))

    # æ™‚é–“ç™ºå±•
    ax1.plot(equil_time, equil_temp, 'b-', alpha=0.5, label='Equilibration')
    ax1.plot(analysis_time, analysis_temp, 'g-', alpha=0.5, label='Production')
    ax1.axhline(y=target_temp, color='r', linestyle='--', linewidth=2,
                label=f'Target: {target_temp} K')
    ax1.axhline(y=mean_temp, color='purple', linestyle='--', linewidth=2,
                label=f'Mean: {mean_temp:.2f} Â± {sem:.2f} K')
    ax1.axvline(x=equilibration_time, color='gray', linestyle=':', linewidth=2)
    ax1.set_xlabel('Time (ps)', fontsize=12)
    ax1.set_ylabel('Temperature (K)', fontsize=12)
    ax1.legend()
    ax1.grid(True, alpha=0.3)
    ax1.set_title('NVT Equilibration: Temperature vs Time', fontsize=14, fontweight='bold')

    # ãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ 
    ax2.hist(analysis_temp, bins=30, alpha=0.7, color='green', edgecolor='black')
    ax2.axvline(x=target_temp, color='r', linestyle='--', linewidth=2,
                label=f'Target: {target_temp} K')
    ax2.axvline(x=mean_temp, color='purple', linestyle='--', linewidth=2,
                label=f'Mean: {mean_temp:.2f} K')
    ax2.set_xlabel('Temperature (K)', fontsize=12)
    ax2.set_ylabel('Frequency', fontsize=12)
    ax2.legend()
    ax2.grid(True, alpha=0.3, axis='y')
    ax2.set_title('Temperature Distribution (Production Phase)', fontsize=14, fontweight='bold')

    plt.tight_layout()
    plt.savefig(output, dpi=300, bbox_inches='tight')
    print(f"âœ… NVTè§£æãƒ—ãƒ­ãƒƒãƒˆä¿å­˜: {output}")

    # çµæœãƒ¬ãƒãƒ¼ãƒˆ
    deviation = abs(mean_temp - target_temp)
    percent_dev = (deviation / target_temp) * 100

    print(f"\nğŸ“Š NVTå¹³è¡¡åŒ–çµæœ:")
    print(f"   ç›®æ¨™æ¸©åº¦: {target_temp:.2f} K")
    print(f"   å¹³å‡æ¸©åº¦: {mean_temp:.2f} Â± {sem:.2f} K (è§£ææœŸé–“: {equilibration_time:.1f}-{time[-1]:.1f} ps)")
    print(f"   åå·®: {deviation:.2f} K ({percent_dev:.2f}%)")
    print(f"   åˆ¤å®š: {'âœ… è‰¯å¥½' if percent_dev < 1.0 else 'âš ï¸ è¦ç¢ºèª'}")

if __name__ == "__main__":
    import sys

    if len(sys.argv) < 2:
        print("Usage: python nvt_analysis.py temperature.xvg [target_temp] [equil_time]")
        sys.exit(1)

    xvg_file = sys.argv[1]
    target_temp = float(sys.argv[2]) if len(sys.argv) > 2 else 300.0
    equil_time = float(sys.argv[3]) if len(sys.argv) > 3 else 50.0

    analyze_nvt_equilibration(xvg_file, target_temp, equil_time)</code></pre>

        <h2>3.3 NPTå¹³è¡¡åŒ–ï¼ˆåœ§åŠ›å¹³è¡¡åŒ–ï¼‰</h2>

        <p>
        æ¸©åº¦ãŒå®‰å®šã—ãŸã‚‰ã€æ¬¡ã«<strong>NPTå¹³è¡¡åŒ–</strong>ã§åœ§åŠ›ã‚‚å¹³è¡¡åŒ–ã—ã¾ã™ã€‚
        NPTã‚¢ãƒ³ã‚µãƒ³ãƒ–ãƒ«ã§ã¯ç²’å­æ•°ï¼ˆNï¼‰ã€åœ§åŠ›ï¼ˆPï¼‰ã€æ¸©åº¦ï¼ˆTï¼‰ã‚’ä¸€å®šã«ä¿ã¡ã€ä½“ç©ï¼ˆVï¼‰ãŒå¤‰å‹•ã—ã¾ã™ã€‚
        </p>

        <p>
        GROMACSã§ã¯<strong>Parrinello-Rahmanåœ§åŠ›æµ´</strong>ãŒæ¨å¥¨ã•ã‚Œã¾ã™ï¼š
        </p>

        <p>
        \[
        \frac{d^2\mathbf{b}}{dt^2} = V \mathbf{W}^{-1} \mathbf{b}'^{-1} (\mathbf{P} - \mathbf{P}_0)
        \]
        </p>

        <p>
        ã“ã“ã§ \( \mathbf{b} \) ã¯ãƒœãƒƒã‚¯ã‚¹ãƒ™ã‚¯ãƒˆãƒ«ã€\( \mathbf{W} \) ã¯åœ§åŠ›ç·©å’Œæ™‚é–“ã«é–¢é€£ã™ã‚‹è³ªé‡è¡Œåˆ—ã€
        \( \mathbf{P} \) ã¯ç¬æ™‚åœ§åŠ›ã€\( \mathbf{P}_0 \) ã¯ç›®æ¨™åœ§åŠ›ã§ã™ã€‚
        </p>

        <h3>3.3.1 NPTå¹³è¡¡åŒ–ã®mdpãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿</h3>

        <pre><code class="language-bash">; npt.mdp - NPT Equilibration (100 ps)
define                   = -DPOSRES
integrator               = md
dt                       = 0.002
nsteps                   = 50000          ; 100 ps
nstlog                   = 5000
nstenergy                = 5000
nstxout-compressed       = 5000

; Neighbor searching
cutoff-scheme            = Verlet
nstlist                  = 10
pbc                      = xyz

; Electrostatics
coulombtype              = PME
rcoulomb                 = 1.0
pme_order                = 4
fourierspacing           = 0.16

; van der Waals
vdwtype                  = Cut-off
rvdw                     = 1.0
DispCorr                 = EnerPres

; Temperature coupling
tcoupl                   = V-rescale
tc-grps                  = Protein Non-Protein
tau_t                    = 0.1    0.1
ref_t                    = 300    300

; Pressure coupling (Parrinello-Rahman)
pcoupl                   = Parrinello-Rahman
pcoupltype               = isotropic
tau_p                    = 2.0            ; åœ§åŠ›ç·©å’Œæ™‚é–“ (ps)
ref_p                    = 1.0            ; 1 bar
compressibility          = 4.5e-5         ; æ°´ã®åœ§ç¸®ç‡ (1/bar)

; Velocity generation
gen_vel                  = no             ; NVTã‹ã‚‰ç¶™ç¶š

; Constraints
constraints              = h-bonds
constraint_algorithm     = lincs
lincs_iter               = 1
lincs_order              = 4</code></pre>

        <div class="warning-box">
            <strong>âš ï¸ Berendsen vs Parrinello-Rahman</strong><br>
            åˆæœŸNPTå¹³è¡¡åŒ–ã§ã¯<code>pcoupl = Berendsen</code>ï¼ˆç·©ã‚„ã‹ã§å®‰å®šï¼‰ã‚’ä½¿ã„ã€
            ãƒ—ãƒ­ãƒ€ã‚¯ã‚·ãƒ§ãƒ³MDã§ã¯<code>pcoupl = Parrinello-Rahman</code>ï¼ˆæ­£ç¢ºãªçµ±è¨ˆã‚¢ãƒ³ã‚µãƒ³ãƒ–ãƒ«ï¼‰ã‚’ä½¿ç”¨ã™ã‚‹ã®ãŒä¸€èˆ¬çš„ã§ã™ã€‚
            ãŸã ã—ã€ç¾ä»£ã§ã¯åˆã‚ã‹ã‚‰Parrinello-Rahmanã§ã‚‚å•é¡Œãªã„å ´åˆãŒå¤šã„ã§ã™ã€‚
        </div>

        <h3>3.3.2 NPTå¹³è¡¡åŒ–ã®å®Ÿè¡Œã¨è©•ä¾¡</h3>

        <pre><code class="language-bash"># NPTå¹³è¡¡åŒ–ã®å®Ÿè¡Œ
gmx grompp -f npt.mdp -c nvt.gro -r nvt.gro -t nvt.cpt -p topol.top -o npt.tpr
gmx mdrun -deffnm npt

# åœ§åŠ›ãƒ»å¯†åº¦ã®æŠ½å‡º
echo "18 0" | gmx energy -f npt.edr -o pressure.xvg
echo "24 0" | gmx energy -f npt.edr -o density.xvg</code></pre>

        <h3>3.3.3 Pythonã«ã‚ˆã‚‹åœ§åŠ›ãƒ»å¯†åº¦ã®è©•ä¾¡</h3>

        <pre><code class="language-python">#!/usr/bin/env python3
"""
NPTå¹³è¡¡åŒ–ã®å“è³ªè©•ä¾¡
- åœ§åŠ›ãƒ»å¯†åº¦ã®æ™‚é–“ç™ºå±•ã¨å®‰å®šæ€§ã‚’è©•ä¾¡
"""
import numpy as np
import matplotlib.pyplot as plt

def analyze_npt_equilibration(pressure_xvg, density_xvg,
                               target_pressure=1.0, equilibration_time=50.0,
                               output='npt_analysis.png'):
    """
    NPTå¹³è¡¡åŒ–ã®å“è³ªã‚’è©•ä¾¡

    Parameters
    ----------
    pressure_xvg : str
        pressure.xvgãƒ•ã‚¡ã‚¤ãƒ«
    density_xvg : str
        density.xvgãƒ•ã‚¡ã‚¤ãƒ«
    target_pressure : float
        ç›®æ¨™åœ§åŠ› (bar)
    equilibration_time : float
        å¹³è¡¡åŒ–ã«ä½¿ã†æ™‚é–“ (ps)
    """
    # ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿
    time_p, pressure = parse_xvg(pressure_xvg)
    time_d, density = parse_xvg(density_xvg)

    # è§£ææœŸé–“ã®ãƒã‚¹ã‚¯
    analysis_mask_p = time_p >= equilibration_time
    analysis_mask_d = time_d >= equilibration_time

    analysis_pressure = pressure[analysis_mask_p]
    analysis_density = density[analysis_mask_d]
    analysis_time_p = time_p[analysis_mask_p]
    analysis_time_d = time_d[analysis_mask_d]

    # çµ±è¨ˆè§£æ
    mean_pressure, sem_pressure = block_average(analysis_pressure, block_size=10)
    mean_density, sem_density = block_average(analysis_density, block_size=10)

    # ãƒ—ãƒ­ãƒƒãƒˆ
    fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 10))

    # åœ§åŠ›
    ax1.plot(time_p, pressure, 'b-', alpha=0.6, linewidth=1)
    ax1.axhline(y=target_pressure, color='r', linestyle='--', linewidth=2,
                label=f'Target: {target_pressure} bar')
    ax1.axhline(y=mean_pressure, color='purple', linestyle='--', linewidth=2,
                label=f'Mean: {mean_pressure:.2f} Â± {sem_pressure:.2f} bar')
    ax1.axvline(x=equilibration_time, color='gray', linestyle=':', linewidth=2)
    ax1.set_xlabel('Time (ps)', fontsize=12)
    ax1.set_ylabel('Pressure (bar)', fontsize=12)
    ax1.legend()
    ax1.grid(True, alpha=0.3)
    ax1.set_title('NPT Equilibration: Pressure vs Time', fontsize=14, fontweight='bold')

    # å¯†åº¦
    ax2.plot(time_d, density, 'g-', alpha=0.6, linewidth=1)
    ax2.axhline(y=mean_density, color='purple', linestyle='--', linewidth=2,
                label=f'Mean: {mean_density:.2f} Â± {sem_density:.4f} kg/mÂ³')
    ax2.axvline(x=equilibration_time, color='gray', linestyle=':', linewidth=2)
    ax2.set_xlabel('Time (ps)', fontsize=12)
    ax2.set_ylabel('Density (kg/mÂ³)', fontsize=12)
    ax2.legend()
    ax2.grid(True, alpha=0.3)
    ax2.set_title('NPT Equilibration: Density vs Time', fontsize=14, fontweight='bold')

    plt.tight_layout()
    plt.savefig(output, dpi=300, bbox_inches='tight')
    print(f"âœ… NPTè§£æãƒ—ãƒ­ãƒƒãƒˆä¿å­˜: {output}")

    # çµæœãƒ¬ãƒãƒ¼ãƒˆ
    pressure_dev = abs(mean_pressure - target_pressure)

    print(f"\nğŸ“Š NPTå¹³è¡¡åŒ–çµæœ:")
    print(f"   ç›®æ¨™åœ§åŠ›: {target_pressure:.2f} bar")
    print(f"   å¹³å‡åœ§åŠ›: {mean_pressure:.2f} Â± {sem_pressure:.2f} bar")
    print(f"   åå·®: {pressure_dev:.2f} bar")
    print(f"   å¹³å‡å¯†åº¦: {mean_density:.2f} Â± {sem_density:.4f} kg/mÂ³")
    print(f"   æ°´ã®å¯†åº¦å‚è€ƒå€¤: 997 kg/mÂ³ (300 K, 1 bar)")
    print(f"   åˆ¤å®š: {'âœ… è‰¯å¥½' if pressure_dev < 10.0 else 'âš ï¸ è¦ç¢ºèª'}")

if __name__ == "__main__":
    import sys

    if len(sys.argv) < 3:
        print("Usage: python npt_analysis.py pressure.xvg density.xvg [target_p] [equil_time]")
        sys.exit(1)

    pressure_xvg = sys.argv[1]
    density_xvg = sys.argv[2]
    target_p = float(sys.argv[3]) if len(sys.argv) > 3 else 1.0
    equil_time = float(sys.argv[4]) if len(sys.argv) > 4 else 50.0

    analyze_npt_equilibration(pressure_xvg, density_xvg, target_p, equil_time)</code></pre>

        <h2>3.4 ãƒ—ãƒ­ãƒ€ã‚¯ã‚·ãƒ§ãƒ³MDï¼ˆæœ¬ç•ªã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰</h2>

        <p>
        å¹³è¡¡åŒ–ãŒå®Œäº†ã—ãŸã‚‰ã€ä½ç½®æ‹˜æŸã‚’å¤–ã—ã¦<strong>ãƒ—ãƒ­ãƒ€ã‚¯ã‚·ãƒ§ãƒ³MD</strong>ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚
        é€šå¸¸ã€æ•°ãƒŠãƒç§’ã€œæ•°ç™¾ãƒŠãƒç§’ã®é•·æ™‚é–“ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’è¡Œã„ã¾ã™ã€‚
        </p>

        <h3>3.4.1 ãƒ—ãƒ­ãƒ€ã‚¯ã‚·ãƒ§ãƒ³MDã®mdpãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿</h3>

        <pre><code class="language-bash">; md.mdp - Production MD (10 ns)
integrator               = md
dt                       = 0.002
nsteps                   = 5000000        ; 10 ns (5000000 * 2 fs)
nstlog                   = 10000
nstenergy                = 10000
nstxout-compressed       = 10000          ; 20 psã”ã¨ã«åº§æ¨™ä¿å­˜

; Output precision
compressed-x-precision   = 1000           ; XTCåœ§ç¸®ç²¾åº¦

; Neighbor searching
cutoff-scheme            = Verlet
nstlist                  = 10
pbc                      = xyz

; Electrostatics
coulombtype              = PME
rcoulomb                 = 1.0
pme_order                = 4
fourierspacing           = 0.16

; van der Waals
vdwtype                  = Cut-off
rvdw                     = 1.0
DispCorr                 = EnerPres

; Temperature coupling
tcoupl                   = V-rescale
tc-grps                  = Protein Non-Protein
tau_t                    = 0.1    0.1
ref_t                    = 300    300

; Pressure coupling
pcoupl                   = Parrinello-Rahman
pcoupltype               = isotropic
tau_p                    = 2.0
ref_p                    = 1.0
compressibility          = 4.5e-5

; Velocity generation
gen_vel                  = no

; Constraints
constraints              = h-bonds
constraint_algorithm     = lincs
lincs_iter               = 1
lincs_order              = 4

; Periodic boundary conditions
pbc                      = xyz</code></pre>

        <h3>3.4.2 ãƒ—ãƒ­ãƒ€ã‚¯ã‚·ãƒ§ãƒ³MDã®å®Ÿè¡Œ</h3>

        <pre><code class="language-bash"># ãƒ—ãƒ­ãƒ€ã‚¯ã‚·ãƒ§ãƒ³MDã®å®Ÿè¡Œ
gmx grompp -f md.mdp -c npt.gro -t npt.cpt -p topol.top -o md_0_10.tpr
gmx mdrun -deffnm md_0_10

# GPUã‚’ä½¿ã†å ´åˆ
gmx mdrun -deffnm md_0_10 -nb gpu -pme gpu -bonded gpu

# è¤‡æ•°GPU
gmx mdrun -deffnm md_0_10 -nb gpu -pme gpu -bonded gpu -gpu_id 01</code></pre>

        <div class="info-box">
            <strong>ğŸ’¡ MDã®ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆå†é–‹</strong><br>
            é•·æ™‚é–“MDã¯é€”ä¸­ã§ä¸­æ–­ã•ã‚Œã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆ.cptï¼‰ã‹ã‚‰å†é–‹ã§ãã¾ã™ï¼š
            <pre><code class="language-bash">gmx mdrun -deffnm md_0_10 -cpi md_0_10.cpt -append</code></pre>
        </div>

        <h3>3.4.3 Pythonã«ã‚ˆã‚‹è»Œé“è§£æã®åŸºç¤</h3>

        <pre><code class="language-python">#!/usr/bin/env python3
"""
MDãƒˆãƒ©ã‚¸ã‚§ã‚¯ãƒˆãƒªã®åŸºæœ¬è§£æ
- RMSD (Root Mean Square Deviation): æ§‹é€ å¤‰åŒ–
- RMSF (Root Mean Square Fluctuation): æ®‹åŸºã”ã¨ã®æºã‚‰ã
"""
import MDAnalysis as mda
from MDAnalysis.analysis import rms, align
import matplotlib.pyplot as plt
import numpy as np

def calculate_rmsd(topology, trajectory, selection='backbone'):
    """
    ãƒãƒƒã‚¯ãƒœãƒ¼ãƒ³ã®RMSDã‚’è¨ˆç®—

    Parameters
    ----------
    topology : str
        ãƒˆãƒãƒ­ã‚¸ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ« (.gro, .pdb, .tpr)
    trajectory : str
        è»Œé“ãƒ•ã‚¡ã‚¤ãƒ« (.xtc, .trr)
    selection : str
        åŸå­é¸æŠï¼ˆ'backbone', 'protein', 'name CA'ãªã©ï¼‰

    Returns
    -------
    time : ndarray
        æ™‚é–“ (ps)
    rmsd : ndarray
        RMSD (Ã…)
    """
    u = mda.Universe(topology, trajectory)

    # å‚ç…§æ§‹é€ ï¼ˆæœ€åˆã®ãƒ•ãƒ¬ãƒ¼ãƒ ï¼‰
    ref = mda.Universe(topology, trajectory)

    # RMSDè¨ˆç®—
    R = rms.RMSD(u, ref, select=selection, groupselections=[selection])
    R.run()

    time = R.results.rmsd[:, 1]  # ps
    rmsd_values = R.results.rmsd[:, 2]  # Ã…

    return time, rmsd_values

def calculate_rmsf(topology, trajectory, selection='protein and name CA'):
    """
    CÎ±åŸå­ã®RMSFã‚’è¨ˆç®—ï¼ˆæ®‹åŸºã”ã¨ã®æºã‚‰ãï¼‰

    Parameters
    ----------
    topology : str
        ãƒˆãƒãƒ­ã‚¸ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«
    trajectory : str
        è»Œé“ãƒ•ã‚¡ã‚¤ãƒ«
    selection : str
        åŸå­é¸æŠï¼ˆé€šå¸¸ã¯CÎ±åŸå­ï¼‰

    Returns
    -------
    resids : ndarray
        æ®‹åŸºç•ªå·
    rmsf : ndarray
        RMSF (Ã…)
    """
    u = mda.Universe(topology, trajectory)

    # å…¨ãƒ•ãƒ¬ãƒ¼ãƒ ã§backboneã‚’åŸºæº–ã«é‡ã­åˆã‚ã›
    align.AlignTraj(u, u, select='backbone', in_memory=True).run()

    # CÎ±åŸå­ã®RMSFè¨ˆç®—
    ca_atoms = u.select_atoms(selection)

    # å„åŸå­ã®ä½ç½®ã‚’æ™‚é–“å¹³å‡
    positions = np.array([ca_atoms.positions for ts in u.trajectory])
    mean_positions = positions.mean(axis=0)

    # RMSF = sqrt(mean((r - r_avg)^2))
    deviations = positions - mean_positions
    rmsf = np.sqrt((deviations ** 2).sum(axis=2).mean(axis=0))

    resids = ca_atoms.resids

    return resids, rmsf

def plot_rmsd_rmsf(topology, trajectory, output='md_rmsd_rmsf.png'):
    """
    RMSDãƒ»RMSFã‚’ãƒ—ãƒ­ãƒƒãƒˆ
    """
    # RMSDè¨ˆç®—
    time, rmsd = calculate_rmsd(topology, trajectory, selection='backbone')

    # RMSFè¨ˆç®—
    resids, rmsf = calculate_rmsf(topology, trajectory, selection='protein and name CA')

    # ãƒ—ãƒ­ãƒƒãƒˆ
    fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 10))

    # RMSD
    ax1.plot(time / 1000, rmsd, 'b-', linewidth=2)  # nså˜ä½
    ax1.set_xlabel('Time (ns)', fontsize=12)
    ax1.set_ylabel('RMSD (Ã…)', fontsize=12)
    ax1.set_title('Backbone RMSD vs Time', fontsize=14, fontweight='bold')
    ax1.grid(True, alpha=0.3)

    # RMSF
    ax2.plot(resids, rmsf, 'r-', linewidth=2)
    ax2.set_xlabel('Residue Number', fontsize=12)
    ax2.set_ylabel('RMSF (Ã…)', fontsize=12)
    ax2.set_title('Per-Residue RMSF (CÎ± atoms)', fontsize=14, fontweight='bold')
    ax2.grid(True, alpha=0.3)

    plt.tight_layout()
    plt.savefig(output, dpi=300, bbox_inches='tight')
    print(f"âœ… RMSD/RMSFãƒ—ãƒ­ãƒƒãƒˆä¿å­˜: {output}")

    # çµ±è¨ˆ
    rmsd_mean = rmsd.mean()
    rmsd_std = rmsd.std()
    rmsf_mean = rmsf.mean()
    rmsf_max = rmsf.max()
    max_rmsf_resid = resids[rmsf.argmax()]

    print(f"\nğŸ“Š MDè§£æçµæœ:")
    print(f"   RMSDå¹³å‡: {rmsd_mean:.2f} Â± {rmsd_std:.2f} Ã…")
    print(f"   RMSFå¹³å‡: {rmsf_mean:.2f} Ã…")
    print(f"   RMSFæœ€å¤§: {rmsf_max:.2f} Ã… (æ®‹åŸº {max_rmsf_resid})")

if __name__ == "__main__":
    import sys

    if len(sys.argv) < 3:
        print("Usage: python md_analysis.py topology trajectory")
        print("  topology: .gro, .pdb, or .tpr")
        print("  trajectory: .xtc or .trr")
        sys.exit(1)

    topology = sys.argv[1]
    trajectory = sys.argv[2]

    plot_rmsd_rmsf(topology, trajectory)</code></pre>

        <div class="mermaid">
flowchart LR
    A[EMå®Œäº†<br/>em.gro] --> B[NVTå¹³è¡¡åŒ–<br/>100 ps<br/>æ¸©åº¦300K]
    B --> C[NPTå¹³è¡¡åŒ–<br/>100 ps<br/>åœ§åŠ›1 bar]
    C --> D[ãƒ—ãƒ­ãƒ€ã‚¯ã‚·ãƒ§ãƒ³MD<br/>10 ns]
    D --> E[è»Œé“è§£æ<br/>RMSD/RMSF]
        </div>

        <h2>3.5 æ¼”ç¿’å•é¡Œ</h2>

        <h3>Exercise 3-1: ã‚¨ãƒãƒ«ã‚®ãƒ¼æœ€å°åŒ–ã®åæŸè§£æ (Easy)</h3>

        <p>
        <strong>å•é¡Œ</strong>: æä¾›ã•ã‚ŒãŸEM log fileã‹ã‚‰ã€Potential Energyã¨Maximum Forceã®åæŸã‚’ç¢ºèªã—ã€
        emtol=1000.0ã®åŸºæº–ã‚’æº€ãŸã—ã¦ã„ã‚‹ã‹åˆ¤å®šã—ã¦ãã ã•ã„ã€‚
        </p>

        <details>
            <summary><strong>è§£ç­”ä¾‹ã‚’è¡¨ç¤º</strong></summary>

            <pre><code class="language-python">#!/usr/bin/env python3
"""
Exercise 3-1: ã‚¨ãƒãƒ«ã‚®ãƒ¼æœ€å°åŒ–ã®åæŸåˆ¤å®š
"""
import re

def check_em_convergence(log_file, emtol=1000.0):
    """
    EMãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰åæŸåˆ¤å®š
    """
    with open(log_file, 'r') as f:
        content = f.read()

    # æœ€çµ‚çš„ãªFmaxã‚’æŠ½å‡º
    fmax_match = re.search(r'converged to Fmax < [\d.e+-]+ in \d+ steps', content)
    if not fmax_match:
        print("âŒ åæŸæƒ…å ±ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
        return False

    # Potential Energyã®æœ€çµ‚å€¤
    energy_match = re.search(r'Potential Energy\s+=\s+([-\d.e+]+)', content)
    if energy_match:
        final_energy = float(energy_match.group(1))
        print(f"æœ€çµ‚Potential Energy: {final_energy:.2e} kJ/mol")

    # Maximum forceã®æœ€çµ‚å€¤
    force_match = re.search(r'Maximum force\s+=\s+([-\d.e+]+) on atom', content)
    if force_match:
        final_fmax = float(force_match.group(1))
        print(f"æœ€çµ‚Maximum Force: {final_fmax:.2e} kJ/mol/nm")

        if final_fmax < emtol:
            print(f"âœ… åæŸæˆåŠŸ: Fmax ({final_fmax:.2f}) < emtol ({emtol:.2f})")
            return True
        else:
            print(f"âŒ åæŸå¤±æ•—: Fmax ({final_fmax:.2f}) >= emtol ({emtol:.2f})")
            return False

    return False

if __name__ == "__main__":
    import sys
    if len(sys.argv) < 2:
        print("Usage: python ex3_1.py em.log [emtol]")
        sys.exit(1)

    log_file = sys.argv[1]
    emtol = float(sys.argv[2]) if len(sys.argv) > 2 else 1000.0

    check_em_convergence(log_file, emtol)</code></pre>

            <p><strong>è©•ä¾¡åŸºæº–</strong>:</p>
            <ul>
                <li>Fmax < emtol: åæŸæˆåŠŸ âœ…</li>
                <li>Fmax >= emtol: è¿½åŠ æœ€é©åŒ–ï¼ˆConjugate Gradientï¼‰ãŒå¿…è¦ âš ï¸</li>
                <li>éå¸¸ã«é«˜ã„Fmax (>10000): åˆæœŸæ§‹é€ ã«å•é¡ŒãŒã‚ã‚‹å¯èƒ½æ€§ âŒ</li>
            </ul>
        </details>

        <h3>Exercise 3-2: NVTå¹³è¡¡åŒ–ã®æ¸©åº¦å®‰å®šæ€§è©•ä¾¡ (Medium)</h3>

        <p>
        <strong>å•é¡Œ</strong>: temperature.xvgã‹ã‚‰æœ€å¾Œã®50 psã®ãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ã„ã€
        å¹³å‡æ¸©åº¦ã¨æ¨™æº–åå·®ã‚’è¨ˆç®—ã—ã¦ãã ã•ã„ã€‚ç›®æ¨™æ¸©åº¦300 Kã‹ã‚‰ã®åå·®ãŒ1%ä»¥å†…ã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚
        </p>

        <details>
            <summary><strong>è§£ç­”ä¾‹ã‚’è¡¨ç¤º</strong></summary>

            <pre><code class="language-python">#!/usr/bin/env python3
"""
Exercise 3-2: NVTæ¸©åº¦å®‰å®šæ€§è©•ä¾¡
"""
import numpy as np

def parse_xvg(xvg_file):
    time, values = [], []
    with open(xvg_file, 'r') as f:
        for line in f:
            if line.startswith('#') or line.startswith('@'):
                continue
            parts = line.split()
            if len(parts) >= 2:
                time.append(float(parts[0]))
                values.append(float(parts[1]))
    return np.array(time), np.array(values)

def evaluate_temperature_stability(xvg_file, target_temp=300.0, analysis_window=50.0):
    """
    NVTæ¸©åº¦å®‰å®šæ€§ã‚’è©•ä¾¡

    Parameters
    ----------
    xvg_file : str
        temperature.xvgãƒ•ã‚¡ã‚¤ãƒ«
    target_temp : float
        ç›®æ¨™æ¸©åº¦ (K)
    analysis_window : float
        è§£æã«ä½¿ã†æœ€å¾Œã®N ps
    """
    time, temp = parse_xvg(xvg_file)

    # æœ€å¾Œã®analysis_window psåˆ†ã‚’æŠ½å‡º
    total_time = time[-1]
    cutoff_time = total_time - analysis_window
    analysis_mask = time >= cutoff_time

    analysis_time = time[analysis_mask]
    analysis_temp = temp[analysis_mask]

    # çµ±è¨ˆ
    mean_temp = analysis_temp.mean()
    std_temp = analysis_temp.std()

    deviation = abs(mean_temp - target_temp)
    percent_deviation = (deviation / target_temp) * 100

    print(f"ğŸ“Š æ¸©åº¦å®‰å®šæ€§è©•ä¾¡:")
    print(f"   è§£æåŒºé–“: {cutoff_time:.1f} - {total_time:.1f} ps ({len(analysis_temp)} ã‚µãƒ³ãƒ—ãƒ«)")
    print(f"   ç›®æ¨™æ¸©åº¦: {target_temp:.2f} K")
    print(f"   å¹³å‡æ¸©åº¦: {mean_temp:.2f} Â± {std_temp:.2f} K")
    print(f"   åå·®: {deviation:.2f} K ({percent_deviation:.2f}%)")

    if percent_deviation < 1.0:
        print(f"   åˆ¤å®š: âœ… è‰¯å¥½ï¼ˆåå·® < 1%ï¼‰")
        return True
    else:
        print(f"   åˆ¤å®š: âš ï¸ è¦ç¢ºèªï¼ˆåå·® >= 1%ï¼‰")
        return False

if __name__ == "__main__":
    import sys
    if len(sys.argv) < 2:
        print("Usage: python ex3_2.py temperature.xvg [target_temp] [window]")
        sys.exit(1)

    xvg_file = sys.argv[1]
    target_temp = float(sys.argv[2]) if len(sys.argv) > 2 else 300.0
    window = float(sys.argv[3]) if len(sys.argv) > 3 else 50.0

    evaluate_temperature_stability(xvg_file, target_temp, window)</code></pre>

            <p><strong>è©•ä¾¡åŸºæº–</strong>:</p>
            <ul>
                <li>åå·® < 1%: è‰¯å¥½ âœ…</li>
                <li>1% â‰¤ åå·® < 2%: è¨±å®¹ç¯„å›²ã€ãƒ—ãƒ­ãƒ€ã‚¯ã‚·ãƒ§ãƒ³MDå¯ âš ï¸</li>
                <li>åå·® â‰¥ 2%: å†å¹³è¡¡åŒ–æ¨å¥¨ âŒ</li>
            </ul>
        </details>

        <h3>Exercise 3-3: ãƒ—ãƒ­ãƒ€ã‚¯ã‚·ãƒ§ãƒ³MDã®RMSDè§£æã¨æ§‹é€ å®‰å®šæ€§è©•ä¾¡ (Hard)</h3>

        <p>
        <strong>å•é¡Œ</strong>: 10 nsã®ãƒ—ãƒ­ãƒ€ã‚¯ã‚·ãƒ§ãƒ³MDè»Œé“ã‹ã‚‰ã€æœ€åˆã®2 nsã‚’å¹³è¡¡åŒ–æœŸé–“ã¨ã—ã¦é™¤å¤–ã—ã€
        æ®‹ã‚Šã®8 nsã§backbone RMSDã®æ™‚é–“å¹³å‡ã¨ãƒ—ãƒ©ãƒˆãƒ¼ï¼ˆå®‰å®šçŠ¶æ…‹ï¼‰é”æˆæ™‚åˆ»ã‚’æ±‚ã‚ã¦ãã ã•ã„ã€‚
        ã¾ãŸã€RMSD < 3 Ã… ã®åŸºæº–ã‚’æº€ãŸã—ã¦ã„ã‚‹ã‹åˆ¤å®šã—ã¦ãã ã•ã„ã€‚
        </p>

        <details>
            <summary><strong>è§£ç­”ä¾‹ã‚’è¡¨ç¤º</strong></summary>

            <pre><code class="language-python">#!/usr/bin/env python3
"""
Exercise 3-3: ãƒ—ãƒ­ãƒ€ã‚¯ã‚·ãƒ§ãƒ³MDã®RMSDè§£æ
"""
import MDAnalysis as mda
from MDAnalysis.analysis import rms
import matplotlib.pyplot as plt
import numpy as np

def detect_plateau(time, rmsd, window_size=100, threshold=0.1):
    """
    RMSDãƒ—ãƒ©ãƒˆãƒ¼ï¼ˆå®‰å®šçŠ¶æ…‹ï¼‰ã‚’æ¤œå‡º

    Parameters
    ----------
    time : ndarray
        æ™‚é–“é…åˆ— (ps)
    rmsd : ndarray
        RMSDé…åˆ— (Ã…)
    window_size : int
        ç§»å‹•å¹³å‡ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚µã‚¤ã‚º
    threshold : float
        ãƒ—ãƒ©ãƒˆãƒ¼åˆ¤å®šé–¾å€¤ï¼ˆæ¨™æº–åå·®ã®å¤‰åŒ–ç‡ï¼‰

    Returns
    -------
    plateau_time : float
        ãƒ—ãƒ©ãƒˆãƒ¼é”æˆæ™‚åˆ» (ps)
    """
    # ç§»å‹•å¹³å‡
    rolling_mean = np.convolve(rmsd, np.ones(window_size)/window_size, mode='valid')

    # ç§»å‹•æ¨™æº–åå·®
    rolling_std = []
    for i in range(len(rmsd) - window_size + 1):
        rolling_std.append(rmsd[i:i+window_size].std())
    rolling_std = np.array(rolling_std)

    # æ¨™æº–åå·®ãŒé–¾å€¤ä»¥ä¸‹ã«ãªã‚‹æœ€åˆã®æ™‚åˆ»
    stable_indices = np.where(rolling_std < threshold)[0]
    if len(stable_indices) > 0:
        plateau_idx = stable_indices[0]
        plateau_time = time[plateau_idx]
    else:
        plateau_time = None

    return plateau_time

def analyze_production_md_rmsd(topology, trajectory,
                                 equilibration_ns=2.0,
                                 stability_criterion=3.0,
                                 output='ex3_3_rmsd.png'):
    """
    ãƒ—ãƒ­ãƒ€ã‚¯ã‚·ãƒ§ãƒ³MDã®RMSDè§£æã¨æ§‹é€ å®‰å®šæ€§è©•ä¾¡

    Parameters
    ----------
    topology : str
        ãƒˆãƒãƒ­ã‚¸ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ« (.gro, .tpr)
    trajectory : str
        è»Œé“ãƒ•ã‚¡ã‚¤ãƒ« (.xtc)
    equilibration_ns : float
        é™¤å¤–ã™ã‚‹å¹³è¡¡åŒ–æœŸé–“ (ns)
    stability_criterion : float
        å®‰å®šæ€§åˆ¤å®šåŸºæº– (Ã…)
    """
    u = mda.Universe(topology, trajectory)
    ref = mda.Universe(topology, trajectory)

    # RMSDè¨ˆç®—
    R = rms.RMSD(u, ref, select='backbone', groupselections=['backbone'])
    R.run()

    time = R.results.rmsd[:, 1] / 1000  # ps â†’ ns
    rmsd = R.results.rmsd[:, 2]  # Ã…

    # å¹³è¡¡åŒ–æœŸé–“ã‚’é™¤å¤–
    analysis_mask = time >= equilibration_ns
    analysis_time = time[analysis_mask]
    analysis_rmsd = rmsd[analysis_mask]

    # çµ±è¨ˆ
    mean_rmsd = analysis_rmsd.mean()
    std_rmsd = analysis_rmsd.std()

    # ãƒ—ãƒ©ãƒˆãƒ¼æ¤œå‡º
    plateau_time = detect_plateau(time, rmsd, window_size=100, threshold=0.1)

    # ãƒ—ãƒ­ãƒƒãƒˆ
    fig, ax = plt.subplots(figsize=(12, 6))

    ax.plot(time, rmsd, 'b-', linewidth=2, label='Backbone RMSD')
    ax.axvline(x=equilibration_ns, color='gray', linestyle=':', linewidth=2,
               label=f'Analysis Start ({equilibration_ns} ns)')
    if plateau_time:
        ax.axvline(x=plateau_time/1000, color='green', linestyle='--', linewidth=2,
                   label=f'Plateau Reached (~{plateau_time/1000:.2f} ns)')
    ax.axhline(y=stability_criterion, color='r', linestyle='--', linewidth=2,
               label=f'Stability Criterion ({stability_criterion} Ã…)')
    ax.axhline(y=mean_rmsd, color='purple', linestyle='--', linewidth=2,
               label=f'Mean ({equilibration_ns}-{time[-1]:.1f} ns): {mean_rmsd:.2f} Ã…')

    ax.set_xlabel('Time (ns)', fontsize=12)
    ax.set_ylabel('RMSD (Ã…)', fontsize=12)
    ax.set_title('Production MD: Backbone RMSD Analysis', fontsize=14, fontweight='bold')
    ax.legend()
    ax.grid(True, alpha=0.3)

    plt.tight_layout()
    plt.savefig(output, dpi=300, bbox_inches='tight')
    print(f"âœ… RMSDè§£æãƒ—ãƒ­ãƒƒãƒˆä¿å­˜: {output}")

    # çµæœãƒ¬ãƒãƒ¼ãƒˆ
    print(f"\nğŸ“Š ãƒ—ãƒ­ãƒ€ã‚¯ã‚·ãƒ§ãƒ³MD RMSDè§£æ:")
    print(f"   ç·ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³æ™‚é–“: {time[-1]:.2f} ns")
    print(f"   è§£ææœŸé–“: {equilibration_ns:.2f} - {time[-1]:.2f} ns")
    print(f"   å¹³å‡RMSD: {mean_rmsd:.2f} Â± {std_rmsd:.2f} Ã…")
    if plateau_time:
        print(f"   ãƒ—ãƒ©ãƒˆãƒ¼é”æˆ: {plateau_time/1000:.2f} ns")
    else:
        print(f"   ãƒ—ãƒ©ãƒˆãƒ¼: æœªé”æˆï¼ˆã•ã‚‰ãªã‚‹å¹³è¡¡åŒ–ãŒå¿…è¦ï¼‰")

    is_stable = mean_rmsd < stability_criterion
    print(f"   å®‰å®šæ€§åˆ¤å®š: {'âœ… å®‰å®šï¼ˆRMSD < 3 Ã…ï¼‰' if is_stable else 'âš ï¸ è¦ç¢ºèªï¼ˆRMSD >= 3 Ã…ï¼‰'}")

    return mean_rmsd, std_rmsd, plateau_time

if __name__ == "__main__":
    import sys
    if len(sys.argv) < 3:
        print("Usage: python ex3_3.py topology trajectory [equil_ns] [criterion]")
        sys.exit(1)

    topology = sys.argv[1]
    trajectory = sys.argv[2]
    equil_ns = float(sys.argv[3]) if len(sys.argv) > 3 else 2.0
    criterion = float(sys.argv[4]) if len(sys.argv) > 4 else 3.0

    analyze_production_md_rmsd(topology, trajectory, equil_ns, criterion)</code></pre>

            <p><strong>è©•ä¾¡åŸºæº–</strong>:</p>
            <ul>
                <li>RMSD < 2 Ã…: éå¸¸ã«å®‰å®š âœ…âœ…</li>
                <li>2 Ã… â‰¤ RMSD < 3 Ã…: å®‰å®š âœ…</li>
                <li>3 Ã… â‰¤ RMSD < 5 Ã…: ã‚„ã‚„ä¸å®‰å®šã€æ³¨æ„ãŒå¿…è¦ âš ï¸</li>
                <li>RMSD â‰¥ 5 Ã…: ä¸å®‰å®šã€å¤§ããªæ§‹é€ å¤‰åŒ–ã®å¯èƒ½æ€§ âŒ</li>
            </ul>

            <p><strong>ãƒ’ãƒ³ãƒˆ</strong>:</p>
            <ul>
                <li>ãƒ—ãƒ©ãƒˆãƒ¼ãŒæ—©æœŸï¼ˆ2-3 nsä»¥å†…ï¼‰ã«é”æˆã•ã‚Œã‚‹å ´åˆã€å¹³è¡¡åŒ–ãŒååˆ†ã ã£ãŸè¨¼æ‹ </li>
                <li>ãƒ—ãƒ©ãƒˆãƒ¼æœªé”æˆã®å ´åˆã€ã•ã‚‰ãªã‚‹ãƒ—ãƒ­ãƒ€ã‚¯ã‚·ãƒ§ãƒ³MDå»¶é•·ãŒæ¨å¥¨ã•ã‚Œã‚‹</li>
                <li>å‘¨æœŸçš„ãªæŒ¯å‹•ãŒã‚ã‚‹å ´åˆã€ãƒ‰ãƒ¡ã‚¤ãƒ³é‹å‹•ã‚„æ§‹é€ é·ç§»ã®å¯èƒ½æ€§ãŒã‚ã‚‹</li>
            </ul>
        </details>

        <h2>3.6 å­¦ç¿’ç›®æ¨™ã®ç¢ºèª</h2>

        <div class="info-box">
            <strong>ãƒ¬ãƒ™ãƒ«1: åŸºæœ¬ç†è§£</strong>
            <ul>
                <li>ã‚¨ãƒãƒ«ã‚®ãƒ¼æœ€å°åŒ–ï¼ˆEMï¼‰ã®ç›®çš„ã¨åæŸåˆ¤å®šåŸºæº–ã‚’èª¬æ˜ã§ãã‚‹</li>
                <li>NVTå¹³è¡¡åŒ–ã¨NPTå¹³è¡¡åŒ–ã®é•ã„ã‚’ç†è§£ã—ã¦ã„ã‚‹</li>
                <li>Steepest Descentæ³•ã¨Conjugate Gradientæ³•ã®é•ã„ã‚’çŸ¥ã£ã¦ã„ã‚‹</li>
                <li>V-rescaleç†±æµ´ã¨Parrinello-Rahmanåœ§åŠ›æµ´ã®å½¹å‰²ã‚’ç†è§£ã—ã¦ã„ã‚‹</li>
                <li>ä½ç½®æ‹˜æŸï¼ˆPOSRESï¼‰ã®ç›®çš„ã‚’èª¬æ˜ã§ãã‚‹</li>
            </ul>

            <strong>ãƒ¬ãƒ™ãƒ«2: å®Ÿè·µã‚¹ã‚­ãƒ«</strong>
            <ul>
                <li>EMã€NVTã€NPTã€ãƒ—ãƒ­ãƒ€ã‚¯ã‚·ãƒ§ãƒ³MDã®mdpãƒ•ã‚¡ã‚¤ãƒ«ã‚’é©åˆ‡ã«è¨­å®šã§ãã‚‹</li>
                <li>gmx gromppã€gmx mdrunã‚’ä½¿ã£ã¦å„æ®µéšã‚’å®Ÿè¡Œã§ãã‚‹</li>
                <li>Pythonã§æ¸©åº¦ãƒ»åœ§åŠ›ãƒ»ã‚¨ãƒãƒ«ã‚®ãƒ¼ã®æ™‚é–“ç™ºå±•ã‚’ãƒ—ãƒ­ãƒƒãƒˆã§ãã‚‹</li>
                <li>å¹³è¡¡åŒ–ã®å“è³ªï¼ˆåæŸã€å®‰å®šæ€§ï¼‰ã‚’è©•ä¾¡ã§ãã‚‹</li>
                <li>MDAnalysisã‚’ä½¿ã£ã¦RMSDãƒ»RMSFã‚’è¨ˆç®—ã§ãã‚‹</li>
            </ul>

            <strong>ãƒ¬ãƒ™ãƒ«3: å¿œç”¨åŠ›</strong>
            <ul>
                <li>å¹³è¡¡åŒ–ãŒä¸ååˆ†ãªå ´åˆã®å¯¾å‡¦æ³•ï¼ˆmdpèª¿æ•´ã€æ™‚é–“å»¶é•·ï¼‰ã‚’åˆ¤æ–­ã§ãã‚‹</li>
                <li>ç•°ãªã‚‹ç³»ï¼ˆè†œã‚¿ãƒ³ãƒ‘ã‚¯è³ªã€ãƒªã‚¬ãƒ³ãƒ‰çµåˆç³»ï¼‰ã«é©ã—ãŸmdpè¨­å®šãŒã§ãã‚‹</li>
                <li>ãƒ—ãƒ­ãƒ€ã‚¯ã‚·ãƒ§ãƒ³MDã®è»Œé“ã‹ã‚‰æ§‹é€ å®‰å®šæ€§ã‚’å®šé‡çš„ã«è©•ä¾¡ã§ãã‚‹</li>
                <li>ãƒ–ãƒ­ãƒƒã‚¯å¹³å‡æ³•ã§çµ±è¨ˆèª¤å·®ã‚’æ¨å®šã§ãã‚‹</li>
                <li>å¤§è¦æ¨¡MDï¼ˆæ•°ç™¾nsã€œÎ¼sï¼‰ã®å®Ÿè¡Œè¨ˆç”»ã¨å“è³ªç®¡ç†ãŒã§ãã‚‹</li>
            </ul>
        </div>

        <h2>å‚è€ƒæ–‡çŒ®</h2>

        <ol>
            <li>Hess, B., Kutzner, C., van der Spoel, D., & Lindahl, E. (2008). GROMACS 4: Algorithms for Highly Efficient, Load-Balanced, and Scalable Molecular Simulation. <em>Journal of Chemical Theory and Computation</em>, 4(3), 435-447. <strong>pp. 438-442</strong>.</li>

            <li>Bussi, G., Donadio, D., & Parrinello, M. (2007). Canonical sampling through velocity rescaling. <em>The Journal of Chemical Physics</em>, 126(1), 014101. <strong>pp. 1-7</strong>.</li>

            <li>Parrinello, M., & Rahman, A. (1981). Polymorphic transitions in single crystals: A new molecular dynamics method. <em>Journal of Applied Physics</em>, 52(12), 7182-7190. <strong>pp. 7182-7185</strong>.</li>

            <li>Berendsen, H. J. C., Postma, J. P. M., van Gunsteren, W. F., DiNola, A., & Haak, J. R. (1984). Molecular dynamics with coupling to an external bath. <em>The Journal of Chemical Physics</em>, 81(8), 3684-3690. <strong>pp. 3684-3688</strong>.</li>

            <li>Lemkul, J. A. (2019). From Proteins to Perturbed Hamiltonians: A Suite of Tutorials for the GROMACS-2018 Molecular Simulation Package. <em>Living Journal of Computational Molecular Science</em>, 1(1), 5068. <strong>pp. 10-25</strong>.</li>

            <li>Michaud-Agrawal, N., Denning, E. J., Woolf, T. B., & Beckstein, O. (2011). MDAnalysis: A toolkit for the analysis of molecular dynamics simulations. <em>Journal of Computational Chemistry</em>, 32(10), 2319-2327. <strong>pp. 2320-2325</strong>.</li>

            <li>van der Spoel, D., Lindahl, E., Hess, B., Groenhof, G., Mark, A. E., & Berendsen, H. J. C. (2005). GROMACS: Fast, flexible, and free. <em>Journal of Computational Chemistry</em>, 26(16), 1701-1718. <strong>pp. 1705-1712</strong>.</li>
        </ol>

        <div class="nav-buttons">
            <a href="chapter-2.html" class="btn">â† Chapter 2: ã‚¿ãƒ³ãƒ‘ã‚¯è³ªãƒ»æ°´ç³»ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—</a>
            <a href="chapter-4.html" class="btn">Chapter 4: è§£æãƒ„ãƒ¼ãƒ«ã¨Pythonçµ±åˆ â†’</a>
        </div>
    </div>

    <script>
        mermaid.initialize({ startOnLoad: true, theme: 'default' });
    </script>
</body>
</html>