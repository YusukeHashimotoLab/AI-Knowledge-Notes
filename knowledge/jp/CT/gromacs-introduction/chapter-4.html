<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 4: è§£æãƒ„ãƒ¼ãƒ«ã¨Pythonçµ±åˆ - GROMACSå…¥é–€</title>

    <!-- MathJax 3.x -->
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <!-- Mermaid -->
    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>

    <!-- Prism.js -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>

    <style>
        :root {
            --ct-gradient-start: #11998e;
            --ct-gradient-end: #38ef7d;
            --text-primary: #2c3e50;
            --text-secondary: #546e7a;
            --bg-light: #f8f9fa;
            --border-color: #e0e0e0;
            --code-bg: #1e1e1e;
            --shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            line-height: 1.8;
            color: var(--text-primary);
            background: linear-gradient(135deg, var(--ct-gradient-start), var(--ct-gradient-end));
            min-height: 100vh;
            padding: 2rem 1rem;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            background: white;
            padding: 3rem;
            border-radius: 16px;
            box-shadow: var(--shadow);
        }

        h1, h2, h3 {
            background: linear-gradient(135deg, var(--ct-gradient-start), var(--ct-gradient-end));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin: 2rem 0 1rem 0;
        }

        h1 { font-size: 2.5rem; border-bottom: 3px solid var(--ct-gradient-end); padding-bottom: 0.5rem; }
        h2 { font-size: 2rem; margin-top: 3rem; }
        h3 { font-size: 1.5rem; margin-top: 2rem; }

        p { margin: 1rem 0; color: var(--text-secondary); }

        pre {
            background: var(--code-bg);
            padding: 1.5rem;
            border-radius: 8px;
            overflow-x: auto;
            margin: 1.5rem 0;
            box-shadow: var(--shadow);
        }

        code {
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.9rem;
        }

        .info-box {
            background: linear-gradient(135deg, rgba(17,153,142,0.1), rgba(56,239,125,0.1));
            border-left: 4px solid var(--ct-gradient-start);
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-radius: 0 8px 8px 0;
        }

        .warning-box {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-radius: 0 8px 8px 0;
        }

        .mermaid {
            background: white;
            padding: 2rem;
            border-radius: 8px;
            margin: 2rem 0;
            box-shadow: var(--shadow);
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 2rem 0;
            box-shadow: var(--shadow);
            border-radius: 8px;
            overflow: hidden;
        }

        th, td {
            padding: 1rem;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
        }

        th {
            background: linear-gradient(135deg, var(--ct-gradient-start), var(--ct-gradient-end));
            color: white;
            font-weight: 600;
        }

        tr:hover {
            background: var(--bg-light);
        }

        .nav-buttons {
            display: flex;
            justify-content: space-between;
            margin-top: 3rem;
            padding-top: 2rem;
            border-top: 2px solid var(--border-color);
        }

        .btn {
            padding: 0.8rem 2rem;
            background: linear-gradient(135deg, var(--ct-gradient-start), var(--ct-gradient-end));
            color: white;
            text-decoration: none;
            border-radius: 8px;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: var(--shadow);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }

        @media (max-width: 768px) {
            .container { padding: 1.5rem; }
            h1 { font-size: 2rem; }
            h2 { font-size: 1.5rem; }
            table { font-size: 0.9rem; }
            .nav-buttons { flex-direction: column; gap: 1rem; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Chapter 4: è§£æãƒ„ãƒ¼ãƒ«ã¨Pythonçµ±åˆ</h1>

        <div class="info-box">
            <strong>å­¦ç¿’ç›®æ¨™</strong>
            <ul>
                <li>GROMACSæ¨™æº–è§£æãƒ„ãƒ¼ãƒ«ï¼ˆgmx rms, gmx rmsf, gmx hbondç­‰ï¼‰ã®ä½¿ã„æ–¹ã‚’ç¿’å¾—ã™ã‚‹</li>
                <li>MDAnalysisã‚’ä½¿ã£ãŸé«˜åº¦ãªè»Œé“è§£ææ‰‹æ³•ã‚’å­¦ã¶</li>
                <li>æ°´ç´ çµåˆã€äºŒæ¬¡æ§‹é€ ã€æº¶åª’å’Œæ§‹é€ ã®è§£æãŒã§ãã‚‹</li>
                <li>è¤‡æ•°è»Œé“ã®çµ±åˆè§£æã¨ãƒãƒƒãƒå‡¦ç†ã‚’å®Ÿè£…ã§ãã‚‹</li>
            </ul>
        </div>

        <h2>4.1 GROMACSæ¨™æº–è§£æãƒ„ãƒ¼ãƒ«ã®åŸºç¤</h2>

        <p>
        GROMACSã«ã¯50ç¨®é¡ä»¥ä¸Šã®è§£æãƒ„ãƒ¼ãƒ«ãŒæ¨™æº–æ­è¼‰ã•ã‚Œã¦ã„ã¾ã™ã€‚ã“ã‚Œã‚‰ã¯<code>gmx</code>ã‚³ãƒãƒ³ãƒ‰ã®ã‚µãƒ–ã‚³ãƒãƒ³ãƒ‰ã¨ã—ã¦å®Ÿè¡Œã•ã‚Œã¾ã™ã€‚
        </p>

        <table>
            <thead>
                <tr>
                    <th>ãƒ„ãƒ¼ãƒ«</th>
                    <th>æ©Ÿèƒ½</th>
                    <th>å‡ºåŠ›</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>gmx rms</td>
                    <td>RMSDè¨ˆç®—ï¼ˆå…¨ä½“æ§‹é€ å¤‰åŒ–ï¼‰</td>
                    <td>XVGãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆæ™‚é–“ vs RMSDï¼‰</td>
                </tr>
                <tr>
                    <td>gmx rmsf</td>
                    <td>RMSFè¨ˆç®—ï¼ˆæ®‹åŸºã”ã¨ã®æºã‚‰ãï¼‰</td>
                    <td>XVGãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆæ®‹åŸº vs RMSFï¼‰</td>
                </tr>
                <tr>
                    <td>gmx hbond</td>
                    <td>æ°´ç´ çµåˆè§£æ</td>
                    <td>æ°´ç´ çµåˆæ•°ã€å¯¿å‘½ã€è·é›¢åˆ†å¸ƒ</td>
                </tr>
                <tr>
                    <td>gmx sasa</td>
                    <td>æº¶åª’æ¥è§¦è¡¨é¢ç©ï¼ˆSASAï¼‰</td>
                    <td>å…¨ä½“ãƒ»æ®‹åŸºã”ã¨ã®SASA</td>
                </tr>
                <tr>
                    <td>gmx gyrate</td>
                    <td>å›è»¢åŠå¾„ï¼ˆRgï¼‰è¨ˆç®—</td>
                    <td>ã‚¿ãƒ³ãƒ‘ã‚¯è³ªã®ã‚³ãƒ³ãƒ‘ã‚¯ãƒˆã•</td>
                </tr>
                <tr>
                    <td>gmx do_dssp</td>
                    <td>äºŒæ¬¡æ§‹é€ è§£æï¼ˆDSSPï¼‰</td>
                    <td>Î±-helixã€Î²-sheetæ¯”ç‡ã®æ™‚é–“å¤‰åŒ–</td>
                </tr>
                <tr>
                    <td>gmx rdf</td>
                    <td>å‹•å¾„åˆ†å¸ƒé–¢æ•°ï¼ˆRDFï¼‰</td>
                    <td>åŸå­é–“è·é›¢åˆ†å¸ƒ</td>
                </tr>
            </tbody>
        </table>

        <h3>4.1.1 RMSDãƒ»RMSFè§£æã®å®Ÿè·µ</h3>

        <pre><code class="language-bash"># RMSDè¨ˆç®—ï¼ˆbackboneã‚’å‚ç…§æ§‹é€ ã«é‡ã­åˆã‚ã›ï¼‰
echo "4 4" | gmx rms -s md_0_10.tpr -f md_0_10.xtc -o rmsd.xvg -tu ns

# èª¬æ˜ï¼š
# 4 4 = Backbone Backboneï¼ˆ1ã¤ç›®ã¯é‡ã­åˆã‚ã›åŸºæº–ã€2ã¤ç›®ã¯RMSDè¨ˆç®—å¯¾è±¡ï¼‰
# -tu ns = æ™‚é–“å˜ä½ã‚’ãƒŠãƒç§’ã«æŒ‡å®š

# CÎ±åŸå­ã®RMSFè¨ˆç®—
echo "3" | gmx rmsf -s md_0_10.tpr -f md_0_10.xtc -o rmsf.xvg -res

# èª¬æ˜ï¼š
# 3 = C-alphaï¼ˆCÎ±åŸå­ã®ã¿é¸æŠï¼‰
# -res = æ®‹åŸºã”ã¨ã«å¹³å‡åŒ–

# çµæœã‚’ãƒ—ãƒ­ãƒƒãƒˆï¼ˆxmgraceä½¿ç”¨ï¼‰
xmgrace rmsd.xvg
xmgrace rmsf.xvg</code></pre>

        <h3>4.1.2 æ°´ç´ çµåˆè§£æ</h3>

        <p>
        æ°´ç´ çµåˆã¯ã‚¿ãƒ³ãƒ‘ã‚¯è³ªã®å®‰å®šæ€§ã¨æ§‹é€ ç¶­æŒã«é‡è¦ã§ã™ã€‚GROMACSã§ã¯å¹¾ä½•å­¦çš„åŸºæº–ã§æ°´ç´ çµåˆã‚’åˆ¤å®šã—ã¾ã™ï¼š
        </p>

        <p>
        \[
        \text{æ°´ç´ çµåˆæ¡ä»¶: } r_{\text{D-A}} < 3.5 \text{ Ã… } \land \angle \text{D-H-A} > 150Â°
        \]
        </p>

        <pre><code class="language-bash"># ã‚¿ãƒ³ãƒ‘ã‚¯è³ªå†…éƒ¨ã®æ°´ç´ çµåˆï¼ˆä¸»é–é–“ï¼‰
echo "1 1" | gmx hbond -s md_0_10.tpr -f md_0_10.xtc -num hbnum.xvg -dist hbdist.xvg -ang hbang.xvg

# ã‚¿ãƒ³ãƒ‘ã‚¯è³ª-æ°´é–“ã®æ°´ç´ çµåˆ
echo "1 12" | gmx hbond -s md_0_10.tpr -f md_0_10.xtc -num hbnum_protein_water.xvg

# èª¬æ˜ï¼š
# 1 = Protein
# 12 = Water
# -num = æ°´ç´ çµåˆæ•°ã®æ™‚é–“å¤‰åŒ–
# -dist = ãƒ‰ãƒŠãƒ¼-ã‚¢ã‚¯ã‚»ãƒ—ã‚¿ãƒ¼è·é›¢åˆ†å¸ƒ
# -ang = çµåˆè§’åº¦åˆ†å¸ƒ</code></pre>

        <h3>4.1.3 Pythonã«ã‚ˆã‚‹è§£æçµæœã®å¯è¦–åŒ–</h3>

        <pre><code class="language-python">#!/usr/bin/env python3
"""
GROMACS XVGè§£æçµæœã®çµ±åˆå¯è¦–åŒ–
- RMSD, RMSF, æ°´ç´ çµåˆæ•°ã‚’ä¸€æ‹¬ãƒ—ãƒ­ãƒƒãƒˆ
"""
import numpy as np
import matplotlib.pyplot as plt

def parse_xvg(xvg_file):
    """XVGãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ‘ãƒ¼ã‚¹"""
    time, values = [], []
    with open(xvg_file, 'r') as f:
        for line in f:
            if line.startswith('#') or line.startswith('@'):
                continue
            parts = line.split()
            if len(parts) >= 2:
                time.append(float(parts[0]))
                values.append(float(parts[1]))
    return np.array(time), np.array(values)

def plot_gromacs_analysis(rmsd_xvg, rmsf_xvg, hbond_xvg, output='gromacs_analysis.png'):
    """
    GROMACSè§£æçµæœã®çµ±åˆãƒ—ãƒ­ãƒƒãƒˆ
    """
    # ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿
    time_rmsd, rmsd = parse_xvg(rmsd_xvg)
    resid, rmsf = parse_xvg(rmsf_xvg)
    time_hb, hbonds = parse_xvg(hbond_xvg)

    # 3x1ã‚µãƒ–ãƒ—ãƒ­ãƒƒãƒˆ
    fig, (ax1, ax2, ax3) = plt.subplots(3, 1, figsize=(12, 12))

    # RMSD
    ax1.plot(time_rmsd, rmsd, 'b-', linewidth=2)
    ax1.set_xlabel('Time (ns)', fontsize=12)
    ax1.set_ylabel('RMSD (nm)', fontsize=12)
    ax1.set_title('Backbone RMSD', fontsize=14, fontweight='bold')
    ax1.grid(True, alpha=0.3)
    ax1.text(0.02, 0.95, f'Mean: {rmsd.mean():.3f} Â± {rmsd.std():.3f} nm',
             transform=ax1.transAxes, verticalalignment='top',
             bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.5))

    # RMSF
    ax2.plot(resid, rmsf, 'r-', linewidth=2)
    ax2.set_xlabel('Residue Number', fontsize=12)
    ax2.set_ylabel('RMSF (nm)', fontsize=12)
    ax2.set_title('Per-Residue RMSF (CÎ± atoms)', fontsize=14, fontweight='bold')
    ax2.grid(True, alpha=0.3)

    # é«˜RMSFé ˜åŸŸã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆ
    high_rmsf_threshold = rmsf.mean() + 2 * rmsf.std()
    high_rmsf_mask = rmsf > high_rmsf_threshold
    if np.any(high_rmsf_mask):
        ax2.fill_between(resid, 0, rmsf, where=high_rmsf_mask,
                         color='red', alpha=0.3, label='High flexibility')
        ax2.legend()

    # æ°´ç´ çµåˆæ•°
    ax3.plot(time_hb, hbonds, 'g-', linewidth=2)
    ax3.set_xlabel('Time (ns)', fontsize=12)
    ax3.set_ylabel('Number of H-bonds', fontsize=12)
    ax3.set_title('Hydrogen Bonds vs Time', fontsize=14, fontweight='bold')
    ax3.grid(True, alpha=0.3)
    ax3.text(0.02, 0.95, f'Mean: {hbonds.mean():.1f} Â± {hbonds.std():.1f}',
             transform=ax3.transAxes, verticalalignment='top',
             bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.5))

    plt.tight_layout()
    plt.savefig(output, dpi=300, bbox_inches='tight')
    print(f"âœ… çµ±åˆè§£æãƒ—ãƒ­ãƒƒãƒˆä¿å­˜: {output}")

    # ã‚µãƒãƒªãƒ¼ãƒ¬ãƒãƒ¼ãƒˆ
    print(f"\nğŸ“Š è§£æã‚µãƒãƒªãƒ¼:")
    print(f"   RMSD: {rmsd.mean():.3f} Â± {rmsd.std():.3f} nm")
    print(f"   RMSF: {rmsf.mean():.3f} Â± {rmsf.std():.3f} nm (æœ€å¤§: {rmsf.max():.3f} nm at residue {resid[rmsf.argmax()]:.0f})")
    print(f"   æ°´ç´ çµåˆ: {hbonds.mean():.1f} Â± {hbonds.std():.1f} æœ¬")

if __name__ == "__main__":
    import sys
    if len(sys.argv) < 4:
        print("Usage: python gromacs_analysis.py rmsd.xvg rmsf.xvg hbnum.xvg")
        sys.exit(1)

    rmsd_xvg = sys.argv[1]
    rmsf_xvg = sys.argv[2]
    hbond_xvg = sys.argv[3]

    plot_gromacs_analysis(rmsd_xvg, rmsf_xvg, hbond_xvg)</code></pre>

        <h2>4.2 MDAnalysisã«ã‚ˆã‚‹é«˜åº¦ãªè§£æ</h2>

        <p>
        <strong>MDAnalysis</strong>ã¯Pythonãƒ™ãƒ¼ã‚¹ã®MDè§£æãƒ©ã‚¤ãƒ–ãƒ©ãƒªã§ã€GROMACSãƒ„ãƒ¼ãƒ«ã§ã¯å›°é›£ãªè¤‡é›‘ãªè§£æã‚’å¯èƒ½ã«ã—ã¾ã™ã€‚
        NumPyãƒ©ã‚¤ã‚¯ãªAPIã§åŸå­é¸æŠã€è»Œé“æ“ä½œã€ã‚«ã‚¹ã‚¿ãƒ è¨ˆç®—ãŒã§ãã¾ã™ã€‚
        </p>

        <h3>4.2.1 MDAnalysisã®åŸºæœ¬æ“ä½œ</h3>

        <pre><code class="language-python">#!/usr/bin/env python3
"""
MDAnalysisåŸºæœ¬æ“ä½œ
- Universeæ§‹ç¯‰ã€åŸå­é¸æŠã€è»Œé“ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
"""
import MDAnalysis as mda
import numpy as np

def mdanalysis_basics(topology, trajectory):
    """
    MDAnalysisã®åŸºæœ¬ãƒ‘ã‚¿ãƒ¼ãƒ³
    """
    # Universeã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæ§‹ç¯‰
    u = mda.Universe(topology, trajectory)

    print("ğŸ“¦ Universeã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæƒ…å ±:")
    print(f"   åŸå­æ•°: {len(u.atoms)}")
    print(f"   æ®‹åŸºæ•°: {len(u.residues)}")
    print(f"   ã‚»ã‚°ãƒ¡ãƒ³ãƒˆæ•°: {len(u.segments)}")
    print(f"   ãƒ•ãƒ¬ãƒ¼ãƒ æ•°: {len(u.trajectory)}")
    print(f"   æ™‚é–“ç¯„å›²: {u.trajectory[0].time:.2f} - {u.trajectory[-1].time:.2f} ps")

    # åŸå­é¸æŠï¼ˆGROMACSäº’æ› + VMDé¢¨ï¼‰
    protein = u.select_atoms('protein')
    backbone = u.select_atoms('backbone')
    ca_atoms = u.select_atoms('protein and name CA')
    water = u.select_atoms('resname SOL or resname TIP3')
    ions = u.select_atoms('resname NA or resname CL')

    print(f"\nğŸ” åŸå­é¸æŠ:")
    print(f"   ã‚¿ãƒ³ãƒ‘ã‚¯è³ª: {len(protein)} åŸå­")
    print(f"   ãƒãƒƒã‚¯ãƒœãƒ¼ãƒ³: {len(backbone)} åŸå­")
    print(f"   CÎ±åŸå­: {len(ca_atoms)} åŸå­")
    print(f"   æ°´åˆ†å­: {len(water)} åŸå­")
    print(f"   ã‚¤ã‚ªãƒ³: {len(ions)} åŸå­")

    # è»Œé“ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
    print(f"\nâ±ï¸ è»Œé“ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆæœ€åˆã®5ãƒ•ãƒ¬ãƒ¼ãƒ ï¼‰:")
    for i, ts in enumerate(u.trajectory[:5]):
        print(f"   Frame {i}: Time = {ts.time:.2f} ps, Box = {ts.dimensions[:3]}")

    # è³ªé‡ä¸­å¿ƒï¼ˆCenter of Massï¼‰è¨ˆç®—
    protein_com = protein.center_of_mass()
    print(f"\nğŸ“ ã‚¿ãƒ³ãƒ‘ã‚¯è³ªè³ªé‡ä¸­å¿ƒ (æœ€çµ‚ãƒ•ãƒ¬ãƒ¼ãƒ ): {protein_com}")

    # å›è»¢åŠå¾„ï¼ˆRadius of Gyrationï¼‰
    protein_rg = protein.radius_of_gyration()
    print(f"   å›è»¢åŠå¾„ Rg: {protein_rg:.3f} Ã…")

if __name__ == "__main__":
    import sys
    if len(sys.argv) < 3:
        print("Usage: python mdanalysis_basics.py topology trajectory")
        sys.exit(1)

    mdanalysis_basics(sys.argv[1], sys.argv[2])</code></pre>

        <h3>4.2.2 è·é›¢è§£æã¨å‹•å¾„åˆ†å¸ƒé–¢æ•°ï¼ˆRDFï¼‰</h3>

        <pre><code class="language-python">#!/usr/bin/env python3
"""
å‹•å¾„åˆ†å¸ƒé–¢æ•°ï¼ˆRDFï¼‰ã®è¨ˆç®—
- ã‚¿ãƒ³ãƒ‘ã‚¯è³ª-æ°´é–“ã®RDF
- ã‚¤ã‚ªãƒ³-ã‚¿ãƒ³ãƒ‘ã‚¯è³ªé–“ã®RDF
"""
import MDAnalysis as mda
from MDAnalysis.analysis import rdf
import matplotlib.pyplot as plt
import numpy as np

def calculate_rdf(topology, trajectory, selection1, selection2,
                  nbins=75, range_rdf=(0.0, 15.0), output='rdf.png'):
    """
    å‹•å¾„åˆ†å¸ƒé–¢æ•°ï¼ˆRDFï¼‰ã‚’è¨ˆç®—

    Parameters
    ----------
    topology : str
        ãƒˆãƒãƒ­ã‚¸ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«
    trajectory : str
        è»Œé“ãƒ•ã‚¡ã‚¤ãƒ«
    selection1 : str
        ä¸­å¿ƒã¨ãªã‚‹åŸå­ç¾¤ã®é¸æŠæ–‡å­—åˆ—
    selection2 : str
        å‘¨è¾ºã®åŸå­ç¾¤ã®é¸æŠæ–‡å­—åˆ—
    nbins : int
        ãƒ“ãƒ³ã®æ•°
    range_rdf : tuple
        RDFã®è¨ˆç®—ç¯„å›² (Ã…)
    """
    u = mda.Universe(topology, trajectory)

    # åŸå­é¸æŠ
    group1 = u.select_atoms(selection1)
    group2 = u.select_atoms(selection2)

    print(f"ğŸ“Š RDFè¨ˆç®—:")
    print(f"   ä¸­å¿ƒã‚°ãƒ«ãƒ¼ãƒ—: {selection1} ({len(group1)} åŸå­)")
    print(f"   å‘¨è¾ºã‚°ãƒ«ãƒ¼ãƒ—: {selection2} ({len(group2)} åŸå­)")

    # RDFè¨ˆç®—
    rdf_calc = rdf.InterRDF(group1, group2, nbins=nbins, range=range_rdf)
    rdf_calc.run()

    bins = rdf_calc.results.bins
    rdf_values = rdf_calc.results.rdf

    # ãƒ—ãƒ­ãƒƒãƒˆ
    fig, ax = plt.subplots(figsize=(10, 6))

    ax.plot(bins, rdf_values, 'b-', linewidth=2, label=f'{selection1} - {selection2}')
    ax.axhline(y=1.0, color='r', linestyle='--', linewidth=1, label='Bulk density')
    ax.set_xlabel('Distance (Ã…)', fontsize=12)
    ax.set_ylabel('g(r)', fontsize=12)
    ax.set_title('Radial Distribution Function', fontsize=14, fontweight='bold')
    ax.legend()
    ax.grid(True, alpha=0.3)

    plt.tight_layout()
    plt.savefig(output, dpi=300, bbox_inches='tight')
    print(f"âœ… RDFãƒ—ãƒ­ãƒƒãƒˆä¿å­˜: {output}")

    # ãƒ”ãƒ¼ã‚¯æ¤œå‡º
    peaks = []
    for i in range(1, len(rdf_values) - 1):
        if rdf_values[i] > rdf_values[i-1] and rdf_values[i] > rdf_values[i+1]:
            if rdf_values[i] > 1.5:  # æœ‰æ„ãªãƒ”ãƒ¼ã‚¯ã®ã¿
                peaks.append((bins[i], rdf_values[i]))

    if peaks:
        print(f"\nğŸ” æ¤œå‡ºã•ã‚ŒãŸRDFãƒ”ãƒ¼ã‚¯:")
        for r, g_r in peaks[:3]:  # æœ€åˆã®3ãƒ”ãƒ¼ã‚¯
            print(f"   r = {r:.2f} Ã…, g(r) = {g_r:.2f}")

    return bins, rdf_values

if __name__ == "__main__":
    import sys
    if len(sys.argv) < 4:
        print("Usage: python rdf_analysis.py topology trajectory selection1 selection2")
        print("  Example: python rdf_analysis.py md.tpr md.xtc 'protein' 'resname SOL and name OW'")
        sys.exit(1)

    topology = sys.argv[1]
    trajectory = sys.argv[2]
    sel1 = sys.argv[3]
    sel2 = sys.argv[4]

    calculate_rdf(topology, trajectory, sel1, sel2)</code></pre>

        <h3>4.2.3 äºŒæ¬¡æ§‹é€ è§£æï¼ˆDSSPçµ±åˆï¼‰</h3>

        <pre><code class="language-python">#!/usr/bin/env python3
"""
äºŒæ¬¡æ§‹é€ è§£æï¼ˆDSSPï¼‰
- Î±-helixã€Î²-sheetã€ã‚³ã‚¤ãƒ«ã®æ™‚é–“å¤‰åŒ–
- æ®‹åŸºã”ã¨ã®äºŒæ¬¡æ§‹é€ é »åº¦
"""
import MDAnalysis as mda
from MDAnalysis.analysis.dssp import DSSP
import matplotlib.pyplot as plt
import numpy as np

def analyze_secondary_structure(topology, trajectory, output='dssp_analysis.png'):
    """
    äºŒæ¬¡æ§‹é€ ã®æ™‚é–“ç™ºå±•ã‚’è§£æ

    Parameters
    ----------
    topology : str
        ãƒˆãƒãƒ­ã‚¸ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«
    trajectory : str
        è»Œé“ãƒ•ã‚¡ã‚¤ãƒ«

    Note
    ----
    DSSPãƒã‚¤ãƒŠãƒªï¼ˆmkdsspï¼‰ãŒå¿…è¦: conda install -c salilab dssp
    """
    u = mda.Universe(topology, trajectory)

    # DSSPè§£æå®Ÿè¡Œ
    print("â³ DSSPè§£æå®Ÿè¡Œä¸­...")
    dssp = DSSP(u, executable='mkdssp')
    dssp.run()

    # äºŒæ¬¡æ§‹é€ ã‚³ãƒ¼ãƒ‰
    # H = Î±-helix, E = Î²-sheet, C = Coil/Turn, ãã®ä»–
    ss_codes = dssp.results.dssp

    # ãƒ•ãƒ¬ãƒ¼ãƒ ã”ã¨ã®äºŒæ¬¡æ§‹é€ æ¯”ç‡
    n_frames = len(ss_codes)
    n_residues = len(ss_codes[0])

    helix_fraction = []
    sheet_fraction = []
    coil_fraction = []

    for frame in ss_codes:
        helix_count = np.sum([c == 'H' for c in frame])
        sheet_count = np.sum([c == 'E' for c in frame])
        coil_count = n_residues - helix_count - sheet_count

        helix_fraction.append(helix_count / n_residues * 100)
        sheet_fraction.append(sheet_count / n_residues * 100)
        coil_fraction.append(coil_count / n_residues * 100)

    helix_fraction = np.array(helix_fraction)
    sheet_fraction = np.array(sheet_fraction)
    coil_fraction = np.array(coil_fraction)

    # æ™‚é–“è»¸
    times = [ts.time for ts in u.trajectory] / 1000  # ps â†’ ns

    # ãƒ—ãƒ­ãƒƒãƒˆ
    fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 10))

    # æ™‚é–“å¤‰åŒ–
    ax1.plot(times, helix_fraction, 'r-', linewidth=2, label='Î±-Helix')
    ax1.plot(times, sheet_fraction, 'b-', linewidth=2, label='Î²-Sheet')
    ax1.plot(times, coil_fraction, 'g-', linewidth=2, label='Coil/Turn')
    ax1.set_xlabel('Time (ns)', fontsize=12)
    ax1.set_ylabel('Secondary Structure (%)', fontsize=12)
    ax1.set_title('Secondary Structure vs Time', fontsize=14, fontweight='bold')
    ax1.legend()
    ax1.grid(True, alpha=0.3)

    # æ®‹åŸºã”ã¨ã®äºŒæ¬¡æ§‹é€ é »åº¦ï¼ˆãƒ’ãƒ¼ãƒˆãƒãƒƒãƒ—ï¼‰
    # å„æ®‹åŸºã§æœ€ã‚‚é »ç¹ãªäºŒæ¬¡æ§‹é€ ã‚’è¨ˆç®—
    ss_matrix = np.zeros((n_residues, 3))  # helix, sheet, coil

    for frame in ss_codes:
        for i, code in enumerate(frame):
            if code == 'H':
                ss_matrix[i, 0] += 1
            elif code == 'E':
                ss_matrix[i, 1] += 1
            else:
                ss_matrix[i, 2] += 1

    ss_matrix = ss_matrix / n_frames * 100  # ãƒ‘ãƒ¼ã‚»ãƒ³ãƒˆ

    residue_numbers = np.arange(1, n_residues + 1)
    ax2.plot(residue_numbers, ss_matrix[:, 0], 'r-', linewidth=2, label='Î±-Helix')
    ax2.plot(residue_numbers, ss_matrix[:, 1], 'b-', linewidth=2, label='Î²-Sheet')
    ax2.plot(residue_numbers, ss_matrix[:, 2], 'g-', linewidth=2, label='Coil/Turn')
    ax2.set_xlabel('Residue Number', fontsize=12)
    ax2.set_ylabel('Frequency (%)', fontsize=12)
    ax2.set_title('Per-Residue Secondary Structure Frequency', fontsize=14, fontweight='bold')
    ax2.legend()
    ax2.grid(True, alpha=0.3)

    plt.tight_layout()
    plt.savefig(output, dpi=300, bbox_inches='tight')
    print(f"âœ… DSSPè§£æãƒ—ãƒ­ãƒƒãƒˆä¿å­˜: {output}")

    # çµ±è¨ˆ
    print(f"\nğŸ“Š äºŒæ¬¡æ§‹é€ çµ±è¨ˆï¼ˆå…¨ãƒ•ãƒ¬ãƒ¼ãƒ å¹³å‡ï¼‰:")
    print(f"   Î±-Helix: {helix_fraction.mean():.1f} Â± {helix_fraction.std():.1f} %")
    print(f"   Î²-Sheet: {sheet_fraction.mean():.1f} Â± {sheet_fraction.std():.1f} %")
    print(f"   Coil/Turn: {coil_fraction.mean():.1f} Â± {coil_fraction.std():.1f} %")

if __name__ == "__main__":
    import sys
    if len(sys.argv) < 3:
        print("Usage: python dssp_analysis.py topology trajectory")
        sys.exit(1)

    analyze_secondary_structure(sys.argv[1], sys.argv[2])</code></pre>

        <div class="mermaid">
flowchart TD
    A[MDãƒˆãƒ©ã‚¸ã‚§ã‚¯ãƒˆãƒª<br/>md.xtc] --> B[GROMACSè§£æãƒ„ãƒ¼ãƒ«]
    A --> C[MDAnalysis]
    B --> D[RMSD/RMSF<br/>æ°´ç´ çµåˆ<br/>SASA]
    C --> E[RDF<br/>DSSP<br/>ã‚«ã‚¹ã‚¿ãƒ è§£æ]
    D --> F[çµ±åˆå¯è¦–åŒ–<br/>Matplotlib]
    E --> F
        </div>

        <h2>4.3 è¤‡æ•°è»Œé“ã®çµ±åˆè§£æ</h2>

        <p>
        é•·æ™‚é–“MDï¼ˆæ•°ç™¾nsã€œÎ¼sï¼‰ã§ã¯ã€è¤‡æ•°ã®è»Œé“ãƒ•ã‚¡ã‚¤ãƒ«ã‚’çµåˆã—ã¦è§£æã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚
        ã¾ãŸã€è¤‡æ•°ã®ãƒ¬ãƒ—ãƒªã‚«ï¼ˆç‹¬ç«‹å®Ÿè¡Œï¼‰ã®çµ±è¨ˆè§£æã‚‚é‡è¦ã§ã™ã€‚
        </p>

        <h3>4.3.1 è»Œé“ã®çµåˆ</h3>

        <pre><code class="language-bash"># è¤‡æ•°XTCãƒ•ã‚¡ã‚¤ãƒ«ã®çµåˆ
gmx trjcat -f md_0_10.xtc md_10_20.xtc md_20_30.xtc -o md_0_30.xtc

# æ™‚é–“é–“éš”ã‚’æŒ‡å®šã—ã¦ãƒ•ãƒ¬ãƒ¼ãƒ å‰Šæ¸›ï¼ˆ10 psã”ã¨ã«ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ï¼‰
gmx trjconv -f md_0_30.xtc -o md_0_30_dt10.xtc -dt 10

# PBCå‡¦ç†ï¼ˆå‘¨æœŸå¢ƒç•Œæ¡ä»¶ã®é™¤å»ã€ã‚¿ãƒ³ãƒ‘ã‚¯è³ªã‚’ä¸­å¿ƒã«é…ç½®ï¼‰
echo "1 0" | gmx trjconv -s md.tpr -f md_0_30.xtc -o md_0_30_center.xtc -center -pbc mol -ur compact

# èª¬æ˜ï¼š
# 1 = Proteinï¼ˆä¸­å¿ƒã«é…ç½®ã™ã‚‹ã‚°ãƒ«ãƒ¼ãƒ—ï¼‰
# 0 = Systemï¼ˆå‡ºåŠ›ã™ã‚‹ã‚°ãƒ«ãƒ¼ãƒ—ï¼‰
# -center = ã‚¿ãƒ³ãƒ‘ã‚¯è³ªã‚’ä¸­å¿ƒã«
# -pbc mol = åˆ†å­ãŒåˆ†å‰²ã•ã‚Œãªã„ã‚ˆã†ã«PBCå‡¦ç†
# -ur compact = ã‚³ãƒ³ãƒ‘ã‚¯ãƒˆãªå˜ä½ã‚»ãƒ«è¡¨ç¾</code></pre>

        <h3>4.3.2 ãƒ¬ãƒ—ãƒªã‚«é–“ã®çµ±è¨ˆè§£æ</h3>

        <pre><code class="language-python">#!/usr/bin/env python3
"""
è¤‡æ•°ãƒ¬ãƒ—ãƒªã‚«MDã®çµ±è¨ˆè§£æ
- ãƒ¬ãƒ—ãƒªã‚«ã”ã¨ã®RMSDè¨ˆç®—
- ãƒ¬ãƒ—ãƒªã‚«é–“ã®å¹³å‡ã¨æ¨™æº–åå·®
- åæŸæ€§ã®è©•ä¾¡
"""
import MDAnalysis as mda
from MDAnalysis.analysis import rms
import matplotlib.pyplot as plt
import numpy as np
from pathlib import Path

def analyze_replicas(topology_pattern, trajectory_pattern, n_replicas,
                     equilibration_ns=2.0, output='replica_analysis.png'):
    """
    è¤‡æ•°ãƒ¬ãƒ—ãƒªã‚«ã®çµ±è¨ˆè§£æ

    Parameters
    ----------
    topology_pattern : str
        ãƒˆãƒãƒ­ã‚¸ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆä¾‹: 'replica_{}.tpr'ï¼‰
    trajectory_pattern : str
        è»Œé“ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆä¾‹: 'replica_{}.xtc'ï¼‰
    n_replicas : int
        ãƒ¬ãƒ—ãƒªã‚«æ•°
    equilibration_ns : float
        é™¤å¤–ã™ã‚‹å¹³è¡¡åŒ–æœŸé–“ (ns)
    """
    all_rmsd = []
    all_times = []

    print(f"ğŸ“Š {n_replicas}ãƒ¬ãƒ—ãƒªã‚«ã®è§£æé–‹å§‹...")

    for i in range(n_replicas):
        topology = topology_pattern.format(i+1)
        trajectory = trajectory_pattern.format(i+1)

        if not Path(topology).exists() or not Path(trajectory).exists():
            print(f"âš ï¸ Replica {i+1} ã®ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ã‚¹ã‚­ãƒƒãƒ—")
            continue

        u = mda.Universe(topology, trajectory)
        ref = mda.Universe(topology, trajectory)

        # RMSDè¨ˆç®—
        R = rms.RMSD(u, ref, select='backbone', groupselections=['backbone'])
        R.run()

        time = R.results.rmsd[:, 1] / 1000  # ps â†’ ns
        rmsd = R.results.rmsd[:, 2]  # Ã…

        # å¹³è¡¡åŒ–æœŸé–“ã‚’é™¤å¤–
        mask = time >= equilibration_ns
        time_analysis = time[mask]
        rmsd_analysis = rmsd[mask]

        all_times.append(time_analysis)
        all_rmsd.append(rmsd_analysis)

        print(f"   Replica {i+1}: å¹³å‡RMSD = {rmsd_analysis.mean():.3f} Â± {rmsd_analysis.std():.3f} Ã…")

    # çµ±è¨ˆè§£æï¼ˆå…¨ãƒ¬ãƒ—ãƒªã‚«ã®å¹³å‡ã¨æ¨™æº–åå·®ï¼‰
    # æ™‚é–“è»¸ã‚’æƒãˆã‚‹ï¼ˆæœ€çŸ­ã®ãƒˆãƒ©ã‚¸ã‚§ã‚¯ãƒˆãƒªã«åˆã‚ã›ã‚‹ï¼‰
    min_length = min([len(t) for t in all_times])
    all_rmsd_aligned = np.array([r[:min_length] for r in all_rmsd])
    time_aligned = all_times[0][:min_length]

    mean_rmsd = all_rmsd_aligned.mean(axis=0)
    std_rmsd = all_rmsd_aligned.std(axis=0)

    # ãƒ—ãƒ­ãƒƒãƒˆ
    fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 10))

    # å„ãƒ¬ãƒ—ãƒªã‚«ã®RMSD
    for i, (time, rmsd) in enumerate(zip(all_times, all_rmsd)):
        ax1.plot(time, rmsd, alpha=0.5, linewidth=1, label=f'Replica {i+1}')

    ax1.plot(time_aligned, mean_rmsd, 'k-', linewidth=3, label='Mean')
    ax1.fill_between(time_aligned, mean_rmsd - std_rmsd, mean_rmsd + std_rmsd,
                     color='gray', alpha=0.3, label='Â±1 SD')
    ax1.set_xlabel('Time (ns)', fontsize=12)
    ax1.set_ylabel('RMSD (Ã…)', fontsize=12)
    ax1.set_title(f'RMSD Comparison ({n_replicas} Replicas)', fontsize=14, fontweight='bold')
    ax1.legend()
    ax1.grid(True, alpha=0.3)

    # ãƒ¬ãƒ—ãƒªã‚«ã”ã¨ã®å¹³å‡RMSDã®åˆ†å¸ƒ
    replica_means = [r.mean() for r in all_rmsd]
    replica_stds = [r.std() for r in all_rmsd]

    ax2.bar(range(1, len(replica_means) + 1), replica_means, yerr=replica_stds,
            capsize=5, color='steelblue', edgecolor='black', linewidth=1.5)
    ax2.axhline(y=np.mean(replica_means), color='r', linestyle='--', linewidth=2,
                label=f'Overall Mean: {np.mean(replica_means):.3f} Ã…')
    ax2.set_xlabel('Replica Number', fontsize=12)
    ax2.set_ylabel('Mean RMSD (Ã…)', fontsize=12)
    ax2.set_title('Per-Replica Mean RMSD', fontsize=14, fontweight='bold')
    ax2.legend()
    ax2.grid(True, alpha=0.3, axis='y')

    plt.tight_layout()
    plt.savefig(output, dpi=300, bbox_inches='tight')
    print(f"âœ… ãƒ¬ãƒ—ãƒªã‚«è§£æãƒ—ãƒ­ãƒƒãƒˆä¿å­˜: {output}")

    # åæŸæ€§è©•ä¾¡ï¼ˆãƒ¬ãƒ—ãƒªã‚«é–“ã®æ¨™æº–åå·®ãŒå°ã•ã„ã»ã©åæŸï¼‰
    overall_mean = np.mean(replica_means)
    overall_std = np.std(replica_means)

    print(f"\nğŸ“Š ãƒ¬ãƒ—ãƒªã‚«é–“çµ±è¨ˆ:")
    print(f"   ãƒ¬ãƒ—ãƒªã‚«æ•°: {len(replica_means)}")
    print(f"   å¹³å‡RMSD: {overall_mean:.3f} Â± {overall_std:.3f} Ã…ï¼ˆãƒ¬ãƒ—ãƒªã‚«é–“SDï¼‰")
    print(f"   åæŸåˆ¤å®š: {'âœ… è‰¯å¥½ï¼ˆSD < 0.5 Ã…ï¼‰' if overall_std < 0.5 else 'âš ï¸ è¦æ³¨æ„ï¼ˆSD >= 0.5 Ã…ï¼‰'}")

if __name__ == "__main__":
    import sys
    if len(sys.argv) < 4:
        print("Usage: python replica_analysis.py topology_pattern trajectory_pattern n_replicas")
        print("  Example: python replica_analysis.py 'replica_{}.tpr' 'replica_{}.xtc' 5")
        sys.exit(1)

    topology_pattern = sys.argv[1]
    trajectory_pattern = sys.argv[2]
    n_replicas = int(sys.argv[3])

    analyze_replicas(topology_pattern, trajectory_pattern, n_replicas)</code></pre>

        <h2>4.4 æ¼”ç¿’å•é¡Œ</h2>

        <h3>Exercise 4-1: GROMACSè§£æãƒ„ãƒ¼ãƒ«ã®å®Ÿè¡Œã¨ãƒ—ãƒ­ãƒƒãƒˆ (Easy)</h3>

        <p>
        <strong>å•é¡Œ</strong>: æä¾›ã•ã‚ŒãŸMDãƒˆãƒ©ã‚¸ã‚§ã‚¯ãƒˆãƒªã‹ã‚‰ã€RMSDã€RMSFã€æ°´ç´ çµåˆæ•°ã‚’è¨ˆç®—ã—ã€
        Pythonã§3ã¤ã®çµæœã‚’1ã¤ã®ãƒ—ãƒ­ãƒƒãƒˆã«çµ±åˆã—ã¦ãã ã•ã„ã€‚
        </p>

        <details>
            <summary><strong>è§£ç­”ä¾‹ã‚’è¡¨ç¤º</strong></summary>

            <pre><code class="language-bash"># Step 1: GROMACSè§£æãƒ„ãƒ¼ãƒ«ã®å®Ÿè¡Œ
echo "4 4" | gmx rms -s md.tpr -f md.xtc -o rmsd.xvg -tu ns
echo "3" | gmx rmsf -s md.tpr -f md.xtc -o rmsf.xvg -res
echo "1 1" | gmx hbond -s md.tpr -f md.xtc -num hbnum.xvg

# Step 2: çµ±åˆãƒ—ãƒ­ãƒƒãƒˆä½œæˆ
python gromacs_analysis.py rmsd.xvg rmsf.xvg hbnum.xvg</code></pre>

            <p><strong>è©•ä¾¡åŸºæº–</strong>:</p>
            <ul>
                <li>3ã¤ã®è§£æãŒæ­£ã—ãå®Ÿè¡Œã•ã‚Œã¦ã„ã‚‹ âœ…</li>
                <li>XVGãƒ•ã‚¡ã‚¤ãƒ«ãŒé©åˆ‡ã«ãƒ‘ãƒ¼ã‚¹ã•ã‚Œã¦ã„ã‚‹ âœ…</li>
                <li>ãƒ—ãƒ­ãƒƒãƒˆã«å¹³å‡å€¤ãƒ»æ¨™æº–åå·®ãŒè¡¨ç¤ºã•ã‚Œã¦ã„ã‚‹ âœ…</li>
            </ul>
        </details>

        <h3>Exercise 4-2: å‹•å¾„åˆ†å¸ƒé–¢æ•°ï¼ˆRDFï¼‰ã«ã‚ˆã‚‹ã‚¤ã‚ªãƒ³é…ç½®è§£æ (Medium)</h3>

        <p>
        <strong>å•é¡Œ</strong>: ã‚¿ãƒ³ãƒ‘ã‚¯è³ªè¡¨é¢ã®è·é›»æ®‹åŸºï¼ˆASP, GLU, LYS, ARGï¼‰ã¨ã‚¤ã‚ªãƒ³ï¼ˆNa+, Cl-ï¼‰é–“ã®RDFã‚’è¨ˆç®—ã—ã€
        ã‚¤ã‚ªãƒ³ãŒã‚¿ãƒ³ãƒ‘ã‚¯è³ªè¡¨é¢ã«çµåˆã—ã¦ã„ã‚‹ã‹ï¼ˆç¬¬1ãƒ”ãƒ¼ã‚¯ãŒ3.5 Ã…ä»¥ä¸‹ï¼‰ã‚’åˆ¤å®šã—ã¦ãã ã•ã„ã€‚
        </p>

        <details>
            <summary><strong>è§£ç­”ä¾‹ã‚’è¡¨ç¤º</strong></summary>

            <pre><code class="language-python">#!/usr/bin/env python3
"""
Exercise 4-2: ã‚¤ã‚ªãƒ³-ã‚¿ãƒ³ãƒ‘ã‚¯è³ªé–“RDFè§£æ
"""
import MDAnalysis as mda
from MDAnalysis.analysis import rdf
import matplotlib.pyplot as plt
import numpy as np

def analyze_ion_binding(topology, trajectory, output='ion_rdf.png'):
    """
    ã‚¤ã‚ªãƒ³ã¨ã‚¿ãƒ³ãƒ‘ã‚¯è³ªè·é›»æ®‹åŸºé–“ã®RDFè§£æ
    """
    u = mda.Universe(topology, trajectory)

    # è·é›»æ®‹åŸºã®é¸æŠ
    negative_res = u.select_atoms('resname ASP GLU and name OD* OE*')  # è² é›»è·
    positive_res = u.select_atoms('resname LYS ARG and name NZ NH*')   # æ­£é›»è·

    # ã‚¤ã‚ªãƒ³ã®é¸æŠ
    na_ions = u.select_atoms('resname NA and name NA')  # Na+
    cl_ions = u.select_atoms('resname CL and name CL')  # Cl-

    print("ğŸ“Š ã‚¤ã‚ªãƒ³-ã‚¿ãƒ³ãƒ‘ã‚¯è³ªRDFè§£æ:")
    print(f"   è² é›»è·æ®‹åŸº: {len(negative_res)} åŸå­")
    print(f"   æ­£é›»è·æ®‹åŸº: {len(positive_res)} åŸå­")
    print(f"   Na+ ã‚¤ã‚ªãƒ³: {len(na_ions)} å€‹")
    print(f"   Cl- ã‚¤ã‚ªãƒ³: {len(cl_ions)} å€‹")

    # RDFè¨ˆç®—
    rdf_na_neg = rdf.InterRDF(na_ions, negative_res, nbins=75, range=(0.0, 15.0))
    rdf_na_neg.run()

    rdf_cl_pos = rdf.InterRDF(cl_ions, positive_res, nbins=75, range=(0.0, 15.0))
    rdf_cl_pos.run()

    # ãƒ—ãƒ­ãƒƒãƒˆ
    fig, ax = plt.subplots(figsize=(10, 6))

    ax.plot(rdf_na_neg.results.bins, rdf_na_neg.results.rdf, 'b-', linewidth=2,
            label='Na+ - è² é›»è·æ®‹åŸº (ASP, GLU)')
    ax.plot(rdf_cl_pos.results.bins, rdf_cl_pos.results.rdf, 'r-', linewidth=2,
            label='Cl- - æ­£é›»è·æ®‹åŸº (LYS, ARG)')
    ax.axhline(y=1.0, color='gray', linestyle='--', linewidth=1)
    ax.axvline(x=3.5, color='green', linestyle=':', linewidth=2,
               label='çµåˆåˆ¤å®šé–¾å€¤ (3.5 Ã…)')
    ax.set_xlabel('Distance (Ã…)', fontsize=12)
    ax.set_ylabel('g(r)', fontsize=12)
    ax.set_title('Ion-Protein RDF', fontsize=14, fontweight='bold')
    ax.legend()
    ax.grid(True, alpha=0.3)

    plt.tight_layout()
    plt.savefig(output, dpi=300, bbox_inches='tight')
    print(f"âœ… ã‚¤ã‚ªãƒ³RDFãƒ—ãƒ­ãƒƒãƒˆä¿å­˜: {output}")

    # çµåˆåˆ¤å®š
    first_peak_na = rdf_na_neg.results.bins[np.argmax(rdf_na_neg.results.rdf[:20])]
    first_peak_cl = rdf_cl_pos.results.bins[np.argmax(rdf_cl_pos.results.rdf[:20])]

    print(f"\nğŸ” ã‚¤ã‚ªãƒ³çµåˆè§£æ:")
    print(f"   Na+ ç¬¬1ãƒ”ãƒ¼ã‚¯: {first_peak_na:.2f} Ã…")
    print(f"   Na+ çµåˆ: {'âœ… ã‚ã‚Š' if first_peak_na < 3.5 else 'âŒ ãªã—'}")
    print(f"   Cl- ç¬¬1ãƒ”ãƒ¼ã‚¯: {first_peak_cl:.2f} Ã…")
    print(f"   Cl- çµåˆ: {'âœ… ã‚ã‚Š' if first_peak_cl < 3.5 else 'âŒ ãªã—'}")

if __name__ == "__main__":
    import sys
    if len(sys.argv) < 3:
        print("Usage: python ex4_2.py topology trajectory")
        sys.exit(1)

    analyze_ion_binding(sys.argv[1], sys.argv[2])</code></pre>

            <p><strong>è©•ä¾¡åŸºæº–</strong>:</p>
            <ul>
                <li>è·é›»æ®‹åŸºãŒæ­£ã—ãé¸æŠã•ã‚Œã¦ã„ã‚‹ï¼ˆASP/GLUè² ã€LYS/ARGæ­£ï¼‰âœ…</li>
                <li>RDFã®ç¬¬1ãƒ”ãƒ¼ã‚¯ä½ç½®ãŒæ­£ç¢ºã«æ¤œå‡ºã•ã‚Œã¦ã„ã‚‹ âœ…</li>
                <li>3.5 Ã…ã®çµåˆåˆ¤å®šé–¾å€¤ãŒé©åˆ‡ã«é©ç”¨ã•ã‚Œã¦ã„ã‚‹ âœ…</li>
            </ul>
        </details>

        <h3>Exercise 4-3: è¤‡æ•°ãƒ¬ãƒ—ãƒªã‚«ã®åæŸæ€§è©•ä¾¡ã¨ãƒ–ãƒ¼ãƒˆã‚¹ãƒˆãƒ©ãƒƒãƒ—æ³• (Hard)</h3>

        <p>
        <strong>å•é¡Œ</strong>: 3ãƒ¬ãƒ—ãƒªã‚«ã®MDãƒ‡ãƒ¼ã‚¿ã‹ã‚‰ã€RMSDå¹³å‡å€¤ã®ä¿¡é ¼åŒºé–“ï¼ˆ95%ï¼‰ã‚’ãƒ–ãƒ¼ãƒˆã‚¹ãƒˆãƒ©ãƒƒãƒ—æ³•ã§æ¨å®šã—ã€
        ãƒ¬ãƒ—ãƒªã‚«é–“ã®åæŸæ€§ã‚’çµ±è¨ˆçš„ã«è©•ä¾¡ã—ã¦ãã ã•ã„ã€‚
        </p>

        <details>
            <summary><strong>è§£ç­”ä¾‹ã‚’è¡¨ç¤º</strong></summary>

            <pre><code class="language-python">#!/usr/bin/env python3
"""
Exercise 4-3: ãƒ–ãƒ¼ãƒˆã‚¹ãƒˆãƒ©ãƒƒãƒ—æ³•ã«ã‚ˆã‚‹ä¿¡é ¼åŒºé–“æ¨å®š
"""
import MDAnalysis as mda
from MDAnalysis.analysis import rms
import matplotlib.pyplot as plt
import numpy as np
from scipy import stats

def bootstrap_confidence_interval(data, n_bootstrap=1000, confidence=0.95):
    """
    ãƒ–ãƒ¼ãƒˆã‚¹ãƒˆãƒ©ãƒƒãƒ—æ³•ã§ä¿¡é ¼åŒºé–“ã‚’æ¨å®š

    Parameters
    ----------
    data : ndarray
        ã‚µãƒ³ãƒ—ãƒ«ãƒ‡ãƒ¼ã‚¿ï¼ˆå„ãƒ¬ãƒ—ãƒªã‚«ã®å¹³å‡RMSDï¼‰
    n_bootstrap : int
        ãƒ–ãƒ¼ãƒˆã‚¹ãƒˆãƒ©ãƒƒãƒ—ã‚µãƒ³ãƒ—ãƒ«æ•°
    confidence : float
        ä¿¡é ¼æ°´æº–ï¼ˆ0.95 = 95%ï¼‰

    Returns
    -------
    mean : float
        ã‚µãƒ³ãƒ—ãƒ«å¹³å‡
    ci_lower, ci_upper : float
        ä¿¡é ¼åŒºé–“ã®ä¸‹é™ãƒ»ä¸Šé™
    """
    bootstrap_means = []

    for _ in range(n_bootstrap):
        # ãƒªã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ï¼ˆå¾©å…ƒæŠ½å‡ºï¼‰
        resample = np.random.choice(data, size=len(data), replace=True)
        bootstrap_means.append(resample.mean())

    bootstrap_means = np.array(bootstrap_means)

    # ä¿¡é ¼åŒºé–“ï¼ˆãƒ‘ãƒ¼ã‚»ãƒ³ã‚¿ã‚¤ãƒ«æ³•ï¼‰
    alpha = 1 - confidence
    ci_lower = np.percentile(bootstrap_means, alpha/2 * 100)
    ci_upper = np.percentile(bootstrap_means, (1 - alpha/2) * 100)

    return data.mean(), ci_lower, ci_upper

def evaluate_replica_convergence(topologies, trajectories, equilibration_ns=2.0,
                                  output='bootstrap_convergence.png'):
    """
    ãƒ–ãƒ¼ãƒˆã‚¹ãƒˆãƒ©ãƒƒãƒ—æ³•ã§ãƒ¬ãƒ—ãƒªã‚«åæŸæ€§ã‚’è©•ä¾¡
    """
    replica_means = []

    for i, (top, traj) in enumerate(zip(topologies, trajectories)):
        u = mda.Universe(top, traj)
        ref = mda.Universe(top, traj)

        R = rms.RMSD(u, ref, select='backbone', groupselections=['backbone'])
        R.run()

        time = R.results.rmsd[:, 1] / 1000  # ps â†’ ns
        rmsd = R.results.rmsd[:, 2]  # Ã…

        # å¹³è¡¡åŒ–æœŸé–“ã‚’é™¤å¤–
        mask = time >= equilibration_ns
        rmsd_analysis = rmsd[mask]

        replica_means.append(rmsd_analysis.mean())
        print(f"Replica {i+1}: å¹³å‡RMSD = {replica_means[-1]:.3f} Ã…")

    replica_means = np.array(replica_means)

    # ãƒ–ãƒ¼ãƒˆã‚¹ãƒˆãƒ©ãƒƒãƒ—æ³•ã§ä¿¡é ¼åŒºé–“æ¨å®š
    mean, ci_lower, ci_upper = bootstrap_confidence_interval(replica_means,
                                                              n_bootstrap=10000,
                                                              confidence=0.95)

    print(f"\nğŸ“Š ãƒ–ãƒ¼ãƒˆã‚¹ãƒˆãƒ©ãƒƒãƒ—ä¿¡é ¼åŒºé–“ï¼ˆ95%ï¼‰:")
    print(f"   å¹³å‡RMSD: {mean:.3f} Ã…")
    print(f"   95% CI: [{ci_lower:.3f}, {ci_upper:.3f}] Ã…")
    print(f"   CIå¹…: {ci_upper - ci_lower:.3f} Ã…")

    # åæŸæ€§åˆ¤å®š
    convergence_criterion = 0.5  # CIå¹…ãŒ0.5 Ã…ä»¥ä¸‹ãªã‚‰åæŸ
    is_converged = (ci_upper - ci_lower) < convergence_criterion

    print(f"   åæŸåˆ¤å®š: {'âœ… åæŸï¼ˆCIå¹… < 0.5 Ã…ï¼‰' if is_converged else 'âš ï¸ æœªåæŸï¼ˆCIå¹… >= 0.5 Ã…ï¼‰'}")

    # å¯è¦–åŒ–
    fig, ax = plt.subplots(figsize=(10, 6))

    # ãƒ¬ãƒ—ãƒªã‚«ã”ã¨ã®å¹³å‡RMSD
    x = np.arange(1, len(replica_means) + 1)
    ax.bar(x, replica_means, color='steelblue', edgecolor='black', linewidth=1.5,
           label='Replica Mean RMSD')

    # å…¨ä½“å¹³å‡ã¨ä¿¡é ¼åŒºé–“
    ax.axhline(y=mean, color='red', linestyle='--', linewidth=2, label='Overall Mean')
    ax.axhspan(ci_lower, ci_upper, color='red', alpha=0.2, label='95% CI (Bootstrap)')

    ax.set_xlabel('Replica Number', fontsize=12)
    ax.set_ylabel('Mean RMSD (Ã…)', fontsize=12)
    ax.set_title('Replica Convergence Analysis (Bootstrap Method)', fontsize=14, fontweight='bold')
    ax.legend()
    ax.grid(True, alpha=0.3, axis='y')

    plt.tight_layout()
    plt.savefig(output, dpi=300, bbox_inches='tight')
    print(f"âœ… åæŸæ€§ãƒ—ãƒ­ãƒƒãƒˆä¿å­˜: {output}")

if __name__ == "__main__":
    import sys
    if len(sys.argv) < 4:
        print("Usage: python ex4_3.py topology1 trajectory1 topology2 trajectory2 topology3 trajectory3")
        sys.exit(1)

    topologies = [sys.argv[1], sys.argv[3], sys.argv[5]]
    trajectories = [sys.argv[2], sys.argv[4], sys.argv[6]]

    evaluate_replica_convergence(topologies, trajectories)</code></pre>

            <p><strong>è©•ä¾¡åŸºæº–</strong>:</p>
            <ul>
                <li>ãƒ–ãƒ¼ãƒˆã‚¹ãƒˆãƒ©ãƒƒãƒ—ãƒªã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ãŒæ­£ã—ãå®Ÿè£…ã•ã‚Œã¦ã„ã‚‹ âœ…</li>
                <li>95%ä¿¡é ¼åŒºé–“ãŒãƒ‘ãƒ¼ã‚»ãƒ³ã‚¿ã‚¤ãƒ«æ³•ã§è¨ˆç®—ã•ã‚Œã¦ã„ã‚‹ âœ…</li>
                <li>åæŸæ€§ãŒCIå¹…ï¼ˆ< 0.5 Ã…ï¼‰ã§é©åˆ‡ã«åˆ¤å®šã•ã‚Œã¦ã„ã‚‹ âœ…</li>
                <li>10,000ã‚µãƒ³ãƒ—ãƒ«ä»¥ä¸Šã®ãƒ–ãƒ¼ãƒˆã‚¹ãƒˆãƒ©ãƒƒãƒ—ã§ååˆ†ãªç²¾åº¦ âœ…</li>
            </ul>
        </details>

        <h2>4.5 å­¦ç¿’ç›®æ¨™ã®ç¢ºèª</h2>

        <div class="info-box">
            <strong>ãƒ¬ãƒ™ãƒ«1: åŸºæœ¬ç†è§£</strong>
            <ul>
                <li>GROMACSè§£æãƒ„ãƒ¼ãƒ«ï¼ˆgmx rms, gmx rmsf, gmx hbondç­‰ï¼‰ã®å½¹å‰²ã‚’èª¬æ˜ã§ãã‚‹</li>
                <li>RMSDã€RMSFã€æ°´ç´ çµåˆã€RDFã®ç‰©ç†çš„æ„å‘³ã‚’ç†è§£ã—ã¦ã„ã‚‹</li>
                <li>MDAnalysisã®Universeã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨åŸå­é¸æŠã®ä»•çµ„ã¿ã‚’ç†è§£ã—ã¦ã„ã‚‹</li>
                <li>XVGãƒ•ã‚¡ã‚¤ãƒ«ã®å½¢å¼ã¨ãƒ‘ãƒ¼ã‚¹æ–¹æ³•ã‚’çŸ¥ã£ã¦ã„ã‚‹</li>
                <li>DSSPã«ã‚ˆã‚‹äºŒæ¬¡æ§‹é€ åˆ†é¡ï¼ˆÎ±-helixã€Î²-sheetã€ã‚³ã‚¤ãƒ«ï¼‰ã‚’ç†è§£ã—ã¦ã„ã‚‹</li>
            </ul>

            <strong>ãƒ¬ãƒ™ãƒ«2: å®Ÿè·µã‚¹ã‚­ãƒ«</strong>
            <ul>
                <li>gmx rmsã€gmx rmsfã€gmx hbondã‚’å®Ÿè¡Œã—ã€çµæœã‚’è§£é‡ˆã§ãã‚‹</li>
                <li>Pythonã§XVGãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ‘ãƒ¼ã‚¹ã—ã€Matplotlibã§ãƒ—ãƒ­ãƒƒãƒˆã§ãã‚‹</li>
                <li>MDAnalysisã§è»Œé“ã‚’ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã—ã€ã‚«ã‚¹ã‚¿ãƒ è§£æãŒã§ãã‚‹</li>
                <li>RDFã‚’è¨ˆç®—ã—ã€ãƒ”ãƒ¼ã‚¯ä½ç½®ã‹ã‚‰æº¶åª’å’Œæ§‹é€ ã‚’è­°è«–ã§ãã‚‹</li>
                <li>è¤‡æ•°ãƒ¬ãƒ—ãƒªã‚«ã®çµ±è¨ˆè§£æï¼ˆå¹³å‡ã€æ¨™æº–åå·®ï¼‰ãŒã§ãã‚‹</li>
            </ul>

            <strong>ãƒ¬ãƒ™ãƒ«3: å¿œç”¨åŠ›</strong>
            <ul>
                <li>è¤‡æ•°è»Œé“ã®çµåˆã¨PBCå‡¦ç†ã‚’é©åˆ‡ã«å®Ÿè¡Œã§ãã‚‹</li>
                <li>ãƒ¬ãƒ—ãƒªã‚«é–“ã®åæŸæ€§ã‚’ãƒ–ãƒ¼ãƒˆã‚¹ãƒˆãƒ©ãƒƒãƒ—æ³•ã§çµ±è¨ˆçš„ã«è©•ä¾¡ã§ãã‚‹</li>
                <li>DSSPè§£æã‹ã‚‰äºŒæ¬¡æ§‹é€ å®‰å®šæ€§ã‚’å®šé‡çš„ã«è­°è«–ã§ãã‚‹</li>
                <li>ã‚¤ã‚ªãƒ³é…ç½®ã€ã‚¿ãƒ³ãƒ‘ã‚¯è³ª-ãƒªã‚¬ãƒ³ãƒ‰ç›¸äº’ä½œç”¨ãªã©ã®é«˜åº¦ãªè§£æãŒã§ãã‚‹</li>
                <li>ãƒãƒƒãƒå‡¦ç†ã‚¹ã‚¯ãƒªãƒ—ãƒˆã§å¤§è¦æ¨¡MDè§£æã‚’è‡ªå‹•åŒ–ã§ãã‚‹</li>
            </ul>
        </div>

        <h2>å‚è€ƒæ–‡çŒ®</h2>

        <ol>
            <li>Michaud-Agrawal, N., Denning, E. J., Woolf, T. B., & Beckstein, O. (2011). MDAnalysis: A toolkit for the analysis of molecular dynamics simulations. <em>Journal of Computational Chemistry</em>, 32(10), 2319-2327. <strong>pp. 2320-2325</strong>.</li>

            <li>Gowers, R. J., Linke, M., Barnoud, J., Reddy, T. J. E., Melo, M. N., Seyler, S. L., ... & Beckstein, O. (2016). MDAnalysis: A Python package for the rapid analysis of molecular dynamics simulations. <em>Proceedings of the 15th Python in Science Conference</em>, 98-105. <strong>pp. 98-103</strong>.</li>

            <li>Kabsch, W., & Sander, C. (1983). Dictionary of protein secondary structure: Pattern recognition of hydrogenâ€bonded and geometrical features. <em>Biopolymers</em>, 22(12), 2577-2637. <strong>pp. 2577-2590</strong>.</li>

            <li>Humphrey, W., Dalke, A., & Schulten, K. (1996). VMD: Visual molecular dynamics. <em>Journal of Molecular Graphics</em>, 14(1), 33-38. <strong>pp. 33-37</strong>.</li>

            <li>McGibbon, R. T., Beauchamp, K. A., Harrigan, M. P., Klein, C., Swails, J. M., HernÃ¡ndez, C. X., ... & Pande, V. S. (2015). MDTraj: A modern open library for the analysis of molecular dynamics trajectories. <em>Biophysical Journal</em>, 109(8), 1528-1532. <strong>pp. 1528-1531</strong>.</li>

            <li>Lemkul, J. A. (2019). From Proteins to Perturbed Hamiltonians: A Suite of Tutorials for the GROMACS-2018 Molecular Simulation Package. <em>Living Journal of Computational Molecular Science</em>, 1(1), 5068. <strong>pp. 25-40</strong>.</li>

            <li>Efron, B., & Tibshirani, R. J. (1994). An Introduction to the Bootstrap. <em>Chapman and Hall/CRC</em>. <strong>pp. 45-60</strong>.</li>
        </ol>

        <div class="nav-buttons">
            <a href="chapter-3.html" class="btn">â† Chapter 3: å¹³è¡¡åŒ–ã¨ãƒ—ãƒ­ãƒ€ã‚¯ã‚·ãƒ§ãƒ³MD</a>
            <a href="chapter-5.html" class="btn">Chapter 5: å®Ÿè·µãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ â†’</a>
        </div>
    </div>

    <script>
        mermaid.initialize({ startOnLoad: true, theme: 'default' });
    </script>
</body>
</html>