<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Chapter 1: Fundamentals of Spectroscopic Analysis - MS Terakoya</title>
<style>
        :root {
            --color-primary: #2c3e50;
            --color-primary-dark: #1a252f;
            --color-accent: #f093fb;
            --color-accent-light: #f5576c;
            --color-text: #2d3748;
            --color-text-light: #4a5568;
            --color-bg: #ffffff;
            --color-bg-alt: #f7fafc;
            --color-border: #e2e8f0;
            --color-code-bg: #f8f9fa;
            --color-link: #f093fb;
            --color-link-hover: #d07be8;

            --spacing-xs: 0.5rem;
            --spacing-sm: 1rem;
            --spacing-md: 1.5rem;
            --spacing-lg: 2rem;
            --spacing-xl: 3rem;

            --font-body: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            --font-mono: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;

            --border-radius: 8px;
            --box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-body);
            line-height: 1.7;
            color: var(--color-text);
            background-color: var(--color-bg);
            font-size: 16px;
        }

        header {
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            color: white;
            padding: var(--spacing-xl) var(--spacing-md);
            margin-bottom: var(--spacing-xl);
            box-shadow: var(--box-shadow);
        }

        .header-content {
            max-width: 900px;
            margin: 0 auto;
        }

        h1 {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: var(--spacing-sm);
            line-height: 1.2;
        }

        .subtitle {
            font-size: 1.1rem;
            opacity: 0.95;
            font-weight: 400;
            margin-bottom: var(--spacing-md);
        }

        .meta {
            display: flex;
            flex-wrap: wrap;
            gap: var(--spacing-md);
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .meta-item {
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 0 var(--spacing-md) var(--spacing-xl);
        }

        h2 {
            font-size: 1.75rem;
            color: var(--color-primary);
            margin-top: var(--spacing-xl);
            margin-bottom: var(--spacing-md);
            padding-bottom: var(--spacing-sm);
            border-bottom: 3px solid var(--color-accent);
        }

        h3 {
            font-size: 1.4rem;
            color: var(--color-primary);
            margin-top: var(--spacing-lg);
            margin-bottom: var(--spacing-sm);
        }

        p {
            margin-bottom: var(--spacing-sm);
            line-height: 1.8;
        }

        ul, ol {
            margin-bottom: var(--spacing-sm);
            padding-left: var(--spacing-lg);
        }

        li {
            margin-bottom: 0.5rem;
            line-height: 1.7;
        }

        .info-box {
            background: linear-gradient(135deg, rgba(240, 147, 251, 0.1) 0%, rgba(245, 87, 108, 0.1) 100%);
            border-left: 4px solid var(--color-accent);
            padding: var(--spacing-md);
            margin: var(--spacing-md) 0;
            border-radius: var(--border-radius);
        }

        .info-box strong {
            color: var(--color-accent-light);
        }

        .mermaid {
            background-color: var(--color-bg-alt);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
            margin: var(--spacing-md) 0;
            text-align: center;
        }

        pre {
            background-color: var(--color-code-bg);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
            overflow-x: auto;
            margin: var(--spacing-md) 0;
            border: 1px solid var(--color-border);
        }

        code {
            font-family: var(--font-mono);
            font-size: 0.9em;
            background-color: var(--color-code-bg);
            padding: 0.2em 0.4em;
            border-radius: 3px;
        }

        pre code {
            background-color: transparent;
            padding: 0;
        }

        .code-example {
            margin: var(--spacing-md) 0;
        }

        .code-example h4 {
            color: var(--color-primary);
            margin-bottom: var(--spacing-sm);
            font-size: 1.1rem;
        }

        details {
            background-color: var(--color-bg-alt);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
            margin: var(--spacing-md) 0;
            border: 1px solid var(--color-border);
        }

        summary {
            cursor: pointer;
            font-weight: 600;
            color: var(--color-primary);
            user-select: none;
            padding: var(--spacing-sm);
            margin: calc(-1 * var(--spacing-md));
            margin-bottom: var(--spacing-md);
            background: linear-gradient(135deg, rgba(240, 147, 251, 0.15) 0%, rgba(245, 87, 108, 0.15) 100%);
            border-radius: var(--border-radius) var(--border-radius) 0 0;
        }

        summary:hover {
            background: linear-gradient(135deg, rgba(240, 147, 251, 0.25) 0%, rgba(245, 87, 108, 0.25) 100%);
        }

        .navigation {
            display: flex;
            justify-content: space-between;
            margin-top: var(--spacing-xl);
            padding-top: var(--spacing-lg);
            border-top: 2px solid var(--color-border);
            gap: var(--spacing-md);
        }

        .nav-button {
            flex: 1;
            padding: var(--spacing-md);
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            color: white;
            text-decoration: none;
            border-radius: var(--border-radius);
            text-align: center;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: var(--box-shadow);
        }

        .nav-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        footer {
            margin-top: var(--spacing-xl);
            padding: var(--spacing-lg);
            background-color: var(--color-bg-alt);
            text-align: center;
            border-top: 1px solid var(--color-border);
        }

        footer p {
            margin-bottom: var(--spacing-sm);
            color: var(--color-text-light);
        }

        footer a {
            color: var(--color-link);
            text-decoration: none;
        }

        footer a:hover {
            color: var(--color-link-hover);
            text-decoration: underline;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.6rem;
            }

            h2 {
                font-size: 1.4rem;
            }

            h3 {
                font-size: 1.2rem;
            }

            .navigation {
                flex-direction: column;
            }
        }



        /* Breadcrumb styles */
        .breadcrumb {
            background: #f7fafc;
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #e2e8f0;
            font-size: 0.9rem;
        }

        .breadcrumb-content {
            max-width: 900px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .breadcrumb a {
            color: #667eea;
            text-decoration: none;
            transition: color 0.2s;
        }

        .breadcrumb a:hover {
            color: #764ba2;
            text-decoration: underline;
        }

        .breadcrumb-separator {
            color: #a0aec0;
            margin: 0 0.25rem;
        }

        .breadcrumb-current {
            color: #4a5568;
            font-weight: 500;
        }
    </style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.6.1/mermaid.min.js"></script>
<script>
        mermaid.initialize({
            startOnLoad: true,
            theme: 'default',
            themeVariables: {
                primaryColor: '#f093fb',
                primaryTextColor: '#2c3e50',
                primaryBorderColor: '#f5576c',
                lineColor: '#f5576c',
                secondaryColor: '#f7fafc',
                tertiaryColor: '#ffffff'
            }
        });
    </script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            }
        };
    </script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet"/>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet"/>
</head>
<body>
<nav class="breadcrumb">
<div class="breadcrumb-content">
<a href="../index.html">AI Terakoya Home</a><span class="breadcrumb-separator">:</span><a href="../../MS/index.html">Materials Science</a><span class="breadcrumb-separator">:</span><a href="../../MS/spectroscopy-introduction/index.html">Spectroscopy</a><span class="breadcrumb-separator">:</span><span class="breadcrumb-current">Chapter 1</span>
</div>
</nav><div class="locale-switcher">
<span class="current-locale">üåê EN</span>
<span class="locale-separator">|</span>
<a class="locale-link" href="../../../jp/MS/spectroscopy-introduction/chapter-1.html">Êó•Êú¨Ë™û</a>
<span class="locale-meta">Last sync: 2025-11-16</span>
</div>

<header>
<div class="header-content">
<h1>Chapter 1: Fundamentals of Spectroscopic Analysis</h1>
<p class="subtitle">Understanding the Essence of Materials through Light-Matter Interactions</p>
<div class="meta">
<span class="meta-item">=√ö Series: Introduction to Spectroscopic Analysis</span>
<span class="meta-item">√± Study Time: 90 minutes</span>
<span class="meta-item">&lt;¬Ø Difficulty: Beginner</span>
</div>
</div>
</header>
<main class="container">
<h2>Introduction</h2>
<p>Spectroscopy is a powerful analytical technique that utilizes the interaction between light and matter to elucidate the electronic states, chemical bonding, structure, and composition of materials. In this chapter, we will learn the quantum mechanical principles that form the foundation of all spectroscopic methods and acquire theoretical fundamentals for interpreting experimental data, including the Beer-Lambert law, transition moments, and selection rules.</p>
<div class="info-box">
<strong>Why is Spectroscopy Important?</strong><br/>
            Spectroscopy is non-destructive, applicable to trace samples, and can probe different properties of materials across diverse energy ranges (from X-rays to microwaves). It serves as a foundational technology in Materials Informatics for material exploration and design, including band gap measurements in semiconductors, functional group identification in organic molecules, and chemical state analysis of catalyst surfaces.
        </div>
<h2>1. Fundamentals of Light-Matter Interactions</h2>
<h3>1.1 Properties of Electromagnetic Waves</h3>
<p>Light exhibits wave-particle duality as an electromagnetic wave. As a wave, light is expressed by wavelength $\lambda$ (nm) or wavenumber $\tilde{\nu}$ (cm<sup>-1</sup>), while as a particle, photons possess the following energy:</p>
<p>$$E = h\nu = \frac{hc}{\lambda} = hc\tilde{\nu}$$</p>
<p>where $h = 6.626 \times 10^{-34}$ J¬∑s (Planck's constant) and $c = 2.998 \times 10^8$ m/s (speed of light).</p>
<div class="info-box">
<strong>Energy Regions and Corresponding Transitions</strong><br/>
<ul>
<li><strong>X-ray (0.01-10 nm)</strong>: Core electron excitation (XPS, XRF)</li>
<li><strong>UV-Vis (200-800 nm)</strong>: Valence electron excitation, HOMO-LUMO transitions</li>
<li><strong>Infrared (2.5-25 ¬ºm)</strong>: Molecular vibrations</li>
<li><strong>Microwave (0.1-10 cm)</strong>: Molecular rotations</li>
</ul>
</div>
<div class="code-example"><pre><code class="language-python">
            <h4>Code Example 1: Planck Function and Energy Calculations</h4>
            <pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt

# Planck's constant and speed of light
h = 6.62607015e-34  # J¬∑s
c = 2.99792458e8    # m/s
eV = 1.602176634e-19  # J (1 eV)

def wavelength_to_energy(wavelength_nm):
    """
    Calculate photon energy (eV) from wavelength (nm)

    Parameters:
    -----------
    wavelength_nm : float or array
        Wavelength (nanometer)

    Returns:
    --------
    energy_eV : float or array
        Photon energy (electron volt)
    """
    wavelength_m = wavelength_nm * 1e-9
    energy_J = h * c / wavelength_m
    energy_eV = energy_J / eV
    return energy_eV

def wavenumber_to_energy(wavenumber_cm):
    """
    Calculate photon energy (eV) from wavenumber (cm^-1)

    Parameters:
    -----------
    wavenumber_cm : float or array
        Wavenumber (cm^-1)

    Returns:
    --------
    energy_eV : float or array
        Photon energy (eV)
    """
    energy_J = h * c * wavenumber_cm * 100  # cm^-1 to m^-1
    energy_eV = energy_J / eV
    return energy_eV

# Energy calculation for visible light region (380-780 nm)
wavelengths = np.linspace(380, 780, 100)
energies = wavelength_to_energy(wavelengths)

# Visualization
plt.figure(figsize=(10, 6))
plt.plot(wavelengths, energies, linewidth=2, color='#f093fb')
plt.fill_between(wavelengths, energies, alpha=0.3, color='#f5576c')
plt.xlabel('Wavelength (nm)', fontsize=12)
plt.ylabel('Photon Energy (eV)', fontsize=12)
plt.title('Wavelength-Energy Relationship in Visible Region', fontsize=14, fontweight='bold')
plt.grid(True, alpha=0.3)
plt.tight_layout()
plt.savefig('wavelength_energy.png', dpi=300, bbox_inches='tight')
plt.show()

# Specific examples
print(f"Red light (650 nm) energy: {wavelength_to_energy(650):.3f} eV")
print(f"Blue light (450 nm) energy: {wavelength_to_energy(450):.3f} eV")
print(f"IR vibration (1000 cm^-1) energy: {wavenumber_to_energy(1000):.4f} eV")
</code></pre>
        </code></pre></div>
<h3>1.2 Basic Processes: Absorption, Emission, and Scattering</h3>
<p>Light-matter interactions are classified into three main processes:</p>
<div class="mermaid">
        flowchart TD
            A[Incident Light] --&gt; B{Interaction with Matter}
            B --&gt;|Absorption| C[Transition to Excited State<br/>E = E‚Äö - EÔøΩ]
            B --&gt;|Emission| D[Transition to Ground State<br/>Fluorescence/Phosphorescence]
            B --&gt;|Scattering| E[Rayleigh Scattering<br/>Elastic]
            B --&gt;|Scattering| F[Raman Scattering<br/>Inelastic]

            style A fill:#f093fb,color:#fff
            style C fill:#f5576c,color:#fff
            style D fill:#f5576c,color:#fff
            style E fill:#a8e6cf,color:#000
            style F fill:#a8e6cf,color:#000
        </div>
<ul>
<li><strong>Absorption</strong>: When the photon energy matches the energy difference between two energy levels $\Delta E = E_2 - E_1$ of the material, the photon is absorbed and the material transitions to an excited state.</li>
<li><strong>Emission</strong>: Photons are emitted during the transition from an excited state to the ground state. This includes fluorescence, phosphorescence, and chemiluminescence.</li>
<li><strong>Scattering</strong>: Classified into Rayleigh scattering (elastic, no energy change) and Raman scattering (inelastic, vibrational energy change).</li>
</ul>
<h3>1.3 Beer-Lambert Law</h3>
<p>The Beer-Lambert law (also called Lambert-Beer law), the fundamental law of absorption spectroscopy, describes the relationship between absorbance $A$ and sample concentration $c$ and path length $l$:</p>
<p>$$A = \log_{10}\left(\frac{I_0}{I}\right) = \varepsilon c l$$</p>
<p>where $I_0$ is the incident light intensity, $I$ is the transmitted light intensity, and $\varepsilon$ is the molar absorption coefficient (L mol<sup>-1</sup> cm<sup>-1</sup>). Transmittance $T$ is defined as $T = I/I_0$, with the relationship $A = -\log_{10}(T)$.</p>
<div class="code-example"><pre><code class="language-python">
            <h4>Code Example 2: Beer-Lambert Law Simulation</h4>
            <pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt

def beer_lambert(I0, epsilon, concentration, path_length):
    """
    Calculate transmitted light intensity using Beer-Lambert law

    Parameters:
    -----------
    I0 : float
        Incident light intensity
    epsilon : float
        Molar absorption coefficient (L mol^-1 cm^-1)
    concentration : float or array
        Concentration (mol/L)
    path_length : float
        Path length (cm)

    Returns:
    --------
    I : float or array
        Transmitted light intensity
    A : float or array
        Absorbance
    T : float or array
        Transmittance
    """
    A = epsilon * concentration * path_length
    T = 10**(-A)
    I = I0 * T
    return I, A, T

# Parameter settings
I0 = 1.0  # Incident light intensity (normalized)
epsilon = 1000  # Molar absorption coefficient (typical organic dye)
path_length = 1.0  # Path length 1 cm
concentrations = np.linspace(0, 1e-4, 100)  # Concentration range (mol/L)

# Calculation
I, A, T = beer_lambert(I0, epsilon, concentrations, path_length)

# Visualization
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 5))

# Absorbance vs concentration
ax1.plot(concentrations * 1e6, A, linewidth=2, color='#f093fb', label='Absorbance')
ax1.set_xlabel('Concentration (¬ºmol/L)', fontsize=12)
ax1.set_ylabel('Absorbance', fontsize=12)
ax1.set_title('Beer-Lambert Law: Concentration Dependence', fontsize=14, fontweight='bold')
ax1.grid(True, alpha=0.3)
ax1.legend()

# Transmittance vs concentration
ax2.plot(concentrations * 1e6, T * 100, linewidth=2, color='#f5576c', label='Transmittance')
ax2.set_xlabel('Concentration (¬ºmol/L)', fontsize=12)
ax2.set_ylabel('Transmittance (%)', fontsize=12)
ax2.set_title('Concentration Dependence of Transmittance', fontsize=14, fontweight='bold')
ax2.grid(True, alpha=0.3)
ax2.legend()

plt.tight_layout()
plt.savefig('beer_lambert.png', dpi=300, bbox_inches='tight')
plt.show()

# Quantitative analysis example: Calculate concentration from absorbance
measured_A = 0.5
calculated_c = measured_A / (epsilon * path_length)
print(f"Measured absorbance: {measured_A}")
print(f"Calculated concentration: {calculated_c * 1e6:.2f} ¬ºmol/L")
</code></pre>
        </code></pre></div>
<h2>2. Quantum Mechanical Foundations</h2>
<h3>2.1 Electronic and Vibrational States</h3>
<p>Molecular energy levels can be separated into three degrees of freedom: electronic states, vibrational states, and rotational states (Born-Oppenheimer approximation):</p>
<p>$$E_{\text{total}} = E_{\text{electronic}} + E_{\text{vibrational}} + E_{\text{rotational}}$$</p>
<p>Typical energy scales are as follows:</p>
<ul>
<li>$E_{\text{electronic}} \sim 1-10$ eV (UV-Vis region)</li>
<li>$E_{\text{vibrational}} \sim 0.05-0.5$ eV (infrared region)</li>
<li>$E_{\text{rotational}} \sim 10^{-4}-10^{-3}$ eV (microwave region)</li>
</ul>
<h3>2.2 Transition Moments and Fermi's Golden Rule</h3>
<p>The transition probability from state $\left|\psi_i\right\rangle$ to $\left|\psi_f\right\rangle$ due to light absorption is given by Fermi's golden rule:</p>
<p>$$W_{i \to f} = \frac{2\pi}{\hbar} \left| \left\langle \psi_f \right| \hat{H}_{\text{int}} \left| \psi_i \right\rangle \right|^2 \rho(E_f)$$</p>
<p>where $\hat{H}_{\text{int}}$ is the light-matter interaction Hamiltonian and $\rho(E_f)$ is the density of final states. In the electric dipole approximation, the transition dipole moment $\boldsymbol{\mu}_{fi}$ becomes important:</p>
<p>$$\boldsymbol{\mu}_{fi} = \left\langle \psi_f \right| \hat{\boldsymbol{\mu}} \left| \psi_i \right\rangle = \int \psi_f^* \hat{\boldsymbol{\mu}} \psi_i \, d\tau$$</p>
<p>When the transition dipole moment is non-zero ($\boldsymbol{\mu}_{fi} \neq 0$), the transition is called "allowed transition"; when zero, it is called "forbidden transition".</p>
<div class="code-example"><pre><code class="language-python">
            <h4>Code Example 3: Transition Probability Calculation Using Fermi's Golden Rule</h4>
            <pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt

# Physical constants
hbar = 1.054571817e-34  # J¬∑s
eV = 1.602176634e-19    # J

def transition_probability(transition_dipole_moment, state_density, energy_eV):
    """
    Calculate transition probability using Fermi's golden rule (simplified version)

    Parameters:
    -----------
    transition_dipole_moment : float
        Transition dipole moment (Debye)
    state_density : float
        Density of states (eV^-1)
    energy_eV : float
        Transition energy (eV)

    Returns:
    --------
    W : float
        Transition probability (s^-1)
    """
    # Convert Debye to C¬∑m (1 D H 3.336e-30 C¬∑m)
    mu = transition_dipole_moment * 3.336e-30

    # Simplified transition probability (electric dipole approximation)
    # Actual calculation also considers electric field intensity
    W = (2 * np.pi / hbar) * (mu**2) * state_density * eV
    return W

def franck_condon_factor(n_initial, n_final, displacement):
    """
    Approximate calculation of Franck-Condon factor (harmonic oscillator approximation)

    Parameters:
    -----------
    n_initial : int
        Initial vibrational quantum number
    n_final : int
        Final vibrational quantum number
    displacement : float
        Displacement of equilibrium position (dimensionless)

    Returns:
    --------
    fc_factor : float
        Franck-Condon factor
    """
    # Simplification: Gaussian approximation
    delta_n = n_final - n_initial
    fc_factor = np.exp(-displacement**2 / 2) * (displacement**delta_n / np.math.factorial(abs(delta_n)))
    return abs(fc_factor)**2

# Relationship between transition dipole moment and transition probability
dipole_moments = np.linspace(0.1, 5.0, 50)  # Debye
state_density = 1e15  # eV^-1 (typical value for solids)
energy = 2.0  # eV

transition_probs = [transition_probability(mu, state_density, energy) for mu in dipole_moments]

# Calculate Franck-Condon factors (v=0 ‚Äô v' transitions)
displacements = np.linspace(0, 3, 4)
vibrational_levels = np.arange(0, 8)

fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 5))

# Transition dipole moment and transition probability
ax1.plot(dipole_moments, np.array(transition_probs) * 1e-15, linewidth=2, color='#f093fb')
ax1.set_xlabel('Transition Dipole Moment (Debye)', fontsize=12)
ax1.set_ylabel('Transition Probability (√ó10¬πu s{¬π)', fontsize=12)
ax1.set_title('Transition Dipole Moment vs Transition Probability', fontsize=14, fontweight='bold')
ax1.grid(True, alpha=0.3)

# Franck-Condon factors
for d in displacements:
    fc_factors = [franck_condon_factor(0, v, d) for v in vibrational_levels]
    ax2.plot(vibrational_levels, fc_factors, marker='o', linewidth=2, label=f'‚Äùq = {d:.1f}')

ax2.set_xlabel("Final Vibrational Quantum Number v'", fontsize=12)
ax2.set_ylabel('Franck-Condon Factor', fontsize=12)
ax2.set_title('Franck-Condon Factor Calculation', fontsize=14, fontweight='bold')
ax2.legend()
ax2.grid(True, alpha=0.3)

plt.tight_layout()
plt.savefig('transition_probability.png', dpi=300, bbox_inches='tight')
plt.show()
</code></pre>
        </code></pre></div>
<h3>2.3 Selection Rules</h3>
<p>Selection rules are quantum mechanical rules that determine which transitions are allowed and which are forbidden. The main selection rules are shown below:</p>
<div class="info-box">
<strong>Major Selection Rules</strong>
<ul>
<li><strong>Electric dipole transitions (UV-Vis, IR)</strong>: $\Delta l = \pm 1$ (orbital angular momentum quantum number), $\Delta S = 0$ (spin), $\Delta v = \pm 1$ (vibrational quantum number, harmonic oscillator approximation)</li>
<li><strong>Laporte rule (centrosymmetric molecules)</strong>: Only $g \leftrightarrow u$ allowed ($g \leftrightarrow g$ or $u \leftrightarrow u$ forbidden)</li>
<li><strong>Spin selection rule</strong>: Singlet-singlet and triplet-triplet transitions allowed, singlet-triplet transitions forbidden (though relaxed by spin-orbit coupling)</li>
<li><strong>Raman scattering</strong>: Polarizability change $\partial \alpha / \partial Q \neq 0$ (complementary to IR absorption)</li>
</ul>
</div>
<h3>2.4 Franck-Condon Principle</h3>
<p>The Franck-Condon principle states that electronic transitions are very fast (~10<sup>-15</sup> s) compared to the timescale of vibrations (~10<sup>-13</sup> s), so the nuclear positions hardly change during electronic transitions. This results in vibrational structure appearing in absorption and emission spectra.</p>
<div class="code-example"><pre><code class="language-python">
            <h4>Code Example 4: Absorption Spectrum Simulation Based on Franck-Condon Principle</h4>
            <pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
from scipy.special import factorial

def harmonic_oscillator_wavefunction(x, n, omega=1.0, m=1.0, hbar=1.0):
    """
    Harmonic oscillator wavefunction

    Parameters:
    -----------
    x : array
        Coordinate
    n : int
        Quantum number
    omega : float
        Angular frequency
    m : float
        Mass
    hbar : float
        Reduced Planck's constant

    Returns:
    --------
    psi : array
        Wavefunction
    """
    alpha = np.sqrt(m * omega / hbar)
    norm = (alpha / np.pi)**0.25 / np.sqrt(2**n * factorial(n))
    hermite = np.polynomial.hermite.hermval(alpha * x, [0]*n + [1])
    psi = norm * hermite * np.exp(-alpha**2 * x**2 / 2)
    return psi

def franck_condon_spectrum(displacement=1.5, n_levels=6):
    """
    Absorption spectrum simulation based on Franck-Condon principle

    Parameters:
    -----------
    displacement : float
        Displacement of equilibrium positions between excited and ground states
    n_levels : int
        Number of vibrational levels to consider

    Returns:
    --------
    energies : array
        Transition energies
    intensities : array
        Relative intensities
    """
    # Coordinate grid
    x = np.linspace(-6, 6, 1000)

    # Ground state v=0 wavefunction
    psi_ground = harmonic_oscillator_wavefunction(x, 0)

    energies = []
    intensities = []

    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 6))

    # Potential energy curves
    V_ground = 0.5 * x**2
    V_excited = 0.5 * (x - displacement)**2 + 3.0  # Excited state (upward shift)

    ax1.plot(x, V_ground, 'b-', linewidth=2, label='Ground State')
    ax1.plot(x, V_excited, 'r-', linewidth=2, label='Excited State')

    # Transitions to each vibrational level
    for n in range(n_levels):
        # Excited state v=n wavefunction (equilibrium position shifted by displacement)
        psi_excited = harmonic_oscillator_wavefunction(x - displacement, n)

        # Franck-Condon integral (overlap integral)
        fc_integral = np.trapz(psi_ground * psi_excited, x)
        fc_factor = fc_integral**2

        # Transition energy (electronic transition + vibrational energy)
        E_transition = 3.0 + n * 0.2  # in eV

        energies.append(E_transition)
        intensities.append(fc_factor)

        # Draw vibrational levels on potential curves
        E_vib_ground = 0.5
        E_vib_excited = 3.0 + n * 0.2
        ax1.axhline(y=E_vib_excited, xmin=0.5, xmax=0.9, color='red', alpha=0.3, linewidth=1)

        # Transition arrows
        if n &lt; 4:
            ax1.annotate('', xy=(displacement, E_vib_excited), xytext=(0, E_vib_ground),
                        arrowprops=dict(arrowstyle='-&gt;', color='green', alpha=0.5, lw=1.5))

    ax1.set_xlabel('Nuclear Coordinate (a.u.)', fontsize=12)
    ax1.set_ylabel('Energy (eV)', fontsize=12)
    ax1.set_title('Franck-Condon Principle', fontsize=14, fontweight='bold')
    ax1.legend()
    ax1.set_ylim(0, 5)
    ax1.grid(True, alpha=0.3)

    # Absorption spectrum
    energies = np.array(energies)
    intensities = np.array(intensities)

    # Gaussian broadening
    E_range = np.linspace(2.8, 4.5, 500)
    spectrum = np.zeros_like(E_range)
    broadening = 0.05  # eV

    for E, I in zip(energies, intensities):
        spectrum += I * np.exp(-(E_range - E)**2 / (2 * broadening**2))

    ax2.plot(E_range, spectrum, linewidth=2, color='#f093fb')
    ax2.fill_between(E_range, spectrum, alpha=0.3, color='#f5576c')
    ax2.set_xlabel('Photon Energy (eV)', fontsize=12)
    ax2.set_ylabel('Absorption Intensity (a.u.)', fontsize=12)
    ax2.set_title('Simulated Absorption Spectrum', fontsize=14, fontweight='bold')
    ax2.grid(True, alpha=0.3)

    plt.tight_layout()
    plt.savefig('franck_condon_spectrum.png', dpi=300, bbox_inches='tight')
    plt.show()

    return energies, intensities

# Execute
energies, intensities = franck_condon_spectrum(displacement=1.5)
print("Transition energies (eV):", energies)
print("Franck-Condon factors:", intensities)
</code></pre>
        </code></pre></div>
<h2>3. Classification of Spectroscopic Methods</h2>
<h3>3.1 Classification by Energy Region</h3>
<div class="mermaid">
        flowchart LR
            A[Electromagnetic Spectrum] --&gt; B[X-ray<br/>0.01-10 nm]
            A --&gt; C[UV-Vis<br/>200-800 nm]
            A --&gt; D[Infrared<br/>2.5-25 ¬ºm]
            A --&gt; E[Microwave<br/>0.1-10 cm]

            B --&gt; B1[XPS<br/>Chemical State]
            B --&gt; B2[XRF<br/>Elemental Analysis]

            C --&gt; C1[UV-Vis<br/>Electronic Transitions]
            C --&gt; C2[PL<br/>Emission]

            D --&gt; D1[FTIR<br/>Vibrations]
            D --&gt; D2[Raman<br/>Vibrations]

            E --&gt; E1[ESR<br/>Magnetic Resonance]
            E --&gt; E2[NMR<br/>Nuclear Spin]

            style A fill:#f093fb,color:#fff
            style B fill:#ff6b6b,color:#fff
            style C fill:#4ecdc4,color:#fff
            style D fill:#ffe66d,color:#000
            style E fill:#a8e6cf,color:#000
        
        </div>
<h3>3.2 Classification by Measurement Principle</h3>
<ul>
<li><strong>Absorption Spectroscopy</strong>: UV-Vis, FTIR, Atomic Absorption Spectroscopy (AAS)</li>
<li><strong>Emission Spectroscopy</strong>: Fluorescence (PL), Phosphorescence, Chemiluminescence</li>
<li><strong>Scattering Spectroscopy</strong>: Raman, Brillouin scattering</li>
<li><strong>Resonance Spectroscopy</strong>: NMR, ESR</li>
</ul>
<h2>4. How to Read Spectra</h2>
<h3>4.1 Conversion of Horizontal and Vertical Axes</h3>
<p>Spectroscopic data are expressed in various unit systems:</p>
<ul>
<li><strong>Horizontal axis</strong>: Wavelength $\lambda$ (nm), wavenumber $\tilde{\nu}$ (cm<sup>-1</sup>), energy $E$ (eV), frequency $\nu$ (Hz)</li>
<li><strong>Vertical axis</strong>: Transmittance $T$ (%), absorbance $A$, intensity $I$ (a.u.), molar absorption coefficient $\varepsilon$</li>
</ul>
<div class="code-example"><pre><code class="language-python">
            <h4>Code Example 5: Wavelength-Wavenumber-Energy Conversion Calculator</h4>
            <pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt

class SpectroscopyUnitConverter:
    """Spectroscopy unit conversion class"""

    def __init__(self):
        self.h = 6.62607015e-34  # J¬∑s
        self.c = 2.99792458e8    # m/s
        self.eV = 1.602176634e-19  # J

    def wavelength_to_wavenumber(self, wavelength_nm):
        """Wavelength (nm) ‚Äô Wavenumber (cm^-1)"""
        wavelength_cm = wavelength_nm * 1e-7
        return 1 / wavelength_cm

    def wavenumber_to_wavelength(self, wavenumber_cm):
        """Wavenumber (cm^-1) ‚Äô Wavelength (nm)"""
        wavelength_cm = 1 / wavenumber_cm
        return wavelength_cm * 1e7

    def wavelength_to_energy_eV(self, wavelength_nm):
        """Wavelength (nm) ‚Äô Energy (eV)"""
        wavelength_m = wavelength_nm * 1e-9
        energy_J = self.h * self.c / wavelength_m
        return energy_J / self.eV

    def energy_eV_to_wavelength(self, energy_eV):
        """Energy (eV) ‚Äô Wavelength (nm)"""
        energy_J = energy_eV * self.eV
        wavelength_m = self.h * self.c / energy_J
        return wavelength_m * 1e9

    def wavelength_to_frequency(self, wavelength_nm):
        """Wavelength (nm) ‚Äô Frequency (Hz)"""
        wavelength_m = wavelength_nm * 1e-9
        return self.c / wavelength_m

    def transmittance_to_absorbance(self, T):
        """Transmittance (%) ‚Äô Absorbance"""
        T_fraction = T / 100
        return -np.log10(T_fraction)

    def absorbance_to_transmittance(self, A):
        """Absorbance ‚Äô Transmittance (%)"""
        return 10**(-A) * 100

# Instantiate converter
converter = SpectroscopyUnitConverter()

# Conversion table for UV-Vis region
wavelengths_nm = np.array([200, 250, 300, 400, 500, 600, 700, 800])
wavenumbers_cm = converter.wavelength_to_wavenumber(wavelengths_nm)
energies_eV = converter.wavelength_to_energy_eV(wavelengths_nm)
frequencies_THz = converter.wavelength_to_frequency(wavelengths_nm) / 1e12

print("=" * 70)
print("UV-Vis Region Unit Conversion Table")
print("=" * 70)
print(f"{'Wavelength (nm)':&lt;12} {'Wavenumber (cm{¬π)':&lt;15} {'Energy (eV)':&lt;15} {'Frequency (THz)':&lt;12}")
print("-" * 70)
for wl, wn, E, f in zip(wavelengths_nm, wavenumbers_cm, energies_eV, frequencies_THz):
    print(f"{wl:&lt;12.0f} {wn:&lt;15.0f} {E:&lt;15.2f} {f:&lt;12.1f}")

# Conversion table for IR region
print("\n" + "=" * 70)
print("Infrared Region Unit Conversion Table")
print("=" * 70)
wavenumbers_IR = np.array([4000, 3000, 2000, 1500, 1000, 500])
wavelengths_IR = converter.wavenumber_to_wavelength(wavenumbers_IR)
energies_IR_eV = converter.wavelength_to_energy_eV(wavelengths_IR)

print(f"{'Wavenumber (cm{¬π)':&lt;15} {'Wavelength (¬ºm)':&lt;15} {'Energy (eV)':&lt;15}")
print("-" * 70)
for wn, wl, E in zip(wavenumbers_IR, wavelengths_IR / 1000, energies_IR_eV):
    print(f"{wn:&lt;15.0f} {wl:&lt;15.2f} {E:&lt;15.4f}")

# Relationship between transmittance and absorbance
transmittances = np.linspace(1, 100, 100)
absorbances = converter.transmittance_to_absorbance(transmittances)

plt.figure(figsize=(10, 6))
plt.plot(transmittances, absorbances, linewidth=2, color='#f093fb')
plt.xlabel('Transmittance (%)', fontsize=12)
plt.ylabel('Absorbance', fontsize=12)
plt.title('Relationship between Transmittance and Absorbance', fontsize=14, fontweight='bold')
plt.grid(True, alpha=0.3)
plt.tight_layout()
plt.savefig('transmittance_absorbance.png', dpi=300, bbox_inches='tight')
plt.show()
</code></pre>
        </code></pre></div>
<h3>4.2 Interpretation of Peak Position, Intensity, and Width</h3>
<p>The following information can be obtained from spectral peaks:</p>
<ul>
<li><strong>Peak position</strong>: Energy level difference $\Delta E$, type of chemical bonding, band gap</li>
<li><strong>Peak intensity</strong>: Transition probability, concentration, molar absorption coefficient</li>
<li><strong>Peak width (FWHM)</strong>: Inhomogeneous broadening (crystallinity, defects), homogeneous broadening (lifetime)</li>
</ul>
<div class="code-example"><pre><code class="language-python">
            <h4>Code Example 6: Gaussian and Lorentzian Lineshape Fitting</h4>
            <pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit

def gaussian(x, amplitude, center, width):
    """
    Gaussian lineshape function

    Parameters:
    -----------
    x : array
        Horizontal axis (wavelength, energy, etc.)
    amplitude : float
        Peak height
    center : float
        Peak center position
    width : float
        Standard deviation (FWHM = 2.355 * width)

    Returns:
    --------
    y : array
        Gaussian curve
    """
    return amplitude * np.exp(-(x - center)**2 / (2 * width**2))

def lorentzian(x, amplitude, center, width):
    """
    Lorentzian lineshape function

    Parameters:
    -----------
    x : array
        Horizontal axis
    amplitude : float
        Peak height
    center : float
        Peak center position
    width : float
        Half width at half maximum (HWHM)

    Returns:
    --------
    y : array
        Lorentzian curve
    """
    return amplitude * (width**2 / ((x - center)**2 + width**2))

def voigt(x, amplitude, center, width_g, width_l):
    """
    Voigt lineshape function (convolution of Gaussian and Lorentzian)
    Simplified version: pseudo-Voigt

    Parameters:
    -----------
    x : array
        Horizontal axis
    amplitude : float
        Peak height
    center : float
        Peak center position
    width_g : float
        Gaussian component width
    width_l : float
        Lorentzian component width

    Returns:
    --------
    y : array
        Voigt curve
    """
    # pseudo-Voigt: Linear combination of Gaussian and Lorentzian
    eta = 0.5  # mixing parameter
    g = gaussian(x, amplitude, center, width_g)
    l = lorentzian(x, amplitude, center, width_l)
    return eta * l + (1 - eta) * g

# Generate synthetic spectrum (with noise)
x_data = np.linspace(400, 700, 300)  # Wavelength (nm)
true_params = {
    'amplitude': 1.0,
    'center': 550,
    'width': 30
}

# Gaussian + noise
y_data = gaussian(x_data, **true_params) + np.random.normal(0, 0.02, len(x_data))

# Fitting
initial_guess = [0.8, 540, 25]

popt_gauss, _ = curve_fit(gaussian, x_data, y_data, p0=initial_guess)
popt_lorentz, _ = curve_fit(lorentzian, x_data, y_data, p0=initial_guess)

# Visualization of results
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 5))

# Fitting results
ax1.scatter(x_data, y_data, s=10, alpha=0.5, color='gray', label='Experimental Data')
ax1.plot(x_data, gaussian(x_data, *popt_gauss), 'r-', linewidth=2, label='Gaussian Fit')
ax1.plot(x_data, lorentzian(x_data, *popt_lorentz), 'b--', linewidth=2, label='Lorentzian Fit')
ax1.set_xlabel('Wavelength (nm)', fontsize=12)
ax1.set_ylabel('Absorbance (a.u.)', fontsize=12)
ax1.set_title('Peak Shape Fitting', fontsize=14, fontweight='bold')
ax1.legend()
ax1.grid(True, alpha=0.3)

# Comparison of lineshape functions
x_comparison = np.linspace(-100, 100, 500)
y_gauss = gaussian(x_comparison, 1.0, 0, 20)
y_lorentz = lorentzian(x_comparison, 1.0, 0, 20)
y_voigt = voigt(x_comparison, 1.0, 0, 20, 10)

ax2.plot(x_comparison, y_gauss, 'r-', linewidth=2, label='Gaussian')
ax2.plot(x_comparison, y_lorentz, 'b-', linewidth=2, label='Lorentzian')
ax2.plot(x_comparison, y_voigt, 'g-', linewidth=2, label='Voigt (pseudo)')
ax2.set_xlabel('Relative Position', fontsize=12)
ax2.set_ylabel('Normalized Intensity', fontsize=12)
ax2.set_title('Comparison of Lineshape Functions', fontsize=14, fontweight='bold')
ax2.legend()
ax2.grid(True, alpha=0.3)
ax2.set_yscale('log')
ax2.set_ylim(1e-4, 2)

plt.tight_layout()
plt.savefig('peak_fitting.png', dpi=300, bbox_inches='tight')
plt.show()

# Output fitting parameters
print("Gaussian fit results:")
print(f"  Amplitude: {popt_gauss[0]:.3f}")
print(f"  Center: {popt_gauss[1]:.1f} nm")
print(f"  FWHM: {2.355 * popt_gauss[2]:.1f} nm")

print("\nLorentzian fit results:")
print(f"  Amplitude: {popt_lorentz[0]:.3f}")
print(f"  Center: {popt_lorentz[1]:.1f} nm")
print(f"  FWHM: {2 * popt_lorentz[2]:.1f} nm")
</code></pre>
        </code></pre></div>
<h3>4.3 Importance of Baseline Processing</h3>
<p>Measured spectra contain baselines due to absorption by sample holders, scattering, instrumental drift, etc. Baseline correction is essential for accurate quantitative analysis.</p>
<div class="code-example"><pre><code class="language-python">
            <h4>Code Example 7: Baseline Correction (Polynomial Fitting)</h4>
            <pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import find_peaks

def polynomial_baseline(x, y, degree=2, exclude_peaks=True):
    """
    Baseline correction using polynomial fitting

    Parameters:
    -----------
    x : array
        Horizontal axis data
    y : array
        Vertical axis data (spectrum)
    degree : int
        Degree of polynomial
    exclude_peaks : bool
        Exclude peak regions for fitting

    Returns:
    --------
    baseline : array
        Estimated baseline
    corrected : array
        Baseline-corrected spectrum
    """
    if exclude_peaks:
        # Peak detection
        peaks, _ = find_peaks(y, prominence=0.1 * np.max(y))

        # Mask excluding peak regions
        mask = np.ones(len(y), dtype=bool)
        window = int(len(y) * 0.05)  # Exclude 5% around peaks
        for peak in peaks:
            start = max(0, peak - window)
            end = min(len(y), peak + window)
            mask[start:end] = False

        # Polynomial fitting in masked regions
        coeffs = np.polyfit(x[mask], y[mask], degree)
    else:
        coeffs = np.polyfit(x, y, degree)

    baseline = np.polyval(coeffs, x)
    corrected = y - baseline

    return baseline, corrected

# Synthetic spectrum (with baseline)
x = np.linspace(400, 700, 500)

# True spectrum (two peaks)
true_spectrum = gaussian(x, 0.8, 500, 25) + gaussian(x, 0.5, 600, 20)

# Baseline (2nd order polynomial)
baseline_true = 0.1 + 0.0005 * (x - 550) + 0.000001 * (x - 550)**2

# Observed spectrum = true spectrum + baseline + noise
observed_spectrum = true_spectrum + baseline_true + np.random.normal(0, 0.01, len(x))

# Baseline correction
baseline_estimated, corrected_spectrum = polynomial_baseline(x, observed_spectrum, degree=2, exclude_peaks=True)

# Visualization
fig, (ax1, ax2, ax3) = plt.subplots(3, 1, figsize=(10, 12))

# Observed spectrum
ax1.plot(x, observed_spectrum, 'k-', linewidth=1.5, label='Observed Spectrum')
ax1.plot(x, baseline_true, 'r--', linewidth=2, label='True Baseline')
ax1.plot(x, baseline_estimated, 'b--', linewidth=2, label='Estimated Baseline')
ax1.set_xlabel('Wavelength (nm)', fontsize=12)
ax1.set_ylabel('Intensity (a.u.)', fontsize=12)
ax1.set_title('Baseline Correction: Observed Spectrum', fontsize=14, fontweight='bold')
ax1.legend()
ax1.grid(True, alpha=0.3)

# Corrected spectrum
ax2.plot(x, corrected_spectrum, 'g-', linewidth=2, label='Corrected Spectrum')
ax2.plot(x, true_spectrum, 'r--', linewidth=2, alpha=0.7, label='True Spectrum')
ax2.set_xlabel('Wavelength (nm)', fontsize=12)
ax2.set_ylabel('Intensity (a.u.)', fontsize=12)
ax2.set_title('After Baseline Correction', fontsize=14, fontweight='bold')
ax2.legend()
ax2.grid(True, alpha=0.3)

# Residual analysis
residual = corrected_spectrum - true_spectrum
ax3.plot(x, residual, 'purple', linewidth=1)
ax3.axhline(y=0, color='k', linestyle='--', linewidth=1)
ax3.fill_between(x, residual, alpha=0.3, color='purple')
ax3.set_xlabel('Wavelength (nm)', fontsize=12)
ax3.set_ylabel('Residual (a.u.)', fontsize=12)
ax3.set_title('Correction Residual', fontsize=14, fontweight='bold')
ax3.grid(True, alpha=0.3)

plt.tight_layout()
plt.savefig('baseline_correction.png', dpi=300, bbox_inches='tight')
plt.show()

# Statistics
print(f"RMS error before baseline correction: {np.sqrt(np.mean((observed_spectrum - true_spectrum)**2)):.4f}")
print(f"RMS error after baseline correction: {np.sqrt(np.mean(residual**2)):.4f}")
</code></pre>
        </code></pre></div>
<h2>5. Analysis of Multi-Peak Spectra</h2>
<div class="code-example"><pre><code class="language-python">
            <h4>Code Example 8: Automatic Multi-Peak Detection and Fitting</h4>
            <pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import find_peaks
from scipy.optimize import curve_fit

def multi_gaussian(x, *params):
    """
    Sum of multiple Gaussian functions

    Parameters:
    -----------
    x : array
        Horizontal axis
    params : tuple
        (amplitude1, center1, width1, amplitude2, center2, width2, ...)

    Returns:
    --------
    y : array
        Sum of multiple Gaussians
    """
    y = np.zeros_like(x)
    for i in range(0, len(params), 3):
        amplitude = params[i]
        center = params[i+1]
        width = params[i+2]
        y += gaussian(x, amplitude, center, width)
    return y

def auto_peak_fitting(x, y, min_prominence=0.1):
    """
    Automatic peak detection and multi-Gaussian fitting

    Parameters:
    -----------
    x : array
        Horizontal axis data
    y : array
        Vertical axis data
    min_prominence : float
        Minimum prominence for peak detection (relative to maximum)

    Returns:
    --------
    params : array
        Fitting parameters
    fitted : array
        Fitted curve
    individual_peaks : list of arrays
        Individual peak components
    """
    # Baseline correction
    baseline, y_corrected = polynomial_baseline(x, y, degree=1, exclude_peaks=True)

    # Peak detection
    peaks, properties = find_peaks(y_corrected, prominence=min_prominence * np.max(y_corrected))

    print(f"Number of detected peaks: {len(peaks)}")

    # Initial guess
    initial_params = []
    for peak in peaks:
        amplitude = y_corrected[peak]
        center = x[peak]
        width = 20  # Initial width estimate
        initial_params.extend([amplitude, center, width])

    # Multi-Gaussian fitting
    try:
        popt, _ = curve_fit(multi_gaussian, x, y_corrected, p0=initial_params, maxfev=10000)
        fitted = multi_gaussian(x, *popt)

        # Individual peak components
        individual_peaks = []
        for i in range(0, len(popt), 3):
            peak_component = gaussian(x, popt[i], popt[i+1], popt[i+2])
            individual_peaks.append(peak_component)

        return popt, fitted, individual_peaks, baseline

    except RuntimeError:
        print("Fitting failed: did not converge")
        return None, None, None, baseline

# Generate complex spectrum (4 peaks)
x_data = np.linspace(400, 700, 600)
true_components = [
    gaussian(x_data, 0.7, 450, 20),
    gaussian(x_data, 1.0, 520, 25),
    gaussian(x_data, 0.6, 580, 18),
    gaussian(x_data, 0.4, 650, 22)
]
true_spectrum = sum(true_components)
baseline = 0.05 + 0.0001 * x_data
observed = true_spectrum + baseline + np.random.normal(0, 0.02, len(x_data))

# Automatic fitting
params, fitted, individual, baseline_est = auto_peak_fitting(x_data, observed, min_prominence=0.15)

# Visualization
fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 10))

# Fitting results
ax1.plot(x_data, observed, 'k.', markersize=2, alpha=0.5, label='Observed Data')
if fitted is not None:
    ax1.plot(x_data, fitted + baseline_est, 'r-', linewidth=2, label='Fitted Curve')
    for i, peak in enumerate(individual):
        ax1.plot(x_data, peak + baseline_est, '--', linewidth=1.5, alpha=0.7, label=f'Peak {i+1}')
ax1.plot(x_data, baseline_est, 'g--', linewidth=2, label='Baseline')
ax1.set_xlabel('Wavelength (nm)', fontsize=12)
ax1.set_ylabel('Intensity (a.u.)', fontsize=12)
ax1.set_title('Automatic Fitting of Multi-Peak Spectrum', fontsize=14, fontweight='bold')
ax1.legend(loc='best', fontsize=9)
ax1.grid(True, alpha=0.3)

# Separated peak components
if individual is not None:
    for i, peak in enumerate(individual):
        ax2.plot(x_data, peak, linewidth=2, label=f'Peak {i+1}')
        ax2.fill_between(x_data, peak, alpha=0.3)
ax2.set_xlabel('Wavelength (nm)', fontsize=12)
ax2.set_ylabel('Intensity (a.u.)', fontsize=12)
ax2.set_title('Separated Peak Components', fontsize=14, fontweight='bold')
ax2.legend()
ax2.grid(True, alpha=0.3)

plt.tight_layout()
plt.savefig('multi_peak_fitting.png', dpi=300, bbox_inches='tight')
plt.show()

# Detailed fitting results
if params is not None:
    print("\n" + "=" * 60)
    print("Fitting Results")
    print("=" * 60)
    for i in range(0, len(params), 3):
        peak_num = i // 3 + 1
        amplitude = params[i]
        center = params[i+1]
        width = params[i+2]
        fwhm = 2.355 * width
        area = amplitude * width * np.sqrt(2 * np.pi)
        print(f"\nPeak {peak_num}:")
        print(f"  Center position: {center:.1f} nm")
        print(f"  Amplitude: {amplitude:.3f}")
        print(f"  FWHM: {fwhm:.1f} nm")
        print(f"  Area: {area:.3f}")
</code></pre>
        </code></pre></div>
<h2>Exercises</h2>
<details>
<summary><strong>Exercises (click to expand)</strong></summary>
<h3>Easy Level (Basic Calculations)</h3>
<p><strong>Problem 1</strong>: Calculate the photon energy in eV for light with a wavelength of 500 nm. Also, what color in the visible spectrum does this light correspond to?</p>
<details>
<summary>View solution</summary>
<p><strong>Solution</strong>:</p>
<pre><code class="language-python">h = 6.626e-34  # J¬∑s
c = 2.998e8    # m/s
eV = 1.602e-19  # J

wavelength = 500e-9  # m
E = h * c / wavelength / eV
print(f"Photon energy: {E:.2f} eV")
# Output: Photon energy: 2.48 eV
# 500 nm corresponds to green light
</code></pre>
</details>
<p><strong>Problem 2</strong>: In the Beer-Lambert law, if the molar absorption coefficient $\varepsilon = 50000$ L mol<sup>-1</sup> cm<sup>-1</sup>, path length $l = 1$ cm, and absorbance $A = 0.8$, find the sample concentration (mol/L).</p>
<details>
<summary>View solution</summary>
<p><strong>Solution</strong>:</p>
<pre><code class="language-python">epsilon = 50000  # L mol^-1 cm^-1
l = 1.0  # cm
A = 0.8

c = A / (epsilon * l)
print(f"Concentration: {c:.2e} mol/L = {c * 1e6:.2f} ¬ºmol/L")
# Output: Concentration: 1.60e-05 mol/L = 16.00 ¬ºmol/L
</code></pre>
</details>
<p><strong>Problem 3</strong>: In infrared spectroscopy, a peak is observed at wavenumber 1650 cm<sup>-1</sup>. Calculate the wavelength (¬ºm) and energy (eV) corresponding to this wavenumber.</p>
<details>
<summary>View solution</summary>
<p><strong>Solution</strong>:</p>
<pre><code class="language-python">wavenumber = 1650  # cm^-1

# Wavenumber to wavelength
wavelength_cm = 1 / wavenumber
wavelength_um = wavelength_cm * 1e4
print(f"Wavelength: {wavelength_um:.2f} ¬ºm")

# Energy
h = 6.626e-34
c = 2.998e8
eV = 1.602e-19
energy_J = h * c * wavenumber * 100  # cm^-1 to m^-1
energy_eV = energy_J / eV
print(f"Energy: {energy_eV:.4f} eV")
# Output: Wavelength: 6.06 ¬ºm, Energy: 0.2045 eV
</code></pre>
</details>
<h3>Medium Level (Practical Calculations)</h3>
<p><strong>Problem 4</strong>: The data below show measurements of concentration and absorbance for a solution. Create a calibration curve using the Beer-Lambert law and estimate the concentration of an unknown sample (absorbance 0.65).</p>
<table border="1" style="border-collapse: collapse; margin: 1em 0;">
<tr><th>Concentration (¬ºmol/L)</th><td>10</td><td>20</td><td>30</td><td>40</td><td>50</td></tr>
<tr><th>Absorbance</th><td>0.18</td><td>0.35</td><td>0.53</td><td>0.71</td><td>0.88</td></tr>
</table>
<details>
<summary>View solution</summary>
<p><strong>Solution</strong>:</p>
<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import linregress

# Data
concentrations = np.array([10, 20, 30, 40, 50])  # ¬ºmol/L
absorbances = np.array([0.18, 0.35, 0.53, 0.71, 0.88])

# Linear regression
slope, intercept, r_value, p_value, std_err = linregress(concentrations, absorbances)

print(f"Calibration curve: A = {slope:.4f} * C + {intercept:.4f}")
print(f"Correlation coefficient R¬≤: {r_value**2:.4f}")

# Estimate concentration of unknown sample
unknown_A = 0.65
unknown_C = (unknown_A - intercept) / slope
print(f"Unknown sample concentration: {unknown_C:.1f} ¬ºmol/L")

# Visualization
plt.figure(figsize=(8, 6))
plt.scatter(concentrations, absorbances, s=100, color='#f093fb', label='Measured Data')
plt.plot(concentrations, slope * concentrations + intercept, 'r-', linewidth=2, label=f'Calibration Curve (R¬≤={r_value**2:.3f})')
plt.scatter([unknown_C], [unknown_A], s=150, color='#f5576c', marker='*', label='Unknown Sample', zorder=5)
plt.xlabel('Concentration (¬ºmol/L)', fontsize=12)
plt.ylabel('Absorbance', fontsize=12)
plt.title('Creating Calibration Curve', fontsize=14, fontweight='bold')
plt.legend()
plt.grid(True, alpha=0.3)
plt.tight_layout()
plt.show()

# Output: Unknown sample concentration: 36.4 ¬ºmol/L
</code></pre>
</details>
<p><strong>Problem 5</strong>: Suppose an absorption spectrum can be approximated by the following Gaussian function. Calculate the peak center, FWHM, and integrated intensity.</p>
<p>$$I(\lambda) = 0.8 \exp\left(-\frac{(\lambda - 520)^2}{2 \times 25^2}\right)$$</p>
<details>
<summary>View solution</summary>
<p><strong>Solution</strong>:</p>
<pre><code class="language-python">import numpy as np
from scipy.integrate import quad

# Gaussian function parameters
amplitude = 0.8
center = 520  # nm
sigma = 25  # nm

# FWHM calculation
fwhm = 2.355 * sigma
print(f"Peak center: {center} nm")
print(f"FWHM: {fwhm:.1f} nm")

# Integrated intensity (analytical solution)
integral_analytical = amplitude * sigma * np.sqrt(2 * np.pi)
print(f"Integrated intensity (analytical): {integral_analytical:.2f}")

# Verification by numerical integration
def gaussian_func(x):
    return amplitude * np.exp(-(x - center)**2 / (2 * sigma**2))

integral_numerical, error = quad(gaussian_func, 0, 1000)
print(f"Integrated intensity (numerical): {integral_numerical:.2f}")

# Output: Peak center: 520 nm, FWHM: 58.9 nm, Integrated intensity: 50.13
</code></pre>
</details>
<p><strong>Problem 6</strong>: Based on the Franck-Condon principle, calculate transition intensities from the ground state (v=0) to different vibrational levels of the excited state (v'=0, 1, 2, 3). Assume the equilibrium position of the excited state is displaced by 1.2 in dimensionless coordinates from the ground state.</p>
<details>
<summary>View solution</summary>
<p><strong>Solution</strong>:</p>
<pre><code class="language-python">import numpy as np

def franck_condon_factor_harmonic(n_i, n_f, displacement):
    """
    Franck-Condon factor (harmonic oscillator approximation)
    Simplified formula for n_i = 0
    """
    from scipy.special import factorial

    if n_i == 0:
        S = displacement**2 / 2  # Huang-Rhys factor
        fc = np.exp(-S) * (S**n_f) / factorial(n_f)
    return fc

displacement = 1.2
vibrational_levels = [0, 1, 2, 3]

print("Franck-Condon factors (v=0 ‚Äô v' transitions):")
print("=" * 40)
for v_f in vibrational_levels:
    fc = franck_condon_factor_harmonic(0, v_f, displacement)
    print(f"v=0 ‚Äô v'={v_f}: {fc:.4f}")

# Normalized relative intensities
fc_values = [franck_condon_factor_harmonic(0, v, displacement) for v in vibrational_levels]
fc_normalized = np.array(fc_values) / np.max(fc_values)
print("\nRelative intensities (normalized to maximum):")
for v, intensity in zip(vibrational_levels, fc_normalized):
    print(f"v'={v}: {intensity:.2f}")
</code></pre>
</details>
<h3>Hard Level (Advanced Analysis)</h3>
<p><strong>Problem 7</strong>: Generate a synthetic spectrum consisting of two Gaussian peaks (centers: 500 nm, 550 nm; width: 20 nm; amplitude ratio 2:1) and add noise (standard deviation 0.05). Then perform two-component fitting using scipy.optimize.curve_fit to recover the original parameters.</p>
<details>
<summary>View solution</summary>
<p><strong>Solution</strong>:</p>
<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit

def two_gaussian(x, A1, c1, w1, A2, c2, w2):
    """Sum of two Gaussians"""
    g1 = A1 * np.exp(-(x - c1)**2 / (2 * w1**2))
    g2 = A2 * np.exp(-(x - c2)**2 / (2 * w2**2))
    return g1 + g2

# True parameters
true_params = [1.0, 500, 20, 0.5, 550, 20]

# Synthetic spectrum
x = np.linspace(400, 650, 300)
y_true = two_gaussian(x, *true_params)
y_noisy = y_true + np.random.normal(0, 0.05, len(x))

# Fitting (initial guess)
initial_guess = [0.8, 495, 18, 0.4, 545, 22]
popt, pcov = curve_fit(two_gaussian, x, y_noisy, p0=initial_guess)

# Visualization of results
plt.figure(figsize=(10, 6))
plt.plot(x, y_noisy, 'k.', markersize=3, alpha=0.5, label='Noisy Data')
plt.plot(x, y_true, 'g--', linewidth=2, label='True Spectrum')
plt.plot(x, two_gaussian(x, *popt), 'r-', linewidth=2, label='Fitted Result')

# Individual components
plt.plot(x, popt[0] * np.exp(-(x - popt[1])**2 / (2 * popt[2]**2)), 'b--', alpha=0.7, label='Peak 1')
plt.plot(x, popt[3] * np.exp(-(x - popt[4])**2 / (2 * popt[5]**2)), 'm--', alpha=0.7, label='Peak 2')

plt.xlabel('Wavelength (nm)', fontsize=12)
plt.ylabel('Intensity (a.u.)', fontsize=12)
plt.title('Two-Component Gaussian Fitting', fontsize=14, fontweight='bold')
plt.legend()
plt.grid(True, alpha=0.3)
plt.tight_layout()
plt.show()

# Parameter comparison
print("Parameter recovery results:")
print("=" * 60)
labels = ['Amplitude1', 'Center1', 'Width1', 'Amplitude2', 'Center2', 'Width2']
for label, true, fitted in zip(labels, true_params, popt):
    error = abs(fitted - true) / true * 100
    print(f"{label:8s}: True={true:6.2f}, Fitted={fitted:6.2f}, Error={error:5.2f}%")
</code></pre>
</details>
<p><strong>Problem 8</strong>: Based on selection rules, determine whether the following transitions are allowed or forbidden.</p>
<ul>
<li>(a) 1s ‚Äô 2p transition in hydrogen atom</li>
<li>(b) 1s ‚Äô 2s transition in hydrogen atom</li>
<li>(c) √Ä ‚Äô √Ä* transition in benzene (D<sub>6h</sub> symmetry)</li>
<li>(d) d-d transition in octahedral complex (O<sub>h</sub> symmetry)</li>
</ul>
<details>
<summary>View solution</summary>
<p><strong>Solution</strong>:</p>
<p>(a) <strong>Allowed</strong>: $\Delta l = +1$ (s ‚Äô p), satisfies selection rule for electric dipole transitions.</p>
<p>(b) <strong>Forbidden</strong>: $\Delta l = 0$ (s ‚Äô s), electric dipole transitions require $\Delta l = \pm 1$.</p>
<p>(c) <strong>Allowed</strong>: Transition from √Ä orbital (√Ä<sub>u</sub>) to √Ä* orbital (√Ä<sub>g</sub>*) satisfies Laporte rule (g ‚Äù u).</p>
<p>(d) <strong>Forbidden</strong> (Laporte-forbidden): Both are d orbitals (g symmetry), so g ‚Äù g transition. However, weak absorption may be observed due to symmetry breaking by vibrations or ligand effects.</p>
</details>
<p><strong>Problem 9</strong>: Given measured absorption spectrum data, perform the following analysis steps:</p>
<ol>
<li>Baseline correction (2nd order polynomial fitting)</li>
<li>Automatic peak detection</li>
<li>Gaussian fitting of each peak</li>
<li>Calculate peak center, FWHM, and integrated intensity</li>
</ol>
<details>
<summary>View solution (complete analysis code)</summary>
<p>Due to length constraints, this solution is abbreviated. Please refer to Code Example 8 for the complete implementation framework.</p>
</details>
<p><strong>Problem 10</strong>: Implement the Voigt lineshape (convolution of Gaussian and Lorentzian) and plot and compare pure Gaussian, pure Lorentzian, and Voigt lineshapes. The Voigt lineshape is defined by the following integral:</p>
<p>$$V(x; \sigma, \gamma) = \int_{-\infty}^{\infty} G(x'; \sigma) L(x - x'; \gamma) \, dx'$$</p>
<details>
<summary>View solution</summary>
<p>Use scipy.special.wofz (Faddeeva function) for efficient Voigt profile calculation. See the peak fitting section for implementation details.</p>
</details>
</details>
<h2>Learning Objectives Check</h2>
<p>Review what you learned in this chapter and verify the following items.</p>
<h3>Basic Understanding</h3>
<ul>
<li> Can explain the relationship between photon energy and wavelength (Planck relation)</li>
<li> Understand the differences and physical mechanisms of absorption, emission, and scattering</li>
<li> Can explain the physical meaning and application conditions of Beer-Lambert law</li>
<li> Understand the concept of selection rules and major selection rules ($\Delta l = \pm 1$, Laporte rule, etc.)</li>
</ul>
<h3>Practical Skills</h3>
<ul>
<li> Can interconvert wavelength, wavenumber, and energy</li>
<li> Can perform concentration calculations and create calibration curves using Beer-Lambert law</li>
<li> Can perform peak fitting (Gaussian/Lorentzian) on spectra</li>
<li> Can appropriately perform baseline correction</li>
</ul>
<h3>Applied Capabilities</h3>
<ul>
<li> Can calculate transition probabilities from Fermi's golden rule</li>
<li> Can interpret vibrational structure based on Franck-Condon principle</li>
<li> Can separate and quantify multi-peak spectra</li>
</ul>
<h2>References</h2>
<ol>
<li>Atkins, P., de Paula, J. (2010). <em>Physical Chemistry</em> (9th ed.). Oxford University Press, pp. 465-468 (Beer-Lambert law), pp. 485-490 (transition dipole moments), pp. 501-506 (selection rules). - Detailed explanation of quantum mechanical foundations of spectroscopy and transition moments</li>
<li>Banwell, C. N., McCash, E. M. (1994). <em>Fundamentals of Molecular Spectroscopy</em> (4th ed.). McGraw-Hill, pp. 8-15 (electromagnetic radiation), pp. 28-35 (Beer-Lambert law applications). - Basic principles of spectroscopic analysis and applications of Beer-Lambert law</li>
<li>Hollas, J. M. (2004). <em>Modern Spectroscopy</em> (4th ed.). Wiley, pp. 15-23 (selection rules), pp. 45-52 (Franck-Condon principle), pp. 78-85 (transition probabilities). - Comprehensive explanation of selection rules and Franck-Condon principle</li>
<li>Beer, A. (1852). Bestimmung der Absorption des rothen Lichts in farbigen Fl√ºssigkeiten. <em>Annalen der Physik und Chemie</em>, 86, 78-88. DOI: 10.1002/andp.18521620505 - Original paper of Beer-Lambert law (historical reference)</li>
<li>Shirley, D. A. (1972). High-resolution X-ray photoemission spectrum of the valence bands of gold. <em>Physical Review B</em>, 5(12), 4709-4714. DOI: 10.1103/PhysRevB.5.4709 - Original paper of Shirley background correction algorithm</li>
<li>NumPy 1.24 and SciPy 1.11 Documentation. <em>Signal Processing (scipy.signal) and Optimization (scipy.optimize)</em>. Available at: https://docs.scipy.org/doc/scipy/reference/signal.html - Practical methods for spectral data analysis with Python</li>
<li>Turrell, G., Corset, J. (Eds.). (1996). <em>Raman Microscopy: Developments and Applications</em>. Academic Press, pp. 25-34 (classical scattering theory), pp. 58-67 (selection rules for Raman). - Details of scattering spectroscopy theory and selection rules</li>
<li>Levine, I. N. (2013). <em>Quantum Chemistry</em> (7th ed.). Pearson, pp. 580-595 (time-dependent perturbation theory), pp. 620-635 (transition dipole moments). - Transition dipole moments and quantum mechanical calculation methods</li>
</ol>
<h2>Next Steps</h2>
<p>In Chapter 1, we learned the foundations of spectroscopic analysis: light-matter interactions, Beer-Lambert law, quantum mechanical principles, and selection rules. We also acquired practical data processing skills with Python (unit conversion, peak fitting, baseline correction).</p>
<p>In <strong>Chapter 2</strong>, we will apply this foundational knowledge to learn the principles and practice of infrared and Raman spectroscopy. We will cover everything about vibrational spectroscopy frequently used in materials science, including functional group identification, crystallinity evaluation, complementary relationship between IR and Raman, and detailed selection rules through group theory.</p>
<div class="navigation">
<a class="nav-button" href="./index.html">ÔøΩ Back to Series Overview</a>
<a class="nav-button" href="./chapter-2.html">Chapter 2: Infrared and Raman Spectroscopy ‚Äô</a>
</div>
</main>
<footer>
<p>¬© 2025 MS Terakoya - Materials Science Learning Platform</p>
<p><a href="../index.html">Back to Top Page</a></p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
</body>
</html>
