<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Chapter 4: X-ray Photoelectron Spectroscopy (XPS) - Introduction to Spectroscopy</title>
<!-- MathJax for equations -->
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<!-- Mermaid for diagrams -->
<script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
<!-- Prism.js for code highlighting -->
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet"/>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
<style>
        :root {
            --color-primary: #2c3e50;
            --color-accent: #f093fb;
            --color-accent-light: #f5576c;
            --color-bg: #ffffff;
            --color-text: #333333;
            --color-border: #e0e0e0;
            --color-code-bg: #f8f9fa;
            --spacing-unit: 8px;
            --font-body: 'Segoe UI', 'Helvetica Neue', Arial, sans-serif;
            --font-code: 'Consolas', 'Monaco', monospace;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-body);
            line-height: 1.8;
            color: var(--color-text);
            background: var(--color-bg);
            padding: calc(var(--spacing-unit) * 4);
            max-width: 1200px;
            margin: 0 auto;
        }

        h1, h2, h3, h4 {
            color: var(--color-primary);
            margin-top: calc(var(--spacing-unit) * 6);
            margin-bottom: calc(var(--spacing-unit) * 3);
            line-height: 1.3;
        }

        h1 {
            font-size: 2.5rem;
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            padding-bottom: calc(var(--spacing-unit) * 2);
            border-bottom: 3px solid var(--color-accent);
        }

        h2 {
            font-size: 1.8rem;
            padding-left: calc(var(--spacing-unit) * 2);
            border-left: 4px solid var(--color-accent);
        }

        h3 {
            font-size: 1.4rem;
            color: var(--color-accent-light);
        }

        h4 {
            font-size: 1.2rem;
        }

        p {
            margin-bottom: calc(var(--spacing-unit) * 2);
            text-align: justify;
        }

        .intro-box {
            background: linear-gradient(135deg, rgba(240, 147, 251, 0.1) 0%, rgba(245, 87, 108, 0.1) 100%);
            padding: calc(var(--spacing-unit) * 3);
            border-radius: 8px;
            border-left: 4px solid var(--color-accent);
            margin: calc(var(--spacing-unit) * 4) 0;
        }

        .key-concept {
            background: var(--color-code-bg);
            padding: calc(var(--spacing-unit) * 3);
            border-radius: 8px;
            margin: calc(var(--spacing-unit) * 3) 0;
            border: 2px solid var(--color-border);
        }

        .equation-box {
            background: #fff;
            padding: calc(var(--spacing-unit) * 3);
            border-radius: 8px;
            margin: calc(var(--spacing-unit) * 3) 0;
            border: 2px solid var(--color-accent-light);
            box-shadow: 0 2px 8px rgba(245, 87, 108, 0.1);
        }

        code {
            font-family: var(--font-code);
            background: var(--color-code-bg);
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.9em;
        }

        pre {
            background: #2d2d2d;
            padding: calc(var(--spacing-unit) * 3);
            border-radius: 8px;
            overflow-x: auto;
            margin: calc(var(--spacing-unit) * 3) 0;
            border: 2px solid var(--color-accent);
        }

        pre code {
            background: none;
            color: #f8f8f2;
            padding: 0;
        }

        .mermaid {
            background: white;
            padding: calc(var(--spacing-unit) * 3);
            border-radius: 8px;
            margin: calc(var(--spacing-unit) * 4) 0;
            border: 2px solid var(--color-border);
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: calc(var(--spacing-unit) * 3) 0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        th, td {
            padding: calc(var(--spacing-unit) * 2);
            text-align: left;
            border: 1px solid var(--color-border);
        }

        th {
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            color: white;
            font-weight: 600;
        }

        tr:nth-child(even) {
            background: var(--color-code-bg);
        }

        ul, ol {
            margin: calc(var(--spacing-unit) * 2) 0;
            padding-left: calc(var(--spacing-unit) * 5);
        }

        li {
            margin: calc(var(--spacing-unit) * 1) 0;
        }

        .exercise-box {
            background: linear-gradient(135deg, rgba(240, 147, 251, 0.05) 0%, rgba(245, 87, 108, 0.05) 100%);
            padding: calc(var(--spacing-unit) * 3);
            border-radius: 8px;
            margin: calc(var(--spacing-unit) * 3) 0;
            border-left: 4px solid var(--color-accent-light);
        }

        .exercise-box h4 {
            color: var(--color-accent-light);
            margin-top: 0;
        }

        details {
            margin: calc(var(--spacing-unit) * 2) 0;
            padding: calc(var(--spacing-unit) * 2);
            background: white;
            border-radius: 8px;
            border: 1px solid var(--color-border);
        }

        summary {
            cursor: pointer;
            font-weight: 600;
            color: var(--color-accent-light);
            padding: calc(var(--spacing-unit) * 1);
        }

        summary:hover {
            color: var(--color-accent);
        }

        .learning-objectives {
            background: linear-gradient(135deg, rgba(240, 147, 251, 0.1) 0%, rgba(245, 87, 108, 0.1) 100%);
            padding: calc(var(--spacing-unit) * 3);
            border-radius: 8px;
            margin: calc(var(--spacing-unit) * 4) 0;
        }

        .learning-objectives ul {
            list-style: none;
            padding-left: 0;
        }

        .learning-objectives li::before {
            content: " ";
            color: var(--color-accent-light);
            font-weight: bold;
            margin-right: calc(var(--spacing-unit) * 1);
        }

        .references {
            background: var(--color-code-bg);
            padding: calc(var(--spacing-unit) * 3);
            border-radius: 8px;
            margin-top: calc(var(--spacing-unit) * 6);
        }

        .references h2 {
            border-left: none;
            padding-left: 0;
        }

        .references ol {
            padding-left: calc(var(--spacing-unit) * 4);
        }

        .references li {
            margin: calc(var(--spacing-unit) * 2) 0;
            line-height: 1.6;
        }

        @media (max-width: 768px) {
            body {
                padding: calc(var(--spacing-unit) * 2);
            }

            h1 {
                font-size: 2rem;
            }

            h2 {
                font-size: 1.5rem;
            }

            pre {
                padding: calc(var(--spacing-unit) * 2);
            }
        }



        /* Breadcrumb styles */
        .breadcrumb {
            background: #f7fafc;
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #e2e8f0;
            font-size: 0.9rem;
        }

        .breadcrumb-content {
            max-width: 900px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .breadcrumb a {
            color: #667eea;
            text-decoration: none;
            transition: color 0.2s;
        }

        .breadcrumb a:hover {
            color: #764ba2;
            text-decoration: underline;
        }

        .breadcrumb-separator {
            color: #a0aec0;
            margin: 0 0.25rem;
        }

        .breadcrumb-current {
            color: #4a5568;
            font-weight: 500;
        }
    </style>
</head>
<body>
<nav class="breadcrumb">
<div class="breadcrumb-content">
<a href="../index.html">AI Terakoya Top</a><span class="breadcrumb-separator">:</span><a href="../../MS/index.html">Materials Science</a><span class="breadcrumb-separator">:</span><a href="../../MS/spectroscopy-introduction/index.html">Spectroscopy</a><span class="breadcrumb-separator">:</span><span class="breadcrumb-current">Chapter 4</span>
</div>
</nav>
<h1>Chapter 4: X-ray Photoelectron Spectroscopy (XPS: X-ray Photoelectron Spectroscopy)</h1>
<div class="intro-box">
<p><strong>What you will learn in this chapter:</strong> X-ray Photoelectron Spectroscopy (XPS) is a surface analysis technique that analyzes the chemical composition and electronic states of material surfaces with high sensitivity. Based on the principle of the photoelectric effect, by measuring the kinetic energy of photoelectrons emitted from the sample surface, it enables element identification, chemical shift analysis, quantitative analysis, and depth profiling. In this chapter, you will systematically learn from the physical principles of XPS to practical peak fitting methods, quantitative analysis algorithms, and depth profiling, covering both the fundamentals and applications of XPS data analysis.</p>
</div>
<h2>4.1 Principles of X-ray Photoelectron Spectroscopy</h2>
<h3>4.1.1 Photoelectric Effect and Einstein's Equation</h3>
<p>XPS is based on the photoelectric effect theorized by Albert Einstein (1905). When a sample is irradiated with X-rays, the photon energy of the X-rays is absorbed by electrons, and electrons are emitted from the sample surface (photoelectrons).</p>
<div class="equation-box">
<p><strong>Kinetic Energy of Photoelectrons (Einstein's Equation):</strong></p>
        \[
        E_{\text{kinetic}} = h\nu - E_{\text{binding}} - \phi
        \]
        <p>where \( h\nu \) is the photon energy of incident X-rays, \( E_{\text{binding}} \) is the binding energy of electrons, and \( \phi \) is the work function of the instrument.</p>
<p><strong>Determination of Binding Energy:</strong></p>
        \[
        E_{\text{binding}} = h\nu - E_{\text{kinetic}} - \phi
        \]
        <p>In XPS, by measuring the kinetic energy \( E_{\text{kinetic}} \), the binding energy \( E_{\text{binding}} \) is determined. Binding energy has characteristic values for each element and chemical state, enabling element identification and chemical state analysis.</p>
</div>
<h3>4.1.2 Characteristics of XPS Measurement</h3>
<div class="key-concept">
<h4>Main Features of XPS</h4>
<ul>
<li><strong>Surface Sensitivity:</strong> The inelastic mean free path (IMFP) of photoelectrons is a few nm, obtaining information from approximately 5-10 nm of the sample surface</li>
<li><strong>Element Identification:</strong> All elements except Li can be detected (detection limit: 0.1-1 at%)</li>
<li><strong>Chemical State Analysis:</strong> Chemical shifts (0.1-10 eV) enable identification of oxidation states and coordination environments</li>
<li><strong>Quantitative Analysis:</strong> Elemental composition ratios are determined from peak areas (relative error: ±10%)</li>
<li><strong>Non-destructive Analysis:</strong> Normal measurements cause almost no sample damage</li>
<li><strong>Ultra-high Vacuum Environment:</strong> Measurements are conducted under ultra-high vacuum of 10<sup>-7</sup> - 10<sup>-9</sup> Pa</li>
</ul>
</div>
<h3>4.1.3 X-ray Sources and Energy Resolution</h3>
<p>Typical X-ray sources used in XPS are Al K± radiation (1486.6 eV) and Mg K± radiation (1253.6 eV). Using a monochromatic X-ray source can improve energy resolution.</p>
<table>
<thead>
<tr>
<th>X-ray Source</th>
<th>Photon Energy (eV)</th>
<th>Linewidth (eV)</th>
<th>Energy Resolution</th>
</tr>
</thead>
<tbody>
<tr>
<td>Mg K± (non-monochromatic)</td>
<td>1253.6</td>
<td>0.7</td>
<td>Standard</td>
</tr>
<tr>
<td>Al K± (non-monochromatic)</td>
<td>1486.6</td>
<td>0.85</td>
<td>Standard</td>
</tr>
<tr>
<td>Al K± (monochromatic)</td>
<td>1486.6</td>
<td>0.2-0.3</td>
<td>High Resolution</td>
</tr>
</tbody>
</table>
<div class="mermaid">
    flowchart LR
        A[X-ray Irradiation<br/>h½ = 1486.6 eV] --&gt; B[Sample Surface<br/>Atomic Orbitals]
        B --&gt; C[Photoelectron Emission<br/>E_kinetic Measurement]
        C --&gt; D[Energy Analyzer<br/>Hemispherical Analyzer]
        D --&gt; E[Detector<br/>Electron Counting]
        E --&gt; F[XPS Spectrum<br/>E_binding vs. Intensity]

        style A fill:#e3f2fd
        style B fill:#fff3e0
        style C fill:#fce4ec
        style D fill:#e8f5e9
        style E fill:#f3e5f5
        style F fill:#ffe0b2
    

    <h2>4.2 Chemical Shift and Peak Identification</h2>
<h3>4.2.1 Origin of Chemical Shift</h3>
<p>When the chemical state (oxidation state, coordination environment) of an atom changes, the binding energy of core electrons shifts. This is called the chemical shift.</p>
<div class="key-concept">
<h4>Principle of Chemical Shift</h4>
<p><strong>High Oxidation State ’ Increase in Binding Energy (Shift to Higher Energy)</strong></p>
<ul>
<li>As electrons are withdrawn, the effective nuclear charge of the atom increases</li>
<li>Core electrons are more strongly bound</li>
<li>Example: C 1s peak: C-C (284.5 eV) &lt; C-O (286.5 eV) &lt; C=O (288.0 eV) &lt; O-C=O (289.5 eV)</li>
</ul>
<p><strong>Increase in Electron Density ’ Decrease in Binding Energy (Shift to Lower Energy)</strong></p>
<ul>
<li>Electron-donating groups increase the electron density of the atom</li>
<li>Screening effect of core electrons becomes stronger</li>
<li>Example: Si 2p peak: SiO<sub>2</sub> (103.5 eV) &gt; Si (99.3 eV)</li>
</ul>
</div>
<h3>4.2.2 XPS Peaks of Representative Elements</h3>
<table>
<thead>
<tr>
<th>Element</th>
<th>Peak</th>
<th>Binding Energy (eV)</th>
<th>Chemical State</th>
</tr>
</thead>
<tbody>
<tr>
<td rowspan="4">C</td>
<td>1s</td>
<td>284.5</td>
<td>C-C, C-H (hydrocarbon)</td>
</tr>
<tr>
<td>1s</td>
<td>286.5</td>
<td>C-O (ether, alcohol)</td>
</tr>
<tr>
<td>1s</td>
<td>288.0</td>
<td>C=O (carbonyl)</td>
</tr>
<tr>
<td>1s</td>
<td>289.5</td>
<td>O-C=O (carboxyl)</td>
</tr>
<tr>
<td rowspan="2">Si</td>
<td>2p<sub>3/2</sub></td>
<td>99.3</td>
<td>Si<sup>0</sup> (metallic silicon)</td>
</tr>
<tr>
<td>2p<sub>3/2</sub></td>
<td>103.5</td>
<td>Si<sup>4+</sup> (SiO<sub>2</sub>)</td>
</tr>
<tr>
<td rowspan="3">Fe</td>
<td>2p<sub>3/2</sub></td>
<td>707.0</td>
<td>Fe<sup>0</sup> (metallic iron)</td>
</tr>
<tr>
<td>2p<sub>3/2</sub></td>
<td>710.8</td>
<td>Fe<sup>3+</sup> (Fe<sub>2</sub>O<sub>3</sub>)</td>
</tr>
<tr>
<td>2p<sub>3/2</sub></td>
<td>709.5</td>
<td>Fe<sup>2+</sup> (FeO)</td>
</tr>
<tr>
<td rowspan="2">O</td>
<td>1s</td>
<td>530.0</td>
<td>Metal oxide (M-O)</td>
</tr>
<tr>
<td>1s</td>
<td>532.5</td>
<td>Organic compound (C-O, C=O)</td>
</tr>
</tbody>
</table>
<h4>Code Example 1: XPS Spectrum Simulation and Peak Identification</h4>
<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt

def gaussian_peak(x, amplitude, center, width):
    """
    Generate Gaussian-type peak

    Parameters:
    -----------
    x : array
        Binding energy (eV)
    amplitude : float
        Peak height
    center : float
        Peak center (eV)
    width : float
        Full width at half maximum (FWHM, eV)

    Returns:
    --------
    peak : array
        Intensity of Gaussian peak
    """
    sigma = width / (2 * np.sqrt(2 * np.log(2)))
    peak = amplitude * np.exp(-((x - center)**2) / (2 * sigma**2))
    return peak

def simulate_xps_c1s_spectrum():
    """
    Simulate C 1s XPS spectrum (multiple chemical states)
    """
    # Binding energy range
    BE = np.linspace(280, 295, 1500)

    # C 1s peaks (4 chemical states)
    C_CC = gaussian_peak(BE, amplitude=1000, center=284.5, width=1.2)   # C-C, C-H
    C_CO = gaussian_peak(BE, amplitude=300, center=286.5, width=1.3)    # C-O
    C_O = gaussian_peak(BE, amplitude=150, center=288.0, width=1.4)     # C=O
    COO = gaussian_peak(BE, amplitude=80, center=289.5, width=1.5)      # O-C=O

    # Total spectrum
    total_spectrum = C_CC + C_CO + C_O + COO

    # Noise
    noise = np.random.normal(0, 10, len(BE))
    observed_spectrum = total_spectrum + noise

    # Plot
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 5))

    # Overall spectrum
    ax1.plot(BE, observed_spectrum, 'k-', linewidth=1.5, label='Observed Spectrum')
    ax1.fill_between(BE, C_CC, alpha=0.3, color='blue', label='C-C, C-H (284.5 eV)')
    ax1.fill_between(BE, C_CO, alpha=0.3, color='green', label='C-O (286.5 eV)')
    ax1.fill_between(BE, C_O, alpha=0.3, color='orange', label='C=O (288.0 eV)')
    ax1.fill_between(BE, COO, alpha=0.3, color='red', label='O-C=O (289.5 eV)')
    ax1.set_xlabel('Binding Energy (eV)', fontsize=12)
    ax1.set_ylabel('Intensity (cps)', fontsize=12)
    ax1.set_title('C 1s XPS Spectrum (Multi-component)', fontsize=14, fontweight='bold')
    ax1.legend(loc='upper right', fontsize=9)
    ax1.grid(alpha=0.3)
    ax1.invert_xaxis()  # XPS convention (high energy ’ low energy)

    # Separation of each component
    ax2.plot(BE, C_CC, 'b-', linewidth=2, label='C-C, C-H')
    ax2.plot(BE, C_CO, 'g-', linewidth=2, label='C-O')
    ax2.plot(BE, C_O, 'orange', linewidth=2, label='C=O')
    ax2.plot(BE, COO, 'r-', linewidth=2, label='O-C=O')
    ax2.axvline(284.5, color='blue', linestyle='--', alpha=0.5)
    ax2.axvline(286.5, color='green', linestyle='--', alpha=0.5)
    ax2.axvline(288.0, color='orange', linestyle='--', alpha=0.5)
    ax2.axvline(289.5, color='red', linestyle='--', alpha=0.5)
    ax2.set_xlabel('Binding Energy (eV)', fontsize=12)
    ax2.set_ylabel('Intensity (cps)', fontsize=12)
    ax2.set_title('Separation of Chemical States', fontsize=14, fontweight='bold')
    ax2.legend()
    ax2.grid(alpha=0.3)
    ax2.invert_xaxis()

    plt.tight_layout()
    plt.show()

    print("C 1s Peak Identification:")
    print("  284.5 eV: C-C, C-H (hydrocarbon skeleton)")
    print("  286.5 eV: C-O (ether, alcohol)")
    print("  288.0 eV: C=O (carbonyl group)")
    print("  289.5 eV: O-C=O (carboxyl group)")

# Execute
simulate_xps_c1s_spectrum()
</code></pre>
<h2>4.3 Peak Fitting and Deconvolution</h2>
<h3>4.3.1 Selection of Peak Shape</h3>
<p>XPS peaks are represented by a Voigt function, which is a mixture of Gaussian and Lorentzian types (or its approximation, the Gaussian-Lorentzian function).</p>
<div class="equation-box">
<p><strong>Gaussian-Lorentzian (GL) Mixed Function:</strong></p>
        \[
        f(x) = m \cdot G(x) + (1-m) \cdot L(x)
        \]
        <p>where \( G(x) \) is the Gaussian function, \( L(x) \) is the Lorentzian function, and \( m \) (0 d m d 1) is the mixing ratio.</p>
<p><strong>Gaussian Function:</strong></p>
        \[
        G(x) = A \exp\left(-\frac{(x - x_0)^2}{2\sigma^2}\right)
        \]

        <p><strong>Lorentzian Function:</strong></p>
        \[
        L(x) = A \frac{\gamma^2}{(x - x_0)^2 + \gamma^2}
        \]
    </div>
<h3>4.3.2 Shirley Background</h3>
<p>XPS spectra contain a background from inelastically scattered electrons. The Shirley background proposed by David A. Shirley (1972) is widely used.</p>
<h4>Code Example 2: Shirley Background Subtraction and Peak Fitting</h4>
<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit

def shirley_background(x, y, tol=1e-5, max_iter=50):
    """
    Calculate Shirley background

    Parameters:
    -----------
    x : array
        Binding energy (eV)
    y : array
        Observed intensity
    tol : float
        Convergence criterion
    max_iter : int
        Maximum iteration count

    Returns:
    --------
    background : array
        Shirley background
    """
    # Sort data in ascending order (BE: high ’ low)
    if x[0] &lt; x[-1]:
        x = x[::-1]
        y = y[::-1]

    # Initialize
    background = np.zeros_like(y)
    y_max = np.max(y)
    y_min = np.min(y)

    # Iterative calculation
    for iteration in range(max_iter):
        # Background calculation at each point
        for i in range(1, len(x)):
            integral = np.trapz(y[:i] - background[:i], x[:i])
            background[i] = y_min + (y_max - y_min) * integral / np.trapz(y - background, x)

        # Convergence check
        if iteration &gt; 0:
            change = np.max(np.abs(background - background_old))
            if change &lt; tol:
                break
        background_old = background.copy()

    return background

def voigt_approximation(x, amplitude, center, sigma, gamma):
    """
    Approximation of Voigt function (Gaussian-Lorentzian mixture)

    Parameters:
    -----------
    x : array
        Binding energy
    amplitude : float
        Peak height
    center : float
        Peak center
    sigma : float
        Width of Gaussian component
    gamma : float
        Width of Lorentzian component

    Returns:
    --------
    voigt : array
        Value of Voigt function
    """
    gaussian = np.exp(-((x - center)**2) / (2 * sigma**2))
    lorentzian = gamma**2 / ((x - center)**2 + gamma**2)
    voigt = amplitude * (0.7 * gaussian + 0.3 * lorentzian)
    return voigt

def multi_peak_fit(x, y, initial_params):
    """
    Fitting of multiple peaks

    Parameters:
    -----------
    x : array
        Binding energy
    y : array
        Intensity
    initial_params : list of tuples
        Initial parameters for each peak [(A1, c1, s1, g1), (A2, c2, s2, g2), ...]

    Returns:
    --------
    fitted_params : array
        Fitted parameters
    fitted_peaks : list
        Curve of each peak
    """
    def multi_voigt(x, *params):
        """Sum of multiple Voigt peaks"""
        n_peaks = len(params) // 4
        result = np.zeros_like(x)
        for i in range(n_peaks):
            A, c, s, g = params[i*4:(i+1)*4]
            result += voigt_approximation(x, A, c, s, g)
        return result

    # Flatten initial parameters
    p0 = [p for peak in initial_params for p in peak]

    # Fitting
    popt, pcov = curve_fit(multi_voigt, x, y, p0=p0, maxfev=10000)

    # Reconstruct each peak
    n_peaks = len(popt) // 4
    fitted_peaks = []
    for i in range(n_peaks):
        A, c, s, g = popt[i*4:(i+1)*4]
        peak = voigt_approximation(x, A, c, s, g)
        fitted_peaks.append((peak, A, c, s, g))

    return popt, fitted_peaks

# Simulation data (Si 2p: Si + SiO2)
BE = np.linspace(96, 108, 1200)

# True peaks
Si_metal = voigt_approximation(BE, amplitude=800, center=99.3, sigma=0.4, gamma=0.2)
SiO2 = voigt_approximation(BE, amplitude=500, center=103.5, sigma=0.5, gamma=0.25)
true_spectrum = Si_metal + SiO2

# Background (exponential decay type)
background_true = 100 * np.exp(-(BE - 96) / 10)

# Observed spectrum
noise = np.random.normal(0, 15, len(BE))
observed = true_spectrum + background_true + noise

# Shirley background subtraction
shirley_bg = shirley_background(BE, observed)
corrected = observed - shirley_bg

# Peak fitting
initial_params = [
    (800, 99.3, 0.4, 0.2),   # Si metal
    (500, 103.5, 0.5, 0.25)  # SiO2
]
fitted_params, fitted_peaks = multi_peak_fit(BE, corrected, initial_params)

# Plot
fig, axes = plt.subplots(2, 2, figsize=(14, 10))

# Original spectrum
axes[0, 0].plot(BE, observed, 'k-', label='Observed Spectrum', linewidth=1.5)
axes[0, 0].plot(BE, shirley_bg, 'r--', label='Shirley Background', linewidth=2)
axes[0, 0].set_xlabel('Binding Energy (eV)')
axes[0, 0].set_ylabel('Intensity (cps)')
axes[0, 0].set_title('Si 2p Spectrum (Raw Data)')
axes[0, 0].legend()
axes[0, 0].grid(alpha=0.3)
axes[0, 0].invert_xaxis()

# After background subtraction
axes[0, 1].plot(BE, corrected, 'o', markersize=3, alpha=0.5, label='After BG Subtraction')
fitted_total = sum([peak[0] for peak in fitted_peaks])
axes[0, 1].plot(BE, fitted_total, 'r-', linewidth=2, label='Fitting Total')
axes[0, 1].set_xlabel('Binding Energy (eV)')
axes[0, 1].set_ylabel('Intensity (cps)')
axes[0, 1].set_title('After Shirley BG Subtraction and Fitting')
axes[0, 1].legend()
axes[0, 1].grid(alpha=0.3)
axes[0, 1].invert_xaxis()

# Separation of each component
axes[1, 0].plot(BE, corrected, 'k-', alpha=0.3, label='Observed Data')
colors = ['blue', 'green']
labels = ['Si metal (99.3 eV)', 'SiO‚ (103.5 eV)']
for i, (peak, A, c, s, g) in enumerate(fitted_peaks):
    axes[1, 0].fill_between(BE, peak, alpha=0.5, color=colors[i], label=labels[i])
    axes[1, 0].axvline(c, color=colors[i], linestyle='--', linewidth=1.5)
axes[1, 0].set_xlabel('Binding Energy (eV)')
axes[1, 0].set_ylabel('Intensity (cps)')
axes[1, 0].set_title('Peak Separation (Deconvolution)')
axes[1, 0].legend()
axes[1, 0].grid(alpha=0.3)
axes[1, 0].invert_xaxis()

# Residual
residual = corrected - fitted_total
axes[1, 1].plot(BE, residual, 'purple', linewidth=1)
axes[1, 1].axhline(0, color='black', linestyle='--', linewidth=1)
axes[1, 1].fill_between(BE, residual, alpha=0.3, color='purple')
axes[1, 1].set_xlabel('Binding Energy (eV)')
axes[1, 1].set_ylabel('Residual (cps)')
axes[1, 1].set_title('Fitting Residual')
axes[1, 1].grid(alpha=0.3)
axes[1, 1].invert_xaxis()

plt.tight_layout()
plt.show()

# Output fitting results
print("Peak Fitting Results:")
for i, (peak, A, c, s, g) in enumerate(fitted_peaks):
    area = np.trapz(peak, BE)
    print(f"  Peak {i+1}: Center = {c:.2f} eV, Area = {area:.1f}")
</code></pre>
<h2>4.4 Quantitative Analysis and Sensitivity Factors</h2>
<h3>4.4.1 Principles of XPS Quantitative Analysis</h3>
<p>From the peak areas of XPS spectra, the atomic concentration of surface composition can be determined.</p>
<div class="equation-box">
<p><strong>Atomic Concentration Calculation Formula:</strong></p>
        \[
        C_i = \frac{I_i / S_i}{\sum_j (I_j / S_j)}
        \]
        <p>where \( C_i \) is the atomic concentration (at%) of element \(i\), \( I_i \) is the peak area, and \( S_i \) is the Relative Sensitivity Factor (RSF).</p>
<p><strong>Physical Meaning of Sensitivity Factor:</strong></p>
<ul>
<li>\( S_i = \sigma_i \cdot \lambda_i \cdot D(\theta) \cdot T(E) \)</li>
<li>\( \sigma_i \): Photoionization cross-section (element and orbital dependent)</li>
<li>\( \lambda_i \): Inelastic mean free path (IMFP)</li>
<li>\( D(\theta) \): Angular dependence factor</li>
<li>\( T(E) \): Instrument transmission function</li>
</ul>
</div>
<h3>4.4.2 Scofield Relative Sensitivity Factors</h3>
<p>Sensitivity factors based on photoionization cross-sections theoretically calculated by J.H. Scofield (1976) are widely used.</p>
<table>
<thead>
<tr>
<th>Element</th>
<th>Orbital</th>
<th>Scofield RSF<br/>(Al K±)</th>
<th>Binding Energy (eV)</th>
</tr>
</thead>
<tbody>
<tr><td>C</td><td>1s</td><td>0.25</td><td>284.5</td></tr>
<tr><td>O</td><td>1s</td><td>0.66</td><td>532.0</td></tr>
<tr><td>Si</td><td>2p</td><td>0.27</td><td>99.3</td></tr>
<tr><td>N</td><td>1s</td><td>0.42</td><td>399.5</td></tr>
<tr><td>F</td><td>1s</td><td>1.00</td><td>686.0</td></tr>
<tr><td>Al</td><td>2p</td><td>0.19</td><td>74.0</td></tr>
<tr><td>Fe</td><td>2p<sub>3/2</sub></td><td>2.85</td><td>707.0</td></tr>
<tr><td>Cu</td><td>2p<sub>3/2</sub></td><td>5.32</td><td>932.5</td></tr>
</tbody>
</table>
<h4>Code Example 3: XPS Quantitative Analysis and Composition Determination</h4>
<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt

def xps_quantification(peak_areas, sensitivity_factors):
    """
    Calculate atomic concentration by XPS quantitative analysis

    Parameters:
    -----------
    peak_areas : dict
        Peak area for each element {'C': area_C, 'O': area_O, ...}
    sensitivity_factors : dict
        Relative sensitivity factor for each element {'C': RSF_C, 'O': RSF_O, ...}

    Returns:
    --------
    atomic_concentrations : dict
        Atomic concentration (at%) for each element
    """
    # Calculate normalized intensities
    normalized_intensities = {}
    for element, area in peak_areas.items():
        RSF = sensitivity_factors[element]
        normalized_intensities[element] = area / RSF

    # Total
    total = sum(normalized_intensities.values())

    # Atomic concentration (at%)
    atomic_concentrations = {}
    for element, norm_int in normalized_intensities.items():
        atomic_concentrations[element] = (norm_int / total) * 100

    return atomic_concentrations

def plot_composition(atomic_concentrations):
    """
    Visualize composition with pie chart and bar chart
    """
    elements = list(atomic_concentrations.keys())
    concentrations = list(atomic_concentrations.values())

    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 5))

    # Pie chart
    colors = plt.cm.Set3(np.linspace(0, 1, len(elements)))
    wedges, texts, autotexts = ax1.pie(concentrations, labels=elements, autopct='%1.1f%%',
                                         colors=colors, startangle=90, textprops={'fontsize': 12})
    for autotext in autotexts:
        autotext.set_color('white')
        autotext.set_fontweight('bold')
    ax1.set_title('Surface Composition (Atomic Concentration)', fontsize=14, fontweight='bold')

    # Bar chart
    ax2.bar(elements, concentrations, color=colors, edgecolor='black', linewidth=1.5)
    ax2.set_xlabel('Element', fontsize=12)
    ax2.set_ylabel('Atomic Concentration (at%)', fontsize=12)
    ax2.set_title('Surface Composition (Bar Chart)', fontsize=14, fontweight='bold')
    ax2.grid(alpha=0.3, axis='y')

    # Display concentration on top of each bar
    for i, (elem, conc) in enumerate(zip(elements, concentrations)):
        ax2.text(i, conc + 1, f'{conc:.1f}%', ha='center', va='bottom', fontsize=11, fontweight='bold')

    plt.tight_layout()
    plt.show()

# Execution example: Analysis of SiO2 thin film
print("=== XPS Quantitative Analysis Example: SiO‚ Thin Film ===\n")

# Measured peak areas (arbitrary units)
peak_areas = {
    'Si': 12000,  # Si 2p
    'O': 28000,   # O 1s
    'C': 3000     # C 1s (carbon contamination)
}

# Scofield relative sensitivity factors (Al K± radiation)
sensitivity_factors = {
    'Si': 0.27,
    'O': 0.66,
    'C': 0.25
}

# Quantitative analysis
atomic_conc = xps_quantification(peak_areas, sensitivity_factors)

print("Peak Areas:")
for elem, area in peak_areas.items():
    print(f"  {elem}: {area}")

print("\nRelative Sensitivity Factors:")
for elem, RSF in sensitivity_factors.items():
    print(f"  {elem}: {RSF}")

print("\nAtomic Concentrations:")
for elem, conc in atomic_conc.items():
    print(f"  {elem}: {conc:.2f} at%")

# Comparison with theoretical composition (SiO2 = Si:O = 1:2 = 33.3:66.7)
Si_theory = 33.3
O_theory = 66.7
print(f"\nTheoretical Composition (SiO‚): Si = 33.3 at%, O = 66.7 at%")
print(f"Measured Composition: Si = {atomic_conc['Si']:.2f} at%, O = {atomic_conc['O']:.2f} at%")
print(f"Carbon Contamination: C = {atomic_conc['C']:.2f} at%")

# Plot
plot_composition(atomic_conc)

# Composition after contamination correction
Si_corrected = atomic_conc['Si'] / (atomic_conc['Si'] + atomic_conc['O']) * 100
O_corrected = atomic_conc['O'] / (atomic_conc['Si'] + atomic_conc['O']) * 100
print(f"\nAfter Carbon Correction: Si = {Si_corrected:.2f} at%, O = {O_corrected:.2f} at%")
</code></pre>
<h2>4.5 Depth Profiling</h2>
<h3>4.5.1 Ion Sputtering Method</h3>
<p>By sputtering the sample surface with an Ar<sup>+</sup> ion beam while repeatedly performing XPS measurements, a composition profile in the depth direction can be obtained.</p>
<div class="key-concept">
<h4>Procedure for Depth Profiling</h4>
<ol>
<li>Measure XPS spectrum at the sample surface</li>
<li>Ar<sup>+</sup> ion sputtering (remove several nm)</li>
<li>Perform XPS measurement again</li>
<li>Repeat steps 2-3 to construct a depth profile</li>
</ol>
<p><strong>Calibration of Sputtering Rate:</strong></p>
<ul>
<li>Use standard samples with known film thickness (SiO<sub>2</sub>/Si, etc.)</li>
<li>Convert sputtering time to depth</li>
<li>Sputtering rate: typically 0.1-1 nm/min</li>
</ul>
</div>
<h3>4.5.2 Non-destructive Angle-Resolved XPS</h3>
<p>By changing the detection angle, depth information can be obtained non-destructively.</p>
<div class="equation-box">
<p><strong>Angular Dependence of Detection Depth:</strong></p>
        \[
        d = 3\lambda \sin\theta
        \]
        <p>where \( d \) is the information depth, \( \lambda \) is the inelastic mean free path (IMFP), and \( \theta \) is the detection angle (angle from the sample surface).</p>
<p><strong>Advantages of Angle-Resolved Measurement:</strong></p>
<ul>
<li>Non-destructive: No damage to the sample</li>
<li>Rapid: No sputtering required</li>
<li>Surface sensitive: Information from 1-2 nm of surface at shallow angles (\( \theta = 15° \))</li>
</ul>
</div>
<h4>Code Example 4: Simulation and Analysis of Depth Profile</h4>
<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
from scipy.special import erf

def depth_profile_simulation(depth, interface_position, interface_width, concentration_top, concentration_bottom):
    """
    Simulate depth concentration profile with interface

    Parameters:
    -----------
    depth : array
        Depth (nm)
    interface_position : float
        Interface position (nm)
    interface_width : float
        Interface width (diffusion width, nm)
    concentration_top : float
        Concentration of surface layer (at%)
    concentration_bottom : float
        Concentration of substrate layer (at%)

    Returns:
    --------
    concentration : array
        Concentration at each depth (at%)
    """
    # Represent interface with erf function
    concentration = concentration_bottom + (concentration_top - concentration_bottom) * \
                    0.5 * (1 - erf((depth - interface_position) / interface_width))
    return concentration

def simulate_sputter_depth_profiling():
    """
    Simulate sputtering depth profiling (SiO2/Si structure)
    """
    # Depth range
    depth = np.linspace(0, 50, 200)  # 0-50 nm

    # SiO2 layer (0-20 nm) and Si substrate (beyond 20 nm)
    Si_profile = depth_profile_simulation(depth, interface_position=20, interface_width=2,
                                          concentration_top=33, concentration_bottom=100)
    O_profile = depth_profile_simulation(depth, interface_position=20, interface_width=2,
                                         concentration_top=67, concentration_bottom=0)

    # Sputtering measurement points (discrete)
    sputter_times = np.array([0, 5, 10, 15, 20, 25, 30, 40, 50])  # Sputtering time (minutes)
    sputter_rate = 1.0  # nm/min
    measured_depths = sputter_times * sputter_rate

    # Measured concentrations (with noise)
    Si_measured = np.interp(measured_depths, depth, Si_profile) + np.random.normal(0, 2, len(measured_depths))
    O_measured = np.interp(measured_depths, depth, O_profile) + np.random.normal(0, 2, len(measured_depths))

    # Plot
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 6))

    # Theoretical profile
    ax1.plot(depth, Si_profile, 'b-', linewidth=2, label='Si (Theoretical)')
    ax1.plot(depth, O_profile, 'r-', linewidth=2, label='O (Theoretical)')
    ax1.scatter(measured_depths, Si_measured, s=100, color='blue', marker='o',
                edgecolor='black', linewidth=1.5, label='Si (Measured)', zorder=5)
    ax1.scatter(measured_depths, O_measured, s=100, color='red', marker='s',
                edgecolor='black', linewidth=1.5, label='O (Measured)', zorder=5)
    ax1.axvline(20, color='green', linestyle='--', linewidth=2, label='Interface Position (20 nm)')
    ax1.set_xlabel('Depth (nm)', fontsize=12)
    ax1.set_ylabel('Atomic Concentration (at%)', fontsize=12)
    ax1.set_title('Depth Profile (SiO‚/Si)', fontsize=14, fontweight='bold')
    ax1.legend()
    ax1.grid(alpha=0.3)
    ax1.set_xlim(0, 50)
    ax1.set_ylim(-5, 105)

    # Visualization of layer structure
    ax2.fill_between([0, 20], 0, 100, alpha=0.3, color='red', label='SiO‚ Layer (20 nm)')
    ax2.fill_between([20, 50], 0, 100, alpha=0.3, color='blue', label='Si Substrate')
    ax2.text(10, 50, 'SiO‚', fontsize=16, fontweight='bold', ha='center')
    ax2.text(35, 50, 'Si', fontsize=16, fontweight='bold', ha='center')
    ax2.axvline(20, color='green', linestyle='--', linewidth=3, label='Interface')
    ax2.set_xlabel('Depth (nm)', fontsize=12)
    ax2.set_ylabel('Layer Structure', fontsize=12)
    ax2.set_title('Sample Structure (Cross-section)', fontsize=14, fontweight='bold')
    ax2.set_xlim(0, 50)
    ax2.set_yticks([])
    ax2.legend()
    ax2.grid(alpha=0.3, axis='x')

    plt.tight_layout()
    plt.show()

    # Estimate interface thickness
    interface_region = (measured_depths &gt;= 15) &amp; (measured_depths &lt;= 25)
    if np.sum(interface_region) &gt; 0:
        interface_width_est = np.max(measured_depths[interface_region]) - np.min(measured_depths[interface_region])
        print(f"Estimated Interface Width: {interface_width_est:.1f} nm")

# Execute
simulate_sputter_depth_profiling()
</code></pre>
<h2>4.6 Auger Electrons and Peak Identification</h2>
<h3>4.6.1 Principles of Auger Process</h3>
<p>In XPS measurements, in addition to photoelectron peaks, Auger electron peaks are also observed. Auger electrons are emitted during the relaxation process after a core hole is created.</p>
<div class="mermaid">
    flowchart TD
        A[X-ray Irradiation] --&gt; B[1s Electron Photoemission<br/>Core Hole Creation]
        B --&gt; C{Relaxation Process}
        C --&gt;|Process 1| D[2p Electron Transitions to 1s Orbital<br/>X-ray Fluorescence Emission]
        C --&gt;|Process 2| E[2p ’ 1s Transition<br/>Energy to 2p Electron]
        E --&gt; F[Auger Electron Emission<br/>KL‚Lƒ Electron]

        style A fill:#e3f2fd
        style B fill:#fff3e0
        style C fill:#fce4ec
        style D fill:#e8f5e9
        style E fill:#ffe0b2
        style F fill:#f3e5f5
    

    <div class="equation-box">
<p><strong>Kinetic Energy of Auger Electrons:</strong></p>
        \[
        E_{\text{Auger}} = E_1 - E_2 - E_3
        \]
        <p>where \( E_1 \) is the energy of the initial hole, \( E_2 \) is the energy of the transitioning electron, and \( E_3 \) is the orbital energy of the emitted Auger electron.</p>
<p><strong>Characteristics of Auger Electrons:</strong></p>
<ul>
<li>Independent of incident X-ray energy (element-specific value)</li>
<li>High surface sensitivity (IMFP &lt; 1 nm)</li>
<li>Small chemical shift (lower sensitivity than photoelectron peaks)</li>
</ul>
</div>
<h4>Code Example 5: Identification of Auger Electron and Photoelectron Peaks</h4>
<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt

def simulate_xps_with_auger(x_ray_energy):
    """
    Simulate photoelectron and Auger electron peaks in XPS spectrum

    Parameters:
    -----------
    x_ray_energy : float
        X-ray energy (eV): Al K± = 1486.6, Mg K± = 1253.6

    Returns:
    --------
    Plot the spectrum
    """
    # Binding energy range (0-1500 eV)
    BE = np.linspace(0, 1500, 3000)

    # Photoelectron peaks (displayed in binding energy)
    C_1s = gaussian_peak(BE, amplitude=800, center=284.5, width=1.2)
    O_1s = gaussian_peak(BE, amplitude=600, center=532.0, width=1.5)
    Si_2p = gaussian_peak(BE, amplitude=400, center=99.3, width=1.0)

    # Auger electron peaks (convert from kinetic energy to binding energy)
    # C KLL Auger: kinetic energy H 270 eV (independent of X-ray energy)
    C_KLL_kinetic = 270  # eV
    C_KLL_BE = x_ray_energy - C_KLL_kinetic
    C_KLL = gaussian_peak(BE, amplitude=150, center=C_KLL_BE, width=8)

    # O KLL Auger: kinetic energy H 510 eV
    O_KLL_kinetic = 510
    O_KLL_BE = x_ray_energy - O_KLL_kinetic
    O_KLL = gaussian_peak(BE, amplitude=120, center=O_KLL_BE, width=10)

    # Total spectrum
    total_spectrum = C_1s + O_1s + Si_2p + C_KLL + O_KLL

    # Noise
    noise = np.random.normal(0, 10, len(BE))
    observed = total_spectrum + noise

    # Plot
    fig, ax = plt.subplots(figsize=(14, 6))

    ax.plot(BE, observed, 'k-', linewidth=1.5, label='Observed Spectrum', alpha=0.7)
    ax.fill_between(BE, C_1s, alpha=0.5, color='blue', label='C 1s (284.5 eV) Photoelectron')
    ax.fill_between(BE, O_1s, alpha=0.5, color='red', label='O 1s (532.0 eV) Photoelectron')
    ax.fill_between(BE, Si_2p, alpha=0.5, color='green', label='Si 2p (99.3 eV) Photoelectron')
    ax.fill_between(BE, C_KLL, alpha=0.5, color='purple', label=f'C KLL ({C_KLL_BE:.1f} eV) Auger')
    ax.fill_between(BE, O_KLL, alpha=0.5, color='orange', label=f'O KLL ({O_KLL_BE:.1f} eV) Auger')

    # Emphasize distinction between photoelectrons and Auger electrons
    ax.axvline(284.5, color='blue', linestyle='--', linewidth=1, alpha=0.5)
    ax.axvline(532.0, color='red', linestyle='--', linewidth=1, alpha=0.5)
    ax.axvline(99.3, color='green', linestyle='--', linewidth=1, alpha=0.5)
    ax.axvline(C_KLL_BE, color='purple', linestyle=':', linewidth=2)
    ax.axvline(O_KLL_BE, color='orange', linestyle=':', linewidth=2)

    ax.set_xlabel('Binding Energy (eV)', fontsize=12)
    ax.set_ylabel('Intensity (cps)', fontsize=12)
    ax.set_title(f'XPS Wide Scan (X-ray Energy: {x_ray_energy:.1f} eV)', fontsize=14, fontweight='bold')
    ax.legend(loc='upper right', fontsize=10)
    ax.grid(alpha=0.3)
    ax.invert_xaxis()
    ax.set_xlim(1500, 0)

    plt.tight_layout()
    plt.show()

    print(f"X-ray Energy: {x_ray_energy:.1f} eV")
    print("\nPhotoelectron Peaks (Binding Energy):")
    print(f"  C 1s: 284.5 eV")
    print(f"  O 1s: 532.0 eV")
    print(f"  Si 2p: 99.3 eV")
    print("\nAuger Electron Peaks (Binding Energy Display):")
    print(f"  C KLL: {C_KLL_BE:.1f} eV (Kinetic Energy: {C_KLL_kinetic} eV)")
    print(f"  O KLL: {O_KLL_BE:.1f} eV (Kinetic Energy: {O_KLL_kinetic} eV)")
    print("\nIdentification Method: When changing X-ray energy, the binding energy display position of Auger electrons changes,")
    print("         but the binding energy of photoelectrons does not change.")

# Measurement with Al K± radiation
print("=== Measurement with Al K± Radiation (1486.6 eV) ===")
simulate_xps_with_auger(x_ray_energy=1486.6)

# Measurement with Mg K± radiation
print("\n=== Measurement with Mg K± Radiation (1253.6 eV) ===")
simulate_xps_with_auger(x_ray_energy=1253.6)
</code></pre>
<h2>4.7 XPS Data Preprocessing and Noise Removal</h2>
<h3>4.7.1 Smoothing with Savitzky-Golay Filter</h3>
<p>XPS spectra contain statistical noise. The Savitzky-Golay (SG) filter is an effective method for removing noise while preserving peak shape.</p>
<h4>Code Example 6: Savitzky-Golay Filter and Noise Removal</h4>
<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import savgol_filter

def xps_noise_reduction(BE, noisy_spectrum, window_length=11, polyorder=3):
    """
    Noise removal with Savitzky-Golay filter

    Parameters:
    -----------
    BE : array
        Binding energy
    noisy_spectrum : array
        Spectrum with noise
    window_length : int
        Length of filter window (odd number)
    polyorder : int
        Polynomial order

    Returns:
    --------
    smoothed_spectrum : array
        Smoothed spectrum
    """
    smoothed = savgol_filter(noisy_spectrum, window_length=window_length, polyorder=polyorder)
    return smoothed

# Simulation: Low count rate measurement (high noise)
BE = np.linspace(280, 295, 1500)

# True spectrum
true_spectrum = gaussian_peak(BE, amplitude=500, center=284.5, width=1.2) + \
                gaussian_peak(BE, amplitude=200, center=286.5, width=1.3)

# Heavy noise
heavy_noise = np.random.normal(0, 30, len(BE))
noisy_spectrum = true_spectrum + heavy_noise

# Apply SG filter with different parameters
smoothed_sg5 = xps_noise_reduction(BE, noisy_spectrum, window_length=5, polyorder=2)
smoothed_sg11 = xps_noise_reduction(BE, noisy_spectrum, window_length=11, polyorder=3)
smoothed_sg21 = xps_noise_reduction(BE, noisy_spectrum, window_length=21, polyorder=3)

# Plot
fig, axes = plt.subplots(2, 2, figsize=(14, 10))

# Original noisy spectrum
axes[0, 0].plot(BE, noisy_spectrum, 'gray', alpha=0.5, linewidth=0.5, label='With Noise')
axes[0, 0].plot(BE, true_spectrum, 'r-', linewidth=2, label='True Spectrum')
axes[0, 0].set_xlabel('Binding Energy (eV)')
axes[0, 0].set_ylabel('Intensity (cps)')
axes[0, 0].set_title('Original Spectrum (High Noise)')
axes[0, 0].legend()
axes[0, 0].grid(alpha=0.3)
axes[0, 0].invert_xaxis()

# SG filter (window_length=5)
axes[0, 1].plot(BE, noisy_spectrum, 'gray', alpha=0.3, linewidth=0.5)
axes[0, 1].plot(BE, smoothed_sg5, 'b-', linewidth=2, label='SG (window=5, order=2)')
axes[0, 1].plot(BE, true_spectrum, 'r--', linewidth=1.5, label='True Spectrum')
axes[0, 1].set_xlabel('Binding Energy (eV)')
axes[0, 1].set_ylabel('Intensity (cps)')
axes[0, 1].set_title('Savitzky-Golay Filter (window=5)')
axes[0, 1].legend()
axes[0, 1].grid(alpha=0.3)
axes[0, 1].invert_xaxis()

# SG filter (window_length=11)
axes[1, 0].plot(BE, noisy_spectrum, 'gray', alpha=0.3, linewidth=0.5)
axes[1, 0].plot(BE, smoothed_sg11, 'g-', linewidth=2, label='SG (window=11, order=3)')
axes[1, 0].plot(BE, true_spectrum, 'r--', linewidth=1.5, label='True Spectrum')
axes[1, 0].set_xlabel('Binding Energy (eV)')
axes[1, 0].set_ylabel('Intensity (cps)')
axes[1, 0].set_title('Savitzky-Golay Filter (window=11)')
axes[1, 0].legend()
axes[1, 0].grid(alpha=0.3)
axes[1, 0].invert_xaxis()

# SG filter (window_length=21)
axes[1, 1].plot(BE, noisy_spectrum, 'gray', alpha=0.3, linewidth=0.5)
axes[1, 1].plot(BE, smoothed_sg21, 'purple', linewidth=2, label='SG (window=21, order=3)')
axes[1, 1].plot(BE, true_spectrum, 'r--', linewidth=1.5, label='True Spectrum')
axes[1, 1].set_xlabel('Binding Energy (eV)')
axes[1, 1].set_ylabel('Intensity (cps)')
axes[1, 1].set_title('Savitzky-Golay Filter (window=21)')
axes[1, 1].legend()
axes[1, 1].grid(alpha=0.3)
axes[1, 1].invert_xaxis()

plt.tight_layout()
plt.show()

# Error evaluation
mse_sg5 = np.mean((smoothed_sg5 - true_spectrum)**2)
mse_sg11 = np.mean((smoothed_sg11 - true_spectrum)**2)
mse_sg21 = np.mean((smoothed_sg21 - true_spectrum)**2)

print("Smoothing Evaluation (Mean Squared Error):")
print(f"  SG (window=5, order=2): MSE = {mse_sg5:.2f}")
print(f"  SG (window=11, order=3): MSE = {mse_sg11:.2f} (Best)")
print(f"  SG (window=21, order=3): MSE = {mse_sg21:.2f}")
print("\nRecommendation: window_length = 11-15, polyorder = 2-3")
</code></pre>
<h2>4.8 Charge Correction and Reference Peak</h2>
<h3>4.8.1 Charging Effect in Insulating Samples</h3>
<p>In insulating samples, the sample surface becomes positively charged due to photoelectron emission, and the entire spectrum shifts to the high binding energy side. Charge correction is essential.</p>
<div class="key-concept">
<h4>Charge Correction Methods</h4>
<ul>
<li><strong>C 1s Reference Method:</strong> Correct based on the C-C peak of hydrocarbon contamination (284.5 eV)</li>
<li><strong>Au 4f Reference Method:</strong> Deposit Au thin film on sample surface and correct based on Au 4f<sub>7/2</sub> (84.0 eV)</li>
<li><strong>Flood Gun Method:</strong> Neutralize charging with low-energy electron beam</li>
</ul>
</div>
<h4>Code Example 7: Charging Shift Correction</h4>
<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt

def charge_shift_correction(BE, spectrum, reference_peak_position, true_reference_BE):
    """
    Correction of charging shift

    Parameters:
    -----------
    BE : array
        Measured binding energy
    spectrum : array
        Measured spectrum
    reference_peak_position : float
        Observed position of reference peak (eV)
    true_reference_BE : float
        True binding energy of reference peak (eV)

    Returns:
    --------
    corrected_BE : array
        Corrected binding energy
    shift : float
        Charging shift amount (eV)
    """
    shift = reference_peak_position - true_reference_BE
    corrected_BE = BE - shift
    return corrected_BE, shift

# Simulation: Charging in insulating sample
BE_charged = np.linspace(280, 540, 2600)

# Spectrum shifted by +3.0 eV due to charging
charge_shift = 3.0
C_1s_charged = gaussian_peak(BE_charged, amplitude=800, center=284.5 + charge_shift, width=1.2)
O_1s_charged = gaussian_peak(BE_charged, amplitude=600, center=532.0 + charge_shift, width=1.5)
spectrum_charged = C_1s_charged + O_1s_charged + np.random.normal(0, 10, len(BE_charged))

# Detection of C 1s peak position (maximum value)
C_1s_region = (BE_charged &gt;= 284.5 + charge_shift - 5) &amp; (BE_charged &lt;= 284.5 + charge_shift + 5)
C_1s_observed_pos = BE_charged[C_1s_region][np.argmax(spectrum_charged[C_1s_region])]

# Charge correction
corrected_BE, detected_shift = charge_shift_correction(BE_charged, spectrum_charged,
                                                        reference_peak_position=C_1s_observed_pos,
                                                        true_reference_BE=284.5)

# Spectrum after correction (same intensity, only horizontal axis corrected)
spectrum_corrected = spectrum_charged

# Plot
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 6))

# Before correction
ax1.plot(BE_charged, spectrum_charged, 'r-', linewidth=1.5, label='Charged Spectrum')
ax1.axvline(284.5 + charge_shift, color='blue', linestyle='--', linewidth=2, label=f'C 1s (Observed: {284.5 + charge_shift:.1f} eV)')
ax1.axvline(532.0 + charge_shift, color='green', linestyle='--', linewidth=2, label=f'O 1s (Observed: {532.0 + charge_shift:.1f} eV)')
ax1.set_xlabel('Binding Energy (Measured, eV)', fontsize=12)
ax1.set_ylabel('Intensity (cps)', fontsize=12)
ax1.set_title('Before Charge Shift (Before Correction)', fontsize=14, fontweight='bold')
ax1.legend()
ax1.grid(alpha=0.3)
ax1.invert_xaxis()

# After correction
ax2.plot(corrected_BE, spectrum_corrected, 'b-', linewidth=1.5, label='Corrected Spectrum')
ax2.axvline(284.5, color='blue', linestyle='--', linewidth=2, label='C 1s (Corrected: 284.5 eV)')
ax2.axvline(532.0, color='green', linestyle='--', linewidth=2, label='O 1s (Corrected: 532.0 eV)')
ax2.set_xlabel('Binding Energy (Corrected, eV)', fontsize=12)
ax2.set_ylabel('Intensity (cps)', fontsize=12)
ax2.set_title('After Charge Shift Correction', fontsize=14, fontweight='bold')
ax2.legend()
ax2.grid(alpha=0.3)
ax2.invert_xaxis()

plt.tight_layout()
plt.show()

print("Charge Correction Results:")
print(f"  Detected Charging Shift: {detected_shift:.2f} eV")
print(f"  True Charging Shift: {charge_shift:.2f} eV")
print(f"  C 1s Peak Position: {C_1s_observed_pos:.2f} eV ’ Corrected to 284.5 eV")
print(f"  O 1s Peak Position: {532.0 + charge_shift:.2f} eV ’ Corrected to 532.0 eV")
</code></pre>
<h2>4.9 Exercise Problems</h2>
<div class="exercise-box">
<h3>Basic Problems (Easy)</h3>
<h4>Problem 1: Calculation of Photoelectron Kinetic Energy</h4>
<p>In XPS measurement using Al K± radiation (1486.6 eV), the kinetic energy of C 1s photoelectrons was measured as 1202.1 eV. Calculate the binding energy of C 1s electrons with a work function of 4.5 eV.</p>
<details>
<summary>See Answer</summary>
<div style="padding: 10px; background: #f0f0f0; border-radius: 5px; margin-top: 10px;">
<p><strong>Answer:</strong></p>
<p>Einstein's equation:</p>
                \[
                E_{\text{kinetic}} = h\nu - E_{\text{binding}} - \phi
                \]
                \[
                E_{\text{binding}} = h\nu - E_{\text{kinetic}} - \phi = 1486.6 - 1202.1 - 4.5 = 280.0\,\text{eV}
                \]
                <p><strong>Answer: 280.0 eV</strong> (Since actual C 1s is approximately 284.5 eV, there may be charging in the sample)</p>
<p><strong>Python Code:</strong></p>
<pre><code class="language-python">h_nu = 1486.6  # eV (Al K±)
E_kinetic = 1202.1  # eV
phi = 4.5  # eV
E_binding = h_nu - E_kinetic - phi
print(f"C 1s Binding Energy: {E_binding:.1f} eV")
</code></pre>
</div>
</details>
<h4>Problem 2: Interpretation of Chemical Shift</h4>
<p>In the C 1s spectrum of a polymer sample, peaks were observed at 284.5 eV, 286.5 eV, and 288.0 eV. Identify the chemical state of each peak.</p>
<details>
<summary>See Answer</summary>
<div style="padding: 10px; background: #f0f0f0; border-radius: 5px; margin-top: 10px;">
<p><strong>Answer:</strong></p>
<ul>
<li><strong>284.5 eV:</strong> C-C, C-H (hydrocarbon skeleton)</li>
<li><strong>286.5 eV:</strong> C-O (ether, alcohol bond)</li>
<li><strong>288.0 eV:</strong> C=O (carbonyl group)</li>
</ul>
<p><strong>Answer:</strong> Mixed structure of polymer backbone (C-C) and functional groups (C-O, C=O)</p>
</div>
</details>
<h4>Problem 3: Sensitivity Factor in Quantitative Analysis</h4>
<p>From the peaks of Si 2p (peak area 15000, RSF = 0.27) and O 1s (peak area 35000, RSF = 0.66), calculate the atomic concentrations of Si and O.</p>
<details>
<summary>See Answer</summary>
<div style="padding: 10px; background: #f0f0f0; border-radius: 5px; margin-top: 10px;">
<p><strong>Answer:</strong></p>
<p>Normalized intensity:</p>
                \[
                I_{\text{Si}} / S_{\text{Si}} = 15000 / 0.27 = 55556
                \]
                \[
                I_{\text{O}} / S_{\text{O}} = 35000 / 0.66 = 53030
                \]
                <p>Atomic concentration:</p>
                \[
                C_{\text{Si}} = \frac{55556}{55556 + 53030} \times 100 = 51.2\,\text{at\%}
                \]
                \[
                C_{\text{O}} = \frac{53030}{55556 + 53030} \times 100 = 48.8\,\text{at\%}
                \]
                <p><strong>Answer: Si = 51.2 at%, O = 48.8 at%</strong> (Si:O H 1:1, close to SiO)</p>
<p><strong>Python Code:</strong></p>
<pre><code class="language-python">I_Si = 15000
I_O = 35000
RSF_Si = 0.27
RSF_O = 0.66

norm_Si = I_Si / RSF_Si
norm_O = I_O / RSF_O
total = norm_Si + norm_O

C_Si = (norm_Si / total) * 100
C_O = (norm_O / total) * 100

print(f"Si: {C_Si:.1f} at%")
print(f"O: {C_O:.1f} at%")
</code></pre>
</div>
</details>
</div>
<div class="exercise-box">
<h3>Intermediate Problems (Medium)</h3>
<h4>Problem 4: Multi-component Peak Fitting</h4>
<p>In the Fe 2p<sub>3/2</sub> spectrum, three chemical states are mixed at 707.0 eV (Fe<sup>0</sup>), 709.5 eV (Fe<sup>2+</sup>), and 710.8 eV (Fe<sup>3+</sup>). Create a Python program to fit each peak with a Gaussian function (FWHM = 2.0 eV) and determine the ratio of each oxidation state.</p>
<details>
<summary>See Answer</summary>
<div style="padding: 10px; background: #f0f0f0; border-radius: 5px; margin-top: 10px;">
<p><strong>Answer:</strong></p>
<p>Perform three-component fitting using the multi_peak_fit function from Code Example 2.</p>
<p><strong>Python Code:</strong></p>
<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit

# Simulation of Fe 2p3/2 spectrum
BE_Fe = np.linspace(700, 720, 2000)

# Three chemical states
Fe0 = gaussian_peak(BE_Fe, amplitude=300, center=707.0, width=2.0)
Fe2 = gaussian_peak(BE_Fe, amplitude=500, center=709.5, width=2.0)
Fe3 = gaussian_peak(BE_Fe, amplitude=400, center=710.8, width=2.0)
observed_Fe = Fe0 + Fe2 + Fe3 + np.random.normal(0, 15, len(BE_Fe))

# Fitting (using Gaussian function)
def three_gaussian(x, A1, c1, w1, A2, c2, w2, A3, c3, w3):
    return (gaussian_peak(x, A1, c1, w1) +
            gaussian_peak(x, A2, c2, w2) +
            gaussian_peak(x, A3, c3, w3))

p0 = [300, 707.0, 2.0, 500, 709.5, 2.0, 400, 710.8, 2.0]
popt, _ = curve_fit(three_gaussian, BE_Fe, observed_Fe, p0=p0, maxfev=10000)

# Reconstruct each component
Fe0_fit = gaussian_peak(BE_Fe, popt[0], popt[1], popt[2])
Fe2_fit = gaussian_peak(BE_Fe, popt[3], popt[4], popt[5])
Fe3_fit = gaussian_peak(BE_Fe, popt[6], popt[7], popt[8])

# Peak area
area_Fe0 = np.trapz(Fe0_fit, BE_Fe)
area_Fe2 = np.trapz(Fe2_fit, BE_Fe)
area_Fe3 = np.trapz(Fe3_fit, BE_Fe)
total_area = area_Fe0 + area_Fe2 + area_Fe3

# Ratio of each oxidation state
ratio_Fe0 = (area_Fe0 / total_area) * 100
ratio_Fe2 = (area_Fe2 / total_area) * 100
ratio_Fe3 = (area_Fe3 / total_area) * 100

print("Fe Oxidation State Ratio:")
print(f"  Fep (Metallic Iron): {ratio_Fe0:.1f}%")
print(f"  Fe²z (FeO): {ratio_Fe2:.1f}%")
print(f"  Fe³z (Fe‚Oƒ): {ratio_Fe3:.1f}%")

# Plot
plt.figure(figsize=(12, 6))
plt.plot(BE_Fe, observed_Fe, 'ko', markersize=2, alpha=0.5, label='Observed Data')
plt.fill_between(BE_Fe, Fe0_fit, alpha=0.5, color='blue', label=f'Fep ({ratio_Fe0:.1f}%)')
plt.fill_between(BE_Fe, Fe2_fit, alpha=0.5, color='green', label=f'Fe²z ({ratio_Fe2:.1f}%)')
plt.fill_between(BE_Fe, Fe3_fit, alpha=0.5, color='red', label=f'Fe³z ({ratio_Fe3:.1f}%)')
plt.xlabel('Binding Energy (eV)', fontsize=12)
plt.ylabel('Intensity (cps)', fontsize=12)
plt.title('Fe 2pƒ/‚ Multi-component Fitting', fontsize=14, fontweight='bold')
plt.legend()
plt.grid(alpha=0.3)
plt.gca().invert_xaxis()
plt.tight_layout()
plt.show()
</code></pre>
<p><strong>Answer: Quantify the ratio of each oxidation state (according to fitting results)</strong></p>
</div>
</details>
<h4>Problem 5: Interpretation of Depth Profiling</h4>
<p>In the sputtering depth profile of a TiO<sub>2</sub>/Ti sample, O concentration was 60 at% and Ti concentration was 40 at% from the surface to 10 nm, and beyond 10 nm, O concentration was 0 at% and Ti concentration was 100 at%. Determine the interface position and thickness of each layer.</p>
<details>
<summary>See Answer</summary>
<div style="padding: 10px; background: #f0f0f0; border-radius: 5px; margin-top: 10px;">
<p><strong>Answer:</strong></p>
<p>Judgment from data:</p>
<ul>
<li><strong>TiO<sub>2</sub> Layer:</strong> 0-10 nm (Ti:O = 40:60 H 2:3, oxygen deficient from stoichiometric ratio)</li>
<li><strong>Interface Position:</strong> 10 nm</li>
<li><strong>Ti Substrate:</strong> Beyond 10 nm (Ti 100 at%)</li>
</ul>
<p><strong>Answer: TiO<sub>2</sub> layer thickness = 10 nm, Interface position = 10 nm, Ti substrate &gt; 10 nm</strong></p>
</div>
</details>
<h4>Problem 6: Implementation of Charge Correction</h4>
<p>The C 1s peak of an insulating sample was observed at 287.5 eV. Perform charge correction based on the normal C-C peak (284.5 eV) and find the true binding energy of the Si 2p peak measured simultaneously (observed value: 102.3 eV).</p>
<details>
<summary>See Answer</summary>
<div style="padding: 10px; background: #f0f0f0; border-radius: 5px; margin-top: 10px;">
<p><strong>Answer:</strong></p>
<p>Charging shift:</p>
                \[
                \Delta E = 287.5 - 284.5 = 3.0\,\text{eV}
                \]
                <p>True binding energy of Si 2p:</p>
                \[
                E_{\text{Si 2p, true}} = 102.3 - 3.0 = 99.3\,\text{eV}
                \]
                <p><strong>Answer: Si 2p = 99.3 eV (Metallic Silicon)</strong></p>
<p><strong>Python Code:</strong></p>
<pre><code class="language-python">C_1s_observed = 287.5  # eV
C_1s_reference = 284.5  # eV
Si_2p_observed = 102.3  # eV

charge_shift = C_1s_observed - C_1s_reference
Si_2p_corrected = Si_2p_observed - charge_shift

print(f"Charging Shift: {charge_shift:.1f} eV")
print(f"Corrected Si 2p: {Si_2p_corrected:.1f} eV (Metallic Si)")
</code></pre>
</div>
</details>
</div>
<div class="exercise-box">
<h3>Advanced Problems (Hard)</h3>
<h4>Problem 7: Surface Layer Thickness Determination by Angle-Resolved XPS</h4>
<p>A SiO<sub>2</sub> thin film on Si substrate was measured by angle-resolved XPS. At detection angle \( \theta = 90° \) (perpendicular), the intensity of Si 2p (metallic Si, 99.3 eV) was \( I_{90} = 1000 \) cps, and at \( \theta = 30° \) (shallow angle), it was \( I_{30} = 200 \) cps. With the inelastic mean free path of Si electrons as \( \lambda = 3.0 \) nm, estimate the thickness of the SiO<sub>2</sub> layer.</p>
<details>
<summary>See Answer</summary>
<div style="padding: 10px; background: #f0f0f0; border-radius: 5px; margin-top: 10px;">
<p><strong>Answer:</strong></p>
<p>Intensity equation for angle-resolved XPS (signal attenuation from substrate):</p>
                \[
                I(\theta) = I_0 \exp\left(-\frac{d}{\lambda \sin\theta}\right)
                \]
                <p>where \( d \) is the SiO<sub>2</sub> layer thickness.</p>
<p>From data at two angles:</p>
                \[
                \frac{I_{30}}{I_{90}} = \exp\left(-\frac{d}{\lambda}\left(\frac{1}{\sin 30°} - \frac{1}{\sin 90°}\right)\right)
                \]
                \[
                \ln\left(\frac{I_{30}}{I_{90}}\right) = -\frac{d}{\lambda}\left(\frac{1}{0.5} - \frac{1}{1.0}\right) = -\frac{d}{\lambda} \cdot 1.0
                \]
                \[
                d = -\lambda \ln\left(\frac{I_{30}}{I_{90}}\right) = -3.0 \times \ln\left(\frac{200}{1000}\right) = -3.0 \times (-1.609) = 4.83\,\text{nm}
                \]

                <p><strong>Python Code:</strong></p>
<pre><code class="language-python">import numpy as np

I_90 = 1000  # cps
I_30 = 200   # cps
lambda_imfp = 3.0  # nm
theta_90 = np.radians(90)
theta_30 = np.radians(30)

# Layer thickness calculation
d = -lambda_imfp * np.log(I_30 / I_90) / (1/np.sin(theta_30) - 1/np.sin(theta_90))

print(f"SiO‚ Layer Thickness: {d:.2f} nm")
</code></pre>
<p><strong>Answer: SiO<sub>2</sub> layer thickness H 4.8 nm</strong></p>
</div>
</details>
<h4>Problem 8: Classification of XPS Spectra by Machine Learning</h4>
<p>Create a program to classify XPS spectra of different chemical states (metal, oxide, nitride) using machine learning (Random Forest). Use 10 samples for each state as training data and 5 samples for each state as test data.</p>
<details>
<summary>See Answer</summary>
<div style="padding: 10px; background: #f0f0f0; border-radius: 5px; margin-top: 10px;">
<p><strong>Answer:</strong></p>
<p>Train a random forest classifier using features of XPS spectra (peak position, peak width, peak intensity).</p>
<p><strong>Python Code:</strong></p>
<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report, confusion_matrix
import seaborn as sns

# Generate training data (features: peak center position, FWHM, peak height)
np.random.seed(42)

# Metal (BE H 99, FWHM H 1.0, height H 800)
metal_features = np.random.normal([99.0, 1.0, 800], [0.3, 0.1, 50], (10, 3))

# Oxide (BE H 103, FWHM H 1.5, height H 600)
oxide_features = np.random.normal([103.0, 1.5, 600], [0.3, 0.15, 40], (10, 3))

# Nitride (BE H 101, FWHM H 1.2, height H 700)
nitride_features = np.random.normal([101.0, 1.2, 700], [0.3, 0.12, 45], (10, 3))

# Data integration
X = np.vstack([metal_features, oxide_features, nitride_features])
y = np.array([0]*10 + [1]*10 + [2]*10)  # 0: Metal, 1: Oxide, 2: Nitride

# Split training and test data
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.33, random_state=42, stratify=y)

# Random forest classifier
rf_classifier = RandomForestClassifier(n_estimators=100, max_depth=10, random_state=42)
rf_classifier.fit(X_train, y_train)

# Prediction
y_pred = rf_classifier.predict(X_test)

# Evaluation
class_names = ['Metal', 'Oxide', 'Nitride']
print("Classification Report:")
print(classification_report(y_test, y_pred, target_names=class_names))

# Confusion matrix
cm = confusion_matrix(y_test, y_pred)
plt.figure(figsize=(8, 6))
sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', xticklabels=class_names, yticklabels=class_names)
plt.xlabel('Predicted Label', fontsize=12)
plt.ylabel('True Label', fontsize=12)
plt.title('Confusion Matrix (XPS Classification)', fontsize=14, fontweight='bold')
plt.tight_layout()
plt.show()

# Feature importance
importances = rf_classifier.feature_importances_
feature_names = ['Peak Center (eV)', 'FWHM (eV)', 'Peak Height (cps)']
plt.figure(figsize=(8, 5))
plt.barh(feature_names, importances, color='skyblue', edgecolor='black')
plt.xlabel('Importance', fontsize=12)
plt.title('Feature Importance', fontsize=14, fontweight='bold')
plt.grid(alpha=0.3, axis='x')
plt.tight_layout()
plt.show()

print("\nFeature Importance:")
for name, importance in zip(feature_names, importances):
    print(f"  {name}: {importance:.3f}")
</code></pre>
<p><strong>Answer: Classify chemical states of XPS spectra with high accuracy (&gt;95%)</strong></p>
</div>
</details>
<h4>Problem 9: Algorithm for Identification of XPS and Auger Electrons</h4>
<p>Implement an algorithm to automatically identify photoelectron peaks and Auger electron peaks from XPS wide scan spectra. Take two spectra with different X-ray energies (Al K±, Mg K±) as input and determine which type each peak is.</p>
<details>
<summary>See Answer</summary>
<div style="padding: 10px; background: #f0f0f0; border-radius: 5px; margin-top: 10px;">
<p><strong>Answer:</strong></p>
<p>Principle: Photoelectron peaks have constant binding energy, Auger electrons have constant kinetic energy.</p>
<p><strong>Python Code:</strong></p>
<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt

def identify_photoelectron_auger(BE_AlKa, intensity_AlKa, BE_MgKa, intensity_MgKa, threshold=1.0):
    """
    Identify photoelectron and Auger electron peaks

    Parameters:
    -----------
    BE_AlKa, BE_MgKa : array
        Binding energy for each X-ray source
    intensity_AlKa, intensity_MgKa : array
        Intensity of each spectrum
    threshold : float
        Threshold for peak position change (eV)

    Returns:
    --------
    peak_types : dict
        Type of each peak ('photoelectron' or 'Auger')
    """
    # Peak detection (simple maximum value detection)
    from scipy.signal import find_peaks

    peaks_AlKa, _ = find_peaks(intensity_AlKa, height=100, distance=50)
    peaks_MgKa, _ = find_peaks(intensity_MgKa, height=100, distance=50)

    # Search for correspondence of each peak
    peak_types = {}
    for i, peak_Al in enumerate(peaks_AlKa):
        BE_Al = BE_AlKa[peak_Al]

        # Search for corresponding peak in MgKa spectrum (within ±5 eV)
        matched = False
        for peak_Mg in peaks_MgKa:
            BE_Mg = BE_MgKa[peak_Mg]
            if abs(BE_Al - BE_Mg) &lt; threshold:
                # Binding energy matches ’ Photoelectron peak
                peak_types[f"Peak_{i+1} ({BE_Al:.1f} eV)"] = "Photoelectron"
                matched = True
                break

        if not matched:
            # Binding energy changes ’ Auger electron peak
            # Calculate expected position in MgKa
            E_shift = 1486.6 - 1253.6  # Al K± - Mg K± = 233 eV
            expected_BE_Mg = BE_Al - E_shift
            peak_types[f"Peak_{i+1} ({BE_Al:.1f} eV, Mg: {expected_BE_Mg:.1f} eV)"] = "Auger"

    return peak_types

# Implementation example (use data from Code Example 5)
# (Omitted: In practice, use simulation data from Code Example 5)

print("Identification Algorithm:")
print("  Photoelectron: Binding energy does not depend on X-ray energy")
print("  Auger: Binding energy display depends on X-ray energy")
</code></pre>
<p><strong>Answer: Automatic identification of photoelectrons and Auger electrons (based on X-ray energy dependence)</strong></p>
</div>
</details>
</div>
<div class="learning-objectives">
<h2>Learning Objectives Review</h2>
<p>Please self-assess the following items:</p>
<h3>Level 1: Basic Understanding</h3>
<ul>
<li>Understanding the photoelectric effect principle of XPS and Einstein's equation</li>
<li>Ability to explain the origin of chemical shifts and relationship with oxidation states</li>
<li>Ability to convert between binding energy and kinetic energy</li>
<li>Understanding basic reading of XPS spectra</li>
</ul>
<h3>Level 2: Practical Skills</h3>
<ul>
<li>Ability to perform Shirley background subtraction</li>
<li>Ability to perform multi-peak fitting (deconvolution)</li>
<li>Ability to calculate surface composition by quantitative analysis</li>
<li>Ability to implement charge correction</li>
<li>Ability to analyze depth profiles</li>
</ul>
<h3>Level 3: Application Ability</h3>
<ul>
<li>Ability to determine surface layer thickness by angle-resolved XPS</li>
<li>Ability to identify photoelectron and Auger electron peaks</li>
<li>Ability to perform advanced noise removal and spectral preprocessing</li>
<li>Ability to classify XPS spectra using machine learning</li>
</ul>
</div>
<div class="references">
<h2>References</h2>
<ol>
<li>Briggs, D., Seah, M.P. (1990). <em>Practical Surface Analysis, Volume 1: Auger and X-ray Photoelectron Spectroscopy</em> (2nd ed.). Wiley, pp. 26-31 (photoionization cross-sections), pp. 85-105 (quantification methods), pp. 201-215 (chemical shifts), pp. 312-335 (depth profiling). - Comprehensive explanation of XPS principles, quantitative analysis methods, and practical measurement techniques</li>
<li>Shirley, D.A. (1972). High-resolution X-ray photoemission spectrum of the valence bands of gold. <em>Physical Review B</em>, 5(12), 4709-4714. DOI: 10.1103/PhysRevB.5.4709 - Original paper on Shirley background subtraction method</li>
<li>Scofield, J.H. (1976). Hartree-Slater subshell photoionization cross-sections at 1254 and 1487 eV. <em>Journal of Electron Spectroscopy and Related Phenomena</em>, 8(2), 129-137. DOI: 10.1016/0368-2048(76)80015-1 - Foundational paper on theoretical calculation of XPS relative sensitivity factors</li>
<li>Hüfner, S. (2003). <em>Photoelectron Spectroscopy: Principles and Applications</em> (3rd ed.). Springer, pp. 1-28 (basic principles), pp. 45-65 (chemical shifts), pp. 350-380 (surface analysis), pp. 420-450 (applications). - Quantum mechanical fundamentals of photoelectron spectroscopy, theory of chemical shifts</li>
<li>Moulder, J.F., Stickle, W.F., Sobol, P.E., Bomben, K.D. (1992). <em>Handbook of X-ray Photoelectron Spectroscopy</em>. Physical Electronics, pp. 40-42 (C 1s), pp. 82-84 (O 1s), pp. 181-183 (Si 2p), pp. 230-232 (Fe 2p). - XPS spectrum database, standard peak position collection</li>
<li>Powell, C.J., Jablonski, A. (2010). NIST Electron Inelastic-Mean-Free-Path Database, Version 1.2. National Institute of Standards and Technology, Gaithersburg, MD. DOI: 10.18434/T48C78 - Inelastic mean free path (IMFP) database</li>
<li>Pielaszek, R., Andrearczyk, K., Wójcik, M. (2022). Machine learning for automated XPS data analysis. <em>Surface and Interface Analysis</em>, 54(4), 367-378. DOI: 10.1002/sia.7051 - Latest methods for automated XPS analysis using machine learning</li>
<li>SciPy 1.11 documentation. scipy.signal.savgol_filter, scipy.signal.find_peaks. https://docs.scipy.org/doc/scipy/reference/signal.html - Savitzky-Golay filter, peak detection, signal processing algorithms</li>
</ol>
</div>
<script>
        // MathJax configuration
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            }
        };

        // Mermaid initialization
        mermaid.initialize({
            startOnLoad: true,
            theme: 'default',
            flowchart: {
                useMaxWidth: true,
                htmlLabels: true,
                curve: 'basis'
            }
        });
    </script>
</div></div></body>
</html>
