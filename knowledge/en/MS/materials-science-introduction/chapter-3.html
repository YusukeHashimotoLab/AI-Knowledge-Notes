<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 3: Fundamentals of Crystal Structure - MS Terakoya</title>

    <style>
        :root {
            --color-primary: #2c3e50;
            --color-primary-dark: #1a252f;
            --color-accent: #f093fb;
            --color-accent-light: #f5576c;
            --color-text: #2d3748;
            --color-text-light: #4a5568;
            --color-bg: #ffffff;
            --color-bg-alt: #f7fafc;
            --color-border: #e2e8f0;
            --color-code-bg: #f8f9fa;
            --color-link: #f093fb;
            --color-link-hover: #d07be8;

            --spacing-xs: 0.5rem;
            --spacing-sm: 1rem;
            --spacing-md: 1.5rem;
            --spacing-lg: 2rem;
            --spacing-xl: 3rem;

            --font-body: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            --font-mono: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;

            --border-radius: 8px;
            --box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-body);
            line-height: 1.7;
            color: var(--color-text);
            background-color: var(--color-bg);
            font-size: 16px;
        }

        header {
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            color: white;
            padding: var(--spacing-xl) var(--spacing-md);
            margin-bottom: var(--spacing-xl);
            box-shadow: var(--box-shadow);
        }

        .header-content {
            max-width: 900px;
            margin: 0 auto;
        }

        h1 {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: var(--spacing-sm);
            line-height: 1.2;
        }

        .subtitle {
            font-size: 1.1rem;
            opacity: 0.95;
            font-weight: 400;
            margin-bottom: var(--spacing-md);
        }

        .meta {
            display: flex;
            flex-wrap: wrap;
            gap: var(--spacing-md);
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .meta-item {
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 0 var(--spacing-md) var(--spacing-xl);
        }

        h2 {
            font-size: 1.75rem;
            color: var(--color-primary);
            margin-top: var(--spacing-xl);
            margin-bottom: var(--spacing-md);
            padding-bottom: var(--spacing-xs);
            border-bottom: 3px solid var(--color-accent);
        }

        h3 {
            font-size: 1.4rem;
            color: var(--color-primary);
            margin-top: var(--spacing-lg);
            margin-bottom: var(--spacing-sm);
        }

        h4 {
            font-size: 1.1rem;
            color: var(--color-primary-dark);
            margin-top: var(--spacing-md);
            margin-bottom: var(--spacing-sm);
        }

        p {
            margin-bottom: var(--spacing-md);
            color: var(--color-text);
        }

        a {
            color: var(--color-link);
            text-decoration: none;
            transition: color 0.2s;
        }

        a:hover {
            color: var(--color-link-hover);
            text-decoration: underline;
        }

        ul, ol {
            margin-left: var(--spacing-lg);
            margin-bottom: var(--spacing-md);
        }

        li {
            margin-bottom: var(--spacing-xs);
            color: var(--color-text);
        }

        pre {
            background-color: var(--color-code-bg);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            overflow-x: auto;
            margin-bottom: var(--spacing-md);
            font-family: var(--font-mono);
            font-size: 0.9rem;
            line-height: 1.5;
        }

        code {
            font-family: var(--font-mono);
            font-size: 0.9em;
            background-color: var(--color-code-bg);
            padding: 0.2em 0.4em;
            border-radius: 3px;
        }

        pre code {
            background-color: transparent;
            padding: 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: var(--spacing-md);
            font-size: 0.95rem;
        }

        th, td {
            border: 1px solid var(--color-border);
            padding: var(--spacing-sm);
            text-align: left;
        }

        th {
            background-color: var(--color-bg-alt);
            font-weight: 600;
            color: var(--color-primary);
        }

        blockquote {
            border-left: 4px solid var(--color-accent);
            padding-left: var(--spacing-md);
            margin: var(--spacing-md) 0;
            color: var(--color-text-light);
            font-style: italic;
            background-color: var(--color-bg-alt);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        .mermaid {
            text-align: center;
            margin: var(--spacing-lg) 0;
            background-color: var(--color-bg-alt);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        .learning-objectives {
            background: linear-gradient(135deg, #fce7f3 0%, #fbcfe8 100%);
            padding: var(--spacing-lg);
            border-radius: var(--border-radius);
            border-left: 4px solid var(--color-accent);
            margin-bottom: var(--spacing-xl);
        }

        .learning-objectives h2 {
            margin-top: 0;
            border-bottom: none;
        }

        .breadcrumb {
            max-width: 900px;
            margin: 0 auto;
            padding: var(--spacing-sm) var(--spacing-md);
            font-size: 0.9rem;
            color: var(--color-text-light);
        }

        .breadcrumb a {
            color: var(--color-link);
            text-decoration: none;
        }

        .breadcrumb a:hover {
            text-decoration: underline;
        }

        .navigation {
            display: flex;
            justify-content: space-between;
            gap: var(--spacing-md);
            margin: var(--spacing-xl) 0;
            padding-top: var(--spacing-lg);
            border-top: 2px solid var(--color-border);
        }

        .nav-button {
            flex: 1;
            padding: var(--spacing-md);
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            color: white;
            border-radius: var(--border-radius);
            text-align: center;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: var(--box-shadow);
        }

        .nav-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            text-decoration: none;
        }

        footer {
            margin-top: var(--spacing-xl);
            padding: var(--spacing-lg) var(--spacing-md);
            background-color: var(--color-bg-alt);
            border-top: 1px solid var(--color-border);
            text-align: center;
            font-size: 0.9rem;
            color: var(--color-text-light);
        }
        .disclaimer {
            max-width: 900px;
            margin: 2rem auto;
            padding: 1.5rem;
            background: #f8f9fa;
            border-left: 4px solid #6c757d;
            border-radius: 4px;
        }

        .disclaimer h3 {
            color: #495057;
            margin-bottom: 1rem;
            font-size: 1.1rem;
        }

        .disclaimer ul {
            list-style: none;
            padding-left: 0;
        }

        .disclaimer li {
            padding: 0.5rem 0;
            padding-left: 1.5rem;
            position: relative;
            font-size: 0.9rem;
            color: #6c757d;
            line-height: 1.6;
        }

        .disclaimer li::before {
            content: " ";
            position: absolute;
            left: 0;
        }


        @media (max-width: 768px) {
            h1 {
                font-size: 1.5rem;
            }

            h2 {
                font-size: 1.4rem;
            }

            h3 {
                font-size: 1.2rem;
            }

            .meta {
                font-size: 0.85rem;
            }

            .navigation {
                flex-direction: column;
            }

            table {
                font-size: 0.85rem;
            }

            th, td {
                padding: var(--spacing-xs);
            }
        }
    </style>

    <!-- Prism.js for syntax highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <script>
        mermaid.initialize({ startOnLoad: true, theme: 'default', securityLevel: 'strict' });
    </script>

    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true,
                processEnvironments: true
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
                ignoreHtmlClass: 'mermaid'
            }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" id="MathJax-script" async></script>
</head>
<body>
    <header>
        <div class="header-content">
            <h1>Chapter 3: Fundamentals of Crystal Structure</h1>
            <p class="subtitle">Relationship Between Regular Atomic Arrangement and Material Properties</p>
            <div class="meta">
                <span class="meta-item">=Ö Reading Time: 30-35 minutes</span>
                <span class="meta-item">=Ê Difficulty: Intermediate</span>
                <span class="meta-item">=» Code Examples: 7</span>
            </div>
        </div>
    </header>

    <div class="breadcrumb">
        <a href="../../index.html">AI Terakoya Home</a> &gt;
        <a href="../index.html">MS Dojo</a> &gt;
        <a href="index.html">Introduction to Materials Science</a> &gt;
        Chapter 3
    </div>

    <main class="container">
        <p class="chapter-description" style="margin: 1.5rem 0; padding: 1rem; background: linear-gradient(135deg, #fce7f3 0%, #fbcfe8 100%); border-left: 4px solid #f093fb; border-radius: 8px; font-size: 1.05rem; line-height: 1.8; color: #2d3748;">
            Material properties greatly depend on how atoms are arranged. In this chapter, we will learn the fundamental concepts of crystal structure, major crystal systems, Miller indices, and visualize crystal structures using Python.
        </p>

        <div class="learning-objectives">
            <h2>Learning Objectives</h2>
            <p>By reading this chapter, you will be able to:</p>
            <ul>
                <li> Understand the difference between crystalline and amorphous materials and distinguish them from X-ray diffraction patterns</li>
                <li> Understand the concepts of unit cell and lattice parameters</li>
                <li> Explain the characteristics and representative materials of major crystal structures (FCC, BCC, HCP)</li>
                <li> Represent crystal planes and directions using Miller indices</li>
                <li> Calculate packing fraction and coordination number</li>
                <li> Visualize 3D crystal structures using Python</li>
            </ul>
        </div>

        <hr>

        <h2>3.1 Crystalline and Amorphous Materials</h2>

        <h3>What is Crystal Structure?</h3>

        <p><strong>Crystals</strong> are solids in which atoms are arranged regularly and periodically in three-dimensional space. On the other hand, <strong>amorphous</strong> materials are solids without long-range order in atomic arrangement.</p>

        <table>
            <thead>
                <tr>
                    <th>Property</th>
                    <th>Crystalline</th>
                    <th>Amorphous</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>Atomic Arrangement</strong></td>
                    <td>Long-range order (periodic)</td>
                    <td>Short-range order only (random)</td>
                </tr>
                <tr>
                    <td><strong>Melting Point</strong></td>
                    <td>Sharp melting point</td>
                    <td>Glass transition temperature (gradual softening)</td>
                </tr>
                <tr>
                    <td><strong>X-ray Diffraction</strong></td>
                    <td>Sharp peaks (Bragg reflection)</td>
                    <td>Broad halo</td>
                </tr>
                <tr>
                    <td><strong>Anisotropy</strong></td>
                    <td>Properties vary with direction</td>
                    <td>Isotropic (same in all directions)</td>
                </tr>
                <tr>
                    <td><strong>Examples</strong></td>
                    <td>Metals, Si, NaCl, Diamond</td>
                    <td>Glass, Polymers, Amorphous Si</td>
                </tr>
            </tbody>
        </table>

        <h3>Evaluation of Crystallinity by X-ray Diffraction</h3>

        <p><strong>X-ray Diffraction (XRD)</strong> is the most important technique for analyzing crystal structure. When X-rays are incident on a crystal, <strong>Bragg reflection</strong> occurs at specific angles due to the atomic arrangement.</p>

        <p><strong>Bragg's Law</strong>:</p>

        <p>$$n\lambda = 2d\sin\theta$$</p>

        <p>where,</p>
        <ul>
            <li>$n$: Reflection order (integer)</li>
            <li>$\lambda$: X-ray wavelength</li>
            <li>$d$: Interplanar spacing</li>
            <li>$\theta$: Incident angle (Bragg angle)</li>
        </ul>

        <p>Crystalline materials show strong diffraction peaks at specific angles ($2\theta$), while amorphous materials show broad halo patterns.</p>

        <h3>Code Example 1: Simulation of X-ray Diffraction Patterns for Crystalline and Amorphous Materials</h3>

        <p>Visualize the difference between X-ray diffraction patterns of crystalline and amorphous materials.</p>

        <pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt

# X-ray diffraction pattern simulation
def simulate_crystalline_xrd():
    """
    Simulate XRD pattern for crystalline material
    Sharp Bragg peaks appear at specific angles
    """
    # 2¸ range (degrees)
    two_theta = np.linspace(10, 80, 1000)
    intensity = np.zeros_like(two_theta)

    # Bragg reflection peaks from major crystal planes
    # Diffraction from (111), (200), (220), (311) planes
    peaks = [28.4, 33.0, 47.5, 56.1]  # 2¸ positions (e.g., FCC structure)
    peak_intensities = [100, 50, 80, 40]  # Relative intensities
    peak_width = 0.3  # Peak width (degrees)

    # Add Gaussian peaks
    for peak_pos, peak_int in zip(peaks, peak_intensities):
        intensity += peak_int * np.exp(-((two_theta - peak_pos) / peak_width)**2)

    # Background noise
    intensity += np.random.normal(2, 0.5, len(two_theta))

    return two_theta, intensity


def simulate_amorphous_xrd():
    """
    Simulate XRD pattern for amorphous material
    Broad halo pattern
    """
    two_theta = np.linspace(10, 80, 1000)

    # Broad halo (due to short-range order)
    halo_center = 25  # Halo center position
    halo_width = 15   # Halo width
    intensity = 30 * np.exp(-((two_theta - halo_center) / halo_width)**2)

    # Additional broad peak
    intensity += 15 * np.exp(-((two_theta - 45) / 20)**2)

    # Noise
    intensity += np.random.normal(2, 0.5, len(two_theta))

    return two_theta, intensity


# Create plots
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 5))

# XRD pattern of crystalline material
two_theta_cryst, intensity_cryst = simulate_crystalline_xrd()
ax1.plot(two_theta_cryst, intensity_cryst, linewidth=1.5, color='#1f77b4')
ax1.set_xlabel('2¸ (degrees)', fontsize=12, fontweight='bold')
ax1.set_ylabel('Intensity (a.u.)', fontsize=12, fontweight='bold')
ax1.set_title('XRD Pattern of Crystalline Material\n(Sharp Bragg Peaks)', fontsize=13, fontweight='bold')
ax1.grid(alpha=0.3)
ax1.set_ylim(0, 110)

# Annotate peak positions
peaks_labels = ['(111)', '(200)', '(220)', '(311)']
peaks_pos = [28.4, 33.0, 47.5, 56.1]
for label, pos in zip(peaks_labels, peaks_pos):
    ax1.annotate(label, xy=(pos, 105), ha='center', fontsize=10,
                 bbox=dict(boxstyle='round,pad=0.3', facecolor='yellow', alpha=0.5))

# XRD pattern of amorphous material
two_theta_amor, intensity_amor = simulate_amorphous_xrd()
ax2.plot(two_theta_amor, intensity_amor, linewidth=1.5, color='#ff7f0e')
ax2.set_xlabel('2¸ (degrees)', fontsize=12, fontweight='bold')
ax2.set_ylabel('Intensity (a.u.)', fontsize=12, fontweight='bold')
ax2.set_title('XRD Pattern of Amorphous Material\n(Broad Halo)', fontsize=13, fontweight='bold')
ax2.grid(alpha=0.3)
ax2.set_ylim(0, 35)

plt.tight_layout()
plt.show()

print("Interpretation of XRD Patterns:")
print("\n[Crystalline Materials]")
print("- Sharp peaks appear at clear angles")
print("- Lattice parameters and crystal structure determined from peak positions")
print("- Information about atomic arrangement obtained from peak intensities")
print("- Examples: Metals, Ceramics, Silicon single crystals")

print("\n[Amorphous Materials]")
print("- Broad halo pattern")
print("- Short-range order exists, but no long-range order")
print("- Average interatomic distance estimated from halo position")
print("- Examples: Glass, Amorphous silicon, Some polymers")
</code></pre>

        <p><strong>Explanation</strong>: X-ray diffraction patterns clearly indicate the presence or absence of crystallinity. Crystalline materials show sharp peaks at specific angles, which allows identification of the crystal structure. Amorphous materials show broad patterns, indicating the absence of long-range order.</p>

        <hr>

        <h2>3.2 Unit Cell and Lattice Parameters</h2>

        <h3>Unit Cell</h3>

        <p>The <strong>unit cell</strong> is the smallest repeating unit of a crystal structure. The entire crystal can be constructed by arranging unit cells in three-dimensional space.</p>

        <p><strong>Lattice Parameters</strong>:</p>
        <ul>
            <li>$a, b, c$: Edge lengths of the unit cell (in Å)</li>
            <li>$\alpha, \beta, \gamma$: Angles between edges (in degrees or radians)</li>
        </ul>

        <h3>Seven Crystal Systems</h3>

        <p>Based on the shape of the unit cell, crystals are classified into seven crystal systems:</p>

        <table>
            <thead>
                <tr>
                    <th>Crystal System</th>
                    <th>Lattice Parameter Relationship</th>
                    <th>Angle Relationship</th>
                    <th>Examples</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>Cubic</strong></td>
                    <td>a = b = c</td>
                    <td>± = ² = ³ = 90°</td>
                    <td>NaCl, Cu, Fe, Si</td>
                </tr>
                <tr>
                    <td><strong>Tetragonal</strong></td>
                    <td>a = b ` c</td>
                    <td>± = ² = ³ = 90°</td>
                    <td>TiO‚, SnO‚</td>
                </tr>
                <tr>
                    <td><strong>Orthorhombic</strong></td>
                    <td>a ` b ` c</td>
                    <td>± = ² = ³ = 90°</td>
                    <td>±-S, BaSO„</td>
                </tr>
                <tr>
                    <td><strong>Hexagonal</strong></td>
                    <td>a = b ` c</td>
                    <td>± = ² = 90°, ³ = 120°</td>
                    <td>Mg, Zn, Graphite</td>
                </tr>
                <tr>
                    <td><strong>Rhombohedral</strong></td>
                    <td>a = b = c</td>
                    <td>± = ² = ³ ` 90°</td>
                    <td>Quartz, CaCOƒ</td>
                </tr>
                <tr>
                    <td><strong>Monoclinic</strong></td>
                    <td>a ` b ` c</td>
                    <td>± = ³ = 90° ` ²</td>
                    <td>²-S, CaSO„·2H‚O</td>
                </tr>
                <tr>
                    <td><strong>Triclinic</strong></td>
                    <td>a ` b ` c</td>
                    <td>± ` ² ` ³ ` 90°</td>
                    <td>CuSO„·5H‚O</td>
                </tr>
            </tbody>
        </table>

        <p>The most important in materials science is the <strong>cubic system</strong>. Many metals belong to the cubic system.</p>

        <h3>Miller Indices</h3>

        <p><strong>Miller indices</strong> are a notation method for representing planes and directions in crystals.</p>

        <p><strong>Notation for crystal planes</strong>: $(hkl)$</p>
        <p><strong>Notation for crystal directions</strong>: $[uvw]$</p>

        <p><strong>Method for determining Miller indices</strong> (for crystal planes):</p>
        <ol>
            <li>Find the coordinates where the plane intersects the a, b, c axes (intercepts)</li>
            <li>Take the reciprocals of each intercept</li>
            <li>Convert to integer ratios</li>
            <li>Express as $(hkl)$</li>
        </ol>

        <p><strong>Examples</strong>:</p>
        <ul>
            <li>$(100)$ plane: Plane perpendicular to the a-axis</li>
            <li>$(110)$ plane: Plane inclined at 45° to both a and b axes</li>
            <li>$(111)$ plane: Plane equally inclined to the a, b, and c axes</li>
        </ul>

        <h3>Calculation of Interplanar Spacing</h3>

        <p>For cubic systems, the interplanar spacing $d_{hkl}$ of the $(hkl)$ plane is calculated by the following equation:</p>

        <p>$$d_{hkl} = \frac{a}{\sqrt{h^2 + k^2 + l^2}}$$</p>

        <p>where $a$ is the lattice parameter.</p>

        <h3>Code Example 2: Calculator for Unit Cell Volume and Interplanar Spacing</h3>

        <p>Calculate the unit cell volume and interplanar spacing for planes specified by Miller indices from lattice parameters.</p>

        <pre><code class="language-python">import numpy as np

class CrystalCalculator:
    """
    Class for calculating various parameters of crystal structure
    """

    def __init__(self, a, b=None, c=None, alpha=90, beta=90, gamma=90):
        """
        Set lattice parameters

        Parameters:
        a, b, c: Lattice parameters (Å)
        alpha, beta, gamma: Angles (degrees)
        """
        self.a = a
        self.b = b if b is not None else a
        self.c = c if c is not None else a
        self.alpha = np.radians(alpha)
        self.beta = np.radians(beta)
        self.gamma = np.radians(gamma)

    def unit_cell_volume(self):
        """
        Calculate unit cell volume (Å³)
        """
        # General formula (applicable to all crystal systems)
        cos_alpha = np.cos(self.alpha)
        cos_beta = np.cos(self.beta)
        cos_gamma = np.cos(self.gamma)

        volume = self.a * self.b * self.c * np.sqrt(
            1 - cos_alpha**2 - cos_beta**2 - cos_gamma**2
            + 2*cos_alpha*cos_beta*cos_gamma
        )
        return volume

    def d_spacing_cubic(self, h, k, l):
        """
        Calculate interplanar spacing for cubic systems (simplified version)

        Parameters:
        h, k, l: Miller indices

        Returns:
        d: Interplanar spacing (Å)
        """
        if h == 0 and k == 0 and l == 0:
            raise ValueError("Miller indices cannot all be zero")

        d = self.a / np.sqrt(h**2 + k**2 + l**2)
        return d

    def print_crystal_info(self, crystal_name):
        """
        Display crystal information in an organized format
        """
        print(f"\n{'='*60}")
        print(f"[Crystal Parameters of {crystal_name}]")
        print(f"{'='*60}")
        print(f"Lattice parameter a = {self.a:.4f} Å")
        if self.b != self.a or self.c != self.a:
            print(f"Lattice parameter b = {self.b:.4f} Å")
            print(f"Lattice parameter c = {self.c:.4f} Å")

        volume = self.unit_cell_volume()
        print(f"Unit cell volume V = {volume:.4f} Å³")

        # Calculate interplanar spacing for major crystal planes (cubic system)
        if self.a == self.b == self.c and \
           self.alpha == self.beta == self.gamma == np.radians(90):
            print(f"\nInterplanar spacing for major crystal planes:")
            planes = [(1,0,0), (1,1,0), (1,1,1), (2,0,0), (2,2,0)]
            for h, k, l in planes:
                d = self.d_spacing_cubic(h, k, l)
                print(f"  ({h}{k}{l}) plane: d = {d:.4f} Å")


# Crystal parameters for representative materials
print("Crystal Structure Calculations for Representative Materials")

# Copper (FCC)
cu = CrystalCalculator(a=3.615)  # Å
cu.print_crystal_info("Copper (Cu, FCC)")

# Iron (BCC)
fe = CrystalCalculator(a=2.866)  # Å
fe.print_crystal_info("Iron (Fe, BCC)")

# Silicon (Diamond structure)
si = CrystalCalculator(a=5.431)  # Å
si.print_crystal_info("Silicon (Si)")

# Alumina (Hexagonal system)
al2o3 = CrystalCalculator(a=4.759, c=12.991, gamma=120)  # Å
print(f"\n{'='*60}")
print(f"[Crystal Parameters of Alumina (Al‚Oƒ, HCP)]")
print(f"{'='*60}")
print(f"Lattice parameter a = {al2o3.a:.4f} Å")
print(f"Lattice parameter c = {al2o3.c:.4f} Å")
print(f"c/a ratio = {al2o3.c/al2o3.a:.4f}")
volume = al2o3.unit_cell_volume()
print(f"Unit cell volume V = {volume:.4f} Å³")

print("\n" + "="*60)
print("Applications of interplanar spacing:")
print("- Prediction of X-ray diffraction peak positions")
print("- Calculation of atomic plane density")
print("- Analysis of slip systems (plastic deformation mechanisms)")
</code></pre>

        <p><strong>Sample Output</strong>:</p>
        <pre><code>Crystal Structure Calculations for Representative Materials
============================================================
[Crystal Parameters of Copper (Cu, FCC)]
============================================================
Lattice parameter a = 3.6150 Å
Unit cell volume V = 47.2418 Å³

Interplanar spacing for major crystal planes:
  (100) plane: d = 3.6150 Å
  (110) plane: d = 2.5557 Å
  (111) plane: d = 2.0871 Å
  (200) plane: d = 1.8075 Å
  (220) plane: d = 1.2779 Å</code></pre>

        <p><strong>Explanation</strong>: Unit cell volume and interplanar spacing can be calculated from lattice parameters. Interplanar spacing is used for predicting X-ray diffraction peak positions and calculating atomic plane density.</p>

        <hr>

        <h2>3.3 Major Crystal Structures</h2>

        <p>Most metallic materials have one of the following three crystal structures:</p>

        <h3>1. Face-Centered Cubic (FCC)</h3>

        <p><strong>Characteristics</strong>:</p>
        <ul>
            <li>Atoms located at the center of each face of the cube</li>
            <li>Number of atoms per unit cell: 4 (8 corners × 1/8 + 6 faces × 1/2 = 4)</li>
            <li>Coordination number: 12 (number of nearest atoms)</li>
            <li>Atomic Packing Fraction (APF): 74%</li>
            <li>Close-packed structure</li>
        </ul>

        <p><strong>Representative Materials</strong>:</p>
        <ul>
            <li>Copper (Cu): a = 3.615 Å</li>
            <li>Aluminum (Al): a = 4.049 Å</li>
            <li>Gold (Au): a = 4.078 Å</li>
            <li>Silver (Ag): a = 4.086 Å</li>
            <li>Nickel (Ni): a = 3.524 Å</li>
        </ul>

        <p><strong>Properties</strong>: Excellent ductility (many slip systems), relatively soft</p>

        <h3>2. Body-Centered Cubic (BCC)</h3>

        <p><strong>Characteristics</strong>:</p>
        <ul>
            <li>Atom located at the center of the cube</li>
            <li>Number of atoms per unit cell: 2 (8 corners × 1/8 + 1 body center = 2)</li>
            <li>Coordination number: 8</li>
            <li>Atomic Packing Fraction (APF): 68%</li>
        </ul>

        <p><strong>Representative Materials</strong>:</p>
        <ul>
            <li>Iron (Fe, ±-iron): a = 2.866 Å</li>
            <li>Chromium (Cr): a = 2.885 Å</li>
            <li>Tungsten (W): a = 3.165 Å</li>
            <li>Molybdenum (Mo): a = 3.147 Å</li>
            <li>Vanadium (V): a = 3.024 Å</li>
        </ul>

        <p><strong>Properties</strong>: High strength, prone to brittle fracture at low temperatures</p>

        <h3>3. Hexagonal Close-Packed (HCP)</h3>

        <p><strong>Characteristics</strong>:</p>
        <ul>
            <li>Close-packed structure of hexagonal system</li>
            <li>Number of atoms per unit cell: 6</li>
            <li>Coordination number: 12</li>
            <li>Atomic Packing Fraction (APF): 74% (same as FCC)</li>
            <li>Ideal c/a ratio: 1.633</li>
        </ul>

        <p><strong>Representative Materials</strong>:</p>
        <ul>
            <li>Magnesium (Mg): a = 3.209 Å, c/a = 1.624</li>
            <li>Zinc (Zn): a = 2.665 Å, c/a = 1.856</li>
            <li>Titanium (Ti): a = 2.951 Å, c/a = 1.588</li>
            <li>Cobalt (Co): a = 2.507 Å, c/a = 1.623</li>
        </ul>

        <p><strong>Properties</strong>: Few slip systems, low ductility (strong anisotropy)</p>

        <h3>Comparison Table of Crystal Structures</h3>

        <table>
            <thead>
                <tr>
                    <th>Item</th>
                    <th>FCC</th>
                    <th>BCC</th>
                    <th>HCP</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>Atoms per Unit Cell</strong></td>
                    <td>4</td>
                    <td>2</td>
                    <td>6</td>
                </tr>
                <tr>
                    <td><strong>Coordination Number</strong></td>
                    <td>12</td>
                    <td>8</td>
                    <td>12</td>
                </tr>
                <tr>
                    <td><strong>Packing Fraction (APF)</strong></td>
                    <td>74%</td>
                    <td>68%</td>
                    <td>74%</td>
                </tr>
                <tr>
                    <td><strong>Number of Slip Systems</strong></td>
                    <td>12</td>
                    <td>48 (limited at low temp)</td>
                    <td>3 (few)</td>
                </tr>
                <tr>
                    <td><strong>Ductility</strong></td>
                    <td>High</td>
                    <td>Medium to High</td>
                    <td>Low</td>
                </tr>
                <tr>
                    <td><strong>Representative Metals</strong></td>
                    <td>Cu, Al, Au, Ag</td>
                    <td>Fe, Cr, W, Mo</td>
                    <td>Mg, Zn, Ti, Co</td>
                </tr>
            </tbody>
        </table>

        <h3>Code Example 3: Calculation of Atomic Packing Fraction (APF)</h3>

        <p>Calculate and compare the atomic packing fraction for FCC, BCC, and HCP structures.</p>

        <pre><code class="language-python">import numpy as np

def calculate_apf_fcc(a, r=None):
    """
    Calculate atomic packing fraction (APF) for FCC structure

    Parameters:
    a: Lattice parameter (Å)
    r: Atomic radius (Å). If None, calculated from lattice parameter

    Returns:
    apf: Packing fraction
    """
    # In FCC structure, atoms touch along face diagonal
    # Face diagonal = 4r = a2, so r = a2/4
    if r is None:
        r = a * np.sqrt(2) / 4

    # Number of atoms per unit cell
    n_atoms = 4

    # Volume of atoms
    v_atoms = n_atoms * (4/3) * np.pi * r**3

    # Volume of unit cell
    v_cell = a**3

    # Packing fraction
    apf = v_atoms / v_cell

    return apf, r


def calculate_apf_bcc(a, r=None):
    """
    Calculate atomic packing fraction (APF) for BCC structure

    Parameters:
    a: Lattice parameter (Å)
    r: Atomic radius (Å). If None, calculated from lattice parameter

    Returns:
    apf: Packing fraction
    """
    # In BCC structure, atoms touch along body diagonal
    # Body diagonal = 4r = a3, so r = a3/4
    if r is None:
        r = a * np.sqrt(3) / 4

    # Number of atoms per unit cell
    n_atoms = 2

    # Volume of atoms
    v_atoms = n_atoms * (4/3) * np.pi * r**3

    # Volume of unit cell
    v_cell = a**3

    # Packing fraction
    apf = v_atoms / v_cell

    return apf, r


def calculate_apf_hcp(a, c, r=None):
    """
    Calculate atomic packing fraction (APF) for HCP structure

    Parameters:
    a: Lattice parameter of basal plane (Å)
    c: Lattice parameter in c-axis direction (Å)
    r: Atomic radius (Å). If None, assumed to be a/2

    Returns:
    apf: Packing fraction
    """
    # In HCP structure, atoms touch within the basal plane
    # a = 2r
    if r is None:
        r = a / 2

    # Number of atoms per unit cell
    n_atoms = 6

    # Volume of atoms
    v_atoms = n_atoms * (4/3) * np.pi * r**3

    # Volume of unit cell (hexagonal)
    # V = (3/2) * a² * c
    v_cell = (np.sqrt(3) / 2) * a**2 * c

    # Packing fraction
    apf = v_atoms / v_cell

    return apf, r


# Calculate and compare packing fractions
print("="*70)
print("Atomic Packing Fraction (APF) Calculation for Major Crystal Structures")
print("="*70)

# FCC (Copper as example)
a_fcc = 3.615  # Å
apf_fcc, r_fcc = calculate_apf_fcc(a_fcc)
print(f"\n[FCC Structure (e.g., Copper)]")
print(f"Lattice parameter a = {a_fcc} Å")
print(f"Atomic radius r = {r_fcc:.4f} Å")
print(f"Number of atoms per unit cell = 4")
print(f"Packing fraction APF = {apf_fcc:.4f} ({apf_fcc*100:.2f}%)")
print(f"Theoretical value: 0.7405 (74.05%)")

# BCC (Iron as example)
a_bcc = 2.866  # Å
apf_bcc, r_bcc = calculate_apf_bcc(a_bcc)
print(f"\n[BCC Structure (e.g., Iron)]")
print(f"Lattice parameter a = {a_bcc} Å")
print(f"Atomic radius r = {r_bcc:.4f} Å")
print(f"Number of atoms per unit cell = 2")
print(f"Packing fraction APF = {apf_bcc:.4f} ({apf_bcc*100:.2f}%)")
print(f"Theoretical value: 0.6802 (68.02%)")

# HCP (Magnesium as example, ideal c/a ratio)
a_hcp = 3.209  # Å
c_hcp = a_hcp * np.sqrt(8/3)  # Ideal c/a = 1.633
apf_hcp, r_hcp = calculate_apf_hcp(a_hcp, c_hcp)
print(f"\n[HCP Structure (e.g., Magnesium)]")
print(f"Lattice parameter a = {a_hcp} Å")
print(f"Lattice parameter c = {c_hcp:.4f} Å (ideal value)")
print(f"c/a ratio = {c_hcp/a_hcp:.4f}")
print(f"Atomic radius r = {r_hcp:.4f} Å")
print(f"Number of atoms per unit cell = 6")
print(f"Packing fraction APF = {apf_hcp:.4f} ({apf_hcp*100:.2f}%)")
print(f"Theoretical value: 0.7405 (74.05%)")

# Comparison
print("\n" + "="*70)
print("Comparison of Packing Fractions:")
print("="*70)
print(f"FCC: {apf_fcc*100:.2f}% - Close-packed, excellent ductility")
print(f"BCC: {apf_bcc*100:.2f}% - Somewhat sparse, high strength")
print(f"HCP: {apf_hcp*100:.2f}% - Close-packed, low ductility")

print("\nRelationship between packing fraction and material properties:")
print("- High packing fraction ’ High density, tendency for good ductility")
print("- Low packing fraction ’ Many voids, easier atomic movement")
print("- High coordination number ’ More bonds, higher stability")
</code></pre>

        <p><strong>Sample Output</strong>:</p>
        <pre><code>======================================================================
Atomic Packing Fraction (APF) Calculation for Major Crystal Structures
======================================================================

[FCC Structure (e.g., Copper)]
Lattice parameter a = 3.615 Å
Atomic radius r = 1.2780 Å
Number of atoms per unit cell = 4
Packing fraction APF = 0.7405 (74.05%)
Theoretical value: 0.7405 (74.05%)

[BCC Structure (e.g., Iron)]
Lattice parameter a = 2.866 Å
Atomic radius r = 1.2410 Å
Number of atoms per unit cell = 2
Packing fraction APF = 0.6802 (68.02%)
Theoretical value: 0.6802 (68.02%)</code></pre>

        <p><strong>Explanation</strong>: Atomic Packing Fraction (APF) is the ratio of the volume occupied by atoms to the unit cell volume. FCC and HCP have 74% packing (close-packed structures), while BCC has 68% (somewhat sparse structure). Packing fraction affects material density and mechanical properties.</p>

        <h3>Code Example 4: Visualization of Coordination Number and Nearest Neighbor Distance</h3>

        <p>Visualize the coordination number (number of nearest atoms) and interatomic distances for FCC and BCC structures.</p>

        <pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

def plot_coordination_fcc():
    """
    Visualize coordination number of FCC structure with 3D plot
    Central atom (face center) and its surrounding 12 nearest neighbors
    """
    fig = plt.figure(figsize=(10, 8))
    ax = fig.add_subplot(111, projection='3d')

    # Lattice parameter (normalized: a=1)
    a = 1.0

    # Position of central atom (e.g., face center at (0.5, 0.5, 0))
    center = np.array([0.5, 0.5, 0])

    # Relative positions of nearest neighbors in FCC structure (displacement from central atom)
    # Coordination number 12: distances to 4 different types of face centers
    nearest_neighbors = [
        # 4 in the same plane
        np.array([0.5, 0, 0]), np.array([-0.5, 0, 0]),
        np.array([0, 0.5, 0]), np.array([0, -0.5, 0]),
        # 4 in the upper plane
        np.array([0.5, 0, 1]), np.array([-0.5, 0, 1]),
        np.array([0, 0.5, 1]), np.array([0, -0.5, 1]),
        # 4 in the lower plane
        np.array([0.5, 0, -1]), np.array([-0.5, 0, -1]),
        np.array([0, 0.5, -1]), np.array([0, -0.5, -1]),
    ]

    # Simplification: Calculate actual positions
    # Note: The above is for conceptual explanation. Actually calculate positions within unit cell accurately

    # More accurate nearest neighbor positions (centered at face center)
    # FCC: Nearest atoms from face center are corners and other face centers
    neighbors_accurate = []
    for i in [-1, 1]:
        for j in [-1, 1]:
            neighbors_accurate.append(center + np.array([i*0.5, j*0.5, 0]))
            neighbors_accurate.append(center + np.array([i*0.5, 0, j*0.5]))
            neighbors_accurate.append(center + np.array([0, i*0.5, j*0.5]))

    # Remove duplicates
    neighbors_unique = []
    for n in neighbors_accurate:
        is_duplicate = False
        for nu in neighbors_unique:
            if np.allclose(n, nu):
                is_duplicate = True
                break
        if not is_duplicate:
            neighbors_unique.append(n)

    # Plot central atom
    ax.scatter(*center, s=500, c='red', marker='o',
               edgecolors='black', linewidth=2, label='Central atom', alpha=0.8)

    # Plot nearest neighbors
    neighbors_array = np.array(neighbors_unique)
    ax.scatter(neighbors_array[:, 0], neighbors_array[:, 1], neighbors_array[:, 2],
               s=200, c='blue', marker='o', edgecolors='black', linewidth=1.5,
               label='Nearest neighbors', alpha=0.6)

    # Draw bonds
    for neighbor in neighbors_unique:
        ax.plot([center[0], neighbor[0]],
                [center[1], neighbor[1]],
                [center[2], neighbor[2]],
                'k--', linewidth=1, alpha=0.3)

    ax.set_xlabel('X', fontsize=12, fontweight='bold')
    ax.set_ylabel('Y', fontsize=12, fontweight='bold')
    ax.set_zlabel('Z', fontsize=12, fontweight='bold')
    ax.set_title('Coordination Number of FCC Structure (12)', fontsize=14, fontweight='bold')
    ax.legend(fontsize=11)
    ax.set_box_aspect([1,1,1])

    return fig


def calculate_nearest_neighbor_distances():
    """
    Calculate nearest neighbor distances for FCC, BCC, HCP structures
    """
    print("="*70)
    print("Calculation of Nearest Neighbor Distances")
    print("="*70)

    # FCC
    a_fcc = 3.615  # Copper lattice parameter (Å)
    # FCC: Face diagonal = 4r = a2 ’ Nearest distance = 2r = a/2
    d_fcc = a_fcc / np.sqrt(2)
    print(f"\n[FCC (Copper)]")
    print(f"Lattice parameter a = {a_fcc} Å")
    print(f"Nearest neighbor distance = {d_fcc:.4f} Å")
    print(f"Coordination number = 12")

    # BCC
    a_bcc = 2.866  # Iron lattice parameter (Å)
    # BCC: Body diagonal = 4r = a3 ’ Nearest distance = 2r = a3/2
    d_bcc = a_bcc * np.sqrt(3) / 2
    print(f"\n[BCC (Iron)]")
    print(f"Lattice parameter a = {a_bcc} Å")
    print(f"Nearest neighbor distance = {d_bcc:.4f} Å")
    print(f"Coordination number = 8")

    # HCP
    a_hcp = 3.209  # Magnesium lattice parameter (Å)
    # HCP: Within basal plane = a = 2r ’ Nearest distance = a
    d_hcp = a_hcp
    print(f"\n[HCP (Magnesium)]")
    print(f"Lattice parameter a = {a_hcp} Å")
    print(f"Nearest neighbor distance = {d_hcp:.4f} Å")
    print(f"Coordination number = 12")

    # Comparison graphs
    structures = ['FCC\n(Cu)', 'BCC\n(Fe)', 'HCP\n(Mg)']
    distances = [d_fcc, d_bcc, d_hcp]
    coordination_numbers = [12, 8, 12]

    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 5))

    # Comparison of nearest neighbor distances
    colors = ['#1f77b4', '#ff7f0e', '#2ca02c']
    ax1.bar(structures, distances, color=colors, edgecolor='black', linewidth=1.5, alpha=0.7)
    ax1.set_ylabel('Nearest Neighbor Distance (Å)', fontsize=12, fontweight='bold')
    ax1.set_title('Nearest Neighbor Distance by Crystal Structure', fontsize=13, fontweight='bold')
    ax1.grid(axis='y', alpha=0.3)

    # Display values on top of bars
    for i, (s, d) in enumerate(zip(structures, distances)):
        ax1.text(i, d + 0.05, f'{d:.3f} Å', ha='center', fontsize=11, fontweight='bold')

    # Comparison of coordination numbers
    ax2.bar(structures, coordination_numbers, color=colors, edgecolor='black', linewidth=1.5, alpha=0.7)
    ax2.set_ylabel('Coordination Number', fontsize=12, fontweight='bold')
    ax2.set_title('Coordination Number by Crystal Structure', fontsize=13, fontweight='bold')
    ax2.set_ylim(0, 14)
    ax2.grid(axis='y', alpha=0.3)

    # Display values on top of bars
    for i, (s, cn) in enumerate(zip(structures, coordination_numbers)):
        ax2.text(i, cn + 0.3, f'{cn}', ha='center', fontsize=12, fontweight='bold')

    plt.tight_layout()
    plt.show()

    print("\n" + "="*70)
    print("Relationship between coordination number and material properties:")
    print("- High coordination number ’ More bonds ’ Stable, densely packed")
    print("- FCC, HCP: Coordination number 12 ’ Close-packed, excellent ductility")
    print("- BCC: Coordination number 8 ’ Somewhat sparse, high strength but brittle at low temperatures")


# Execute
calculate_nearest_neighbor_distances()
# plot_coordination_fcc()  # Uncomment if 3D plot is needed
plt.show()
</code></pre>

        <p><strong>Explanation</strong>: Coordination number is the number of atoms arranged closest around a given atom. The higher the coordination number, the more interatomic bonds exist, and the material is more stable and densely packed. FCC and HCP have coordination number 12 (close-packed), while BCC has coordination number 8 (somewhat sparse structure).</p>

        <hr>

        <h2>3.4 Crystal Structure and Material Properties</h2>

        <h3>Density Calculation</h3>

        <p>The theoretical density of a material can be calculated from its crystal structure:</p>

        <p>$$\rho = \frac{n \cdot M}{V_{cell} \cdot N_A}$$</p>

        <p>where,</p>
        <ul>
            <li>$\rho$: Density (g/cm³)</li>
            <li>$n$: Number of atoms per unit cell</li>
            <li>$M$: Atomic weight (g/mol)</li>
            <li>$V_{cell}$: Unit cell volume (cm³)</li>
            <li>$N_A$: Avogadro's number (6.022×10²³ mol{¹)</li>
        </ul>

        <h3>Slip Systems and Ductility</h3>

        <p><strong>Slip systems</strong> are combinations of planes and directions along which atomic planes slide during plastic deformation. The more slip systems available, the better the ductility of the material.</p>

        <p><strong>Slip systems for major crystal structures</strong>:</p>
        <ul>
            <li><strong>FCC</strong>: {111}è110é ’ 4 planes × 3 directions = 12 slip systems ’ High ductility</li>
            <li><strong>BCC</strong>: {110}è111é, {112}è111é, {123}è111é ’ 48 slip systems (theoretically) ’ Medium ductility</li>
            <li><strong>HCP</strong>: {0001}è1120é ’ 1 plane × 3 directions = 3 slip systems ’ Low ductility</li>
        </ul>

        <p><strong>Relationship between crystal structure and mechanical properties</strong>:</p>
        <ul>
            <li>FCC metals (Cu, Al, Au): Many slip systems ’ High ductility, good workability</li>
            <li>BCC metals (Fe, Cr, W): High temperature dependence ’ Brittle at low temperatures, ductile at high temperatures</li>
            <li>HCP metals (Mg, Zn, Ti): Few slip systems ’ Low ductility, difficult to process</li>
        </ul>

        <h3>Code Example 5: Density Calculation Tool</h3>

        <p>Calculate the theoretical density of materials from crystal structure parameters.</p>

        <pre><code class="language-python">import numpy as np

# Avogadro's number
NA = 6.022e23  # mol^-1

def calculate_density(n_atoms, atomic_mass, a, b=None, c=None,
                     alpha=90, beta=90, gamma=90):
    """
    Calculate theoretical density from crystal structure

    Parameters:
    n_atoms: Number of atoms per unit cell
    atomic_mass: Atomic weight (g/mol)
    a, b, c: Lattice parameters (Å)
    alpha, beta, gamma: Angles (degrees)

    Returns:
    density: Density (g/cm³)
    """
    # Set default values for lattice parameters
    if b is None:
        b = a
    if c is None:
        c = a

    # Convert angles to radians
    alpha_rad = np.radians(alpha)
    beta_rad = np.radians(beta)
    gamma_rad = np.radians(gamma)

    # Calculate unit cell volume (Å³)
    cos_alpha = np.cos(alpha_rad)
    cos_beta = np.cos(beta_rad)
    cos_gamma = np.cos(gamma_rad)

    V_cell = a * b * c * np.sqrt(
        1 - cos_alpha**2 - cos_beta**2 - cos_gamma**2
        + 2*cos_alpha*cos_beta*cos_gamma
    )

    # Convert Å³ ’ cm³ (1 Å = 10^-8 cm)
    V_cell_cm3 = V_cell * 1e-24

    # Calculate density
    density = (n_atoms * atomic_mass) / (V_cell_cm3 * NA)

    return density


# Calculate theoretical density for representative materials
print("="*70)
print("Theoretical Density Calculated from Crystal Structure")
print("="*70)

materials = [
    {
        'name': 'Copper (Cu, FCC)',
        'n_atoms': 4,
        'atomic_mass': 63.546,  # g/mol
        'a': 3.615,  # Å
        'structure': 'FCC'
    },
    {
        'name': 'Iron (Fe, BCC)',
        'n_atoms': 2,
        'atomic_mass': 55.845,
        'a': 2.866,
        'structure': 'BCC'
    },
    {
        'name': 'Aluminum (Al, FCC)',
        'n_atoms': 4,
        'atomic_mass': 26.982,
        'a': 4.049,
        'structure': 'FCC'
    },
    {
        'name': 'Tungsten (W, BCC)',
        'n_atoms': 2,
        'atomic_mass': 183.84,
        'a': 3.165,
        'structure': 'BCC'
    },
    {
        'name': 'Magnesium (Mg, HCP)',
        'n_atoms': 6,
        'atomic_mass': 24.305,
        'a': 3.209,
        'c': 5.211,
        'gamma': 120,
        'structure': 'HCP'
    },
    {
        'name': 'Gold (Au, FCC)',
        'n_atoms': 4,
        'atomic_mass': 196.967,
        'a': 4.078,
        'structure': 'FCC'
    }
]

# Calculate and display density
calculated_densities = []
experimental_densities = [8.96, 7.87, 2.70, 19.25, 1.74, 19.32]  # g/cm³ (measured values)

for i, mat in enumerate(materials):
    if 'c' in mat:
        density = calculate_density(mat['n_atoms'], mat['atomic_mass'],
                                   mat['a'], c=mat['c'], gamma=mat.get('gamma', 90))
    else:
        density = calculate_density(mat['n_atoms'], mat['atomic_mass'], mat['a'])

    calculated_densities.append(density)

    print(f"\n[{mat['name']}]")
    print(f"Crystal structure: {mat['structure']}")
    print(f"Number of atoms per unit cell: {mat['n_atoms']}")
    print(f"Atomic weight: {mat['atomic_mass']} g/mol")
    print(f"Lattice parameter a = {mat['a']} Å" + (f", c = {mat['c']} Å" if 'c' in mat else ""))
    print(f"Calculated density: {density:.3f} g/cm³")
    print(f"Experimental density: {experimental_densities[i]:.3f} g/cm³")
    print(f"Error: {abs(density - experimental_densities[i]) / experimental_densities[i] * 100:.2f}%")

# Comparison graph
import matplotlib.pyplot as plt

fig, ax = plt.subplots(figsize=(12, 6))

x = np.arange(len(materials))
width = 0.35

rects1 = ax.bar(x - width/2, calculated_densities, width, label='Calculated density',
                color='#1f77b4', edgecolor='black', linewidth=1.5, alpha=0.7)
rects2 = ax.bar(x + width/2, experimental_densities, width, label='Experimental density',
                color='#ff7f0e', edgecolor='black', linewidth=1.5, alpha=0.7)

ax.set_ylabel('Density (g/cm³)', fontsize=13, fontweight='bold')
ax.set_title('Comparison of Calculated Density from Crystal Structure and Experimental Values', fontsize=14, fontweight='bold')
ax.set_xticks(x)
ax.set_xticklabels([m['name'].split('(')[0].strip() for m in materials], rotation=15, ha='right')
ax.legend(fontsize=11)
ax.grid(axis='y', alpha=0.3)

# Display values on top of bars
for rect1, rect2 in zip(rects1, rects2):
    height1 = rect1.get_height()
    height2 = rect2.get_height()
    ax.text(rect1.get_x() + rect1.get_width()/2., height1,
            f'{height1:.2f}', ha='center', va='bottom', fontsize=8)
    ax.text(rect2.get_x() + rect2.get_width()/2., height2,
            f'{height2:.2f}', ha='center', va='bottom', fontsize=8)

plt.tight_layout()
plt.show()

print("\n" + "="*70)
print("Applications of density calculation:")
print("- Material identification (determine crystal structure from XRD pattern and density)")
print("- Evaluation of defects and impurities (estimate vacancy concentration from difference between experimental and theoretical density)")
print("- Lightweight design (optimize balance between density and strength)")
</code></pre>

        <p><strong>Sample Output</strong>:</p>
        <pre><code>======================================================================
Theoretical Density Calculated from Crystal Structure
======================================================================

[Copper (Cu, FCC)]
Crystal structure: FCC
Number of atoms per unit cell: 4
Atomic weight: 63.546 g/mol
Lattice parameter a = 3.615 Å
Calculated density: 8.933 g/cm³
Experimental density: 8.960 g/cm³
Error: 0.30%

[Iron (Fe, BCC)]
Crystal structure: BCC
Number of atoms per unit cell: 2
Atomic weight: 55.845 g/mol
Lattice parameter a = 2.866 Å
Calculated density: 7.879 g/cm³
Experimental density: 7.870 g/cm³
Error: 0.11%</code></pre>

        <p><strong>Explanation</strong>: Theoretical density can be calculated with high accuracy from crystal structure parameters. The difference between calculated and experimental values can be used to estimate vacancy concentration and other defects.</p>

        <h3>Code Example 6: Visualization of Slip Systems</h3>

        <p>Visualize the major slip system {111}è110é of FCC structure in 2D.</p>

        <pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
from matplotlib.patches import Polygon, FancyArrowPatch

def visualize_slip_systems_fcc():
    """
    Visualize slip systems of FCC structure in 2D projection
    {111}<110> slip system
    """
    fig, axes = plt.subplots(1, 3, figsize=(16, 5))

    # Draw projection of (111) plane
    # Unit cell of FCC structure (simplified 2D representation)

    # Examples of slip planes and slip directions
    slip_systems = [
        {
            'plane': '(111)',
            'direction': '[110]',
            'description': 'Most active slip system'
        },
        {
            'plane': '(111)',
            'direction': '[110]',
            'description': 'Symmetrical slip system'
        },
        {
            'plane': '(111)',
            'direction': '[101]',
            'description': 'Additional slip system'
        }
    ]

    for idx, (ax, slip_sys) in enumerate(zip(axes, slip_systems)):
        # Atomic positions (simplified 2D array)
        atoms_x = [0, 1, 2, 0.5, 1.5, 1]
        atoms_y = [0, 0, 0, 0.866, 0.866, 1.732]

        # Plot atoms
        ax.scatter(atoms_x, atoms_y, s=300, c='lightblue',
                  edgecolors='black', linewidth=2, zorder=3)

        # Show slip plane (gray band)
        slip_plane = Polygon([(0, 0), (2, 0), (2.5, 0.866), (0.5, 0.866)],
                            alpha=0.2, facecolor='gray', edgecolor='black',
                            linewidth=1.5, linestyle='--', zorder=1)
        ax.add_patch(slip_plane)

        # Show slip direction with arrow
        arrow = FancyArrowPatch((0.5, 0.4), (1.8, 0.4),
                               arrowstyle='->', mutation_scale=30,
                               linewidth=3, color='red', zorder=2)
        ax.add_patch(arrow)

        ax.set_xlim(-0.5, 3)
        ax.set_ylim(-0.5, 2.5)
        ax.set_aspect('equal')
        ax.set_title(f'{slip_sys["plane"]} plane\n{slip_sys["direction"]} direction\n({slip_sys["description"]})',
                    fontsize=11, fontweight='bold')
        ax.axis('off')

        # Legend
        ax.text(0.1, 2.2, 'Ï Atoms', fontsize=9)
        ax.text(0.1, 2.0, '   Slip plane', fontsize=9, color='gray')
        ax.text(0.1, 1.8, '’ Slip direction', fontsize=9, color='red')

    plt.suptitle('Slip Systems of FCC Structure {111}è110é (Total 12 systems)',
                fontsize=14, fontweight='bold', y=0.98)
    plt.tight_layout()
    plt.show()

    # Explain relationship between slip systems and ductility
    print("="*70)
    print("Slip Systems and Material Ductility")
    print("="*70)

    print("\n[FCC Structure]")
    print("- Slip planes: {111} (4 planes)")
    print("- Slip directions: è110é (3 directions per plane)")
    print("- Total slip systems: 4 × 3 = 12")
    print("- Ductility: Very high (many slip systems)")
    print("- Examples: Cu, Al, Au, Ag ’ Easy plastic deformation")

    print("\n[BCC Structure]")
    print("- Slip planes: {110}, {112}, {123} (multiple)")
    print("- Slip directions: è111é")
    print("- Total slip systems: 48 (theoretically)")
    print("- Ductility: High temperature dependence (limited at low temperatures)")
    print("- Examples: Fe, Cr, W ’ Prone to brittle fracture at low temperatures")

    print("\n[HCP Structure]")
    print("- Slip planes: {0001} (1 plane, basal plane)")
    print("- Slip directions: è1120é (3 directions)")
    print("- Total slip systems: 1 × 3 = 3 (very few)")
    print("- Ductility: Low (limited slip systems)")
    print("- Examples: Mg, Zn, Ti ’ Difficult to process at room temperature")

    print("\n" + "="*70)
    print("Number of slip systems and workability:")
    print("- Many slip systems ’ Easy plastic deformation ’ High ductility, good workability")
    print("- Few slip systems ’ Difficult plastic deformation ’ Low ductility, prone to brittle fracture")
    print("- Material selection: FCC metals are advantageous for applications requiring processing")


# Execute
visualize_slip_systems_fcc()
</code></pre>

        <p><strong>Explanation</strong>: Slip systems are combinations of planes and directions along which atomic planes slide during plastic deformation. The more slip systems available, the more directions from which the material can receive forces and still plastically deform, resulting in excellent ductility. FCC has 12 slip systems (high ductility), while HCP has 3 slip systems (low ductility).</p>

        <h3>Code Example 7: 3D Visualization of Crystal Structures (FCC, BCC, HCP)</h3>

        <p>Visualize the three major crystal structures in 3D to understand the differences in structure.</p>

        <pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

def plot_crystal_structure_3d(structure_type='FCC'):
    """
    Visualize crystal structure in 3D

    Parameters:
    structure_type: One of 'FCC', 'BCC', 'HCP'
    """
    fig = plt.figure(figsize=(10, 8))
    ax = fig.add_subplot(111, projection='3d')

    # Lattice parameter (normalized: a=1)
    a = 1.0

    if structure_type == 'FCC':
        # Atomic positions for FCC structure
        positions = [
            # 8 corners (each 1/8)
            [0, 0, 0], [a, 0, 0], [a, a, 0], [0, a, 0],
            [0, 0, a], [a, 0, a], [a, a, a], [0, a, a],
            # 6 face centers (each 1/2)
            [a/2, a/2, 0], [a/2, 0, a/2], [0, a/2, a/2],
            [a/2, a/2, a], [a/2, a, a/2], [a, a/2, a/2]
        ]
        title = 'FCC (Face-Centered Cubic)'
        description = '4 atoms per unit cell\nCoordination number 12, Packing fraction 74%'

    elif structure_type == 'BCC':
        # Atomic positions for BCC structure
        positions = [
            # 8 corners (each 1/8)
            [0, 0, 0], [a, 0, 0], [a, a, 0], [0, a, 0],
            [0, 0, a], [a, 0, a], [a, a, a], [0, a, a],
            # 1 body center
            [a/2, a/2, a/2]
        ]
        title = 'BCC (Body-Centered Cubic)'
        description = '2 atoms per unit cell\nCoordination number 8, Packing fraction 68%'

    elif structure_type == 'HCP':
        # Atomic positions for HCP structure (simplified representation)
        c_a_ratio = 1.633  # Ideal c/a ratio
        c = a * c_a_ratio

        # 3 corners of basal plane + 3 corners of top plane + 2 internal atoms
        positions = [
            # Lower basal plane (3 corners)
            [0, 0, 0], [a, 0, 0], [a/2, a*np.sqrt(3)/2, 0],
            # Upper basal plane
            [0, 0, c], [a, 0, c], [a/2, a*np.sqrt(3)/2, c],
            # Internal (2 atoms)
            [a/2, a/(2*np.sqrt(3)), c/2], [a/2, a*np.sqrt(3)/6, c/2]
        ]
        title = 'HCP (Hexagonal Close-Packed)'
        description = '6 atoms per unit cell\nCoordination number 12, Packing fraction 74%'
    else:
        raise ValueError("structure_type must be one of 'FCC', 'BCC', 'HCP'")

    # Convert atomic positions to array
    positions = np.array(positions)

    # Plot atoms
    ax.scatter(positions[:, 0], positions[:, 1], positions[:, 2],
              s=300, c='lightblue', edgecolors='darkblue', linewidth=2,
              alpha=0.8, depthshade=True)

    # Draw unit cell frame
    # Edges of cube
    edges = [
        # Bottom face
        [[0, 0, 0], [a, 0, 0]], [[a, 0, 0], [a, a, 0]],
        [[a, a, 0], [0, a, 0]], [[0, a, 0], [0, 0, 0]],
        # Top face
        [[0, 0, a], [a, 0, a]], [[a, 0, a], [a, a, a]],
        [[a, a, a], [0, a, a]], [[0, a, a], [0, 0, a]],
        # Vertical edges
        [[0, 0, 0], [0, 0, a]], [[a, 0, 0], [a, 0, a]],
        [[a, a, 0], [a, a, a]], [[0, a, 0], [0, a, a]]
    ]

    if structure_type != 'HCP':
        for edge in edges:
            edge = np.array(edge)
            ax.plot3D(edge[:, 0], edge[:, 1], edge[:, 2],
                     'k-', linewidth=1.5, alpha=0.6)
    else:
        # For HCP, hexagonal prism frame
        # Simplified, omitted (implementation is complex)
        pass

    # Axis labels
    ax.set_xlabel('X', fontsize=12, fontweight='bold')
    ax.set_ylabel('Y', fontsize=12, fontweight='bold')
    ax.set_zlabel('Z', fontsize=12, fontweight='bold')
    ax.set_title(f'{title}\n{description}', fontsize=13, fontweight='bold', pad=20)

    # Adjust viewpoint
    ax.view_init(elev=20, azim=45)
    ax.set_box_aspect([1,1,1])

    # Turn off grid
    ax.grid(False)

    return fig, ax


# Display three crystal structures side by side
fig = plt.figure(figsize=(18, 6))

for i, structure in enumerate(['FCC', 'BCC', 'HCP'], 1):
    ax = fig.add_subplot(1, 3, i, projection='3d')

    # Lattice parameter
    a = 1.0

    if structure == 'FCC':
        positions = np.array([
            [0, 0, 0], [a, 0, 0], [a, a, 0], [0, a, 0],
            [0, 0, a], [a, 0, a], [a, a, a], [0, a, a],
            [a/2, a/2, 0], [a/2, 0, a/2], [0, a/2, a/2],
            [a/2, a/2, a], [a/2, a, a/2], [a, a/2, a/2]
        ])
        title = 'FCC'
        info = 'Atoms: 4\nCoordination: 12\nAPF: 74%'

    elif structure == 'BCC':
        positions = np.array([
            [0, 0, 0], [a, 0, 0], [a, a, 0], [0, a, 0],
            [0, 0, a], [a, 0, a], [a, a, a], [0, a, a],
            [a/2, a/2, a/2]
        ])
        title = 'BCC'
        info = 'Atoms: 2\nCoordination: 8\nAPF: 68%'

    else:  # HCP
        c = a * 1.633
        positions = np.array([
            [0, 0, 0], [a, 0, 0], [a/2, a*np.sqrt(3)/2, 0],
            [0, 0, c], [a, 0, c], [a/2, a*np.sqrt(3)/2, c],
            [a/2, a/(2*np.sqrt(3)), c/2]
        ])
        title = 'HCP'
        info = 'Atoms: 6\nCoordination: 12\nAPF: 74%'

    # Plot atoms
    ax.scatter(positions[:, 0], positions[:, 1], positions[:, 2],
              s=250, c='lightblue', edgecolors='darkblue', linewidth=2,
              alpha=0.8, depthshade=True)

    # Unit cell frame
    if structure != 'HCP':
        edges = [
            [[0, 0, 0], [a, 0, 0]], [[a, 0, 0], [a, a, 0]],
            [[a, a, 0], [0, a, 0]], [[0, a, 0], [0, 0, 0]],
            [[0, 0, a], [a, 0, a]], [[a, 0, a], [a, a, a]],
            [[a, a, a], [0, a, a]], [[0, a, a], [0, 0, a]],
            [[0, 0, 0], [0, 0, a]], [[a, 0, 0], [a, 0, a]],
            [[a, a, 0], [a, a, a]], [[0, a, 0], [0, a, a]]
        ]
        for edge in edges:
            edge = np.array(edge)
            ax.plot3D(edge[:, 0], edge[:, 1], edge[:, 2],
                     'k-', linewidth=1.5, alpha=0.5)

    ax.set_xlabel('X', fontsize=10)
    ax.set_ylabel('Y', fontsize=10)
    ax.set_zlabel('Z', fontsize=10)
    ax.set_title(f'{title}\n{info}', fontsize=12, fontweight='bold')
    ax.view_init(elev=20, azim=45)
    ax.set_box_aspect([1,1,1])
    ax.grid(False)

plt.suptitle('3D Visualization of Major Crystal Structures', fontsize=15, fontweight='bold', y=0.98)
plt.tight_layout()
plt.show()

print("="*70)
print("Significance of crystal structure visualization:")
print("="*70)
print("\n3D visualization helps understand:")
print("- Spatial arrangement of atoms (where atoms are located)")
print("- Packing density (densely packed or with voids)")
print("- Symmetry (relationship between structural beauty and properties)")
print("- Prediction of slip planes (which planes slip easily)")

print("\nApplications in actual material development:")
print("- Prediction of crystal structures for new materials")
print("- Understanding of phase transformations (e.g., FCC’BCC)")
print("- Prediction of material properties (estimate properties from structure)")
</code></pre>

        <p><strong>Explanation</strong>: 3D visualization clearly shows the differences in atomic arrangement among FCC, BCC, and HCP. FCC and BCC belong to the cubic system, while HCP belongs to the hexagonal system, with different packing densities (packing fractions) and coordination numbers. These differences significantly affect the mechanical properties of materials.</p>

        <hr>

        <h2>3.5 Chapter Summary</h2>

        <h3>What We Learned</h3>

        <ol>
            <li><strong>Difference Between Crystalline and Amorphous Materials</strong>
                <ul>
                    <li>Crystalline: Long-range order, sharp melting point, sharp XRD peaks</li>
                    <li>Amorphous: Short-range order only, glass transition, broad XRD patterns</li>
                </ul>
            </li>
            <li><strong>Unit Cell and Lattice Parameters</strong>
                <ul>
                    <li>Unit cell: Smallest repeating unit of crystal</li>
                    <li>Seven crystal systems: Cubic, tetragonal, orthorhombic, hexagonal, rhombohedral, monoclinic, triclinic</li>
                    <li>Miller indices: Notation for crystal planes with (hkl) and directions with [uvw]</li>
                </ul>
            </li>
            <li><strong>Major Crystal Structures</strong>
                <ul>
                    <li>FCC: 4 atoms, coordination 12, APF 74%, high ductility (Cu, Al, Au)</li>
                    <li>BCC: 2 atoms, coordination 8, APF 68%, high strength (Fe, Cr, W)</li>
                    <li>HCP: 6 atoms, coordination 12, APF 74%, low ductility (Mg, Zn, Ti)</li>
                </ul>
            </li>
            <li><strong>Crystal Structure and Material Properties</strong>
                <ul>
                    <li>Density can be calculated from crystal structure</li>
                    <li>Number of slip systems determines ductility</li>
                    <li>FCC: 12 slip systems ’ High ductility</li>
                    <li>HCP: 3 slip systems ’ Low ductility</li>
                </ul>
            </li>
            <li><strong>Visualization with Python</strong>
                <ul>
                    <li>Simulation of XRD patterns</li>
                    <li>Calculation of packing fraction and coordination number</li>
                    <li>Density calculation tool</li>
                    <li>3D visualization of crystal structures</li>
                </ul>
            </li>
        </ol>

        <h3>Key Points</h3>

        <ul>
            <li>Crystal structure is a <strong>critical factor governing mechanical properties</strong> of materials</li>
            <li>Higher packing fraction generally means higher density and better ductility</li>
            <li>Number of slip systems determines ductility (more systems = higher ductility)</li>
            <li>XRD is the most important technique for crystal structure analysis</li>
            <li>Miller indices are the standard method for representing crystal planes and directions</li>
        </ul>

        <h3>To the Next Chapter</h3>

        <p>In Chapter 4, we will learn about the <strong>relationship between material properties and structure</strong>:</p>
        <ul>
            <li>Mechanical properties (stress-strain curves, hardness)</li>
            <li>Electrical properties (band structure, conductivity)</li>
            <li>Thermal properties (thermal conductivity, thermal expansion)</li>
            <li>Optical properties (absorption spectra, color)</li>
            <li>Calculation and plotting of material properties using Python</li>
        </ul>

        <div class="navigation">
            <a href="chapter-2.html" class="nav-button"> Previous: Atomic Structure and Chemical Bonding</a>
            <a href="index.html" class="nav-button">Series Index</a>
            <a href="chapter-4.html" class="nav-button">Next: Material Properties and Structure Relationship ’</a>
        </div>
    </main>


    <section class="disclaimer">
        <h3>Disclaimer</h3>
        <ul>
            <li>This content is provided for educational, research, and informational purposes only and does not constitute professional advice (legal, accounting, technical guarantees, etc.).</li>
            <li>This content and accompanying code examples are provided "AS IS" without any warranties, express or implied, including but not limited to merchantability, fitness for a particular purpose, non-infringement, accuracy, completeness, operation, or safety.</li>
            <li>The authors and Tohoku University assume no responsibility for the content, availability, or safety of external links, third-party data, tools, or libraries.</li>
            <li>The authors and Tohoku University shall not be liable for any direct, indirect, incidental, special, consequential, or punitive damages arising from the use, execution, or interpretation of this content, to the maximum extent permitted by applicable law.</li>
            <li>The content may be changed, updated, or discontinued without notice.</li>
            <li>The copyright and license of this content are subject to the specified conditions (e.g., CC BY 4.0). Such licenses typically include warranty disclaimers.</li>
        </ul>
    </section>

<footer>
        <p><strong>Author</strong>: MS Knowledge Hub Content Team</p>
        <p><strong>Version</strong>: 1.0 | <strong>Created</strong>: 2025-10-25</p>
        <p><strong>License</strong>: Creative Commons BY 4.0</p>
        <p>&copy; 2025 MS Terakoya. All rights reserved.</p>
    </footer>
</body>
</html>
