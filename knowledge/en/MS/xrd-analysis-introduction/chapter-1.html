<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="Chapter 1: Fundamentals of X-ray Diffraction - MS Terakoya. Understand Bragg's law and calculate diffraction conditions using formulas and Python" name="description"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Chapter 1: Fundamentals of X-ray Diffraction - MS Terakoya</title>
<style>
        :root {
            --color-primary: #2c3e50;
            --color-primary-dark: #1a252f;
            --color-accent: #f093fb;
            --color-accent-light: #f5576c;
            --color-text: #2d3748;
            --color-text-light: #4a5568;
            --color-bg: #ffffff;
            --color-bg-alt: #f7fafc;
            --color-border: #e2e8f0;
            --color-code-bg: #f8f9fa;
            --color-link: #f093fb;
            --color-link-hover: #d07be8;

            --spacing-xs: 0.5rem;
            --spacing-sm: 1rem;
            --spacing-md: 1.5rem;
            --spacing-lg: 2rem;
            --spacing-xl: 3rem;

            --font-body: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            --font-mono: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;

            --border-radius: 8px;
            --box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-body);
            line-height: 1.7;
            color: var(--color-text);
            background-color: var(--color-bg);
            font-size: 16px;
        }

        header {
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            color: white;
            padding: var(--spacing-xl) var(--spacing-md);
            margin-bottom: var(--spacing-xl);
            box-shadow: var(--box-shadow);
        }

        .header-content {
            max-width: 900px;
            margin: 0 auto;
        }

        h1 {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: var(--spacing-sm);
            line-height: 1.2;
        }

        .subtitle {
            font-size: 1.1rem;
            opacity: 0.95;
            font-weight: 400;
            margin-bottom: var(--spacing-md);
        }

        .meta {
            display: flex;
            flex-wrap: wrap;
            gap: var(--spacing-md);
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .meta-item {
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 0 var(--spacing-md) var(--spacing-xl);
        }

        h2 {
            font-size: 1.75rem;
            color: var(--color-primary);
            margin-top: var(--spacing-xl);
            margin-bottom: var(--spacing-md);
            padding-bottom: var(--spacing-xs);
            border-bottom: 3px solid var(--color-accent);
        }

        h3 {
            font-size: 1.4rem;
            color: var(--color-primary);
            margin-top: var(--spacing-lg);
            margin-bottom: var(--spacing-sm);
        }

        h4 {
            font-size: 1.1rem;
            color: var(--color-primary-dark);
            margin-top: var(--spacing-md);
            margin-bottom: var(--spacing-sm);
        }

        p {
            margin-bottom: var(--spacing-md);
            color: var(--color-text);
        }

        a {
            color: var(--color-link);
            text-decoration: none;
            transition: color 0.2s;
        }

        a:hover {
            color: var(--color-link-hover);
            text-decoration: underline;
        }

        ul, ol {
            margin-left: var(--spacing-lg);
            margin-bottom: var(--spacing-md);
        }

        li {
            margin-bottom: var(--spacing-xs);
            color: var(--color-text);
        }

        pre {
            background-color: var(--color-code-bg);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            overflow-x: auto;
            margin-bottom: var(--spacing-md);
            font-family: var(--font-mono);
            font-size: 0.9rem;
            line-height: 1.5;
        }

        code {
            font-family: var(--font-mono);
            font-size: 0.9em;
            background-color: var(--color-code-bg);
            padding: 0.2em 0.4em;
            border-radius: 3px;
        }

        pre code {
            background-color: transparent;
            padding: 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: var(--spacing-md);
            font-size: 0.95rem;
        }

        th, td {
            border: 1px solid var(--color-border);
            padding: var(--spacing-sm);
            text-align: left;
        }

        th {
            background-color: var(--color-bg-alt);
            font-weight: 600;
            color: var(--color-primary);
        }

        blockquote {
            border-left: 4px solid var(--color-accent);
            padding-left: var(--spacing-md);
            margin: var(--spacing-md) 0;
            color: var(--color-text-light);
            font-style: italic;
            background-color: var(--color-bg-alt);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        .mermaid {
            text-align: center;
            margin: var(--spacing-lg) 0;
            background-color: var(--color-bg-alt);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        details {
            background-color: var(--color-bg-alt);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            margin-bottom: var(--spacing-md);
        }

        summary {
            cursor: pointer;
            font-weight: 600;
            color: var(--color-primary);
            user-select: none;
            padding: var(--spacing-xs);
            margin: calc(-1 * var(--spacing-md));
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        summary:hover {
            background-color: rgba(240, 147, 251, 0.1);
        }

        details[open] summary {
            margin-bottom: var(--spacing-md);
            border-bottom: 1px solid var(--color-border);
        }

        .learning-objectives {
            background: linear-gradient(135deg, #fce7f3 0%, #fbcfe8 100%);
            padding: var(--spacing-lg);
            border-radius: var(--border-radius);
            border-left: 4px solid var(--color-accent);
            margin-bottom: var(--spacing-xl);
        }

        .learning-objectives h2 {
            margin-top: 0;
            border-bottom: none;
        }

        .breadcrumb {
            max-width: 900px;
            margin: 0 auto;
            padding: var(--spacing-sm) var(--spacing-md);
            font-size: 0.9rem;
            color: var(--color-text-light);
        }

        .breadcrumb a {
            color: var(--color-link);
            text-decoration: none;
        }

        .breadcrumb a:hover {
            text-decoration: underline;
        }

        .navigation {
            display: flex;
            justify-content: space-between;
            gap: var(--spacing-md);
            margin: var(--spacing-xl) 0;
            padding-top: var(--spacing-lg);
            border-top: 2px solid var(--color-border);
        }

        .nav-button {
            flex: 1;
            padding: var(--spacing-md);
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            color: white;
            border-radius: var(--border-radius);
            text-align: center;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: var(--box-shadow);
        }

        .nav-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            text-decoration: none;
        }

        footer {
            margin-top: var(--spacing-xl);
            padding: var(--spacing-lg) var(--spacing-md);
            background-color: var(--color-bg-alt);
            border-top: 1px solid var(--color-border);
            text-align: center;
            font-size: 0.9rem;
            color: var(--color-text-light);
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.6rem;
            }

            h2 {
                font-size: 1.4rem;
            }

            h3 {
                font-size: 1.2rem;
            }

            .navigation {
                flex-direction: column;
            }

            pre {
                font-size: 0.85rem;
            }
        }

        /* Breadcrumb styles */
        .breadcrumb {
            background: #f7fafc;
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #e2e8f0;
            font-size: 0.9rem;
        }

        .breadcrumb-content {
            max-width: 900px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .breadcrumb a {
            color: #667eea;
            text-decoration: none;
            transition: color 0.2s;
        }

        .breadcrumb a:hover {
            color: #764ba2;
            text-decoration: underline;
        }

        .breadcrumb-separator {
            color: #a0aec0;
            margin: 0 0.25rem;
        }

        .breadcrumb-current {
            color: #4a5568;
            font-weight: 500;
        }
    </style>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ startOnLoad: true, theme: 'neutral' });
    </script>
</head>
<body>
<nav class="breadcrumb">
<div class="breadcrumb-content">
<a href="../index.html">AI Terakoya Home</a><span class="breadcrumb-separator">:</span><a href="../../MS/index.html">Materials Science</a><span class="breadcrumb-separator">:</span><a href="../../MS/xrd-analysis-introduction/index.html">XRD Analysis</a><span class="breadcrumb-separator">:</span><span class="breadcrumb-current">Chapter 1</span>
</div>
</nav><div class="locale-switcher">
<span class="current-locale">üåê EN</span>
<span class="locale-separator">|</span>
<a href="../../../jp/MS/xrd-analysis-introduction/chapter-1.html" class="locale-link">üáØüáµ JP</a>
<span class="locale-separator">|</span>
<span class="locale-meta">Last sync: 2025-11-16</span>
</div>
<header>
<div class="header-content">
<h1>Chapter 1: Fundamentals of X-ray Diffraction</h1>
<p class="subtitle">From Bragg's Law to Structure Factors - Theoretical Foundations of Crystal Structure Analysis</p>
<div class="meta">
<span class="meta-item">=√ñ Reading Time: 25-30 min</span>
<span class="meta-item">&lt;¬Ø Difficulty: Intermediate</span>
<span class="meta-item">=¬ª Code Examples: 8</span>
</div>
</div>
</header>
<main class="container">

<p class="chapter-description">This chapter covers the fundamentals of Fundamentals of X, which ray diffraction. You will learn Infer crystal symmetry from systematic absences and structure factor calculations.</p>
<div class="learning-objectives">
<h2>Learning Objectives</h2>
<p>Upon completing this chapter, you will be able to:</p>
<ul>
<li>Understand Bragg's law and calculate diffraction conditions using formulas and Python</li>
<li>Visualize and explain the relationship between crystal lattice and reciprocal lattice</li>
<li>Infer crystal symmetry from systematic absences</li>
<li>Implement structure factor calculations and predict diffraction intensities</li>
<li>Visualize diffraction conditions using the Ewald sphere</li>
</ul>
</div>
<h2>1.1 Bragg's Law and Diffraction Conditions</h2>
<p>X-ray diffraction (XRD) is the most fundamental technique for crystal structure analysis. When X-rays interact with the atomic arrangement in a crystal, diffraction occurs at specific angles, providing information about the crystal structure.</p>
<h3>1.1.1 Derivation of Bragg's Law</h3>
<p>Bragg's law was discovered in 1912 by William Lawrence Bragg and William Henry Bragg. Considering a crystal as a collection of atomic planes, constructive interference occurs when the path difference between X-rays reflected from adjacent atomic planes equals an integer multiple of the wavelength.</p>
<p>When X-rays of wavelength \( \lambda \) are incident at angle \( \theta \) on crystal planes with spacing \( d \), the diffraction condition is expressed as:</p>
<p style="text-align: center; font-size: 1.2em; margin: 1.5em 0;">
            \[ 2d\sin\theta = n\lambda \]
        </p>
<p>Here, \( n \) is the order of diffraction (integer), \( d \) is the plane spacing, \( \theta \) is the incident angle (Bragg angle), and \( \lambda \) is the X-ray wavelength.</p>
<div class="mermaid">
graph LR
    A[X-ray Incidence<br/>¬ª = 1.54 √Ö] --&gt; B[Crystal Plane<br/>d = 3.5 √Ö]
    B --&gt; C{Bragg Condition<br/>2dsin¬∏ = n¬ª}
    C --&gt;|Satisfied| D[Diffraction Peak<br/>Observed]
    C --&gt;|Not Satisfied| E[No Diffraction<br/>Not Observed]
    style C fill:#fce7f3
    style D fill:#e8f5e9
    style E fill:#ffebee
        </div>
<h3>1.1.2 Python Implementation for Calculations</h3>
<pre><code class="language-python"># Requirements:
# - Python 3.9+
# - matplotlib&gt;=3.7.0
# - numpy&gt;=1.24.0, &lt;2.0.0

import numpy as np
import matplotlib.pyplot as plt

def bragg_law(d, wavelength, n=1):
    """Calculate diffraction angle using Bragg's law

    Args:
        d (float): Plane spacing [√Ö]
        wavelength (float): X-ray wavelength [√Ö]
        n (int): Order of diffraction

    Returns:
        float: Bragg angle [degrees], or None if diffraction is impossible
    """
    # 2d*sin(theta) = n*lambda
    # sin(theta) = n*lambda / (2*d)
    sin_theta = (n * wavelength) / (2 * d)

    # Check for physically valid solution
    if sin_theta &gt; 1.0:
        return None  # Diffraction impossible

    theta_rad = np.arcsin(sin_theta)
    theta_deg = np.degrees(theta_rad)

    return theta_deg


# Example: Calculation using Cu K¬± radiation (1.54 √Ö)
wavelength_CuKa = 1.54056  # √Ö

# Calculate diffraction angles for different plane spacings
d_spacings = [4.0, 3.5, 3.0, 2.5, 2.0, 1.5]  # √Ö

print("d-spacing [√Ö] | Bragg angle [deg] (n=1) | Bragg angle [deg] (n=2)")
print("-" * 60)
for d in d_spacings:
    theta_n1 = bragg_law(d, wavelength_CuKa, n=1)
    theta_n2 = bragg_law(d, wavelength_CuKa, n=2)

    if theta_n1 is not None:
        print(f"{d:6.2f}      | {theta_n1:15.2f}    | ", end="")
        if theta_n2 is not None:
            print(f"{theta_n2:15.2f}")
        else:
            print("   Impossible")
    else:
        print(f"{d:6.2f}      |    Impossible    |    Impossible")

# Expected output:
# d-spacing [√Ö] | Bragg angle [deg] (n=1) | Bragg angle [deg] (n=2)
# ------------------------------------------------------------
#   4.00      |           11.10    |            22.48
#   3.50      |           12.69    |            25.77
#   3.00      |           14.83    |            30.36
#   2.50      |           17.93    |            37.32
#   2.00      |           22.58    |            48.92
#   1.50      |           30.96    |            75.55</code></pre>
<h3>1.1.3 Visualization of Diffraction Angles</h3>
<pre><code class="language-python">def plot_bragg_angles(wavelength, d_range=(1.0, 5.0), n_max=3):
    """Plot the dependence of Bragg angle on plane spacing

    Args:
        wavelength (float): X-ray wavelength [√Ö]
        d_range (tuple): Range of plane spacing [√Ö]
        n_max (int): Maximum order of diffraction
    """
    d_values = np.linspace(d_range[0], d_range[1], 200)

    plt.figure(figsize=(10, 6))
    colors = ['#f093fb', '#f5576c', '#3498db']

    for n in range(1, n_max + 1):
        theta_values = []
        valid_d_values = []

        for d in d_values:
            theta = bragg_law(d, wavelength, n)
            if theta is not None:
                theta_values.append(theta)
                valid_d_values.append(d)

        if theta_values:
            plt.plot(valid_d_values, theta_values,
                    label=f'n = {n}', linewidth=2, color=colors[n-1])

    plt.xlabel('Plane spacing d [√Ö]', fontsize=12)
    plt.ylabel('Bragg angle ¬∏ [degrees]', fontsize=12)
    plt.title(f'Bragg\'s Law: Relationship between Diffraction Angle and Plane Spacing (¬ª = {wavelength:.2f} √Ö)', fontsize=14)
    plt.grid(True, alpha=0.3)
    plt.legend(fontsize=11)
    plt.xlim(d_range)
    plt.ylim(0, 90)
    plt.tight_layout()
    plt.show()

# For Cu K¬± radiation
plot_bragg_angles(1.54056, d_range=(1.0, 5.0), n_max=3)</code></pre>
<h2>1.2 Crystal Lattice and Reciprocal Lattice</h2>
<h3>1.2.1 Fundamentals of Crystal Lattice</h3>
<p>A crystal is a structure where basic units (unit cells) are periodically arranged in three-dimensional space. The unit cell is defined by three basis vectors \( \mathbf{a}, \mathbf{b}, \mathbf{c} \).</p>
<p>The position vector \( \mathbf{R} \) of any lattice point is expressed as:</p>
<p style="text-align: center; font-size: 1.1em; margin: 1.5em 0;">
            \[ \mathbf{R} = u\mathbf{a} + v\mathbf{b} + w\mathbf{c} \]
        </p>
<p>Here, \( u, v, w \) are integers.</p>
<h3>1.2.2 Reciprocal Lattice Vectors</h3>
<p>The reciprocal lattice is an extremely important concept for understanding diffraction phenomena in crystals. The reciprocal lattice vectors \( \mathbf{a}^*, \mathbf{b}^*, \mathbf{c}^* \) are defined as follows:</p>
<p style="text-align: center; font-size: 1.05em; margin: 1.5em 0;">
            \[
            \mathbf{a}^* = \frac{\mathbf{b} \times \mathbf{c}}{V}, \quad
            \mathbf{b}^* = \frac{\mathbf{c} \times \mathbf{a}}{V}, \quad
            \mathbf{c}^* = \frac{\mathbf{a} \times \mathbf{b}}{V}
            \]
        </p>
<p>Here, \( V = \mathbf{a} \cdot (\mathbf{b} \times \mathbf{c}) \) is the volume of the unit cell.</p>
<pre><code class="language-python"># Requirements:
# - Python 3.9+
# - numpy&gt;=1.24.0, &lt;2.0.0

import numpy as np

def reciprocal_lattice_vectors(a, b, c):
    """Calculate reciprocal lattice vectors from real lattice vectors

    Args:
        a, b, c (np.ndarray): Real lattice basis vectors [√Ö]

    Returns:
        tuple: (a*, b*, c*) Reciprocal lattice vectors [√Ö^-1]
    """
    # Unit cell volume
    V = np.dot(a, np.cross(b, c))

    # Reciprocal lattice vectors
    a_star = np.cross(b, c) / V
    b_star = np.cross(c, a) / V
    c_star = np.cross(a, b) / V

    return a_star, b_star, c_star


def d_spacing_from_hkl(h, k, l, a_star, b_star, c_star):
    """Calculate plane spacing from Miller indices

    Args:
        h, k, l (int): Miller indices
        a_star, b_star, c_star (np.ndarray): Reciprocal lattice vectors [√Ö^-1]

    Returns:
        float: Plane spacing d [√Ö]
    """
    # Reciprocal lattice vector G = h*a* + k*b* + l*c*
    G = h * a_star + k * b_star + l * c_star

    # Plane spacing d = 1 / |G|
    d = 1.0 / np.linalg.norm(G)

    return d


# Example: Cubic crystal system (a = b = c = 4.0 √Ö, 90 degree angles)
a = np.array([4.0, 0.0, 0.0])
b = np.array([0.0, 4.0, 0.0])
c = np.array([0.0, 0.0, 4.0])

a_star, b_star, c_star = reciprocal_lattice_vectors(a, b, c)

print("Real lattice vectors:")
print(f"a = {a}")
print(f"b = {b}")
print(f"c = {c}\n")

print("Reciprocal lattice vectors:")
print(f"a* = {a_star} [√Ö^-1]")
print(f"b* = {b_star} [√Ö^-1]")
print(f"c* = {c_star} [√Ö^-1]\n")

# Calculate plane spacings for various Miller indices
miller_indices = [(1, 0, 0), (1, 1, 0), (1, 1, 1), (2, 0, 0), (2, 2, 0)]

print("Miller indices | Plane spacing d [√Ö]")
print("-" * 30)
for h, k, l in miller_indices:
    d = d_spacing_from_hkl(h, k, l, a_star, b_star, c_star)
    print(f" ({h} {k} {l})      | {d:12.4f}")

# Expected output (cubic crystal):
# (1 0 0)      |       4.0000
# (1 1 0)      |       2.8284
# (1 1 1)      |       2.3094
# (2 0 0)      |       2.0000
# (2 2 0)      |       1.4142</code></pre>
<h2>1.3 Systematic Absences and Symmetry</h2>
<h3>1.3.1 Systematic Absences</h3>
<p>Systematic absences refer to the phenomenon where reflections with specific Miller indices disappear due to crystal symmetry (space group). This reflects the symmetry of atomic arrangements within the unit cell.</p>
<p><strong>Representative systematic absences:</strong></p>
<table>
<thead>
<tr>
<th>Lattice Type</th>
<th>Systematic Absence</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td>Body-centered cubic (BCC)</td>
<td>Reflections with \( h + k + l = odd \) are absent</td>
<td>(1,0,0), (1,1,0) are absent</td>
</tr>
<tr>
<td>Face-centered cubic (FCC)</td>
<td>Reflections with mixed \( h, k, l \) (mixed parity) are absent</td>
<td>(1,0,0), (1,1,0) are absent</td>
</tr>
<tr>
<td>C-centered orthorhombic (C)</td>
<td>Reflections with \( h + k = odd \) are absent</td>
<td>(1,0,0), (0,1,0) are absent</td>
</tr>
</tbody>
</table>
<h3>1.3.2 Implementation of Systematic Absences</h3>
<pre><code class="language-python">def systematic_absences(h, k, l, lattice_type):
    """Determine systematic absences

    Args:
        h, k, l (int): Miller indices
        lattice_type (str): Lattice type ('P', 'I', 'F', 'C', 'A', 'B')

    Returns:
        bool: True = reflection observed, False = absent
    """
    if lattice_type == 'P':  # Primitive lattice
        return True

    elif lattice_type == 'I':  # Body-centered lattice
        return (h + k + l) % 2 == 0

    elif lattice_type == 'F':  # Face-centered lattice
        # h, k, l are all even or all odd
        parity = [h % 2, k % 2, l % 2]
        return len(set(parity)) == 1

    elif lattice_type == 'C':  # C-centered
        return (h + k) % 2 == 0

    elif lattice_type == 'A':  # A-centered
        return (k + l) % 2 == 0

    elif lattice_type == 'B':  # B-centered
        return (h + l) % 2 == 0

    else:
        raise ValueError(f"Unknown lattice type: {lattice_type}")


# Test: Confirm systematic absences for various lattice types
lattice_types = ['P', 'I', 'F', 'C']
miller_list = [(1,0,0), (1,1,0), (1,1,1), (2,0,0), (2,2,0), (2,2,2)]

print("Miller indices | P (Primitive) | I (BCC) | F (FCC) | C (C-centered)")
print("-" * 65)

for hkl in miller_list:
    h, k, l = hkl
    results = [systematic_absences(h, k, l, lt) for lt in lattice_types]
    status = [' ' if r else ' -' for r in results]
    print(f" ({h} {k} {l})     | {status[0]}      | {status[1]}      | {status[2]}      | {status[3]}")

# Expected output:
#  (1 0 0)     |        |  -      |  -      |  -
#  (1 1 0)     |        |        |  -      |  -
#  (1 1 1)     |        |  -      |        |  
#  (2 0 0)     |        |        |        |  
#  (2 2 0)     |        |        |        |  
#  (2 2 2)     |        |        |        |  </code></pre>
<h2>1.4 Structure Factor</h2>
<h3>1.4.1 Definition of Structure Factor</h3>
<p>The structure factor \( F_{hkl} \) is a complex number that determines the diffraction intensity for specific Miller indices \( (h, k, l) \). It is the sum of the amplitudes and phases of scattered waves from all atoms in the unit cell.</p>
<p style="text-align: center; font-size: 1.1em; margin: 1.5em 0;">
            \[ F_{hkl} = \sum_{j=1}^{N} f_j \exp\left[2\pi i (hx_j + ky_j + lz_j)\right] \]
        </p>
<p>Here, \( f_j \) is the atomic scattering factor of atom \( j \), and \( (x_j, y_j, z_j) \) are the fractional coordinates of atom \( j \).</p>
<p>The diffraction intensity \( I_{hkl} \) is proportional to the square of the absolute value of the structure factor:</p>
<p style="text-align: center; font-size: 1.1em; margin: 1.5em 0;">
            \[ I_{hkl} \propto |F_{hkl}|^2 = F_{hkl} \cdot F_{hkl}^* \]
        </p>
<h3>1.4.2 Implementation of Structure Factor Calculation</h3>
<pre><code class="language-python"># Requirements:
# - Python 3.9+
# - numpy&gt;=1.24.0, &lt;2.0.0

import numpy as np

def structure_factor(h, k, l, atoms, scattering_factors):
    """Calculate structure factor

    Args:
        h, k, l (int): Miller indices
        atoms (list): List of atomic positions [(x1, y1, z1), (x2, y2, z2), ...]
        scattering_factors (list): Scattering factor for each atom [f1, f2, ...]

    Returns:
        complex: Structure factor F_hkl
    """
    F_hkl = 0.0 + 0.0j  # Complex number

    for (x, y, z), f_j in zip(atoms, scattering_factors):
        # Phase factor exp[2√Äi(hx + ky + lz)]
        phase = 2 * np.pi * (h * x + k * y + l * z)
        F_hkl += f_j * np.exp(1j * phase)

    return F_hkl


def intensity_from_structure_factor(F_hkl):
    """Calculate diffraction intensity from structure factor

    Args:
        F_hkl (complex): Structure factor

    Returns:
        float: Diffraction intensity I  |F|^2
    """
    return np.abs(F_hkl) ** 2


# Example: Simple cubic (SC) - 1 atom at (0, 0, 0)
print("=== Simple Cubic (SC) ===")
atoms_sc = [(0, 0, 0)]
f_sc = [1.0]  # Normalized scattering factor

for hkl in [(1,0,0), (1,1,0), (1,1,1), (2,0,0)]:
    h, k, l = hkl
    F = structure_factor(h, k, l, atoms_sc, f_sc)
    I = intensity_from_structure_factor(F)
    print(f"({h} {k} {l}): F = {F:.4f}, I = {I:.4f}")

# Example: Body-centered cubic (BCC) - 2 atoms at (0,0,0), (1/2,1/2,1/2)
print("\n=== Body-Centered Cubic (BCC) ===")
atoms_bcc = [(0, 0, 0), (0.5, 0.5, 0.5)]
f_bcc = [1.0, 1.0]

for hkl in [(1,0,0), (1,1,0), (1,1,1), (2,0,0), (2,2,0)]:
    h, k, l = hkl
    F = structure_factor(h, k, l, atoms_bcc, f_bcc)
    I = intensity_from_structure_factor(F)
    print(f"({h} {k} {l}): F = {F.real:6.4f}{F.imag:+6.4f}i, I = {I:.4f}")

# Expected output:
# BCC: (1,0,0) and (1,1,0) have I=0 (systematic absence), (1,1,1) and (2,2,0) have I&gt;0</code></pre>
<h3>1.4.3 Application to Real Crystals</h3>
<pre><code class="language-python">def calculate_xrd_pattern(a, lattice_type, atom_positions, scattering_factors,
                          wavelength=1.54056, two_theta_max=90):
    """Simulate XRD pattern

    Args:
        a (float): Lattice constant [√Ö]
        lattice_type (str): Lattice type ('P', 'I', 'F')
        atom_positions (list): Fractional coordinates of atoms
        scattering_factors (list): Atomic scattering factors
        wavelength (float): X-ray wavelength [√Ö]
        two_theta_max (float): Maximum 2¬∏ angle [degrees]

    Returns:
        tuple: (two_theta_list, intensity_list)
    """
    # Reciprocal lattice vectors (simplified for cubic)
    a_vec = np.array([a, 0, 0])
    b_vec = np.array([0, a, 0])
    c_vec = np.array([0, 0, a])
    a_star, b_star, c_star = reciprocal_lattice_vectors(a_vec, b_vec, c_vec)

    two_theta_list = []
    intensity_list = []

    # Scan Miller indices
    for h in range(0, 6):
        for k in range(0, 6):
            for l in range(0, 6):
                if h == 0 and k == 0 and l == 0:
                    continue

                # Check systematic absences
                if not systematic_absences(h, k, l, lattice_type):
                    continue

                # Calculate plane spacing
                d = d_spacing_from_hkl(h, k, l, a_star, b_star, c_star)

                # Calculate Bragg angle
                theta = bragg_law(d, wavelength, n=1)
                if theta is None or 2*theta &gt; two_theta_max:
                    continue

                # Calculate structure factor and intensity
                F = structure_factor(h, k, l, atom_positions, scattering_factors)
                I = intensity_from_structure_factor(F)

                # Lorentz-polarization factor (simplified)
                LP = (1 + np.cos(2*np.radians(theta))**2) / (np.sin(np.radians(theta))**2 * np.cos(np.radians(theta)))
                I_corrected = I * LP

                two_theta_list.append(2 * theta)
                intensity_list.append(I_corrected)

    return np.array(two_theta_list), np.array(intensity_list)


# Simulation: ¬±-Fe (BCC, a = 2.87 √Ö)
a_Fe = 2.87
atoms_Fe = [(0, 0, 0), (0.5, 0.5, 0.5)]
f_Fe = [26.0, 26.0]  # Atomic number of Fe

two_theta, intensity = calculate_xrd_pattern(
    a=a_Fe,
    lattice_type='I',
    atom_positions=atoms_Fe,
    scattering_factors=f_Fe,
    wavelength=1.54056,
    two_theta_max=120
)

# Display peaks
print("=== ¬±-Fe (BCC) XRD Pattern Simulation ===")
print("2¬∏ [deg]  | Relative intensity")
print("-" * 30)

# Normalize intensities
intensity_normalized = 100 * intensity / np.max(intensity)

# Sort by 2theta
sorted_indices = np.argsort(two_theta)
for idx in sorted_indices[:10]:  # Top 10 peaks
    print(f"{two_theta[idx]:7.2f}  | {intensity_normalized[idx]:7.1f}")

# Expected output: Typical peak positions for ¬±-Fe
# (110): ~44.7¬∞
# (200): ~65.0¬∞
# (211): ~82.3¬∞</code></pre>
<h2>1.5 Ewald Sphere and Visualization of Diffraction Conditions</h2>
<h3>1.5.1 Concept of the Ewald Sphere</h3>
<p>The Ewald sphere is a powerful tool for visualizing the geometric conditions of X-ray diffraction. In reciprocal space, a sphere of radius \( 1/\lambda \) is drawn with the endpoint of the incident X-ray vector \( \mathbf{k}_0 \) at the origin.</p>
<p>The diffraction condition is satisfied when the Ewald sphere passes through a reciprocal lattice point:</p>
<p style="text-align: center; font-size: 1.1em; margin: 1.5em 0;">
            \[ \mathbf{k} - \mathbf{k}_0 = \mathbf{G}_{hkl} \]
        </p>
<p>Here, \( \mathbf{k} \) is the wave vector of the diffracted X-ray, and \( \mathbf{G}_{hkl} \) is the reciprocal lattice vector.</p>
<div class="mermaid">
graph TD
    A[Incident X-ray<br/>wave vector k0] --&gt; B[Ewald Sphere<br/>radius = 1/¬ª]
    B --&gt; C{Reciprocal lattice point<br/>on Ewald sphere?}
    C --&gt;|Yes| D[Diffraction condition satisfied<br/>Diffraction occurs]
    C --&gt;|No| E[No diffraction]
    D --&gt; F[Diffracted X-ray<br/>wave vector k]
    style B fill:#fce7f3
    style D fill:#e8f5e9
    style E fill:#ffebee
        </div>
<h3>1.5.2 Plotting the Ewald Sphere</h3>
<pre><code class="language-python"># Requirements:
# - Python 3.9+
# - matplotlib&gt;=3.7.0

import matplotlib.pyplot as plt
from matplotlib.patches import Circle
from matplotlib.patches import FancyArrowPatch

def plot_ewald_sphere_2d(wavelength, a, hkl_max=3):
    """Draw 2D cross-section of Ewald sphere

    Args:
        wavelength (float): X-ray wavelength [√Ö]
        a (float): Lattice constant [√Ö] (cubic)
        hkl_max (int): Maximum Miller index for reciprocal lattice points to plot
    """
    fig, ax = plt.subplots(figsize=(10, 8))

    # Radius of Ewald sphere
    k = 1.0 / wavelength  # [√Ö^-1]

    # Center of Ewald sphere (endpoint of incident X-ray)
    center = np.array([k, 0])

    # Draw Ewald sphere
    circle = Circle(center, k, fill=False, edgecolor='#f093fb', linewidth=2, label='Ewald Sphere')
    ax.add_patch(circle)

    # Draw reciprocal lattice points (cubic, 2D cross-section)
    a_star = 1.0 / a  # [√Ö^-1]

    reciprocal_points = []
    for h in range(-hkl_max, hkl_max + 1):
        for l in range(-hkl_max, hkl_max + 1):
            G_x = h * a_star
            G_z = l * a_star
            reciprocal_points.append((G_x, G_z, h, l))

            # Plot reciprocal lattice point
            ax.plot(G_x, G_z, 'o', color='#2c3e50', markersize=4)

    # Incident X-ray vector
    ax.arrow(0, 0, k, 0, head_width=0.02, head_length=0.03,
             fc='#f5576c', ec='#f5576c', linewidth=2, label='Incident X-ray k0')

    # Highlight reciprocal lattice points that intersect with Ewald sphere
    for G_x, G_z, h, l in reciprocal_points:
        dist_from_center = np.sqrt((G_x - center[0])**2 + (G_z - center[1])**2)
        if abs(dist_from_center - k) &lt; 0.02:  # On the sphere
            ax.plot(G_x, G_z, 'o', color='#e74c3c', markersize=10,
                   label=f'Diffraction possible: ({h},0,{l})' if h==1 and l==0 else '')

            # Diffracted X-ray vector
            ax.arrow(0, 0, G_x, G_z, head_width=0.01, head_length=0.02,
                    fc='#e74c3c', ec='#e74c3c', linewidth=1.5,
                    linestyle='--', alpha=0.7)

    ax.set_xlabel('Reciprocal lattice h direction [√Ö$^{-1}$]', fontsize=12)
    ax.set_ylabel('Reciprocal lattice l direction [√Ö$^{-1}$]', fontsize=12)
    ax.set_title(f'Ewald Sphere and Reciprocal Lattice (¬ª = {wavelength:.2f} √Ö, a = {a:.2f} √Ö)', fontsize=14)
    ax.set_aspect('equal')
    ax.grid(True, alpha=0.3)
    ax.axhline(y=0, color='k', linewidth=0.5)
    ax.axvline(x=0, color='k', linewidth=0.5)

    # Clean up legend
    handles, labels = ax.get_legend_handles_labels()
    by_label = dict(zip(labels, handles))
    ax.legend(by_label.values(), by_label.keys(), loc='upper right')

    plt.tight_layout()
    plt.show()

# For Cu K¬± radiation, lattice constant a = 3.5 √Ö
plot_ewald_sphere_2d(wavelength=1.54056, a=3.5, hkl_max=2)</code></pre>
<h2>Review of Learning Objectives</h2>
<p>Having completed this chapter, you are now able to explain and implement the following:</p>
<div class="learning-objectives">
<h3>Basic Understanding</h3>
<ul>
<li> Physical meaning and derivation of Bragg's law \( 2d\sin\theta = n\lambda \)</li>
<li> Relationship between crystal lattice and reciprocal lattice, and calculation of plane spacing</li>
<li> Relationship between systematic absences and crystal symmetry</li>
</ul>
<h3>Practical Skills</h3>
<ul>
<li> Calculate diffraction angles in Python and visualize the relationship with plane spacing</li>
<li> Derive plane spacing for Miller indices from reciprocal lattice vectors</li>
<li> Calculate structure factors and predict diffraction intensities</li>
<li> Simulate XRD patterns and compare with experimental data</li>
</ul>
<h3>Application Capability</h3>
<ul>
<li> Geometrically understand diffraction conditions using the Ewald sphere</li>
<li> Infer crystal lattice type from systematic absences</li>
<li> Simulate XRD patterns for real materials (¬±-Fe, etc.)</li>
</ul>
</div>
<h2>Exercises</h2>
<h3>Easy (Basic Confirmation)</h3>
<details>
<summary><strong>Q1</strong>: Calculate the Bragg angle (n=1) for a crystal plane with spacing d = 2.5 √Ö using Cu K¬± radiation (¬ª = 1.54 √Ö).</summary>
<p><strong>Solution</strong>:</p>
<pre><code class="language-python">theta = bragg_law(d=2.5, wavelength=1.54, n=1)
print(f"Bragg angle: {theta:.2f} degrees")
# Output: Bragg angle: 17.93 degrees</code></pre>
<p><strong>Explanation</strong>:</p>
<p>From Bragg's law \( 2d\sin\theta = n\lambda \):</p>
<p>\[ \sin\theta = \frac{n\lambda}{2d} = \frac{1 \times 1.54}{2 \times 2.5} = 0.308 \]</p>
<p>\[ \theta = \arcsin(0.308) = 17.93¬∞ \]</p>
</details>
<details>
<summary><strong>Q2</strong>: In a body-centered cubic (BCC) lattice, is the (1,1,0) reflection observed? Verify using systematic absences.</summary>
<p><strong>Solution</strong>:</p>
<pre><code class="language-python">is_allowed = systematic_absences(1, 1, 0, 'I')
print(f"(1,1,0) reflection: {'Observed' if is_allowed else 'Absent'}")
# Output: (1,1,0) reflection: Observed</code></pre>
<p><strong>Explanation</strong>:</p>
<p>BCC (body-centered lattice, lattice_type='I') systematic absence: Only \( h + k + l = even \) are observed.</p>
<p>For (1,1,0): \( 1 + 1 + 0 = 2 \) (even) ‚Äô Observed </p>
<p>For (1,0,0): \( 1 + 0 + 0 = 1 \) (odd) ‚Äô Absent </p>
</details>
<h3>Medium (Application)</h3>
<details>
<summary><strong>Q3</strong>: Calculate the plane spacing for (2,2,0) and (1,1,1) planes in a cubic crystal (a=4.0√Ö) and compare which has larger spacing.</summary>
<p><strong>Solution</strong>:</p>
<pre><code class="language-python">a = 4.0
a_vec = np.array([a, 0, 0])
b_vec = np.array([0, a, 0])
c_vec = np.array([0, 0, a])
a_star, b_star, c_star = reciprocal_lattice_vectors(a_vec, b_vec, c_vec)

d_220 = d_spacing_from_hkl(2, 2, 0, a_star, b_star, c_star)
d_111 = d_spacing_from_hkl(1, 1, 1, a_star, b_star, c_star)

print(f"d_220 = {d_220:.4f} √Ö")
print(f"d_111 = {d_111:.4f} √Ö")
print(f"Larger spacing: {'(1,1,1)' if d_111 &gt; d_220 else '(2,2,0)'}")

# Expected output:
# d_220 = 1.4142 √Ö
# d_111 = 2.3094 √Ö
# Larger spacing: (1,1,1)</code></pre>
<p><strong>Explanation</strong>:</p>
<p>Cubic crystal plane spacing formula: \( d_{hkl} = \frac{a}{\sqrt{h^2 + k^2 + l^2}} \)</p>
<p>(2,2,0): \( d = 4.0 / \sqrt{4+4+0} = 4.0 / 2.83 = 1.414 \) √Ö</p>
<p>(1,1,1): \( d = 4.0 / \sqrt{1+1+1} = 4.0 / 1.732 = 2.309 \) √Ö</p>
<p>Conclusion: (1,1,1) has larger plane spacing (smaller Miller indices correspond to wider spacing)</p>
</details>
<details>
<summary><strong>Q4</strong>: Compare the intensity of the (1,0,0) reflection for simple cubic (SC) and face-centered cubic (FCC) lattices using structure factors.</summary>
<p><strong>Solution</strong>:</p>
<pre><code class="language-python"># SC: 1 atom at (0,0,0)
atoms_sc = [(0, 0, 0)]
f_sc = [1.0]
F_sc = structure_factor(1, 0, 0, atoms_sc, f_sc)
I_sc = intensity_from_structure_factor(F_sc)

# FCC: 4 atoms at (0,0,0), (1/2,1/2,0), (1/2,0,1/2), (0,1/2,1/2)
atoms_fcc = [(0,0,0), (0.5,0.5,0), (0.5,0,0.5), (0,0.5,0.5)]
f_fcc = [1.0, 1.0, 1.0, 1.0]
F_fcc = structure_factor(1, 0, 0, atoms_fcc, f_fcc)
I_fcc = intensity_from_structure_factor(F_fcc)

print(f"SC: F_100 = {F_sc:.4f}, I = {I_sc:.4f}")
print(f"FCC: F_100 = {F_fcc:.4f}, I = {I_fcc:.4f}")

# Expected output:
# SC: F_100 = 1.0000, I = 1.0000
# FCC: F_100 = 0.0000, I = 0.0000 (absent)</code></pre>
<p><strong>Explanation</strong>:</p>
<p>FCC structure factor for (1,0,0):</p>
<p>\[ F = 1 \cdot e^{0} + 1 \cdot e^{i\pi} + 1 \cdot e^{i\pi} + 1 \cdot e^{0} = 1 + (-1) + (-1) + 1 = 0 \]</p>
<p>In FCC, mixed-index reflections ((1,0,0), etc.) are systematically absent.</p>
</details>
<h3>Hard (Advanced)</h3>
<details>
<summary><strong>Q5</strong>: Simulate XRD patterns for ¬±-Fe (BCC, a=2.87√Ö) and ¬≥-Fe (FCC, a=3.65√Ö), and compare the position (2¬∏) of the strongest peak. Use Cu K¬± radiation.</summary>
<p><strong>Solution</strong>:</p>
<pre><code class="language-python"># ¬±-Fe (BCC)
two_theta_bcc, intensity_bcc = calculate_xrd_pattern(
    a=2.87, lattice_type='I',
    atom_positions=[(0,0,0), (0.5,0.5,0.5)],
    scattering_factors=[26.0, 26.0]
)
max_idx_bcc = np.argmax(intensity_bcc)
print(f"¬±-Fe (BCC) strongest peak: 2¬∏ = {two_theta_bcc[max_idx_bcc]:.2f}¬∞")

# ¬≥-Fe (FCC)
two_theta_fcc, intensity_fcc = calculate_xrd_pattern(
    a=3.65, lattice_type='F',
    atom_positions=[(0,0,0), (0.5,0.5,0), (0.5,0,0.5), (0,0.5,0.5)],
    scattering_factors=[26.0]*4
)
max_idx_fcc = np.argmax(intensity_fcc)
print(f"¬≥-Fe (FCC) strongest peak: 2¬∏ = {two_theta_fcc[max_idx_fcc]:.2f}¬∞")

# Expected output:
# ¬±-Fe (BCC) strongest peak: 2¬∏ H 44.7¬∞ (110 reflection)
# ¬≥-Fe (FCC) strongest peak: 2¬∏ H 43.6¬∞ (111 reflection)</code></pre>
<p><strong>Explanation</strong>:</p>
<p>¬±-Fe (BCC): Strongest peak is (110) reflection (h+k+l=2, minimum even number)</p>
<p>¬≥-Fe (FCC): Strongest peak is (111) reflection (all odd, minimum)</p>
<p>This difference allows clear distinction between BCC and FCC by XRD. This is applied in phase transformation analysis of actual steel materials.</p>
</details>
<details>
<summary><strong>Q6</strong>: Using the Ewald sphere concept, explain why not all reciprocal lattice points diffract simultaneously with monochromatic X-rays.</summary>
<p><strong>Solution</strong>:</p>
<p><strong>Reason</strong>:</p>
<ol>
<li>The radius of the Ewald sphere is fixed (= 1/¬ª)</li>
<li>The diffraction condition is "reciprocal lattice point is on the Ewald sphere"</li>
<li>With monochromatic X-rays, the Ewald sphere is at a fixed position unless the sample is rotated</li>
<li>Most reciprocal lattice points are inside or outside the sphere, not on the surface</li>
</ol>
<p><strong>Experimental Solutions</strong>:</p>
<ul>
<li><strong>Powder XRD</strong>: Randomly oriented microcrystals allow observation of diffraction from all orientations</li>
<li><strong>Single crystal rotation method</strong>: Rotate the sample to sequentially pass reciprocal lattice points through the Ewald sphere</li>
<li><strong>White X-ray (Laue method)</strong>: Various wavelengths ‚Äô various Ewald sphere radii ‚Äô simultaneous observation of many reflections</li>
</ul>
</details>
<h2>Confirmation of Learning Objectives</h2>
<p>Upon completing this chapter, you can explain and implement the following:</p>
<h3>Basic Understanding</h3>
<ul>
<li> Derive Bragg's law (n¬ª = 2d sin¬∏) and explain its physical meaning</li>
<li> Understand the relationship between crystal lattice and reciprocal lattice, and calculate reciprocal lattice vectors</li>
<li> Explain the physical mechanism of systematic absences (destructive interference)</li>
<li> Understand the calculation method and physical meaning of structure factor F(hkl)</li>
</ul>
<h3>Practical Skills</h3>
<ul>
<li> Calculate d-spacing in Python and predict diffraction angles</li>
<li> Apply systematic absences to any space group and determine allowed reflections</li>
<li> Calculate structure factors from atomic coordinates and predict diffraction intensities</li>
<li> Visualize diffraction conditions using the Ewald sphere concept</li>
</ul>
<h3>Application Capability</h3>
<ul>
<li> Infer crystal structure (BCC/FCC, etc.) from experimental XRD patterns</li>
<li> Predict the effect of lattice constant changes on XRD patterns</li>
<li> Use systematic absences to narrow down space group candidates</li>
<li> Plan XRD analysis strategies for polycrystalline materials</li>
</ul>
<h2>References</h2>
<ol>
<li>Cullity, B. D., &amp; Stock, S. R. (2001). <em>Elements of X-Ray Diffraction</em> (3rd ed.). Prentice Hall. - Classic textbook on X-ray diffraction, comprehensive coverage from Bragg's law to crystal structure analysis</li>
<li>Warren, B. E. (1990). <em>X-ray Diffraction</em>. Dover Publications. - Detailed explanation of the physical foundations of diffraction theory, excellent derivation of structure factors</li>
<li>Pecharsky, V. K., &amp; Zavalij, P. Y. (2009). <em>Fundamentals of Powder Diffraction and Structural Characterization of Materials</em> (2nd ed.). Springer. - Practical textbook specialized in powder XRD</li>
<li>International Tables for Crystallography, Volume A: Space-Group Symmetry (2016). International Union of Crystallography. - Definitive reference for space groups and systematic absences</li>
<li>Giacovazzo, C., et al. (2011). <em>Fundamentals of Crystallography</em> (3rd ed.). Oxford University Press. - Theoretical foundations of crystallography, clear explanation of reciprocal lattice concepts</li>
<li>Hammond, C. (2015). <em>The Basics of Crystallography and Diffraction</em> (4th ed.). Oxford University Press. - Textbook with excellent visual understanding of Ewald sphere construction</li>
<li>Ladd, M., &amp; Palmer, R. (2013). <em>Structure Determination by X-ray Crystallography</em> (5th ed.). Springer. - Practical guide from structure factor calculation to crystal structure determination</li>
</ol>
<h2>Next Steps</h2>
<p>In Chapter 1, we learned the theoretical foundations of X-ray diffraction. Concepts such as Bragg's law, reciprocal lattice, systematic absences, and structure factors form the basis of all XRD analysis.</p>
<p><strong>Chapter 2</strong> will apply these theories to actual XRD measurements. We will learn practical analysis techniques such as powder X-ray diffraction data acquisition, peak identification, background removal, and peak fitting.</p>
<div class="navigation">
<a class="nav-button" href="./index.html">ÔøΩ Series Index</a>
<a class="nav-button" href="chapter-2.html">Chapter 2: Powder XRD Measurement and Analysis ‚Äô</a>
</div>
<section class="disclaimer">
<h3>Disclaimer</h3>
<ul>
<li>This content is provided solely for educational, research, and informational purposes and does not constitute professional advice (legal, accounting, technical warranty, etc.).</li>
<li>This content and accompanying code examples are provided "AS IS" without any warranty, express or implied, including but not limited to merchantability, fitness for a particular purpose, non-infringement, accuracy, completeness, operation, or safety.</li>
<li>The author and Tohoku University assume no responsibility for the content, availability, or safety of external links, third-party data, tools, libraries, etc.</li>
<li>To the maximum extent permitted by applicable law, the author and Tohoku University shall not be liable for any direct, indirect, incidental, special, consequential, or punitive damages arising from the use, execution, or interpretation of this content.</li>
<li>The content may be changed, updated, or discontinued without notice.</li>
<li>The copyright and license of this content are subject to the stated conditions (e.g., CC BY 4.0). Such licenses typically include no-warranty clauses.</li>
</ul>
</section>

</main>
<footer>
<p>¬© 2025 MS Terakoya - Materials Science Learning Platform</p>
<p><a href="../index.html">Return to Top Page</a></p>
</footer>
</body>
</html>
