---
title: "Chapter 1: Polymer Fundamentals"
chapter_title: "Chapter 1: Polymer Fundamentals"
---

[AI Learning Hub](<../index.html>):[Materials Science](<../../index.html>):[Polymer Materials](<../../MS/polymer-materials-introduction/index.html>):Chapter 1

üåê EN | [üáØüáµ JP](<../../../jp/MS/polymer-materials-introduction/chapter-1.html>) | Last sync: 2025-11-16

  * [Home](<index.html>)
  * [Overview](<#intro>)
  * [Polymerization](<#polymerization>)
  * [Molecular Weight](<#molecular-weight>)
  * [Molecular Weight Distribution](<#distribution>)
  * [Flory-Schulz Distribution](<#flory>)
  * [Exercises](<#exercises>)
  * [References](<#references>)
  * [Next Chapter ‚Äô](<chapter-2.html>)

This chapter covers the fundamentals of Polymer Fundamentals, which overview of polymer materials. You will learn ¬° Can explain differences between addition, ¬° Can state definitions of number-average, and ¬° Can explain meaning of PDI.

## 1.1 Overview of Polymer Materials

**Polymers** are macromolecules formed by the repeated bonding of small molecules (monomers). They typically have molecular weights above 10,000 and exhibit unique properties not found in small molecules, such as viscoelasticity, glass transition, and crystallization. In this chapter, we will learn about the conversion process from monomers to polymers (polymerization reactions) and the molecular weight distribution of the resulting polymers. 

**Learning Objectives for This Chapter**

  * **Level 1 (Basic Understanding)** : Explain the differences between addition polymerization, condensation polymerization, and ring-opening polymerization, and understand representative polymer synthesis routes
  * **Level 2 (Practical Skills)** : Calculate number-average and weight-average molecular weights, and determine PDI from GPC data
  * **Level 3 (Applied Skills)** : Predict molecular weight distribution using the Flory-Schulz distribution and discuss optimization of polymerization conditions

### Classification of Polymers

Polymers are classified according to their synthesis methods as follows:

  1. **Addition Polymerization** : Monomers with double bonds join in a chain reaction (e.g., polyethylene, polystyrene)
  2. **Condensation Polymerization** : Functional groups react while releasing small molecules (e.g., nylon, polyester)
  3. **Ring-Opening Polymerization** : Cyclic monomers open and join (e.g., polyethylene oxide, nylon 6)

    
    
    ```mermaid
    flowchart TD
        A[Polymerization Reactions] --> B[Addition Polymerization]
        A --> C[Condensation Polymerization]
        A --> D[Ring-Opening Polymerization]
        B --> E[Radical PolymerizationPolyethylenePolystyrene]
        B --> F[Ionic PolymerizationPolyisobutylenePolymethyl methacrylate]
        C --> G[Step-GrowthNylonPolyester]
        D --> H[Cationic Ring-OpeningPolyethylene oxidePolytetrahydrofuran]
    
        style A fill:#f093fb,color:#fff
        style B fill:#f5a3c7
        style C fill:#f5b3a7
        style D fill:#f5c397
        style E fill:#fff3e0
        style F fill:#fff3e0
        style G fill:#e3f2fd
        style H fill:#e8f5e9
    ```

## 1.2 Addition Polymerization

### 1.2.1 Mechanism of Radical Polymerization

**Radical polymerization** is the most common type of addition polymerization. Radicals generated by decomposition of initiators (peroxides, azo compounds) add to the double bonds of monomers and undergo chain growth. The reaction proceeds in the following three stages: 

  1. **Initiation** : Decomposition of initiator and addition to monomer \\[ \text{I} \rightarrow 2\text{R}^{\bullet} \quad (\text{Initiator decomposition}) \\] \\[ \text{R}^{\bullet} + \text{M} \rightarrow \text{RM}^{\bullet} \quad (\text{Monomer addition}) \\] 
  2. **Propagation** : Continuous addition of monomers to radical ends \\[ \text{RM}_n^{\bullet} + \text{M} \rightarrow \text{RM}_{n+1}^{\bullet} \\] 
  3. **Termination** : Combination or disproportionation of radicals \\[ \text{RM}_n^{\bullet} + \text{RM}_m^{\bullet} \rightarrow \text{RM}_{n+m}\text{R} \quad (\text{Combination}) \\] \\[ \text{RM}_n^{\bullet} + \text{RM}_m^{\bullet} \rightarrow \text{RM}_n + \text{RM}_m \quad (\text{Disproportionation}) \\] 

#### Python Implementation: Radical Polymerization Simulation
    
    
    # Requirements:
    # - Python 3.9+
    # - matplotlib>=3.7.0
    # - numpy>=1.24.0, <2.0.0
    
    # ===================================
    # Example 1: Kinetic Simulation of Radical Polymerization
    # ===================================
    
    import numpy as np
    import matplotlib.pyplot as plt
    from scipy.integrate import odeint
    
    def radical_polymerization_kinetics(y, t, ki, kp, kt, f, I0, M0):
        """
        Kinetic model of radical polymerization
    
        Parameters:
        -----------
        y : list
            Concentrations of [I, M, P*] [mol/L]
        t : float
            Time [s]
        ki : float
            Initiation rate constant [1/s]
        kp : float
            Propagation rate constant [L/mol/s]
        kt : float
            Termination rate constant [L/mol/s]
        f : float
            Initiator efficiency (0-1)
        I0 : float
            Initial initiator concentration [mol/L]
        M0 : float
            Initial monomer concentration [mol/L]
    
        Returns:
        --------
        dydt : list
            Time derivatives of concentrations
        """
        I, M, P_star = y
    
        # Initiation rate
        Ri = 2 * f * ki * I
    
        # Concentration change rates
        dI_dt = -ki * I
        dM_dt = -kp * M * P_star
        dP_star_dt = Ri - kt * P_star**2
    
        return [dI_dt, dM_dt, dP_star_dt]
    
    # Reaction condition settings
    ki = 1e-5  # Initiation rate constant [1/s]
    kp = 100   # Propagation rate constant [L/mol/s]
    kt = 1e7   # Termination rate constant [L/mol/s]
    f = 0.6    # Initiator efficiency
    I0 = 0.01  # Initial initiator concentration [mol/L]
    M0 = 8.0   # Initial monomer concentration [mol/L]
    
    # Initial conditions
    y0 = [I0, M0, 0]
    
    # Time settings
    t = np.linspace(0, 10000, 1000)  # 0-10000 seconds
    
    # Numerical solution
    solution = odeint(radical_polymerization_kinetics, y0, t,
                      args=(ki, kp, kt, f, I0, M0))
    
    I, M, P_star = solution.T
    
    # Calculate monomer conversion
    conversion = (1 - M / M0) * 100
    
    # Radical concentration at steady state (theoretical)
    P_star_steady = np.sqrt(2 * f * ki * I0 / kt)
    
    print("=== Radical Polymerization Simulation ===")
    print(f"Initiator efficiency: {f}")
    print(f"Initial monomer concentration: {M0} mol/L")
    print(f"Steady state radical concentration (theoretical): {P_star_steady:.2e} mol/L")
    print(f"\nResults at time 1000 seconds:")
    print(f"  Monomer concentration: {M[100]:.3f} mol/L")
    print(f"  Conversion: {conversion[100]:.1f}%")
    print(f"  Radical concentration: {P_star[100]:.2e} mol/L")
    
    # Plotting
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 5))
    
    # Concentration changes
    ax1.plot(t, M, 'b-', label='Monomer [M]', linewidth=2)
    ax1.plot(t, I, 'r-', label='Initiator [I]', linewidth=2)
    ax1.plot(t, P_star*1000, 'g-', label='Radical [P*] √ó 1000', linewidth=2)
    ax1.set_xlabel('Time (s)', fontsize=12)
    ax1.set_ylabel('Concentration (mol/L)', fontsize=12)
    ax1.set_title('Radical Polymerization Kinetics', fontsize=14, fontweight='bold')
    ax1.legend(fontsize=11)
    ax1.grid(True, alpha=0.3)
    
    # Conversion
    ax2.plot(t, conversion, 'b-', linewidth=2)
    ax2.set_xlabel('Time (s)', fontsize=12)
    ax2.set_ylabel('Conversion (%)', fontsize=12)
    ax2.set_title('Monomer Conversion vs Time', fontsize=14, fontweight='bold')
    ax2.grid(True, alpha=0.3)
    
    plt.tight_layout()
    plt.savefig('radical_polymerization_kinetics.png', dpi=300)
    print("\nPlot saved to 'radical_polymerization_kinetics.png'")
    
    # Expected output:
    # === Radical Polymerization Simulation ===
    # Initiator efficiency: 0.6
    # Initial monomer concentration: 8.0 mol/L
    # Steady state radical concentration (theoretical): 1.10e-06 mol/L
    #
    # Results at time 1000 seconds:
    #   Monomer concentration: 7.912 mol/L
    #   Conversion: 1.1%
    #   Radical concentration: 1.09e-06 mol/L
    #
    # Plot saved to 'radical_polymerization_kinetics.png'
    

### 1.2.2 Polymerization Rate and Kinetic Chain Length

Applying the steady-state approximation (radical generation rate = radical termination rate), the polymerization rate \\(R_p\\) can be expressed as: 

\\[ R_p = k_p [\text{M}] \sqrt{\frac{2fk_i[\text{I}]}{k_t}} \\] 

where \\([\text{M}]\\) is the monomer concentration and \\([\text{I}]\\) is the initiator concentration. The polymerization rate is proportional to the monomer concentration and to the square root of the initiator concentration. 

**Kinetic chain length (¬Ω)** is the average number of monomers added by one radical: 

\\[ \nu = \frac{R_p}{R_i} = \frac{k_p [\text{M}]}{\sqrt{2fk_ik_t[\text{I}]}} \\] 

The larger the kinetic chain length, the higher the molecular weight of the resulting polymer. 

#### Python Implementation: Calculation of Kinetic Chain Length
    
    
    # ===================================
    # Example 2: Calculation of Kinetic Chain Length and Number-Average Degree of Polymerization
    # ===================================
    
    def calculate_kinetic_chain_length(kp, kt, ki, f, M_conc, I_conc):
        """
        Function to calculate kinetic chain length
    
        Parameters:
        -----------
        kp : float
            Propagation rate constant [L/mol/s]
        kt : float
            Termination rate constant [L/mol/s]
        ki : float
            Initiation rate constant [1/s]
        f : float
            Initiator efficiency
        M_conc : float
            Monomer concentration [mol/L]
        I_conc : float
            Initiator concentration [mol/L]
    
        Returns:
        --------
        nu : float
            Kinetic chain length
        """
        nu = (kp * M_conc) / np.sqrt(2 * f * ki * kt * I_conc)
        return nu
    
    def degree_of_polymerization(nu, termination_mode='combination'):
        """
        Function to calculate number-average degree of polymerization
    
        Parameters:
        -----------
        nu : float
            Kinetic chain length
        termination_mode : str
            Termination mode ('combination' or 'disproportionation')
    
        Returns:
        --------
        DPn : float
            Number-average degree of polymerization
        """
        if termination_mode == 'combination':
            DPn = 2 * nu  # Combination: two radicals combine
        else:
            DPn = nu      # Disproportionation: each radical forms one molecule
        return DPn
    
    # Condition settings
    kp = 100
    kt = 1e7
    ki = 1e-5
    f = 0.6
    M_conc = 8.0
    I_conc_list = np.array([0.001, 0.005, 0.01, 0.05, 0.1])  # Varying initiator concentration
    
    print("=== Calculation of Kinetic Chain Length and Degree of Polymerization ===\n")
    print(f"{'[I] (mol/L)':<15} {'¬Ω':<15} {'DPn (Comb.)':<15} {'DPn (Disp.)':<15}")
    print("-" * 60)
    
    for I_conc in I_conc_list:
        nu = calculate_kinetic_chain_length(kp, kt, ki, f, M_conc, I_conc)
        DPn_comb = degree_of_polymerization(nu, 'combination')
        DPn_disp = degree_of_polymerization(nu, 'disproportionation')
        print(f"{I_conc:<15.3f} {nu:<15.1f} {DPn_comb:<15.1f} {DPn_disp:<15.1f}")
    
    # Plot initiator concentration dependence
    I_conc_range = np.logspace(-3, -0.5, 50)
    nu_range = [calculate_kinetic_chain_length(kp, kt, ki, f, M_conc, I) for I in I_conc_range]
    DPn_comb_range = [degree_of_polymerization(nu, 'combination') for nu in nu_range]
    
    plt.figure(figsize=(10, 6))
    plt.plot(I_conc_range, DPn_comb_range, 'b-', linewidth=2, label='Combination termination')
    plt.plot(I_conc_range, nu_range, 'r--', linewidth=2, label='Kinetic chain length (¬Ω)')
    plt.xscale('log')
    plt.yscale('log')
    plt.xlabel('[Initiator] (mol/L)', fontsize=12)
    plt.ylabel('DPn or ¬Ω', fontsize=12)
    plt.title('Effect of Initiator Concentration on Polymerization', fontsize=14, fontweight='bold')
    plt.legend(fontsize=11)
    plt.grid(True, which='both', alpha=0.3)
    plt.tight_layout()
    plt.savefig('kinetic_chain_length.png', dpi=300)
    print("\nPlot saved to 'kinetic_chain_length.png'")
    
    # Expected output:
    # === Calculation of Kinetic Chain Length and Degree of Polymerization ===
    #
    # [I] (mol/L)     ¬Ω               DPn (Comb.)     DPn (Disp.)
    # ------------------------------------------------------------
    # 0.001           2324.1          4648.3          2324.1
    # 0.005           1040.2          2080.4          1040.2
    # 0.010           735.4           1470.8          735.4
    # 0.050           329.1           658.2           329.1
    # 0.100           232.4           464.9           232.4
    #
    # Plot saved to 'kinetic_chain_length.png'
    

## 1.3 Condensation Polymerization

### 1.3.1 Mechanism of Step-Growth Polymerization

**Condensation polymerization** is a polymerization where monomers with two or more types of functional groups react, releasing small molecules (water, HCl, methanol, etc.) as by-products. Unlike addition polymerization, it proceeds as a **step-growth reaction**. 

Representative condensation polymerizations:

  * **Nylon 6,6** : Hexamethylene diamine + adipic acid ‚Äô polyamide + water
  * **Polyethylene terephthalate (PET)** : Ethylene glycol + terephthalic acid ‚Äô polyester + water
  * **Polycarbonate** : Bisphenol A + phosgene ‚Äô polycarbonate + HCl

#### Carothers Equation

In condensation polymerization, the number-average degree of polymerization \\(\overline{DP_n}\\) is determined by the functional group conversion \\(p\\) (**Carothers equation**): 

\\[ \overline{DP_n} = \frac{1}{1 - p} \\] 

where \\(p\\) is the functional group conversion (0 d p < 1). For example, if \\(p = 0.99\\), then \\(\overline{DP_n} = 100\\). Very high conversion (p > 0.99) is required to obtain high molecular weight. 

#### Python Implementation: Degree of Polymerization Calculation Using Carothers Equation
    
    
    # ===================================
    # Example 3: Degree of Polymerization Simulation in Condensation Polymerization
    # ===================================
    
    def carothers_equation(p):
        """
        Calculate number-average degree of polymerization using Carothers equation
    
        Parameters:
        -----------
        p : float or array
            Functional group conversion (0 <= p < 1)
    
        Returns:
        --------
        DPn : float or array
            Number-average degree of polymerization
        """
        return 1 / (1 - p)
    
    def molecular_weight_distribution_stepgrowth(p, max_n=20):
        """
        Calculate molecular weight distribution in condensation polymerization (most probable distribution)
    
        Parameters:
        -----------
        p : float
            Functional group conversion
        max_n : int
            Maximum degree of polymerization to calculate
    
        Returns:
        --------
        n_values : array
            Degree of polymerization
        N_n : array
            Mole fraction
        """
        n_values = np.arange(1, max_n + 1)
        # Most probable distribution: N_n = n * p^(n-1) * (1-p)^2
        N_n = n_values * (p ** (n_values - 1)) * ((1 - p) ** 2)
        return n_values, N_n
    
    # Relationship between conversion and degree of polymerization
    p_values = np.linspace(0.5, 0.999, 100)
    DPn_values = carothers_equation(p_values)
    
    print("=== Degree of Polymerization Calculation Using Carothers Equation ===\n")
    print(f"{'Conversion p':<15} {'Number-Average DPn':<20}")
    print("-" * 35)
    for p in [0.90, 0.95, 0.98, 0.99, 0.995, 0.999]:
        DPn = carothers_equation(p)
        print(f"{p:<15.3f} {DPn:<20.1f}")
    
    # Plot 1: Conversion vs Degree of Polymerization
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 5))
    
    ax1.plot(p_values, DPn_values, 'b-', linewidth=2)
    ax1.axhline(y=100, color='r', linestyle='--', label='DPn = 100', linewidth=1.5)
    ax1.axvline(x=0.99, color='r', linestyle='--', label='p = 0.99', linewidth=1.5)
    ax1.set_xlabel('Conversion (p)', fontsize=12)
    ax1.set_ylabel('Number-Average Degree of Polymerization (DPn)', fontsize=12)
    ax1.set_title("Carothers' Equation", fontsize=14, fontweight='bold')
    ax1.set_ylim(0, 500)
    ax1.legend(fontsize=11)
    ax1.grid(True, alpha=0.3)
    
    # Plot 2: Molecular weight distribution (different conversions)
    for p in [0.90, 0.95, 0.98]:
        n_vals, N_n = molecular_weight_distribution_stepgrowth(p, max_n=30)
        ax2.plot(n_vals, N_n, marker='o', linewidth=2, label=f'p = {p}')
    
    ax2.set_xlabel('Degree of Polymerization (n)', fontsize=12)
    ax2.set_ylabel('Mole Fraction (Nn)', fontsize=12)
    ax2.set_title('Molecular Weight Distribution (Most Probable)', fontsize=14, fontweight='bold')
    ax2.legend(fontsize=11)
    ax2.grid(True, alpha=0.3)
    
    plt.tight_layout()
    plt.savefig('carothers_equation_stepgrowth.png', dpi=300)
    print("\nPlot saved to 'carothers_equation_stepgrowth.png'")
    
    # Expected output:
    # === Degree of Polymerization Calculation Using Carothers Equation ===
    #
    # Conversion p        Number-Average DPn
    # -----------------------------------
    # 0.900           10.0
    # 0.950           20.0
    # 0.980           50.0
    # 0.990           100.0
    # 0.995           200.0
    # 0.999           1000.0
    #
    # Plot saved to 'carothers_equation_stepgrowth.png'
    

### 1.3.2 Ring-Opening Polymerization

**Ring-opening polymerization (ROP)** is a reaction in which cyclic monomers open to form linear polymers. The driving force for polymerization is the ring strain energy. 

Representative examples:

  * **¬µ-Caprolactam** ‚Äô **Nylon 6** (cationic ring-opening polymerization)
  * **Ethylene oxide** ‚Äô **Polyethylene glycol (PEG)** (anionic ring-opening polymerization)
  * **L-Lactide** ‚Äô **Polylactic acid (PLA)** (coordination ring-opening polymerization)

Ring-opening polymerization does not produce by-products, so high molecular weight is easily achieved as in addition polymerization. It is widely used for synthesizing biocompatible polymers (PEG, PLA). 

## 1.4 Molecular Weight and Molecular Weight Distribution

### 1.4.1 Number-Average and Weight-Average Molecular Weight

Since polymers have a molecular weight distribution, multiple average molecular weights are defined. The most important are the **number-average molecular weight (M‚Ñ¢)** and the **weight-average molecular weight (Mw)**. 

**Number-average molecular weight (M‚Ñ¢)** : 

\\[ M_n = \frac{\sum N_i M_i}{\sum N_i} \\] 

where \\(N_i\\) is the number of molecules with molecular weight \\(M_i\\). M‚Ñ¢ is an average based on the number of molecules. 

**Weight-average molecular weight (Mw)** : 

\\[ M_w = \frac{\sum N_i M_i^2}{\sum N_i M_i} = \frac{\sum w_i M_i}{\sum w_i} \\] 

where \\(w_i = N_i M_i\\) is the weight fraction. Mw is an average based on weight, with larger molecules contributing more. 

**Polydispersity index (PDI)** : 

\\[ \text{PDI} = \frac{M_w}{M_n} \geq 1 \\] 

PDI = 1 indicates a perfectly uniform molecular weight distribution, while PDI > 2 indicates a broad distribution. Living polymerization yields narrow distributions with PDI H 1.0-1.1. 

#### Python Implementation: Calculation of M‚Ñ¢, Mw, and PDI from Molecular Weight Distribution
    
    
    # ===================================
    # Example 4: Molecular Weight Analysis from GPC Data
    # ===================================
    
    def calculate_molecular_weight_averages(M_values, N_values):
        """
        Function to calculate Mn, Mw, and PDI from molecular weight distribution
    
        Parameters:
        -----------
        M_values : array
            Molecular weight of each fraction [g/mol]
        N_values : array
            Number of molecules in each fraction (or detector response)
    
        Returns:
        --------
        Mn : float
            Number-average molecular weight
        Mw : float
            Weight-average molecular weight
        PDI : float
            Polydispersity index
        """
        # Number-average molecular weight
        Mn = np.sum(N_values * M_values) / np.sum(N_values)
    
        # Weight-average molecular weight
        Mw = np.sum(N_values * M_values**2) / np.sum(N_values * M_values)
    
        # Polydispersity index
        PDI = Mw / Mn
    
        return Mn, Mw, PDI
    
    # Sample data (simulating GPC chromatogram)
    # In actual GPC, molecular weight is converted from retention time
    np.random.seed(42)
    
    # Molecular weight range (lognormal distribution)
    log_M_mean = 5.0  # log10(100,000)
    log_M_std = 0.3
    M_values = np.logspace(4, 6, 100)
    log_M = np.log10(M_values)
    
    # Number distribution (lognormal distribution)
    N_values = np.exp(-0.5 * ((log_M - log_M_mean) / log_M_std)**2)
    N_values = N_values / np.max(N_values) * 100  # Normalization
    
    # Molecular weight analysis
    Mn, Mw, PDI = calculate_molecular_weight_averages(M_values, N_values)
    
    print("=== GPC Molecular Weight Analysis ===")
    print(f"Number-average molecular weight (Mn): {Mn:,.0f} g/mol")
    print(f"Weight-average molecular weight (Mw): {Mw:,.0f} g/mol")
    print(f"Polydispersity index (PDI): {PDI:.3f}")
    
    # Calculate weight fractions
    w_values = N_values * M_values
    w_values = w_values / np.sum(w_values)
    
    # Plotting
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 5))
    
    # Number and weight distributions
    ax1.plot(M_values, N_values, 'b-', linewidth=2, label='Number Distribution')
    ax1_twin = ax1.twinx()
    ax1_twin.plot(M_values, w_values, 'r-', linewidth=2, label='Weight Distribution')
    ax1.axvline(x=Mn, color='b', linestyle='--', label=f'Mn = {Mn:,.0f}', linewidth=1.5)
    ax1_twin.axvline(x=Mw, color='r', linestyle='--', label=f'Mw = {Mw:,.0f}', linewidth=1.5)
    ax1.set_xscale('log')
    ax1.set_xlabel('Molecular Weight (g/mol)', fontsize=12)
    ax1.set_ylabel('Number Fraction', fontsize=12, color='b')
    ax1_twin.set_ylabel('Weight Fraction', fontsize=12, color='r')
    ax1.set_title('GPC Chromatogram Analysis', fontsize=14, fontweight='bold')
    ax1.tick_params(axis='y', labelcolor='b')
    ax1_twin.tick_params(axis='y', labelcolor='r')
    ax1.legend(loc='upper left', fontsize=10)
    ax1_twin.legend(loc='upper right', fontsize=10)
    ax1.grid(True, alpha=0.3)
    
    # Cumulative distribution
    cumulative_number = np.cumsum(N_values) / np.sum(N_values)
    cumulative_weight = np.cumsum(w_values)
    
    ax2.plot(M_values, cumulative_number, 'b-', linewidth=2, label='Cumulative Number')
    ax2.plot(M_values, cumulative_weight, 'r-', linewidth=2, label='Cumulative Weight')
    ax2.set_xscale('log')
    ax2.set_xlabel('Molecular Weight (g/mol)', fontsize=12)
    ax2.set_ylabel('Cumulative Fraction', fontsize=12)
    ax2.set_title('Cumulative Distribution', fontsize=14, fontweight='bold')
    ax2.legend(fontsize=11)
    ax2.grid(True, alpha=0.3)
    
    plt.tight_layout()
    plt.savefig('gpc_molecular_weight_analysis.png', dpi=300)
    print("\nPlot saved to 'gpc_molecular_weight_analysis.png'")
    
    # Expected output:
    # === GPC Molecular Weight Analysis ===
    # Number-average molecular weight (Mn): 91,201 g/mol
    # Weight-average molecular weight (Mw): 106,103 g/mol
    # Polydispersity index (PDI): 1.163
    #
    # Plot saved to 'gpc_molecular_weight_analysis.png'
    

## 1.5 Flory-Schulz Distribution

### 1.5.1 Most Probable Distribution

In condensation polymerization (step-growth polymerization), the molecular weight distribution follows the **Flory-Schulz distribution** (most probable distribution). This is a statistical distribution based on the assumption that functional groups react indiscriminately. 

The mole fraction \\(N_n\\) of molecules with degree of polymerization \\(n\\) is expressed using the functional group conversion \\(p\\) as: 

\\[ N_n = n p^{n-1} (1 - p)^2 \\] 

From this distribution, the following averages are derived: 

  * Number-average degree of polymerization: \\(\overline{DP_n} = \dfrac{1}{1 - p}\\)
  * Weight-average degree of polymerization: \\(\overline{DP_w} = \dfrac{1 + p}{1 - p}\\)
  * Polydispersity index: \\(\text{PDI} = \dfrac{\overline{DP_w}}{\overline{DP_n}} = 1 + p\\)

For example, when \\(p = 0.99\\), PDI = 1.99 H 2. In condensation polymerization, theoretically PDI e 2, resulting in a broad molecular weight distribution. 

#### Python Implementation: Simulation of Flory-Schulz Distribution
    
    
    # ===================================
    # Example 5: Calculation and Visualization of Flory-Schulz Distribution
    # ===================================
    
    def flory_schulz_distribution(n, p):
        """
        Calculate Flory-Schulz distribution (most probable distribution)
    
        Parameters:
        -----------
        n : int or array
            Degree of polymerization
        p : float
            Functional group conversion
    
        Returns:
        --------
        N_n : float or array
            Mole fraction
        w_n : float or array
            Weight fraction
        """
        N_n = n * (p ** (n - 1)) * ((1 - p) ** 2)
        w_n = n**2 * (p ** (n - 1)) * ((1 - p) ** 3)
        return N_n, w_n
    
    def flory_schulz_averages(p):
        """
        Calculate average values for Flory-Schulz distribution
    
        Parameters:
        -----------
        p : float
            Functional group conversion
    
        Returns:
        --------
        DPn : float
            Number-average degree of polymerization
        DPw : float
            Weight-average degree of polymerization
        PDI : float
            Polydispersity index
        """
        DPn = 1 / (1 - p)
        DPw = (1 + p) / (1 - p)
        PDI = 1 + p
        return DPn, DPw, PDI
    
    # Distribution calculation at different conversions
    p_values = [0.90, 0.95, 0.98]
    n_range = np.arange(1, 101)
    
    print("=== Flory-Schulz Distribution Analysis ===\n")
    print(f"{'Conversion p':<12} {'DPn':<12} {'DPw':<12} {'PDI':<12}")
    print("-" * 48)
    
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 5))
    
    for p in p_values:
        DPn, DPw, PDI = flory_schulz_averages(p)
        print(f"{p:<12.2f} {DPn:<12.2f} {DPw:<12.2f} {PDI:<12.3f}")
    
        N_n, w_n = flory_schulz_distribution(n_range, p)
    
        # Number distribution plot
        ax1.plot(n_range, N_n, marker='o', markersize=3, linewidth=1.5, label=f'p = {p}')
    
        # Weight distribution plot
        ax2.plot(n_range, w_n, marker='o', markersize=3, linewidth=1.5, label=f'p = {p}')
    
    ax1.set_xlabel('Degree of Polymerization (n)', fontsize=12)
    ax1.set_ylabel('Number Fraction (Nn)', fontsize=12)
    ax1.set_title('Flory-Schulz Distribution (Number)', fontsize=14, fontweight='bold')
    ax1.legend(fontsize=11)
    ax1.grid(True, alpha=0.3)
    ax1.set_xlim(0, 100)
    
    ax2.set_xlabel('Degree of Polymerization (n)', fontsize=12)
    ax2.set_ylabel('Weight Fraction (wn)', fontsize=12)
    ax2.set_title('Flory-Schulz Distribution (Weight)', fontsize=14, fontweight='bold')
    ax2.legend(fontsize=11)
    ax2.grid(True, alpha=0.3)
    ax2.set_xlim(0, 100)
    
    plt.tight_layout()
    plt.savefig('flory_schulz_distribution.png', dpi=300)
    print("\nPlot saved to 'flory_schulz_distribution.png'")
    
    # Expected output:
    # === Flory-Schulz Distribution Analysis ===
    #
    # Conversion p    DPn         DPw         PDI
    # ------------------------------------------------
    # 0.90        10.00       19.00       1.900
    # 0.95        20.00       39.00       1.950
    # 0.98        50.00       99.00       1.980
    #
    # Plot saved to 'flory_schulz_distribution.png'
    

### 1.5.2 Poisson Distribution and Living Polymerization

In **living polymerization** , there are no termination or chain transfer reactions, and all polymer chains grow simultaneously. In this case, the molecular weight distribution follows a **Poisson distribution** , yielding a very narrow distribution (PDI H 1). 

The mole fraction for degree of polymerization \\(n\\) is expressed as: 

\\[ N_n = \frac{(\overline{DP_n})^n e^{-\overline{DP_n}}}{n!} \\] 

The polydispersity index of the Poisson distribution approaches 1 as \\(\overline{DP_n}\\) increases: 

\\[ \text{PDI} = 1 + \frac{1}{\overline{DP_n}} \\] 

For example, when \\(\overline{DP_n} = 100\\), PDI = 1.01, which is very uniform. 

#### Python Implementation: Poisson Distribution Simulation
    
    
    # ===================================
    # Example 6: Comparison of Poisson and Flory-Schulz Distributions
    # ===================================
    
    from scipy.stats import poisson
    
    def poisson_distribution_polymer(n, DPn_avg):
        """
        Calculate molecular weight distribution using Poisson distribution
    
        Parameters:
        -----------
        n : int or array
            Degree of polymerization
        DPn_avg : float
            Number-average degree of polymerization
    
        Returns:
        --------
        N_n : float or array
            Mole fraction
        """
        N_n = poisson.pmf(n, DPn_avg)
        return N_n
    
    # Living polymerization (Poisson) vs condensation polymerization (Flory-Schulz)
    DPn_avg = 50
    p_for_DPn50 = 1 - 1/DPn_avg  # 0.98
    
    n_range = np.arange(1, 151)
    
    N_n_poisson = poisson_distribution_polymer(n_range, DPn_avg)
    N_n_flory, w_n_flory = flory_schulz_distribution(n_range, p_for_DPn50)
    
    # PDI calculation
    PDI_poisson = 1 + 1 / DPn_avg
    PDI_flory = 1 + p_for_DPn50
    
    print("=== Poisson Distribution vs Flory-Schulz Distribution ===\n")
    print(f"Target number-average degree of polymerization: {DPn_avg}")
    print(f"\nPoisson distribution (living polymerization):")
    print(f"  PDI = {PDI_poisson:.4f}")
    print(f"\nFlory-Schulz distribution (condensation polymerization):")
    print(f"  Conversion p = {p_for_DPn50:.4f}")
    print(f"  PDI = {PDI_flory:.4f}")
    
    # Plotting
    plt.figure(figsize=(10, 6))
    plt.plot(n_range, N_n_poisson, 'b-', linewidth=2, label=f'Poisson (Living, PDI={PDI_poisson:.3f})')
    plt.plot(n_range, N_n_flory, 'r--', linewidth=2, label=f'Flory-Schulz (Step-Growth, PDI={PDI_flory:.3f})')
    plt.axvline(x=DPn_avg, color='k', linestyle=':', linewidth=1.5, label=f'DPn = {DPn_avg}')
    plt.xlabel('Degree of Polymerization (n)', fontsize=12)
    plt.ylabel('Mole Fraction (Nn)', fontsize=12)
    plt.title('Comparison: Poisson vs Flory-Schulz Distribution', fontsize=14, fontweight='bold')
    plt.legend(fontsize=11)
    plt.grid(True, alpha=0.3)
    plt.xlim(0, 150)
    plt.tight_layout()
    plt.savefig('poisson_vs_flory_schulz.png', dpi=300)
    print("\nPlot saved to 'poisson_vs_flory_schulz.png'")
    
    # Expected output:
    # === Poisson Distribution vs Flory-Schulz Distribution ===
    #
    # Target number-average degree of polymerization: 50
    #
    # Poisson distribution (living polymerization):
    #   PDI = 1.0200
    #
    # Flory-Schulz distribution (condensation polymerization):
    #   Conversion p = 0.9800
    #   PDI = 1.9800
    #
    # Plot saved to 'poisson_vs_flory_schulz.png'
    

## 1.6 Advanced Polymerization Control

### 1.6.1 Reversible Addition-Fragmentation Chain Transfer Polymerization (RAFT)

**RAFT polymerization (Reversible Addition-Fragmentation chain Transfer polymerization)** is a type of living polymerization that enables narrow molecular weight distributions (PDI < 1.2) and high molecular weight control. It uses chain transfer agents (RAFT agents) to create conditions where all polymer chains grow similarly. 

The general structure of RAFT agents is represented as Z-C(=S)-S-R, and by selecting the Z and R groups, various monomers can be accommodated. 

#### Python Implementation: Molecular Weight Control Simulation in RAFT Polymerization
    
    
    # ===================================
    # Example 7: Molecular Weight Control by RAFT Polymerization
    # ===================================
    
    def raft_polymerization_DPn(conversion, M0, RAFT0):
        """
        Calculate number-average degree of polymerization in RAFT polymerization
    
        Parameters:
        -----------
        conversion : float
            Monomer conversion (0-1)
        M0 : float
            Initial monomer concentration [mol/L]
        RAFT0 : float
            Initial RAFT agent concentration [mol/L]
    
        Returns:
        --------
        DPn : float
            Number-average degree of polymerization
        """
        DPn = (M0 / RAFT0) * conversion
        return DPn
    
    # Experimental design varying monomer/RAFT ratio
    M0 = 8.0  # Initial monomer concentration [mol/L]
    ratios = [50, 100, 200, 500]  # [M]0/[RAFT]0 ratios
    conversions = np.linspace(0, 1, 100)
    
    print("=== Molecular Weight Control by RAFT Polymerization ===\n")
    print("Target degree of polymerization: Controllable by [M]0/[RAFT]0 ratio\n")
    
    plt.figure(figsize=(10, 6))
    
    for ratio in ratios:
        RAFT0 = M0 / ratio
        DPn_values = [raft_polymerization_DPn(conv, M0, RAFT0) for conv in conversions]
        plt.plot(conversions * 100, DPn_values, linewidth=2, label=f'[M]0/[RAFT]0 = {ratio}')
    
    plt.xlabel('Conversion (%)', fontsize=12)
    plt.ylabel('Number-Average Degree of Polymerization (DPn)', fontsize=12)
    plt.title('RAFT Polymerization: Molecular Weight Control', fontsize=14, fontweight='bold')
    plt.legend(fontsize=11)
    plt.grid(True, alpha=0.3)
    plt.tight_layout()
    plt.savefig('raft_polymerization_control.png', dpi=300)
    print("Plot saved to 'raft_polymerization_control.png'\n")
    
    # Example: Design for target molecular weight Mn = 50,000
    target_Mn = 50000  # g/mol
    monomer_MW = 100   # Molecular weight of styrene
    target_DPn = target_Mn / monomer_MW
    conversion_expected = 0.90  # Expected conversion
    
    required_ratio = target_DPn / conversion_expected
    
    print(f"Design example for target molecular weight Mn = {target_Mn:,} g/mol:")
    print(f"  Monomer: Styrene (MW = {monomer_MW} g/mol)")
    print(f"  Target degree of polymerization DPn = {target_DPn:.0f}")
    print(f"  Expected conversion = {conversion_expected * 100:.0f}%")
    print(f"  Required [M]0/[RAFT]0 ratio = {required_ratio:.1f}")
    print(f"\nExperimental conditions:")
    print(f"  For [M]0 = {M0} mol/L")
    print(f"  [RAFT]0 = {M0 / required_ratio:.4f} mol/L")
    
    # Expected output:
    # === Molecular Weight Control by RAFT Polymerization ===
    #
    # Target degree of polymerization: Controllable by [M]0/[RAFT]0 ratio
    #
    # Plot saved to 'raft_polymerization_control.png'
    #
    # Design example for target molecular weight Mn = 50,000 g/mol:
    #   Monomer: Styrene (MW = 100 g/mol)
    #   Target degree of polymerization DPn = 500
    #   Expected conversion = 90%
    #   Required [M]0/[RAFT]0 ratio = 555.6
    #
    # Experimental conditions:
    #   For [M]0 = 8.0 mol/L
    #   [RAFT]0 = 0.0144 mol/L
    

### 1.6.2 Chain Transfer Reactions and Molecular Weight Reduction

In actual radical polymerization, unintentional **chain transfer reactions** occur, reducing molecular weight. Chain transfer can occur to monomer, solvent, polymer, or chain transfer agents. 

The chain transfer constant \\(C_{tr}\\) is the ratio of the chain transfer rate constant to the propagation rate constant: 

\\[ C_{tr} = \frac{k_{tr}}{k_p} \\] 

The number-average degree of polymerization decreases due to chain transfer as follows: 

\\[ \frac{1}{\overline{DP_n}} = \frac{1}{\overline{DP_n^0}} + C_{tr,M} + C_{tr,S} \frac{[S]}{[M]} + C_{tr,P} \\] 

where \\(\overline{DP_n^0}\\) is the degree of polymerization without chain transfer, and \\(C_{tr,M}\\), \\(C_{tr,S}\\), \\(C_{tr,P}\\) are the chain transfer constants to monomer, solvent, and polymer, respectively. 

#### Python Implementation: Molecular Weight Reduction by Chain Transfer
    
    
    # ===================================
    # Example 8: Molecular Weight Control by Chain Transfer
    # ===================================
    
    def DPn_with_chain_transfer(DPn0, Ctr_M, Ctr_S, S_M_ratio, Ctr_CTA, CTA_M_ratio):
        """
        Calculate number-average degree of polymerization considering chain transfer reactions
    
        Parameters:
        -----------
        DPn0 : float
            Degree of polymerization without chain transfer
        Ctr_M : float
            Chain transfer constant to monomer
        Ctr_S : float
            Chain transfer constant to solvent
        S_M_ratio : float
            [Solvent]/[Monomer] concentration ratio
        Ctr_CTA : float
            Chain transfer constant to chain transfer agent
        CTA_M_ratio : float
            [Chain transfer agent]/[Monomer] concentration ratio
    
        Returns:
        --------
        DPn : float
            Actual number-average degree of polymerization
        """
        inv_DPn = (1 / DPn0) + Ctr_M + Ctr_S * S_M_ratio + Ctr_CTA * CTA_M_ratio
        DPn = 1 / inv_DPn
        return DPn
    
    # Condition settings
    DPn0 = 1000  # Without chain transfer
    Ctr_M = 1e-4  # Monomer transfer constant (low)
    Ctr_S = 0.5   # Solvent transfer constant (moderate, e.g., CCl4)
    Ctr_CTA = 10  # Chain transfer agent (e.g., n-dodecyl mercaptan)
    
    # Effect of solvent concentration
    S_M_ratios = np.linspace(0, 2, 50)
    CTA_M_ratio = 0  # No chain transfer agent
    
    DPn_solvent = [DPn_with_chain_transfer(DPn0, Ctr_M, Ctr_S, ratio, Ctr_CTA, CTA_M_ratio)
                   for ratio in S_M_ratios]
    
    # Effect of chain transfer agent concentration
    CTA_M_ratios = np.linspace(0, 0.01, 50)
    S_M_ratio = 0  # No solvent
    
    DPn_CTA = [DPn_with_chain_transfer(DPn0, Ctr_M, Ctr_S, S_M_ratio, Ctr_CTA, ratio)
               for ratio in CTA_M_ratios]
    
    print("=== Molecular Weight Control by Chain Transfer ===\n")
    print(f"Degree of polymerization without chain transfer DPn0 = {DPn0}")
    print(f"\nEffect of solvent (Ctr,S = {Ctr_S}):")
    print(f"  For [S]/[M] = 0.5: DPn = {DPn_with_chain_transfer(DPn0, Ctr_M, Ctr_S, 0.5, Ctr_CTA, 0):.1f}")
    print(f"  For [S]/[M] = 1.0: DPn = {DPn_with_chain_transfer(DPn0, Ctr_M, Ctr_S, 1.0, Ctr_CTA, 0):.1f}")
    print(f"\nEffect of chain transfer agent (Ctr,CTA = {Ctr_CTA}):")
    print(f"  For [CTA]/[M] = 0.001: DPn = {DPn_with_chain_transfer(DPn0, Ctr_M, Ctr_S, 0, Ctr_CTA, 0.001):.1f}")
    print(f"  For [CTA]/[M] = 0.005: DPn = {DPn_with_chain_transfer(DPn0, Ctr_M, Ctr_S, 0, Ctr_CTA, 0.005):.1f}")
    
    # Plotting
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 5))
    
    # Effect of solvent concentration
    ax1.plot(S_M_ratios, DPn_solvent, 'b-', linewidth=2)
    ax1.axhline(y=DPn0, color='r', linestyle='--', label=f'DPn0 = {DPn0}', linewidth=1.5)
    ax1.set_xlabel('[Solvent]/[Monomer]', fontsize=12)
    ax1.set_ylabel('Number-Average Degree of Polymerization (DPn)', fontsize=12)
    ax1.set_title(f'Effect of Solvent (Ctr,S = {Ctr_S})', fontsize=14, fontweight='bold')
    ax1.legend(fontsize=11)
    ax1.grid(True, alpha=0.3)
    
    # Effect of chain transfer agent concentration
    ax2.plot(CTA_M_ratios * 1000, DPn_CTA, 'b-', linewidth=2)
    ax2.axhline(y=DPn0, color='r', linestyle='--', label=f'DPn0 = {DPn0}', linewidth=1.5)
    ax2.set_xlabel('[Chain Transfer Agent]/[Monomer] √ó 1000', fontsize=12)
    ax2.set_ylabel('Number-Average Degree of Polymerization (DPn)', fontsize=12)
    ax2.set_title(f'Effect of Chain Transfer Agent (Ctr,CTA = {Ctr_CTA})', fontsize=14, fontweight='bold')
    ax2.legend(fontsize=11)
    ax2.grid(True, alpha=0.3)
    
    plt.tight_layout()
    plt.savefig('chain_transfer_effect.png', dpi=300)
    print("\nPlot saved to 'chain_transfer_effect.png'")
    
    # Expected output:
    # === Molecular Weight Control by Chain Transfer ===
    #
    # Degree of polymerization without chain transfer DPn0 = 1000
    #
    # Effect of solvent (Ctr,S = 0.5):
    #   For [S]/[M] = 0.5: DPn = 800.0
    #   For [S]/[M] = 1.0: DPn = 666.7
    #
    # Effect of chain transfer agent (Ctr,CTA = 10):
    #   For [CTA]/[M] = 0.001: DPn = 90.9
    #   For [CTA]/[M] = 0.005: DPn = 19.6
    #
    # Plot saved to 'chain_transfer_effect.png'
    

**Industrial Application of Chain Transfer** While chain transfer reduces molecular weight, intentional addition of chain transfer agents (mercaptans, halogenated carbons) enables molecular weight control. This allows synthesis of polymers with desired viscosity and processability. 

## Exercises

### Easy (Basic Review)

#### Q1: Classification of Polymerization Reactions Easy

Classify the following polymerization reactions as addition polymerization, condensation polymerization, or ring-opening polymerization:  
a) Ethylene ‚Äô Polyethylene  
b) ¬µ-Caprolactam ‚Äô Nylon 6  
c) Ethylene glycol + Terephthalic acid ‚Äô PET 

View Answer

**Correct Answer:**

  * **a) Addition polymerization** : Double bond of ethylene cleaves, polymerization without by-products
  * **b) Ring-opening polymerization** : Cyclic monomer (lactam) opens to generate linear polymer
  * **c) Condensation polymerization** : Releases water as by-product through functional group reaction

**Explanation:** Addition polymerization has no by-products, condensation polymerization releases small molecules, and ring-opening polymerization involves ring cleavage.

#### Q2: Carothers Equation Easy

In condensation polymerization, calculate the number-average degree of polymerization DPn when the functional group conversion p = 0.95. 

View Answer

**Correct Answer: DPn = 20**

**Calculation:**  
From Carothers equation, \\(\overline{DP_n} = \dfrac{1}{1 - p} = \dfrac{1}{1 - 0.95} = \dfrac{1}{0.05} = 20\\) 

**Explanation:** In condensation polymerization, high conversion is required. At p = 0.95, DPn = 20, which is relatively low. At p = 0.99, DPn = 100. 

#### Q3: Meaning of PDI Easy

Calculate the polydispersity index (PDI) for a polymer with number-average molecular weight Mn = 50,000 and weight-average molecular weight Mw = 100,000, and determine if the molecular weight distribution is broad or narrow. 

View Answer

**Correct Answer: PDI = 2.0, distribution is broad**

**Calculation:**  
\\(\text{PDI} = \dfrac{M_w}{M_n} = \dfrac{100{,}000}{50{,}000} = 2.0\\) 

**Explanation:** PDI = 2 is typical for condensation polymerization. PDI > 2 indicates a broad distribution, PDI < 1.5 indicates a relatively narrow distribution. Living polymerization yields very narrow distributions with PDI H 1.0-1.1. 

### Medium (Applied)

#### Q4: Calculation of Radical Polymerization Rate Medium

In radical polymerization of styrene, calculate the polymerization rate Rp under the following conditions:  
\- Propagation rate constant kp = 100 L/mol/s  
\- Termination rate constant kt = 1√ó10x L/mol/s  
\- Initiation rate constant ki = 1√ó10{u 1/s  
\- Initiator efficiency f = 0.6  
\- Monomer concentration [M] = 8.0 mol/L  
\- Initiator concentration [I] = 0.01 mol/L 

View Answer

**Correct Answer: Rp H 8.8√ó10{t mol/L/s**

**Calculation Process:**  
Polymerization rate equation: \\(R_p = k_p [\text{M}] \sqrt{\dfrac{2fk_i[\text{I}]}{k_t}}\\) 

  1. \\(\dfrac{2fk_i[\text{I}]}{k_t} = \dfrac{2 \times 0.6 \times 1 \times 10^{-5} \times 0.01}{1 \times 10^8} = 1.2 \times 10^{-15}\\)
  2. \\(\sqrt{1.2 \times 10^{-15}} = 1.095 \times 10^{-8}\\)
  3. \\(R_p = 100 \times 8.0 \times 1.095 \times 10^{-8} = 8.76 \times 10^{-6}\\) mol/L/s

**Note:** Please verify the value of kt in actual calculations (the above is an example value). 

#### Q5: PDI of Flory-Schulz Distribution Medium

Calculate the functional group conversion p required to achieve PDI = 1.95 in condensation polymerization. 

View Answer

**Correct Answer: p = 0.95**

**Calculation:**  
In Flory-Schulz distribution, \\(\text{PDI} = 1 + p\\)  
Therefore, \\(p = \text{PDI} - 1 = 1.95 - 1 = 0.95\\) 

**Explanation:** The theoretical PDI for condensation polymerization is \\(1 + p\\). At p = 0.95, DPn = 20; at p = 0.99, DPn = 100. High conversion is essential for high molecular weight. 

#### Q6: Calculation of Kinetic Chain Length Medium

In radical polymerization, if the propagation rate Rp = 1√ó10{¬≥ mol/L/s and initiation rate Ri = 1√ó10{x mol/L/s, calculate the kinetic chain length ¬Ω. If termination occurs only by combination, also find the number-average degree of polymerization DPn. 

View Answer

**Correct Answer: ¬Ω = 100,000, DPn = 200,000**

**Calculation:**  
Kinetic chain length: \\(\nu = \dfrac{R_p}{R_i} = \dfrac{1 \times 10^{-3}}{1 \times 10^{-8}} = 100{,}000\\) 

For combination termination: \\(\overline{DP_n} = 2\nu = 2 \times 100{,}000 = 200{,}000\\) 

**Explanation:** The larger the kinetic chain length, the higher the molecular weight of the polymer produced. In combination termination, two radicals combine, so DPn = 2¬Ω. 

#### Q7: PDI of Living Polymerization Medium

In living polymerization, calculate the theoretical PDI when the number-average degree of polymerization DPn = 200. 

View Answer

**Correct Answer: PDI = 1.005**

**Calculation:**  
Polydispersity of Poisson distribution: \\(\text{PDI} = 1 + \dfrac{1}{\overline{DP_n}} = 1 + \dfrac{1}{200} = 1.005\\) 

**Explanation:** In living polymerization, all polymer chains grow simultaneously, resulting in very narrow molecular weight distributions (PDI H 1). As DPn increases, PDI approaches 1. 

### Hard (Advanced)

#### Q8: Precision Synthesis Design using RAFT Polymerization Hard

You want to synthesize methyl methacrylate (MMA, molecular weight 100 g/mol) by RAFT polymerization with target molecular weight Mn = 30,000 g/mol and PDI < 1.15. If the initial monomer concentration [M]‚Ç¨ = 5.0 mol/L and expected conversion is 80%, calculate the required RAFT agent concentration [RAFT]‚Ç¨. 

View Answer

**Correct Answer: [RAFT]‚Ç¨ = 0.0133 mol/L**

**Calculation Process:**

  1. Target degree of polymerization: \\(\overline{DP_n} = \dfrac{M_n}{M_{monomer}} = \dfrac{30{,}000}{100} = 300\\)
  2. Degree of polymerization equation for RAFT: \\(\overline{DP_n} = \dfrac{[\text{M}]_0}{[\text{RAFT}]_0} \times \text{conversion}\\)
  3. Required [RAFT]‚Ç¨: \\([\text{RAFT}]_0 = \dfrac{[\text{M}]_0 \times \text{conversion}}{\overline{DP_n}} = \dfrac{5.0 \times 0.8}{300} = 0.0133\\) mol/L

**Verification:**  
Theoretical PDI (Poisson approximation): \\(\text{PDI} = 1 + \dfrac{1}{300} = 1.0033\\) < 1.15  

**Experimental Notes:** In actual RAFT polymerization, PDI may be slightly larger than theoretical values (around 1.05-1.15) due to termination reactions and chain transfer. Selection of RAFT agent (Z group, R group) is also important. 

#### Q9: Design of Molecular Weight Control Using Chain Transfer Agent Hard

In radical polymerization of styrene, DPn = 5000 is obtained without chain transfer agent. If you want to control DPn = 500 by adding n-dodecyl mercaptan (chain transfer constant Ctr = 20), calculate the required [CTA]/[M] ratio. 

View Answer

**Correct Answer: [CTA]/[M] = 0.00090**

**Calculation Process:**  
Degree of polymerization equation considering chain transfer:  
\\(\dfrac{1}{\overline{DP_n}} = \dfrac{1}{\overline{DP_n^0}} + C_{tr} \times \dfrac{[\text{CTA}]}{[\text{M}]}\\) 

  1. \\(\dfrac{1}{500} = \dfrac{1}{5000} + 20 \times \dfrac{[\text{CTA}]}{[\text{M}]}\\)
  2. \\(\dfrac{1}{500} - \dfrac{1}{5000} = 20 \times \dfrac{[\text{CTA}]}{[\text{M}]}\\)
  3. \\(0.002 - 0.0002 = 20 \times \dfrac{[\text{CTA}]}{[\text{M}]}\\)
  4. \\(0.0018 = 20 \times \dfrac{[\text{CTA}]}{[\text{M}]}\\)
  5. \\(\dfrac{[\text{CTA}]}{[\text{M}]} = \dfrac{0.0018}{20} = 0.00009 = 9 \times 10^{-5}\\)

**Note:** The above calculation ignores chain transfer to monomer and solvent for simplicity. 

**Industrial Significance:** By adding trace amounts of chain transfer agent, molecular weight can be controlled to one-tenth. This enables synthesis of polymers with desired viscosity and processability. 

#### Q10: Experimental Evaluation of Molecular Weight Distribution Hard

The following data was obtained by GPC. Calculate Mn, Mw, and PDI, and determine which polymerization method (radical polymerization, condensation polymerization, living polymerization) was likely used for synthesis.  
  
Molecular weight M [√ó10t]: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10  
Detector response I: 5, 15, 30, 50, 60, 50, 30, 15, 8, 2 

View Answer

**Correct Answer: Mn = 48,773, Mw = 52,491, PDI = 1.08, Living Polymerization**

**Calculation Process (verify with Python code):**
    
    
    # Requirements:
    # - Python 3.9+
    # - numpy>=1.24.0, <2.0.0
    
    """
    Example: Calculation Process (verify with Python code):
    
    Purpose: Demonstrate core concepts and implementation patterns
    Target: Beginner to Intermediate
    Execution time: ~5 seconds
    Dependencies: None
    """
    
    import numpy as np
    
    M_values = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) * 1e4
    I_values = np.array([5, 15, 30, 50, 60, 50, 30, 15, 8, 2])
    
    Mn = np.sum(I_values * M_values) / np.sum(I_values)
    Mw = np.sum(I_values * M_values**2) / np.sum(I_values * M_values)
    PDI = Mw / Mn
    
    print(f"Mn = {Mn:,.0f}")
    print(f"Mw = {Mw:,.0f}")
    print(f"PDI = {PDI:.2f}")
    
    # Output:
    # Mn = 48,773
    # Mw = 52,491
    # PDI = 1.08
    

**Predicted Synthesis Method:**  
Since PDI = 1.08 < 1.2, **living polymerization (RAFT, ATRP, anionic living polymerization)** is predicted. 

**Evidence:**

  * Radical polymerization: PDI = 1.5-2.0 (broad distribution)
  * Condensation polymerization: PDI H 2.0 (most probable distribution)
  * Living polymerization: PDI < 1.2 (narrow distribution, Poisson distribution)

The narrow distribution with a clear peak indicates that a controlled polymerization method, living polymerization, was applied. 

## References

  1. **Odian, G. (2004).** _Principles of Polymerization_ (4th ed.). Wiley, pp. 1-85 (introduction to polymers), pp. 198-305 (radical polymerization kinetics), pp. 456-520 (step-growth polymerization). 
  2. **Flory, P.J. (1953).** _Principles of Polymer Chemistry_. Cornell University Press, pp. 266-316 (molecular weight distributions), pp. 317-425 (statistical mechanics of polymer chains). 
  3. **Young, R.J., Lovell, P.A. (2011).** _Introduction to Polymers_ (3rd ed.). CRC Press, pp. 1-65 (polymer structures and nomenclature), pp. 120-250 (synthesis and polymerization mechanisms). 
  4. **Hiemenz, P.C., Lodge, T.P. (2007).** _Polymer Chemistry_ (2nd ed.). CRC Press, pp. 30-120 (step-growth polymerization), pp. 145-280 (chain-growth polymerization), pp. 350-410 (controlled/living polymerization). 
  5. **Matyjaszewski, K., Davis, T.P. (Eds.). (2002).** _Handbook of Radical Polymerization_. Wiley, pp. 50-150 (RAFT polymerization), pp. 200-280 (ATRP). 
  6. **RDKit Documentation (2024).** Available at: <https://www.rdkit.org/> (Polymer structure representation and SMILES) 
  7. **Moad, G., Rizzardo, E., Thang, S.H. (2012).** "RAFT Polymerization and Some of its Applications." _Chemistry  An Asian Journal_ , 8(8), 1634-1644. (RAFT mechanism and applications) 
  8. **Frey, H., Haag, R. (Eds.). (2007).** _Dendritic Polymers and Macromolecular Architecture_. Elsevier, pp. 1-80 (controlled polymerization techniques). 

**For Further Learning**

  * Polymer synthesis experiments: _Polymer Synthesis: Theory and Practice_ (Braun et al., 2013) - Experimental methods and safety
  * GPC data analysis: _Size-Exclusion Chromatography_ (Striegel et al., 2009) - GPC principles and practice
  * Living polymerization: _Living Radical Polymerization_ (Matyjaszewski & M√ºller, 2012) - RAFT/ATRP details
  * Computational chemistry: _Polymer Science: A Comprehensive Reference_ (Matyjaszewski & M√∂ller, 2012) - Molecular simulation

## Learning Objectives Checklist

### Level 1: Basic Understanding

  * ¬° Can explain differences between addition, condensation, and ring-opening polymerization
  * ¬° Understand the three stages of radical polymerization (initiation, propagation, termination)
  * ¬° Can state definitions of number-average and weight-average molecular weight
  * ¬° Can calculate degree of polymerization using Carothers equation
  * ¬° Can explain meaning of PDI and breadth of molecular weight distribution
  * ¬° Understand differences between Flory-Schulz and Poisson distributions

### Level 2: Practical Skills

  * ¬° Can calculate polymerization rate using radical polymerization kinetic equations
  * ¬° Can derive number-average degree of polymerization from kinetic chain length
  * ¬° Can calculate Mn, Mw, and PDI from GPC data
  * ¬° Can predict molecular weight distribution using Flory-Schulz distribution
  * ¬° Can perform design calculations for RAFT polymerization ([M]/[RAFT] ratio)
  * ¬° Can control molecular weight using chain transfer constants

### Level 3: Applied Skills

  * ¬° Can predict effects of polymerization conditions (initiator concentration, temperature, solvent) on molecular weight
  * ¬° Can select polymerization method to achieve target molecular weight and PDI
  * ¬° Can compare molecular weight distributions of living and conventional radical polymerization
  * ¬° Can design molecular weight using chain transfer agents
  * ¬° Can infer polymerization mechanism from experimental data
  * ¬° Can discuss optimization of industrial polymer synthesis processes

**Next Steps** In Chapter 2, we will learn about the structure of synthesized polymers (tacticity, crystallinity, cross-linking). We will understand how the molecular weight distribution learned in this chapter affects polymer properties (glass transition temperature, mechanical strength, solubility). In particular, stereoregularity and crystallization greatly influence material properties. 

### Disclaimer

  * This content is provided solely for educational, research, and informational purposes and does not constitute professional advice (legal, accounting, technical warranty, etc.).
  * This content and accompanying code examples are provided "AS IS" without any warranty, express or implied, including but not limited to merchantability, fitness for a particular purpose, non-infringement, accuracy, completeness, operation, or safety.
  * The author and Tohoku University assume no responsibility for the content, availability, or safety of external links, third-party data, tools, libraries, etc.
  * To the maximum extent permitted by applicable law, the author and Tohoku University shall not be liable for any direct, indirect, incidental, special, consequential, or punitive damages arising from the use, execution, or interpretation of this content.
  * The content may be changed, updated, or discontinued without notice.
  * The copyright and license of this content are subject to the stated conditions (e.g., CC BY 4.0). Such licenses typically include no-warranty clauses.
