<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="Chapter 4: Functional Ceramics - Ceramic Materials Introduction - MS Dojo" name="description"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Chapter 4: Functional Ceramics - Ceramic Materials Introduction - MS Dojo</title>
<meta content="Learn the principles and applications of dielectric, piezoelectric, ionic conductor, luminescent, and magnetic ceramics with Python." name="description"/>
<!-- Prism.js for code highlighting -->
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet"/>
<!-- MathJax for mathematical expressions -->
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<!-- Mermaid for diagrams -->
<script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
<link href="../../assets/css/knowledge-base.css" rel="stylesheet"/>
</head>
<body>
<nav class="breadcrumb">
<div class="breadcrumb-content">
<a href="../index.html">AI Terakoya Top</a><span class="breadcrumb-separator">‚Ä∫</span><a href="../../MS/index.html">Materials Science</a><span class="breadcrumb-separator">‚Ä∫</span><a href="../../MS/ceramic-materials-introduction/index.html">Ceramic Materials</a><span class="breadcrumb-separator">‚Ä∫</span><span class="breadcrumb-current">Chapter 4</span>
</div>
</nav><div class="locale-switcher">
<span class="current-locale">üåê EN</span>
<span class="locale-separator">|</span>
<a href="../../../jp/MS/ceramic-materials-introduction/chapter-4.html" class="locale-link">üáØüáµ JP</a>
<span class="locale-separator">|</span>
<span class="locale-meta">Last sync: 2025-11-16</span>
</div>
<header>
<h1>Chapter 4: Functional Ceramics</h1>
<p>Principles and Applications of Dielectric, Piezoelectric, Ionic Conductor, Luminescent, and Magnetic Ceramics</p>
</header>
<nav>
<ul>
<li><a href="index.html">Top</a></li>
<li><a href="#intro">Overview</a></li>
<li><a href="#dielectric">Dielectrics</a></li>
<li><a href="#piezoelectric">Piezoelectrics</a></li>
<li><a href="#ionic">Ionic Conductors</a></li>
<li><a href="#luminescence">Luminescent Materials</a></li>
<li><a href="#magnetic">Magnetics</a></li>
<li><a href="#exercises">Exercises</a></li>
<li><a href="#references">References</a></li>
<li><a href="chapter-3.html">‚Üê Previous Chapter</a></li>
<li><a href="chapter-5.html">Next Chapter ‚Üí</a></li>
</ul>
</nav>
<main>

<p class="chapter-description">This chapter covers Functional Ceramics. You will learn essential concepts and techniques.</p>
<section id="intro">
<h2>4.1 Overview of Functional Ceramics</h2>
<p>
                Functional ceramics are material groups that utilize <strong>dielectric, piezoelectric, ionic conduction, luminescence, and magnetic</strong> properties. They are widely applied as capacitors, sensors, solid electrolytes, LED phosphors, and magnetic devices. In this chapter, we will learn the physical mechanisms of each function and practice property calculations with Python.
            </p>
<div class="info-box">
<strong>Learning Objectives for This Chapter</strong>
<ul>
<li><strong>Level 1 (Basic Understanding)</strong>: Explain the definitions of permittivity, piezoelectric constant, and ionic conductivity, and understand representative materials and applications</li>
<li><strong>Level 2 (Practical Skills)</strong>: Execute permittivity calculations, piezoelectric response simulations, and Arrhenius plots with Python</li>
<li><strong>Level 3 (Application Ability)</strong>: Extract material constants from measured data and apply to device design. Optimize phase diagrams and compositions</li>
</ul>
</div>
<h3>Classification of Functional Ceramics</h3>
<div class="mermaid">
            flowchart TD
                A[Functional Ceramics] --&gt; B[Dielectric Materials]
                A --&gt; C[Piezoelectric/Pyroelectric Materials]
                A --&gt; D[Ionic Conductors]
                A --&gt; E[Optical Functional Materials]
                A --&gt; F[Magnetic Materials]

                B --&gt; B1[BaTiO‚ÇÉ<br/>MLCC]
                B --&gt; B2[High Permittivity Materials<br/>Œµ·µ£ &gt; 1000]

                C --&gt; C1[PZT<br/>Actuators]
                C --&gt; C2[AlN<br/>High-frequency Filters]

                D --&gt; D1[YSZ<br/>SOFC Electrolyte]
                D --&gt; D2[Li-based<br/>All-solid-state Batteries]

                E --&gt; E1[Phosphors<br/>LED, PDP]
                E --&gt; E2[Lasers<br/>YAG:Nd]

                F --&gt; F1[Ferrites<br/>Magnetic Cores]
                F --&gt; F2[Magnetic Garnets<br/>Optical Isolators]

                style A fill:#f093fb,color:#fff
                style B fill:#e3f2fd
                style C fill:#fff3e0
                style D fill:#e8f5e9
                style E fill:#fce4ec
                style F fill:#f3e5f5
            
            </div>
<table>
<thead>
<tr>
<th>Function</th>
<th>Representative Materials</th>
<th>Property Parameters</th>
<th>Primary Applications</th>
</tr>
</thead>
<tbody>
<tr>
<td>Dielectric</td>
<td>BaTiO‚ÇÉ, (Ba,Sr)TiO‚ÇÉ</td>
<td>Permittivity Œµ·µ£ = 1000-10000</td>
<td>MLCC, Memory</td>
</tr>
<tr>
<td>Piezoelectric</td>
<td>PZT, BaTiO‚ÇÉ, AlN</td>
<td>Piezoelectric constant d‚ÇÉ‚ÇÉ = 100-600 pC/N</td>
<td>Ultrasonic sensors, oscillators</td>
</tr>
<tr>
<td>Ionic Conductor</td>
<td>YSZ, LLZO, Œ≤-Al‚ÇÇO‚ÇÉ</td>
<td>Conductivity œÉ = 0.01-1 S/cm</td>
<td>SOFC, All-solid-state batteries</td>
</tr>
<tr>
<td>Luminescent</td>
<td>Y‚ÇÉAl‚ÇÖO‚ÇÅ‚ÇÇ:Ce (YAG:Ce)</td>
<td>Quantum efficiency &gt; 90%</td>
<td>White LED phosphors</td>
</tr>
<tr>
<td>Magnetic</td>
<td>NiFe‚ÇÇO‚ÇÑ, BaFe‚ÇÅ‚ÇÇO‚ÇÅ‚Çâ</td>
<td>Saturation magnetization Ms = 0.3-0.6 T</td>
<td>Transformers, Motors</td>
</tr>
</tbody>
</table>
</section>
<section id="dielectric">
<h2>4.2 Dielectric Ceramics</h2>
<h3>4.2.1 Mechanism of Dielectric Polarization</h3>
<p>
                When an electric field is applied to a dielectric, the following four types of polarization occur:
            </p>
<ol>
<li><strong>Electronic polarization</strong>: Displacement of electron cloud (all materials, ~10<sup>15</sup> Hz)</li>
<li><strong>Ionic polarization</strong>: Relative displacement of ions (infrared range, ~10<sup>13</sup> Hz)</li>
<li><strong>Orientation polarization</strong>: Rotation of permanent dipoles (microwave range, ~10<sup>9</sup> Hz)</li>
<li><strong>Interfacial polarization</strong>: Charge accumulation at interfaces (low frequency, ~10<sup>3</sup> Hz)</li>
</ol>
<p>
                The permittivity \( \epsilon_r \) is defined as the ratio to the vacuum permittivity \( \epsilon_0 = 8.854 \times 10^{-12} \) F/m:
            </p>
<p>
                \[
                \epsilon_r = \frac{\epsilon}{\epsilon_0}
                \]
            </p>
<h3>4.2.2 Ferroelectricity of BaTiO‚ÇÉ</h3>
<p>
                BaTiO‚ÇÉ undergoes a phase transition to tetragonal structure below the Curie temperature (T<sub>c</sub> ‚âà 120¬∞C) and possesses spontaneous polarization. This ferroelectricity results in extremely high permittivity values exceeding 10,000.
            </p>
<h4>Python Implementation: Permittivity Calculation using Clausius-Mossotti Equation</h4>
<pre><code class="language-python"># Requirements:
# - Python 3.9+
# - matplotlib&gt;=3.7.0
# - numpy&gt;=1.24.0, &lt;2.0.0

# ===================================
# Example 1: Clausius-Mossotti Permittivity Calculation
# ===================================

import numpy as np
import matplotlib.pyplot as plt

def clausius_mossotti_permittivity(alpha, N, epsilon_0=8.854e-12):
    """
    Calculate permittivity using the Clausius-Mossotti equation

    Parameters:
    -----------
    alpha : float
        Polarizability [C¬∑m¬≤/V]
    N : float
        Number of atoms per unit volume [m^-3]
    epsilon_0 : float
        Vacuum permittivity [F/m]

    Returns:
    --------
    epsilon_r : float
        Relative permittivity (dimensionless)
    """
    # Clausius-Mossotti equation: (Œµ·µ£ - 1)/(Œµ·µ£ + 2) = N¬∑Œ±/(3Œµ‚ÇÄ)
    # Rearranged: Œµ·µ£ = (1 + 2¬∑N¬∑Œ±/(3Œµ‚ÇÄ)) / (1 - N¬∑Œ±/(3Œµ‚ÇÄ))

    numerator = 1 + 2 * N * alpha / (3 * epsilon_0)
    denominator = 1 - N * alpha / (3 * epsilon_0)

    epsilon_r = numerator / denominator

    return epsilon_r


def curie_weiss_law(T, T_c=393, C=1.5e5):
    """
    Temperature dependence of permittivity using Curie-Weiss law

    Parameters:
    -----------
    T : float or array
        Temperature [K]
    T_c : float
        Curie temperature [K] (BaTiO‚ÇÉ ‚âà 120¬∞C = 393K)
    C : float
        Curie constant [K]

    Returns:
    --------
    epsilon_r : float or array
        Relative permittivity
    """
    # Curie-Weiss law: Œµ·µ£ = C / (T - T·∂ú)
    epsilon_r = C / np.abs(T - T_c)

    # Limit maximum value to avoid divergence
    epsilon_r = np.minimum(epsilon_r, 20000)

    return epsilon_r


def plot_dielectric_properties():
    """
    Visualize dielectric properties
    """
    fig, axes = plt.subplots(1, 2, figsize=(14, 5))

    # Left plot: Polarizability vs permittivity relationship
    ax1 = axes[0]

    # Typical material polarizability range
    alpha_range = np.linspace(1e-40, 5e-40, 100)  # C¬∑m¬≤/V
    N = 5e28  # m^-3 (typical ion density)

    epsilon_r_values = [clausius_mossotti_permittivity(alpha, N) for alpha in alpha_range]

    ax1.plot(alpha_range * 1e40, epsilon_r_values, linewidth=2, color='navy')

    # Plot representative materials
    materials = {
        'SiO‚ÇÇ': {'alpha': 3.5e-41, 'epsilon_r': 3.8},
        'Al‚ÇÇO‚ÇÉ': {'alpha': 1.0e-40, 'epsilon_r': 9.0},
        'TiO‚ÇÇ': {'alpha': 2.5e-40, 'epsilon_r': 80},
        'BaTiO‚ÇÉ': {'alpha': 4.5e-40, 'epsilon_r': 1200}
    }

    for name, props in materials.items():
        ax1.scatter(props['alpha'] * 1e40, props['epsilon_r'],
                   s=150, edgecolors='black', linewidth=2, zorder=5)
        ax1.annotate(name, (props['alpha'] * 1e40, props['epsilon_r']),
                    xytext=(5, 5), textcoords='offset points', fontsize=10)

    ax1.set_xlabel('Polarizability Œ± (10^-40 C¬∑m¬≤/V)', fontsize=12)
    ax1.set_ylabel('Relative Permittivity Œµ·µ£', fontsize=12)
    ax1.set_title('Clausius-Mossotti Relation', fontsize=14, fontweight='bold')
    ax1.grid(True, alpha=0.3)

    # Right plot: BaTiO‚ÇÉ Curie-Weiss behavior
    ax2 = axes[1]

    T_range = np.linspace(293, 493, 500)  # 20¬∞C ~ 220¬∞C
    T_c = 393  # 120¬∞C

    epsilon_r_bto = curie_weiss_law(T_range, T_c, C=1.5e5)

    ax2.plot(T_range - 273.15, epsilon_r_bto, linewidth=2, color='crimson')
    ax2.axvline(x=T_c - 273.15, color='blue', linestyle='--', linewidth=2,
                label=f'Curie temperature = {T_c-273.15:.0f}¬∞C')

    ax2.set_xlabel('Temperature (¬∞C)', fontsize=12)
    ax2.set_ylabel('Relative Permittivity Œµ·µ£', fontsize=12)
    ax2.set_title('BaTiO‚ÇÉ Curie-Weiss Behavior', fontsize=14, fontweight='bold')
    ax2.set_ylim(0, 20000)
    ax2.legend()
    ax2.grid(True, alpha=0.3)

    plt.tight_layout()
    plt.savefig('dielectric_properties.png', dpi=300, bbox_inches='tight')
    plt.show()

    # Numerical examples
    print("=== Clausius-Mossotti Calculation ===")
    for name, props in materials.items():
        calculated_eps = clausius_mossotti_permittivity(props['alpha'], N)
        print(f"{name:10s}: Œ± = {props['alpha']*1e40:.2f}√ó10^-40, Œµ·µ£ = {calculated_eps:.1f} (exp: {props['epsilon_r']})")

    print("\n=== BaTiO‚ÇÉ Temperature Dependence ===")
    for T_celsius in [80, 100, 120, 140, 160]:
        T = T_celsius + 273.15
        eps = curie_weiss_law(T, T_c=393, C=1.5e5)
        print(f"T = {T_celsius:3d}¬∞C ‚Üí Œµ·µ£ = {eps:6.0f}")

# Execute
plot_dielectric_properties()
</code></pre>
<h3>4.2.3 MLCC (Multilayer Ceramic Capacitor) Design</h3>
<p>
                MLCCs achieve high capacitance through a structure of alternating dielectric layers and internal electrodes. The capacitance C is:
            </p>
<p>
                \[
                C = \frac{\epsilon_0 \epsilon_r A}{d} \times n
                \]
            </p>
<p>
                where \( A \) is the electrode area, \( d \) is the dielectric layer thickness, and \( n \) is the number of layers.
            </p>
<h4>Python Implementation: MLCC Capacitance Design Calculation</h4>
<pre><code class="language-python"># Requirements:
# - Python 3.9+
# - matplotlib&gt;=3.7.0
# - numpy&gt;=1.24.0, &lt;2.0.0

# ===================================
# Example 2: MLCC Capacitance Design
# ===================================

import numpy as np
import matplotlib.pyplot as plt

def mlcc_capacitance(epsilon_r, A, d, n, epsilon_0=8.854e-12):
    """
    Calculate capacitance of MLCC (Multilayer Ceramic Capacitor)

    Parameters:
    -----------
    epsilon_r : float
        Relative permittivity
    A : float
        Electrode area [m¬≤]
    d : float
        Dielectric layer thickness [m]
    n : int
        Number of layers
    epsilon_0 : float
        Vacuum permittivity [F/m]

    Returns:
    --------
    C : float
        Capacitance [F]
    """
    C = (epsilon_0 * epsilon_r * A / d) * n
    return C


def design_mlcc_optimization():
    """
    MLCC design optimization simulation
    """
    # Design parameters
    epsilon_r = 3000  # X7R material (BaTiO‚ÇÉ-based)
    A = (1e-3)**2  # 1mm √ó 1mm
    d_range = np.linspace(1e-6, 50e-6, 100)  # 1~50 Œºm
    n = 100  # 100 layers

    # Capacitance calculation
    C_values = [mlcc_capacitance(epsilon_r, A, d, n) for d in d_range]

    fig, axes = plt.subplots(1, 2, figsize=(14, 5))

    # Left plot: Layer thickness vs capacitance
    ax1 = axes[0]
    ax1.plot(d_range * 1e6, np.array(C_values) * 1e6, linewidth=2, color='navy')
    ax1.axhline(y=1, color='red', linestyle='--', alpha=0.5, label='Target: 1 ŒºF')

    ax1.set_xlabel('Dielectric Layer Thickness (Œºm)', fontsize=12)
    ax1.set_ylabel('Capacitance (ŒºF)', fontsize=12)
    ax1.set_title('MLCC Capacitance vs Layer Thickness', fontsize=14, fontweight='bold')
    ax1.legend()
    ax1.grid(True, alpha=0.3)

    # Right plot: Effect of number of layers
    ax2 = axes[1]
    d_fixed = 5e-6  # 5 Œºm
    n_range = np.arange(10, 501, 10)
    C_vs_n = [mlcc_capacitance(epsilon_r, A, d_fixed, n) for n in n_range]

    ax2.plot(n_range, np.array(C_vs_n) * 1e6, linewidth=2, color='green')

    ax2.set_xlabel('Number of Layers n', fontsize=12)
    ax2.set_ylabel('Capacitance (ŒºF)', fontsize=12)
    ax2.set_title(f'MLCC Capacitance vs Layer Count (d = {d_fixed*1e6} Œºm)', fontsize=14, fontweight='bold')
    ax2.grid(True, alpha=0.3)

    plt.tight_layout()
    plt.savefig('mlcc_design.png', dpi=300, bbox_inches='tight')
    plt.show()

    # Design examples
    print("=== MLCC Design Examples ===")
    designs = [
        {'name': 'Low-C (1 nF)', 'd': 20e-6, 'n': 10},
        {'name': 'Mid-C (100 nF)', 'd': 10e-6, 'n': 50},
        {'name': 'High-C (1 ŒºF)', 'd': 5e-6, 'n': 200},
        {'name': 'Ultra-C (10 ŒºF)', 'd': 2e-6, 'n': 500}
    ]

    for design in designs:
        C = mlcc_capacitance(epsilon_r, A, design['d'], design['n'])
        volume = A * design['d'] * design['n']
        density = C / volume  # F/m¬≥
        print(f"{design['name']:20s}: d={design['d']*1e6:4.1f} Œºm, n={design['n']:3d} ‚Üí C={C*1e6:8.2f} ŒºF, density={density*1e-9:.2f} ŒºF/mm¬≥")

# Execute
design_mlcc_optimization()
</code></pre>
<div class="info-box">
<strong>MLCC Thin Layer Trend</strong>
                In modern MLCCs, the dielectric layer thickness has been reduced to less than 1 Œºm (0.5 Œºm in advanced products). This enables achieving high capacitance exceeding 10 ŒºF in a 1608 size (1.6 mm √ó 0.8 mm). Thin-layer production requires uniform dielectric slurries and nanoparticle raw materials.
            </div>
</section>
<section id="piezoelectric">
<h2>4.3 Piezoelectric Ceramics</h2>
<h3>4.3.1 Principle of Piezoelectric Effect</h3>
<p>
                The piezoelectric effect is the phenomenon where charge is generated by mechanical stress (direct piezoelectric effect) and strain is induced by applying an electric field (converse piezoelectric effect). Crystal structure asymmetry is necessary, and 20 of the 32 crystal point groups exhibit piezoelectricity.
            </p>
<p>
                The piezoelectric constant \( d_{33} \) represents the strain (or charge) when the electric field direction and stress direction are parallel:
            </p>
<p>
                \[
                S_3 = d_{33} E_3 \quad \text{(Converse piezoelectric effect)}
                \]
                \[
                D_3 = d_{33} T_3 \quad \text{(Direct piezoelectric effect)}
                \]
            </p>
<p>
                where \( S \) is strain, \( E \) is electric field, \( D \) is electric displacement, and \( T \) is stress.
            </p>
<h3>4.3.2 Properties of PZT (Lead Zirconate Titanate)</h3>
<p>
                PZT (Pb(Zr<sub>x</sub>Ti<sub>1-x</sub>)O‚ÇÉ) is the most widely used piezoelectric material. Piezoelectric properties are maximized at the MPB (Morphotropic Phase Boundary, x ‚âà 0.52) composition.
            </p>
<table>
<thead>
<tr>
<th>Material</th>
<th>d‚ÇÉ‚ÇÉ (pC/N)</th>
<th>k<sub>p</sub></th>
<th>Applications</th>
</tr>
</thead>
<tbody>
<tr>
<td>BaTiO‚ÇÉ</td>
<td>190</td>
<td>0.36</td>
<td>Early piezoelectric devices</td>
</tr>
<tr>
<td>PZT-4</td>
<td>289</td>
<td>0.58</td>
<td>Sensors</td>
</tr>
<tr>
<td>PZT-5H</td>
<td>593</td>
<td>0.65</td>
<td>Actuators</td>
</tr>
<tr>
<td>AlN</td>
<td>5.5</td>
<td>0.20</td>
<td>High-frequency filters</td>
</tr>
</tbody>
</table>
<h4>Python Implementation: Calculation of Piezoelectric Constant and Coupling Coefficient</h4>
<pre><code class="language-python"># Requirements:
# - Python 3.9+
# - matplotlib&gt;=3.7.0
# - numpy&gt;=1.24.0, &lt;2.0.0

# ===================================
# Example 3: Piezoelectric Constant and Coupling Coefficient Calculation
# ===================================

import numpy as np
import matplotlib.pyplot as plt

def piezoelectric_strain(d_33, E_3):
    """
    Calculate strain from converse piezoelectric effect

    Parameters:
    -----------
    d_33 : float
        Piezoelectric constant [m/V] or [C/N]
    E_3 : float
        Electric field [V/m]

    Returns:
    --------
    S_3 : float
        Strain (dimensionless)
    """
    S_3 = d_33 * E_3
    return S_3


def electromechanical_coupling_factor(d_33, epsilon_33, s_33):
    """
    Calculate electromechanical coupling coefficient

    Parameters:
    -----------
    d_33 : float
        Piezoelectric constant [C/N]
    epsilon_33 : float
        Permittivity [F/m]
    s_33 : float
        Elastic compliance [m¬≤/N]

    Returns:
    --------
    k_33 : float
        Coupling coefficient (dimensionless, 0~1)
    """
    k_33 = d_33 / np.sqrt(epsilon_33 * s_33)
    return k_33


def plot_piezoelectric_response():
    """
    Visualize piezoelectric response
    """
    # Physical properties of PZT-5H
    d_33 = 593e-12  # C/N
    epsilon_0 = 8.854e-12
    epsilon_r = 3400
    epsilon_33 = epsilon_0 * epsilon_r

    fig, axes = plt.subplots(1, 2, figsize=(14, 5))

    # Left plot: Electric field-strain relationship (converse piezoelectric effect)
    ax1 = axes[0]
    E_range = np.linspace(-2e6, 2e6, 500)  # -2 ~ +2 MV/m
    strain = piezoelectric_strain(d_33, E_range)

    ax1.plot(E_range / 1e6, strain * 1e6, linewidth=2, color='navy')
    ax1.axhline(y=0, color='black', linestyle='-', linewidth=0.5)
    ax1.axvline(x=0, color='black', linestyle='-', linewidth=0.5)

    ax1.set_xlabel('Electric Field E‚ÇÉ (MV/m)', fontsize=12)
    ax1.set_ylabel('Strain S‚ÇÉ (Œºstrain)', fontsize=12)
    ax1.set_title('Converse Piezoelectric Effect (PZT-5H)', fontsize=14, fontweight='bold')
    ax1.grid(True, alpha=0.3)

    # Right plot: Material comparison (piezoelectric constant and coupling coefficient)
    ax2 = axes[1]

    materials_piezo = {
        'BaTiO‚ÇÉ': {'d33': 190e-12, 'epsilon_r': 1700, 's33': 8.3e-12},
        'PZT-4': {'d33': 289e-12, 'epsilon_r': 1300, 's33': 12.3e-12},
        'PZT-5H': {'d33': 593e-12, 'epsilon_r': 3400, 's33': 16.5e-12},
        'PVDF': {'d33': 33e-12, 'epsilon_r': 12, 's33': 400e-12},
        'AlN': {'d33': 5.5e-12, 'epsilon_r': 9, 's33': 3.0e-12}
    }

    names = list(materials_piezo.keys())
    d33_values = [props['d33'] * 1e12 for props in materials_piezo.values()]
    k33_values = []

    for props in materials_piezo.values():
        epsilon = epsilon_0 * props['epsilon_r']
        k33 = electromechanical_coupling_factor(props['d33'], epsilon, props['s33'])
        k33_values.append(k33)

    x = np.arange(len(names))
    width = 0.35

    ax2.bar(x - width/2, d33_values, width, label='d‚ÇÉ‚ÇÉ (pC/N)', color='skyblue', edgecolor='black')
    ax2_twin = ax2.twinx()
    ax2_twin.bar(x + width/2, k33_values, width, label='k‚ÇÉ‚ÇÉ', color='salmon', edgecolor='black')

    ax2.set_xlabel('Material', fontsize=12)
    ax2.set_ylabel('Piezoelectric Constant d‚ÇÉ‚ÇÉ (pC/N)', fontsize=12, color='skyblue')
    ax2_twin.set_ylabel('Coupling Coefficient k‚ÇÉ‚ÇÉ', fontsize=12, color='salmon')
    ax2.set_title('Piezoelectric Material Comparison', fontsize=14, fontweight='bold')
    ax2.set_xticks(x)
    ax2.set_xticklabels(names, rotation=15)
    ax2.tick_params(axis='y', labelcolor='skyblue')
    ax2_twin.tick_params(axis='y', labelcolor='salmon')
    ax2.grid(True, alpha=0.3, axis='y')

    plt.tight_layout()
    plt.savefig('piezoelectric_response.png', dpi=300, bbox_inches='tight')
    plt.show()

    # Numerical examples
    print("=== Piezoelectric Response Calculation (PZT-5H) ===")
    for E_MV in [0.5, 1.0, 2.0]:
        E = E_MV * 1e6
        S = piezoelectric_strain(d_33, E)
        displacement = S * 1e-3  # For 1 mm thickness
        print(f"E = {E_MV:.1f} MV/m ‚Üí Strain = {S*1e6:.1f} Œºstrain, Displacement (1mm) = {displacement*1e9:.2f} nm")

    print("\n=== Electromechanical Coupling Coefficients ===")
    for name, props in materials_piezo.items():
        epsilon = epsilon_0 * props['epsilon_r']
        k33 = electromechanical_coupling_factor(props['d33'], epsilon, props['s33'])
        print(f"{name:10s}: d‚ÇÉ‚ÇÉ = {props['d33']*1e12:5.1f} pC/N, k‚ÇÉ‚ÇÉ = {k33:.3f}")

# Execute
plot_piezoelectric_response()
</code></pre>
<h4>Python Implementation: PZT Phase Diagram and MPB Composition</h4>
<pre><code class="language-python"># Requirements:
# - Python 3.9+
# - matplotlib&gt;=3.7.0
# - numpy&gt;=1.24.0, &lt;2.0.0

# ===================================
# Example 4: PZT Phase Diagram and MPB Composition Visualization
# ===================================

import numpy as np
import matplotlib.pyplot as plt

def pzt_phase_diagram():
    """
    Visualize PZT phase diagram and MPB (Morphotropic Phase Boundary)
    """
    # Composition range (Zr content)
    x_Zr = np.linspace(0, 1, 500)

    # Composition dependence of Curie temperature (simplified model)
    T_c = 490 - 200 * x_Zr + 150 * x_Zr**2  # ¬∞C

    # Composition dependence of piezoelectric constant (maximum near MPB)
    # MPB composition: x ‚âà 0.52
    x_MPB = 0.52
    d_33 = 200 + 400 * np.exp(-((x_Zr - x_MPB) / 0.1)**2)

    fig, axes = plt.subplots(1, 2, figsize=(14, 5))

    # Left plot: Phase diagram
    ax1 = axes[0]

    # Phase boundary definition (simplified)
    x_rhomb = x_Zr[x_Zr &gt; x_MPB]
    x_tetra = x_Zr[x_Zr &lt;= x_MPB]
    T_c_rhomb = T_c[x_Zr &gt; x_MPB]
    T_c_tetra = T_c[x_Zr &lt;= x_MPB]

    # Fill regions
    ax1.fill_between(x_rhomb, 0, T_c_rhomb, alpha=0.3, color='blue', label='Rhombohedral (FE_R)')
    ax1.fill_between(x_tetra, 0, T_c_tetra, alpha=0.3, color='red', label='Tetragonal (FE_T)')
    ax1.fill_between(x_Zr, T_c, 500, alpha=0.2, color='gray', label='Cubic (Paraelectric)')

    # MPB line
    ax1.axvline(x=x_MPB, color='green', linestyle='--', linewidth=2, label=f'MPB (x = {x_MPB})')
    ax1.plot(x_Zr, T_c, 'k-', linewidth=2, label='Curie Temperature')

    ax1.set_xlabel('Zr Content x in Pb(Zr_xTi_{1-x})O‚ÇÉ', fontsize=12)
    ax1.set_ylabel('Temperature (¬∞C)', fontsize=12)
    ax1.set_title('PZT Phase Diagram', fontsize=14, fontweight='bold')
    ax1.set_xlim(0, 1)
    ax1.set_ylim(0, 500)
    ax1.legend(loc='upper right')
    ax1.grid(True, alpha=0.3)

    # Right plot: Composition dependence of piezoelectric constant
    ax2 = axes[1]
    ax2.plot(x_Zr, d_33, linewidth=2, color='navy')
    ax2.axvline(x=x_MPB, color='green', linestyle='--', linewidth=2, label=f'MPB (x = {x_MPB})')
    ax2.scatter([x_MPB], [np.max(d_33)], s=200, c='red', marker='*', edgecolors='black',
                linewidth=2, zorder=5, label=f'd‚ÇÉ‚ÇÉ max = {np.max(d_33):.0f} pC/N')

    ax2.set_xlabel('Zr Content x in Pb(Zr_xTi_{1-x})O‚ÇÉ', fontsize=12)
    ax2.set_ylabel('Piezoelectric Constant d‚ÇÉ‚ÇÉ (pC/N)', fontsize=12)
    ax2.set_title('PZT Piezoelectric Constant vs Composition', fontsize=14, fontweight='bold')
    ax2.legend()
    ax2.grid(True, alpha=0.3)

    plt.tight_layout()
    plt.savefig('pzt_phase_diagram.png', dpi=300, bbox_inches='tight')
    plt.show()

    # Numerical examples
    print("=== PZT Composition Effects ===")
    compositions = [0.3, 0.4, 0.52, 0.6, 0.7]
    for x in compositions:
        idx = np.argmin(np.abs(x_Zr - x))
        T_c_val = T_c[idx]
        d_33_val = d_33[idx]
        phase = 'Tetragonal' if x &lt; x_MPB else 'Rhombohedral'
        print(f"x = {x:.2f} ({phase:15s}): T_c = {T_c_val:5.1f}¬∞C, d‚ÇÉ‚ÇÉ = {d_33_val:5.0f} pC/N")

# Execute
pzt_phase_diagram()
</code></pre>
<div class="warning-box">
<strong>Development of Lead-Free Piezoelectric Materials</strong>
                Although PZT has high performance, the environmental impact of lead (Pb) is a concern. In recent years, lead-free materials such as (K,Na)NbO‚ÇÉ (KNN) and (Bi,Na)TiO‚ÇÉ (BNT) have been researched, but they have not yet reached PZT's performance (d‚ÇÉ‚ÇÉ ‚âà 600 pC/N). KNN achieves approximately 300 pC/N.
            </div>
</section>
<section id="ionic">
<h2>4.4 Ionic Conductor Ceramics</h2>
<h3>4.4.1 Mechanism of Ionic Conduction</h3>
<p>
                In ionic conductors, ions (O¬≤‚Åª, Li‚Å∫, Na‚Å∫, etc.) move through the crystal lattice. The conductivity \( \sigma \) is expressed by the Arrhenius equation:
            </p>
<p>
                \[
                \sigma = \sigma_0 \exp\left(-\frac{E_a}{k_B T}\right)
                \]
            </p>
<p>
                where \( \sigma_0 \) is the pre-exponential factor, \( E_a \) is the activation energy, \( k_B \) is the Boltzmann constant, and \( T \) is the temperature.
            </p>
<h3>4.4.2 YSZ (Yttria-Stabilized Zirconia)</h3>
<p>
                YSZ ((Y‚ÇÇO‚ÇÉ)<sub>x</sub>(ZrO‚ÇÇ)<sub>1-x</sub>) is used as the electrolyte in SOFCs (Solid Oxide Fuel Cells). Y¬≥‚Å∫ doping creates oxygen vacancies, allowing O¬≤‚Åª ion conduction.
            </p>
<table>
<thead>
<tr>
<th>Material</th>
<th>Conducting Ion</th>
<th>œÉ (S/cm) @ 800¬∞C</th>
<th>E<sub>a</sub> (eV)</th>
<th>Applications</th>
</tr>
</thead>
<tbody>
<tr>
<td>YSZ (8mol% Y‚ÇÇO‚ÇÉ)</td>
<td>O¬≤‚Åª</td>
<td>0.1</td>
<td>1.0</td>
<td>SOFC electrolyte</td>
</tr>
<tr>
<td>LLZO (Li‚ÇáLa‚ÇÉZr‚ÇÇO‚ÇÅ‚ÇÇ)</td>
<td>Li‚Å∫</td>
<td>0.05 (room temp)</td>
<td>0.3</td>
<td>All-solid-state batteries</td>
</tr>
<tr>
<td>Œ≤-Al‚ÇÇO‚ÇÉ</td>
<td>Na‚Å∫</td>
<td>0.2 (300¬∞C)</td>
<td>0.16</td>
<td>Na-S batteries</td>
</tr>
<tr>
<td>GDC (Ce‚ÇÄ.‚ÇâGd‚ÇÄ.‚ÇÅO‚ÇÅ.‚Çâ‚ÇÖ)</td>
<td>O¬≤‚Åª</td>
<td>0.02</td>
<td>0.7</td>
<td>Low-temperature SOFC</td>
</tr>
</tbody>
</table>
<h4>Python Implementation: Arrhenius Conductivity and Activation Energy</h4>
<pre><code class="language-python"># Requirements:
# - Python 3.9+
# - matplotlib&gt;=3.7.0
# - numpy&gt;=1.24.0, &lt;2.0.0

# ===================================
# Example 5: Arrhenius Conductivity Calculation
# ===================================

import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit

def ionic_conductivity(T, sigma_0, E_a, k_B=8.617e-5):
    """
    Calculate ionic conductivity using Arrhenius equation

    Parameters:
    -----------
    T : float or array
        Temperature [K]
    sigma_0 : float
        Pre-exponential factor [S/cm]
    E_a : float
        Activation energy [eV]
    k_B : float
        Boltzmann constant [eV/K]

    Returns:
    --------
    sigma : float or array
        Ionic conductivity [S/cm]
    """
    sigma = sigma_0 * np.exp(-E_a / (k_B * T))
    return sigma


def fit_arrhenius_data(T_data, sigma_data):
    """
    Fit Arrhenius parameters from measured data

    Parameters:
    -----------
    T_data : array
        Temperature data [K]
    sigma_data : array
        Conductivity data [S/cm]

    Returns:
    --------
    sigma_0 : float
        Pre-exponential factor [S/cm]
    E_a : float
        Activation energy [eV]
    """
    # Logarithmic transformation: ln(œÉ) = ln(œÉ‚ÇÄ) - E_a/(k_B¬∑T)
    # y = ln(œÉ), x = 1/T, slope = -E_a/k_B, intercept = ln(œÉ‚ÇÄ)

    x = 1 / T_data
    y = np.log(sigma_data)

    # Linear regression
    coeffs = np.polyfit(x, y, 1)
    slope = coeffs[0]
    intercept = coeffs[1]

    E_a = -slope * 8.617e-5  # eV
    sigma_0 = np.exp(intercept)

    return sigma_0, E_a


def plot_ionic_conductivity():
    """
    Arrhenius plot and material comparison of ionic conductivity
    """
    # Parameters for each material
    materials_ionic = {
        'YSZ (8YSZ)': {'sigma_0': 2.5e4, 'E_a': 1.0, 'color': 'navy'},
        'GDC': {'sigma_0': 1.0e4, 'E_a': 0.7, 'color': 'green'},
        'LLZO': {'sigma_0': 1.0e2, 'E_a': 0.3, 'color': 'red'},
        'Œ≤-Al‚ÇÇO‚ÇÉ': {'sigma_0': 5.0e2, 'E_a': 0.16, 'color': 'purple'}
    }

    # Temperature range
    T_range = np.linspace(300, 1200, 500)  # K

    fig, axes = plt.subplots(1, 2, figsize=(14, 5))

    # Left plot: Arrhenius plot
    ax1 = axes[0]

    for name, params in materials_ionic.items():
        sigma = ionic_conductivity(T_range, params['sigma_0'], params['E_a'])
        ax1.semilogy(1e4 / T_range, sigma, linewidth=2, label=name, color=params['color'])

    ax1.set_xlabel('10^4 / T (K^-1)', fontsize=12)
    ax1.set_ylabel('Ionic Conductivity œÉ (S/cm)', fontsize=12)
    ax1.set_title('Arrhenius Plot for Ionic Conductors', fontsize=14, fontweight='bold')
    ax1.legend()
    ax1.grid(True, alpha=0.3, which='both')

    # Right plot: Conductivity comparison at actual temperatures
    ax2 = axes[1]

    temperatures_celsius = [400, 600, 800, 1000]
    x_pos = np.arange(len(temperatures_celsius))
    width = 0.2

    for i, (name, params) in enumerate(materials_ionic.items()):
        sigma_values = [ionic_conductivity(T + 273.15, params['sigma_0'], params['E_a'])
                       for T in temperatures_celsius]
        ax2.bar(x_pos + i * width, sigma_values, width, label=name, color=params['color'], edgecolor='black')

    ax2.set_xlabel('Temperature (¬∞C)', fontsize=12)
    ax2.set_ylabel('Ionic Conductivity œÉ (S/cm)', fontsize=12)
    ax2.set_title('Conductivity Comparison at Different Temperatures', fontsize=14, fontweight='bold')
    ax2.set_xticks(x_pos + width * 1.5)
    ax2.set_xticklabels(temperatures_celsius)
    ax2.set_yscale('log')
    ax2.legend()
    ax2.grid(True, alpha=0.3, which='both')

    plt.tight_layout()
    plt.savefig('ionic_conductivity.png', dpi=300, bbox_inches='tight')
    plt.show()

    # Numerical examples
    print("=== Ionic Conductivity at SOFC Operating Temperature (800¬∞C) ===")
    T_SOFC = 800 + 273.15
    for name, params in materials_ionic.items():
        sigma = ionic_conductivity(T_SOFC, params['sigma_0'], params['E_a'])
        print(f"{name:15s}: œÉ = {sigma:.4f} S/cm, E_a = {params['E_a']:.2f} eV")

# Execute
plot_ionic_conductivity()
</code></pre>
<h4>Python Implementation: Temperature Dependence of YSZ Ionic Conductivity</h4>
<pre><code class="language-python"># Requirements:
# - Python 3.9+
# - matplotlib&gt;=3.7.0
# - numpy&gt;=1.24.0, &lt;2.0.0

# ===================================
# Example 6: Detailed Analysis of YSZ Conductivity
# ===================================

import numpy as np
import matplotlib.pyplot as plt

def ysz_conductivity_vs_doping():
    """
    Relationship between Y‚ÇÇO‚ÇÉ doping level and conductivity in YSZ
    """
    # Y‚ÇÇO‚ÇÉ doping level (mol%)
    doping_levels = np.array([3, 5, 8, 10, 12, 15])

    # Conductivity at 800¬∞C (based on experimental data)
    sigma_800C = np.array([0.02, 0.06, 0.10, 0.08, 0.05, 0.03])

    # Activation energy
    E_a_values = np.array([1.1, 1.05, 1.0, 1.05, 1.15, 1.2])

    fig, axes = plt.subplots(1, 2, figsize=(14, 5))

    # Left plot: Doping level vs conductivity
    ax1 = axes[0]
    ax1.plot(doping_levels, sigma_800C, 'o-', linewidth=2, markersize=10, color='navy')
    ax1.axvline(x=8, color='red', linestyle='--', linewidth=2, label='Optimal: 8 mol%')

    ax1.set_xlabel('Y‚ÇÇO‚ÇÉ Content (mol%)', fontsize=12)
    ax1.set_ylabel('Ionic Conductivity œÉ (S/cm) @ 800¬∞C', fontsize=12)
    ax1.set_title('YSZ Conductivity vs Doping Level', fontsize=14, fontweight='bold')
    ax1.legend()
    ax1.grid(True, alpha=0.3)

    # Right plot: Temperature dependence (for each doping level)
    ax2 = axes[1]
    T_range = np.linspace(600, 1200, 100) + 273.15

    for i, doping in enumerate([5, 8, 10]):
        idx = np.where(doping_levels == doping)[0][0]
        sigma_0_calc = sigma_800C[idx] / np.exp(-E_a_values[idx] / (8.617e-5 * (800 + 273.15)))
        sigma_T = ionic_conductivity(T_range, sigma_0_calc, E_a_values[idx])

        ax2.semilogy(T_range - 273.15, sigma_T, linewidth=2, label=f'{doping} mol% Y‚ÇÇO‚ÇÉ')

    ax2.set_xlabel('Temperature (¬∞C)', fontsize=12)
    ax2.set_ylabel('Ionic Conductivity œÉ (S/cm)', fontsize=12)
    ax2.set_title('YSZ Conductivity vs Temperature', fontsize=14, fontweight='bold')
    ax2.legend()
    ax2.grid(True, alpha=0.3, which='both')

    plt.tight_layout()
    plt.savefig('ysz_conductivity_analysis.png', dpi=300, bbox_inches='tight')
    plt.show()

    # Numerical examples
    print("=== YSZ Doping Level Effects ===")
    for i, doping in enumerate(doping_levels):
        print(f"{doping:2d} mol% Y‚ÇÇO‚ÇÉ: œÉ(800¬∞C) = {sigma_800C[i]:.3f} S/cm, E_a = {E_a_values[i]:.2f} eV")

# Execute
ysz_conductivity_vs_doping()
</code></pre>
<div class="info-box">
<strong>Operating Principle of SOFC and Role of YSZ</strong>
                In SOFCs (Solid Oxide Fuel Cells), O¬≤‚Åª ions migrate through the YSZ electrolyte from the cathode to the anode, reacting with hydrogen to produce water. High-temperature operation at 800-1000¬∞C achieves conductivity above 0.1 S/cm, enabling high-efficiency power generation (45-60%).
            </div>
</section>
<section id="luminescence">
<h2>4.5 Luminescent Material Ceramics</h2>
<h3>4.5.1 Luminescence Mechanism of Phosphors</h3>
<p>
                Phosphors absorb excitation energy (electron beam, UV, blue LED) and emit visible light. Rare-earth ions (Ce¬≥‚Å∫, Eu¬≤‚Å∫, Eu¬≥‚Å∫, etc.) serving as luminescence centers are doped into host crystals (YAG, CaS, SrSiO‚ÇÖ, etc.).
            </p>
<p>
                Luminous efficiency (quantum efficiency) is:
            </p>
<p>
                \[
                \eta = \frac{\text{Number of emitted photons}}{\text{Number of absorbed photons}} \times 100\%
                \]
            </p>
<h3>4.5.2 YAG:Ce Phosphor for White LEDs</h3>
<p>
                YAG:Ce (Y‚ÇÉAl‚ÇÖO‚ÇÅ‚ÇÇ:Ce¬≥‚Å∫) is excited by blue LEDs (450-470 nm) and emits yellow light (500-650 nm). White light is achieved through color mixing with the blue light.
            </p>
<h4>Python Implementation: CIE Chromaticity Coordinate Calculation</h4>
<pre><code class="language-python"># Requirements:
# - Python 3.9+
# - matplotlib&gt;=3.7.0
# - numpy&gt;=1.24.0, &lt;2.0.0

# ===================================
# Example 7: CIE Chromaticity Coordinate Calculation
# ===================================

import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import simpson

def gaussian_emission_spectrum(wavelength, peak, fwhm, intensity=1.0):
    """
    Generate Gaussian emission spectrum

    Parameters:
    -----------
    wavelength : array
        Wavelength [nm]
    peak : float
        Peak wavelength [nm]
    fwhm : float
        Full width at half maximum (FWHM) [nm]
    intensity : float
        Intensity (arbitrary units)

    Returns:
    --------
    spectrum : array
        Emission intensity
    """
    sigma = fwhm / (2 * np.sqrt(2 * np.log(2)))
    spectrum = intensity * np.exp(-((wavelength - peak)**2) / (2 * sigma**2))
    return spectrum


def cie_xyz_from_spectrum(wavelength, spectrum):
    """
    Calculate CIE XYZ values from emission spectrum (simplified version)

    Parameters:
    -----------
    wavelength : array
        Wavelength [nm]
    spectrum : array
        Emission intensity

    Returns:
    --------
    X, Y, Z : float
        CIE tristimulus values
    """
    # Simplified model of CIE 1931 standard observer (actual implementation uses standard data)
    # Gaussian approximation for simplicity

    # xÃÑ(Œª): Red cone sensitivity (peak 600 nm)
    x_bar = gaussian_emission_spectrum(wavelength, 600, 50, 1.0)

    # »≥(Œª): Green cone sensitivity (peak 550 nm)
    y_bar = gaussian_emission_spectrum(wavelength, 550, 50, 1.0)

    # zÃÑ(Œª): Blue cone sensitivity (peak 450 nm)
    z_bar = gaussian_emission_spectrum(wavelength, 450, 50, 1.0)

    # Integration
    X = simpson(spectrum * x_bar, wavelength)
    Y = simpson(spectrum * y_bar, wavelength)
    Z = simpson(spectrum * z_bar, wavelength)

    return X, Y, Z


def plot_yag_ce_emission():
    """
    YAG:Ce emission spectrum and CIE chromaticity coordinates
    """
    # Wavelength range
    wavelength = np.linspace(380, 780, 400)

    # Blue LED (excitation light)
    blue_led = gaussian_emission_spectrum(wavelength, 460, 20, 1.0)

    # YAG:Ce emission (yellow)
    yag_ce_emission = gaussian_emission_spectrum(wavelength, 560, 100, 0.8)

    # Combined spectrum (white light)
    white_light = blue_led + yag_ce_emission

    fig, axes = plt.subplots(1, 2, figsize=(14, 5))

    # Left plot: Emission spectrum
    ax1 = axes[0]
    ax1.fill_between(wavelength, 0, blue_led, alpha=0.5, color='blue', label='Blue LED (460 nm)')
    ax1.fill_between(wavelength, 0, yag_ce_emission, alpha=0.5, color='yellow', label='YAG:Ce (560 nm)')
    ax1.plot(wavelength, white_light, 'k-', linewidth=2, label='White Light (combined)')

    ax1.set_xlabel('Wavelength (nm)', fontsize=12)
    ax1.set_ylabel('Intensity (a.u.)', fontsize=12)
    ax1.set_title('YAG:Ce White LED Emission Spectrum', fontsize=14, fontweight='bold')
    ax1.set_xlim(380, 780)
    ax1.legend()
    ax1.grid(True, alpha=0.3)

    # Right plot: CIE 1931 chromaticity diagram (simplified version)
    ax2 = axes[1]

    # Calculate CIE chromaticity coordinates
    X_blue, Y_blue, Z_blue = cie_xyz_from_spectrum(wavelength, blue_led)
    x_blue = X_blue / (X_blue + Y_blue + Z_blue)
    y_blue = Y_blue / (X_blue + Y_blue + Z_blue)

    X_yellow, Y_yellow, Z_yellow = cie_xyz_from_spectrum(wavelength, yag_ce_emission)
    x_yellow = X_yellow / (X_yellow + Y_yellow + Z_yellow)
    y_yellow = Y_yellow / (X_yellow + Y_yellow + Z_yellow)

    X_white, Y_white, Z_white = cie_xyz_from_spectrum(wavelength, white_light)
    x_white = X_white / (X_white + Y_white + Z_white)
    y_white = Y_white / (X_white + Y_white + Z_white)

    # Plot
    ax2.scatter(x_blue, y_blue, s=200, c='blue', marker='o', edgecolors='black', linewidth=2, label='Blue LED')
    ax2.scatter(x_yellow, y_yellow, s=200, c='yellow', marker='s', edgecolors='black', linewidth=2, label='YAG:Ce')
    ax2.scatter(x_white, y_white, s=250, c='white', marker='*', edgecolors='black', linewidth=2, label='White Light', zorder=5)

    # Color temperature line (simplified)
    blackbody_x = np.array([0.45, 0.40, 0.35, 0.31])
    blackbody_y = np.array([0.41, 0.40, 0.38, 0.33])
    ax2.plot(blackbody_x, blackbody_y, 'k--', linewidth=1, alpha=0.5, label='Blackbody Locus')

    ax2.set_xlabel('CIE x', fontsize=12)
    ax2.set_ylabel('CIE y', fontsize=12)
    ax2.set_title('CIE 1931 Chromaticity Diagram', fontsize=14, fontweight='bold')
    ax2.set_xlim(0, 0.8)
    ax2.set_ylim(0, 0.9)
    ax2.legend()
    ax2.grid(True, alpha=0.3)

    plt.tight_layout()
    plt.savefig('yag_ce_emission.png', dpi=300, bbox_inches='tight')
    plt.show()

    # Numerical results
    print("=== CIE Chromaticity Coordinates ===")
    print(f"Blue LED:  (x, y) = ({x_blue:.3f}, {y_blue:.3f})")
    print(f"YAG:Ce:    (x, y) = ({x_yellow:.3f}, {y_yellow:.3f})")
    print(f"White Light: (x, y) = ({x_white:.3f}, {y_white:.3f})")
    print(f"\nColor Temperature: ~5000-6000 K (cool white)")

# Execute
plot_yag_ce_emission()
</code></pre>
<div class="info-box">
<strong>White LED Phosphor Design</strong>
                YAG:Ce alone is insufficient for ideal white light (color temperature 5000 K, color rendering index Ra &gt; 80). By adding CaAlSiN‚ÇÉ:Eu¬≤‚Å∫ (nitride red phosphor) to supplement the red component, color rendering index Ra &gt; 90 can be achieved.
            </div>
</section>
<section id="magnetic">
<h2>4.6 Magnetic Ceramics</h2>
<h3>4.6.1 Magnetism of Ferrites</h3>
<p>
                Ferrites are oxide magnetic materials with the general formula MFe‚ÇÇO‚ÇÑ (M = Mn, Ni, Zn, Co). They have spinel structure and exhibit ferrimagnetism. Due to high electrical resistance (&gt;10‚Å∂ Œ©¬∑cm), they are suitable for high-frequency applications.
            </p>
<h3>4.6.2 Key Property Parameters</h3>
<ul>
<li><strong>Saturation magnetization M<sub>s</sub></strong>: Maximum magnetization (T = Tesla)</li>
<li><strong>Coercivity H<sub>c</sub></strong>: Magnetic field to reverse magnetization (A/m)</li>
<li><strong>Permeability Œº<sub>r</sub></strong>: Magnetic permeability (dimensionless)</li>
<li><strong>Curie temperature T<sub>c</sub></strong>: Ferromagnetic ‚Üí paramagnetic transition temperature (¬∞C)</li>
</ul>
<table>
<thead>
<tr>
<th>Material</th>
<th>M<sub>s</sub> (T)</th>
<th>H<sub>c</sub> (A/m)</th>
<th>Œº<sub>r</sub></th>
<th>Applications</th>
</tr>
</thead>
<tbody>
<tr>
<td>MnZn-ferrite</td>
<td>0.35</td>
<td>10-20</td>
<td>2000-5000</td>
<td>Transformer cores</td>
</tr>
<tr>
<td>NiZn-ferrite</td>
<td>0.30</td>
<td>15-30</td>
<td>100-1000</td>
<td>High-frequency cores</td>
</tr>
<tr>
<td>BaFe‚ÇÅ‚ÇÇO‚ÇÅ‚Çâ (M-type)</td>
<td>0.48</td>
<td>200k-400k</td>
<td>1.1</td>
<td>Permanent magnets</td>
</tr>
<tr>
<td>CoFe‚ÇÇO‚ÇÑ</td>
<td>0.53</td>
<td>5k-10k</td>
<td>10-50</td>
<td>Magnetic recording</td>
</tr>
</tbody>
</table>
<h4>Python Implementation: Ferrite Magnetization Property Simulation</h4>
<pre><code class="language-python"># Requirements:
# - Python 3.9+
# - matplotlib&gt;=3.7.0
# - numpy&gt;=1.24.0, &lt;2.0.0

# ===================================
# Example 8: Ferrite Magnetization Curves
# ===================================

import numpy as np
import matplotlib.pyplot as plt

def langevin_function(x):
    """
    Langevin function (paramagnetic magnetization)

    Parameters:
    -----------
    x : float or array
        Argument (ŒºH/kT)

    Returns:
    --------
    L(x) : float or array
        Langevin function value
    """
    # Avoid divergence for small x
    with np.errstate(divide='ignore', invalid='ignore'):
        L = np.where(np.abs(x) &lt; 1e-3, x / 3, 1 / np.tanh(x) - 1 / x)
    return L


def ferrite_magnetization_curve(H, M_s=0.35, H_c=15, a=1000):
    """
    Ferrite magnetization curve (simplified model)

    Parameters:
    -----------
    H : array
        Magnetic field [A/m]
    M_s : float
        Saturation magnetization [T]
    H_c : float
        Coercivity [A/m]
    a : float
        Shape parameter

    Returns:
    --------
    M : array
        Magnetization [T]
    """
    # tanh-based simplified model
    M = M_s * np.tanh((H - H_c) / a) if isinstance(H, (int, float)) else \
        M_s * np.tanh((H - H_c) / a)
    return M


def plot_ferrite_properties():
    """
    Visualize ferrite magnetic properties
    """
    # Magnetic field range
    H_range = np.linspace(-5000, 5000, 1000)

    fig, axes = plt.subplots(1, 2, figsize=(14, 5))

    # Left plot: Soft magnetic ferrite (MnZn)
    ax1 = axes[0]

    M_s_soft = 0.35
    H_c_soft = 15
    M_soft = M_s_soft * np.tanh(H_range / 500)

    ax1.plot(H_range, M_soft, linewidth=2, color='navy')
    ax1.axhline(y=M_s_soft, color='red', linestyle='--', linewidth=1, alpha=0.5, label=f'M_s = {M_s_soft} T')
    ax1.axhline(y=-M_s_soft, color='red', linestyle='--', linewidth=1, alpha=0.5)
    ax1.axvline(x=0, color='black', linestyle='-', linewidth=0.5)
    ax1.axhline(y=0, color='black', linestyle='-', linewidth=0.5)

    ax1.set_xlabel('Magnetic Field H (A/m)', fontsize=12)
    ax1.set_ylabel('Magnetization M (T)', fontsize=12)
    ax1.set_title('Soft Ferrite (MnZn) M-H Curve', fontsize=14, fontweight='bold')
    ax1.legend()
    ax1.grid(True, alpha=0.3)

    # Right plot: Hard magnetic ferrite (BaFe‚ÇÅ‚ÇÇO‚ÇÅ‚Çâ)
    ax2 = axes[1]

    M_s_hard = 0.48
    H_c_hard = 250000  # 250 kA/m
    H_hard = np.linspace(-400000, 400000, 1000)
    M_hard = M_s_hard * np.tanh((H_hard - H_c_hard) / 50000)

    # Hysteresis loop approximation
    M_hard_up = M_s_hard * np.tanh((H_hard + H_c_hard) / 50000)
    M_hard_down = M_s_hard * np.tanh((H_hard - H_c_hard) / 50000)

    ax2.plot(H_hard / 1000, M_hard_up, linewidth=2, color='blue', label='Ascending')
    ax2.plot(H_hard / 1000, M_hard_down, linewidth=2, color='red', label='Descending')
    ax2.axvline(x=H_c_hard / 1000, color='green', linestyle='--', linewidth=2, label=f'H_c = {H_c_hard/1000:.0f} kA/m')
    ax2.axvline(x=-H_c_hard / 1000, color='green', linestyle='--', linewidth=2)

    ax2.set_xlabel('Magnetic Field H (kA/m)', fontsize=12)
    ax2.set_ylabel('Magnetization M (T)', fontsize=12)
    ax2.set_title('Hard Ferrite (BaFe‚ÇÅ‚ÇÇO‚ÇÅ‚Çâ) Hysteresis Loop', fontsize=14, fontweight='bold')
    ax2.legend()
    ax2.grid(True, alpha=0.3)

    plt.tight_layout()
    plt.savefig('ferrite_magnetization.png', dpi=300, bbox_inches='tight')
    plt.show()

    # Numerical examples
    print("=== Ferrite Magnetic Properties ===")
    print("\nSoft Ferrite (MnZn):")
    print(f"  M_s = {M_s_soft} T, H_c = {H_c_soft} A/m")
    print(f"  Application: High permeability (Œº_r ~ 2000-5000), transformer cores")

    print("\nHard Ferrite (BaFe‚ÇÅ‚ÇÇO‚ÇÅ‚Çâ):")
    print(f"  M_s = {M_s_hard} T, H_c = {H_c_hard/1000} kA/m")
    print(f"  Application: Permanent magnets, motors, speakers")

# Execute
plot_ferrite_properties()
</code></pre>
<div class="warning-box">
<strong>Application Separation of Soft and Hard Magnetics</strong>
                Soft ferrites (low H<sub>c</sub>, high Œº<sub>r</sub>) are used in transformers and inductors because magnetization easily reverses. In contrast, hard ferrites (high H<sub>c</sub>) have stable magnetization and function as permanent magnets. Both types are controlled by composition (Mn/Zn vs Ba/Sr) and sintering conditions.
            </div>
</section>
<section id="exercises">
<h2>Exercises</h2>
<div class="exercise-box">
<h4>Exercise 4-1: Application of Clausius-Mossotti Equation<span class="difficulty easy">Easy</span></h4>
<p>
                    Calculate the relative permittivity Œµ<sub>r</sub> of TiO‚ÇÇ given polarizability Œ± = 2.5√ó10‚Åª‚Å¥‚Å∞ C¬∑m¬≤/V and ion density N = 5√ó10¬≤‚Å∏ m‚Åª¬≥.
                </p>
<details>
<summary>Solution Example</summary>
<pre><code class="language-python">alpha = 2.5e-40
N = 5e28
epsilon_r = clausius_mossotti_permittivity(alpha, N)
print(f"Œµ·µ£ = {epsilon_r:.1f}")
# Output: Œµ·µ£ ‚âà 80
</code></pre>
</details>
</div>
<div class="exercise-box">
<h4>Exercise 4-2: MLCC Capacitance Design<span class="difficulty easy">Easy</span></h4>
<p>
                    Design a 1 ŒºF MLCC. Given Œµ<sub>r</sub>=3000, electrode area 1 mm¬≤, and layer thickness 5 Œºm, calculate the required number of layers n.
                </p>
<details>
<summary>Solution Example</summary>
<pre><code class="language-python">C_target = 1e-6  # 1 ŒºF
epsilon_r = 3000
A = (1e-3)**2
d = 5e-6
epsilon_0 = 8.854e-12

n = (C_target * d) / (epsilon_0 * epsilon_r * A)
print(f"Required number of layers n = {n:.0f}")
# Output: n ‚âà 377 layers
</code></pre>
</details>
</div>
<div class="exercise-box">
<h4>Exercise 4-3: Piezoelectric Displacement Calculation<span class="difficulty easy">Easy</span></h4>
<p>
                    Calculate the displacement of a 1 mm thick specimen when an electric field of 1 MV/m is applied to PZT-5H (d‚ÇÉ‚ÇÉ = 593 pC/N).
                </p>
<details>
<summary>Solution Example</summary>
<pre><code class="language-python">d_33 = 593e-12
E = 1e6
thickness = 1e-3

strain = piezoelectric_strain(d_33, E)
displacement = strain * thickness
print(f"Displacement = {displacement*1e9:.1f} nm")
# Output: Displacement ‚âà 593 nm
</code></pre>
</details>
</div>
<div class="exercise-box">
<h4>Exercise 4-4: Estimation of Arrhenius Activation Energy<span class="difficulty medium">Medium</span></h4>
<p>
                    The conductivity of YSZ was 0.05 S/cm at 700¬∞C and 0.15 S/cm at 900¬∞C. Determine the activation energy E<sub>a</sub>.
                </p>
<details>
<summary>Solution Example</summary>
<pre><code class="language-python">T1 = 700 + 273.15
T2 = 900 + 273.15
sigma1 = 0.05
sigma2 = 0.15
k_B = 8.617e-5

# ln(œÉ‚ÇÇ/œÉ‚ÇÅ) = -E_a/k_B √ó (1/T‚ÇÇ - 1/T‚ÇÅ)
E_a = -k_B * np.log(sigma2 / sigma1) / (1/T2 - 1/T1)
print(f"E_a = {E_a:.2f} eV")
# Output: E_a ‚âà 0.95 eV
</code></pre>
</details>
</div>
<div class="exercise-box">
<h4>Exercise 4-5: White LED Color Temperature Adjustment<span class="difficulty medium">Medium</span></h4>
<p>
                    Explain how to adjust the color temperature from 4000 K (warm white) to 6500 K (cool white) by varying the intensity ratio of blue LED (460 nm) and YAG:Ce (560 nm).
                </p>
<details>
<summary>Solution Example</summary>
<pre><code class="language-python"># To increase color temperature (cool white), increase blue component
# Reduce YAG:Ce emission intensity or make YAG:Ce layer thinner

# 4000 K: Blue/Yellow = 1.0
# 6500 K: Blue/Yellow = 1.5

print("To increase color temperature:")
print("1. Make YAG:Ce phosphor layer thinner (reduce yellow)")
print("2. Reduce YAG:Ce concentration")
print("3. Increase blue LED output")
</code></pre>
</details>
</div>
<div class="exercise-box">
<h4>Exercise 4-6: PZT Composition Optimization<span class="difficulty medium">Medium</span></h4>
<p>
                    Run a simulation to find the composition (MPB) where d‚ÇÉ‚ÇÉ is maximized by varying the Zr/Ti ratio in PZT.
                </p>
<details>
<summary>Solution Example</summary>
<pre><code class="language-python">x_Zr = np.linspace(0, 1, 100)
x_MPB = 0.52
d_33 = 200 + 400 * np.exp(-((x_Zr - x_MPB) / 0.1)**2)

max_idx = np.argmax(d_33)
print(f"Optimal composition: x_Zr = {x_Zr[max_idx]:.2f}")
print(f"Maximum d‚ÇÉ‚ÇÉ = {d_33[max_idx]:.0f} pC/N")
# Output: x_Zr = 0.52, d‚ÇÉ‚ÇÉ ‚âà 600 pC/N
</code></pre>
</details>
</div>
<div class="exercise-box">
<h4>Exercise 4-7: Frequency Dependence of Ferrite Permeability<span class="difficulty medium">Medium</span></h4>
<p>
                    The permeability of MnZn ferrite decreases from 3000 at 1 kHz to 500 at 1 MHz. Explain the cause of this frequency dependence.
                </p>
<details>
<summary>Solution Example</summary>
<pre><code class="language-python">print("Causes of frequency dependence:")
print("1. Eddy current loss (low resistivity)")
print("2. Delayed domain wall motion (domain walls cannot follow at high frequency)")
print("3. Spin rotation resonance (ferrimagnetic resonance frequency)")
print("\nCountermeasure: Switch to NiZn ferrite (high resistance)")
</code></pre>
</details>
</div>
<div class="exercise-box">
<h4>Exercise 4-8: SOFC Electrolyte Thickness Optimization<span class="difficulty hard">Hard</span></h4>
<p>
                    The resistance R of YSZ electrolyte is R = œÅ √ó L / A (œÅ: resistivity, L: thickness, A: area). Given conductivity 0.1 S/cm at 800¬∞C and area 10 cm¬≤, find the maximum thickness to keep resistance below 0.1 Œ©.
                </p>
<details>
<summary>Solution Example</summary>
<pre><code class="language-python">sigma = 0.1  # S/cm = 10 S/m
rho = 1 / sigma  # Œ©¬∑m
A = 10e-4  # m¬≤
R_target = 0.1  # Œ©

L_max = R_target * A / rho
print(f"Maximum thickness L = {L_max*1e6:.0f} Œºm")
# Output: L ‚âà 100 Œºm
# In actual SOFCs, 10-50 Œºm is typical
</code></pre>
</details>
</div>
<div class="exercise-box">
<h4>Exercise 4-9: Piezoelectric Energy Harvesting<span class="difficulty hard">Hard</span></h4>
<p>
                    A PZT element (d‚ÇÉ‚ÇÉ = 300 pC/N, area 10 cm¬≤) is subjected to a periodic load of 100 N at 10 Hz. Estimate the generated power (simplified calculation).
                </p>
<details>
<summary>Solution Example</summary>
<pre><code class="language-python">d_33 = 300e-12
F = 100  # N
A = 10e-4  # m¬≤
f = 10  # Hz
epsilon_r = 1300
epsilon_0 = 8.854e-12

# Generated charge Q = d‚ÇÉ‚ÇÉ √ó F
Q = d_33 * F
print(f"Generated charge Q = {Q*1e9:.1f} nC")

# Capacitance C = Œµ‚ÇÄŒµ·µ£A/d (assuming 1 mm thickness)
d = 1e-3
C = epsilon_0 * epsilon_r * A / d
V = Q / C
print(f"Voltage V = {V:.1f} V")

# Power P = 0.5 √ó C √ó V¬≤ √ó f
P = 0.5 * C * V**2 * f
print(f"Power P = {P*1e6:.1f} ŒºW")
# Example output: ~10-100 ŒºW (practical level requires mW)
</code></pre>
</details>
</div>
<div class="exercise-box">
<h4>Exercise 4-10: Multilayer Phosphor Design<span class="difficulty hard">Hard</span></h4>
<p>
                    To achieve high color rendering white LEDs (Ra &gt; 90), design a two-layer phosphor with YAG:Ce (yellow) and CaAlSiN‚ÇÉ:Eu (red). Describe the strategy for optimizing the thickness ratio and emission intensity ratio of each layer.
                </p>
<details>
<summary>Solution Example</summary>
<pre><code class="language-python">print("Design strategy:")
print("1. YAG:Ce layer (yellow): 550 nm emission with blue LED excitation")
print("2. CaAlSiN‚ÇÉ:Eu layer (red): 630 nm emission with blue excitation")
print("3. Thickness ratio: YAG:Ce = 80%, red phosphor = 20%")
print("4. Emission intensity ratio: Blue:Yellow:Red = 30:50:20")
print("5. Adjust CIE chromaticity coordinates to (0.33, 0.33)")
print("6. Confirm color rendering index Ra &gt; 90 (R9 red component is critical)")
print("\nOptimization algorithm:")
print("- Monte Carlo optimization with thickness and concentration as parameters")
print("- Objective function: Maximize Ra &amp; color temperature constraint 5000-6500K")
</code></pre>
</details>
</div>
</section>
<section id="references">
<h2>References</h2>
<ol>
<li>Moulson, A.J., Herbert, J.M. (2003). <em>Electroceramics: Materials, Properties, Applications</em>. Wiley, pp. 1-85, 155-210, 340-395.</li>
<li>Jaffe, B., Cook, W.R., Jaffe, H. (1971). <em>Piezoelectric Ceramics</em>. Academic Press, pp. 50-135.</li>
<li>Tuller, H.L. (2000). Ionic conduction in nanocrystalline materials. <em>Solid State Ionics</em>, 131, 15-68.</li>
<li>Ronda, C.R. (2008). <em>Luminescence: From Theory to Applications</em>. Wiley-VCH, pp. 120-180.</li>
<li>Blasse, G., Grabmaier, B.C. (1994). <em>Luminescent Materials</em>. Springer, pp. 1-65.</li>
<li>Goldman, A. (2006). <em>Modern Ferrite Technology</em>. Springer, pp. 30-95.</li>
<li>Setter, N. (2002). <em>Piezoelectric Materials in Devices</em>. EPFL Swiss Federal Institute of Technology, pp. 1-50, 200-250.</li>
</ol>
</section>
<section class="disclaimer">
<h3>Disclaimer</h3>
<ul>
<li>This content is provided solely for educational, research, and informational purposes and does not constitute professional advice (legal, accounting, technical warranty, etc.).</li>
<li>This content and accompanying code examples are provided "AS IS" without any warranty, express or implied, including but not limited to merchantability, fitness for a particular purpose, non-infringement, accuracy, completeness, operation, or safety.</li>
<li>The author and Tohoku University assume no responsibility for the content, availability, or safety of external links, third-party data, tools, libraries, etc.</li>
<li>To the maximum extent permitted by applicable law, the author and Tohoku University shall not be liable for any direct, indirect, incidental, special, consequential, or punitive damages arising from the use, execution, or interpretation of this content.</li>
<li>The content may be changed, updated, or discontinued without notice.</li>
<li>The copyright and license of this content are subject to the stated conditions (e.g., CC BY 4.0). Such licenses typically include no-warranty clauses.</li>
</ul>
</section>

</main>
<footer>
<p>¬© 2025 MS Dojo - Materials Science Education</p>
<p><a href="index.html">Return to Ceramic Materials Introduction Top</a> | <a href="../../MS/">MS Field Top</a></p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
<script>
        mermaid.initialize({ startOnLoad: true, theme: 'base' });
    </script>
</body>
</html>
