<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Chapter 4: Principles and Applications of X-ray Diffraction - MS Terakoya</title>
<link href="../../assets/css/knowledge-base.css" rel="stylesheet"/>
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet"/>
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet"/>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
<script>
        mermaid.initialize({
            startOnLoad: true,
            theme: 'default',
            flowchart: {
                useMaxWidth: true,
                htmlLabels: true,
                curve: 'basis'
            }
        });
    </script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true,
                processEnvironments: true
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
            }
        };
    </script>
</head>
<body>
<header>
<div class="header-content">
<h1>Chapter 4: Principles and Applications of X-ray Diffraction</h1>
<p class="subtitle">From Bragg's Law to Measured Data Analysis</p>
<div class="meta">
<span class="meta-item">üìñ Estimated Study Time: 30 minutes</span>
<span class="meta-item">üéØ Difficulty: Intermediate</span>
<span class="meta-item">üíª Code Examples: 8</span>
</div>
</div>
</header>
<div class="breadcrumb">
<a href="../index.html">AI Terakoya Top</a> &gt;
        <a href="../index.html">MS Dojo</a> &gt;
        <a href="index.html">Introduction to Crystallography</a> &gt;
        Chapter 4
    </div>
<div class="container">
<div class="learning-objectives">
<h2>Learning Objectives</h2>
<p>By studying this chapter, you will acquire the following knowledge and skills:</p>
<ul>
<li>Understand the fundamentals of <strong>X-ray and matter interactions</strong></li>
<li>Derive <strong>Bragg's Law nŒª = 2d sinŒ∏</strong> and explain its physical meaning</li>
<li>Calculate the <strong>structure factor F<sub>hkl</sub></strong> and understand its influence on diffraction intensity</li>
<li>Estimate crystal structures from <strong>systematic absences (extinction rules)</strong></li>
<li>Interpret <strong>powder X-ray diffraction patterns</strong> and identify peaks</li>
<li>Understand the fundamental concepts of <strong>Rietveld analysis</strong></li>
<li>Analyze <strong>measured XRD data</strong> using Python</li>
</ul>
</div>
<h2>1. Interaction of X-rays with Crystals</h2>
<h3>1.1 What Are X-rays?</h3>
<p>
<strong>X-rays</strong> are electromagnetic waves with wavelengths ranging from approximately 0.01 to 10 nm (10 √Ö).
            In materials science, primarily <strong>Cu KŒ± radiation (Œª = 1.5406 √Ö)</strong> and <strong>Mo KŒ± radiation (Œª = 0.7107 √Ö)</strong> are used.
        </p>
<p>Since the wavelength of X-rays is on the same order as interatomic distances (several √Ö), <strong>diffraction phenomena</strong> occur due to crystal lattices.</p>
<div class="info-box">
<h4>Major X-ray Sources</h4>
<table>
<thead>
<tr>
<th>X-ray Source</th>
<th>Wavelength (√Ö)</th>
<th>Energy (keV)</th>
<th>Primary Applications</th>
</tr>
</thead>
<tbody>
<tr>
<td>Cu KŒ±</td>
<td>1.5406</td>
<td>8.05</td>
<td>Powder XRD, general structure analysis</td>
</tr>
<tr>
<td>Mo KŒ±</td>
<td>0.7107</td>
<td>17.48</td>
<td>Single crystal XRD, when short wavelength needed</td>
</tr>
<tr>
<td>Co KŒ±</td>
<td>1.7902</td>
<td>6.93</td>
<td>Iron-containing samples (avoiding fluorescence)</td>
</tr>
<tr>
<td>Synchrotron</td>
<td>Variable</td>
<td>Variable</td>
<td>High-brilliance, high-resolution measurements</td>
</tr>
</tbody>
</table>
</div>
<h3>1.2 Basic Principles of X-ray Diffraction</h3>
<p>When X-rays enter a crystal, the following process occurs:</p>
<div class="mermaid">
            flowchart TD
                A[X-ray incidence] --&gt; B[Scattering by each atom]
                B --&gt; C{Interference of scattered waves}
                C --&gt;|Phases aligned| D[Constructive interference: diffraction peak]
                C --&gt;|Phases misaligned| E[Destructive interference: extinction]
                D --&gt; F[Peak observation at detector]
                E --&gt; G[Background]

                style A fill:#e3f2fd
                style B fill:#e3f2fd
                style C fill:#fff3e0
                style D fill:#e8f5e9
                style E fill:#ffebee
                style F fill:#e8f5e9
                style G fill:#ffebee
        </div>
<p>
            Each atom in the crystal scatters X-rays, and the scattered waves <strong>interfere</strong>.
            When the phases of scattered waves align at specific angles, they <strong>constructively interfere</strong>, observed as <strong>diffraction peaks</strong>.
        </p>
<h2>2. Bragg's Law</h2>
<h3>2.1 Derivation of Bragg's Law</h3>
<p>
            In 1913, William Lawrence Bragg and his father William Henry Bragg proposed a simple yet powerful model that treats X-ray diffraction as <strong>specular reflection from crystal planes</strong>.
        </p>
<div class="info-box">
<h4>Bragg's Law</h4>
<div class="formula-block">
                $$
                n\lambda = 2d_{hkl}\sin\theta
                $$
            </div>
<p>Where:</p>
<ul>
<li><strong>n</strong>: order of reflection (typically 1)</li>
<li><strong>Œª</strong>: X-ray wavelength</li>
<li><strong>d<sub>hkl</sub></strong>: interplanar spacing of (hkl) plane</li>
<li><strong>Œ∏</strong>: Bragg angle (angle of incidence = angle of reflection)</li>
</ul>
</div>
<h4>Derivation Concept</h4>
<p>
            Consider X-rays incident at angle Œ∏ on crystal planes spaced at distance d.
            If the <strong>path difference</strong> between waves reflected from the upper and lower planes equals an integer multiple of wavelength Œª,
            constructive interference occurs.
        </p>
<p>The path difference is geometrically calculated as:</p>
<div class="formula-block">
            $$
            \text{Path difference} = 2d\sin\theta
            $$
        </div>
<p>The condition for constructive interference is:</p>
<div class="formula-block">
            $$
            2d\sin\theta = n\lambda \quad (n = 1, 2, 3, \ldots)
            $$
        </div>
<div class="warning-box">
<h4>Important Note</h4>
<p>
                Bragg's law is a <strong>necessary condition</strong> for diffraction to occur, but <strong>not sufficient</strong>.
                In practice, the <strong>structure factor F<sub>hkl</sub></strong> must also be non-zero (discussed later).
            </p>
</div>
<h3>2.2 Calculations Using Bragg's Law</h3>
<div class="example-box">
<h4>Code Example 1: Calculating Bragg Angles</h4>
<p>Calculate diffraction angles from major crystal planes of silicon (Si):</p>
</div>
<pre class="line-numbers"><code class="language-python">import numpy as np
import matplotlib.pyplot as plt

def cubic_d_spacing(a, h, k, l):
    """
    Calculate interplanar spacing for cubic crystal

    Parameters:
    -----------
    a : float
        Lattice parameter (√Ö)
    h, k, l : int
        Miller indices

    Returns:
    --------
    float : Interplanar spacing (√Ö)
    """
    return a / np.sqrt(h**2 + k**2 + l**2)

def bragg_angle(d_hkl, wavelength, n=1):
    """
    Calculate diffraction angle 2Œ∏ from Bragg's law

    Parameters:
    -----------
    d_hkl : float
        Interplanar spacing (√Ö)
    wavelength : float
        X-ray wavelength (√Ö)
    n : int
        Order of reflection

    Returns:
    --------
    float : Diffraction angle 2Œ∏ (degrees), or None if diffraction not possible
    """
    sin_theta = n * wavelength / (2 * d_hkl)
    if abs(sin_theta) &gt; 1:
        return None  # Diffraction condition not satisfied
    theta = np.arcsin(sin_theta)
    return np.degrees(2 * theta)  # Return 2Œ∏

# Silicon (Si) parameters
a_Si = 5.4310  # √Ö
wavelength_CuKa = 1.5406  # √Ö

print("=== X-ray Diffraction Pattern Prediction for Silicon (Si) ===")
print(f"Lattice parameter: a = {a_Si} √Ö")
print(f"X-ray wavelength: Œª = {wavelength_CuKa} √Ö (Cu KŒ±)\n")

# Major crystal planes
planes = [
    (1, 1, 1), (2, 2, 0), (3, 1, 1),
    (4, 0, 0), (3, 3, 1), (4, 2, 2)
]

print(f"{'(hkl)':&lt;10} {'d (√Ö)':&lt;12} {'2Œ∏ (deg)':&lt;12}")
print("-" * 40)

results = []
for hkl in planes:
    h, k, l = hkl
    d = cubic_d_spacing(a_Si, h, k, l)
    two_theta = bragg_angle(d, wavelength_CuKa)

    if two_theta is not None:
        print(f"({h}{k}{l}){'':&lt;8} {d:8.4f}    {two_theta:8.3f}")
        results.append((hkl, two_theta))

# Visualize peak pattern in graph
fig, ax = plt.subplots(figsize=(12, 6))

for (h, k, l), two_theta in results:
    ax.axvline(two_theta, color='red', linewidth=2, alpha=0.7)
    ax.text(two_theta, 1.05, f'({h}{k}{l})',
            rotation=90, va='bottom', ha='right', fontsize=9)

ax.set_xlim(20, 100)
ax.set_ylim(0, 1.2)
ax.set_xlabel('2Œ∏ (degrees)', fontsize=14, fontweight='bold')
ax.set_ylabel('Relative Intensity (arbitrary units)', fontsize=14, fontweight='bold')
ax.set_title('Theoretical XRD Pattern of Silicon (Si)', fontsize=16, fontweight='bold')
ax.grid(axis='x', alpha=0.3)

plt.tight_layout()
plt.savefig('si_xrd_pattern.png', dpi=150, bbox_inches='tight')
plt.show()
print("\nXRD pattern saved: si_xrd_pattern.png")
</code></pre>
<h3>2.3 Relationship Between Wavelength and Diffraction Angle</h3>
<div class="example-box">
<h4>Code Example 2: Comparing Diffraction Patterns with Different X-ray Sources</h4>
<p>Compare how diffraction angles change for the same crystal plane with Cu KŒ± and Mo KŒ± radiation:</p>
</div>
<pre class="line-numbers"><code class="language-python">def compare_xray_sources():
    """Compare diffraction patterns with different X-ray sources"""

    # X-ray source parameters
    sources = {
        'Cu KŒ±': 1.5406,
        'Mo KŒ±': 0.7107,
        'Co KŒ±': 1.7902
    }

    # Aluminum (Al) parameters
    a_Al = 4.0495  # √Ö
    planes = [(1, 1, 1), (2, 0, 0), (2, 2, 0), (3, 1, 1)]

    print("=== Comparison of Diffraction Angles with Different X-ray Sources (Al) ===\n")
    print(f"Lattice parameter: a = {a_Al} √Ö\n")

    # Calculations for each X-ray source
    fig, ax = plt.subplots(figsize=(14, 8))
    colors = {'Cu KŒ±': 'red', 'Mo KŒ±': 'blue', 'Co KŒ±': 'green'}

    for source_name, wavelength in sources.items():
        print(f"--- {source_name} (Œª = {wavelength} √Ö) ---")
        print(f"{'(hkl)':&lt;10} {'d (√Ö)':&lt;12} {'2Œ∏ (deg)':&lt;12}")
        print("-" * 40)

        y_offset = list(sources.keys()).index(source_name) * 0.3

        for hkl in planes:
            h, k, l = hkl
            d = cubic_d_spacing(a_Al, h, k, l)
            two_theta = bragg_angle(d, wavelength)

            if two_theta is not None:
                print(f"({h}{k}{l}){'':&lt;8} {d:8.4f}    {two_theta:8.3f}")

                # Display as bar graph
                ax.plot([two_theta, two_theta], [y_offset, y_offset + 0.25],
                       color=colors[source_name], linewidth=3)
                if y_offset == 0:  # Display labels only for first source
                    ax.text(two_theta, y_offset + 0.28, f'({h}{k}{l})',
                           rotation=90, va='bottom', ha='center', fontsize=8)
        print()

    # Graph decoration
    ax.set_xlim(0, 150)
    ax.set_ylim(-0.1, 1.0)
    ax.set_xlabel('2Œ∏ (degrees)', fontsize=14, fontweight='bold')
    ax.set_yticks([0.125, 0.425, 0.725])
    ax.set_yticklabels(['Cu KŒ±', 'Mo KŒ±', 'Co KŒ±'])
    ax.set_title('Comparison of Aluminum (Al) Diffraction Patterns with Different X-ray Sources',
                fontsize=16, fontweight='bold')
    ax.grid(axis='x', alpha=0.3)

    # Legend
    from matplotlib.lines import Line2D
    legend_elements = [Line2D([0], [0], color=color, lw=3, label=name)
                      for name, color in colors.items()]
    ax.legend(handles=legend_elements, loc='upper right', fontsize=12)

    plt.tight_layout()
    plt.savefig('xray_source_comparison.png', dpi=150, bbox_inches='tight')
    plt.show()
    print("Comparison graph saved: xray_source_comparison.png")

# Execute
compare_xray_sources()
</code></pre>
<div class="info-box">
<h4>Practical Considerations for Wavelength Selection</h4>
<ul>
<li><strong>Short wavelength (Mo KŒ±)</strong>: Can measure to high angles, less absorption, advantageous for single crystal analysis</li>
<li><strong>Long wavelength (Cu KŒ±)</strong>: Higher resolution at low angles, most commonly used</li>
<li><strong>Sample dependent</strong>: Use Co KŒ± for iron-containing samples (to avoid fluorescence)</li>
</ul>
</div>
<h2>3. Structure Factor and Diffraction Intensity</h2>
<h3>3.1 What is the Structure Factor F<sub>hkl</sub>?</h3>
<p>
            Even if Bragg's law is satisfied, not all reflections are observed.
            The <strong>structure factor F<sub>hkl</sub></strong> determines the actual diffraction intensity.
        </p>
<div class="formula-block">
            $$
            F_{hkl} = \sum_{j=1}^{N} f_j \exp\left[2\pi i(hx_j + ky_j + lz_j)\right]
            $$
        </div>
<p>Where:</p>
<ul>
<li><strong>f<sub>j</sub></strong>: <strong>atomic scattering factor</strong> of the j-th atom (proportional to number of electrons)</li>
<li><strong>(x<sub>j</sub>, y<sub>j</sub>, z<sub>j</sub>)</strong>: <strong>fractional coordinates</strong> of the j-th atom</li>
<li><strong>N</strong>: number of atoms in the unit cell</li>
</ul>
<p>
<strong>Important</strong>: When F<sub>hkl</sub> = 0, diffraction does not occur even if Bragg's law is satisfied.
            This is called <strong>systematic absence</strong>.
        </p>
<h3>3.2 Structure Factor Calculations for Simple Structures</h3>
<div class="example-box">
<h4>Code Example 3: Structure Factors for Simple Cubic, Body-Centered Cubic, and Face-Centered Cubic</h4>
</div>
<pre class="line-numbers"><code class="language-python">import numpy as np
import pandas as pd

def structure_factor(positions, f_atoms, h, k, l):
    """
    Calculate structure factor F_hkl

    Parameters:
    -----------
    positions : list of tuples
        Fractional coordinates of atoms in unit cell [(x1,y1,z1), (x2,y2,z2), ...]
    f_atoms : list of float
        Atomic scattering factor for each atom
    h, k, l : int
        Miller indices

    Returns:
    --------
    complex : Structure factor F_hkl
    """
    F = 0 + 0j
    for (x, y, z), f in zip(positions, f_atoms):
        phase = 2 * np.pi * (h*x + k*y + l*z)
        F += f * np.exp(1j * phase)
    return F

def analyze_structure_factors():
    """Analyze structure factors for different lattice types"""

    # Atomic positions for each lattice type
    structures = {
        'SC (Simple Cubic)': [
            (0, 0, 0)
        ],
        'BCC (Body-Centered Cubic)': [
            (0, 0, 0),
            (0.5, 0.5, 0.5)
        ],
        'FCC (Face-Centered Cubic)': [
            (0, 0, 0),
            (0.5, 0.5, 0),
            (0.5, 0, 0.5),
            (0, 0.5, 0.5)
        ],
        'Diamond Structure': [
            (0, 0, 0),
            (0.5, 0.5, 0),
            (0.5, 0, 0.5),
            (0, 0.5, 0.5),
            (0.25, 0.25, 0.25),
            (0.75, 0.75, 0.25),
            (0.75, 0.25, 0.75),
            (0.25, 0.75, 0.75)
        ]
    }

    # List of Miller indices
    planes = [
        (1, 0, 0), (1, 1, 0), (1, 1, 1),
        (2, 0, 0), (2, 2, 0), (3, 1, 1),
        (2, 2, 2), (4, 0, 0), (3, 3, 1)
    ]

    print("=== Structure Factors and Extinction Rules for Different Lattice Types ===\n")

    for structure_name, positions in structures.items():
        print(f"\n„Äê{structure_name}„Äë")
        print(f"Number of atoms in unit cell: {len(positions)}\n")
        print(f"{'(hkl)':&lt;10} {'|F_hkl|^2':&lt;15} {'Observable':&lt;10} {'Note'}")
        print("-" * 60)

        # Assume all atoms are identical with atomic scattering factor f = 1
        f_atoms = [1.0] * len(positions)

        for hkl in planes:
            h, k, l = hkl
            F = structure_factor(positions, f_atoms, h, k, l)
            F_squared = abs(F)**2

            # Determine observability (|F|^2 &gt; 0.01 considered observable)
            observable = "‚óã" if F_squared &gt; 0.01 else "√ó"

            # Explanation of extinction conditions
            remarks = ""
            if structure_name == 'BCC (Body-Centered Cubic)':
                if (h + k + l) % 2 != 0:
                    remarks = "h+k+l is odd ‚Üí extinct"
            elif structure_name == 'FCC (Face-Centered Cubic)':
                if not (h % 2 == k % 2 == l % 2):
                    remarks = "h,k,l mixed ‚Üí extinct"

            print(f"({h}{k}{l}){'':&lt;8} {F_squared:12.4f}   {observable:&lt;10} {remarks}")

    print("\n" + "="*60)
    print("Summary of Extinction Rules:")
    print("  SC : All reflections are observed")
    print("  BCC: Only h+k+l even are observed")
    print("  FCC: Only all even or all odd h,k,l are observed")
    print("  Diamond: FCC + additionally only h+k+l=4n (n:integer) show strong reflections")
    print("="*60)

# Execute
analyze_structure_factors()
</code></pre>
<div class="warning-box">
<h4>Importance of Extinction Rules</h4>
<p>
                Extinction rules are extremely important for determining crystal structures.
                For example, if the (100) peak is not observed, you know it is not simple cubic (SC) but BCC or FCC.
            </p>
</div>
<h3>3.3 Factors Affecting Diffraction Intensity</h3>
<p>The actual diffraction intensity I<sub>hkl</sub> depends on many factors beyond the structure factor:</p>
<div class="formula-block">
            $$
            I_{hkl} \propto |F_{hkl}|^2 \cdot m_{hkl} \cdot L \cdot P \cdot A \cdot \exp(-2M)
            $$
        </div>
<table>
<thead>
<tr>
<th>Factor</th>
<th>Name</th>
<th>Physical Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td>|F<sub>hkl</sub>|<sup>2</sup></td>
<td>Structure factor</td>
<td>Effect of atomic arrangement in unit cell</td>
</tr>
<tr>
<td>m<sub>hkl</sub></td>
<td>Multiplicity</td>
<td>Number of symmetrically equivalent planes</td>
</tr>
<tr>
<td>L</td>
<td>Lorentz factor</td>
<td>Geometric effect of crystal</td>
</tr>
<tr>
<td>P</td>
<td>Polarization factor</td>
<td>Effect of X-ray polarization state</td>
</tr>
<tr>
<td>A</td>
<td>Absorption factor</td>
<td>X-ray absorption by sample</td>
</tr>
<tr>
<td>exp(-2M)</td>
<td>Temperature factor (Debye-Waller factor)</td>
<td>Diffuse scattering due to atomic thermal vibration</td>
</tr>
</tbody>
</table>
<div class="example-box">
<h4>Code Example 4: Intensity Calculation Including Multiplicity and Lorentz-Polarization Factor</h4>
</div>
<pre class="line-numbers"><code class="language-python">from itertools import permutations, product

def multiplicity(h, k, l, crystal_system='cubic'):
    """
    Calculate multiplicity (number of equivalent planes)

    Parameters:
    -----------
    h, k, l : int
        Miller indices
    crystal_system : str
        Crystal system

    Returns:
    --------
    int : Multiplicity
    """
    planes = set()

    if crystal_system == 'cubic':
        for perm in permutations([abs(h), abs(k), abs(l)]):
            for signs in product([1, -1], repeat=3):
                plane = tuple(s * p for s, p in zip(signs, perm))
                if plane != (0, 0, 0):
                    planes.add(plane)

    return len(planes)

def lorentz_polarization_factor(two_theta):
    """
    Lorentz-polarization factor for powder X-ray diffraction

    Parameters:
    -----------
    two_theta : float
        Diffraction angle 2Œ∏ (radians)

    Returns:
    --------
    float : LP factor
    """
    theta = two_theta / 2
    LP = (1 + np.cos(two_theta)**2) / (np.sin(theta)**2 * np.cos(theta))
    return LP

def calculate_intensity_with_factors():
    """Calculate diffraction intensity considering various factors"""

    # Aluminum (FCC, a = 4.0495 √Ö)
    a_Al = 4.0495
    wavelength = 1.5406  # Cu KŒ±

    # Atomic positions for FCC structure
    fcc_positions = [
        (0, 0, 0),
        (0.5, 0.5, 0),
        (0.5, 0, 0.5),
        (0, 0.5, 0.5)
    ]
    f_Al = 13  # Aluminum atomic number (simplified as atomic scattering factor)

    planes = [
        (1, 1, 1), (2, 0, 0), (2, 2, 0),
        (3, 1, 1), (2, 2, 2), (4, 0, 0)
    ]

    print("=== XRD Intensity Calculation with Various Factors (Al, FCC) ===\n")
    print(f"{'(hkl)':&lt;10} {'d (√Ö)':&lt;10} {'2Œ∏':&lt;10} {'|F|^2':&lt;12} {'m':&lt;6} {'LP':&lt;10} {'I_rel':&lt;10}")
    print("-" * 80)

    intensities = []

    for hkl in planes:
        h, k, l = hkl

        # Interplanar spacing
        d = cubic_d_spacing(a_Al, h, k, l)

        # Bragg angle
        two_theta_deg = bragg_angle(d, wavelength)
        if two_theta_deg is None:
            continue
        two_theta_rad = np.radians(two_theta_deg)

        # Structure factor
        F = structure_factor(fcc_positions, [f_Al]*4, h, k, l)
        F_squared = abs(F)**2

        # Check extinction rule (mixed indices extinct for FCC)
        if F_squared &lt; 0.01:
            continue

        # Multiplicity
        m = multiplicity(h, k, l, 'cubic')

        # Lorentz-polarization factor
        LP = lorentz_polarization_factor(two_theta_rad)

        # Relative intensity (temperature factor and absorption omitted)
        I_rel = F_squared * m * LP

        intensities.append((hkl, I_rel))

        print(f"({h}{k}{l}){'':&lt;8} {d:8.4f}  {two_theta_deg:8.2f}  {F_squared:10.2f}  {m:&lt;6} {LP:8.4f}  {I_rel:8.2f}")

    # Normalize by maximum intensity
    max_intensity = max(I for _, I in intensities)

    print("\n--- Normalized Relative Intensity (maximum = 100) ---")
    print(f"{'(hkl)':&lt;10} {'Relative Intensity':&lt;15}")
    print("-" * 30)

    for hkl, I in intensities:
        I_normalized = 100 * I / max_intensity
        print(f"({hkl[0]}{hkl[1]}{hkl[2]}){'':&lt;8} {I_normalized:8.1f}")

# Execute
calculate_intensity_with_factors()
</code></pre>
<h2>4. Interpreting Powder X-ray Diffraction Patterns</h2>
<h3>4.1 What is Powder XRD?</h3>
<p>
<strong>Powder X-ray Diffraction (PXRD)</strong> is a measurement method for samples consisting of fine crystalline grains oriented in <strong>random directions</strong>.
            It is one of the most frequently used structural characterization techniques in materials science.
        </p>
<div class="info-box">
<h4>Characteristics of Powder XRD</h4>
<ul>
<li><strong>Easy sample preparation</strong>: No single crystal required</li>
<li><strong>Phase identification</strong>: Can identify crystalline phases in unknown samples</li>
<li><strong>Quantitative analysis</strong>: Can estimate proportions of each phase in mixtures</li>
<li><strong>Lattice parameter determination</strong>: Can obtain precise lattice parameters from peak positions</li>
<li><strong>Crystallite size</strong>: Can estimate nanoparticle size from peak width</li>
</ul>
</div>
<h3>4.2 XRD Pattern Simulation</h3>
<div class="example-box">
<h4>Code Example 5: Complete XRD Pattern Simulation</h4>
<p>Generate realistic XRD patterns including peak shapes (Gaussian functions) and background:</p>
</div>
<pre class="line-numbers"><code class="language-python">def gaussian_peak(two_theta, center, intensity, fwhm):
    """
    Gaussian peak function

    Parameters:
    -----------
    two_theta : array
        Array of 2Œ∏ values
    center : float
        Peak center position
    intensity : float
        Peak intensity
    fwhm : float
        Full Width at Half Maximum

    Returns:
    --------
    array : Intensity of Gaussian peak
    """
    sigma = fwhm / (2 * np.sqrt(2 * np.log(2)))
    return intensity * np.exp(-((two_theta - center)**2) / (2 * sigma**2))

def simulate_xrd_pattern(material_name, a, c=None, crystal_system='cubic',
                        positions=None, f_atoms=None,
                        wavelength=1.5406, two_theta_range=(20, 100),
                        fwhm=0.2, background=50):
    """
    Simulate complete XRD pattern

    Parameters:
    -----------
    material_name : str
        Material name
    a, c : float
        Lattice parameters
    crystal_system : str
        Crystal system
    positions : list
        Fractional coordinates of atoms in unit cell
    f_atoms : list
        Atomic scattering factors
    wavelength : float
        X-ray wavelength
    two_theta_range : tuple
        Measurement range of 2Œ∏
    fwhm : float
        Full width at half maximum of peaks
    background : float
        Background intensity

    Returns:
    --------
    two_theta, intensity : arrays
    """
    # Array of 2Œ∏ values
    two_theta = np.linspace(two_theta_range[0], two_theta_range[1], 4000)
    intensity = np.ones_like(two_theta) * background  # Background

    # Calculate peaks
    max_hkl = 5
    peaks_info = []

    for h in range(max_hkl + 1):
        for k in range(h, max_hkl + 1):
            for l in range(k, max_hkl + 1):
                if h == 0 and k == 0 and l == 0:
                    continue

                # Interplanar spacing
                if crystal_system == 'cubic':
                    d = cubic_d_spacing(a, h, k, l)

                # Bragg angle
                two_theta_peak = bragg_angle(d, wavelength)
                if two_theta_peak is None or two_theta_peak &gt; two_theta_range[1]:
                    continue

                # Structure factor
                if positions is not None and f_atoms is not None:
                    F = structure_factor(positions, f_atoms, h, k, l)
                    F_squared = abs(F)**2
                    if F_squared &lt; 0.01:
                        continue
                else:
                    F_squared = 1.0

                # Multiplicity
                m = multiplicity(h, k, l, crystal_system)

                # Lorentz-polarization factor
                LP = lorentz_polarization_factor(np.radians(two_theta_peak))

                # Peak intensity
                I_peak = F_squared * m * LP

                # Add Gaussian peak
                intensity += gaussian_peak(two_theta, two_theta_peak, I_peak, fwhm)
                peaks_info.append(((h, k, l), two_theta_peak, I_peak))

    # Normalize intensity
    intensity = (intensity / intensity.max()) * 1000

    return two_theta, intensity, peaks_info

# Simulate XRD pattern for silicon
a_Si = 5.4310
diamond_positions = [
    (0, 0, 0), (0.5, 0.5, 0), (0.5, 0, 0.5), (0, 0.5, 0.5),
    (0.25, 0.25, 0.25), (0.75, 0.75, 0.25),
    (0.75, 0.25, 0.75), (0.25, 0.75, 0.75)
]
f_Si = [14] * 8  # Silicon atomic number

two_theta, intensity, peaks = simulate_xrd_pattern(
    'Silicon (Si)',
    a=a_Si,
    crystal_system='cubic',
    positions=diamond_positions,
    f_atoms=f_Si,
    fwhm=0.15
)

# Display graph
fig, ax = plt.subplots(figsize=(14, 6))

ax.plot(two_theta, intensity, 'b-', linewidth=1.5, label='Simulation')
ax.fill_between(two_theta, 0, intensity, alpha=0.2, color='blue')

# Label major peaks
peaks_sorted = sorted(peaks, key=lambda x: x[2], reverse=True)[:6]
for (h, k, l), pos, I in peaks_sorted:
    ax.annotate(f'({h}{k}{l})',
               xy=(pos, I * 1000 / intensity.max()),
               xytext=(pos, I * 1000 / intensity.max() + 80),
               ha='center', fontsize=10,
               arrowprops=dict(arrowstyle='-&gt;', color='red', lw=1))

ax.set_xlim(20, 100)
ax.set_ylim(0, 1100)
ax.set_xlabel('2Œ∏ (degrees)', fontsize=14, fontweight='bold')
ax.set_ylabel('Intensity (arbitrary units)', fontsize=14, fontweight='bold')
ax.set_title('Powder XRD Pattern of Silicon (Si) (Simulation)',
            fontsize=16, fontweight='bold')
ax.grid(axis='both', alpha=0.3)
ax.legend(fontsize=12)

plt.tight_layout()
plt.savefig('si_powder_xrd_simulation.png', dpi=150, bbox_inches='tight')
plt.show()
print("Powder XRD simulation saved: si_powder_xrd_simulation.png")
</code></pre>
<h3>4.3 Reading and Analyzing Measured Data</h3>
<div class="example-box">
<h4>Code Example 6: Reading XRD Data and Peak Detection</h4>
<p>Read actual XRD measurement data (text file) and automatically detect peaks:</p>
</div>
<pre class="line-numbers"><code class="language-python">from scipy.signal import find_peaks
from scipy.optimize import curve_fit

def read_xrd_data(filename):
    """
    Read XRD data file

    Common format:
    2theta  Intensity
    20.0    150.2
    20.1    152.3
    ...

    Parameters:
    -----------
    filename : str
        Path to data file

    Returns:
    --------
    two_theta, intensity : arrays
    """
    try:
        data = np.loadtxt(filename, skiprows=1)  # Skip header row
        two_theta = data[:, 0]
        intensity = data[:, 1]
        return two_theta, intensity
    except FileNotFoundError:
        print(f"File {filename} not found.")
        print("Generating sample data.")
        # Generate sample data
        return simulate_xrd_pattern('Sample', a=5.0, fwhm=0.3)[:2]

def detect_peaks_in_xrd(two_theta, intensity, prominence=50, distance=10):
    """
    Detect peaks in XRD pattern

    Parameters:
    -----------
    two_theta : array
        2Œ∏ data
    intensity : array
        Intensity data
    prominence : float
        Threshold for peak detection (prominence)
    distance : int
        Minimum distance between peaks (number of data points)

    Returns:
    --------
    peak_positions, peak_intensities : arrays
    """
    peaks_idx, properties = find_peaks(intensity,
                                       prominence=prominence,
                                       distance=distance)

    peak_positions = two_theta[peaks_idx]
    peak_intensities = intensity[peaks_idx]
    peak_prominences = properties['prominences']

    return peak_positions, peak_intensities, peak_prominences

def analyze_xrd_data():
    """Demonstration of measured XRD data analysis"""

    # Read data (simulate if actual file doesn't exist)
    two_theta, intensity = read_xrd_data('sample_xrd.txt')

    # Peak detection
    peak_pos, peak_int, peak_prom = detect_peaks_in_xrd(
        two_theta, intensity,
        prominence=100,
        distance=20
    )

    print("=== Detected Peaks ===\n")
    print(f"{'Peak Number':&lt;12} {'2Œ∏ (deg)':&lt;12} {'Intensity':&lt;15} {'d-spacing (√Ö)':&lt;12}")
    print("-" * 60)

    wavelength = 1.5406  # Cu KŒ±

    for i, (pos, intensity_val) in enumerate(zip(peak_pos, peak_int), 1):
        # Calculate d-spacing from Bragg's law
        theta = np.radians(pos / 2)
        d_spacing = wavelength / (2 * np.sin(theta))

        print(f"{i:&lt;12} {pos:10.2f}  {intensity_val:12.1f}  {d_spacing:10.4f}")

    # Display graph
    fig, ax = plt.subplots(figsize=(14, 7))

    # Plot XRD pattern
    ax.plot(two_theta, intensity, 'b-', linewidth=1.5, label='Measured Data')

    # Mark detected peaks
    ax.plot(peak_pos, peak_int, 'ro', markersize=8, label='Detected Peaks')

    # Display peak numbers
    for i, (pos, int_val) in enumerate(zip(peak_pos, peak_int), 1):
        ax.annotate(f'{i}',
                   xy=(pos, int_val),
                   xytext=(pos, int_val + 80),
                   ha='center', fontsize=10, fontweight='bold',
                   bbox=dict(boxstyle='round,pad=0.3', facecolor='yellow', alpha=0.7))

    ax.set_xlabel('2Œ∏ (degrees)', fontsize=14, fontweight='bold')
    ax.set_ylabel('Intensity (arbitrary units)', fontsize=14, fontweight='bold')
    ax.set_title('XRD Pattern and Peak Detection', fontsize=16, fontweight='bold')
    ax.legend(fontsize=12)
    ax.grid(axis='both', alpha=0.3)

    plt.tight_layout()
    plt.savefig('xrd_peak_detection.png', dpi=150, bbox_inches='tight')
    plt.show()
    print("\nPeak detection results saved: xrd_peak_detection.png")

# Execute
analyze_xrd_data()
</code></pre>
<h3>4.4 Peak Fitting</h3>
<div class="example-box">
<h4>Code Example 7: Peak Fitting with Gaussian-Lorentzian Functions</h4>
<p>Mathematically fit peak shapes to determine accurate peak positions and widths:</p>
</div>
<pre class="line-numbers"><code class="language-python">def pseudo_voigt(x, amplitude, center, fwhm, eta):
    """
    Pseudo-Voigt function (mixture of Gaussian and Lorentzian components)

    Parameters:
    -----------
    x : array
        Data points
    amplitude : float
        Peak amplitude
    center : float
        Peak center
    fwhm : float
        Full width at half maximum
    eta : float
        Fraction of Lorentzian component (0: Gaussian, 1: Lorentzian)

    Returns:
    --------
    array : Peak shape
    """
    # Gaussian component
    sigma = fwhm / (2 * np.sqrt(2 * np.log(2)))
    gaussian = np.exp(-((x - center)**2) / (2 * sigma**2))

    # Lorentzian component
    gamma = fwhm / 2
    lorentzian = gamma**2 / ((x - center)**2 + gamma**2)

    # Mixture
    return amplitude * (eta * lorentzian + (1 - eta) * gaussian)

def fit_single_peak(two_theta, intensity, peak_center, window=2.0):
    """
    Fit single peak

    Parameters:
    -----------
    two_theta : array
        2Œ∏ data
    intensity : array
        Intensity data
    peak_center : float
        Approximate peak center position
    window : float
        Fitting range (¬±window degrees)

    Returns:
    --------
    popt : array
        Optimized parameters [amplitude, center, fwhm, eta]
    pcov : array
        Covariance matrix
    """
    # Extract fitting range
    mask = (two_theta &gt;= peak_center - window) &amp; (two_theta &lt;= peak_center + window)
    x_data = two_theta[mask]
    y_data = intensity[mask]

    # Initial estimates
    amplitude_init = np.max(y_data) - np.min(y_data)
    center_init = peak_center
    fwhm_init = 0.2
    eta_init = 0.5

    p0 = [amplitude_init, center_init, fwhm_init, eta_init]

    # Boundary conditions
    bounds = ([0, peak_center - 1, 0.05, 0],
              [amplitude_init * 2, peak_center + 1, 1.0, 1])

    try:
        popt, pcov = curve_fit(pseudo_voigt, x_data, y_data, p0=p0, bounds=bounds)
        return popt, pcov, x_data, y_data
    except RuntimeError:
        print(f"Fitting failed for peak at {peak_center:.2f}¬∞.")
        return None, None, x_data, y_data

def demo_peak_fitting():
    """Demonstration of peak fitting"""

    # Generate sample data
    two_theta, intensity = simulate_xrd_pattern('Sample', a=5.4, fwhm=0.2)[:2]

    # Peak detection
    peak_pos, _, _ = detect_peaks_in_xrd(two_theta, intensity, prominence=100)

    # Fit three strongest peaks
    strongest_peaks = sorted(zip(peak_pos, intensity[np.isin(two_theta, peak_pos)]),
                            key=lambda x: x[1], reverse=True)[:3]

    fig, axes = plt.subplots(1, 3, figsize=(16, 5))

    for ax, (peak_center, _) in zip(axes, strongest_peaks):
        result = fit_single_peak(two_theta, intensity, peak_center, window=2.5)

        if result[0] is not None:
            popt, pcov, x_fit, y_fit = result
            amplitude, center, fwhm, eta = popt

            # Fitting curve
            x_fine = np.linspace(x_fit.min(), x_fit.max(), 500)
            y_fine = pseudo_voigt(x_fine, *popt)

            # Plot
            ax.plot(x_fit, y_fit, 'bo', markersize=4, label='Measured Data')
            ax.plot(x_fine, y_fine, 'r-', linewidth=2, label='Fitting')

            # Display results
            textstr = f'Center: {center:.3f}¬∞\nFWHM: {fwhm:.3f}¬∞\nŒ∑: {eta:.2f}'
            ax.text(0.05, 0.95, textstr, transform=ax.transAxes,
                   fontsize=10, verticalalignment='top',
                   bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.8))

            ax.set_xlabel('2Œ∏ (degrees)', fontsize=12, fontweight='bold')
            ax.set_ylabel('Intensity', fontsize=12, fontweight='bold')
            ax.set_title(f'Peak @ {center:.1f}¬∞', fontsize=13, fontweight='bold')
            ax.legend(fontsize=10)
            ax.grid(alpha=0.3)

    plt.tight_layout()
    plt.savefig('xrd_peak_fitting.png', dpi=150, bbox_inches='tight')
    plt.show()
    print("Peak fitting results saved: xrd_peak_fitting.png")

# Execute
demo_peak_fitting()
</code></pre>
<h2>5. Advanced XRD Analysis with pymatgen</h2>
<h3>5.1 Generating XRD Patterns with pymatgen</h3>
<p>
<strong>pymatgen</strong> is a powerful Python library for materials science that can automatically generate XRD patterns from crystal structures.
        </p>
<div class="example-box">
<h4>Code Example 8: XRD Pattern Generation and Comparison with pymatgen</h4>
</div>
<pre class="line-numbers"><code class="language-python">try:
    from pymatgen.core import Structure, Lattice
    from pymatgen.analysis.diffraction.xrd import XRDCalculator
    PYMATGEN_AVAILABLE = True
except ImportError:
    print("pymatgen is not installed.")
    print("Install with: pip install pymatgen")
    PYMATGEN_AVAILABLE = False

def generate_xrd_with_pymatgen():
    """Generate XRD pattern using pymatgen"""

    if not PYMATGEN_AVAILABLE:
        print("This example is skipped because pymatgen is not installed.")
        return

    # Define silicon structure
    lattice = Lattice.cubic(5.4310)
    species = ['Si', 'Si', 'Si', 'Si', 'Si', 'Si', 'Si', 'Si']
    coords = [
        [0, 0, 0], [0.5, 0.5, 0], [0.5, 0, 0.5], [0, 0.5, 0.5],
        [0.25, 0.25, 0.25], [0.75, 0.75, 0.25],
        [0.75, 0.25, 0.75], [0.25, 0.75, 0.75]
    ]

    si_structure = Structure(lattice, species, coords)

    print("=== XRD Pattern Generation with pymatgen ===\n")
    print(f"Crystal structure: {si_structure.composition}")
    print(f"Space group: {si_structure.get_space_group_info()}\n")

    # Initialize XRD calculator
    calculator = XRDCalculator(wavelength='CuKa')  # Cu KŒ± radiation

    # Calculate XRD pattern
    pattern = calculator.get_pattern(si_structure, two_theta_range=(20, 100))

    print(f"{'2Œ∏ (deg)':&lt;12} {'d-spacing (√Ö)':&lt;15} {'(hkl)':&lt;15} {'Relative Int.':&lt;12}")
    print("-" * 60)

    for i in range(len(pattern.x)):
        two_theta = pattern.x[i]
        intensity = pattern.y[i]
        hkl = pattern.hkls[i][0]['hkl']  # Get first hkl
        d_spacing = pattern.d_hkls[i]

        print(f"{two_theta:10.2f}  {d_spacing:12.4f}  {str(hkl):&lt;15} {intensity:10.1f}")

    # Display graph
    fig, ax = plt.subplots(figsize=(14, 7))

    # Plot as bar graph
    ax.vlines(pattern.x, 0, pattern.y, colors='blue', linewidth=2, label='pymatgen')

    # Label peaks with hkl
    for i, (two_theta, intensity, hkls_data) in enumerate(zip(pattern.x, pattern.y, pattern.hkls)):
        if intensity &gt; 20:  # Display label only for peaks with intensity &gt; 20
            hkl = hkls_data[0]['hkl']
            ax.text(two_theta, intensity + 5, f'({hkl[0]}{hkl[1]}{hkl[2]})',
                   rotation=90, va='bottom', ha='center', fontsize=9)

    ax.set_xlim(20, 100)
    ax.set_ylim(0, max(pattern.y) * 1.15)
    ax.set_xlabel('2Œ∏ (degrees)', fontsize=14, fontweight='bold')
    ax.set_ylabel('Relative Intensity', fontsize=14, fontweight='bold')
    ax.set_title('XRD Pattern of Silicon (Si) - pymatgen Generated',
                fontsize=16, fontweight='bold')
    ax.legend(fontsize=12)
    ax.grid(axis='both', alpha=0.3)

    plt.tight_layout()
    plt.savefig('si_xrd_pymatgen.png', dpi=150, bbox_inches='tight')
    plt.show()
    print("\npymatgen XRD pattern saved: si_xrd_pymatgen.png")

    # Compare multiple materials
    compare_materials_xrd()

def compare_materials_xrd():
    """Compare XRD patterns of multiple materials"""

    if not PYMATGEN_AVAILABLE:
        return

    # Define materials
    materials = {
        'Si (Diamond)': Structure(
            Lattice.cubic(5.4310),
            ['Si']*8,
            [[0,0,0], [0.5,0.5,0], [0.5,0,0.5], [0,0.5,0.5],
             [0.25,0.25,0.25], [0.75,0.75,0.25], [0.75,0.25,0.75], [0.25,0.75,0.75]]
        ),
        'Al (FCC)': Structure(
            Lattice.cubic(4.0495),
            ['Al']*4,
            [[0,0,0], [0.5,0.5,0], [0.5,0,0.5], [0,0.5,0.5]]
        ),
        'Fe (BCC)': Structure(
            Lattice.cubic(2.8665),
            ['Fe']*2,
            [[0,0,0], [0.5,0.5,0.5]]
        )
    }

    calculator = XRDCalculator(wavelength='CuKa')

    fig, axes = plt.subplots(3, 1, figsize=(14, 12))

    for ax, (name, structure) in zip(axes, materials.items()):
        pattern = calculator.get_pattern(structure, two_theta_range=(20, 100))

        # Bar graph
        ax.vlines(pattern.x, 0, pattern.y, colors='darkblue', linewidth=2.5)

        # Peak labels
        for two_theta, intensity, hkls_data in zip(pattern.x, pattern.y, pattern.hkls):
            if intensity &gt; 15:
                hkl = hkls_data[0]['hkl']
                ax.text(two_theta, intensity + 3, f'({hkl[0]}{hkl[1]}{hkl[2]})',
                       rotation=90, va='bottom', ha='center', fontsize=9)

        ax.set_xlim(20, 100)
        ax.set_ylim(0, 110)
        ax.set_ylabel('Relative Intensity', fontsize=12, fontweight='bold')
        ax.set_title(name, fontsize=14, fontweight='bold', loc='left')
        ax.grid(axis='x', alpha=0.3)

    axes[-1].set_xlabel('2Œ∏ (degrees)', fontsize=14, fontweight='bold')

    plt.tight_layout()
    plt.savefig('materials_xrd_comparison.png', dpi=150, bbox_inches='tight')
    plt.show()
    print("Material comparison graph saved: materials_xrd_comparison.png")

# Execute
generate_xrd_with_pymatgen()
</code></pre>
<div class="success-box">
<h4>Advantages of pymatgen</h4>
<ul>
<li><strong>Structure database integration</strong>: Can directly obtain structures from Materials Project and others</li>
<li><strong>Automatic structure factor calculation</strong>: Accurate calculations including atomic scattering factors and temperature factors</li>
<li><strong>Automatic space group recognition</strong>: Accurate pattern generation considering symmetry</li>
<li><strong>Phase identification function</strong>: Identification of unknown samples by comparison with measured patterns</li>
</ul>
</div>
<h2>6. Introduction to Rietveld Analysis</h2>
<h3>6.1 What is the Rietveld Method?</h3>
<p>
<strong>Rietveld refinement</strong> is a technique that fits the entire powder XRD pattern with a crystal structure model.
            It was developed by Hugo Rietveld in 1969.
        </p>
<div class="info-box">
<h4>Information Obtained from the Rietveld Method</h4>
<ul>
<li><strong>Lattice parameters</strong>: High precision (¬±0.0001 √Ö or better)</li>
<li><strong>Atomic coordinates</strong>: Atomic positions within the unit cell</li>
<li><strong>Occupancy</strong>: Occupancy of atomic sites (evaluation of alloys and defects)</li>
<li><strong>Temperature factors</strong>: Magnitude of atomic thermal vibrations</li>
<li><strong>Crystallite size</strong>: Estimation from peak widths</li>
<li><strong>Microstrain</strong>: Lattice distortion</li>
<li><strong>Phase quantification</strong>: Weight fractions of each phase in multiphase mixtures</li>
</ul>
</div>
<h3>6.2 Principles of the Rietveld Method</h3>
<p>The Rietveld method optimizes the following function by least squares:</p>
<div class="formula-block">
            $$
            S = \sum_i w_i (y_{i,\text{obs}} - y_{i,\text{calc}})^2
            $$
        </div>
<p>Where:</p>
<ul>
<li><strong>y<sub>i,obs</sub></strong>: Observed intensity at the i-th measurement point</li>
<li><strong>y<sub>i,calc</sub></strong>: Calculated intensity at the i-th measurement point</li>
<li><strong>w<sub>i</sub></strong>: Weight (typically 1/y<sub>i,obs</sub>)</li>
</ul>
<p>The calculated intensity is expressed as:</p>
<div class="formula-block">
            $$
            y_{i,\text{calc}} = \text{scale} \sum_{K} L_K |F_K|^2 \Phi(2\theta_i - 2\theta_K) P_K A + y_{i,\text{bg}}
            $$
        </div>
<div class="warning-box">
<h4>Important Notes on Rietveld Analysis</h4>
<p>
                The Rietveld method is a technique that <strong>requires a structure model</strong>.
                If the initial structure model is significantly incorrect, it will not converge to the correct solution.
                Typically, initial models are created from known similar structures or single crystal XRD data.
            </p>
</div>
<h3>6.3 Rietveld Analysis Workflow</h3>
<div class="mermaid">
            flowchart TD
                A[Powder XRD Data Measurement] --&gt; B[Peak Identification and Phase Determination]
                B --&gt; C[Create Initial Structure Model]
                C --&gt; D[Background Setting]
                D --&gt; E[Lattice Parameter Refinement]
                E --&gt; F[Profile Shape Refinement]
                F --&gt; G[Structural Parameter Refinement]
                G --&gt; H{Check Goodness of Fit}
                H --&gt;|Good| I[Validate and Report Results]
                H --&gt;|Poor| J[Model Correction]
                J --&gt; D

                style A fill:#e3f2fd
                style B fill:#e3f2fd
                style C fill:#fff3e0
                style I fill:#e8f5e9
                style J fill:#ffebee
        </div>
<h2>7. Exercises</h2>
<div class="exercise">
<h3>Exercise 1: Application of Bragg's Law</h3>
<p>
                For the face-centered cubic (FCC) structure of copper (Cu) with lattice parameter a = 3.615 √Ö.
                Using Cu KŒ± radiation (Œª = 1.5406 √Ö) for powder XRD measurement,
                at what angle (2Œ∏) will diffraction peaks from the following (hkl) planes be observed?
            </p>
<ol>
<li>(111) plane</li>
<li>(200) plane</li>
<li>(220) plane</li>
</ol>
<p>Also, explain whether the (100) peak is observed according to the FCC extinction rule.</p>
<details>
<summary>View Answer</summary>
<p><strong>Calculation of interplanar spacings:</strong></p>
<ol>
<li>d<sub>111</sub> = 3.615 / ‚àö3 = 2.087 √Ö</li>
<li>d<sub>200</sub> = 3.615 / ‚àö4 = 1.808 √Ö</li>
<li>d<sub>220</sub> = 3.615 / ‚àö8 = 1.278 √Ö</li>
</ol>
<p><strong>Calculation of Bragg angles (Œª = 2d sinŒ∏):</strong></p>
<ol>
<li>2Œ∏<sub>111</sub> = 2 √ó arcsin(1.5406/(2√ó2.087)) ‚âà <strong>43.3¬∞</strong></li>
<li>2Œ∏<sub>200</sub> = 2 √ó arcsin(1.5406/(2√ó1.808)) ‚âà <strong>50.4¬∞</strong></li>
<li>2Œ∏<sub>220</sub> = 2 √ó arcsin(1.5406/(2√ó1.278)) ‚âà <strong>74.1¬∞</strong></li>
</ol>
<p><strong>About the (100) plane:</strong></p>
<p>
                    The FCC extinction rule is "only all even or all odd h, k, l are observed."
                    (100) has h=1 (odd), k=0 (even), l=0 (even), so it is mixed,
                    and the structure factor F<sub>100</sub> = 0. Therefore it is <strong>not observed</strong>.
                </p>
</details>
</div>
<div class="exercise">
<h3>Exercise 2: Structure Factor and Extinction Rules</h3>
<p>
                The following peaks were observed in an XRD measurement:
                (110), (200), (211), (220), (310), (222), (321), (400)
            </p>
<p>
                Is this material simple cubic (SC), body-centered cubic (BCC), or face-centered cubic (FCC)?
                Determine from the extinction rules.
            </p>
<details>
<summary>View Answer</summary>
<p>Check the sum h+k+l for each index:</p>
<ul>
<li>(110): 1+1+0 = 2 (even)</li>
<li>(200): 2+0+0 = 2 (even)</li>
<li>(211): 2+1+1 = 4 (even)</li>
<li>(220): 2+2+0 = 4 (even)</li>
<li>(310): 3+1+0 = 4 (even)</li>
<li>(222): 2+2+2 = 6 (even)</li>
<li>(321): 3+2+1 = 6 (even)</li>
<li>(400): 4+0+0 = 4 (even)</li>
</ul>
<p>
                    All peaks have even h+k+l. This matches the <strong>BCC (body-centered cubic)</strong> extinction rule.
                </p>
<p>
                    If it were FCC, mixed indices like (210) or (221) would be extinct, but
                    there is no such regularity in the observed peaks.
                    If it were SC, all peaks including (100) should be observed.
                </p>
<p><strong>Answer: BCC (body-centered cubic)</strong></p>
</details>
</div>
<div class="exercise">
<h3>Exercise 3: Crystal Identification from d-spacings</h3>
<p>
                From the XRD pattern of an unknown sample, the following d-spacings (√Ö) were obtained:
                3.35, 2.46, 2.13, 1.91, 1.80
            </p>
<p>
                Which of the following materials could this sample be? Determine from lattice parameters.
            </p>
<ul>
<li>A) NaCl (rock salt structure, FCC, a = 5.64 √Ö)</li>
<li>B) Si (diamond structure, a = 5.43 √Ö)</li>
<li>C) Graphite (hexagonal, a = 2.46 √Ö, c = 6.71 √Ö)</li>
</ul>
<details>
<summary>View Answer</summary>
<p>Calculate representative d-spacings for each material:</p>
<p><strong>A) NaCl (FCC, a=5.64 √Ö):</strong></p>
<ul>
<li>d<sub>111</sub> = 5.64/‚àö3 = 3.26 √Ö</li>
<li>d<sub>200</sub> = 5.64/‚àö4 = 2.82 √Ö</li>
<li>d<sub>220</sub> = 5.64/‚àö8 = 2.00 √Ö</li>
</ul>
<p><strong>B) Si (a=5.43 √Ö):</strong></p>
<ul>
<li>d<sub>111</sub> = 5.43/‚àö3 = 3.14 √Ö</li>
<li>d<sub>220</sub> = 5.43/‚àö8 = 1.92 √Ö</li>
</ul>
<p><strong>C) Graphite (hexagonal, a=2.46, c=6.71 √Ö):</strong></p>
<ul>
<li>d<sub>002</sub> = c/2 = 3.35 √Ö ‚úì</li>
<li>d<sub>100</sub> = a‚àö(3/4) = 2.13 √Ö ‚úì</li>
<li>d<sub>004</sub> = c/4 = 1.68 √Ö</li>
</ul>
<p>
<strong>Answer: C) Graphite</strong>
</p>
<p>
                    The maximum d-spacing of 3.35 √Ö matches the characteristic (002) plane spacing of graphite.
                    This corresponds to the important peak for graphite interlayer distance.
                </p>
</details>
</div>
<div class="exercise">
<h3>Exercise 4: Programming Challenge</h3>
<p>
                Under the following conditions, create a program that simulates the XRD pattern of a fictional material and displays the positions and relative intensities of the major peaks (top 5):
            </p>
<ul>
<li>Crystal system: Cubic (FCC structure)</li>
<li>Lattice parameter: a = 4.00 √Ö</li>
<li>X-ray wavelength: Cu KŒ± radiation (Œª = 1.5406 √Ö)</li>
<li>Measurement range: 2Œ∏ = 20¬∞ to 90¬∞</li>
</ul>
<details>
<summary>Hint</summary>
<p>
                    Use a combination of Code Examples 1 and 3. Implement FCC atomic positions and structure factor calculations,
                    Bragg angle calculations using Bragg's law, and intensity calculations considering multiplicity.
                </p>
<p>
                    The completed program should display peaks like (111), (200), (220), (311), (222) at correct angles and relative intensities.
                </p>
</details>
</div>
<h2>Summary</h2>
<p>In this chapter, we learned the principles of X-ray diffraction and practical analysis methods:</p>
<div class="success-box">
<h4>Key Points</h4>
<ul>
<li><strong>Bragg's law nŒª = 2d sinŒ∏</strong> is the necessary condition for diffraction</li>
<li><strong>Structure factor F<sub>hkl</sub></strong> when zero means no diffraction even if Bragg's law is satisfied (extinction rules)</li>
<li><strong>Extinction rules</strong> allow estimation of crystal structure (SC, BCC, FCC, etc.)</li>
<li><strong>Diffraction intensity</strong> depends on many factors including structure factor, multiplicity, Lorentz-polarization factor, temperature factor</li>
<li><strong>Powder XRD</strong> is widely used for material identification, phase analysis, and lattice parameter determination</li>
<li><strong>Peak fitting</strong> enables determination of accurate peak positions and widths</li>
<li><strong>pymatgen</strong> allows automatic generation of XRD patterns from crystal structures</li>
<li><strong>Rietveld analysis</strong> is a technique that fits the entire pattern and refines structural parameters</li>
</ul>
</div>
<p>
            In the next chapter, we will learn <strong>crystal structure visualization and analysis</strong>,
            and acquire practical skills to retrieve and analyze structures from actual materials databases.
        </p>
<div class="navigation">
<a class="nav-button prev" href="chapter-3.html">Chapter 3: Miller Indices and Crystal Planes/Directions</a>
<a class="nav-button next" href="chapter-5.html">Chapter 5: Crystal Structure Visualization and Analysis</a>
</div>
</div>
<footer style="background-color: var(--color-bg-alt); padding: var(--spacing-lg); text-align: center; margin-top: var(--spacing-xl); border-top: 2px solid var(--color-border);">
<p style="margin-bottom: var(--spacing-sm); color: var(--color-text-light);">
            ¬© 2025 AI Terakoya MS Dojo - Introduction to Crystallography
        </p>
<p style="font-size: 0.9rem; color: var(--color-text-light);">
<a href="../index.html" style="color: var(--color-link);">To AI Terakoya Top</a> |
            <a href="../index.html" style="color: var(--color-link);">To MS Dojo</a> |
            <a href="index.html" style="color: var(--color-link);">To Introduction to Crystallography Top</a>
</p>
</footer>
</body>
</html>
