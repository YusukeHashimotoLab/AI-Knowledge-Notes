<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="Chapter 3: Miller Indices and Crystal Planes/Directions - MS Terakoya. Understand thedefinition of Miller indices (hkl)and be able to accurately represe..." name="description"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Chapter 3: Miller Indices and Crystal Planes/Directions - MS Terakoya</title>
<link href="../../assets/css/knowledge-base.css" rel="stylesheet"/>
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet"/>
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet"/>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
<script>
        mermaid.initialize({
            startOnLoad: true,
            theme: 'default',
            flowchart: {
                useMaxWidth: true,
                htmlLabels: true,
                curve: 'basis'
            }
        });
    </script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true,
                processEnvironments: true
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
            }
        };
    </script>
</head>
<body><div class="locale-switcher">
<span class="current-locale">üåê EN</span>
<span class="locale-separator">|</span>
<a href="../../../jp/MS/crystallography-introduction/chapter-3.html" class="locale-link">üáØüáµ JP</a>
<span class="locale-separator">|</span>

<span class="locale-meta">Last sync: 2025-11-16</span>
</div>

<header>
<div class="header-content">
<h1>Chapter 3: Miller Indices and Crystal Planes/Directions</h1>
<p class="subtitle">Learning the Universal Notation for Describing Crystal Structures</p>
<div class="meta">
<span class="meta-item">üìñ Estimated Study Time: 28 minutes</span>
<span class="meta-item">üéØ Difficulty: Beginner to Intermediate</span>
<span class="meta-item">üíª Code Examples: 8</span>
</div>
</div>
</header>
<div class="breadcrumb">
<a href="../index.html">AI Terakoya Top</a> &gt;
        <a href="../index.html">MS Dojo</a> &gt;
        <a href="index.html">Introduction to Crystallography</a> &gt;
        Chapter 3
    </div>
<div class="container">
<div class="learning-objectives">
<h2>Learning Objectives</h2>
<p>By studying this chapter, you will acquire the following knowledge and skills:</p>
<ul>
<li>Understand the <strong>definition of Miller indices (hkl)</strong> and be able to accurately represent crystal planes</li>
<li>Understand the <strong>notation for crystal directions [uvw]</strong> and be able to describe vectors within crystals</li>
<li>Execute <strong>calculation of interplanar spacing d<sub>hkl</sub></strong> for each crystal system</li>
<li>Identify <strong>equivalent planes and directions based on symmetry</strong></li>
<li>Deepen practical understanding through <strong>application examples in real materials</strong></li>
</ul>
</div>
<h2>1. What are Miller Indices?</h2>
<p>
            In crystallography, <strong>Miller indices</strong> are the <strong>standard notation for representing planes and directions</strong> within crystals.
            They were proposed in 1839 by British mineralogist William Hallowes Miller.
        </p>
<h3>1.1 Why Miller Indices are Needed</h3>
<p>Infinite planes and directions exist within crystals. A method to uniquely and concisely express these is necessary:</p>
<ul>
<li><strong>Universality</strong>: Can be used with a common notation across all crystal systems</li>
<li><strong>Conciseness</strong>: Planes can be specified with three integers (h, k, l)</li>
<li><strong>Expression of symmetry</strong>: Can identify equivalent planes that reflect crystal symmetry</li>
<li><strong>Correspondence with X-ray diffraction</strong>: Directly corresponds to peaks in diffraction patterns</li>
</ul>
<div class="info-box">
<h4>Notational Conventions</h4>
<ul>
<li><strong>(hkl)</strong>: Represents a specific crystal plane</li>
<li><strong>{hkl}</strong>: Set of all equivalent planes based on symmetry</li>
<li><strong>[uvw]</strong>: Represents a specific crystal direction</li>
<li><strong>&lt;uvw&gt;</strong>: Set of all equivalent directions based on symmetry</li>
<li><strong>Negative values</strong>: Indicated by a bar over the number (e.g., \(\bar{1}\) is -1)</li>
</ul>
</div>
<h3>1.2 Definition of Miller Indices</h3>
<p>Miller indices (hkl) are determined through the following procedure:</p>
<div class="mermaid">
            flowchart TD
                A[Find the intersection points of the crystal plane with the three crystal axes] --&gt; B[Divide each intercept by the lattice constant]
                B --&gt; C[Take the reciprocals of each value]
                C --&gt; D[Multiply by the least common multiple to convert to integers]
                D --&gt; E[Obtain Miller indices hkl]

                style A fill:#e3f2fd
                style B fill:#e3f2fd
                style C fill:#fff3e0
                style D fill:#fff3e0
                style E fill:#e8f5e9
        </div>
<div class="example-box">
<h4>Example: How to Find the (111) Plane</h4>
<ol>
<li><strong>Intercepts</strong>: The intercepts are 1 lattice constant on all a, b, and c axes</li>
<li><strong>Divide by lattice constant</strong>: 1/a, 1/b, 1/c = 1, 1, 1</li>
<li><strong>Reciprocals</strong>: 1/1, 1/1, 1/1 = 1, 1, 1</li>
<li><strong>Convert to integers</strong>: Already integers, so keep as is</li>
<li><strong>Result</strong>: Miller indices are <strong>(111)</strong></li>
</ol>
</div>
<div class="example-box">
<h4>Example: How to Find the (200) Plane</h4>
<ol>
<li><strong>Intercepts</strong>: Intercept at 1/2 on a-axis, infinity (parallel) on b and c axes</li>
<li><strong>Divide by lattice constant</strong>: 1/2, ‚àû, ‚àû</li>
<li><strong>Reciprocals</strong>: 2, 0, 0</li>
<li><strong>Result</strong>: Miller indices are <strong>(200)</strong></li>
</ol>
<p>This means planes arranged at twice the density of the (100) plane.</p>
</div>
<h2>2. Calculating Miller Indices with Python</h2>
<h3>2.1 Finding Miller Indices from Intercepts</h3>
<div class="example-box">
<h4>Code Example 1: Calculation of Miller Indices</h4>
<p>A program that automatically calculates Miller indices from intercepts with crystal axes:</p>
</div>
<pre class="line-numbers"><code class="language-python">import numpy as np
from fractions import Fraction

def calculate_miller_indices(intercepts):
    """
    Calculate Miller indices from intercepts

    Parameters:
    -----------
    intercepts : tuple of float
        (a-axis intercept, b-axis intercept, c-axis intercept)
        Use np.inf for infinity

    Returns:
    --------
    tuple : Miller indices (h, k, l)
    """
    # Calculate reciprocals (reciprocal of infinity is 0)
    reciprocals = []
    for intercept in intercepts:
        if np.isinf(intercept):
            reciprocals.append(0)
        else:
            reciprocals.append(1 / intercept)

    # Handle as fractions and find least common multiple
    fractions = [Fraction(r).limit_denominator(100) for r in reciprocals]

    # Calculate least common multiple of denominators
    denominators = [f.denominator for f in fractions]
    lcm = np.lcm.reduce(denominators)

    # Convert to integers
    h, k, l = [int(f * lcm) for f in fractions]

    # Simplify by greatest common divisor
    gcd = np.gcd.reduce([abs(h), abs(k), abs(l)])
    if gcd &gt; 0:
        h, k, l = h // gcd, k // gcd, l // gcd

    return (h, k, l)

# Test examples
print("=== Miller Indices Calculation ===\n")

# (111) plane: intercept of 1 on all axes
intercepts_111 = (1, 1, 1)
hkl = calculate_miller_indices(intercepts_111)
print(f"Intercepts {intercepts_111} ‚Üí Miller indices {hkl}")

# (100) plane: intercept only on a-axis, parallel to others
intercepts_100 = (1, np.inf, np.inf)
hkl = calculate_miller_indices(intercepts_100)
print(f"Intercepts {intercepts_100} ‚Üí Miller indices {hkl}")

# (110) plane: intercepts on a and b axes, parallel to c-axis
intercepts_110 = (1, 1, np.inf)
hkl = calculate_miller_indices(intercepts_110)
print(f"Intercepts {intercepts_110} ‚Üí Miller indices {hkl}")

# (210) plane: intercept at 1/2 on a-axis, 1 on b-axis
intercepts_210 = (0.5, 1, np.inf)
hkl = calculate_miller_indices(intercepts_210)
print(f"Intercepts {intercepts_210} ‚Üí Miller indices {hkl}")

# (123) plane: different intercepts
intercepts_123 = (1, 0.5, 0.333333)
hkl = calculate_miller_indices(intercepts_123)
print(f"Intercepts {intercepts_123} ‚Üí Miller indices {hkl}")
</code></pre>
<div class="success-box">
<h4>Execution Result</h4>
<pre><code>=== Miller Indices Calculation ===

Intercepts (1, 1, 1) ‚Üí Miller indices (1, 1, 1)
Intercepts (1, inf, inf) ‚Üí Miller indices (1, 0, 0)
Intercepts (1, 1, inf) ‚Üí Miller indices (1, 1, 0)
Intercepts (0.5, 1, inf) ‚Üí Miller indices (2, 1, 0)
Intercepts (1, 0.5, 0.333333) ‚Üí Miller indices (1, 2, 3)</code></pre>
</div>
<h3>2.2 Visualization of Major Low-Index Planes</h3>
<div class="example-box">
<h4>Code Example 2: 3D Display of Major Planes in Cubic Crystals</h4>
<p>Visualize representative crystal planes to understand the meaning of Miller indices:</p>
</div>
<pre class="line-numbers"><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from mpl_toolkits.mplot3d.art3d import Poly3DCollection

def plot_lattice_plane(hkl, ax, color='cyan', alpha=0.6):
    """
    Draw crystal plane specified by Miller indices

    Parameters:
    -----------
    hkl : tuple
        Miller indices (h, k, l)
    ax : Axes3D
        matplotlib 3D axes
    color : str
        plane color
    alpha : float
        transparency
    """
    h, k, l = hkl

    # Calculate intercepts (set large value for 0)
    intercepts = []
    for index in [h, k, l]:
        if index == 0:
            intercepts.append(10)  # Large value instead of infinity
        else:
            intercepts.append(1 / index)

    # Calculate vertices constituting the plane
    vertices = []

    # Set vertices by case
    if h != 0 and k != 0 and l != 0:
        # (111) type: has three intercepts
        vertices = [
            [intercepts[0], 0, 0],
            [0, intercepts[1], 0],
            [0, 0, intercepts[2]]
        ]
    elif h != 0 and k != 0 and l == 0:
        # (110) type: two intercepts, parallel to c-axis
        vertices = [
            [intercepts[0], 0, 0],
            [intercepts[0], 0, 2],
            [0, intercepts[1], 2],
            [0, intercepts[1], 0]
        ]
    elif h != 0 and k == 0 and l == 0:
        # (100) type: one intercept, parallel to other axes
        vertices = [
            [intercepts[0], 0, 0],
            [intercepts[0], 2, 0],
            [intercepts[0], 2, 2],
            [intercepts[0], 0, 2]
        ]

    # Draw plane
    if len(vertices) &gt; 0:
        poly = Poly3DCollection([vertices], alpha=alpha, facecolor=color, edgecolor='black', linewidth=2)
        ax.add_collection3d(poly)

def plot_crystal_axes():
    """Display crystal axes and major planes of cubic crystal"""
    fig = plt.figure(figsize=(15, 5))

    planes = [
        ((1, 0, 0), 'cyan', '(100) Plane'),
        ((1, 1, 0), 'yellow', '(110) Plane'),
        ((1, 1, 1), 'magenta', '(111) Plane')
    ]

    for idx, (hkl, color, title) in enumerate(planes):
        ax = fig.add_subplot(1, 3, idx + 1, projection='3d')

        # Draw crystal axes
        ax.quiver(0, 0, 0, 1.5, 0, 0, color='red', arrow_length_ratio=0.1, linewidth=2, label='a-axis')
        ax.quiver(0, 0, 0, 0, 1.5, 0, color='green', arrow_length_ratio=0.1, linewidth=2, label='b-axis')
        ax.quiver(0, 0, 0, 0, 0, 1.5, color='blue', arrow_length_ratio=0.1, linewidth=2, label='c-axis')

        # Draw crystal plane
        plot_lattice_plane(hkl, ax, color=color, alpha=0.6)

        # Axis labels
        ax.set_xlabel('a', fontsize=12, fontweight='bold')
        ax.set_ylabel('b', fontsize=12, fontweight='bold')
        ax.set_zlabel('c', fontsize=12, fontweight='bold')

        ax.set_xlim([0, 1.5])
        ax.set_ylim([0, 1.5])
        ax.set_zlim([0, 1.5])

        ax.set_title(title, fontsize=14, fontweight='bold')
        ax.legend(loc='upper left', fontsize=8)

        # Add grid
        ax.grid(True, alpha=0.3)

    plt.tight_layout()
    plt.savefig('miller_indices_planes.png', dpi=150, bbox_inches='tight')
    plt.show()
    print("Saved visualization of major crystal planes: miller_indices_planes.png")

# Execute
plot_crystal_axes()
</code></pre>
<h2>3. Calculation of Interplanar Spacing d<sub>hkl</sub></h2>
<p>
            The <strong>interplanar spacing d<sub>hkl</sub></strong> of crystal planes specified by Miller indices (hkl)
            is an important parameter that determines the position of Bragg peaks observed in X-ray diffraction experiments.
        </p>
<h3>3.1 Interplanar Spacing in Cubic Crystal Systems</h3>
<p>In cubic crystals (a = b = c, Œ± = Œ≤ = Œ≥ = 90¬∞), the interplanar spacing is expressed with a very concise formula:</p>
<div class="formula-block">
            $$
            d_{hkl} = \frac{a}{\sqrt{h^2 + k^2 + l^2}}
            $$
        </div>
<p>Where a is the lattice constant, and h, k, l are Miller indices.</p>
<div class="example-box">
<h4>Code Example 3: Calculation of Interplanar Spacing in Cubic Crystals</h4>
</div>
<pre class="line-numbers"><code class="language-python">import numpy as np
import matplotlib.pyplot as plt

def cubic_d_spacing(a, h, k, l):
    """
    Calculate interplanar spacing for cubic crystal system

    Parameters:
    -----------
    a : float
        Lattice constant (√Ö)
    h, k, l : int
        Miller indices

    Returns:
    --------
    float : Interplanar spacing d_hkl (√Ö)
    """
    return a / np.sqrt(h**2 + k**2 + l**2)

# Calculation for Silicon (cubic, a = 5.431 √Ö)
a_Si = 5.431

print("=== Interplanar Spacing for Silicon (Si) ===")
print(f"Lattice constant a = {a_Si} √Ö\n")

# Calculate interplanar spacing for major planes
planes = [
    (1, 0, 0), (1, 1, 0), (1, 1, 1),
    (2, 0, 0), (2, 2, 0), (3, 1, 1),
    (2, 2, 2), (4, 0, 0), (3, 3, 1)
]

results = []
for hkl in planes:
    h, k, l = hkl
    d = cubic_d_spacing(a_Si, h, k, l)
    results.append((hkl, d))
    print(f"({h}{k}{l}) plane: d = {d:.4f} √Ö")

# Visualize with graph
fig, ax = plt.subplots(figsize=(12, 6))

hkl_labels = [f"({h}{k}{l})" for (h, k, l), d in results]
d_values = [d for hkl, d in results]

bars = ax.bar(range(len(results)), d_values, color='skyblue', edgecolor='navy', linewidth=1.5)
ax.set_xticks(range(len(results)))
ax.set_xticklabels(hkl_labels, rotation=45, ha='right')
ax.set_ylabel('Interplanar Spacing d (√Ö)', fontsize=12, fontweight='bold')
ax.set_xlabel('Miller Indices', fontsize=12, fontweight='bold')
ax.set_title('Interplanar Spacing by Crystal Plane for Silicon (Si)', fontsize=14, fontweight='bold')
ax.grid(axis='y', alpha=0.3)

# Display values on top of bars
for i, (bar, d) in enumerate(zip(bars, d_values)):
    ax.text(bar.get_x() + bar.get_width()/2, bar.get_height() + 0.05,
            f'{d:.3f}', ha='center', va='bottom', fontsize=9)

plt.tight_layout()
plt.savefig('si_d_spacing.png', dpi=150, bbox_inches='tight')
plt.show()
print("\nSaved graph: si_d_spacing.png")
</code></pre>
<h3>3.2 Interplanar Spacing in Tetragonal Crystal Systems</h3>
<p>In tetragonal crystals (a = b ‚â† c, Œ± = Œ≤ = Œ≥ = 90¬∞), the formula changes because the lattice constant in the c-axis direction is different:</p>
<div class="formula-block">
            $$
            d_{hkl} = \frac{1}{\sqrt{\frac{h^2 + k^2}{a^2} + \frac{l^2}{c^2}}}
            $$
        </div>
<div class="example-box">
<h4>Code Example 4: Calculation of Interplanar Spacing in Tetragonal Crystals</h4>
</div>
<pre class="line-numbers"><code class="language-python">def tetragonal_d_spacing(a, c, h, k, l):
    """
    Calculate interplanar spacing for tetragonal crystal system

    Parameters:
    -----------
    a : float
        a-axis (= b-axis) lattice constant (√Ö)
    c : float
        c-axis lattice constant (√Ö)
    h, k, l : int
        Miller indices

    Returns:
    --------
    float : Interplanar spacing d_hkl (√Ö)
    """
    return 1 / np.sqrt((h**2 + k**2) / a**2 + l**2 / c**2)

# TiO2 rutile (tetragonal, a = 4.594 √Ö, c = 2.958 √Ö)
a_TiO2 = 4.594
c_TiO2 = 2.958

print("=== Interplanar Spacing for TiO2 (Rutile) ===")
print(f"Lattice constants a = {a_TiO2} √Ö, c = {c_TiO2} √Ö")
print(f"c/a ratio = {c_TiO2/a_TiO2:.3f}\n")

planes_tetragonal = [
    (1, 0, 0), (0, 0, 1), (1, 1, 0),
    (1, 0, 1), (1, 1, 1), (2, 0, 0),
    (2, 1, 0), (2, 1, 1), (2, 2, 0)
]

# Comparison: when incorrectly assumed to be cubic
print("Correctly calculated as tetragonal vs. incorrectly assumed as cubic:\n")
for hkl in planes_tetragonal[:5]:
    h, k, l = hkl
    d_correct = tetragonal_d_spacing(a_TiO2, c_TiO2, h, k, l)
    d_wrong = cubic_d_spacing(a_TiO2, h, k, l)  # Incorrect assumption
    error = abs(d_correct - d_wrong) / d_correct * 100

    print(f"({h}{k}{l}) plane:")
    print(f"  Correct d = {d_correct:.4f} √Ö")
    print(f"  Incorrect d = {d_wrong:.4f} √Ö (Error: {error:.2f}%)\n")
</code></pre>
<div class="warning-box">
<h4>Important Note</h4>
<p>
                Incorrectly assuming the crystal system leads to significantly wrong interplanar spacing calculations.
                Especially when treating tetragonal crystals with significantly different c-axis as cubic, notable errors occur in planes involving the c-axis such as (001).
            </p>
</div>
<h3>3.3 Interplanar Spacing in Hexagonal Crystal Systems</h3>
<p>
            Hexagonal crystals (a = b ‚â† c, Œ± = Œ≤ = 90¬∞, Œ≥ = 120¬∞) often use <strong>four-index notation (hkil)</strong>,
            where i = -(h+k).
        </p>
<div class="formula-block">
            $$
            d_{hkl} = \frac{1}{\sqrt{\frac{4}{3}\frac{h^2 + hk + k^2}{a^2} + \frac{l^2}{c^2}}}
            $$
        </div>
<div class="example-box">
<h4>Code Example 5: Calculation of Interplanar Spacing in Hexagonal Crystals</h4>
</div>
<pre class="line-numbers"><code class="language-python">def hexagonal_d_spacing(a, c, h, k, l):
    """
    Calculate interplanar spacing for hexagonal crystal system

    Parameters:
    -----------
    a : float
        a-axis (= b-axis) lattice constant (√Ö)
    c : float
        c-axis lattice constant (√Ö)
    h, k, l : int
        Miller indices (3-axis notation)

    Returns:
    --------
    float : Interplanar spacing d_hkl (√Ö)
    """
    return 1 / np.sqrt((4/3) * (h**2 + h*k + k**2) / a**2 + l**2 / c**2)

def miller_to_miller_bravais(h, k, l):
    """
    Convert 3-axis Miller indices to 4-axis Miller-Bravais indices

    Parameters:
    -----------
    h, k, l : int
        3-axis Miller indices

    Returns:
    --------
    tuple : 4-axis indices (h, k, i, l) where i = -(h+k)
    """
    i = -(h + k)
    return (h, k, i, l)

# Œ±-Al2O3 (corundum, hexagonal, a = 4.759 √Ö, c = 12.991 √Ö)
a_Al2O3 = 4.759
c_Al2O3 = 12.991

print("=== Interplanar Spacing for Œ±-Al2O3 (Corundum) ===")
print(f"Lattice constants a = {a_Al2O3} √Ö, c = {c_Al2O3} √Ö")
print(f"c/a ratio = {c_Al2O3/a_Al2O3:.3f}\n")

planes_hexagonal = [
    (1, 0, 0), (0, 0, 1), (1, 1, 0),
    (1, 0, 1), (1, 1, 2), (2, 0, 0),
    (1, 0, 4), (2, 1, 0), (0, 0, 6)
]

print(f"{'3-axis (hkl)':&lt;15} {'4-axis (hkil)':&lt;20} {'d (√Ö)':&lt;10}")
print("-" * 50)

for hkl in planes_hexagonal:
    h, k, l = hkl
    d = hexagonal_d_spacing(a_Al2O3, c_Al2O3, h, k, l)
    hkil = miller_to_miller_bravais(h, k, l)

    # Display negative values
    hkil_str = "("
    for idx in hkil:
        if idx &lt; 0:
            hkil_str += f"{idx}"
        else:
            hkil_str += f"{idx}"
    hkil_str += ")"

    print(f"({h}{k}{l}){'':&lt;12} {hkil_str:&lt;20} {d:.4f}")
</code></pre>
<div class="info-box">
<h4>Advantage of Four-Index Notation</h4>
<p>
                Using four-index notation (hkil) in hexagonal crystals reflects the 6-fold symmetry of the crystal in the notation.
                For example, {10\(\bar{1}\)0} represents six equivalent planes, which becomes clear in the four-index notation.
            </p>
</div>
<h2>4. Equivalent Planes and Directions (Symmetry)</h2>
<p>
            Due to crystal symmetry, crystallographically <strong>equivalent planes and directions</strong> exist.
            To represent these collectively, curly brackets {hkl} and angle brackets &lt;uvw&gt; are used.
        </p>
<h3>4.1 Equivalent Planes in Cubic Crystals</h3>
<p>In cubic crystals, the following equivalent relationships exist:</p>
<table>
<thead>
<tr>
<th>Notation</th>
<th>Meaning</th>
<th>Example: Equivalent planes in {100}</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>{100}</strong></td>
<td>Set of equivalent planes</td>
<td>(100), (010), (001), (\(\bar{1}\)00), (0\(\bar{1}\)0), (00\(\bar{1}\))</td>
</tr>
<tr>
<td><strong>{110}</strong></td>
<td>Set of equivalent planes</td>
<td>(110), (101), (011), (\(\bar{1}\)10), (\(\bar{1}\)0\(\bar{1}\)), etc., 12 planes</td>
</tr>
<tr>
<td><strong>{111}</strong></td>
<td>Set of equivalent planes</td>
<td>(111), (\(\bar{1}\)11), (1\(\bar{1}\)1), etc., 8 planes</td>
</tr>
</tbody>
</table>
<div class="example-box">
<h4>Code Example 6: Generation of Equivalent Planes</h4>
</div>
<pre class="line-numbers"><code class="language-python">from itertools import permutations, product

def generate_equivalent_planes(h, k, l, crystal_system='cubic'):
    """
    Generate all equivalent planes considering symmetry

    Parameters:
    -----------
    h, k, l : int
        Reference Miller indices
    crystal_system : str
        Crystal system ('cubic', 'tetragonal', 'hexagonal')

    Returns:
    --------
    set : Set of equivalent planes
    """
    planes = set()

    if crystal_system == 'cubic':
        # Cubic: all combinations of signs and permutations
        for perm in permutations([abs(h), abs(k), abs(l)]):
            for signs in product([1, -1], repeat=3):
                plane = tuple(s * p for s, p in zip(signs, perm))
                if plane != (0, 0, 0):  # Exclude (000)
                    planes.add(plane)

    elif crystal_system == 'tetragonal':
        # Tetragonal: a, b axes are equivalent, c-axis is independent
        # Only permutation and sign change of h, k
        for h_sign, k_sign, l_sign in product([1, -1], repeat=3):
            planes.add((h_sign * h, k_sign * k, l_sign * l))
            planes.add((k_sign * k, h_sign * h, l_sign * l))  # Permutation of h, k

    elif crystal_system == 'hexagonal':
        # Hexagonal: more complex symmetry (simplified version)
        # Consider 6-fold rotational symmetry
        for l_sign in [1, -1]:
            planes.add((h, k, l_sign * l))
            planes.add((k, -(h+k), l_sign * l))
            planes.add((-(h+k), h, l_sign * l))

    return sorted(planes)

# Equivalent planes in cubic crystals
print("=== Equivalent Planes in Cubic Crystals ===\n")

for base_plane in [(1, 0, 0), (1, 1, 0), (1, 1, 1)]:
    h, k, l = base_plane
    equiv = generate_equivalent_planes(h, k, l, 'cubic')
    print(f"{{{h}{k}{l}}} equivalent planes ({len(equiv)} total):")

    # Display in formatted manner
    for i in range(0, len(equiv), 6):
        planes_str = ', '.join([f"({p[0]:2}{p[1]:2}{p[2]:2})" for p in equiv[i:i+6]])
        print(f"  {planes_str}")
    print()

# Equivalent planes in tetragonal crystals
print("=== Equivalent Planes in Tetragonal Crystals ===\n")
base_plane = (1, 1, 0)
equiv_tetra = generate_equivalent_planes(*base_plane, 'tetragonal')
print(f"{{{base_plane[0]}{base_plane[1]}{base_plane[2]}}} equivalent planes (tetragonal) ({len(equiv_tetra)} total):")
for plane in equiv_tetra:
    print(f"  ({plane[0]:2}{plane[1]:2}{plane[2]:2})")
</code></pre>
<h3>4.2 Notation for Crystal Directions [uvw]</h3>
<p>
            Crystal directions are represented by <strong>[uvw]</strong>, meaning a <strong>vector</strong> from the origin to coordinates (u¬∑a, v¬∑b, w¬∑c).
        </p>
<ul>
<li><strong>[100]</strong>: a-axis direction</li>
<li><strong>[110]</strong>: diagonal direction of a and b axes</li>
<li><strong>[111]</strong>: body diagonal direction</li>
<li><strong>&lt;100&gt;</strong>: All equivalent directions ([100], [010], [001], etc.)</li>
</ul>
<div class="info-box">
<h4>Relationship Between Planes and Directions</h4>
<p>
                In <strong>cubic crystals</strong>, the direction perpendicular to the (hkl) plane is [hkl].
                However, this is a property specific to cubic crystals and generally does not hold for other crystal systems.
            </p>
</div>
<div class="example-box">
<h4>Code Example 7: Visualization of Crystal Direction Vectors</h4>
</div>
<pre class="line-numbers"><code class="language-python">def plot_crystal_directions():
    """Visualize major crystal directions in cubic crystals"""
    fig = plt.figure(figsize=(15, 5))

    directions = [
        ([1, 0, 0], 'red', '[100]'),
        ([1, 1, 0], 'green', '[110]'),
        ([1, 1, 1], 'blue', '[111]')
    ]

    for idx, (uvw, color, title) in enumerate(directions):
        ax = fig.add_subplot(1, 3, idx + 1, projection='3d')

        # Draw cubic frame
        r = [0, 1]
        for s, e in combinations(np.array(list(product(r, r, r))), 2):
            if np.sum(np.abs(s - e)) == 1:
                ax.plot3D(*zip(s, e), color='gray', alpha=0.3, linewidth=1)

        # Draw direction vector
        ax.quiver(0, 0, 0, uvw[0], uvw[1], uvw[2],
                 color=color, arrow_length_ratio=0.15, linewidth=3,
                 label=f'{title} direction')

        # Axis labels
        ax.set_xlabel('a', fontsize=12, fontweight='bold')
        ax.set_ylabel('b', fontsize=12, fontweight='bold')
        ax.set_zlabel('c', fontsize=12, fontweight='bold')

        ax.set_xlim([0, 1.5])
        ax.set_ylim([0, 1.5])
        ax.set_zlim([0, 1.5])

        ax.set_title(title + ' Crystal Direction', fontsize=14, fontweight='bold')
        ax.legend(loc='upper left')
        ax.grid(True, alpha=0.3)

    plt.tight_layout()
    plt.savefig('crystal_directions.png', dpi=150, bbox_inches='tight')
    plt.show()
    print("Saved crystal direction visualization: crystal_directions.png")

from itertools import combinations, product

# Execute
plot_crystal_directions()
</code></pre>
<h2>5. Applications in Real Materials</h2>
<p>
            Miller indices are used in all areas of materials science.
            Here, we will learn about interplanar spacing calculations and applications using actual materials as examples.
        </p>
<h3>5.1 Interpretation of X-ray Diffraction Patterns</h3>
<p>
            In X-ray diffraction (XRD), peaks are observed at specific angles according to Bragg's law:
        </p>
<div class="formula-block">
            $$
            n\lambda = 2d_{hkl}\sin\theta
            $$
        </div>
<p>
            Where Œª is the X-ray wavelength, Œ∏ is the Bragg angle, and n is the order of reflection (usually 1).
            By knowing the interplanar spacing d<sub>hkl</sub>, we can identify which crystal plane the observed peak is reflected from.
        </p>
<div class="example-box">
<h4>Code Example 8: XRD Peak Prediction for Real Materials</h4>
</div>
<pre class="line-numbers"><code class="language-python">def bragg_angle(d_hkl, wavelength, n=1):
    """
    Calculate diffraction angle from Bragg's law

    Parameters:
    -----------
    d_hkl : float
        Interplanar spacing (√Ö)
    wavelength : float
        X-ray wavelength (√Ö)
    n : int
        Order of reflection (usually 1)

    Returns:
    --------
    float : Bragg angle Œ∏ (degrees), None if diffraction impossible
    """
    sin_theta = n * wavelength / (2 * d_hkl)
    if abs(sin_theta) &gt; 1:
        return None  # Does not satisfy diffraction condition
    return np.degrees(np.arcsin(sin_theta))

def predict_xrd_pattern(material_name, a, c=None, crystal_system='cubic',
                       wavelength=1.5406, max_hkl=3):
    """
    Predict XRD diffraction pattern for material

    Parameters:
    -----------
    material_name : str
        Material name
    a : float
        Lattice constant a (√Ö)
    c : float, optional
        Lattice constant c (√Ö) (for tetragonal/hexagonal)
    crystal_system : str
        Crystal system
    wavelength : float
        X-ray wavelength (√Ö), Cu KŒ± line by default
    max_hkl : int
        Maximum Miller index to calculate
    """
    print(f"\n=== XRD Diffraction Pattern Prediction for {material_name} ===")
    print(f"Crystal system: {crystal_system}")
    print(f"Lattice constants: a = {a:.4f} √Ö" + (f", c = {c:.4f} √Ö" if c else ""))
    print(f"X-ray wavelength: {wavelength:.4f} √Ö (Cu KŒ±)\n")

    print(f"{'(hkl)':&lt;10} {'d (√Ö)':&lt;12} {'2Œ∏ (deg)':&lt;12} {'Intensity':&lt;10}")
    print("-" * 55)

    results = []

    # Generate combinations of Miller indices
    for h in range(max_hkl + 1):
        for k in range(h, max_hkl + 1):
            for l in range(k, max_hkl + 1):
                if h == 0 and k == 0 and l == 0:
                    continue

                # Calculate interplanar spacing
                if crystal_system == 'cubic':
                    d = cubic_d_spacing(a, h, k, l)
                elif crystal_system == 'tetragonal':
                    d = tetragonal_d_spacing(a, c, h, k, l)
                elif crystal_system == 'hexagonal':
                    d = hexagonal_d_spacing(a, c, h, k, l)

                # Calculate Bragg angle
                theta = bragg_angle(d, wavelength)

                if theta is not None and theta &lt; 90:
                    # Simple estimation of relative intensity considering multiplicity (number of equivalent planes)
                    multiplicity = len(generate_equivalent_planes(h, k, l, crystal_system))
                    intensity = multiplicity / (h**2 + k**2 + l**2)  # Simple structure factor

                    results.append(((h, k, l), d, 2 * theta, intensity))

    # Sort by 2Œ∏ in ascending order
    results.sort(key=lambda x: x[2])

    # Display top 10 peaks
    for i, ((h, k, l), d, two_theta, intensity) in enumerate(results[:10]):
        # Visualize intensity
        intensity_bar = '‚ñà' * int(intensity * 10)
        print(f"({h}{k}{l}){'':&lt;8} {d:8.4f}    {two_theta:8.2f}    {intensity_bar}")

# Execute: Predict XRD patterns for representative materials

# 1. Silicon (Si, cubic)
predict_xrd_pattern('Silicon (Si)', a=5.4310, crystal_system='cubic', max_hkl=3)

# 2. Gold (Au, cubic)
predict_xrd_pattern('Gold (Au)', a=4.0782, crystal_system='cubic', max_hkl=2)

# 3. TiO2 rutile (tetragonal)
predict_xrd_pattern('TiO2 (Rutile)', a=4.594, c=2.958,
                   crystal_system='tetragonal', max_hkl=2)

# 4. Œ±-Al2O3 (hexagonal)
predict_xrd_pattern('Œ±-Al2O3 (Corundum)', a=4.759, c=12.991,
                   crystal_system='hexagonal', max_hkl=2)
</code></pre>
<div class="success-box">
<h4>Application to XRD Analysis</h4>
<p>
                This program is a basic tool for comparing experimentally obtained XRD patterns with theoretical calculations.
                In actual analysis, structure factors and temperature factors based on atomic positions must also be considered,
                but understanding Miller indices and interplanar spacing forms the foundation for everything.
            </p>
</div>
<h3>5.2 Material Anisotropy and Crystal Planes</h3>
<p>
            Material properties vary greatly depending on crystal planes. For example:
        </p>
<ul>
<li><strong>Surface energy</strong>: {111} planes have lower surface energy than {100} planes (fcc metals)</li>
<li><strong>Growth rate</strong>: Specific planes grow preferentially, determining crystal shape</li>
<li><strong>Catalytic activity</strong>: Specific planes show high reactivity</li>
<li><strong>Mechanical properties</strong>: Slip systems are determined by specific plane and direction combinations</li>
</ul>
<h2>6. Exercises</h2>
<div class="exercise">
<h3>Exercise 1: Determining Miller Indices</h3>
<p>
                For a cubic crystal, determine the Miller indices for crystal planes with the following intercepts:
            </p>
<ol>
<li>Intercept at 2 on a-axis, 1 on b-axis, infinity (parallel) on c-axis</li>
<li>Intercept at 1 on a-axis, 1 on b-axis, 2 on c-axis</li>
<li>Intercept at -1 on a-axis, 1 on b-axis, 1 on c-axis</li>
</ol>
<details>
<summary>View Answer</summary>
<ol>
<li>Intercepts (2, 1, ‚àû) ‚Üí Reciprocals (1/2, 1, 0) ‚Üí Convert to integers (1, 2, 0) ‚Üí <strong>(120)</strong></li>
<li>Intercepts (1, 1, 2) ‚Üí Reciprocals (1, 1, 1/2) ‚Üí Convert to integers (2, 2, 1) ‚Üí <strong>(221)</strong></li>
<li>Intercepts (-1, 1, 1) ‚Üí Reciprocals (-1, 1, 1) ‚Üí <strong>(\(\bar{1}\)11)</strong></li>
</ol>
</details>
</div>
<div class="exercise">
<h3>Exercise 2: Calculation of Interplanar Spacing</h3>
<p>
                Copper (Cu) has a face-centered cubic structure (fcc) with lattice constant a = 3.615 √Ö.
                Calculate the interplanar spacing for the following planes:
            </p>
<ol>
<li>(111) plane</li>
<li>(200) plane</li>
<li>(220) plane</li>
</ol>
<p>
                Also, calculate at what angles (2Œ∏) diffraction peaks from these planes will appear in XRD measurements using Cu KŒ± radiation (Œª = 1.5406 √Ö).
            </p>
<details>
<summary>View Answer</summary>
<p><strong>Interplanar spacings:</strong></p>
<ol>
<li>d<sub>111</sub> = 3.615 / ‚àö3 = 2.087 √Ö</li>
<li>d<sub>200</sub> = 3.615 / ‚àö4 = 1.808 √Ö</li>
<li>d<sub>220</sub> = 3.615 / ‚àö8 = 1.278 √Ö</li>
</ol>
<p><strong>Bragg angles:</strong> (from Œª = 2d sinŒ∏)</p>
<ol>
<li>2Œ∏<sub>111</sub> = 2 √ó arcsin(1.5406/(2√ó2.087)) ‚âà 43.3¬∞</li>
<li>2Œ∏<sub>200</sub> = 2 √ó arcsin(1.5406/(2√ó1.808)) ‚âà 50.4¬∞</li>
<li>2Œ∏<sub>220</sub> = 2 √ó arcsin(1.5406/(2√ó1.278)) ‚âà 74.1¬∞</li>
</ol>
</details>
</div>
<div class="exercise">
<h3>Exercise 3: Understanding Equivalent Planes</h3>
<p>
                In a cubic crystal, list all equivalent planes included in {110}.
                Also, state how many planes there are.
            </p>
<details>
<summary>View Answer</summary>
<p><strong>Answer: 12 planes</strong></p>
<p>Equivalent planes:</p>
<ul>
<li>(110), (101), (011)</li>
<li>(\(\bar{1}\)10), (\(\bar{1}\)0\(\bar{1}\)), (0\(\bar{1}\)\(\bar{1}\))</li>
<li>(1\(\bar{1}\)0), (10\(\bar{1}\)), (01\(\bar{1}\))</li>
<li>(\(\bar{1}\)\(\bar{1}\)0), (\(\bar{1}\)0\(\bar{1}\)), (0\(\bar{1}\)1)</li>
</ul>
<p>
                    These become equivalent due to the symmetry of cubic crystals (24 symmetry operations)
                    and have the same physical properties.
                </p>
</details>
</div>
<div class="exercise">
<h3>Exercise 4: Programming Assignment</h3>
<p>
                For a tetragonal material (e.g., ZrO2, a = 3.64 √Ö, c = 5.27 √Ö),
                create a Python program that performs the following:
            </p>
<ol>
<li>Calculate interplanar spacing for all planes from (100) to (333)</li>
<li>Extract only planes with interplanar spacing of 2.0 √Ö or greater</li>
<li>Sort and display results in descending order of interplanar spacing</li>
</ol>
<details>
<summary>Hint</summary>
<p>
                    Use the <code>tetragonal_d_spacing</code> function from Code Example 4,
                    and calculate by varying h, k, l from 1 to 3 in a triple loop.
                    Results can be stored in a list and sorted using the <code>sorted()</code> function.
                </p>
</details>
</div>
<h2>Summary</h2>
<p>In this chapter, we learned about <strong>Miller indices</strong>, the most important notation in crystallography:</p>
<div class="success-box">
<h4>Key Points</h4>
<ul>
<li><strong>Miller indices (hkl)</strong> are the standard notation representing crystal planes with three integers</li>
<li><strong>Interplanar spacing d<sub>hkl</sub></strong> is calculated using different formulas for each crystal system</li>
<li><strong>Cubic crystals</strong>: d = a / ‚àö(h¬≤ + k¬≤ + l¬≤)</li>
<li><strong>Tetragonal and hexagonal crystals</strong>: Contribution of c-axis must be considered separately</li>
<li><strong>Crystal directions [uvw]</strong> are expressed with different notation from planes</li>
<li><strong>Symmetry</strong> creates many equivalent planes and directions</li>
<li><strong>X-ray diffraction</strong> applications form the foundation of material identification and structure analysis</li>
</ul>
</div>
<p>
            In the next chapter, we will learn in detail about <strong>the principles of X-ray diffraction and Bragg's law</strong>,
            applying knowledge of Miller indices and interplanar spacing to actual structure analysis.
        </p>
<div class="navigation">
<a class="nav-button prev" href="chapter-2.html">Chapter 2: Bravais Lattices and Space Groups</a>
<a class="nav-button next" href="chapter-4.html">Chapter 4: X-ray Diffraction and Bragg's Law</a>
</div>
</div>
<section class="disclaimer">
<h3>Disclaimer</h3>
<ul>
<li>This content is provided solely for educational, research, and informational purposes and does not constitute professional advice (legal, accounting, technical warranty, etc.).</li>
<li>This content and accompanying code examples are provided "AS IS" without any warranty, express or implied, including but not limited to merchantability, fitness for a particular purpose, non-infringement, accuracy, completeness, operation, or safety.</li>
<li>The author and Tohoku University assume no responsibility for the content, availability, or safety of external links, third-party data, tools, libraries, etc.</li>
<li>To the maximum extent permitted by applicable law, the author and Tohoku University shall not be liable for any direct, indirect, incidental, special, consequential, or punitive damages arising from the use, execution, or interpretation of this content.</li>
<li>The content may be changed, updated, or discontinued without notice.</li>
<li>The copyright and license of this content are subject to the stated conditions (e.g., CC BY 4.0). Such licenses typically include no-warranty clauses.</li>
</ul>
</section>

<footer style="background-color: var(--color-bg-alt); padding: var(--spacing-lg); text-align: center; margin-top: var(--spacing-xl); border-top: 2px solid var(--color-border);">
<p style="margin-bottom: var(--spacing-sm); color: var(--color-text-light);">
            ¬© 2025 AI Terakoya MS Dojo - Introduction to Crystallography
        </p>
<p style="font-size: 0.9rem; color: var(--color-text-light);">
<a href="../index.html" style="color: var(--color-link);">AI Terakoya Top</a> |
            <a href="../index.html" style="color: var(--color-link);">MS Dojo</a> |
            <a href="index.html" style="color: var(--color-link);">Introduction to Crystallography Top</a>
</p>
</footer>
</body>
</html>
