<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Chapter 1: Fundamentals of Electrical Conductivity Measurement - MS Terakoya</title>
<style>
        :root {
            --color-primary: #2c3e50;
            --color-primary-dark: #1a252f;
            --color-accent: #f093fb;
            --color-accent-light: #f5576c;
            --color-text: #2d3748;
            --color-text-light: #4a5568;
            --color-bg: #ffffff;
            --color-bg-alt: #f7fafc;
            --color-border: #e2e8f0;
            --color-code-bg: #f8f9fa;
            --color-link: #f093fb;
            --color-link-hover: #d07be8;

            --spacing-xs: 0.5rem;
            --spacing-sm: 1rem;
            --spacing-md: 1.5rem;
            --spacing-lg: 2rem;
            --spacing-xl: 3rem;

            --font-body: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            --font-mono: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;

            --border-radius: 8px;
            --box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-body);
            line-height: 1.7;
            color: var(--color-text);
            background-color: var(--color-bg);
            font-size: 16px;
        }

        header {
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            color: white;
            padding: var(--spacing-xl) var(--spacing-md);
            margin-bottom: var(--spacing-xl);
            box-shadow: var(--box-shadow);
        }

        .header-content {
            max-width: 900px;
            margin: 0 auto;
        }

        h1 {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: var(--spacing-sm);
            line-height: 1.2;
        }

        .subtitle {
            font-size: 1.1rem;
            opacity: 0.95;
            font-weight: 400;
            margin-bottom: var(--spacing-md);
        }

        .meta {
            display: flex;
            flex-wrap: wrap;
            gap: var(--spacing-md);
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .meta-item {
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 0 var(--spacing-md) var(--spacing-xl);
        }

        h2 {
            font-size: 1.75rem;
            color: var(--color-primary);
            margin-top: var(--spacing-xl);
            margin-bottom: var(--spacing-md);
            padding-bottom: var(--spacing-xs);
            border-bottom: 3px solid var(--color-accent);
        }

        h3 {
            font-size: 1.4rem;
            color: var(--color-primary);
            margin-top: var(--spacing-lg);
            margin-bottom: var(--spacing-sm);
        }

        h4 {
            font-size: 1.1rem;
            color: var(--color-primary-dark);
            margin-top: var(--spacing-md);
            margin-bottom: var(--spacing-sm);
        }

        p {
            margin-bottom: var(--spacing-md);
            color: var(--color-text);
        }

        a {
            color: var(--color-link);
            text-decoration: none;
            transition: color 0.2s;
        }

        a:hover {
            color: var(--color-link-hover);
            text-decoration: underline;
        }

        ul, ol {
            margin-left: var(--spacing-lg);
            margin-bottom: var(--spacing-md);
        }

        li {
            margin-bottom: var(--spacing-xs);
            color: var(--color-text);
        }

        pre {
            background-color: var(--color-code-bg);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            overflow-x: auto;
            margin-bottom: var(--spacing-md);
            font-family: var(--font-mono);
            font-size: 0.9rem;
            line-height: 1.5;
        }

        code {
            font-family: var(--font-mono);
            font-size: 0.9em;
            background-color: var(--color-code-bg);
            padding: 0.2em 0.4em;
            border-radius: 3px;
        }

        pre code {
            background-color: transparent;
            padding: 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: var(--spacing-md);
            font-size: 0.95rem;
        }

        th, td {
            border: 1px solid var(--color-border);
            padding: var(--spacing-sm);
            text-align: left;
        }

        th {
            background-color: var(--color-bg-alt);
            font-weight: 600;
            color: var(--color-primary);
        }

        blockquote {
            border-left: 4px solid var(--color-accent);
            padding-left: var(--spacing-md);
            margin: var(--spacing-md) 0;
            color: var(--color-text-light);
            font-style: italic;
            background-color: var(--color-bg-alt);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        .mermaid {
            text-align: center;
            margin: var(--spacing-lg) 0;
            background-color: var(--color-bg-alt);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        .learning-objectives {
            background: linear-gradient(135deg, #fce7f3 0%, #fbcfe8 100%);
            padding: var(--spacing-lg);
            border-radius: var(--border-radius);
            border-left: 4px solid var(--color-accent);
            margin-bottom: var(--spacing-xl);
        }

        .learning-objectives h2 {
            margin-top: 0;
            border-bottom: none;
        }

        .breadcrumb {
            max-width: 900px;
            margin: 0 auto;
            padding: var(--spacing-sm) var(--spacing-md);
            font-size: 0.9rem;
            color: var(--color-text-light);
        }

        .breadcrumb a {
            color: var(--color-link);
            text-decoration: none;
        }

        .breadcrumb a:hover {
            text-decoration: underline;
        }

        .navigation {
            display: flex;
            justify-content: space-between;
            gap: var(--spacing-md);
            margin: var(--spacing-xl) 0;
            padding-top: var(--spacing-lg);
            border-top: 2px solid var(--color-border);
        }

        .nav-button {
            flex: 1;
            padding: var(--spacing-md);
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            color: white;
            border-radius: var(--border-radius);
            text-align: center;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: var(--box-shadow);
        }

        .nav-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            text-decoration: none;
        }

        details {
            background-color: var(--color-bg-alt);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            margin-bottom: var(--spacing-md);
        }

        summary {
            font-weight: 600;
            cursor: pointer;
            color: var(--color-primary);
        }

        summary:hover {
            color: var(--color-accent);
        }

        .exercise-label {
            display: inline-block;
            padding: 0.2rem 0.6rem;
            border-radius: 4px;
            font-size: 0.85rem;
            font-weight: 600;
            margin-right: 0.5rem;
        }

        .easy {
            background-color: #d4edda;
            color: #155724;
        }

        .medium {
            background-color: #fff3cd;
            color: #856404;
        }

        .hard {
            background-color: #f8d7da;
            color: #721c24;
        }

        footer {
            margin-top: var(--spacing-xl);
            padding: var(--spacing-lg) var(--spacing-md);
            background-color: var(--color-bg-alt);
            border-top: 1px solid var(--color-border);
            text-align: center;
            font-size: 0.9rem;
            color: var(--color-text-light);
        }
        .disclaimer {
            max-width: 900px;
            margin: 2rem auto;
            padding: 1.5rem;
            background: #f8f9fa;
            border-left: 4px solid #6c757d;
            border-radius: 4px;
        }

        .disclaimer h3 {
            color: #495057;
            margin-bottom: 1rem;
            font-size: 1.1rem;
        }

        .disclaimer ul {
            list-style: none;
            padding-left: 0;
        }

        .disclaimer li {
            padding: 0.5rem 0;
            padding-left: 1.5rem;
            position: relative;
            font-size: 0.9rem;
            color: #6c757d;
            line-height: 1.6;
        }

        .disclaimer li::before {
            content: "¬†";
            position: absolute;
            left: 0;
        }


        @media (max-width: 768px) {
            h1 {
                font-size: 1.5rem;
            }

            h2 {
                font-size: 1.4rem;
            }

            h3 {
                font-size: 1.2rem;
            }

            .meta {
                font-size: 0.85rem;
            }

            .navigation {
                flex-direction: column;
            }

            table {
                font-size: 0.85rem;
            }

            th, td {
                padding: var(--spacing-xs);
            }
        }
    </style>
<!-- Prism.js for syntax highlighting -->
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet"/>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
<script>
        mermaid.initialize({ startOnLoad: true, theme: 'default', securityLevel: 'strict' });
    </script>
<script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true,
                processEnvironments: true
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
                ignoreHtmlClass: 'mermaid'
            }
        };
    </script>
<script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body><div class="locale-switcher">
<span class="current-locale">üåê EN</span>
<span class="locale-separator">|</span>
<span class="locale-meta">Last sync: 2025-11-16</span>
</div>
<header>
<div class="header-content">
<h1>Chapter 1: Fundamentals of Electrical Conductivity Measurement</h1>
<p class="subtitle">From Drude Model to Four-Point Probe, van der Pauw Method, and Temperature-Dependent Analysis</p>
<div class="meta">
<span class="meta-item">=√ñ Reading Time: 40-50 min</span>
<span class="meta-item">=√ä Level: Intermediate</span>
<span class="meta-item">=¬ª Code Examples: 7</span>
</div>
</div>
</header>
<div class="breadcrumb">
<a href="../index.html">AI Terakoya Top</a> &gt;
        <a href="../index.html">MS Dojo</a> &gt;
        <a href="index.html">Introduction to Electrical and Magnetic Measurements</a> &gt;
        Chapter 1
    </div>
<main class="container">
<p class="chapter-description" style="margin: 1.5rem 0; padding: 1rem; background: linear-gradient(135deg, #fce7f3 0%, #fbcfe8 100%); border-left: 4px solid #f093fb; border-radius: 8px; font-size: 1.05rem; line-height: 1.8; color: #2d3748;">
            Electrical conductivity measurement is a fundamental method for quantitatively evaluating the electrical properties of materials. In this chapter, you will learn the theoretical foundations of electrical conduction through the Drude model, the differences between two-terminal and four-terminal measurements, the van der Pauw method for measuring arbitrarily shaped samples, information about carrier scattering mechanisms obtained from temperature dependence, and practical data analysis using Python.
        </p>
<div class="learning-objectives">
<h2>Learning Objectives</h2>
<p>By reading this chapter, you will master the following:</p>
<ul>
<li> Understand the Drude model and derive the electrical conductivity equation $\sigma = ne^2\tau/m$</li>
<li> Explain the principles and differences between two-terminal and four-terminal measurements</li>
<li> Understand the theory of the van der Pauw method and implement it in Python</li>
<li> Evaluate the effects of contact resistance and perform appropriate corrections</li>
<li> Analyze carrier scattering mechanisms from temperature-dependent data</li>
<li> Understand the relationship between sheet resistance and bulk resistivity</li>
<li> Perform fitting and uncertainty evaluation using Python</li>
</ul>
</div>
<h2>1.1 Drude Model of Electrical Conduction</h2>
<h3>1.1.1 Fundamentals of the Drude Model</h3>
<p>The <strong>Drude model</strong> (proposed in 1900 by Paul Drude) is a classical theory explaining electrical conduction in metals and heavily doped semiconductors. In this model, electrons are treated as a "free electron gas" moving freely.</p>
<p><strong>Basic Assumptions</strong>:</p>
<ul>
<li>Electrons move freely until they <strong>scatter</strong> with atomic nuclei or other electrons</li>
<li>Scattering occurs with an average relaxation time $\tau$ (scattering probability $\propto 1/\tau$)</li>
<li>After scattering, the electron velocity is directed randomly (drift from electric field is reset)</li>
</ul>
<p><strong>Derivation of Electrical Conductivity</strong>:</p>
<p>When an electric field $\vec{E}$ is applied, electrons are accelerated:</p>

        $$
        m\frac{d\vec{v}}{dt} = -e\vec{E} - \frac{m\vec{v}}{\tau}
        $$

        <p>Here, $m$ is the electron mass, $e$ is the elementary charge ($e &gt; 0$), and $\tau$ is the scattering relaxation time. In steady state ($d\vec{v}/dt = 0$):</p>

        $$
        \vec{v}_{\text{drift}} = -\frac{e\tau}{m}\vec{E}
        $$

        <p>The current density $\vec{j}$ is the product of carrier density $n$, charge $-e$, and drift velocity $\vec{v}_{\text{drift}}$:</p>

        $$
        \vec{j} = -ne\vec{v}_{\text{drift}} = \frac{ne^2\tau}{m}\vec{E}
        $$

        <p><strong>Electrical conductivity</strong> $\sigma$ and <strong>resistivity</strong> $\rho$ are:</p>

        $$
        \sigma = \frac{ne^2\tau}{m}, \quad \rho = \frac{1}{\sigma} = \frac{m}{ne^2\tau}
        $$

        <p><strong>Mobility</strong> $\mu$ is the drift velocity per unit electric field:</p>

        $$
        \mu = \frac{|v_{\text{drift}}|}{E} = \frac{e\tau}{m}
        $$

        <p>Therefore, electrical conductivity can also be expressed as:</p>

        $$
        \sigma = ne\mu
        $$

        <h4>Code Example 1-1: Electrical Conductivity Calculation Using the Drude Model</h4>
<pre><code class="language-python"># Requirements:
# - Python 3.9+
# - matplotlib&gt;=3.7.0
# - numpy&gt;=1.24.0, &lt;2.0.0

import numpy as np
import matplotlib.pyplot as plt

def drude_conductivity(n, tau, m=9.10938e-31):
    """
    Calculate electrical conductivity using the Drude model

    Parameters
    ----------
    n : float or array-like
        Carrier density [m^-3]
    tau : float or array-like
        Scattering relaxation time [s]
    m : float
        Effective mass [kg] (default: free electron mass)

    Returns
    -------
    sigma : float or array-like
        Electrical conductivity [S/m]
    """
    e = 1.60218e-19  # Elementary charge [C]
    sigma = n * e**2 * tau / m
    return sigma

# Typical metal (copper) parameters
n_Cu = 8.5e28  # Carrier density [m^-3] (free electron density of copper)
tau_Cu = 2.5e-14  # Scattering relaxation time [s] (room temperature)

sigma_Cu = drude_conductivity(n_Cu, tau_Cu)
rho_Cu = 1 / sigma_Cu

print(f"Copper electrical conductivity: {sigma_Cu:.3e} S/m")
print(f"Copper resistivity: {rho_Cu:.3e} ¬©¬∑m = {rho_Cu * 1e8:.2f} ¬º¬©¬∑cm")
print(f"Experimental value (room temp): √Å H 1.68 ¬º¬©¬∑cm")

# Carrier density dependence
n_range = np.logspace(26, 30, 100)  # [m^-3]
tau_fixed = 1e-14  # [s]

sigma_n = drude_conductivity(n_range, tau_fixed)

# Scattering relaxation time dependence
n_fixed = 1e28  # [m^-3]
tau_range = np.logspace(-15, -12, 100)  # [s]

sigma_tau = drude_conductivity(n_fixed, tau_range)

# Plotting
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 5))

# Left: Carrier density dependence
ax1.loglog(n_range, sigma_n, linewidth=2.5, color='#f093fb')
ax1.scatter([n_Cu], [sigma_Cu], s=150, c='#f5576c', edgecolors='black', linewidth=2, zorder=5, label='Cu (room temp)')
ax1.set_xlabel('Carrier Density n [m$^{-3}$]', fontsize=12)
ax1.set_ylabel('Conductivity √É [S/m]', fontsize=12)
ax1.set_title('Conductivity vs Carrier Density\n(√Ñ = 10 fs)', fontsize=14, fontweight='bold')
ax1.legend(fontsize=11)
ax1.grid(alpha=0.3, which='both')

# Right: Scattering relaxation time dependence
ax2.loglog(tau_range * 1e15, sigma_tau, linewidth=2.5, color='#f093fb')
ax2.scatter([tau_Cu * 1e15], [sigma_Cu], s=150, c='#f5576c', edgecolors='black', linewidth=2, zorder=5, label='Cu (room temp)')
ax2.set_xlabel('Scattering Relaxation Time √Ñ [fs]', fontsize=12)
ax2.set_ylabel('Conductivity √É [S/m]', fontsize=12)
ax2.set_title('Conductivity vs Relaxation Time\n(n = 10$^{28}$ m$^{-3}$)', fontsize=14, fontweight='bold')
ax2.legend(fontsize=11)
ax2.grid(alpha=0.3, which='both')

plt.tight_layout()
plt.show()
</code></pre>
<p><strong>Output Interpretation</strong>:</p>
<ul>
<li>Copper electrical conductivity: approximately $5.8 \times 10^7$ S/m (agrees well with experimental value)</li>
<li>Electrical conductivity is proportional to $n$ and $\tau$ ($\sigma \propto n\tau$)</li>
<li>In metals, $n$ is nearly constant, so temperature dependence is mainly due to $\tau$</li>
</ul>
<h3>1.1.2 Temperature Dependence and Scattering Mechanisms</h3>
<p>The scattering relaxation time $\tau$ varies with temperature depending on the scattering mechanism.</p>
<table>
<thead>
<tr>
<th>Scattering Mechanism</th>
<th>Temperature Dependence</th>
<th>Dominant Temperature Range</th>
<th>Material Examples</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Phonon scattering</strong></td>
<td>$\rho \propto T$ (high temp)</td>
<td>Above room temperature</td>
<td>Pure metals</td>
</tr>
<tr>
<td><strong>Impurity scattering</strong></td>
<td>$\rho = \rho_0$ (constant)</td>
<td>Low temperature</td>
<td>Alloys, doped semiconductors</td>
</tr>
<tr>
<td><strong>Grain boundary scattering</strong></td>
<td>Weak temperature dependence</td>
<td>All temperature ranges</td>
<td>Polycrystalline materials</td>
</tr>
<tr>
<td><strong>Electron-electron scattering</strong></td>
<td>$\rho \propto T^2$</td>
<td>Very low temperature</td>
<td>Fermi liquids</td>
</tr>
</tbody>
</table>
<p><strong>Matthiessen's Rule</strong>: When multiple scattering mechanisms work independently, the total resistivity is the sum of contributions from each mechanism:</p>

        $$
        \rho(T) = \rho_0 + \rho_{\text{phonon}}(T) + \rho_{\text{other}}(T)
        $$

        <p>Here, $\rho_0$ is the residual resistivity (due to impurities and defects, independent of temperature), and $\rho_{\text{phonon}}(T)$ is the temperature-dependent term due to phonon scattering.</p>
<h2>1.2 Two-Terminal and Four-Terminal Measurements</h2>
<h3>1.2.1 Problems with Two-Terminal Measurement</h3>
<p>In two-terminal measurement, the terminals for passing current and measuring voltage are the same, so <strong>contact resistance</strong> and <strong>wire resistance</strong> are included in the measured value.</p>
<div class="mermaid">
flowchart LR
    A[Current Source] --&gt;|I| B[Contact 1<br/>R_c1]
    B --&gt; C[Sample<br/>R_sample]
    C --&gt; D[Contact 2<br/>R_c2]
    D --&gt;|I| E[Voltmeter]
    E --&gt; A

    style A fill:#99ccff,stroke:#0066cc,stroke-width:2px
    style E fill:#99ccff,stroke:#0066cc,stroke-width:2px
    style C fill:#f093fb,stroke:#f5576c,stroke-width:2px,color:#fff
    style B fill:#ffeb99,stroke:#ffa500,stroke-width:2px
    style D fill:#ffeb99,stroke:#ffa500,stroke-width:2px
        </div>
<p>Measured voltage:</p>

        $$
        V_{\text{measured}} = I(R_{\text{c1}} + R_{\text{sample}} + R_{\text{c2}})
        $$

        <p>Contact resistance $R_c$ can be larger than the sample resistance $R_{\text{sample}}$ (especially for thin films and semiconductors), hindering accurate measurement.</p>
<h3>1.2.2 Four-Terminal Measurement (Kelvin Measurement)</h3>
<p>In <strong>four-terminal measurement</strong>, current and voltage terminals are separated, eliminating the effect of contact resistance.</p>
<div class="mermaid">
flowchart LR
    A[Current Source] --&gt;|I| B[Current Contact 1]
    B --&gt; C[Sample<br/>R_sample]
    C --&gt; D[Current Contact 2]
    D --&gt;|I| A

    E[High Input Impedance<br/>Voltmeter] -.-&gt;|V+| F[Voltage Contact 3]
    F --&gt; C
    C --&gt; G[Voltage Contact 4]
    G -.-&gt;|V-| E

    style A fill:#99ccff,stroke:#0066cc,stroke-width:2px
    style E fill:#99ccff,stroke:#0066cc,stroke-width:2px
    style C fill:#f093fb,stroke:#f5576c,stroke-width:2px,color:#fff
        </div>
<p>Since the voltmeter has high input impedance (ideally infinite), almost no current flows through the voltage terminals. Therefore, the voltage drop due to contact resistance at the voltage terminals is zero, and only the voltage inside the sample is measured:</p>

        $$
        V_{\text{sample}} = I \cdot R_{\text{sample}}
        $$

        <p><strong>Advantages of Four-Terminal Measurement</strong>:</p>
<ul>
<li>Not affected by contact resistance</li>
<li>Wire resistance effects can also be eliminated</li>
<li>High-precision measurement of low-resistance materials possible (¬º¬© order measurable)</li>
</ul>
<h4>Code Example 1-2: Simulation of Two-Terminal vs Four-Terminal Measurement</h4>
<pre><code class="language-python"># Requirements:
# - Python 3.9+
# - matplotlib&gt;=3.7.0
# - numpy&gt;=1.24.0, &lt;2.0.0

import numpy as np
import matplotlib.pyplot as plt

def two_terminal_measurement(R_sample, R_contact, I):
    """
    Simulate two-terminal measurement
    """
    V_measured = I * (2 * R_contact + R_sample)
    R_measured = V_measured / I
    return R_measured

def four_terminal_measurement(R_sample, I):
    """
    Simulate four-terminal measurement
    """
    V_sample = I * R_sample
    R_measured = V_sample / I
    return R_measured

# Parameters
R_sample = 1.0  # Sample resistance [¬©]
R_contact_range = np.linspace(0, 5, 100)  # Contact resistance [¬©]
I = 0.1  # Current [A]

# Calculate measured values
R_2terminal = [two_terminal_measurement(R_sample, Rc, I) for Rc in R_contact_range]
R_4terminal = [four_terminal_measurement(R_sample, I) for Rc in R_contact_range]

# Plotting
fig, ax = plt.subplots(figsize=(10, 6))

ax.plot(R_contact_range, R_2terminal, linewidth=2.5, label='2-terminal (with contact resistance)', color='#ffa500')
ax.plot(R_contact_range, R_4terminal, linewidth=2.5, label='4-terminal (no contact resistance)', color='#f093fb', linestyle='--')
ax.axhline(y=R_sample, color='black', linestyle=':', linewidth=1.5, label=f'True sample resistance = {R_sample} ¬©')

ax.set_xlabel('Contact Resistance R$_c$ [¬©]', fontsize=12)
ax.set_ylabel('Measured Resistance [¬©]', fontsize=12)
ax.set_title('2-Terminal vs 4-Terminal Measurement', fontsize=14, fontweight='bold')
ax.legend(fontsize=11, loc='upper left')
ax.grid(alpha=0.3)

plt.tight_layout()
plt.show()

# Specific example
R_contact_example = 2.0  # [¬©]
R_2t = two_terminal_measurement(R_sample, R_contact_example, I)
R_4t = four_terminal_measurement(R_sample, I)

print(f"Sample resistance: {R_sample} ¬©")
print(f"Contact resistance: {R_contact_example} ¬© (each contact)")
print(f"2-terminal measurement: {R_2t:.2f} ¬© (error: {(R_2t - R_sample) / R_sample * 100:.1f}%)")
print(f"4-terminal measurement: {R_4t:.2f} ¬© (error: 0%)")
</code></pre>
<h2>1.3 van der Pauw Method</h2>
<h3>1.3.1 van der Pauw Theorem</h3>
<p>The <strong>van der Pauw method</strong> (proposed in 1958 by L.J. van der Pauw) is a powerful technique for measuring the sheet resistance of arbitrarily shaped thin film samples. It does not require the sample to have a specific shape (rectangular, circular, etc.) and can be measured with just four contacts.</p>
<p><strong>Conditions</strong>:</p>
<ul>
<li>The sample is planar with uniform thickness $t$</li>
<li>The sample has no holes or defects (simply connected)</li>
<li>Four contacts are placed at the edge of the sample</li>
<li>Contacts are sufficiently small</li>
</ul>
<p><strong>van der Pauw Theorem</strong>:</p>
<p>Place four contacts A, B, C, D around the sample and measure the following two resistances:</p>

        $$
        R_{\text{AB,CD}} = \frac{V_{\text{CD}}}{I_{\text{AB}}} \quad \text{(current from AB, voltage measured at CD)}
        $$

        $$
        R_{\text{BC,DA}} = \frac{V_{\text{DA}}}{I_{\text{BC}}} \quad \text{(current from BC, voltage measured at DA)}
        $$

        <p>By the van der Pauw theorem, the sheet resistance $R_s$ satisfies the following equation:</p>

        $$
        \exp\left(-\frac{\pi R_{\text{AB,CD}}}{R_s}\right) + \exp\left(-\frac{\pi R_{\text{BC,DA}}}{R_s}\right) = 1
        $$

        <p>By solving this equation for $R_s$, the sheet resistance is obtained.</p>
<p><strong>Relationship between Sheet Resistance and Bulk Resistivity</strong>:</p>

        $$
        R_s = \frac{\rho}{t}
        $$

        <p>Here, $\rho$ is the bulk resistivity and $t$ is the sample thickness. The unit of $R_s$ is expressed as ¬©/¬° (ohm per square).</p>
<h4>Code Example 1-3: Sheet Resistance Calculation Using the van der Pauw Method</h4>
<pre><code class="language-python"># Requirements:
# - Python 3.9+
# - matplotlib&gt;=3.7.0
# - numpy&gt;=1.24.0, &lt;2.0.0

import numpy as np
from scipy.optimize import fsolve
import matplotlib.pyplot as plt

def van_der_pauw_equation(Rs, R1, R2):
    """
    van der Pauw equation: exp(-√Ä R1/Rs) + exp(-√Ä R2/Rs) = 1
    """
    return np.exp(-np.pi * R1 / Rs) + np.exp(-np.pi * R2 / Rs) - 1

def calculate_sheet_resistance(R_AB_CD, R_BC_DA):
    """
    Calculate sheet resistance using the van der Pauw method

    Parameters
    ----------
    R_AB_CD : float
        Resistance R_AB,CD [¬©]
    R_BC_DA : float
        Resistance R_BC,DA [¬©]

    Returns
    -------
    R_s : float
        Sheet resistance [¬©/sq]
    """
    # Initial estimate: average resistance
    R_initial = (R_AB_CD + R_BC_DA) / 2 * np.pi / np.log(2)

    # Solve numerically
    R_s = fsolve(van_der_pauw_equation, R_initial, args=(R_AB_CD, R_BC_DA))[0]

    return R_s

# Measurement example 1: Square sample (symmetric configuration)
R1 = 100  # [¬©]
R2 = 100  # [¬©]

R_s1 = calculate_sheet_resistance(R1, R2)
print("Example 1: Square sample (symmetric configuration)")
print(f"  R_AB,CD = {R1:.1f} ¬©")
print(f"  R_BC,DA = {R2:.1f} ¬©")
print(f"  Sheet resistance R_s = {R_s1:.2f} ¬©/sq")
print(f"  Approximate formula R_s H (√Ä/ln2)(R1+R2)/2 = {np.pi / np.log(2) * (R1 + R2) / 2:.2f} ¬©/sq")

# Measurement example 2: Asymmetric configuration
R1 = 120  # [¬©]
R2 = 80   # [¬©]

R_s2 = calculate_sheet_resistance(R1, R2)
print("\nExample 2: Asymmetric configuration")
print(f"  R_AB,CD = {R1:.1f} ¬©")
print(f"  R_BC,DA = {R2:.1f} ¬©")
print(f"  Sheet resistance R_s = {R_s2:.2f} ¬©/sq")

# Calculate bulk resistivity from thickness
t = 100e-9  # Thickness 100 nm
rho1 = R_s1 * t
rho2 = R_s2 * t

print(f"\nWith thickness t = {t * 1e9:.0f} nm:")
print(f"  Example 1 bulk resistivity √Å = {rho1:.3e} ¬©¬∑m = {rho1 * 1e8:.2f} ¬º¬©¬∑cm")
print(f"  Example 2 bulk resistivity √Å = {rho2:.3e} ¬©¬∑m = {rho2 * 1e8:.2f} ¬º¬©¬∑cm")

# Visualization of van der Pauw equation
R1_range = np.linspace(50, 150, 50)
R2_range = np.linspace(50, 150, 50)
R1_mesh, R2_mesh = np.meshgrid(R1_range, R2_range)

R_s_mesh = np.zeros_like(R1_mesh)
for i in range(R1_mesh.shape[0]):
    for j in range(R1_mesh.shape[1]):
        R_s_mesh[i, j] = calculate_sheet_resistance(R1_mesh[i, j], R2_mesh[i, j])

# Plotting
fig, ax = plt.subplots(figsize=(10, 8))

contour = ax.contourf(R1_mesh, R2_mesh, R_s_mesh, levels=20, cmap='plasma')
cbar = plt.colorbar(contour, ax=ax)
cbar.set_label('Sheet Resistance R$_s$ [¬©/sq]', fontsize=12)

ax.scatter([R1], [R2], s=200, c='white', edgecolors='black', linewidth=2, marker='o', label='Example 2')
ax.set_xlabel('R$_{AB,CD}$ [¬©]', fontsize=12)
ax.set_ylabel('R$_{BC,DA}$ [¬©]', fontsize=12)
ax.set_title('van der Pauw Method: Sheet Resistance Map', fontsize=14, fontweight='bold')
ax.legend(fontsize=11)
ax.grid(alpha=0.3, color='white')

plt.tight_layout()
plt.show()
</code></pre>
<p><strong>Output Interpretation</strong>:</p>
<ul>
<li>For symmetric configuration ($R_1 = R_2$), the simplified formula $R_s \approx \frac{\pi}{\ln 2}R_1$ is often used</li>
<li>Even for asymmetric configuration, accurate $R_s$ can be obtained by numerically solving the van der Pauw equation</li>
<li>Bulk resistivity is obtained by multiplying sheet resistance by thickness</li>
</ul>
<h2>1.4 Temperature Dependence Measurement and Fitting</h2>
<h3>1.4.1 Temperature Dependence of Metals (Bloch-Gr√ºneisen Model)</h3>
<p>For metals, resistivity is dominated by impurity scattering (temperature-independent $\rho_0$) at low temperatures and phonon scattering (proportional to $T$) at high temperatures:</p>

        $$
        \rho(T) = \rho_0 + A T
        $$

        <p>Here, $A$ is a coefficient related to phonon scattering.</p>
<h3>1.4.2 Temperature Dependence of Semiconductors (Arrhenius Plot)</h3>
<p>In semiconductors, carrier density varies with temperature (thermal excitation):</p>

        $$
        n(T) \propto \exp\left(-\frac{E_a}{k_B T}\right)
        $$

        <p>Resistivity is:</p>

        $$
        \rho(T) = \rho_0 \exp\left(\frac{E_a}{k_B T}\right)
        $$

        <p>A plot of $\ln \rho$ vs $1/T$ (Arrhenius plot) yields the activation energy $E_a$.</p>
<h4>Code Example 1-4: Fitting Temperature-Dependent Data</h4>
<pre><code class="language-python"># Requirements:
# - Python 3.9+
# - matplotlib&gt;=3.7.0
# - numpy&gt;=1.24.0, &lt;2.0.0

"""
Example: Code Example 1-4: Fitting Temperature-Dependent Data

Purpose: Demonstrate data visualization techniques
Target: Intermediate
Execution time: 30-60 seconds
Dependencies: None
"""

import numpy as np
import matplotlib.pyplot as plt
from lmfit import Model

# Metal model: √Å(T) = √Å‚Ç¨ + A*T
def metal_resistivity(T, rho0, A):
    return rho0 + A * T

# Semiconductor model: √Å(T) = √Å‚Ç¨ * exp(Ea / (kB * T))
def semiconductor_resistivity(T, rho0, Ea):
    kB = 8.617333e-5  # Boltzmann constant [eV/K]
    return rho0 * np.exp(Ea / (kB * T))

# Generate simulation data
# Metal (copper)
T_metal = np.linspace(50, 400, 30)  # [K]
rho0_true = 0.5e-8  # [¬©¬∑m]
A_true = 5e-11  # [¬©¬∑m/K]
rho_metal = metal_resistivity(T_metal, rho0_true, A_true) * (1 + 0.02 * np.random.randn(len(T_metal)))  # 2% noise

# Semiconductor (silicon)
T_semi = np.linspace(300, 600, 30)  # [K]
rho0_semi_true = 1e-5  # [¬©¬∑m]
Ea_true = 0.5  # [eV]
rho_semi = semiconductor_resistivity(T_semi, rho0_semi_true, Ea_true) * (1 + 0.05 * np.random.randn(len(T_semi)))  # 5% noise

# Fitting: metal
metal_model = Model(metal_resistivity)
metal_params = metal_model.make_params(rho0=1e-8, A=1e-11)
metal_result = metal_model.fit(rho_metal, metal_params, T=T_metal)

print("Metal fitting results:")
print(metal_result.fit_report())

# Fitting: semiconductor
semi_model = Model(semiconductor_resistivity)
semi_params = semi_model.make_params(rho0=1e-6, Ea=0.6)
semi_result = semi_model.fit(rho_semi, semi_params, T=T_semi)

print("\nSemiconductor fitting results:")
print(semi_result.fit_report())

# Plotting
fig, axes = plt.subplots(2, 2, figsize=(14, 10))

# Metal: √Å vs T
axes[0, 0].scatter(T_metal, rho_metal * 1e8, s=80, alpha=0.7, edgecolors='black', linewidths=1.5, label='Data (with noise)', color='#f093fb')
axes[0, 0].plot(T_metal, metal_result.best_fit * 1e8, linewidth=2.5, label='Fit: √Å = √Å‚Ç¨ + AT', color='#f5576c')
axes[0, 0].set_xlabel('Temperature T [K]', fontsize=12)
axes[0, 0].set_ylabel('Resistivity √Å [¬º¬©¬∑cm]', fontsize=12)
axes[0, 0].set_title('Metal (Cu): Resistivity vs Temperature', fontsize=13, fontweight='bold')
axes[0, 0].legend(fontsize=10)
axes[0, 0].grid(alpha=0.3)

# Metal: residuals
residuals_metal = rho_metal - metal_result.best_fit
axes[0, 1].scatter(T_metal, residuals_metal * 1e8, s=80, alpha=0.7, edgecolors='black', linewidths=1.5, color='#99ccff')
axes[0, 1].axhline(0, color='black', linestyle='--', linewidth=1.5)
axes[0, 1].set_xlabel('Temperature T [K]', fontsize=12)
axes[0, 1].set_ylabel('Residuals [¬º¬©¬∑cm]', fontsize=12)
axes[0, 1].set_title('Fit Residuals (Metal)', fontsize=13, fontweight='bold')
axes[0, 1].grid(alpha=0.3)

# Semiconductor: √Å vs T
axes[1, 0].scatter(T_semi, rho_semi, s=80, alpha=0.7, edgecolors='black', linewidths=1.5, label='Data (with noise)', color='#ffa500')
axes[1, 0].plot(T_semi, semi_result.best_fit, linewidth=2.5, label='Fit: √Å = √Å‚Ç¨exp(Ea/kT)', color='#ff6347')
axes[1, 0].set_xlabel('Temperature T [K]', fontsize=12)
axes[1, 0].set_ylabel('Resistivity √Å [¬©¬∑m]', fontsize=12)
axes[1, 0].set_title('Semiconductor (Si): Resistivity vs Temperature', fontsize=13, fontweight='bold')
axes[1, 0].legend(fontsize=10)
axes[1, 0].grid(alpha=0.3)
axes[1, 0].set_yscale('log')

# Semiconductor: Arrhenius plot
axes[1, 1].scatter(1000 / T_semi, np.log(rho_semi), s=80, alpha=0.7, edgecolors='black', linewidths=1.5, label='Data', color='#ffa500')
axes[1, 1].plot(1000 / T_semi, np.log(semi_result.best_fit), linewidth=2.5, label='Fit (Arrhenius)', color='#ff6347')
axes[1, 1].set_xlabel('1000/T [K$^{-1}$]', fontsize=12)
axes[1, 1].set_ylabel('ln(√Å)', fontsize=12)
axes[1, 1].set_title('Arrhenius Plot (Semiconductor)', fontsize=13, fontweight='bold')
axes[1, 1].legend(fontsize=10)
axes[1, 1].grid(alpha=0.3)

plt.tight_layout()
plt.show()
</code></pre>
<h2>1.5 Contact Resistance Evaluation and Correction</h2>
<h3>1.5.1 Transfer Length Method (TLM)</h3>
<p>The <strong>TLM (Transfer Length Method)</strong> is a technique for quantitatively evaluating contact resistance. Contact pairs are created at different spacings, and contact resistance is determined from the relationship between measured resistance and contact spacing.</p>
<p>The total measured resistance $R_{\text{total}}$ is:</p>

        $$
        R_{\text{total}} = 2R_c + R_s \frac{L}{W}
        $$

        <p>Here, $R_c$ is the contact resistance, $R_s$ is the sheet resistance, $L$ is the contact spacing, and $W$ is the sample width. When $R_{\text{total}}$ is plotted against $L$, the intercept gives $2R_c$ and the slope gives $R_s/W$.</p>
<h4>Code Example 1-5: Contact Resistance Evaluation Using TLM</h4>
<pre><code class="language-python"># Requirements:
# - Python 3.9+
# - matplotlib&gt;=3.7.0
# - numpy&gt;=1.24.0, &lt;2.0.0

"""
Example: Code Example 1-5: Contact Resistance Evaluation Using TLM

Purpose: Demonstrate data visualization techniques
Target: Intermediate
Execution time: 2-5 seconds
Dependencies: None
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import linregress

# Parameters
R_s = 50  # Sheet resistance [¬©/sq]
R_c = 10  # Contact resistance [¬©]
W = 0.01  # Sample width [m] = 1 cm

# Contact spacing
L_values = np.array([0.001, 0.002, 0.003, 0.005, 0.010])  # [m]

# Measured resistance (with noise)
R_total = 2 * R_c + R_s * L_values / W
R_total_noise = R_total * (1 + 0.03 * np.random.randn(len(L_values)))  # 3% noise

# Linear fitting
slope, intercept, r_value, p_value, std_err = linregress(L_values * 1000, R_total_noise)

R_c_fit = intercept / 2
R_s_fit = slope * W * 1000  # slope √ó W

print("Contact resistance evaluation using TLM:")
print(f"  True contact resistance R_c = {R_c:.2f} ¬©")
print(f"  Fitted R_c = {R_c_fit:.2f} ¬©")
print(f"  True sheet resistance R_s = {R_s:.2f} ¬©/sq")
print(f"  Fitted R_s = {R_s_fit:.2f} ¬©/sq")
print(f"  Coefficient of determination R¬≤ = {r_value**2:.4f}")

# Plotting
fig, ax = plt.subplots(figsize=(10, 6))

ax.scatter(L_values * 1000, R_total_noise, s=150, edgecolors='black', linewidths=2, label='Measured data', color='#f093fb', zorder=5)
L_fit = np.linspace(0, np.max(L_values) * 1000, 100)
R_fit = slope * L_fit + intercept
ax.plot(L_fit, R_fit, linewidth=2.5, label=f'Linear fit: R = {slope:.2f}L + {intercept:.2f}', color='#f5576c', linestyle='--')

# Highlight intercept
ax.axhline(y=intercept, color='orange', linestyle=':', linewidth=2, label=f'Intercept = 2R$_c$ = {intercept:.2f} ¬©')
ax.scatter([0], [intercept], s=200, c='orange', edgecolors='black', linewidth=2, marker='s', zorder=5)

ax.set_xlabel('Contact Spacing L [mm]', fontsize=12)
ax.set_ylabel('Total Resistance R$_{total}$ [¬©]', fontsize=12)
ax.set_title('Transfer Length Method (TLM)', fontsize=14, fontweight='bold')
ax.legend(fontsize=11)
ax.grid(alpha=0.3)
ax.set_xlim(left=0)

plt.tight_layout()
plt.show()
</code></pre>
<h2>1.6 Exercises</h2>
<h3>Exercise 1-1: Drude Model Calculation (Easy)</h3>
<p><span class="exercise-label easy">Easy</span> <strong>Problem</strong>: For gold with carrier density $n = 5.9 \times 10^{28}$ m$^{-3}$ and scattering relaxation time $\tau = 3 \times 10^{-14}$ s, calculate the electrical conductivity and resistivity.</p>
<details>
<summary><strong>Show Solution</strong></summary>
<pre><code class="language-python"># Requirements:
# - Python 3.9+
# - numpy&gt;=1.24.0, &lt;2.0.0

"""
Example: EasyProblem: For gold with carrier density $n = 5.9 \times 1

Purpose: Demonstrate core concepts and implementation patterns
Target: Beginner to Intermediate
Execution time: ~5 seconds
Dependencies: None
"""

import numpy as np

# Constants
e = 1.60218e-19  # [C]
m = 9.10938e-31  # [kg]

# Gold parameters
n = 5.9e28  # [m^-3]
tau = 3e-14  # [s]

# Electrical conductivity
sigma = n * e**2 * tau / m
rho = 1 / sigma

print(f"Electrical conductivity √É = {sigma:.3e} S/m")
print(f"Resistivity √Å = {rho:.3e} ¬©¬∑m = {rho * 1e8:.2f} ¬º¬©¬∑cm")
print(f"Experimental value (room temp): √Å H 2.44 ¬º¬©¬∑cm")
</code></pre>
<p><strong>Answer</strong>: √É H 4.54 √ó 10$^7$ S/m, √Å H 2.20 √ó 10$^{-8}$ ¬©¬∑m = 2.20 ¬º¬©¬∑cm (agrees well with experimental value)</p>
</details>
<h3>Exercise 1-2: Mobility Calculation (Easy)</h3>
<p><span class="exercise-label easy">Easy</span> <strong>Problem</strong>: Calculate the mobility $\mu$ of an electron with scattering relaxation time $\tau = 1 \times 10^{-14}$ s.</p>
<details>
<summary><strong>Show Solution</strong></summary>
<pre><code class="language-python">e = 1.60218e-19  # [C]
m = 9.10938e-31  # [kg]
tau = 1e-14  # [s]

mu = e * tau / m
print(f"Mobility ¬º = {mu:.3e} m¬≤/(V¬∑s) = {mu * 1e4:.1f} cm¬≤/(V¬∑s)")
</code></pre>
<p><strong>Answer</strong>: ¬º H 1.76 √ó 10$^{-3}$ m$^2$/(V¬∑s) = 17.6 cm$^2$/(V¬∑s)</p>
</details>
<h3>Exercise 1-3: van der Pauw Method Calculation (Medium)</h3>
<p><span class="exercise-label medium">Medium</span> <strong>Problem</strong>: In van der Pauw measurement, $R_{\text{AB,CD}} = 85$ ¬© and $R_{\text{BC,DA}} = 115$ ¬© were obtained. Calculate the sheet resistance $R_s$ and determine the bulk resistivity $\rho$ for thickness $t = 50$ nm.</p>
<details>
<summary><strong>Show Solution</strong></summary>
<pre><code class="language-python"># Requirements:
# - Python 3.9+
# - numpy&gt;=1.24.0, &lt;2.0.0

"""
Example: MediumProblem: In van der Pauw measurement, $R_{\text{AB,CD}

Purpose: Demonstrate optimization techniques
Target: Intermediate
Execution time: 10-30 seconds
Dependencies: None
"""

import numpy as np
from scipy.optimize import fsolve

def van_der_pauw_eq(Rs, R1, R2):
    return np.exp(-np.pi * R1 / Rs) + np.exp(-np.pi * R2 / Rs) - 1

R1 = 85  # [¬©]
R2 = 115  # [¬©]

R_s = fsolve(van_der_pauw_eq, (R1 + R2) / 2 * np.pi / np.log(2), args=(R1, R2))[0]

print(f"Sheet resistance R_s = {R_s:.2f} ¬©/sq")

t = 50e-9  # [m]
rho = R_s * t

print(f"Thickness t = {t * 1e9:.0f} nm")
print(f"Bulk resistivity √Å = {rho:.3e} ¬©¬∑m = {rho * 1e8:.2f} ¬º¬©¬∑cm")
</code></pre>
<p><strong>Answer</strong>: R$_s$ H 136.8 ¬©/sq, √Å H 6.84 √ó 10$^{-6}$ ¬©¬∑m = 684 ¬º¬©¬∑cm</p>
</details>
<h3>Exercise 1-4: Temperature Dependence Fitting (Medium)</h3>
<p><span class="exercise-label medium">Medium</span> <strong>Problem</strong>: A metal sample has resistivity of 0.8 ¬º¬©¬∑cm at T = 100 K and 2.0 ¬º¬©¬∑cm at 300 K. Fit with model $\rho(T) = \rho_0 + AT$ and determine $\rho_0$ and $A$.</p>
<details>
<summary><strong>Show Solution</strong></summary>
<pre><code class="language-python"># Requirements:
# - Python 3.9+
# - numpy&gt;=1.24.0, &lt;2.0.0

"""
Example: MediumProblem: A metal sample has resistivity of 0.8 ¬º¬©¬∑cm a

Purpose: Demonstrate core concepts and implementation patterns
Target: Beginner to Intermediate
Execution time: ~5 seconds
Dependencies: None
"""

import numpy as np

T1, rho1 = 100, 0.8e-8  # [K], [¬©¬∑m]
T2, rho2 = 300, 2.0e-8  # [K], [¬©¬∑m]

# Solve linear equations
A = (rho2 - rho1) / (T2 - T1)
rho0 = rho1 - A * T1

print(f"√Å‚Ç¨ = {rho0:.3e} ¬©¬∑m = {rho0 * 1e8:.2f} ¬º¬©¬∑cm")
print(f"A = {A:.3e} ¬©¬∑m/K")

# Verification
rho_100 = rho0 + A * 100
rho_300 = rho0 + A * 300
print(f"\nVerification:")
print(f"  √Å(100 K) = {rho_100 * 1e8:.2f} ¬º¬©¬∑cm (given value: 0.80 ¬º¬©¬∑cm)")
print(f"  √Å(300 K) = {rho_300 * 1e8:.2f} ¬º¬©¬∑cm (given value: 2.00 ¬º¬©¬∑cm)")
</code></pre>
<p><strong>Answer</strong>: √Å$_0$ = 2.00 √ó 10$^{-9}$ ¬©¬∑m = 0.20 ¬º¬©¬∑cm, A = 6.00 √ó 10$^{-11}$ ¬©¬∑m/K</p>
</details>
<h3>Exercise 1-5: TLM Analysis (Medium)</h3>
<p><span class="exercise-label medium">Medium</span> <strong>Problem</strong>: In TLM measurement, for contact spacing $L$ = 1, 2, 3, 4, 5 mm, total resistance $R_{\text{total}}$ = 25, 30, 35, 40, 45 ¬© was obtained. With sample width $W = 1$ cm, determine contact resistance $R_c$ and sheet resistance $R_s$.</p>
<details>
<summary><strong>Show Solution</strong></summary>
<pre><code class="language-python"># Requirements:
# - Python 3.9+
# - numpy&gt;=1.24.0, &lt;2.0.0

"""
Example: MediumProblem: In TLM measurement, for contact spacing $L$ =

Purpose: Demonstrate core concepts and implementation patterns
Target: Beginner to Intermediate
Execution time: ~5 seconds
Dependencies: None
"""

import numpy as np
from scipy.stats import linregress

L = np.array([1, 2, 3, 4, 5])  # [mm]
R_total = np.array([25, 30, 35, 40, 45])  # [¬©]
W = 0.01  # [m]

slope, intercept, r_value, _, _ = linregress(L, R_total)

R_c = intercept / 2
R_s = slope * W * 1000  # Convert W to mm

print(f"Contact resistance R_c = {R_c:.2f} ¬©")
print(f"Sheet resistance R_s = {R_s:.2f} ¬©/sq")
print(f"Coefficient of determination R¬≤ = {r_value**2:.4f}")
</code></pre>
<p><strong>Answer</strong>: R$_c$ = 10.0 ¬©, R$_s$ = 50.0 ¬©/sq, R$^2$ = 1.0000 (perfect linear relationship)</p>
</details>
<h3>Exercise 1-6: Semiconductor Activation Energy (Hard)</h3>
<p><span class="exercise-label hard">Hard</span> <strong>Problem</strong>: A semiconductor sample has resistivity of 1.0 ¬©¬∑m at T = 300 K and 0.1 ¬©¬∑m at 400 K. Fit with model $\rho(T) = \rho_0 \exp(E_a / k_B T)$ and determine activation energy $E_a$ in eV ($k_B = 8.617 \times 10^{-5}$ eV/K).</p>
<details>
<summary><strong>Show Solution</strong></summary>
<pre><code class="language-python"># Requirements:
# - Python 3.9+
# - numpy&gt;=1.24.0, &lt;2.0.0

"""
Example: HardProblem: A semiconductor sample has resistivity of 1.0 ¬©

Purpose: Demonstrate core concepts and implementation patterns
Target: Beginner to Intermediate
Execution time: ~5 seconds
Dependencies: None
"""

import numpy as np

T1, rho1 = 300, 1.0  # [K], [¬©¬∑m]
T2, rho2 = 400, 0.1  # [K], [¬©¬∑m]
kB = 8.617e-5  # [eV/K]

# ln(√Å) = ln(√Å‚Ç¨) + Ea/(kB T)
# ln(rho1) = ln(rho0) + Ea/(kB T1)
# ln(rho2) = ln(rho0) + Ea/(kB T2)
# ln(rho1) - ln(rho2) = Ea/(kB) * (1/T1 - 1/T2)

Ea = kB * (np.log(rho1) - np.log(rho2)) / (1/T1 - 1/T2)

print(f"Activation energy Ea = {Ea:.3f} eV")

# Determine √Å‚Ç¨
rho0 = rho1 * np.exp(-Ea / (kB * T1))
print(f"√Å‚Ç¨ = {rho0:.3e} ¬©¬∑m")

# Verification
rho_300 = rho0 * np.exp(Ea / (kB * 300))
rho_400 = rho0 * np.exp(Ea / (kB * 400))
print(f"\nVerification:")
print(f"  √Å(300 K) = {rho_300:.2f} ¬©¬∑m (given value: 1.00 ¬©¬∑m)")
print(f"  √Å(400 K) = {rho_400:.2f} ¬©¬∑m (given value: 0.10 ¬©¬∑m)")
</code></pre>
<p><strong>Answer</strong>: E$_a$ H 0.661 eV, √Å$_0$ H 3.94 √ó 10$^{-13}$ ¬©¬∑m</p>
</details>
<h3>Exercise 1-7: Four-Terminal Measurement Error Evaluation (Hard)</h3>
<p><span class="exercise-label hard">Hard</span> <strong>Problem</strong>: With sample resistance $R_{\text{sample}} = 0.5$ ¬©, contact resistance $R_c = 10$ ¬©, and current $I = 0.1$ A, calculate the relative error for two-terminal and four-terminal measurements. Also determine what maximum contact resistance allows the two-terminal measurement to have relative error within 5%.</p>
<details>
<summary><strong>Show Solution</strong></summary>
<pre><code class="language-python">R_sample = 0.5  # [¬©]
R_c = 10  # [¬©]

# Two-terminal measurement
R_2terminal = 2 * R_c + R_sample
error_relative = (R_2terminal - R_sample) / R_sample * 100

print(f"Sample resistance R_sample = {R_sample} ¬©")
print(f"Contact resistance R_c = {R_c} ¬©")
print(f"Two-terminal measurement: {R_2terminal} ¬©")
print(f"Relative error: {error_relative:.1f}%")

# Condition for relative error within 5%
# (2*R_c + R_sample - R_sample) / R_sample &lt;= 0.05
# 2*R_c / R_sample &lt;= 0.05
# R_c &lt;= 0.05 * R_sample / 2

R_c_max = 0.05 * R_sample / 2
print(f"\nCondition for relative error within 5%: R_c &lt;= {R_c_max:.4f} ¬© = {R_c_max * 1000:.2f} m¬©")
</code></pre>
<p><strong>Answer</strong>: Relative error 4100%, R$_c$ d 0.0125 ¬© = 12.5 m¬© (very stringent condition)</p>
</details>
<h3>Exercise 1-8: Experimental Design (Hard)</h3>
<p><span class="exercise-label hard">Hard</span> <strong>Problem</strong>: Design an experimental plan to evaluate the electrical conduction properties of an unknown thin film material (thickness 200 nm). Explain measurement methods (two-terminal/four-terminal, van der Pauw), temperature range, and data analysis methods.</p>
<details>
<summary><strong>Show Solution</strong></summary>
<p><strong>Experimental Plan</strong>:</p>
<ol>
<li><strong>Sample Preparation</strong>: Place four contacts (diameter &lt; 0.5 mm) at four corners (van der Pauw configuration)</li>
<li><strong>Room Temperature Measurement</strong>:
                    <ul>
<li>Measure $R_{\text{AB,CD}}$ and $R_{\text{BC,DA}}$ using van der Pauw method</li>
<li>Calculate sheet resistance $R_s$, determine resistivity $\rho$ from thickness 200 nm</li>
</ul>
</li>
<li><strong>Temperature Dependence Measurement</strong>:
                    <ul>
<li>Temperature range: 77 K (liquid nitrogen temperature) to 400 K</li>
<li>Measurement interval: every 20-30 K, 20-30 points</li>
<li>Wait for thermal equilibrium at each temperature (10-15 min)</li>
</ul>
</li>
<li><strong>Data Analysis</strong>:
                    <ul>
<li>Create $\rho$ vs $T$ plot</li>
<li>Determine metallic behavior ($\rho \propto T$) or semiconducting behavior ($\rho \propto \exp(E_a / k_B T)$)</li>
<li>Fit with appropriate model (using lmfit)</li>
<li>Evaluate residual resistivity $\rho_0$ using Matthiessen's rule</li>
</ul>
</li>
<li><strong>Contact Resistance Evaluation (Optional)</strong>: Measure multiple contact spacings using TLM method to quantify contact resistance contribution</li>
</ol>
<p><strong>Expected Results</strong>:</p>
<ul>
<li>Metallic material: $\rho \approx 1-100$ ¬º¬©¬∑cm, positive temperature coefficient</li>
<li>Semiconductor material: $\rho \approx 0.1-1000$ ¬©¬∑cm, negative temperature coefficient, activation energy 0.1-1 eV</li>
</ul>
</details>
<h2>1.7 Learning Verification</h2>
<p>Check your understanding with the following checklist:</p>
<h3>Basic Understanding</h3>
<ul>
<li>Can explain the assumptions of the Drude model and the electrical conductivity equation $\sigma = ne^2\tau/m$</li>
<li>Understand the physical meaning of scattering relaxation time $\tau$</li>
<li>Can explain the principles and differences between two-terminal and four-terminal measurements</li>
<li>Understand the van der Pauw theorem equation and can calculate sheet resistance</li>
<li>Understand Matthiessen's rule</li>
</ul>
<h3>Practical Skills</h3>
<ul>
<li>Can calculate electrical conductivity using the Drude model</li>
<li>Can implement Python code for the van der Pauw method</li>
<li>Can fit temperature-dependent data (using lmfit)</li>
<li>Can evaluate contact resistance using TLM method</li>
<li>Can evaluate uncertainty in measurement data</li>
</ul>
<h3>Applied Ability</h3>
<ul>
<li>Can explain differences in temperature dependence between metals and semiconductors</li>
<li>Can estimate scattering mechanisms from experimental data</li>
<li>Can select appropriate measurement method (two-terminal/four-terminal, van der Pauw)</li>
<li>Can identify main sources of measurement error and propose countermeasures</li>
</ul>
<h2>1.8 References</h2>
<ol>
<li>van der Pauw, L. J. (1958). <em>A method of measuring specific resistivity and Hall effect of discs of arbitrary shape</em>. Philips Research Reports, 13(1), 1-9. - Original paper on van der Pauw method</li>
<li>Drude, P. (1900). <em>Zur Elektronentheorie der Metalle</em>. Annalen der Physik, 306(3), 566-613. - Original paper on Drude model</li>
<li>Schroder, D. K. (2006). <em>Semiconductor Material and Device Characterization</em> (3rd ed.). Wiley-Interscience. - Standard textbook on semiconductor measurement techniques</li>
<li>Streetman, B. G., &amp; Banerjee, S. K. (2015). <em>Solid State Electronic Devices</em> (7th ed.). Pearson. - Textbook on electrical conduction theory</li>
<li>Ashcroft, N. W., &amp; Mermin, N. D. (1976). <em>Solid State Physics</em>. Holt, Rinehart and Winston. - Details on Drude model and metal properties</li>
<li>Cohen, M. H., et al. (1960). <em>Contact Resistance and Methods for Its Determination</em>. Solid-State Electronics, 1(2), 159-169. - Contact resistance measurement techniques</li>
<li>Reeves, G. K., &amp; Harrison, H. B. (1982). <em>Obtaining the specific contact resistance from transmission line model measurements</em>. IEEE Electron Device Letters, 3(5), 111-113. - Practical explanation of TLM method</li>
</ol>
<h2>1.9 Next Chapter</h2>
<p>In the next chapter, you will learn the principles and practice of <strong>Hall effect measurement</strong>. The Hall effect is a powerful method that uses the deflection of charges in a magnetic field to determine carrier density and carrier type (electron/hole). Combined with the van der Pauw method, it enables complete characterization of the electrical properties of materials.</p>
<div class="navigation">
<a class="nav-button" href="index.html">ÔøΩ Back to Contents</a>
<a class="nav-button" href="index.html">Back to Contents</a>
<a class="nav-button" href="chapter-2.html">Chapter 2: Hall Effect Measurement ‚Äô</a>
</div>
</main>
<section class="disclaimer">
<h3>Disclaimer</h3>
<ul>
<li>This content is for educational, research, and informational purposes only and does not provide professional advice (legal, accounting, technical guarantees, etc.).</li>
<li>This content and accompanying code examples are provided "AS IS" without warranties of any kind, either express or implied, including merchantability, fitness for a particular purpose, non-infringement, accuracy, completeness, functionality, or safety.</li>
<li>The authors and Tohoku University assume no responsibility for the content, availability, or safety of external links, third-party data, tools, libraries, etc.</li>
<li>To the maximum extent permitted by applicable law, the authors and Tohoku University shall not be liable for any direct, indirect, incidental, special, consequential, or punitive damages arising from the use, execution, or interpretation of this content.</li>
<li>The content may be changed, updated, or discontinued without notice.</li>
<li>The copyright and license of this content are subject to the specified terms (e.g., CC BY 4.0). Such licenses typically include warranty disclaimers.</li>
</ul>
</section>
<footer>
<p><strong>Author</strong>: MS Knowledge Hub Content Team</p>
<p><strong>Version</strong>: 1.0 | <strong>Created</strong>: 2025-10-28</p>
<p><strong>License</strong>: Creative Commons BY 4.0</p>
<p>¬© 2025 MS Terakoya. All rights reserved.</p>
</footer>
</body>
</html>
