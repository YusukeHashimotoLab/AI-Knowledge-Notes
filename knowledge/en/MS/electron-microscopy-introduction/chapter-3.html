<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Chapter 3: Introduction to Transmission Electron Microscopy (TEM) - MS Terakoya</title>
<link href="../../assets/css/knowledge-base.css" rel="stylesheet"/>
<!-- Prism.js for syntax highlighting -->
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet"/>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
<script>
        mermaid.initialize({ startOnLoad: true, theme: 'default', securityLevel: 'strict' });
    </script>
<script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true,
                processEnvironments: true
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
                ignoreHtmlClass: 'mermaid'
            }
        };
    </script>
<script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body><div class="locale-switcher">
<span class="current-locale">üåê EN</span>
<span class="locale-separator">|</span>

<span class="locale-meta">Last sync: 2025-11-16</span>
</div>

<header>
<div class="header-content">
<h1>Chapter 3: Introduction to Transmission Electron Microscopy (TEM)</h1>
<p class="subtitle">TEM Imaging Theory, Diffraction Analysis, and Fundamentals of High-Resolution Observation</p>
<div class="meta">
<span class="meta-item">üìñ Reading Time: 25-35 minutes</span>
<span class="meta-item">üìä Difficulty: Intermediate</span>
<span class="meta-item">üíª Code Examples: 7</span>
</div>
</div>
</header>
<div class="breadcrumb">
<a href="../index.html">AI Terakoya Top</a> &gt;
        <a href="../index.html">MS Dojo</a> &gt;
        <a href="index.html">Electron Microscopy Introduction</a> &gt;
        Chapter 3
    </div>
<main class="container">
<p class="chapter-description" style="margin: 1.5rem 0; padding: 1rem; background: linear-gradient(135deg, #fce7f3 0%, #fbcfe8 100%); border-left: 4px solid #f093fb; border-radius: 8px; font-size: 1.05rem; line-height: 1.8; color: #2d3748;">
            Transmission Electron Microscopy (TEM) is a powerful tool that uses electron beams transmitted through specimens to observe the internal structure of materials at the atomic level. In this chapter, we will learn TEM imaging theory, bright field/dark field imaging, Selected Area Electron Diffraction (SAED), High-Resolution TEM (HRTEM), and aberration correction techniques, and practice diffraction pattern analysis and FFT processing using Python.
        </p>
<div class="learning-objectives">
<h2>Learning Objectives</h2>
<p>By completing this chapter, you will be able to:</p>
<ul>
<li>‚úÖ Understand TEM imaging theory and contrast mechanisms (mass-thickness, diffraction contrast)</li>
<li>‚úÖ Comprehend the formation principles of bright field (BF) and dark field (DF) images and their applications</li>
<li>‚úÖ Index Selected Area Electron Diffraction (SAED) patterns</li>
<li>‚úÖ Understand the differences between lattice images and high-resolution TEM images and perform FFT analysis</li>
<li>‚úÖ Explain the role of Contrast Transfer Function (CTF) and aberration correction techniques</li>
<li>‚úÖ Implement Ewald sphere construction, SAED analysis, and FFT processing of HRTEM images in Python</li>
<li>‚úÖ Quantitatively evaluate the effects of defocus and spherical aberration on images</li>
</ul>
</div>
<h2>3.1 Fundamentals of TEM Imaging Theory</h2>
<h3>3.1.1 TEM Configuration</h3>
<p>The Transmission Electron Microscope (TEM) has an optical system where the objective lens forms an image of the electron beam transmitted through the specimen, and the projection lens magnifies it.</p>
<div class="mermaid">
flowchart TD
    A[Electron Gun] --&gt; B[Illumination System Lenses]
    B --&gt; C[Specimen Stage]
    C --&gt; D[Objective Lens]
    D --&gt; E[Selected Area Aperture<br/>Selected Area Aperture]
    E --&gt; F[Intermediate Lens]
    F --&gt; G[Projection Lens]
    G --&gt; H[Fluorescent Screen/Detector]

    D -.Diffraction Plane.-&gt; I[Back Focal Plane<br/>BFP]
    I -.-&gt; F
    D -.Image Plane.-&gt; J[Gaussian Image Plane]
    J -.-&gt; F

    style A fill:#f093fb,stroke:#f5576c,stroke-width:2px,color:#fff
    style D fill:#f5576c,stroke:#f093fb,stroke-width:2px,color:#fff
    style I fill:#ffeb99,stroke:#ffa500
    style J fill:#99ccff,stroke:#0066cc
        </div>
<p><strong>Important Concepts</strong>:</p>
<ul>
<li><strong>Back Focal Plane (BFP)</strong>: The focal plane of the objective lens where the diffraction pattern is formed</li>
<li><strong>Gaussian Image Plane</strong>: The plane where the real image of the specimen is formed</li>
<li><strong>Objective Aperture</strong>: Placed at the BFP to select specific diffraction spots and control contrast</li>
<li><strong>Selected Area Aperture</strong>: Placed at the image plane to obtain diffraction patterns from specific regions (SAED: Selected Area Electron Diffraction)</li>
</ul>
<h3>3.1.2 TEM Image Contrast Mechanisms</h3>
<p>TEM image contrast is formed by three main mechanisms:</p>
<table>
<thead>
<tr>
<th>Contrast Type</th>
<th>Physical Origin</th>
<th>Applications</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Mass-Thickness Contrast</strong></td>
<td>Differences in electron scattering intensity due to specimen density and thickness</td>
<td>Observation of amorphous specimens, biological specimens, thickness variations</td>
</tr>
<tr>
<td><strong>Diffraction Contrast</strong></td>
<td>Changes in crystal diffraction conditions (Bragg condition)</td>
<td>Observation of dislocations, twins, grain boundaries</td>
</tr>
<tr>
<td><strong>Phase Contrast</strong></td>
<td>Interference due to phase differences between transmitted and diffracted waves</td>
<td>Lattice image observation in High-Resolution TEM (HRTEM)</td>
</tr>
</tbody>
</table>
<p><strong>Bright Field Image (BF)</strong>: Formed by allowing only the transmitted beam (000 reflection) to pass through the objective aperture. Thick or strongly scattering regions appear dark.</p>
<p><strong>Dark Field Image (DF)</strong>: Formed by allowing only a specific diffracted beam to pass through the objective aperture. Only crystal grains satisfying that reflection condition appear bright.</p>
<h3>3.1.3 Contrast Transfer Function (CTF)</h3>
<p>In high-resolution TEM, phase contrast is important. This phase contrast is described by the <strong>Contrast Transfer Function (CTF)</strong>:</p>

        $$
        \text{CTF}(k) = A(k) \sin\left[\chi(k)\right]
        $$

        <p>Here, $A(k)$ is the aperture function, and $\chi(k)$ is the phase shift expressed as:</p>

        $$
        \chi(k) = \frac{2\pi}{\lambda}\left(\frac{\lambda^2 k^2}{2}\Delta f + \frac{\lambda^4 k^4}{4}C_s\right)
        $$

        <ul>
<li>$k$: Spatial frequency (in inverse √Ö)</li>
<li>$\lambda$: Electron wavelength (determined by accelerating voltage)</li>
<li>$\Delta f$: Defocus (focus deviation amount, negative values are underfocus)</li>
<li>$C_s$: Spherical aberration coefficient (lens aberration parameter)</li>
</ul>
<p><strong>Physical Meaning</strong>:</p>
<ul>
<li>In spatial frequency regions where CTF is positive, phase contrast contributes to the image without inversion</li>
<li>In regions where CTF is negative, contrast is inverted (black-white reversal)</li>
<li>At frequencies where CTF becomes zero (zero crossing), that spatial frequency component does not contribute to the image</li>
<li>By setting appropriate defocus (Scherzer focus), a CTF with a constant sign over a wide spatial frequency range can be achieved</li>
</ul>
<h4>Code Example 3-1: Contrast Transfer Function (CTF) Simulation</h4>
<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt

def calculate_ctf(k, voltage_kV, defocus_nm, Cs_mm, aperture_mrad=None):
    """
    Calculate Contrast Transfer Function (CTF)

    Parameters
    ----------
    k : array-like
        Spatial frequency [1/√Ö]
    voltage_kV : float
        Accelerating voltage [kV]
    defocus_nm : float
        Defocus [nm] (negative: underfocus)
    Cs_mm : float
        Spherical aberration coefficient [mm]
    aperture_mrad : float, optional
        Objective aperture semi-angle [mrad]. None for infinite (no aperture)

    Returns
    -------
    ctf : ndarray
        CTF values
    """
    # Electron wavelength calculation (with relativistic correction)
    m0 = 9.10938e-31  # Electron mass [kg]
    e = 1.60218e-19   # Charge [C]
    c = 2.99792e8     # Speed of light [m/s]
    h = 6.62607e-34   # Planck constant [J¬∑s]

    E = voltage_kV * 1000 * e  # Energy [J]
    lambda_pm = h / np.sqrt(2 * m0 * E * (1 + E / (2 * m0 * c**2))) * 1e12  # [pm]
    lambda_A = lambda_pm / 100  # [√Ö]

    # Convert parameters to appropriate units
    defocus_A = defocus_nm * 10  # [√Ö]
    Cs_A = Cs_mm * 1e7  # [√Ö]

    # Phase shift œá(k)
    chi = (2 * np.pi / lambda_A) * (
        0.5 * lambda_A**2 * k**2 * defocus_A +
        0.25 * lambda_A**4 * k**4 * Cs_A
    )

    # Aperture function (Gaussian approximation)
    if aperture_mrad is not None:
        theta_max = aperture_mrad * 1e-3  # [rad]
        k_max = theta_max / lambda_A
        A = np.exp(-(k / k_max)**4)
    else:
        A = 1.0

    # CTF = A(k) * sin(œá(k))
    ctf = A * np.sin(chi)

    return ctf, lambda_A

# Simulation settings
voltage = 200  # [kV]
Cs = 0.5  # [mm] (modern TEM)
k = np.linspace(0, 10, 1000)  # Spatial frequency [1/√Ö]

# CTF for different defocus values
defocus_values = [-50, -70, -100]  # [nm]
colors = ['blue', 'green', 'red']

fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 5))

# Left panel: Defocus dependence
for df, color in zip(defocus_values, colors):
    ctf, wavelength = calculate_ctf(k, voltage, df, Cs)
    ax1.plot(k, ctf, color=color, linewidth=2, label=f'Œîf = {df} nm')

ax1.axhline(y=0, color='black', linestyle='--', linewidth=0.8)
ax1.set_xlabel('Spatial Frequency [1/√Ö]', fontsize=12)
ax1.set_ylabel('CTF', fontsize=12)
ax1.set_title(f'CTF vs Defocus (200 kV, Cs = {Cs} mm)', fontsize=14, fontweight='bold')
ax1.legend(fontsize=11)
ax1.grid(alpha=0.3)
ax1.set_xlim(0, 10)
ax1.set_ylim(-1, 1)

# Right panel: Spherical aberration coefficient dependence
defocus = -70  # [nm]
Cs_values = [0.5, 1.0, 2.0]  # [mm]
colors2 = ['purple', 'orange', 'brown']

for Cs_val, color in zip(Cs_values, colors2):
    ctf, wavelength = calculate_ctf(k, voltage, defocus, Cs_val)
    ax2.plot(k, ctf, color=color, linewidth=2, label=f'Cs = {Cs_val} mm')

ax2.axhline(y=0, color='black', linestyle='--', linewidth=0.8)
ax2.set_xlabel('Spatial Frequency [1/√Ö]', fontsize=12)
ax2.set_ylabel('CTF', fontsize=12)
ax2.set_title(f'CTF vs Cs (200 kV, Œîf = {defocus} nm)', fontsize=14, fontweight='bold')
ax2.legend(fontsize=11)
ax2.grid(alpha=0.3)
ax2.set_xlim(0, 10)
ax2.set_ylim(-1, 1)

plt.tight_layout()
plt.show()

# Scherzer focus (optimal defocus) calculation
Cs_mm = 0.5
lambda_A = 0.0251  # Wavelength at 200 kV
Cs_A = Cs_mm * 1e7
scherzer_defocus_A = -1.2 * np.sqrt(Cs_A * lambda_A)
scherzer_defocus_nm = scherzer_defocus_A / 10

print(f"Scherzer Focus: {scherzer_defocus_nm:.1f} nm")
print(f"First zero crossing frequency: ~{1/2.5:.2f} √Ö")
</code></pre>
<p><strong>Output Interpretation</strong>:</p>
<ul>
<li>When defocus is too large, CTF oscillates at low spatial frequencies, making the image complex</li>
<li>Larger Cs leads to more vigorous CTF oscillation in the high spatial frequency region, reducing resolution</li>
<li>At Scherzer focus (~-70 nm), a positive CTF is obtained over a wide spatial frequency range</li>
</ul>
<h2>3.2 Bright Field and Dark Field Images</h2>
<h3>3.2.1 Bright Field (BF) Image Formation</h3>
<p>Bright field images are formed by selecting only the transmitted beam (000 reflection) with the objective aperture. For thin and uniform specimens, mass-thickness contrast is dominant.</p>
<p><strong>Characteristics of Bright Field Images</strong>:</p>
<ul>
<li>Thick regions or regions containing heavy elements appear dark</li>
<li>High S/N ratio, suitable for low magnification observation</li>
<li>Effective for observing amorphous specimens and biological specimens</li>
<li>For crystalline specimens, crystal grains satisfying Bragg conditions appear dark (diffraction contrast)</li>
</ul>
<h3>3.2.2 Dark Field (DF) Image Formation</h3>
<p>Dark field images are formed by selecting only a specific diffracted beam (e.g., 111 reflection) with the objective aperture.</p>
<p><strong>Advantages of Dark Field Images</strong>:</p>
<ul>
<li>Only particles with specific crystal orientations appear bright</li>
<li>Effective for detecting fine precipitates or second phases</li>
<li>Easy identification of crystal grains (grains with the same orientation have the same brightness)</li>
<li>Suitable for observing dislocations and stacking faults</li>
</ul>
<p><strong>Centered Dark Field (CDF) Method</strong>: A technique where the optical axis is tilted to bring the diffracted beam to the center. It reduces the effect of spherical aberration and provides higher resolution.</p>
<h4>Code Example 3-2: Bright Field and Dark Field Image Simulation</h4>
<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
from scipy.ndimage import gaussian_filter, rotate

def simulate_polycrystalline_sample(size=512, num_grains=50):
    """
    Simulate a polycrystalline specimen

    Parameters
    ----------
    size : int
        Image size [pixels]
    num_grains : int
        Number of crystal grains

    Returns
    -------
    grain_map : ndarray
        Grain map (grain ID for each pixel)
    orientations : ndarray
        Orientation of each grain [degrees]
    """
    # Generate grains using Voronoi tessellation
    from scipy.spatial import Voronoi

    # Random seed points
    np.random.seed(42)
    points = np.random.rand(num_grains, 2) * size

    # Coordinates of all pixels
    x, y = np.meshgrid(np.arange(size), np.arange(size))
    pixels = np.stack([x.ravel(), y.ravel()], axis=1)

    # Find nearest seed point to create Voronoi regions
    from scipy.spatial.distance import cdist
    distances = cdist(pixels, points)
    grain_map = np.argmin(distances, axis=1).reshape(size, size)

    # Assign random orientation to each grain
    orientations = np.random.rand(num_grains) * 360

    return grain_map, orientations

def calculate_diffraction_intensity(grain_map, orientations, hkl=(111,)):
    """
    Calculate intensity under specific diffraction conditions

    Parameters
    ----------
    grain_map : ndarray
        Grain map
    orientations : ndarray
        Orientation of each grain [degrees]
    hkl : tuple
        Miller indices (considering only orientation dependence for simplification)

    Returns
    -------
    intensity : ndarray
        Diffraction intensity map
    """
    # Bragg condition: Strong diffraction only in specific orientation range
    # Simplification: Assume strong diffraction at 30¬∞¬±5¬∞
    target_angle = 30.0
    tolerance = 5.0

    intensity = np.zeros_like(grain_map, dtype=float)

    for grain_id in range(len(orientations)):
        mask = (grain_map == grain_id)
        angle = orientations[grain_id]

        # Determine if diffraction condition is satisfied
        angle_diff = min(abs(angle - target_angle),
                        abs(angle - target_angle + 360),
                        abs(angle - target_angle - 360))

        if angle_diff &lt; tolerance:
            # Bragg condition satisfied ‚Üí Strong diffraction (dark in BF, bright in DF)
            intensity[mask] = 1.0
        else:
            intensity[mask] = 0.1  # Weak diffraction

    # Add noise
    intensity += np.random.normal(0, 0.05, intensity.shape)

    return intensity

# Execute simulation
size = 512
grain_map, orientations = simulate_polycrystalline_sample(size, num_grains=30)

# Bright field image: Strongly diffracting regions are dark
diffraction_intensity = calculate_diffraction_intensity(grain_map, orientations)
bf_image = 1.0 - diffraction_intensity * 0.7  # Transmitted intensity = 1 - diffraction intensity

# Dark field image: Only grains satisfying specific diffraction conditions are bright
df_image = calculate_diffraction_intensity(grain_map, orientations)

# Add blur (make it more realistic)
bf_image = gaussian_filter(bf_image, sigma=1.0)
df_image = gaussian_filter(df_image, sigma=1.0)

# Visualization
fig, axes = plt.subplots(1, 3, figsize=(15, 5))

# Grain map
im0 = axes[0].imshow(grain_map, cmap='tab20', interpolation='nearest')
axes[0].set_title('Crystal Grain Map\n(Ground Truth)', fontsize=13, fontweight='bold')
axes[0].axis('off')

# Bright field image
im1 = axes[1].imshow(bf_image, cmap='gray', vmin=0, vmax=1)
axes[1].set_title('Bright Field Image\n(Transmitted Beam: 000)', fontsize=13, fontweight='bold')
axes[1].axis('off')

# Dark field image
im2 = axes[2].imshow(df_image, cmap='gray', vmin=0, vmax=1)
axes[2].set_title('Dark Field Image\n(Diffracted Beam: 111)', fontsize=13, fontweight='bold')
axes[2].axis('off')

plt.tight_layout()
plt.show()

print("Bright field image: Crystal grains satisfying diffraction conditions appear dark")
print("Dark field image: Only grains satisfying specific diffraction conditions (111 reflection) appear bright")
</code></pre>
<p><strong>Observation Points</strong>:</p>
<ul>
<li>In bright field images, crystal grains with strong diffraction appear dark</li>
<li>In dark field images, only crystal grains with specific orientations selectively appear bright</li>
<li>In actual TEM, different diffraction spots can be selected by changing the objective aperture position</li>
</ul>
<h2>3.3 Selected Area Electron Diffraction (SAED)</h2>
<h3>3.3.1 Principles of Electron Diffraction</h3>
<p>Electron diffraction is a phenomenon where electron waves are diffracted by the periodic structure of crystals. Bragg's law applies:</p>

        $$
        2d_{hkl}\sin\theta = n\lambda
        $$

        <p>In TEM, the incident electron beam enters nearly perpendicular to the specimen, so $\theta$ is very small (typically less than 1¬∞), and the small-angle approximation holds:</p>

        $$
        \sin\theta \approx \theta \approx \tan\theta = \frac{R}{L}
        $$

        <p>Here, $R$ is the distance of the diffraction spot, and $L$ is the camera length. Therefore:</p>

        $$
        d_{hkl} = \frac{\lambda L}{R}
        $$

        <p><strong>SAED (Selected Area Electron Diffraction)</strong>: A technique to obtain diffraction patterns from specific regions (typically several hundred nm to several Œºm) using a selected area aperture.</p>
<h3>3.3.2 Ewald Sphere Construction</h3>
<p>Electron diffraction is understood as the intersection of the Ewald Sphere with reciprocal lattice points in reciprocal space.</p>
<ul>
<li><strong>Ewald Sphere</strong>: A sphere with radius $1/\lambda$ drawn along the incident beam direction</li>
<li><strong>Reciprocal Lattice Points</strong>: Points in reciprocal space corresponding to the periodic structure of the crystal</li>
<li><strong>Diffraction Condition</strong>: When the Ewald sphere passes through a reciprocal lattice point, the Bragg condition is satisfied and diffraction occurs</li>
</ul>
<h4>Code Example 3-3: Ewald Sphere Construction and Diffraction Pattern Simulation</h4>
<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

def generate_reciprocal_lattice_fcc(max_hkl=3):
    """
    Generate reciprocal lattice points for FCC crystal

    Parameters
    ----------
    max_hkl : int
        Maximum Miller index

    Returns
    -------
    points : list of tuples
        Reciprocal lattice points (h, k, l)
    """
    points = []
    for h in range(-max_hkl, max_hkl + 1):
        for k in range(-max_hkl, max_hkl + 1):
            for l in range(-max_hkl, max_hkl + 1):
                # FCC extinction rule: h, k, l are all even or all odd
                if (h % 2 == k % 2 == l % 2):
                    points.append((h, k, l))
    return points

def plot_ewald_sphere(a_lattice=4.05, voltage_kV=200, zone_axis=[0, 0, 1]):
    """
    Plot Ewald sphere construction in 3D

    Parameters
    ----------
    a_lattice : float
        Lattice constant [√Ö]
    voltage_kV : float
        Accelerating voltage [kV]
    zone_axis : list
        Zone axis [uvw]
    """
    # Electron wavelength calculation
    m0 = 9.10938e-31
    e = 1.60218e-19
    c = 2.99792e8
    h = 6.62607e-34
    E = voltage_kV * 1000 * e
    lambda_m = h / np.sqrt(2 * m0 * E * (1 + E / (2 * m0 * c**2)))
    lambda_A = lambda_m * 1e10

    # Ewald sphere radius (inverse √Ö)
    k = 1 / lambda_A

    # Reciprocal lattice vectors (FCC)
    reciprocal_points = generate_reciprocal_lattice_fcc(max_hkl=2)

    # Reciprocal lattice constant
    a_star = 1 / a_lattice

    # 3D plot
    fig = plt.figure(figsize=(14, 6))

    # Left panel: 3D Ewald sphere construction
    ax1 = fig.add_subplot(121, projection='3d')

    # Plot reciprocal lattice points
    for (h, k, l) in reciprocal_points:
        x = h * a_star
        y = k * a_star
        z = l * a_star
        ax1.scatter(x, y, z, c='blue', s=30, alpha=0.6)
        if abs(l) &lt;= 1:  # Near [001] zone axis
            ax1.text(x, y, z, f'  {h}{k}{l}', fontsize=8)

    # Ewald sphere (simplified: represented as circle)
    theta = np.linspace(0, 2*np.pi, 100)
    phi = np.linspace(0, np.pi, 50)

    x_sphere = k * np.outer(np.cos(theta), np.sin(phi))
    y_sphere = k * np.outer(np.sin(theta), np.sin(phi))
    z_sphere = k * np.outer(np.ones(100), np.cos(phi)) - k

    ax1.plot_surface(x_sphere, y_sphere, z_sphere, alpha=0.1, color='red')

    # Incident beam
    ax1.quiver(0, 0, -k, 0, 0, k*1.5, color='green', arrow_length_ratio=0.1, linewidth=2)

    ax1.set_xlabel('$k_x$ [1/√Ö]', fontsize=11)
    ax1.set_ylabel('$k_y$ [1/√Ö]', fontsize=11)
    ax1.set_zlabel('$k_z$ [1/√Ö]', fontsize=11)
    ax1.set_title('Ewald Sphere Construction\n(3D Reciprocal Space)', fontsize=13, fontweight='bold')
    ax1.set_xlim(-2, 2)
    ax1.set_ylim(-2, 2)
    ax1.set_zlim(-2, 2)

    # Right panel: [001] zone axis diffraction pattern (2D projection)
    ax2 = fig.add_subplot(122)

    for (h, k, l) in reciprocal_points:
        if l == 0:  # [001] zone axis
            x = h * a_star
            y = k * a_star
            ax2.scatter(x, y, c='blue', s=100, alpha=0.8)
            ax2.text(x, y + 0.1, f'{h}{k}{l}', fontsize=10, ha='center', fontweight='bold')

    ax2.scatter(0, 0, c='red', s=200, marker='o', label='Transmitted Beam (000)')
    ax2.set_xlabel('$k_x$ [1/√Ö]', fontsize=12)
    ax2.set_ylabel('$k_y$ [1/√Ö]', fontsize=12)
    ax2.set_title('SAED Pattern: [001] Zone Axis\n(Al FCC, 200 kV)', fontsize=13, fontweight='bold')
    ax2.legend(fontsize=10)
    ax2.grid(alpha=0.3)
    ax2.set_aspect('equal')
    ax2.set_xlim(-2.5, 2.5)
    ax2.set_ylim(-2.5, 2.5)

    plt.tight_layout()
    plt.show()

    print(f"Electron wavelength: {lambda_A:.5f} √Ö")
    print(f"Ewald sphere radius: {k:.2f} 1/√Ö")
    print(f"Reciprocal lattice constant: {a_star:.3f} 1/√Ö")

# Execute
plot_ewald_sphere(a_lattice=4.05, voltage_kV=200, zone_axis=[0, 0, 1])
</code></pre>
<h3>3.3.3 Indexing SAED Patterns</h3>
<p>Procedure to identify crystal structure from SAED patterns:</p>
<ol>
<li><strong>Calibrate camera constant</strong>: Determine $\lambda L$ with a known specimen (e.g., Au)</li>
<li><strong>Measure diffraction spot spacing</strong>: Distance $R$ from center (000) to each spot</li>
<li><strong>Calculate interplanar spacing</strong>: $d = \lambda L / R$</li>
<li><strong>Identify Miller indices</strong>: Compare calculated $d$ values with crystallographic data</li>
<li><strong>Determine zone axis</strong>: Determine zone axis $[uvw]$ from multiple diffraction spots</li>
</ol>
<h4>Code Example 3-4: SAED Pattern Indexing Simulation</h4>
<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt

def calculate_d_spacing_fcc(a, h, k, l):
    """
    Calculate interplanar spacing for FCC crystal

    Parameters
    ----------
    a : float
        Lattice constant [√Ö]
    h, k, l : int
        Miller indices

    Returns
    -------
    d : float
        Interplanar spacing [√Ö]
    """
    d = a / np.sqrt(h**2 + k**2 + l**2)
    return d

def index_saed_pattern(camera_length_mm=500, voltage_kV=200, crystal='Al'):
    """
    SAED pattern indexing simulation

    Parameters
    ----------
    camera_length_mm : float
        Camera length [mm]
    voltage_kV : float
        Accelerating voltage [kV]
    crystal : str
        Crystal type ('Al', 'Cu', 'Au')
    """
    # Electron wavelength calculation
    m0 = 9.10938e-31
    e = 1.60218e-19
    c = 2.99792e8
    h = 6.62607e-34
    E = voltage_kV * 1000 * e
    lambda_m = h / np.sqrt(2 * m0 * E * (1 + E / (2 * m0 * c**2)))
    lambda_pm = lambda_m * 1e12  # [pm]

    # Camera constant
    lambda_L = lambda_pm * camera_length_mm  # [pm¬∑mm]

    # Lattice constant database
    lattice_constants = {
        'Al': 4.05,  # [√Ö]
        'Cu': 3.61,
        'Au': 4.08
    }
    a = lattice_constants[crystal]

    # FCC [001] zone axis allowed reflections
    reflections = [
        (0, 0, 0),  # Transmitted beam
        (2, 0, 0), (0, 2, 0), (-2, 0, 0), (0, -2, 0),
        (2, 2, 0), (2, -2, 0), (-2, 2, 0), (-2, -2, 0),
        (4, 0, 0), (0, 4, 0), (-4, 0, 0), (0, -4, 0)
    ]

    # Generate diffraction pattern
    fig, ax = plt.subplots(figsize=(10, 10))

    for (h, k, l) in reflections:
        if h == 0 and k == 0 and l == 0:
            # Transmitted beam
            ax.scatter(0, 0, c='red', s=300, marker='o', edgecolors='black', linewidths=2, zorder=10)
            ax.text(0, -5, '000', fontsize=12, ha='center', fontweight='bold', color='red')
            continue

        # Calculate interplanar spacing
        d = calculate_d_spacing_fcc(a, h, k, l)

        # Diffraction spot position (distance on screen) [mm]
        R_mm = lambda_L / (d * 100)  # Convert d [√Ö] ‚Üí [pm]

        # Position in 2D pattern ([001] zone axis)
        x = h / np.sqrt(h**2 + k**2) * R_mm if h != 0 or k != 0 else 0
        y = k / np.sqrt(h**2 + k**2) * R_mm if h != 0 or k != 0 else 0

        # Simplification: Use h, k signs directly
        x = h * (lambda_L / (calculate_d_spacing_fcc(a, 2, 0, 0) * 100)) / 2
        y = k * (lambda_L / (calculate_d_spacing_fcc(a, 0, 2, 0) * 100)) / 2

        ax.scatter(x, y, c='blue', s=150, alpha=0.8, edgecolors='black', linewidths=1)
        ax.text(x, y - 2, f'{h}{k}{l}', fontsize=10, ha='center', fontweight='bold')
        ax.text(x, y + 2, f'd={d:.3f}√Ö', fontsize=8, ha='center', color='green')

    ax.set_xlabel('x [mm on screen]', fontsize=13)
    ax.set_ylabel('y [mm on screen]', fontsize=13)
    ax.set_title(f'Indexed SAED Pattern: {crystal} FCC [001]\n' +
                 f'(ŒªL = {lambda_L:.2f} pm¬∑mm, a = {a} √Ö)',
                 fontsize=14, fontweight='bold')
    ax.grid(alpha=0.3)
    ax.set_aspect('equal')
    ax.axhline(0, color='gray', linestyle='--', linewidth=0.8)
    ax.axvline(0, color='gray', linestyle='--', linewidth=0.8)

    # Scale bar
    ax.plot([25, 35], [-35, -35], 'k-', linewidth=3)
    ax.text(30, -38, '10 mm', fontsize=10, ha='center')

    plt.tight_layout()
    plt.show()

    # Output d-values of major reflections
    print(f"\n{crystal} FCC major reflections interplanar spacing:")
    print(f"  (200): d = {calculate_d_spacing_fcc(a, 2, 0, 0):.3f} √Ö")
    print(f"  (220): d = {calculate_d_spacing_fcc(a, 2, 2, 0):.3f} √Ö")
    print(f"  (400): d = {calculate_d_spacing_fcc(a, 4, 0, 0):.3f} √Ö")

# Execute
index_saed_pattern(camera_length_mm=500, voltage_kV=200, crystal='Al')
</code></pre>
<h2>3.4 High-Resolution TEM (HRTEM)</h2>
<h3>3.4.1 Lattice Images and Structure Images</h3>
<p>In High-Resolution TEM (HRTEM), interference between the transmitted beam and multiple diffracted beams forms lattice images.</p>
<p><strong>Differences between Lattice Images and HRTEM Images</strong>:</p>
<ul>
<li><strong>Lattice Fringes</strong>: Formed by two-beam interference (transmitted beam + one diffracted beam). Specific lattice planes appear as fringe patterns</li>
<li><strong>HRTEM Images</strong>: Formed by multi-beam interference (transmitted beam + many diffracted beams). Directly reflect atomic arrangements</li>
</ul>
<p><strong>Cautions in Interpreting HRTEM Images</strong>:</p>
<ul>
<li>HRTEM images are <strong>projections</strong> of atomic arrangements, with thickness direction information superimposed</li>
<li>Due to defocus and Cs, the image may not correspond to atomic positions (black-white reversal)</li>
<li>Comparison with image simulation (multislice method, etc.) is essential</li>
</ul>
<h3>3.4.2 FFT Analysis of HRTEM Images</h3>
<p><strong>Fast Fourier Transform (FFT)</strong> of HRTEM images allows extraction of reciprocal lattice information. FFT patterns correspond to SAED patterns.</p>
<h4>Code Example 3-5: HRTEM Image Generation and FFT Analysis</h4>
<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
from scipy.fft import fft2, fftshift

def generate_hrtem_image(size=512, lattice_a=4.05, zone_axis=[1, 1, 0], noise_level=0.1):
    """
    Simulate simplified HRTEM image (two-beam approximation)

    Parameters
    ----------
    size : int
        Image size [pixels]
    lattice_a : float
        Lattice constant [√Ö]
    zone_axis : list
        Zone axis [uvw]
    noise_level : float
        Noise level

    Returns
    -------
    image : ndarray
        HRTEM image
    """
    # Pixel size (√Ö/pixel)
    pixel_size = 0.1  # 0.1 √Ö/pixel ‚Üí resolution equivalent to 0.2 √Ö

    # Coordinate grid
    x = np.arange(size) * pixel_size
    y = np.arange(size) * pixel_size
    X, Y = np.meshgrid(x, y)

    # For [110] zone axis, interference fringes from (111) and (-111) planes
    # Interplanar spacing (FCC)
    d_111 = lattice_a / np.sqrt(3)

    # Lattice fringe simulation
    k1 = 2 * np.pi / d_111

    # Superimpose lattice fringes in two directions
    fringe1 = np.cos(k1 * (X + Y) / np.sqrt(2))
    fringe2 = np.cos(k1 * (X - Y) / np.sqrt(2))

    # HRTEM image: simplified multi-beam interference model
    image = 0.5 + 0.3 * fringe1 + 0.3 * fringe2

    # Add noise
    image += np.random.normal(0, noise_level, image.shape)

    # Normalize
    image = (image - image.min()) / (image.max() - image.min())

    return image, pixel_size

def plot_hrtem_with_fft(image, pixel_size):
    """
    Plot HRTEM image and its FFT pattern

    Parameters
    ----------
    image : ndarray
        HRTEM image
    pixel_size : float
        Pixel size [√Ö/pixel]
    """
    # FFT calculation
    fft_image = fftshift(fft2(image))
    fft_magnitude = np.abs(fft_image)
    fft_magnitude_log = np.log(1 + fft_magnitude)  # Log scale

    # Frequency axis (1/√Ö)
    freq_x = np.fft.fftshift(np.fft.fftfreq(image.shape[1], d=pixel_size))
    freq_y = np.fft.fftshift(np.fft.fftfreq(image.shape[0], d=pixel_size))

    # Visualization
    fig, axes = plt.subplots(1, 3, figsize=(17, 5))

    # HRTEM image (full)
    im0 = axes[0].imshow(image, cmap='gray', extent=[0, image.shape[1]*pixel_size,
                                                      0, image.shape[0]*pixel_size])
    axes[0].set_title('HRTEM Image (Full)', fontsize=13, fontweight='bold')
    axes[0].set_xlabel('x [√Ö]', fontsize=11)
    axes[0].set_ylabel('y [√Ö]', fontsize=11)

    # HRTEM image (zoomed)
    zoom_size = 50
    center = image.shape[0] // 2
    zoomed = image[center-zoom_size:center+zoom_size, center-zoom_size:center+zoom_size]
    extent_zoom = [0, zoom_size*2*pixel_size, 0, zoom_size*2*pixel_size]

    im1 = axes[1].imshow(zoomed, cmap='gray', extent=extent_zoom)
    axes[1].set_title('HRTEM Image (Zoomed)\nLattice Fringes Visible', fontsize=13, fontweight='bold')
    axes[1].set_xlabel('x [√Ö]', fontsize=11)
    axes[1].set_ylabel('y [√Ö]', fontsize=11)

    # FFT pattern (log scale)
    im2 = axes[2].imshow(fft_magnitude_log, cmap='hot',
                        extent=[freq_x.min(), freq_x.max(), freq_y.min(), freq_y.max()])
    axes[2].set_title('FFT Pattern (Log Scale)\n(= Diffractogram)', fontsize=13, fontweight='bold')
    axes[2].set_xlabel('$k_x$ [1/√Ö]', fontsize=11)
    axes[2].set_ylabel('$k_y$ [1/√Ö]', fontsize=11)
    axes[2].set_xlim(-5, 5)
    axes[2].set_ylim(-5, 5)

    # Mark main peaks in FFT
    # Center (000)
    axes[2].scatter(0, 0, c='cyan', s=100, marker='o', edgecolors='white', linewidths=2)

    plt.tight_layout()
    plt.show()

# Execute
image, pixel_size = generate_hrtem_image(size=512, lattice_a=4.05, zone_axis=[1, 1, 0], noise_level=0.05)
plot_hrtem_with_fft(image, pixel_size)

print("FFT pattern interpretation:")
print("  - Center (bright spot): Transmitted beam (000)")
print("  - Symmetrical bright spots: Diffracted beams from lattice planes")
print("  - Spot spacing ‚àù 1/d (reciprocal of interplanar spacing)")
</code></pre>
<h3>3.4.3 Aberration Correction Technology</h3>
<p>In modern TEM, spherical aberration correctors (Cs-correctors) can bring the spherical aberration coefficient close to zero.</p>
<p><strong>Effects of Aberration Correction</strong>:</p>
<ul>
<li><strong>Resolution improvement</strong>: 0.5 √Ö ‚Üí 0.05 √Ö (atomic level)</li>
<li><strong>CTF improvement</strong>: Achieve CTF with constant sign over wide spatial frequency range</li>
<li><strong>Reduced defocus dependence</strong>: Scherzer focus constraint relaxed</li>
<li><strong>Simplified image interpretation</strong>: Intuitive correspondence between atomic positions and images</li>
</ul>
<h4>Code Example 3-6: CTF Comparison Before and After Aberration Correction</h4>
<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt

def ctf_comparison_corrected_vs_uncorrected():
    """
    CTF comparison before and after aberration correction
    """
    k = np.linspace(0, 15, 1000)  # Spatial frequency [1/√Ö]

    voltage = 200  # [kV]
    lambda_A = 0.0251  # Wavelength at 200 kV [√Ö]
    defocus_nm = -70  # [nm]
    defocus_A = defocus_nm * 10  # [√Ö]

    # Before aberration correction: Cs = 0.5 mm
    Cs_uncorrected_mm = 0.5
    Cs_uncorrected_A = Cs_uncorrected_mm * 1e7

    chi_uncorrected = (2 * np.pi / lambda_A) * (
        0.5 * lambda_A**2 * k**2 * defocus_A +
        0.25 * lambda_A**4 * k**4 * Cs_uncorrected_A
    )
    ctf_uncorrected = np.sin(chi_uncorrected)

    # After aberration correction: Cs ‚âà -0.01 mm (negative aberration for correction)
    Cs_corrected_mm = -0.01
    Cs_corrected_A = Cs_corrected_mm * 1e7

    chi_corrected = (2 * np.pi / lambda_A) * (
        0.5 * lambda_A**2 * k**2 * defocus_A +
        0.25 * lambda_A**4 * k**4 * Cs_corrected_A
    )
    ctf_corrected = np.sin(chi_corrected)

    # Plot
    fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 10))

    # Top panel: CTF comparison
    ax1.plot(k, ctf_uncorrected, 'b-', linewidth=2, label='Uncorrected (Cs = 0.5 mm)')
    ax1.plot(k, ctf_corrected, 'r-', linewidth=2, label='Corrected (Cs ‚âà 0 mm)')
    ax1.axhline(0, color='black', linestyle='--', linewidth=0.8)
    ax1.set_xlabel('Spatial Frequency [1/√Ö]', fontsize=12)
    ax1.set_ylabel('CTF', fontsize=12)
    ax1.set_title('CTF: Aberration-Corrected vs Uncorrected TEM\n(200 kV, Œîf = -70 nm)',
                  fontsize=14, fontweight='bold')
    ax1.legend(fontsize=11, loc='upper right')
    ax1.grid(alpha=0.3)
    ax1.set_xlim(0, 15)
    ax1.set_ylim(-1, 1)

    # Annotation: Information transfer limit
    ax1.axvline(x=1/0.2, color='blue', linestyle=':', linewidth=2, alpha=0.7)
    ax1.text(1/0.2 + 0.3, 0.8, 'Uncorrected limit\n(~2 √Ö)', fontsize=10, color='blue')

    ax1.axvline(x=1/0.08, color='red', linestyle=':', linewidth=2, alpha=0.7)
    ax1.text(1/0.08 + 0.3, -0.8, 'Corrected limit\n(~0.8 √Ö)', fontsize=10, color='red')

    # Bottom panel: CTF phase shift œá(k)
    ax2.plot(k, chi_uncorrected, 'b-', linewidth=2, label='Uncorrected (Cs = 0.5 mm)')
    ax2.plot(k, chi_corrected, 'r-', linewidth=2, label='Corrected (Cs ‚âà 0 mm)')
    ax2.set_xlabel('Spatial Frequency [1/√Ö]', fontsize=12)
    ax2.set_ylabel('Phase Shift œá(k) [rad]', fontsize=12)
    ax2.set_title('Phase Shift Function œá(k)', fontsize=14, fontweight='bold')
    ax2.legend(fontsize=11, loc='upper left')
    ax2.grid(alpha=0.3)
    ax2.set_xlim(0, 15)

    plt.tight_layout()
    plt.show()

    # Resolution estimation
    # Frequency range up to first zero crossing is effective for information transfer
    k_zero_uncorrected = k[np.where(np.diff(np.sign(ctf_uncorrected)))[0][0]]
    k_zero_corrected = k[np.where(np.diff(np.sign(ctf_corrected)))[0][0]]

    resolution_uncorrected = 1 / k_zero_uncorrected
    resolution_corrected = 1 / k_zero_corrected

    print(f"Resolution before aberration correction: ~{resolution_uncorrected:.2f} √Ö")
    print(f"Resolution after aberration correction: ~{resolution_corrected:.2f} √Ö")
    print(f"Resolution improvement: {resolution_uncorrected / resolution_corrected:.1f}√ó")

# Execute
ctf_comparison_corrected_vs_uncorrected()
</code></pre>
<h2>3.5 Exercises</h2>
<h3>Exercise 3-1: CTF Optimization</h3>
<p><strong>Problem</strong>: Calculate the Scherzer focus for a 300 kV TEM (Cs = 1.0 mm) and determine the spatial frequency of the first zero crossing.</p>
<details>
<summary><strong>Show Answer</strong></summary>
<pre><code class="language-python">import numpy as np

# Parameters
voltage_kV = 300
Cs_mm = 1.0

# Electron wavelength calculation (relativistic correction)
m0 = 9.10938e-31
e = 1.60218e-19
c = 2.99792e8
h = 6.62607e-34
E = voltage_kV * 1000 * e
lambda_m = h / np.sqrt(2 * m0 * E * (1 + E / (2 * m0 * c**2)))
lambda_A = lambda_m * 1e10

# Scherzer focus
Cs_A = Cs_mm * 1e7
scherzer_defocus_A = -1.2 * np.sqrt(Cs_A * lambda_A)
scherzer_defocus_nm = scherzer_defocus_A / 10

# First zero crossing spatial frequency (approximation)
k_first_zero = 1.5 / (Cs_A**0.25 * lambda_A**0.75)
resolution_A = 1 / k_first_zero

print(f"Electron wavelength at 300 kV: {lambda_A:.5f} √Ö")
print(f"Scherzer Focus: {scherzer_defocus_nm:.1f} nm")
print(f"First zero crossing spatial frequency: {k_first_zero:.3f} 1/√Ö")
print(f"Point resolution: {resolution_A:.3f} √Ö")
</code></pre>
</details>
<h3>Exercise 3-2: SAED Indexing</h3>
<p><strong>Problem</strong>: For a Cu FCC specimen (a = 3.61 √Ö) [011] zone axis SAED pattern, the 200 reflection spot was 15 mm away from the center. Determine the camera constant ŒªL (accelerating voltage 200 kV).</p>
<details>
<summary><strong>Show Answer</strong></summary>
<pre><code class="language-python">import numpy as np

# Given data
a = 3.61  # [√Ö]
h, k, l = 2, 0, 0
R_mm = 15  # [mm]

# Interplanar spacing
d_200 = a / np.sqrt(h**2 + k**2 + l**2)

# Camera constant ŒªL = R * d
# Convert d to pm
d_pm = d_200 * 100
lambda_L = R_mm * d_pm

print(f"Cu (200) plane interplanar spacing: {d_200:.3f} √Ö = {d_pm:.1f} pm")
print(f"Camera constant ŒªL: {lambda_L:.1f} pm¬∑mm")

# Verification: Theoretical value at 200 kV
m0 = 9.10938e-31
e = 1.60218e-19
c = 2.99792e8
h_planck = 6.62607e-34
E = 200 * 1000 * e
lambda_m = h_planck / np.sqrt(2 * m0 * E * (1 + E / (2 * m0 * c**2)))
lambda_pm = lambda_m * 1e12

# Assuming camera length 500 mm
L_mm = lambda_L / lambda_pm
print(f"Estimated camera length: {L_mm:.0f} mm")
</code></pre>
</details>
<h3>Exercise 3-3: FFT Analysis</h3>
<p><strong>Problem</strong>: In an FFT pattern of an HRTEM image, the nearest symmetrical spots from the center are 3.5 1/√Ö apart. Determine the interplanar spacing of the corresponding lattice planes.</p>
<details>
<summary><strong>Show Answer</strong></summary>
<pre><code class="language-python">k = 3.5  # [1/√Ö] (FFT pattern spot position)

# Interplanar spacing d = 1/k
d = 1 / k

print(f"FFT spot spatial frequency: {k} 1/√Ö")
print(f"Corresponding interplanar spacing: {d:.3f} √Ö")
print(f"This could correspond to, for example, Si (111) plane (d = 3.14 √Ö) or Al (111) plane (d = 2.34 √Ö)")
</code></pre>
</details>
<h3>Exercise 3-4: Dark Field Image Application</h3>
<p><strong>Problem</strong>: You want to observe Al<sub>2</sub>Cu precipitates (Œ∏' phase) in an Al alloy using dark field imaging. Explain the strategy for selecting the appropriate diffraction spot.</p>
<details>
<summary><strong>Show Answer</strong></summary>
<p><strong>Strategy</strong>:</p>
<ol>
<li>First, tilt the specimen to a low-index zone axis such as [001]_Al</li>
<li>Obtain SAED pattern and identify diffraction spots from the Al matrix and Œ∏' phase</li>
<li>Select <strong>diffraction spots unique to the Œ∏' phase</strong> (indices not present in Al)</li>
<li>Examples: (002) or (100) reflections of the Œ∏' phase</li>
<li>Take dark field image with that spot ‚Üí Only Œ∏' precipitates will appear bright</li>
<li>Using the Centered Dark Field (CDF) method will provide higher resolution images</li>
</ol>
</details>
<h3>Exercise 3-5: Understanding Multi-Beam Interference</h3>
<p><strong>Problem</strong>: Explain the differences between two-beam interference (transmitted beam + one diffracted beam) and multi-beam interference (transmitted beam + multiple diffracted beams) from a CTF perspective.</p>
<details>
<summary><strong>Show Answer</strong></summary>
<p><strong>Answer</strong>:</p>
<ul>
<li><strong>Two-beam interference</strong>: Only one spatial frequency component interferes. CTF is evaluated at that single point. Observed as lattice fringes, but details of atomic arrangement are not visible</li>
<li><strong>Multi-beam interference</strong>: Many spatial frequency components interfere simultaneously. A wide range of CTF contributes to image formation. HRTEM images reflecting atomic arrangements are obtained</li>
<li><strong>Role of CTF</strong>: Determines how much each spatial frequency component contributes to the image. With aberration correction achieving constant-sign CTF over a wide frequency range, more faithful atomic arrangement images can be obtained</li>
</ul>
</details>
<h3>Exercise 3-6: Effects of Aberration Correction</h3>
<p><strong>Problem</strong>: Compare the point resolution of a 300 kV TEM before aberration correction (Cs = 1.0 mm) and after (Cs ‚âà 0.001 mm).</p>
<details>
<summary><strong>Show Answer</strong></summary>
<pre><code class="language-python">import numpy as np

voltage_kV = 300

# Electron wavelength
m0 = 9.10938e-31
e = 1.60218e-19
c = 2.99792e8
h = 6.62607e-34
E = voltage_kV * 1000 * e
lambda_m = h / np.sqrt(2 * m0 * E * (1 + E / (2 * m0 * c**2)))
lambda_A = lambda_m * 1e10

# Before aberration correction
Cs_uncorrected_mm = 1.0
Cs_uncorrected_A = Cs_uncorrected_mm * 1e7
k_limit_uncorrected = 1.5 / (Cs_uncorrected_A**0.25 * lambda_A**0.75)
resolution_uncorrected = 1 / k_limit_uncorrected

# After aberration correction
Cs_corrected_mm = 0.001
Cs_corrected_A = Cs_corrected_mm * 1e7
k_limit_corrected = 1.5 / (Cs_corrected_A**0.25 * lambda_A**0.75)
resolution_corrected = 1 / k_limit_corrected

print(f"Electron wavelength at 300 kV: {lambda_A:.5f} √Ö")
print(f"\nBefore aberration correction (Cs = {Cs_uncorrected_mm} mm):")
print(f"  Point resolution: {resolution_uncorrected:.3f} √Ö")
print(f"\nAfter aberration correction (Cs = {Cs_corrected_mm} mm):")
print(f"  Point resolution: {resolution_corrected:.3f} √Ö")
print(f"\nResolution improvement: {resolution_uncorrected / resolution_corrected:.1f}√ó")
</code></pre>
</details>
<h3>Exercise 3-7: Practical HRTEM Analysis</h3>
<p><strong>Problem</strong>: Calculate the FFT of a given HRTEM image (512√ó512 pixels, pixel size 0.05 √Ö/pixel) and extract the interplanar spacings of three major lattice planes.</p>
<details>
<summary><strong>Show Answer</strong></summary>
<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
from scipy.fft import fft2, fftshift
from scipy.ndimage import gaussian_filter

# Generate dummy HRTEM image (replace with actual data)
size = 512
pixel_size = 0.05  # [√Ö/pixel]

# Simulate crystal with three lattice planes
x = np.arange(size) * pixel_size
y = np.arange(size) * pixel_size
X, Y = np.meshgrid(x, y)

# Lattice plane 1: d1 = 3.5 √Ö
d1 = 3.5
image = 0.5 + 0.2 * np.cos(2*np.pi * X / d1)

# Lattice plane 2: d2 = 2.0 √Ö
d2 = 2.0
image += 0.15 * np.cos(2*np.pi * (X + Y) / (d2 * np.sqrt(2)))

# Lattice plane 3: d3 = 1.5 √Ö
d3 = 1.5
image += 0.1 * np.cos(2*np.pi * Y / d3)

# Add noise
image += np.random.normal(0, 0.05, image.shape)
image = gaussian_filter(image, sigma=0.5)

# FFT calculation
fft_image = fftshift(fft2(image))
fft_magnitude = np.abs(fft_image)
fft_magnitude_log = np.log(1 + fft_magnitude)

# Frequency axis
freq = np.fft.fftshift(np.fft.fftfreq(size, d=pixel_size))

# FFT peak detection (simplified: manually extract three major peaks from center)
center = size // 2
# In actual analysis, use scipy.signal.find_peaks, etc.

print("FFT analysis results (simulated data):")
print(f"  Peak 1: k ‚âà {1/d1:.3f} 1/√Ö ‚Üí d ‚âà {d1:.2f} √Ö")
print(f"  Peak 2: k ‚âà {1/d2:.3f} 1/√Ö ‚Üí d ‚âà {d2:.2f} √Ö")
print(f"  Peak 3: k ‚âà {1/d3:.3f} 1/√Ö ‚Üí d ‚âà {d3:.2f} √Ö")

# Visualization
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 6))

ax1.imshow(image, cmap='gray')
ax1.set_title('HRTEM Image', fontsize=13, fontweight='bold')
ax1.axis('off')

ax2.imshow(fft_magnitude_log, cmap='hot', extent=[freq.min(), freq.max(), freq.min(), freq.max()])
ax2.set_title('FFT Pattern (Log Scale)', fontsize=13, fontweight='bold')
ax2.set_xlabel('$k_x$ [1/√Ö]', fontsize=11)
ax2.set_ylabel('$k_y$ [1/√Ö]', fontsize=11)
ax2.set_xlim(-2, 2)
ax2.set_ylim(-2, 2)

plt.tight_layout()
plt.show()
</code></pre>
</details>
<h3>Exercise 3-8: Experimental Planning</h3>
<p><strong>Problem</strong>: Plan an experiment to analyze an unknown crystalline specimen using TEM. Explain in what order to acquire bright field images, dark field images, SAED, and HRTEM, and what to investigate with each.</p>
<details>
<summary><strong>Show Answer</strong></summary>
<p><strong>Experimental Plan</strong>:</p>
<ol>
<li><strong>Low magnification bright field image</strong>: Understand overall specimen morphology, thickness, and crystal grain size</li>
<li><strong>SAED (wide area)</strong>: Determine if polycrystalline or single crystal. For polycrystalline, obtain Debye rings</li>
<li><strong>Specimen tilt and SAED</strong>: Search for low-index zone axes ([001], [011], [111], etc.). Estimate lattice constant and crystal system from Debye ring analysis</li>
<li><strong>SAED (selected area)</strong>: Obtain SAED pattern from specific grains and index. Identify crystal structure</li>
<li><strong>Dark field image</strong>: Take dark field image with specific diffraction spot. Observe distribution of crystal grains, twins, and precipitates</li>
<li><strong>HRTEM</strong>: Obtain high-resolution images and precisely measure interplanar spacings through lattice imaging and FFT analysis. Observe defects (dislocations, stacking faults)</li>
<li><strong>Data integration</strong>: Integrate results from SAED, HRTEM, and dark field images to comprehensively analyze crystal structure, orientation, and defects</li>
</ol>
</details>
<h2>3.6 Learning Check</h2>
<p>Confirm your understanding by answering the following questions:</p>
<ol>
<li>Can you explain the roles of the back focal plane (BFP) and image plane in TEM imaging?</li>
<li>Can you describe the differences between bright field and dark field images and provide application examples for each?</li>
<li>Do you understand the physical meaning of the Contrast Transfer Function (CTF)?</li>
<li>Can you explain the purpose of Scherzer focus and how to calculate it?</li>
<li>Can you explain the procedure for determining lattice constants from SAED patterns?</li>
<li>Can you explain diffraction conditions using the Ewald sphere construction?</li>
<li>Can you explain what can be determined from FFT analysis of HRTEM images?</li>
<li>Do you understand the effects of aberration correction techniques and their impact on resolution?</li>
</ol>
<h2>3.7 References</h2>
<ol>
<li>Williams, D. B., &amp; Carter, C. B. (2009). <em>Transmission Electron Microscopy: A Textbook for Materials Science</em> (2nd ed.). Springer. - The definitive TEM textbook</li>
<li>Kirkland, E. J. (2020). <em>Advanced Computing in Electron Microscopy</em> (3rd ed.). Springer. - HRTEM image simulation and FFT analysis</li>
<li>Pennycook, S. J., &amp; Nellist, P. D. (Eds.). (2011). <em>Scanning Transmission Electron Microscopy: Imaging and Analysis</em>. Springer. - STEM techniques (detailed in next chapter)</li>
<li>Spence, J. C. H. (2013). <em>High-Resolution Electron Microscopy</em> (4th ed.). Oxford University Press. - Details of HRTEM theory</li>
<li>Hawkes, P. W., &amp; Spence, J. C. H. (Eds.). (2019). <em>Springer Handbook of Microscopy</em>. Springer. - Comprehensive handbook on electron microscopy techniques</li>
<li>Reimer, L., &amp; Kohl, H. (2008). <em>Transmission Electron Microscopy: Physics of Image Formation</em> (5th ed.). Springer. - Details of TEM imaging theory</li>
<li>Haider, M., et al. (1998). "Electron microscopy image enhanced." <em>Nature</em>, 392, 768‚Äì769. - Breakthrough paper on aberration correction technology</li>
</ol>
<h2>3.8 Next Chapter</h2>
<p>In the next chapter, we will learn the principles of Scanning Transmission Electron Microscopy (STEM), Z-contrast imaging (HAADF-STEM), Electron Energy Loss Spectroscopy (EELS), atomic resolution analysis, and fundamentals and applications of tomography. STEM is a powerful technique that can simultaneously detect various signals by scanning a convergent electron beam across the specimen.</p>
<div class="navigation">
<a class="nav-button" href="chapter-2.html">‚Üê Chapter 2: SEM Introduction</a>
<a class="nav-button" href="index.html">Return to Table of Contents</a>
<a class="nav-button" href="chapter-4.html">Chapter 4: STEM and Analytical Techniques ‚Üí</a>
</div>
</main>
<section class="disclaimer">
<h3>Disclaimer</h3>
<ul>
<li>This content is provided solely for educational, research, and informational purposes and does not constitute professional advice (legal, accounting, technical guarantees, etc.).</li>
<li>This content and accompanying code examples are provided "AS IS" without any warranties, express or implied, including but not limited to merchantability, fitness for a particular purpose, non-infringement, accuracy, completeness, operation, or safety.</li>
<li>The authors and Tohoku University assume no responsibility for the content, availability, or safety of external links, third-party data, tools, or libraries.</li>
<li>To the maximum extent permitted by applicable law, the authors and Tohoku University shall not be liable for any direct, indirect, incidental, special, consequential, or punitive damages arising from the use, execution, or interpretation of this content.</li>
<li>The content of this material may be changed, updated, or discontinued without notice.</li>
<li>The copyright and license of this content follow the specified conditions (e.g., CC BY 4.0). Such licenses typically include no-warranty clauses.</li>
</ul>
</section>
<footer>
<p><strong>Created by</strong>: MS Knowledge Hub Content Team</p>
<p><strong>Version</strong>: 1.0 | <strong>Created</strong>: 2025-10-28</p>
<p><strong>License</strong>: Creative Commons BY 4.0</p>
<p>¬© 2025 MS Terakoya. All rights reserved.</p>
</footer>
</body>
</html>
