<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Chapter 2: Heat Treatment Processes - MS Terakoya</title>
<style>
        :root {
            --color-primary: #2c3e50;
            --color-primary-dark: #1a252f;
            --color-accent: #f093fb;
            --color-accent-light: #f5576c;
            --color-text: #2d3748;
            --color-text-light: #4a5568;
            --color-bg: #ffffff;
            --color-bg-alt: #f7fafc;
            --color-border: #e2e8f0;
            --color-code-bg: #f8f9fa;
            --color-link: #f093fb;
            --color-link-hover: #d07be8;

            --spacing-xs: 0.5rem;
            --spacing-sm: 1rem;
            --spacing-md: 1.5rem;
            --spacing-lg: 2rem;
            --spacing-xl: 3rem;

            --font-body: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            --font-mono: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;

            --border-radius: 8px;
            --box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-body);
            line-height: 1.7;
            color: var(--color-text);
            background-color: var(--color-bg);
            font-size: 16px;
        }

        header {
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            color: white;
            padding: var(--spacing-xl) var(--spacing-md);
            margin-bottom: var(--spacing-xl);
            box-shadow: var(--box-shadow);
        }

        .header-content {
            max-width: 900px;
            margin: 0 auto;
        }

        h1 {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: var(--spacing-sm);
            line-height: 1.2;
        }

        .subtitle {
            font-size: 1.1rem;
            opacity: 0.95;
            font-weight: 400;
            margin-bottom: var(--spacing-md);
        }

        .meta {
            display: flex;
            flex-wrap: wrap;
            gap: var(--spacing-md);
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .meta-item {
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 0 var(--spacing-md) var(--spacing-xl);
        }

        h2 {
            font-size: 1.75rem;
            color: var(--color-primary);
            margin-top: var(--spacing-xl);
            margin-bottom: var(--spacing-md);
            padding-bottom: var(--spacing-xs);
            border-bottom: 3px solid var(--color-accent);
        }

        h3 {
            font-size: 1.4rem;
            color: var(--color-primary);
            margin-top: var(--spacing-lg);
            margin-bottom: var(--spacing-sm);
        }

        h4 {
            font-size: 1.1rem;
            color: var(--color-primary-dark);
            margin-top: var(--spacing-md);
            margin-bottom: var(--spacing-sm);
        }

        p {
            margin-bottom: var(--spacing-md);
            color: var(--color-text);
        }

        a {
            color: var(--color-link);
            text-decoration: none;
            transition: color 0.2s;
        }

        a:hover {
            color: var(--color-link-hover);
            text-decoration: underline;
        }

        ul, ol {
            margin-left: var(--spacing-lg);
            margin-bottom: var(--spacing-md);
        }

        li {
            margin-bottom: var(--spacing-xs);
            color: var(--color-text);
        }

        pre {
            background-color: var(--color-code-bg);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            overflow-x: auto;
            margin-bottom: var(--spacing-md);
            font-family: var(--font-mono);
            font-size: 0.9rem;
            line-height: 1.5;
        }

        code {
            font-family: var(--font-mono);
            font-size: 0.9em;
            background-color: var(--color-code-bg);
            padding: 0.2em 0.4em;
            border-radius: 3px;
        }

        pre code {
            background-color: transparent;
            padding: 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: var(--spacing-md);
            font-size: 0.95rem;
        }

        th, td {
            border: 1px solid var(--color-border);
            padding: var(--spacing-sm);
            text-align: left;
        }

        th {
            background-color: var(--color-bg-alt);
            font-weight: 600;
            color: var(--color-primary);
        }

        blockquote {
            border-left: 4px solid var(--color-accent);
            padding-left: var(--spacing-md);
            margin: var(--spacing-md) 0;
            color: var(--color-text-light);
            font-style: italic;
            background-color: var(--color-bg-alt);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        .mermaid {
            text-align: center;
            margin: var(--spacing-lg) 0;
            background-color: var(--color-bg-alt);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        .learning-objectives {
            background: linear-gradient(135deg, #fce7f3 0%, #fbcfe8 100%);
            padding: var(--spacing-lg);
            border-radius: var(--border-radius);
            border-left: 4px solid var(--color-accent);
            margin-bottom: var(--spacing-xl);
        }

        .learning-objectives h2 {
            margin-top: 0;
            border-bottom: none;
        }

        .exercise-box {
            background-color: #fff7ed;
            border-left: 4px solid #fb923c;
            padding: var(--spacing-md);
            margin-bottom: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        .exercise-box h4 {
            color: #c2410c;
            margin-top: 0;
        }

        .solution-box {
            background-color: #f0fdf4;
            border-left: 4px solid #22c55e;
            padding: var(--spacing-md);
            margin-top: var(--spacing-sm);
            border-radius: var(--border-radius);
        }

        .solution-box summary {
            cursor: pointer;
            font-weight: 600;
            color: #15803d;
            margin-bottom: var(--spacing-sm);
        }

        .breadcrumb {
            max-width: 900px;
            margin: 0 auto;
            padding: var(--spacing-sm) var(--spacing-md);
            font-size: 0.9rem;
            color: var(--color-text-light);
        }

        .breadcrumb a {
            color: var(--color-link);
            text-decoration: none;
        }

        .breadcrumb a:hover {
            text-decoration: underline;
        }

        .navigation {
            display: flex;
            justify-content: space-between;
            gap: var(--spacing-md);
            margin: var(--spacing-xl) 0;
            padding-top: var(--spacing-lg);
            border-top: 2px solid var(--color-border);
        }

        .nav-button {
            flex: 1;
            padding: var(--spacing-md);
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            color: white;
            border-radius: var(--border-radius);
            text-align: center;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: var(--box-shadow);
        }

        .nav-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            text-decoration: none;
        }

        footer {
            margin-top: var(--spacing-xl);
            padding: var(--spacing-lg) var(--spacing-md);
            background-color: var(--color-bg-alt);
            border-top: 1px solid var(--color-border);
            text-align: center;
            font-size: 0.9rem;
            color: var(--color-text-light);
        }

        .disclaimer {
            max-width: 900px;
            margin: 2rem auto;
            padding: 1.5rem;
            background: #f8f9fa;
            border-left: 4px solid #6c757d;
            border-radius: 4px;
        }

        .disclaimer h3 {
            color: #495057;
            margin-bottom: 1rem;
            font-size: 1.1rem;
        }

        .disclaimer ul {
            list-style: none;
            padding-left: 0;
        }

        .disclaimer li {
            padding: 0.5rem 0;
            padding-left: 1.5rem;
            position: relative;
            font-size: 0.9rem;
            color: #6c757d;
            line-height: 1.6;
        }

        .disclaimer li::before {
            content: "Â ";
            position: absolute;
            left: 0;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.5rem;
            }

            h2 {
                font-size: 1.4rem;
            }

            h3 {
                font-size: 1.2rem;
            }

            .meta {
                font-size: 0.85rem;
            }

            .navigation {
                flex-direction: column;
            }

            table {
                font-size: 0.85rem;
            }

            th, td {
                padding: var(--spacing-xs);
            }
        }
    </style>
<!-- Prism.js for syntax highlighting -->
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet"/>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
<script>
        mermaid.initialize({ startOnLoad: true, theme: 'default', securityLevel: 'strict' });
    </script>
<script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true,
                processEnvironments: true
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
                ignoreHtmlClass: 'mermaid'
            }
        };
    </script>
<script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
<header>
<div class="header-content">
<h1>Chapter 2: Heat Treatment Processes</h1>
<p class="subtitle">Annealing, Quenching &amp; Tempering, Age Hardening, TTT/CCT Diagrams</p>
<div class="meta">
<span class="meta-item">=Ã– Reading Time: 40-50 min</span>
<span class="meta-item">=ÃŠ Difficulty: Intermediate</span>
<span class="meta-item">=Â» Code Examples: 7</span>
</div>
</div>
</header>
<div class="breadcrumb">
<a href="../index.html">AI Terakoya Top</a> &gt;
        <a href="../index.html">MS Dojo</a> &gt;
        <a href="index.html">Introduction to Processing Technology</a> &gt;
        Chapter 2
    </div>
<main class="container">
<p class="chapter-description" style="margin: 1.5rem 0; padding: 1rem; background: linear-gradient(135deg, #fce7f3 0%, #fbcfe8 100%); border-left: 4px solid #f093fb; border-radius: 8px; font-size: 1.05rem; line-height: 1.8; color: #2d3748;">
            Heat treatment processes are core technologies for controlling mechanical properties (strength, hardness, toughness) of materials. By controlling phase transformation, diffusion, and precipitation through temperature history of heating, holding, and cooling, target properties are achieved. This chapter covers learning the principles of annealing, quenching and tempering, and age hardening through Python simulations, and mastering practical heat treatment design using TTT/CCT diagrams.
        </p>
<div class="learning-objectives">
<h2>Learning Objectives</h2>
<p>By completing this chapter, you will be able to:</p>
<ul>
<li> Understand the types of annealing (full annealing, stress relief annealing, recrystallization) and their effects</li>
<li> Explain the relationship between quenching cooling rate and microstructure (martensite, bainite)</li>
<li> Conduct hardenability evaluation using the Jominy test</li>
<li> Understand hardness and toughness balance design through tempering</li>
<li> Understand precipitation strengthening mechanism in age hardening</li>
<li> Design heat treatments using TTT (Time-Temperature-Transformation) and CCT diagrams</li>
<li> Simulate diffusion equations, grain growth, and precipitation strengthening in Python</li>
</ul>
</div>
<h2>2.1 Annealing Process</h2>
<h3>2.1.1 Types and Purposes of Annealing</h3>
<p>Annealing involves heating material to high temperature, holding, and slow cooling to achieve the following effects:</p>
<table>
<thead>
<tr>
<th>Annealing Type</th>
<th>Purpose</th>
<th>Temperature Range</th>
<th>Microstructural Change</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Full Annealing</strong></td>
<td>Softening, improved workability</td>
<td>AcÆ’ + 30-50Â°C</td>
<td>Ferrite + Pearlite</td>
</tr>
<tr>
<td><strong>Stress Relief Annealing</strong></td>
<td>Residual stress removal</td>
<td>500-650Â°C</td>
<td>No microstructural change</td>
</tr>
<tr>
<td><strong>Recrystallization Annealing</strong></td>
<td>Work hardening removal, grain refinement</td>
<td>500-700Â°C</td>
<td>New grain formation</td>
</tr>
<tr>
<td><strong>Spheroidizing Annealing</strong></td>
<td>Carbide spheroidization, improved machinability</td>
<td>Near Acï¿½, long duration</td>
<td>Spheroidal cementite</td>
</tr>
</tbody>
</table>
<h3>2.1.2 Diffusion-Controlled Process and Holding Time</h3>
<p>In annealing, atomic diffusion is the key to microstructural homogenization. According to <strong>Fick's Second Law</strong>, diffusion distance is proportional to the square root of time:</p>

        $$
        x = \sqrt{D t}
        $$

        <ul>
<li>$x$: Diffusion distance (m)</li>
<li>$D$: Diffusion coefficient (mÂ²/s)</li>
<li>$t$: Time (s)</li>
</ul>
<p><strong>Arrhenius equation</strong> (temperature dependence):</p>
        $$
        D = D_0 \exp\left(-\frac{Q}{RT}\right)
        $$

        <ul>
<li>$D_0$: Frequency factor (mÂ²/s)</li>
<li>$Q$: Activation energy (J/mol)</li>
<li>$R$: Gas constant (8.314 J/molÂ·K)</li>
<li>$T$: Absolute temperature (K)</li>
</ul>
<h4>Code Example 2-1: Calculating Diffusion Distance and Holding Time</h4>
<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt

def arrhenius_diffusion_coefficient(T_celsius, Q, D0):
    """
    Diffusion coefficient calculation using Arrhenius equation

    Parameters
    ----------
    T_celsius : float
        Temperature (Â°C)
    Q : float
        Activation energy (J/mol)
    D0 : float
        Frequency factor (mÂ²/s)

    Returns
    -------
    D : float
        Diffusion coefficient (mÂ²/s)
    """
    R = 8.314  # J/molÂ·K
    T_kelvin = T_celsius + 273.15

    D = D0 * np.exp(-Q / (R * T_kelvin))

    return D


def diffusion_distance(D, time):
    """
    Diffusion distance calculation

    Parameters
    ----------
    D : float
        Diffusion coefficient (mÂ²/s)
    time : float
        Time (seconds)

    Returns
    -------
    x : float
        Diffusion distance (m)
    """
    x = np.sqrt(D * time)
    return x


# Carbon diffusion in iron (typical values)
Q_C_in_Fe = 142000  # J/mol
D0_C_in_Fe = 2.0e-5  # mÂ²/s

# Simulation over temperature range
temperatures = np.array([700, 800, 900, 1000])  # Â°C
time_hours = np.linspace(0, 10, 100)  # Time (hours)
time_seconds = time_hours * 3600

plt.figure(figsize=(12, 6))

for T in temperatures:
    D = arrhenius_diffusion_coefficient(T, Q_C_in_Fe, D0_C_in_Fe)
    distances = [diffusion_distance(D, t) * 1e6 for t in time_seconds]  # Â¼m

    plt.plot(time_hours, distances, linewidth=2, label=f'{T}Â°C')

    # Estimate holding time (reaching diffusion distance of 100 Â¼m)
    target_distance = 100e-6  # m
    required_time = (target_distance ** 2) / D / 3600  # hours
    print(f"Temperature: {T}Â°C")
    print(f"  Diffusion Coefficient: {D:.2e} mÂ²/s")
    print(f"  Time to diffuse 100 Â¼m: {required_time:.2f} hours\n")

plt.xlabel('Time (hours)')
plt.ylabel('Diffusion Distance (Â¼m)')
plt.title('Carbon Diffusion in Iron (Annealing Process)')
plt.legend()
plt.grid(True, alpha=0.3)
plt.savefig('diffusion_annealing.png', dpi=150, bbox_inches='tight')
plt.show()

# Results:
# 700Â°C to diffuse 100 Â¼m â€™ approximately 10 hours needed
# 1000Â°C to diffuse 100 Â¼m â€™ approximately 0.5 hours (30 minutes)
# â€™ Higher temperature enables homogenization in shorter time</code></pre>
<h3>2.1.3 Recrystallization and Grain Growth</h3>
<p>During annealing after cold working, <strong>recrystallization</strong> (nucleation and growth of new grains) and <strong>grain growth</strong> (grain boundary migration) occur.</p>
<p><strong>Beck-Spaepen grain growth law</strong>:</p>
        $$
        d^n - d_0^n = K t
        $$

        <ul>
<li>$d$: Average grain size (at time $t$)</li>
<li>$d_0$: Initial grain size</li>
<li>$n$: Growth exponent (typically 2-3)</li>
<li>$K$: Temperature-dependent constant</li>
</ul>
<h4>Code Example 2-2: Grain Growth Simulation</h4>
<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt

def grain_growth(d0, K, time, n=2):
    """
    Beck-Spaepen grain growth model

    Parameters
    ----------
    d0 : float
        Initial grain size (Â¼m)
    K : float
        Growth constant (Â¼m^n / s)
    time : ndarray
        Time (seconds)
    n : int
        Growth exponent (default 2)

    Returns
    -------
    d : ndarray
        Grain size history (Â¼m)
    """
    d = (d0 ** n + K * time) ** (1 / n)
    return d


# Parameter settings
d0 = 10  # Â¼m (initial grain size)
K = 0.5  # Â¼mÂ²/s (growth constant at 800Â°C)
time_hours = np.linspace(0, 10, 100)
time_seconds = time_hours * 3600

# Grain growth calculation
grain_size = grain_growth(d0, K, time_seconds, n=2)

# Plot
plt.figure(figsize=(10, 6))
plt.plot(time_hours, grain_size, 'b-', linewidth=2)
plt.xlabel('Annealing Time (hours)')
plt.ylabel('Average Grain Size (Â¼m)')
plt.title('Grain Growth during Annealing (800Â°C)')
plt.grid(True, alpha=0.3)
plt.axhline(y=50, color='r', linestyle='--', label='Target: 50 Â¼m')
plt.legend()
plt.savefig('grain_growth.png', dpi=150, bbox_inches='tight')
plt.show()

# Calculate time to reach target grain size (50 Â¼m)
target_size = 50  # Â¼m
required_time = ((target_size ** 2) - (d0 ** 2)) / K
required_hours = required_time / 3600

print(f"Grain Growth Analysis:")
print(f"  Initial Grain Size: {d0} Â¼m")
print(f"  Target Grain Size: {target_size} Â¼m")
print(f"  Required Annealing Time: {required_hours:.2f} hours")
print(f"  Final Grain Size after 10h: {grain_size[-1]:.1f} Â¼m")</code></pre>
<h2>2.2 Quenching and Tempering</h2>
<h3>2.2.1 Quenching and Martensitic Transformation</h3>
<p>Quenching involves rapid cooling from austenite (Â³ phase) to produce <strong>martensite</strong> (supersaturated solid solution). Martensite has high hardness but high brittleness, so it is adjusted through tempering.</p>
<table>
<thead>
<tr>
<th>Cooling Rate</th>
<th>Quenching Medium</th>
<th>Resulting Microstructure</th>
<th>Hardness (HV)</th>
</tr>
</thead>
<tbody>
<tr>
<td>&gt;200 Â°C/s</td>
<td>Water, brine</td>
<td>Martensite</td>
<td>600-800</td>
</tr>
<tr>
<td>50-200 Â°C/s</td>
<td>Oil</td>
<td>Martensite + Bainite</td>
<td>500-700</td>
</tr>
<tr>
<td>10-50 Â°C/s</td>
<td>Air cooling</td>
<td>Bainite</td>
<td>400-600</td>
</tr>
<tr>
<td>&lt;10 Â°C/s</td>
<td>Furnace cooling</td>
<td>Pearlite</td>
<td>200-400</td>
</tr>
</tbody>
</table>
<p><strong>Newton's law of cooling</strong> (simplified model):</p>
        $$
        \frac{dT}{dt} = -h (T - T_{\text{medium}})
        $$

        <ul>
<li>$h$: Cooling coefficient (1/s)</li>
<li>$T_{\text{medium}}$: Quenching medium temperature</li>
</ul>
<h4>Code Example 2-3: Quenching Cooling Curve Simulation</h4>
<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt

def quenching_cooling_curve(T0, T_medium, h, time):
    """
    Cooling curve using Newton's law of cooling

    Parameters
    ----------
    T0 : float
        Initial temperature (Â°C)
    T_medium : float
        Quenching medium temperature (Â°C)
    h : float
        Cooling coefficient (1/s)
    time : ndarray
        Time (seconds)

    Returns
    -------
    T : ndarray
        Temperature history (Â°C)
    """
    T = T_medium + (T0 - T_medium) * np.exp(-h * time)
    return T


# Cooling condition settings
T_austenitize = 850  # Â°C (austenitizing temperature)
time = np.linspace(0, 60, 500)  # seconds

quenching_conditions = [
    {'name': 'Water Quench', 'T_med': 25, 'h': 0.3, 'color': 'blue'},
    {'name': 'Oil Quench', 'T_med': 60, 'h': 0.1, 'color': 'orange'},
    {'name': 'Air Cool', 'T_med': 25, 'h': 0.02, 'color': 'green'},
    {'name': 'Furnace Cool', 'T_med': 25, 'h': 0.005, 'color': 'red'}
]

plt.figure(figsize=(12, 8))

# Martensite start temperature (Ms) and bainite range
Ms_temp = 350  # Â°C
Bs_temp = 550  # Â°C

plt.axhline(y=Ms_temp, color='purple', linestyle='--', linewidth=2,
            label=f'Ms (Martensite Start): {Ms_temp}Â°C')
plt.axhspan(Bs_temp, Ms_temp, alpha=0.2, color='cyan',
            label='Bainite Range')

for cond in quenching_conditions:
    T_curve = quenching_cooling_curve(
        T_austenitize, cond['T_med'], cond['h'], time
    )
    plt.plot(time, T_curve, linewidth=2.5,
             color=cond['color'], label=cond['name'])

    # Cooling rate calculation (average from 800Â°C to 500Â°C)
    idx_800 = np.argmin(np.abs(T_curve - 800))
    idx_500 = np.argmin(np.abs(T_curve - 500))
    cooling_rate = (T_curve[idx_800] - T_curve[idx_500]) / (time[idx_500] - time[idx_800])

    print(f"{cond['name']}:")
    print(f"  Cooling Rate (800â€™500Â°C): {cooling_rate:.1f} Â°C/s")
    print(f"  Time to Ms ({Ms_temp}Â°C): {time[np.argmin(np.abs(T_curve - Ms_temp))]:.1f} s\n")

plt.xlabel('Time (s)')
plt.ylabel('Temperature (Â°C)')
plt.title('Quenching Cooling Curves and Microstructure Formation')
plt.legend(loc='upper right')
plt.grid(True, alpha=0.3)
plt.xlim(0, 60)
plt.ylim(0, 900)
plt.savefig('quenching_curves.png', dpi=150, bbox_inches='tight')
plt.show()</code></pre>
<h3>2.2.2 Jominy Hardenability Test</h3>
<p>The <strong>Jominy test</strong> is a standard test method for evaluating hardenability of steel. One end is water-cooled, and hardness distribution is measured due to the cooling rate gradient.</p>
<div class="mermaid">
flowchart LR
    A[Austenitizing<br/>850Â°C, 30 min] --&gt; B[Hold specimen<br/>Water cool one end only]
    B --&gt; C[Cooling rate gradient<br/>End: Fast<br/>Interior: Slow]
    C --&gt; D[Hardness measurement<br/>Distance from end vs HRC]
    D --&gt; E[Hardenability evaluation<br/>Gradual hardness drop = High]

    style A fill:#f093fb,stroke:#f5576c,stroke-width:2px,color:#fff
    style E fill:#f093fb,stroke:#f5576c,stroke-width:2px,color:#fff
        </div>
<h4>Code Example 2-4: Jominy Hardenability Curve Simulation</h4>
<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt

def jominy_hardness_profile(distance_mm, HRC_max, DI, steel_type='Low Alloy'):
    """
    Jominy hardenability curve model

    Parameters
    ----------
    distance_mm : ndarray
        Distance from quenched end (mm)
    HRC_max : float
        Maximum hardness (HRC)
    DI : float
        Ideal Diameter (hardenability index)
    steel_type : str
        Steel grade

    Returns
    -------
    hardness : ndarray
        Hardness distribution (HRC)
    """
    # Grossmann hardenability model (simplified)
    # HRC = HRC_max * exp(-k * distance)
    k = 0.1 / DI  # Decay constant

    hardness = HRC_max * np.exp(-k * distance_mm)

    # Minimum hardness (ferrite + pearlite microstructure)
    HRC_min = 20
    hardness = np.maximum(hardness, HRC_min)

    return hardness


# Comparison of 3 steel types
distance = np.linspace(0, 50, 100)  # mm

steels = [
    {'name': 'S45C (Plain Carbon)', 'HRC_max': 62, 'DI': 10},
    {'name': 'SCM440 (Cr-Mo)', 'HRC_max': 60, 'DI': 30},
    {'name': 'SNC815 (Ni-Cr)', 'HRC_max': 58, 'DI': 50}
]

plt.figure(figsize=(12, 7))

for steel in steels:
    hardness = jominy_hardness_profile(distance, steel['HRC_max'], steel['DI'])
    plt.plot(distance, hardness, linewidth=2.5, label=steel['name'])

    # Hardenability evaluation (distance where hardness drops to HRC 50)
    idx_hrc50 = np.argmin(np.abs(hardness - 50))
    distance_hrc50 = distance[idx_hrc50]

    print(f"{steel['name']}:")
    print(f"  Maximum Hardness: {steel['HRC_max']} HRC")
    print(f"  Ideal Diameter (DI): {steel['DI']} mm")
    print(f"  Distance to HRC 50: {distance_hrc50:.1f} mm\n")

plt.axhline(y=50, color='k', linestyle='--', alpha=0.5, label='Target: HRC 50')
plt.xlabel('Distance from Quenched End (mm)')
plt.ylabel('Hardness (HRC)')
plt.title('Jominy Hardenability Test: Steel Comparison')
plt.legend()
plt.grid(True, alpha=0.3)
plt.savefig('jominy_hardenability.png', dpi=150, bbox_inches='tight')
plt.show()

# Result interpretation:
# - Plain Carbon (S45C): Low hardenability, only surface hardening
# - Cr-Mo (SCM440): Moderate hardenability
# - Ni-Cr (SNC815): High hardenability, hardening to deep sections</code></pre>
<h3>2.2.3 Tempering and Hardness Control</h3>
<p><strong>Tempering</strong> involves reheating quenched martensite at appropriate temperature to adjust the balance between hardness and toughness.</p>
<p><strong>Hollomon-Jaffe equation</strong> (tempering parameter):</p>
        $$
        P = T (C + \log_{10} t) \times 10^{-3}
        $$

        <ul>
<li>$P$: Tempering parameter (dimensionless)</li>
<li>$T$: Tempering temperature (K)</li>
<li>$t$: Tempering time (hours)</li>
<li>$C$: Constant (typically 20)</li>
</ul>
<h4>Code Example 2-5: Tempering Hardness Prediction</h4>
<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt

def hollomon_jaffe_parameter(temp_celsius, time_hours, C=20):
    """
    Hollomon-Jaffe tempering parameter

    Parameters
    ----------
    temp_celsius : float
        Tempering temperature (Â°C)
    time_hours : float
        Tempering time (hours)
    C : float
        Constant (default 20)

    Returns
    -------
    P : float
        Tempering parameter
    """
    T_kelvin = temp_celsius + 273.15
    P = T_kelvin * (C + np.log10(time_hours)) * 1e-3

    return P


def tempered_hardness(P, HRC_initial=65):
    """
    Hardness prediction from tempering parameter

    Parameters
    ----------
    P : float
        Tempering parameter
    HRC_initial : float
        Initial hardness after quenching (HRC)

    Returns
    -------
    HRC : float
        Hardness after tempering (HRC)
    """
    # Empirical equation (varies by steel grade)
    HRC = HRC_initial - 0.15 * (P - 10) ** 1.5

    # Minimum hardness constraint
    HRC = np.maximum(HRC, 20)

    return HRC


# Temperature and time effect evaluation
temperatures = [200, 300, 400, 500, 600]  # Â°C
time_hours = np.logspace(-1, 2, 100)  # 0.1 to 100 hours

plt.figure(figsize=(12, 8))

for temp in temperatures:
    P_values = [hollomon_jaffe_parameter(temp, t) for t in time_hours]
    hardness = [tempered_hardness(P) for P in P_values]

    plt.plot(time_hours, hardness, linewidth=2.5, label=f'{temp}Â°C')

    # Time to reach target hardness (HRC 45)
    idx_target = np.argmin(np.abs(np.array(hardness) - 45))
    time_target = time_hours[idx_target]

    print(f"Tempering at {temp}Â°C:")
    print(f"  Time to reach HRC 45: {time_target:.2f} hours\n")

plt.axhline(y=45, color='k', linestyle='--', alpha=0.5, label='Target: HRC 45')
plt.xscale('log')
plt.xlabel('Tempering Time (hours)')
plt.ylabel('Hardness (HRC)')
plt.title('Tempering: Hardness vs Time and Temperature')
plt.legend()
plt.grid(True, alpha=0.3, which='both')
plt.savefig('tempering_hardness.png', dpi=150, bbox_inches='tight')
plt.show()

# Iso-hardness contour plot (2D map)
fig, ax = plt.subplots(figsize=(12, 8))

temp_range = np.linspace(150, 650, 50)
time_range = np.logspace(-1, 2, 50)
T_mesh, Time_mesh = np.meshgrid(temp_range, time_range)

Hardness_mesh = np.zeros_like(T_mesh)
for i in range(T_mesh.shape[0]):
    for j in range(T_mesh.shape[1]):
        P = hollomon_jaffe_parameter(T_mesh[i, j], Time_mesh[i, j])
        Hardness_mesh[i, j] = tempered_hardness(P)

contour = ax.contourf(T_mesh, Time_mesh, Hardness_mesh, levels=15, cmap='viridis')
contour_lines = ax.contour(T_mesh, Time_mesh, Hardness_mesh, levels=[40, 45, 50, 55, 60],
                             colors='white', linewidths=2)
ax.clabel(contour_lines, inline=True, fontsize=10, fmt='%d HRC')

ax.set_xlabel('Tempering Temperature (Â°C)')
ax.set_ylabel('Tempering Time (hours)')
ax.set_yscale('log')
ax.set_title('Tempering Map: Hardness Contours')
plt.colorbar(contour, label='Hardness (HRC)')
plt.savefig('tempering_map.png', dpi=150, bbox_inches='tight')
plt.show()</code></pre>
<h2>2.3 Age Hardening</h2>
<h3>2.3.1 Mechanism of Age Hardening</h3>
<p><strong>Age hardening</strong> (Precipitation Hardening) involves generating fine precipitates from supersaturated solid solution to inhibit dislocation movement and improve strength.</p>
<p><strong>Age hardening process</strong> (Al alloy example):</p>
<ol>
<li><strong>Solution Treatment</strong>: Dissolve alloying elements at high temperature (500-550Â°C)</li>
<li><strong>Quenching</strong>: Rapid cooling to room temperature, retaining supersaturated solid solution (SSSS)</li>
<li><strong>Aging Treatment</strong>: Precipitate formation at intermediate temperature (100-200Â°C)
                <ul>
<li>GP zone (Guinier-Preston zone) formation</li>
<li>Intermediate phase (Â¸'', Â¸') precipitation</li>
<li>Stable phase (Â¸, Mgâ€šSi) coarsening</li>
</ul>
</li>
</ol>
<div class="mermaid">
flowchart LR
    A[Supersaturated<br/>Solid Solution<br/>SSSS] --&gt; B[GP zone formation<br/>Few nm]
    B --&gt; C[Intermediate phase Â¸''<br/>Metastable]
    C --&gt; D[Â¸' phase<br/>Tens of nm]
    D --&gt; E[Stable phase Â¸<br/>Coarsening]

    B -.-&gt; F[Peak strength<br/>Optimal precipitation]
    D -.-&gt; G[Over-aging<br/>Strength decrease]

    style A fill:#fce7f3,stroke:#f093fb,stroke-width:2px
    style F fill:#f093fb,stroke:#f5576c,stroke-width:2px,color:#fff
    style G fill:#fee2e2,stroke:#ef4444,stroke-width:2px
        </div>
<p><strong>Orowan mechanism</strong> (precipitation strengthening):</p>
        $$
        \Delta \sigma = \frac{M G b}{\lambda}
        $$

        <ul>
<li>$\Delta \sigma$: Strength increase (MPa)</li>
<li>$M$: Taylor factor (~3)</li>
<li>$G$: Shear modulus (GPa)</li>
<li>$b$: Burgers vector (nm)</li>
<li>$\lambda$: Precipitate spacing (nm)</li>
</ul>
<h4>Code Example 2-6: Age Hardening Curve Simulation</h4>
<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt

def age_hardening_strength(time_hours, temp_celsius, k=0.5, n=0.3):
    """
    Age hardening strength change model (based on JMA equation)

    Parameters
    ----------
    time_hours : ndarray
        Aging time (hours)
    temp_celsius : float
        Aging temperature (Â°C)
    k : float
        Rate constant
    n : float
        Avrami exponent

    Returns
    -------
    strength : ndarray
        Tensile strength (MPa)
    """
    # Temperature dependence (Arrhenius type)
    k_eff = k * np.exp(-(5000 / (temp_celsius + 273.15)))

    # JMA equation (phase transformation fraction)
    f = 1 - np.exp(-(k_eff * time_hours) ** n)

    # Strength model
    sigma_0 = 100  # Solid solution strength (MPa)
    delta_sigma_max = 300  # Maximum precipitation strengthening (MPa)

    # After peak aging, decrease due to over-aging
    peak_fraction = 0.6
    strength = sigma_0 + delta_sigma_max * f * np.exp(-2 * (f - peak_fraction) ** 2)

    return strength


# Temperature dependence evaluation
temperatures = [150, 180, 200, 220]
time_hours = np.logspace(-1, 3, 200)  # 0.1 to 1000 hours

plt.figure(figsize=(12, 8))

for temp in temperatures:
    strength = age_hardening_strength(time_hours, temp)
    plt.plot(time_hours, strength, linewidth=2.5, label=f'{temp}Â°C')

    # Peak strength and time to reach
    peak_strength = np.max(strength)
    peak_time = time_hours[np.argmax(strength)]

    print(f"Age Hardening at {temp}Â°C:")
    print(f"  Peak Strength: {peak_strength:.1f} MPa")
    print(f"  Time to Peak: {peak_time:.2f} hours\n")

plt.xscale('log')
plt.xlabel('Aging Time (hours)')
plt.ylabel('Tensile Strength (MPa)')
plt.title('Age Hardening: Strength vs Time and Temperature')
plt.legend()
plt.grid(True, alpha=0.3, which='both')
plt.savefig('age_hardening_curve.png', dpi=150, bbox_inches='tight')
plt.show()

# Iso-strength contours (2D map)
fig, ax = plt.subplots(figsize=(12, 8))

temp_range = np.linspace(130, 250, 50)
time_range = np.logspace(-1, 3, 50)
T_mesh, Time_mesh = np.meshgrid(temp_range, time_range)

Strength_mesh = np.zeros_like(T_mesh)
for i in range(T_mesh.shape[0]):
    for j in range(T_mesh.shape[1]):
        strength_val = age_hardening_strength(np.array([Time_mesh[i, j]]), T_mesh[i, j])
        Strength_mesh[i, j] = strength_val[0]

contour = ax.contourf(T_mesh, Time_mesh, Strength_mesh, levels=15, cmap='plasma')
contour_lines = ax.contour(T_mesh, Time_mesh, Strength_mesh,
                             levels=[250, 300, 350, 380], colors='white', linewidths=2)
ax.clabel(contour_lines, inline=True, fontsize=10, fmt='%d MPa')

ax.set_xlabel('Aging Temperature (Â°C)')
ax.set_ylabel('Aging Time (hours)')
ax.set_yscale('log')
ax.set_title('Age Hardening Map: Strength Contours')
plt.colorbar(contour, label='Tensile Strength (MPa)')
plt.savefig('age_hardening_map.png', dpi=150, bbox_inches='tight')
plt.show()</code></pre>
<h2>2.4 Utilization of TTT and CCT Diagrams</h2>
<h3>2.4.1 TTT Diagram (Time-Temperature-Transformation)</h3>
<p>The <strong>TTT diagram</strong> (isothermal transformation diagram) represents microstructural transformation during constant temperature holding. It is essential for steel heat treatment design.</p>
<h4>Code Example 2-7: TTT/CCT Diagram Generation and Heat Treatment Simulation</h4>
<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt

def generate_TTT_diagram():
    """
    Generate simplified TTT diagram (eutectoid steel 0.8%C)
    """
    # Pearlite transformation start/finish curves (C curves)
    time = np.logspace(-1, 5, 200)  # seconds

    # Pearlite nose (fastest transformation at approximately 550Â°C)
    T_pearlite_start = 700 - 150 * np.exp(-((np.log10(time) - 1.5) / 1.5) ** 2)
    T_pearlite_finish = T_pearlite_start - 50

    # Bainite transformation (350-550Â°C)
    T_bainite_start = 500 - 150 * np.exp(-((np.log10(time) - 2.5) / 1.2) ** 2)
    T_bainite_finish = T_bainite_start - 50

    # Martensite start temperature (time-independent)
    Ms_temp = 250

    return time, T_pearlite_start, T_pearlite_finish, T_bainite_start, T_bainite_finish, Ms_temp


def simulate_cooling_path(cooling_rate, T_initial=850, time_max=1000):
    """
    Simulate cooling path

    Parameters
    ----------
    cooling_rate : float
        Cooling rate (Â°C/s)
    T_initial : float
        Initial temperature (Â°C)
    time_max : float
        Maximum time (seconds)

    Returns
    -------
    time, temperature : ndarray
        Cooling path
    """
    time = np.linspace(0, time_max, 500)
    temperature = T_initial - cooling_rate * time
    temperature = np.maximum(temperature, 25)  # Room temperature lower limit

    return time, temperature


# TTT diagram generation
time_ttt, T_p_start, T_p_finish, T_b_start, T_b_finish, Ms = generate_TTT_diagram()

# Plot
fig, ax = plt.subplots(figsize=(14, 10))

# TTT curves
ax.plot(time_ttt, T_p_start, 'r-', linewidth=2.5, label='Pearlite Start')
ax.plot(time_ttt, T_p_finish, 'r--', linewidth=2.5, label='Pearlite Finish')
ax.plot(time_ttt, T_b_start, 'b-', linewidth=2.5, label='Bainite Start')
ax.plot(time_ttt, T_b_finish, 'b--', linewidth=2.5, label='Bainite Finish')
ax.axhline(y=Ms, color='purple', linestyle='-', linewidth=2.5, label=f'Ms (Martensite): {Ms}Â°C')

# Region shading
ax.fill_between(time_ttt, T_p_start, T_p_finish, alpha=0.3, color='red', label='Pearlite Region')
ax.fill_between(time_ttt, T_b_start, T_b_finish, alpha=0.3, color='blue', label='Bainite Region')
ax.fill_between(time_ttt, 0, Ms, alpha=0.2, color='purple', label='Martensite Region')

# Overlay cooling paths
cooling_cases = [
    {'rate': 500, 'name': 'Water Quench (500Â°C/s)', 'color': 'green', 'linestyle': '-'},
    {'rate': 50, 'name': 'Oil Quench (50Â°C/s)', 'color': 'orange', 'linestyle': '-'},
    {'rate': 5, 'name': 'Air Cool (5Â°C/s)', 'color': 'brown', 'linestyle': '-'},
]

for case in cooling_cases:
    time_cool, temp_cool = simulate_cooling_path(case['rate'])
    ax.plot(time_cool, temp_cool, color=case['color'],
            linestyle=case['linestyle'], linewidth=3, label=case['name'])

ax.set_xscale('log')
ax.set_xlabel('Time (s)')
ax.set_ylabel('Temperature (Â°C)')
ax.set_title('TTT Diagram with Cooling Paths (Eutectoid Steel 0.8% C)')
ax.set_xlim(0.1, 1e4)
ax.set_ylim(0, 900)
ax.legend(loc='upper right', fontsize=9)
ax.grid(True, alpha=0.3, which='both')
plt.savefig('ttt_diagram_with_cooling.png', dpi=150, bbox_inches='tight')
plt.show()

# Microstructure prediction
print("Microstructure Prediction:")
for case in cooling_cases:
    time_cool, temp_cool = simulate_cooling_path(case['rate'])

    # Pearlite nose passage determination
    pearlite_time_min = time_ttt[np.argmin(T_p_start)]
    pearlite_temp_min = np.min(T_p_start)

    if case['rate'] &gt; 100:
        microstructure = "100% Martensite (avoided pearlite nose)"
    elif case['rate'] &gt; 20:
        microstructure = "Martensite + Bainite (partial transformation)"
    else:
        microstructure = "Pearlite + Ferrite (slow cooling)"

    print(f"{case['name']}: {microstructure}")</code></pre>
<h2>Exercises</h2>
<div class="exercise-box">
<h4>Exercise 2-1: Annealing Holding Time Design (Easy)</h4>
<p>For full annealing of carbon steel (0.5% C), you want to homogenize a 20 mm thick plate. The diffusion distance must reach at least 10 mm. Calculate the required holding time when annealing at 800Â°C. (Carbon diffusion coefficient: $D = 2.0 \times 10^{-5} \exp(-142000 / (8.314 \times T))$ mÂ²/s, $T$ in K)</p>
<details class="solution-box">
<summary>Solution Example</summary>
<pre><code class="language-python"># Given conditions
target_distance = 10e-3  # m (10 mm)
T_celsius = 800
T_kelvin = T_celsius + 273.15

# Diffusion coefficient calculation
Q = 142000  # J/mol
D0 = 2.0e-5  # mÂ²/s
R = 8.314    # J/molÂ·K

D = D0 * np.exp(-Q / (R * T_kelvin))

# Holding time calculation (xÂ² = D * t)
t_required = (target_distance ** 2) / D
t_hours = t_required / 3600

print(f"Complete Annealing Time Calculation:")
print(f"  Temperature: {T_celsius} Â°C")
print(f"  Target Diffusion Distance: {target_distance*1000} mm")
print(f"  Diffusion Coefficient: {D:.2e} mÂ²/s")
print(f"  Required Holding Time: {t_hours:.2f} hours ({t_required/60:.1f} min)")

# Result: Approximately 8 hours needed
# In practice, with safety margin, 10-12 hours holding is recommended</code></pre>
</details>
</div>
<div class="exercise-box">
<h4>Exercise 2-2: Microstructure Prediction After Quenching (Easy)</h4>
<p>After austenitizing eutectoid steel (0.8% C) at 850Â°C, predict the microstructure when quenched at the following cooling rates: (a) 200Â°C/s, (b) 30Â°C/s, (c) 3Â°C/s. Refer to the TTT diagram and answer the resulting microstructure and expected hardness range.</p>
<details class="solution-box">
<summary>Solution Example</summary>
<p><strong>TTT Diagram Analysis</strong>:</p>
<ul>
<li><strong>(a) 200Â°C/s (water quench)</strong>: Avoids pearlite nose (approximately 550Â°C, 1 second) â€™ <strong>100% Martensite</strong>, hardness HRC 64-66</li>
<li><strong>(b) 30Â°C/s (oil quench)</strong>: Passes through pearlite nose but short duration â€™ <strong>Martensite + Upper Bainite</strong>, hardness HRC 55-60</li>
<li><strong>(c) 3Â°C/s (air cooling)</strong>: Long residence in pearlite transformation region â€™ <strong>Fine Pearlite</strong>, hardness HRC 35-40</li>
</ul>
<p><strong>Experimental Verification</strong>: Ideally, measure with Jominy test and compare with predictions</p>
</details>
</div>
<div class="exercise-box">
<h4>Exercise 2-3: Tempering Condition Design (Medium)</h4>
<p>You want to temper quenched tool steel (HRC 65) to target hardness HRC 55. Calculate the required time when tempering at 400Â°C and 500Â°C. (Use Hollomon-Jaffe parameter)</p>
<details class="solution-box">
<summary>Solution Example</summary>
<pre><code class="language-python"># Inverse calculation: Calculate P from target hardness, then calculate time
def inverse_tempered_hardness(HRC_target, HRC_initial=65):
    """Calculate Hollomon-Jaffe parameter from target hardness"""
    # HRC = HRC_initial - 0.15 * (P - 10)^1.5
    # â€™ P = 10 + ((HRC_initial - HRC) / 0.15)^(2/3)
    P_target = 10 + ((HRC_initial - HRC_target) / 0.15) ** (2/3)
    return P_target

HRC_target = 55
P_target = inverse_tempered_hardness(HRC_target)

print(f"Target Hollomon-Jaffe Parameter: P = {P_target:.2f}\n")

# Calculate time for two temperatures
temperatures = [400, 500]  # Â°C

for temp in temperatures:
    T_kelvin = temp + 273.15
    C = 20

    # P = T * (C + log10(t)) * 1e-3
    # â€™ log10(t) = (P / (T * 1e-3)) - C
    log10_t = (P_target / (T_kelvin * 1e-3)) - C
    t_hours = 10 ** log10_t

    print(f"Tempering at {temp}Â°C:")
    print(f"  Required Time: {t_hours:.2f} hours")
    print(f"  Practical Recommendation: {t_hours*1.2:.2f} hours (with safety margin)\n")

# Results:
# 400Â°C â€™ Approximately 10 hours
# 500Â°C â€™ Approximately 2 hours
# â€™ Higher temperature reaches target hardness in shorter time</code></pre>
</details>
</div>
<div class="exercise-box">
<h4>Exercise 2-4: Age Hardening Optimal Condition Determination (Medium)</h4>
<p>For age hardening of Al-Cu alloy (Al-4%Cu), the target tensile strength is 400 MPa. If aging treatment can be performed at 180Â°C and 200Â°C, compare the optimal aging time and productivity (throughput) for each.</p>
<details class="solution-box">
<summary>Solution Example</summary>
<pre><code class="language-python"># Age hardening simulation (time to reach strength 400 MPa)
target_strength = 400  # MPa
temperatures = [180, 200]

time_hours_range = np.logspace(-1, 3, 500)

for temp in temperatures:
    strength_curve = age_hardening_strength(time_hours_range, temp)

    # Time to reach target strength
    idx_target = np.argmin(np.abs(strength_curve - target_strength))
    time_target = time_hours_range[idx_target]
    strength_achieved = strength_curve[idx_target]

    # Peak strength
    peak_strength = np.max(strength_curve)
    peak_time = time_hours_range[np.argmax(strength_curve)]

    print(f"Aging at {temp}Â°C:")
    print(f"  Time to reach {target_strength} MPa: {time_target:.2f} hours")
    print(f"  Achieved Strength: {strength_achieved:.1f} MPa")
    print(f"  Peak Strength: {peak_strength:.1f} MPa (at {peak_time:.2f} hours)")

    # Productivity evaluation (batch processing)
    batch_capacity = 100  # parts/batch
    throughput = batch_capacity / time_target  # parts/hour

    print(f"  Production Throughput: {throughput:.2f} parts/hour")
    print(f"  Daily Production (24h): {throughput*24:.0f} parts\n")

# Results:
# 180Â°C â€™ Longer time but higher peak strength (stable)
# 200Â°C â€™ Shorter time, higher productivity, but over-aging risk
# â€™ Choose 200Â°C for productivity priority, 180Â°C for quality stability priority</code></pre>
</details>
</div>
<div class="exercise-box">
<h4>Exercise 2-5: Hardenability Evaluation from Jominy Test Data (Medium)</h4>
<p>The following hardness data were obtained from Jominy test: End surface (0 mm): HRC 62, 5 mm: HRC 58, 10 mm: HRC 52, 15 mm: HRC 45. From this data, predict the center hardness when quenching a 30 mm diameter round bar.</p>
<details class="solution-box">
<summary>Solution Example</summary>
<pre><code class="language-python">import numpy as np
from scipy.interpolate import interp1d

# Jominy test data
jominy_distance = np.array([0, 5, 10, 15])  # mm
jominy_hardness = np.array([62, 58, 52, 45])  # HRC

# Create interpolation function
interp_func = interp1d(jominy_distance, jominy_hardness,
                        kind='cubic', fill_value='extrapolate')

# Grossmann conversion table (simplified): Round bar diameter â€™ Jominy equivalent distance
# Center of 30 mm diameter is equivalent to approximately 12-13 mm of Jominy test in terms of cooling rate
# (Actual conversion tables or H-band method should be used, but simplified calculation here)

diameter = 30  # mm
equivalent_jominy_distance = 0.4 * diameter  # Simplified conversion (center)

predicted_hardness = interp_func(equivalent_jominy_distance)

print(f"Jominy Hardenability Analysis:")
print(f"  Bar Diameter: {diameter} mm")
print(f"  Equivalent Jominy Distance (center): {equivalent_jominy_distance:.1f} mm")
print(f"  Predicted Center Hardness: {predicted_hardness:.1f} HRC")

# Surface hardness (Jominy 0 mm equivalent)
surface_hardness = interp_func(0)
print(f"  Predicted Surface Hardness: {surface_hardness:.1f} HRC")

# Case depth (depth with HRC e 50)
hardness_threshold = 50
try:
    depth_threshold = np.interp(hardness_threshold, jominy_hardness[::-1], jominy_distance[::-1])
    # Case depth in round bar (simplified conversion)
    effective_depth = depth_threshold / 0.4
    print(f"\nCase Depth (HRC e 50): {effective_depth:.1f} mm from surface")
except:
    print(f"\nCase Depth: Exceeds measurement range")

# Plot
plt.figure(figsize=(10, 6))
jominy_fine = np.linspace(0, 20, 100)
hardness_fine = interp_func(jominy_fine)
plt.plot(jominy_fine, hardness_fine, 'b-', linewidth=2, label='Interpolated Curve')
plt.scatter(jominy_distance, jominy_hardness, color='red', s=100,
            zorder=5, label='Measured Data')
plt.axvline(x=equivalent_jominy_distance, color='green', linestyle='--',
            linewidth=2, label=f'Equivalent Position (30mm bar center)')
plt.axhline(y=predicted_hardness, color='green', linestyle='--', alpha=0.5)
plt.xlabel('Distance from Quenched End (mm)')
plt.ylabel('Hardness (HRC)')
plt.title('Jominy Hardenability and Center Hardness Prediction')
plt.legend()
plt.grid(True, alpha=0.3)
plt.savefig('jominy_prediction.png', dpi=150, bbox_inches='tight')
plt.show()</code></pre>
</details>
</div>
<div class="exercise-box">
<h4>Exercise 2-6: Heat Treatment Process Design Using TTT Diagram (Hard)</h4>
<p>For eutectoid steel (0.8% C), you want to obtain a mixed microstructure of 50% martensite + 50% bainite. Design optimal cooling rate and isothermal holding conditions referring to TTT diagram. Target hardness is HRC 55-58.</p>
<details class="solution-box">
<summary>Solution Example</summary>
<pre><code class="language-python"># Strategy: Austempering
# 1. Austenitize at 850Â°C
# 2. Rapid quench to bainite region (e.g., 300Â°C) below Ms temperature (250Â°C)
# 3. Bainite transformation by isothermal holding (approximately 50%)
# 4. Cool to room temperature â€™ Retained austenite transforms to martensite

T_austenitize = 850  # Â°C
T_austempering = 300  # Â°C (lower bainite region)
Ms = 250  # Â°C

# Cooling rate calculation (reach bainite region before entering below Ms)
# Must avoid pearlite nose (550Â°C, 1 second)
required_cooling_rate = (T_austenitize - T_austempering) / 5  # Within 5 seconds

print(f"Austempering Process Design:")
print(f"  Step 1: Austenitizing at {T_austenitize}Â°C")
print(f"  Step 2: Rapid quench to {T_austempering}Â°C")
print(f"    Required Cooling Rate: &gt;{required_cooling_rate:.1f} Â°C/s")
print(f"    (Use oil or salt bath quench)")

# Bainite transformation time (read from TTT diagram)
# Transformation start at 300Â°C: approximately 10 seconds, 50% transformation: approximately 60 seconds
t_bainite_start = 10  # seconds
t_bainite_50pct = 60  # seconds

print(f"\n  Step 3: Isothermal hold at {T_austempering}Â°C")
print(f"    Bainite transformation starts: {t_bainite_start} s")
print(f"    Hold time for 50% bainite: {t_bainite_50pct} s")

# Retained austenite â€™ Martensite transformation
print(f"\n  Step 4: Cool to room temperature")
print(f"    Remaining austenite (50%) transforms to martensite below {Ms}Â°C")

# Microstructure and hardness prediction
print(f"\nExpected Microstructure:")
print(f"  50% Lower Bainite (HRC 50-55)")
print(f"  50% Martensite (HRC 60-65)")
print(f"  Composite Hardness: HRC 55-58 ")

# Recommendation for experimental verification
print(f"\nExperimental Verification:")
print(f"  1. Conduct dilatometry to confirm transformation kinetics")
print(f"  2. Metallographic examination (SEM, optical microscopy)")
print(f"  3. Hardness testing (Rockwell C scale)")
print(f"  4. Impact toughness testing (Charpy) for quality assurance")</code></pre>
</details>
</div>
<div class="exercise-box">
<h4>Exercise 2-7: Multi-Step Aging Treatment Optimization (Hard)</h4>
<p>For Al-Mg-Si alloy, perform two-step aging treatment. Determine optimal conditions for Step 1 (low temperature, GP zone formation) and Step 2 (high temperature, intermediate phase precipitation) considering trade-off between tensile strength and cost (energy, time).</p>
<details class="solution-box">
<summary>Solution Example</summary>
<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import differential_evolution

def two_step_aging_strength(t1_hours, T1_celsius, t2_hours, T2_celsius):
    """
    Two-step aging treatment strength prediction model

    Parameters
    ----------
    t1_hours, T1_celsius : float
        Step 1 aging (time, temperature)
    t2_hours, T2_celsius : float
        Step 2 aging (time, temperature)

    Returns
    -------
    strength : float
        Tensile strength (MPa)
    """
    # Step 1: GP zone formation (low temperature, long time)
    strength_step1 = 200 + 100 * (1 - np.exp(-0.5 * t1_hours)) * np.exp(-T1_celsius / 200)

    # Step 2: Intermediate phase precipitation (high temperature, short time)
    strength_step2 = 150 * (1 - np.exp(-0.2 * t2_hours)) * (1 - np.exp(-(T2_celsius - 150) / 50))

    # Composite strength
    total_strength = strength_step1 + strength_step2

    return total_strength


def calculate_cost(t1_hours, T1_celsius, t2_hours, T2_celsius):
    """
    Process cost calculation

    Returns
    -------
    cost : float
        Normalized cost (time + energy)
    """
    # Time cost (productivity)
    time_cost = t1_hours + t2_hours

    # Energy cost (temperature Ã— time)
    energy_cost = (T1_celsius * t1_hours + T2_celsius * t2_hours) / 1000

    # Total cost (weighted)
    total_cost = time_cost + 0.5 * energy_cost

    return total_cost


def objective_function(params):
    """
    Multi-objective optimization objective function

    Maximize strength, minimize cost

    Returns
    -------
    -performance : float
        Negative performance index (minimization problem)
    """
    t1, T1, t2, T2 = params

    strength = two_step_aging_strength(t1, T1, t2, T2)
    cost = calculate_cost(t1, T1, t2, T2)

    # Performance index: strength / cost (higher is better)
    performance = strength / cost

    return -performance  # Convert to minimization problem


# Optimization execution
bounds = [
    (1, 24),    # t1: 1-24 hours
    (100, 150), # T1: 100-150Â°C
    (1, 12),    # t2: 1-12 hours
    (170, 220)  # T2: 170-220Â°C
]

result = differential_evolution(
    objective_function,
    bounds,
    maxiter=100,
    seed=42,
    disp=True
)

t1_opt, T1_opt, t2_opt, T2_opt = result.x
strength_opt = two_step_aging_strength(t1_opt, T1_opt, t2_opt, T2_opt)
cost_opt = calculate_cost(t1_opt, T1_opt, t2_opt, T2_opt)

print(f"Two-Step Aging Optimization Results:")
print(f"\nStep 1 (GP Zone Formation):")
print(f"  Temperature: {T1_opt:.1f} Â°C")
print(f"  Time: {t1_opt:.2f} hours")
print(f"\nStep 2 (Intermediate Phase Precipitation):")
print(f"  Temperature: {T2_opt:.1f} Â°C")
print(f"  Time: {t2_opt:.2f} hours")
print(f"\nPerformance:")
print(f"  Tensile Strength: {strength_opt:.1f} MPa")
print(f"  Total Process Cost: {cost_opt:.2f} (normalized)")
print(f"  Performance Index: {strength_opt/cost_opt:.2f} MPa/cost")

# Comparison: Single-step aging
T_single = 180
t_single = 10
strength_single = two_step_aging_strength(0, 100, t_single, T_single)
cost_single = calculate_cost(0, 100, t_single, T_single)

print(f"\nComparison with Single-Step Aging ({T_single}Â°C, {t_single}h):")
print(f"  Strength: {strength_single:.1f} MPa")
print(f"  Cost: {cost_single:.2f}")
print(f"  Performance Index: {strength_single/cost_single:.2f} MPa/cost")
print(f"\nImprovement:")
print(f"  Strength: +{strength_opt - strength_single:.1f} MPa ({(strength_opt/strength_single-1)*100:.1f}%)")
print(f"  Performance Index: +{(strength_opt/cost_opt) - (strength_single/cost_single):.2f} ({((strength_opt/cost_opt)/(strength_single/cost_single)-1)*100:.1f}%)")</code></pre>
</details>
</div>
<div class="exercise-box">
<h4>Exercise 2-8: Statistical Quality Control of Heat Treatment Process (Hard)</h4>
<p>In factory tempering process, there are variations of temperature Â±5Â°C and time Â±10%. Calculate the probability of achieving target hardness HRC 50Â±2 and evaluate process capability indices (Cp, Cpk). Propose improvement measures to keep defect rate below 1%.</p>
<details class="solution-box">
<summary>Solution Example</summary>
<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import norm

# Process conditions (nominal values)
T_nominal = 450  # Â°C
t_nominal = 2.0  # hours
HRC_target = 50

# Process variation
T_std = 5 / 3  # Â°C (Â±5Â°C as 3Ãƒ)
t_std = t_nominal * 0.1 / 3  # hours (Â±10% as 3Ãƒ)

# Monte Carlo simulation
n_samples = 10000
np.random.seed(42)

T_samples = np.random.normal(T_nominal, T_std, n_samples)
t_samples = np.random.normal(t_nominal, t_std, n_samples)

# Hardness calculation (each sample)
hardness_samples = np.array([
    tempered_hardness(hollomon_jaffe_parameter(T, t))
    for T, t in zip(T_samples, t_samples)
])

# Statistical analysis
HRC_mean = np.mean(hardness_samples)
HRC_std = np.std(hardness_samples)

print(f"Process Capability Analysis:")
print(f"  Target Hardness: {HRC_target} Â± 2 HRC")
print(f"  Actual Mean: {HRC_mean:.2f} HRC")
print(f"  Actual Std Dev: {HRC_std:.2f} HRC")

# Process capability indices
USL = HRC_target + 2  # Upper Specification Limit
LSL = HRC_target - 2  # Lower Specification Limit

Cp = (USL - LSL) / (6 * HRC_std)
Cpk = min((USL - HRC_mean) / (3 * HRC_std),
          (HRC_mean - LSL) / (3 * HRC_std))

print(f"\nProcess Capability Indices:")
print(f"  Cp = {Cp:.3f}")
print(f"  Cpk = {Cpk:.3f}")

if Cp &gt;= 1.33:
    print(f"  â€™ Cp assessment: CAPABLE (e1.33)")
else:
    print(f"  â€™ Cp assessment: MARGINAL (&lt;1.33)")

if Cpk &gt;= 1.33:
    print(f"  â€™ Cpk assessment: CAPABLE and CENTERED (e1.33)")
else:
    print(f"  â€™ Cpk assessment: NEEDS IMPROVEMENT (&lt;1.33)")

# Defect rate calculation
out_of_spec = np.sum((hardness_samples &lt; LSL) | (hardness_samples &gt; USL))
defect_rate = out_of_spec / n_samples * 100

print(f"\nDefect Rate:")
print(f"  Out of Specification: {out_of_spec} / {n_samples}")
print(f"  Defect Rate: {defect_rate:.2f}%")

if defect_rate &lt; 1.0:
    print(f"  â€™ Target (&lt;1%) ACHIEVED ")
else:
    print(f"  â€™ Target (&lt;1%) NOT MET ")

# Histogram and process distribution
plt.figure(figsize=(12, 6))
plt.hist(hardness_samples, bins=50, density=True, alpha=0.7,
         color='blue', edgecolor='black', label='Actual Distribution')

# Normal distribution fit
x_fit = np.linspace(HRC_mean - 4*HRC_std, HRC_mean + 4*HRC_std, 200)
y_fit = norm.pdf(x_fit, HRC_mean, HRC_std)
plt.plot(x_fit, y_fit, 'r-', linewidth=2, label='Normal Fit')

# Specification limits
plt.axvline(x=LSL, color='green', linestyle='--', linewidth=2, label='LSL/USL')
plt.axvline(x=USL, color='green', linestyle='--', linewidth=2)
plt.axvline(x=HRC_target, color='black', linestyle='-', linewidth=2, label='Target')

# Shade out-of-spec regions
x_below = x_fit[x_fit &lt; LSL]
y_below = norm.pdf(x_below, HRC_mean, HRC_std)
plt.fill_between(x_below, 0, y_below, color='red', alpha=0.3, label='Out of Spec')

x_above = x_fit[x_fit &gt; USL]
y_above = norm.pdf(x_above, HRC_mean, HRC_std)
plt.fill_between(x_above, 0, y_above, color='red', alpha=0.3)

plt.xlabel('Hardness (HRC)')
plt.ylabel('Probability Density')
plt.title(f'Tempering Process Capability (Cp={Cp:.2f}, Cpk={Cpk:.2f})')
plt.legend()
plt.grid(True, alpha=0.3)
plt.savefig('process_capability.png', dpi=150, bbox_inches='tight')
plt.show()

# Improvement recommendations
print(f"\nImprovement Recommendations:")

if Cpk &lt; 1.33:
    print(f"  Priority 1: Reduce process variation")
    print(f"    - Improve temperature control (Â±3Â°C target)")
    print(f"    - Calibrate furnace thermocouples")
    print(f"    - Implement SPC charts for real-time monitoring")

if abs(HRC_mean - HRC_target) &gt; 0.5:
    print(f"  Priority 2: Center the process")
    print(f"    - Adjust nominal temperature to {T_nominal + (HRC_target - HRC_mean)*2:.1f}Â°C")

print(f"  Priority 3: Implement closed-loop control")
print(f"    - Measure hardness in-line (non-destructive testing)")
print(f"    - Adaptive control based on feedback")

# Simulation: Predicted improvement
T_std_improved = 3 / 3  # Â±3Â°C
t_std_improved = t_nominal * 0.05 / 3  # Â±5%

T_samples_improved = np.random.normal(T_nominal, T_std_improved, n_samples)
t_samples_improved = np.random.normal(t_nominal, t_std_improved, n_samples)

hardness_improved = np.array([
    tempered_hardness(hollomon_jaffe_parameter(T, t))
    for T, t in zip(T_samples_improved, t_samples_improved)
])

HRC_std_improved = np.std(hardness_improved)
Cp_improved = (USL - LSL) / (6 * HRC_std_improved)
defect_rate_improved = np.sum((hardness_improved &lt; LSL) | (hardness_improved &gt; USL)) / n_samples * 100

print(f"\nProjected Improvement (Â±3Â°C, Â±5% time):")
print(f"  New Cp: {Cp_improved:.3f} (from {Cp:.3f})")
print(f"  New Defect Rate: {defect_rate_improved:.2f}% (from {defect_rate:.2f}%)")
print(f"  â€™ Improvement: {defect_rate - defect_rate_improved:.2f}% reduction")</code></pre>
</details>
</div>
<div class="exercise-box">
<h4>Exercise 2-9: Comprehensive Heat Treatment Simulation Project (Hard)</h4>
<p>Design the entire manufacturing process for automotive gear (SCM440) (carburizing quenching â€™ tempering â€™ surface hardness HRC 58-62, core hardness HRC 35-40). Consider balance between process time, energy cost, and material properties, and determine optimal process using Python.</p>
<details class="solution-box">
<summary>Solution Example</summary>
<pre><code class="language-python"># Comprehensive process design framework
print("Comprehensive Heat Treatment Process Design for Automotive Gear (SCM440)")
print("="*70)

# Step 1: Carburizing
print("\nStep 1: Carburizing Process")
T_carburizing = 930  # Â°C
t_carburizing = 8    # hours (3mm carburized layer thickness)
case_depth = 3       # mm

print(f"  Temperature: {T_carburizing}Â°C")
print(f"  Time: {t_carburizing} hours")
print(f"  Target Case Depth: {case_depth} mm")
print(f"  Carbon Potential: 1.0-1.2%")

# Step 2: Diffusion Hold
print("\nStep 2: Diffusion Hold")
T_diffusion = 850  # Â°C
t_diffusion = 2    # hours
print(f"  Temperature: {T_diffusion}Â°C")
print(f"  Time: {t_diffusion} hours")
print(f"  Purpose: Uniform carbon distribution")

# Step 3: Quenching
print("\nStep 3: Quenching")
T_quench_start = 850
T_quench_medium = 60  # Oil temperature
cooling_rate = 50      # Â°C/s

print(f"  Quench Medium: Oil at {T_quench_medium}Â°C")
print(f"  Cooling Rate: ~{cooling_rate}Â°C/s")
print(f"  Expected Surface Microstructure: Martensite (HRC 60-64)")
print(f"  Expected Core Microstructure: Martensite + Bainite (HRC 45-50)")

# Step 4: Tempering
print("\nStep 4: Tempering")
T_tempering = 180  # Â°C (low-temperature tempering)
t_tempering = 2    # hours

# Hardness prediction (simplified)
P_surface = hollomon_jaffe_parameter(T_tempering, t_tempering)
HRC_surface_tempered = tempered_hardness(P_surface, HRC_initial=62)

print(f"  Temperature: {T_tempering}Â°C")
print(f"  Time: {t_tempering} hours")
print(f"  Expected Surface Hardness: HRC {HRC_surface_tempered:.0f}")
print(f"  Expected Core Hardness: HRC 35-40 (minimal change)")

# Process evaluation
print("\n" + "="*70)
print("Process Performance Evaluation:")

# Total process time
total_time = t_carburizing + t_diffusion + 0.5 + t_tempering  # Quenching 0.5h
print(f"  Total Process Time: {total_time:.1f} hours")

# Energy cost (simplified calculation)
# Furnace volume 1mÂ³, heater efficiency 70%, electricity rate 0.15 USD/kWh
furnace_volume = 1.0  # mÂ³
heat_capacity = 1200  # kJ/mÂ³/Â°C
efficiency = 0.7

energy_carb = furnace_volume * heat_capacity * T_carburizing * t_carburizing / efficiency
energy_diff = furnace_volume * heat_capacity * T_diffusion * t_diffusion / efficiency
energy_temp = furnace_volume * heat_capacity * T_tempering * t_tempering / efficiency

total_energy = (energy_carb + energy_diff + energy_temp) / 3600  # kWh
energy_cost = total_energy * 0.15  # USD/batch

print(f"  Total Energy Consumption: {total_energy:.1f} kWh/batch")
print(f"  Energy Cost: ${energy_cost:.2f}/batch (100 gears)")
print(f"  Per-Gear Cost: ${energy_cost/100:.4f}")

# Material properties evaluation
print(f"\nTarget Material Properties:")
print(f"  Surface Hardness: HRC 58-62 (Target: {HRC_surface_tempered:.0f} )")
print(f"  Core Hardness: HRC 35-40 ")
print(f"  Case Depth: {case_depth} mm ")
print(f"  Core Toughness: Maintained by lower hardness")

# Optimization opportunities
print(f"\nOptimization Opportunities:")
print(f"  1. Use vacuum carburizing â€™ Reduce time by 30%")
print(f"  2. Implement press quenching â€™ Reduce distortion")
print(f"  3. Online hardness monitoring â€™ Quality assurance")
print(f"  4. Energy recovery system â€™ Reduce energy cost by 20%")

# Conclusion
print(f"\n" + "="*70)
print("Conclusion:")
print(f"  This process meets all specifications for automotive gears.")
print(f"  Total cycle time: {total_time:.1f} hours (competitive)")
print(f"  Energy efficiency: Moderate (improvement possible)")
print(f"  Quality assurance: Jominy testing + statistical process control recommended")</code></pre>
</details>
</div>
<h2>Learning Achievement Checklist</h2>
<h3>Basic Understanding Level</h3>
<ul>
<li> Can explain the four types of annealing (full annealing, stress relief, recrystallization, spheroidizing)</li>
<li> Understand Fick's diffusion equation and Arrhenius equation</li>
<li> Can explain the relationship between quenching cooling rate and microstructure (martensite, bainite, pearlite)</li>
<li> Understand the hardness-toughness trade-off in tempering</li>
<li> Can explain the three stages of age hardening (solution treatment â€™ quenching â€™ aging)</li>
</ul>
<h3>Practical Skills Level</h3>
<ul>
<li> Can calculate diffusion distance and holding time to design annealing profiles</li>
<li> Can evaluate hardenability from Jominy test data</li>
<li> Can determine tempering conditions using Hollomon-Jaffe parameter</li>
<li> Can read TTT/CCT diagrams and predict microstructure from cooling rate</li>
<li> Can determine optimal aging time from age hardening curves</li>
</ul>
<h3>Application Level</h3>
<ul>
<li> Can design complex heat treatment processes (austempering, etc.) using TTT diagrams</li>
<li> Can optimize two-step aging treatment (strength-cost trade-off)</li>
<li> Can statistically evaluate heat treatment quality using process capability indices (Cp, Cpk)</li>
<li> Can design and optimize entire composite processes such as carburizing quenching</li>
<li> Can quantitatively evaluate the impact of process variation using Monte Carlo simulation</li>
<li> Can comprehensively evaluate energy cost and productivity of heat treatment</li>
</ul>
<h2>References</h2>
<ol>
<li>Porter, D.A., Easterling, K.E., Sherif, M.Y. (2009). <em>Phase Transformations in Metals and Alloys</em> (3rd ed.). CRC Press, pp. 234-278, 345-389.</li>
<li>Krauss, G. (2015). <em>Steels: Processing, Structure, and Performance</em> (2nd ed.). ASM International, pp. 145-189, 267-312.</li>
<li>Honeycombe, R.W.K., Bhadeshia, H.K.D.H. (2017). <em>Steels: Microstructure and Properties</em> (4th ed.). Butterworth-Heinemann, pp. 89-124, 201-245.</li>
<li>ASM International. (1991). <em>ASM Handbook Volume 4: Heat Treating</em>. ASM International, pp. 456-489, 567-602.</li>
<li>Callister, W.D., Rethwisch, D.G. (2020). <em>Materials Science and Engineering: An Introduction</em> (10th ed.). Wiley, pp. 345-378, 412-456.</li>
<li>Totten, G.E. (Ed.). (2006). <em>Steel Heat Treatment: Metallurgy and Technologies</em> (2nd ed.). CRC Press, pp. 123-167, 289-334.</li>
<li>Polmear, I.J., StJohn, D., Nie, J.F., Qian, M. (2017). <em>Light Alloys: Metallurgy of the Light Metals</em> (5th ed.). Butterworth-Heinemann, pp. 178-223, 267-301.</li>
<li>Brooks, C.R. (1996). <em>Principles of the Heat Treatment of Plain Carbon and Low Alloy Steels</em>. ASM International, pp. 56-89, 134-178.</li>
</ol>
<div class="navigation">
<a class="nav-button" href="chapter-1.html">ï¿½ Chapter 1: Fundamentals of Process Control</a>
<a class="nav-button" href="chapter-3.html">Chapter 3: Surface Treatment Technologies â€™</a>
</div>
</main>
<section class="disclaimer">
<h3>Disclaimer</h3>
<ul>
<li>This content is provided for educational, research, and informational purposes only and does not constitute professional advice (legal, accounting, technical warranty, etc.).</li>
<li>This content and accompanying code examples are provided "AS IS" without any warranty, express or implied, including but not limited to merchantability, fitness for a particular purpose, non-infringement, accuracy, completeness, operation, or safety.</li>
<li>The author and Tohoku University assume no responsibility for the content, availability, or safety of external links, third-party data, tools, libraries, etc.</li>
<li>To the maximum extent permitted by applicable law, the author and Tohoku University shall not be liable for any direct, indirect, incidental, special, consequential, or punitive damages arising from the use, execution, or interpretation of this content.</li>
<li>The content of this material is subject to change, update, or discontinuation without notice.</li>
<li>The copyright and license of this content shall follow the specified conditions (e.g., CC BY 4.0). Such licenses typically include a no-warranty clause.</li>
</ul>
</section>
<footer>
<p><strong>Author</strong>: MS Knowledge Hub Content Team</p>
<p><strong>Version</strong>: 1.0 | <strong>Created</strong>: 2025-10-28</p>
<p><strong>License</strong>: Creative Commons BY 4.0</p>
<p>Â© 2025 MS Terakoya. All rights reserved.</p>
</footer>
</body>
</html>
