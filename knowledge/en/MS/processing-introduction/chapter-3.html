<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Chapter 3: Surface Treatment Technologies - MS Terakoya</title>
<link href="../../assets/css/knowledge-base.css" rel="stylesheet"/>
<!-- Prism.js for syntax highlighting -->
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet"/>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
<script>
        mermaid.initialize({ startOnLoad: true, theme: 'default', securityLevel: 'strict' });
    </script>
<script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true,
                processEnvironments: true
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
                ignoreHtmlClass: 'mermaid'
            }
        };
    </script>
<script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
<nav class="breadcrumb">
<div class="breadcrumb-content">
<a href="../index.html">AI Terakoya Top</a><span class="breadcrumb-separator">‚Ä∫</span><a href="../../MS/index.html">Materials Science</a><span class="breadcrumb-separator">‚Ä∫</span><a href="../../MS/processing-introduction/index.html">Processing</a><span class="breadcrumb-separator">‚Ä∫</span><span class="breadcrumb-current">Chapter 3</span>
</div>
</nav><div class="locale-switcher">
<span class="current-locale">üåê EN</span>
<span class="locale-separator">|</span>

<span class="locale-meta">Last sync: 2025-11-16</span>
</div>

<header>
<div class="header-content">
<h1>Chapter 3: Surface Treatment Technologies</h1>
<p class="subtitle">Electroplating, Anodizing, Surface Modification, Coating Technologies</p>
<div class="meta">
<span class="meta-item">üìñ Process Technology Introduction Series</span>
<span class="meta-item">‚è±Ô∏è Study Time: 35-45 min</span>
<span class="meta-item">üíª 7 Code Examples</span>
<span class="meta-item">üìä Difficulty: Intermediate</span>
</div>
</div>
</header>
<main class="container">
<div class="learning-objectives">
<h2>Learning Objectives</h2>
<p>Upon completing this chapter, you will be able to:</p>
<ul>
<li>‚úÖ Calculate plating thickness using Faraday's law and optimize current density</li>
<li>‚úÖ Understand the relationship between voltage and film thickness in anodization processes and design anodizing treatments</li>
<li>‚úÖ Model ion implantation concentration profiles using Gaussian distributions</li>
<li>‚úÖ Understand coating technology selection criteria and choose appropriate methods</li>
<li>‚úÖ Evaluate the relationship between particle velocity/temperature and adhesion in thermal spray processes</li>
<li>‚úÖ Optimize surface treatment process parameters and perform troubleshooting</li>
</ul>
</div>
<h2>3.1 Electroplating</h2>
<h3>3.1.1 Faraday's Law and Electrochemical Fundamentals</h3>
<p>Electroplating is a process of reducing and depositing metal ions on the cathode (workpiece) surface through electrolysis. Plating rate and film thickness follow Faraday's law.</p>
<p><strong>Faraday's First Law</strong>: Deposited metal mass is proportional to the amount of charge passed</p>
        $$
        m = \frac{M \cdot I \cdot t}{n \cdot F} \cdot \eta
        $$

        <p>Where:</p>
<ul>
<li>$m$: Deposited mass [g]</li>
<li>$M$: Atomic weight of metal [g/mol]</li>
<li>$I$: Current [A]</li>
<li>$t$: Plating time [s]</li>
<li>$n$: Number of electrons (e.g., 2 for Cu¬≤‚Å∫)</li>
<li>$F$: Faraday constant (96485 C/mol)</li>
<li>$\eta$: Current efficiency (typically 0.85-0.98)</li>
</ul>
<p>Plating thickness $d$ [Œºm] is calculated from deposited mass and density:</p>
        $$
        d = \frac{m}{\rho \cdot A} \times 10^4
        $$
        <p>$\rho$: Metal density [g/cm¬≥], $A$: Plating area [cm¬≤]</p>
<p><strong>Effect of Current Density</strong>:</p>
<ul>
<li><strong>Low current density</strong> (0.5-2 A/dm¬≤): Smooth, dense film, slow deposition</li>
<li><strong>High current density</strong> (5-20 A/dm¬≤): Rough film, dendritic growth, fast deposition</li>
</ul>
<p><strong>Throwing Power</strong>:</p>
<p>For complex-shaped parts, current density distribution becomes non-uniform, causing variations in film thickness. Throwing power is improved by bath composition, additives, and agitation.</p>
<h4>Code Example 3.1: Plating Thickness Calculation Using Faraday's Law</h4>
<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt

def calculate_plating_thickness(current_A, time_s, area_cm2,
                                 metal='Cu', efficiency=0.95):
    """
    Plating thickness calculation using Faraday's law

    Parameters:
    -----------
    current_A : float
        Current [A]
    time_s : float
        Plating time [s]
    area_cm2 : float
        Plating area [cm¬≤]
    metal : str
        Metal type ('Cu', 'Ni', 'Cr', 'Au', 'Ag')
    efficiency : float
        Current efficiency (0-1)

    Returns:
    --------
    thickness_um : float
        Plating thickness [Œºm]
    """
    # Metal property database
    metal_data = {
        'Cu': {'M': 63.55, 'n': 2, 'rho': 8.96},   # Copper
        'Ni': {'M': 58.69, 'n': 2, 'rho': 8.91},   # Nickel
        'Cr': {'M': 52.00, 'n': 3, 'rho': 7.19},   # Chromium
        'Au': {'M': 196.97, 'n': 1, 'rho': 19.32}, # Gold
        'Ag': {'M': 107.87, 'n': 1, 'rho': 10.49}  # Silver
    }

    F = 96485  # Faraday constant [C/mol]

    props = metal_data[metal]
    M = props['M']
    n = props['n']
    rho = props['rho']

    # Deposited mass [g]
    mass_g = (M * current_A * time_s * efficiency) / (n * F)

    # Plating thickness [Œºm]
    thickness_um = (mass_g / (rho * area_cm2)) * 1e4

    return thickness_um

# Example: Copper plating
current = 2.0      # 2A
time_hour = 1.0   # 1 hour
time_s = time_hour * 3600
area = 100.0       # 100cm¬≤

thickness = calculate_plating_thickness(current, time_s, area,
                                         metal='Cu', efficiency=0.95)

print(f"=== Copper Plating Process Calculation ===")
print(f"Current: {current} A")
print(f"Current density: {current/area*100:.2f} A/dm¬≤")
print(f"Plating time: {time_hour} hour")
print(f"Plating area: {area} cm¬≤")
print(f"Current efficiency: 95%")
print(f"‚û° Plating thickness: {thickness:.2f} Œºm")

# Plot: Plating time vs thickness
time_range = np.linspace(0, 2, 100) * 3600  # 0-2 hour
thicknesses = [calculate_plating_thickness(current, t, area, 'Cu', 0.95)
               for t in time_range]

plt.figure(figsize=(10, 6))
plt.plot(time_range/3600, thicknesses, linewidth=2, color='#f5576c')
plt.xlabel('Plating Time [hour]', fontsize=12)
plt.ylabel('Plating Thickness [Œºm]', fontsize=12)
plt.title('Copper Plating: Relationship Between Time and Thickness', fontsize=14, fontweight='bold')
plt.grid(True, alpha=0.3)
plt.tight_layout()
plt.show()

# Effect of current density
current_densities = np.linspace(0.5, 10, 50)  # 0.5-10 A/dm¬≤
area_dm2 = area / 100  # cm¬≤ ‚Üí dm¬≤
time_fixed = 3600  # 1 hour

thicknesses_cd = []
for cd in current_densities:
    I = cd * area_dm2
    thick = calculate_plating_thickness(I, time_fixed, area, 'Cu', 0.95)
    thicknesses_cd.append(thick)

plt.figure(figsize=(10, 6))
plt.plot(current_densities, thicknesses_cd, linewidth=2, color='#f093fb')
plt.axvspan(0.5, 2, alpha=0.2, color='green', label='Low current density (smooth)')
plt.axvspan(5, 10, alpha=0.2, color='red', label='High current density (rough)')
plt.xlabel('Current Density [A/dm¬≤]', fontsize=12)
plt.ylabel('Plating Thickness [Œºm]', fontsize=12)
plt.title('Relationship Between Current Density and Plating Thickness (1 hour)', fontsize=14, fontweight='bold')
plt.legend()
plt.grid(True, alpha=0.3)
plt.tight_layout()
plt.show()
</code></pre>
<h3>3.1.2 Plating Bath and Additives</h3>
<p>The composition of the plating bath has a decisive influence on film quality.</p>
<table>
<thead>
<tr>
<th>Bath Component</th>
<th>Role</th>
<th>Typical Concentration</th>
</tr>
</thead>
<tbody>
<tr>
<td>Metal salt (e.g., CuSO‚ÇÑ)</td>
<td>Metal ion supply</td>
<td>200-250 g/L</td>
</tr>
<tr>
<td>Conducting salt (e.g., H‚ÇÇSO‚ÇÑ)</td>
<td>Conductivity enhancement</td>
<td>50-80 g/L</td>
</tr>
<tr>
<td>Brightener</td>
<td>Smoothing, gloss imparting</td>
<td>Several ppm to several hundred ppm</td>
</tr>
<tr>
<td>Leveling agent</td>
<td>Unevenness flattening</td>
<td>Several ppm to tens of ppm</td>
</tr>
<tr>
<td>Surfactant</td>
<td>Hydrogen gas release promotion</td>
<td>Several ppm</td>
</tr>
</tbody>
</table>
<h4>Code Example 3.2: Current Distribution Simulation (2D Electrode)</h4>
<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
from scipy.ndimage import laplace

def simulate_current_distribution_2d(width=50, height=50,
                                      anode_position='top',
                                      cathode_position='bottom',
                                      iterations=500):
    """
    Current density distribution simulation for 2D electrode configuration
    Solve Laplace's equation using finite difference method

    Parameters:
    -----------
    width, height : int
        Calculation grid size
    anode_position : str
        Anode position ('top', 'bottom', 'left', 'right')
    cathode_position : str
        Cathode position ('top', 'bottom', 'left', 'right')
    iterations : int
        Number of iterations
    """
    # Initialize potential distribution
    phi = np.zeros((height, width))

    # Set boundary conditions
    if anode_position == 'top':
        phi[0, :] = 1.0  # Anode potential
    elif anode_position == 'bottom':
        phi[-1, :] = 1.0
    elif anode_position == 'left':
        phi[:, 0] = 1.0
    elif anode_position == 'right':
        phi[:, -1] = 1.0

    if cathode_position == 'top':
        phi[0, :] = 0.0  # Cathode potential
    elif cathode_position == 'bottom':
        phi[-1, :] = 0.0
    elif cathode_position == 'left':
        phi[:, 0] = 0.0
    elif cathode_position == 'right':
        phi[:, -1] = 0.0

    # Solve Laplace's equation iteratively (‚àá¬≤œÜ = 0)
    for _ in range(iterations):
        phi_new = phi.copy()
        phi_new[1:-1, 1:-1] = (phi[:-2, 1:-1] + phi[2:, 1:-1] +
                               phi[1:-1, :-2] + phi[1:-1, 2:]) / 4.0

        # Reapply boundary conditions
        if anode_position == 'top':
            phi_new[0, :] = 1.0
        elif anode_position == 'bottom':
            phi_new[-1, :] = 1.0

        if cathode_position == 'bottom':
            phi_new[-1, :] = 0.0
        elif cathode_position == 'top':
            phi_new[0, :] = 0.0

        phi = phi_new

    # Current density = -‚àáœÜ (proportional to potential gradient)
    grad_y, grad_x = np.gradient(phi)
    current_density = np.sqrt(grad_x**2 + grad_y**2)

    return phi, current_density

# Example: Top anode, bottom cathode
phi, j = simulate_current_distribution_2d(width=50, height=50,
                                           anode_position='top',
                                           cathode_position='bottom')

fig, axes = plt.subplots(1, 3, figsize=(15, 5))

# Potential distribution
im1 = axes[0].imshow(phi, cmap='viridis', origin='lower')
axes[0].set_title('Potential Distribution', fontsize=12, fontweight='bold')
axes[0].set_xlabel('X Position')
axes[0].set_ylabel('Y Position')
plt.colorbar(im1, ax=axes[0], label='Potential [V]')

# Current density distribution
im2 = axes[1].imshow(j, cmap='hot', origin='lower')
axes[1].set_title('Current Density Distribution', fontsize=12, fontweight='bold')
axes[1].set_xlabel('X Position')
axes[1].set_ylabel('Y Position')
plt.colorbar(im2, ax=axes[1], label='Current Density [a.u.]')

# Current density distribution on cathode surface
cathode_j = j[-1, :]  # Bottom edge (cathode)
axes[2].plot(cathode_j, linewidth=2, color='#f5576c')
axes[2].set_title('Current Density on Cathode Surface', fontsize=12, fontweight='bold')
axes[2].set_xlabel('X Position')
axes[2].set_ylabel('Current Density [a.u.]')
axes[2].grid(True, alpha=0.3)

# Uniformity evaluation
uniformity = (1 - (cathode_j.std() / cathode_j.mean())) * 100
axes[2].text(0.5, 0.95, f'Uniformity: {uniformity:.1f}%',
             transform=axes[2].transAxes,
             ha='center', va='top',
             bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.5))

plt.tight_layout()
plt.show()

print(f"Current density uniformity: {uniformity:.2f}%")
print(f"Max/Min current density ratio: {cathode_j.max()/cathode_j.min():.2f}")
</code></pre>
<h2>3.2 Anodizing</h2>
<h3>3.2.1 Principles of Aluminum Anodizing</h3>
<p>Anodizing is a process of electrochemically oxidizing a metal surface to form an oxide film. Aluminum anodizing (anodization) is a representative example.</p>
<p><strong>Anodizing Process</strong>:</p>
<ol>
<li>Immerse aluminum as anode and platinum as cathode in an electrolyte (sulfuric acid, oxalic acid, etc.)</li>
<li>Apply DC voltage to grow Al‚ÇÇO‚ÇÉ film on Al surface</li>
<li>Film has porous structure (barrier layer + porous layer)</li>
</ol>
<div class="mermaid">
flowchart TB
    subgraph "Anodizing Cell"
        A[Aluminum Anode]
        B[Electrolyte<br/>Sulfuric/Oxalic Acid]
        C[Platinum Cathode]
        D[DC Power Supply]
    end

    D --&gt;|Voltage Applied| A
    D --&gt; C
    A --&gt;|Al¬≥‚Å∫| B
    B --&gt;|O¬≤‚Åª| A
    A --&gt;|Al‚ÇÇO‚ÇÉ Formation| E[Oxide Film]

    E --&gt; F[Barrier Layer<br/>Dense, Thin]
    E --&gt; G[Porous Layer<br/>Porous, Thick]

    G --&gt; H[Sealing Treatment<br/>Hot Water/Steam]
    H --&gt; I[Final Film<br/>Improved Corrosion Resistance]

    style A fill:#f093fb,stroke:#f5576c,stroke-width:2px,color:#fff
    style E fill:#f5576c,stroke:#f093fb,stroke-width:2px,color:#fff
    style I fill:#22c55e,stroke:#15803d,stroke-width:2px,color:#fff
        </div>
<p><strong>Relationship Between Film Thickness and Voltage</strong>:</p>
<p>For sulfuric acid baths, the barrier layer thickness is approximately proportional to the applied voltage (empirical rule):</p>
        $$
        d_{\text{barrier}} \approx 1.4 \, [\text{nm/V}] \times V
        $$
        <p>The total film thickness (barrier layer + porous layer) depends on plating time and current density.</p>
<h4>Code Example 3.3: Anodizing Film Thickness vs Voltage Relationship</h4>
<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt

def anodization_thickness(voltage, material='Al',
                          electrolyte='H2SO4', time_min=30):
    """
    Anodizing film thickness calculation

    Parameters:
    -----------
    voltage : float or array
        Applied voltage [V]
    material : str
        Material ('Al', 'Ti')
    electrolyte : str
        Electrolyte ('H2SO4', 'H2C2O4')
    time_min : float
        Treatment time [min]

    Returns:
    --------
    barrier_thickness : float
        Barrier layer thickness [nm]
    total_thickness : float
        Total thickness [Œºm]
    """
    # Constants for material and electrolyte
    if material == 'Al':
        if electrolyte == 'H2SO4':
            k_barrier = 1.4  # nm/V (sulfuric acid bath)
            k_porous = 0.3   # Œºm/min at 1.5 A/dm¬≤
        elif electrolyte == 'H2C2O4':
            k_barrier = 1.0  # nm/V (oxalic acid bath)
            k_porous = 0.5   # Œºm/min
    elif material == 'Ti':
        k_barrier = 2.5  # nm/V (TiO‚ÇÇ)
        k_porous = 0.2   # Œºm/min

    # Barrier layer thickness [nm]
    barrier_thickness = k_barrier * voltage

    # Porous layer thickness [Œºm] (simple model)
    porous_thickness = k_porous * time_min

    # Total thickness [Œºm]
    total_thickness = (barrier_thickness / 1000) + porous_thickness

    return barrier_thickness, total_thickness
# Scan voltage range
voltages = np.linspace(10, 100, 100)
barrier_thicknesses = []
total_thicknesses = []

for V in voltages:
    d_barrier, d_total = anodization_thickness(V, 'Al', 'H2SO4', 30)
    barrier_thicknesses.append(d_barrier)
    total_thicknesses.append(d_total)

fig, axes = plt.subplots(1, 2, figsize=(14, 5))

# Barrier layer thickness vs Voltage
axes[0].plot(voltages, barrier_thicknesses, linewidth=2,
             color='#f5576c', label='Barrier layer')
axes[0].set_xlabel('Applied Voltage [V]', fontsize=12)
axes[0].set_ylabel('Barrier layer thickness [nm]', fontsize=12)
axes[0].set_title('Barrier layer thicknessvs Voltage (Al/Sulfuric acid bath)',
                  fontsize=14, fontweight='bold')
axes[0].grid(True, alpha=0.3)
axes[0].legend()

# Total thickness vs Voltage
axes[1].plot(voltages, total_thicknesses, linewidth=2,
             color='#f093fb', label='Total thickness (30min)')
axes[1].set_xlabel('Applied Voltage [V]', fontsize=12)
axes[1].set_ylabel('Total thickness [Œºm]', fontsize=12)
axes[1].set_title('Total thicknessvs Voltage (Al/Sulfuric acid bath)',
                  fontsize=14, fontweight='bold')
axes[1].grid(True, alpha=0.3)
axes[1].legend()

plt.tight_layout()
plt.show()

# Design exampleÔºö50nm Barrier layeris required
target_barrier = 50  # nm
required_voltage = target_barrier / 1.4
print(f"=== Anodizing Process Design ===")
print(f"targetBarrier layer thickness: {target_barrier} nm")
print(f"‚û° Required voltage: {required_voltage:.1f} V")

# Effect of time
times = np.linspace(10, 60, 50)  # 10-60min
total_thicknesses_time = []
for t in times:
    _, d_total = anodization_thickness(50, 'Al', 'H2SO4', t)
    total_thicknesses_time.append(d_total)

plt.figure(figsize=(10, 6))
plt.plot(times, total_thicknesses_time, linewidth=2, color='#f5576c')
plt.xlabel('Treatment Time [min]', fontsize=12)
plt.ylabel('Total thickness [Œºm]', fontsize=12)
plt.title('Anodizingfilm thicknessvs Treatment Time (50V, Sulfuric acid bath)',
          fontsize=14, fontweight='bold')
plt.grid(True, alpha=0.3)
plt.tight_layout()
plt.show()
</code></pre>
<h3>3.2.2 Sealing Treatment (Sealing)</h3>
<p>Post-treatment to close the pores in the porous layer and improve corrosion resistance„ÄÇ</p>
<ul>
<li><strong>Hot water sealing</strong>Ôºö95-100¬∞C pure water with 30-60min„ÄÅAl(OH)‚ÇÉ closes the pores</li>
<li><strong>Steam sealing</strong>Ôºö110¬∞C steam with 10-30min</li>
<li><strong>Cold sealing</strong>ÔºöNickel salt solution with room temperature (energy-saving)</li>
</ul>
<h2>3.3 Surface Modification Technologies</h2>
<h3>3.3.1 Ion Implantation (Ion Implantation)</h3>
<p>Ion Implantation is a technique that bombards the material surface with high-energy ions to modify chemical composition and crystal structure„ÄÇIt is used for doping in semiconductor manufacturing and surface hardening of metals„ÄÇ</p>
<p><strong>Ion Implantationprocess</strong>Ôºö</p>
<ol>
<li>Ion generation at ion source (e.g., N‚Å∫, B‚Å∫, P‚Å∫)</li>
<li>Acceleration to10-200 keVin acceleration field</li>
<li>Selection of desired ions by mass analyzer</li>
<li>Irradiation of sample in vacuum chamber</li>
</ol>
<p><strong>Concentration Profile (LSStheory)</strong>Ôºö</p>
<p>The concentration distribution after ion implantation is approximated by a Gaussian distributionÔºö</p>
        $$
        C(x) = \frac{\Phi}{\sqrt{2\pi} \Delta R_p} \exp\left(-\frac{(x - R_p)^2}{2 \Delta R_p^2}\right)
        $$

        <ul>
<li>$C(x)$: Depth $x$ at depth [atoms/cm¬≥]</li>
<li>$\Phi$: Dose (total ions/area) [ions/cm¬≤]</li>
<li>$R_p$: Range (peak depth) [nm]</li>
<li>$\Delta R_p$: Range straggling (standard deviation) [nm]</li>
</ul>
<h4>Code Example 3.4: Ion Implantation Concentration Profile (Gaussian LSS Theory)</h4>
<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
from scipy.special import erf

def ion_implantation_profile(energy_keV, dose_cm2, ion='N',
                              substrate='Si', depth_range=None):
    """
    Ion Implantation Concentration Profile Calculation (Gaussian Approximation)

    Parameters:
    -----------
    energy_keV : float
        Ion energy [keV]
    dose_cm2 : float
        Dose [ions/cm¬≤]
    ion : str
        Ion species ('N', 'B', 'P', 'As')
    substrate : str
        Substrate material ('Si', 'Fe', 'Ti')
    depth_range : array
        Depth range [nm] (auto-set if None)

    Returns:
    --------
    depth : array
        Depth [nm]
    concentration : array
        Concentration [atoms/cm¬≥]
    """
    # Simplified LSS theory parameters (empirical formulas)
    # In practice, use simulation tools like SRIM/TRIM

    # Ion mass
    ion_masses = {'N': 14, 'B': 11, 'P': 31, 'As': 75}
    M_ion = ion_masses[ion]

    # Substrate density and atomic weight
    substrate_data = {
        'Si': {'rho': 2.33, 'M': 28},
        'Fe': {'rho': 7.87, 'M': 56},
        'Ti': {'rho': 4.51, 'M': 48}
    }
    rho_sub = substrate_data[substrate]['rho']
    M_sub = substrate_data[substrate]['M']

    # Range Rp [nm] (simplified formula)
    Rp = 10 * energy_keV**0.7 * (M_sub / M_ion)**0.5

    # Range straggling ŒîRp [nm]
    delta_Rp = 0.3 * Rp

    if depth_range is None:
        depth_range = np.linspace(0, 3 * Rp, 500)

    # Gaussian concentration distribution
    concentration = (dose_cm2 / (np.sqrt(2 * np.pi) * delta_Rp)) * \
                    np.exp(-(depth_range - Rp)**2 / (2 * delta_Rp**2))

    return depth_range, concentration, Rp, delta_Rp

# Example: Nitrogen ion implantation into silicon
energy = 50  # keV
dose = 1e16  # ions/cm¬≤

depth, conc, Rp, delta_Rp = ion_implantation_profile(
    energy, dose, ion='N', substrate='Si'
)

plt.figure(figsize=(10, 6))
plt.plot(depth, conc, linewidth=2, color='#f5576c', label=f'{energy} keV, {dose:.0e} ions/cm¬≤')
plt.axvline(Rp, color='gray', linestyle='--', alpha=0.7, label=f'Rp = {Rp:.1f} nm')
plt.axvspan(Rp - delta_Rp, Rp + delta_Rp, alpha=0.2, color='orange',
            label=f'ŒîRp = {delta_Rp:.1f} nm')
plt.xlabel('Depth [nm]', fontsize=12)
plt.ylabel('Concentration [atoms/cm¬≥]', fontsize=12)
plt.title('Ion ImplantationConcentration Profile (N‚Å∫ ‚Üí Si)', fontsize=14, fontweight='bold')
plt.yscale('log')
plt.legend()
plt.grid(True, alpha=0.3)
plt.tight_layout()
plt.show()

# Energy dependence
energies = [30, 50, 100, 150]  # keV
plt.figure(figsize=(10, 6))
for E in energies:
    d, c, rp, drp = ion_implantation_profile(E, dose, 'N', 'Si')
    plt.plot(d, c, linewidth=2, label=f'{E} keV (Rp={rp:.1f} nm)')

plt.xlabel('Depth [nm]', fontsize=12)
plt.ylabel('Concentration [atoms/cm¬≥]', fontsize=12)
plt.title('Ion Implantation Energy and Concentration Profile', fontsize=14, fontweight='bold')
plt.yscale('log')
plt.legend()
plt.grid(True, alpha=0.3)
plt.tight_layout()
plt.show()

print(f"=== Ion Implantation Parameters ===")
print(f"Ion species: N‚Å∫")
print(f"Substrate: Si")
print(f"Energy: {energy} keV")
print(f"Dose: {dose:.0e} ions/cm¬≤")
print(f"‚û° range Rp: {Rp:.2f} nm")
print(f"‚û° Range straggling ŒîRp: {delta_Rp:.2f} nm")
print(f"‚û° Peak concentration: {conc.max():.2e} atoms/cm¬≥")
</code></pre>
<h3>3.3.2 Plasma Treatment (Plasma Treatment)</h3>
<p>Plasma breaks and modifies surface chemical bonds to improve wettability, adhesion, and biocompatibility„ÄÇ</p>
<ul>
<li><strong>Oxygen plasma</strong>ÔºöSurface hydrophilization, organic matter removal</li>
<li><strong>Argon plasma</strong>ÔºöSurface cleaning, activation</li>
<li><strong>Nitrogen plasma</strong>ÔºöSurface nitriding, hardness improvement</li>
</ul>
<h3>3.3.3 Laser Surface Melting (Laser Surface Melting)</h3>
<p>High-power laser rapidly heats, melts, and cools the surface to form fine grains or amorphous layers. Hardness and wear resistance are improved„ÄÇ</p>
<h2>3.4 Coating Technologies</h2>
<h3>3.4.1 Thermal Spray (Thermal Spray)</h3>
<p>Thermal Spray is a process that forms a coating layer by impacting molten or semi-molten particles at high velocity onto the substrate„ÄÇ</p>
<p><strong>Classification of Thermal Spray Methods</strong>Ôºö</p>
<ul>
<li><strong>Flame spray</strong>ÔºöParticle melting with acetylene/oxygen flame, inexpensive, medium adhesion</li>
<li><strong>Plasma spray</strong>ÔºöHigh-temperature plasma (10,000¬∞Chigh quality, ceramics possible</li>
<li><strong>High-Velocity Oxy-Fuel spray (HVOF)</strong>ÔºöSupersonic flame (Mach 2-3), high adhesion, high density</li>
<li><strong>Cold spray</strong>ÔºöSupersonic acceleration of particles in solid phase, low oxidation, metals and composites</li>
</ul>
<p><strong>Important Parameters</strong>Ôºö</p>
<ul>
<li><strong>Particle velocity</strong>Ôºö100-1200 m/s (varies by method)</li>
<li><strong>Particle temperature</strong>ÔºöNear melting point-3000¬∞C</li>
<li><strong>Adhesion strength</strong>ÔºöMechanical interlocking + metallic bonding + diffusion bonding</li>
</ul>
<h4>Code Example 3.5: Coating Adhesion Strength Prediction (Mechanical and Thermal Properties)</h4>
<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt

def predict_coating_adhesion(particle_velocity_ms,
                              particle_temp_C,
                              coating_material='WC-Co',
                              substrate_material='Steel'):
    """
    Coating Adhesion Strength Prediction (Simplified Model)

    Parameters:
    -----------
    particle_velocity_ms : float
        Particle velocity [m/s]
    particle_temp_C : float
        Particle temperature [¬∞C]
    coating_material : str
        Coating material
    substrate_material : str
        Substrate material

    Returns:
    --------
    adhesion_MPa : float
        Predicted adhesion strength [MPa]
    """
    # Material property database
    material_data = {
        'WC-Co': {'T_melt': 2870, 'rho': 14.5, 'E': 600},
        'Al2O3': {'T_melt': 2072, 'rho': 3.95, 'E': 380},
        'Ni': {'T_melt': 1455, 'rho': 8.9, 'E': 200},
        'Steel': {'T_melt': 1500, 'rho': 7.85, 'E': 210}
    }

    coating_props = material_data[coating_material]
    substrate_props = material_data[substrate_material]

    # Simplified adhesion strength model (empirical formula)
    # adhesion ‚àù v^a * (T/Tm)^b

    # Velocity contribution (kinetic energy ‚Üí plastic deformation)
    v_factor = (particle_velocity_ms / 500)**1.5  # Normalized

    # Temperature contribution (diffusion bonding promotion)
    T_ratio = particle_temp_C / coating_props['T_melt']
    T_factor = T_ratio**0.8

    # Young's modulus compatibility (large difference is disadvantageous)
    E_ratio = min(coating_props['E'], substrate_props['E']) / \
              max(coating_props['E'], substrate_props['E'])
    E_factor = E_ratio**0.5

    # Base adhesion strength (material-dependent)
    base_adhesion = 30  # MPa

    # Total adhesion strength [MPa]
    adhesion_MPa = base_adhesion * v_factor * T_factor * E_factor

    return adhesion_MPa

# Parameter scan: Effect of particle velocity
velocities = np.linspace(100, 1000, 50)  # m/s
temp_fixed = 2000  # ¬∞C

adhesions_wc = []
adhesions_al2o3 = []

for v in velocities:
    adh_wc = predict_coating_adhesion(v, temp_fixed, 'WC-Co', 'Steel')
    adh_al2o3 = predict_coating_adhesion(v, temp_fixed, 'Al2O3', 'Steel')
    adhesions_wc.append(adh_wc)
    adhesions_al2o3.append(adh_al2o3)

plt.figure(figsize=(10, 6))
plt.plot(velocities, adhesions_wc, linewidth=2,
         color='#f5576c', label='WC-Co coating')
plt.plot(velocities, adhesions_al2o3, linewidth=2,
         color='#f093fb', label='Al‚ÇÇO‚ÇÉ coating')
plt.xlabel('Particle velocity [m/s]', fontsize=12)
plt.ylabel('Predicted adhesion strength [MPa]', fontsize=12)
plt.title('Thermal Spray: Particle Velocity and Coating Adhesion Strength', fontsize=14, fontweight='bold')
plt.legend()
plt.grid(True, alpha=0.3)
plt.tight_layout()
plt.show()

# Parameter scan: Effect of particle temperature
temps = np.linspace(1000, 2800, 50)  # ¬∞C
vel_fixed = 600  # m/s

adhesions_temp = []
for T in temps:
    adh = predict_coating_adhesion(vel_fixed, T, 'WC-Co', 'Steel')
    adhesions_temp.append(adh)

plt.figure(figsize=(10, 6))
plt.plot(temps, adhesions_temp, linewidth=2, color='#f5576c')
plt.xlabel('Particle temperature [¬∞C]', fontsize=12)
plt.ylabel('Predicted adhesion strength [MPa]', fontsize=12)
plt.title('Thermal Spray: Particle Temperature and Coating Adhesion Strength (WC-Co)', fontsize=14, fontweight='bold')
plt.grid(True, alpha=0.3)
plt.tight_layout()
plt.show()

# Optimization example
v_opt = 800  # m/s
T_opt = 2500  # ¬∞C
adh_opt = predict_coating_adhesion(v_opt, T_opt, 'WC-Co', 'Steel')

print(f"=== Thermal Spray Process Optimization ===")
print(f"Coating material: WC-Co")
print(f"Substrate material: Steel")
print(f"Optimal particle velocity: {v_opt} m/s")
print(f"Optimal particle temperature: {T_opt} ¬∞C")
print(f"‚û° Predicted adhesion strength: {adh_opt:.2f} MPa")
</code></pre>
<h3>3.4.2 PVD/CVD Basics</h3>
<p><strong>PVD (Physical Vapor Deposition)</strong>ÔºöThin film formation by physical evaporation and sputtering (details in Chapter 5)</p>
<p><strong>CVD (Chemical Vapor Deposition)</strong>ÔºöThin film formation by chemical reactions (details in Chapter 5)</p>
<p>In the context of surface treatment, these are used for hard coatings such as TiN (titanium nitride), CrN (chromium nitride), and DLC (diamond-like carbon)„ÄÇ</p>
<h3>3.4.3 Sol-Gel Coating (Sol-Gel Coating)</h3>
<p>Sol-gel method is a technique to form oxide thin films by gelation and sintering from liquid phase„ÄÇ</p>
<ul>
<li><strong>Advantages</strong>ÔºöLow-temperature process, large-area compatible, porous films possible, easy composition control</li>
<li><strong>Applications</strong>ÔºöAnti-reflection films, corrosion-resistant films, catalyst supports, optical films</li>
</ul>
<h4>Code Example 3.6: Thermal Spray Particle Temperature and Velocity Modeling</h4>
<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt

def thermal_spray_particle_dynamics(particle_diameter_um,
                                      material='WC-Co',
                                      spray_method='HVOF',
                                      distance_mm=150):
    """
    Thermal Spray Particle Temperature and Velocity Change Model During Flight

    Parameters:
    -----------
    particle_diameter_um : float
        Particle diameter [Œºm]
    material : str
        Particle material
    spray_method : str
        Spray method ('Flame', 'Plasma', 'HVOF')
    distance_mm : float
        Spray distance [mm]

    Returns:
    --------
    velocity : array
        Velocity [m/s]
    temperature : array
        Temperature [K]
    distance : array
        Distance [mm]
    """
    # Material properties
    material_props = {
        'WC-Co': {'rho': 14500, 'Cp': 200, 'T_melt': 2870 + 273},
        'Al2O3': {'rho': 3950, 'Cp': 880, 'T_melt': 2072 + 273},
        'Ni': {'rho': 8900, 'Cp': 444, 'T_melt': 1455 + 273}
    }
    props = material_props[material]

    # Initial conditions for each spray method
    initial_conditions = {
        'Flame': {'v0': 100, 'T0': 2500 + 273},
        'Plasma': {'v0': 300, 'T0': 10000 + 273},
        'HVOF': {'v0': 800, 'T0': 2800 + 273}
    }
    ic = initial_conditions[spray_method]

    # Distance range
    distance = np.linspace(0, distance_mm, 500)

    # Simple drag model (velocity decay)
    drag_coeff = 0.44  # Spherical particle
    air_rho = 1.2  # kg/m¬≥
    particle_mass = (4/3) * np.pi * (particle_diameter_um/2 * 1e-6)**3 * props['rho']
    particle_area = np.pi * (particle_diameter_um/2 * 1e-6)**2

    # Velocity decay constant
    k_v = (0.5 * drag_coeff * air_rho * particle_area) / particle_mass
    velocity = ic['v0'] * np.exp(-k_v * distance * 1e-3)

    # Temperature decay (convective cooling)
    h = 100  # Heat transfer coefficient [W/m¬≤K]
    T_air = 300  # Air temperature [K]
    surface_area = 4 * np.pi * (particle_diameter_um/2 * 1e-6)**2

    # Temperature decay constant
    k_T = (h * surface_area) / (particle_mass * props['Cp'])
    temperature = T_air + (ic['T0'] - T_air) * np.exp(-k_T * distance * 1e-3 / velocity[0])

    return velocity, temperature - 273, distance  # Convert temperature to ¬∞C

# Example: HVOF spray with WC-Co particles
v, T, d = thermal_spray_particle_dynamics(40, 'WC-Co', 'HVOF', 150)

fig, axes = plt.subplots(2, 1, figsize=(10, 10))

# Velocity profile
axes[0].plot(d, v, linewidth=2, color='#f5576c')
axes[0].set_xlabel('Spray distance [mm]', fontsize=12)
axes[0].set_ylabel('Particle velocity [m/s]', fontsize=12)
axes[0].set_title('Thermal Spray Particle Velocity Profile (HVOF, WC-Co, 40Œºm)',
                  fontsize=14, fontweight='bold')
axes[0].grid(True, alpha=0.3)

# Temperature profile
axes[1].plot(d, T, linewidth=2, color='#f093fb')
axes[1].axhline(2870, color='red', linestyle='--', alpha=0.7, label='WC-Comelting point')
axes[1].set_xlabel('Spray distance [mm]', fontsize=12)
axes[1].set_ylabel('Particle temperature [¬∞C]', fontsize=12)
axes[1].set_title('Thermal Spray Particle Temperature Profile', fontsize=14, fontweight='bold')
axes[1].legend()
axes[1].grid(True, alpha=0.3)

plt.tight_layout()
plt.show()

# Particle state upon substrate arrival
v_impact = v[-1]
T_impact = T[-1]
print(f"=== Particle State Upon Substrate Arrival ===")
print(f"Spray distance: {d[-1]:.1f} mm")
print(f"Impact velocity: {v_impact:.1f} m/s")
print(f"Arrival temperature: {T_impact:.1f} ¬∞C")
print(f"Melting state: {'Molten' if T_impact &gt; 2870 else 'Solid phase'}")

# Comparison of multiple particle sizes
diameters = [20, 40, 60, 80]  # Œºm
plt.figure(figsize=(10, 6))
for dia in diameters:
    v_d, T_d, d_d = thermal_spray_particle_dynamics(dia, 'WC-Co', 'HVOF', 150)
    plt.plot(d_d, v_d, linewidth=2, label=f'{dia} Œºm')

plt.xlabel('Spray distance [mm]', fontsize=12)
plt.ylabel('Particle velocity [m/s]', fontsize=12)
plt.title('Velocity Profile Differences by Particle Size (HVOF, WC-Co)',
          fontsize=14, fontweight='bold')
plt.legend()
plt.grid(True, alpha=0.3)
plt.tight_layout()
plt.show()
</code></pre>
<h2>3.5 Surface Treatment Technology Selection</h2>
<h3>3.5.1 Required Properties and Technology Correspondence</h3>
<table>
<thead>
<tr>
<th>Required Property</th>
<th>Suitable Technology</th>
<th>Characteristics</th>
</tr>
</thead>
<tbody>
<tr>
<td>Corrosion resistance</td>
<td>Plating (Ni, Cr)„ÄÅAnodizing</td>
<td>Chemical barrier layer formation</td>
</tr>
<tr>
<td>Wear resistance</td>
<td>Thermal Spray (WC-Co)„ÄÅPVD (TiN, CrN)</td>
<td>High hardness layer formation</td>
</tr>
<tr>
<td>Decorative (appearance)</td>
<td>Plating (Au, Ag, Ni-Cr)„ÄÅAnodizing</td>
<td>Gloss, coloration</td>
</tr>
<tr>
<td>Conductivity</td>
<td>Plating (Cu, Ag, Au)</td>
<td>Low resistance contact</td>
</tr>
<tr>
<td>Biocompatibility</td>
<td>Plasma Treatment„ÄÅAnodizing (Ti)</td>
<td>Surface hydrophilization, oxide layer</td>
</tr>
<tr>
<td>Thermal insulation</td>
<td>Thermal Spray (ceramics)</td>
<td>Low thermal conductivity</td>
</tr>
<tr>
<td>Surface hardening</td>
<td>Ion Implantation (N‚Å∫), laser treatment</td>
<td>No substrate deformation</td>
</tr>
</tbody>
</table>
<h3>3.5.2 Technology Selection Flowchart</h3>
<div class="mermaid">
flowchart TD
    A[Surface treatment requirements] --&gt; B{Main required properties?}

    B --&gt;|Corrosion resistance| C{Film thickness requirements}
    C --&gt;|Thin film<br/>1-10Œºm| D[Anodizing]
    C --&gt;|thick films<br/>10-100Œºm| E[Plating<br/>Ni/Cr]

    B --&gt;|Wear resistance| F{Operating temperature}
    F --&gt;|Room temperature-300¬∞C| G[PVD/CVD<br/>TiN, CrN]
    F --&gt;|300¬∞C or higher| H[Thermal Spray<br/>WC-Co]

    B --&gt;|Decorative properties| I{Conductivity required?}
    I --&gt;|Required| J[Plating<br/>Au/Ag]
    I --&gt;|Not required| K[Anodizing<br/>coloring]

    B --&gt;|Conductivity| L[Plating<br/>Cu/Ag/Au]

    B --&gt;|Biocompatibility| M[Plasma Treatment<br/>or TiAnodizing]

    B --&gt;|Surface hardening| N{Substrate heating OK?}
    N --&gt;|NG| O[Ion Implantation]
    N --&gt;|OK| P[Laser treatment<br/>or Thermal Spray]

    style A fill:#f093fb,stroke:#f5576c,stroke-width:2px,color:#fff
    style D fill:#22c55e,stroke:#15803d,stroke-width:2px,color:#fff
    style E fill:#22c55e,stroke:#15803d,stroke-width:2px,color:#fff
    style G fill:#22c55e,stroke:#15803d,stroke-width:2px,color:#fff
    style H fill:#22c55e,stroke:#15803d,stroke-width:2px,color:#fff
    style J fill:#22c55e,stroke:#15803d,stroke-width:2px,color:#fff
    style K fill:#22c55e,stroke:#15803d,stroke-width:2px,color:#fff
    style L fill:#22c55e,stroke:#15803d,stroke-width:2px,color:#fff
    style M fill:#22c55e,stroke:#15803d,stroke-width:2px,color:#fff
    style O fill:#22c55e,stroke:#15803d,stroke-width:2px,color:#fff
    style P fill:#22c55e,stroke:#15803d,stroke-width:2px,color:#fff
        </div>
<h4>Code Example 3.7: Surface Treatment Process Comprehensive Workflow (Parameter Optimization)</h4>
<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import minimize

class SurfaceTreatmentOptimizer:
    """
    Surface treatment process parameter optimization class
    """
    def __init__(self, treatment_type='electroplating'):
        self.treatment_type = treatment_type

    def objective_function(self, params, targets):
        """
        Objective function: Minimize error from target properties

        Parameters:
        -----------
        params : array
            Process parameters (varies by method)
        targets : dict
            Target property value

        Returns:
        --------
        error : float
            Error (smaller is better)
        """
        if self.treatment_type == 'electroplating':
            # Parameters: [Current density A/dm¬≤, Plating time h, efficiency]
            current_density, time_h, efficiency = params
            area_dm2 = 1.0  # Normalized

            # PlatingThicknessCalculation
            current_A = current_density * area_dm2
            thickness = calculate_plating_thickness(
                current_A, time_h * 3600, area_dm2 * 100, 'Cu', efficiency
            )

            # ErrorCalculation
            error_thickness = (thickness - targets['thickness'])**2

            # Constraint penalty (film quality deteriorates if current density is too high)
            penalty = 0
            if current_density &gt; 5.0:
                penalty += 100 * (current_density - 5.0)**2
            if current_density &lt; 0.5:
                penalty += 100 * (0.5 - current_density)**2

            return error_thickness + penalty

        elif self.treatment_type == 'anodizing':
            # Parameters: [Voltage V, Time min]
            voltage, time_min = params

            # film thicknessCalculation
            _, thickness = anodization_thickness(voltage, 'Al', 'H2SO4', time_min)

            error_thickness = (thickness - targets['thickness'])**2

            # Constraint penalty
            penalty = 0
            if voltage &gt; 100:
                penalty += 100 * (voltage - 100)**2

            return error_thickness + penalty

        else:
            return 0

    def optimize(self, targets, initial_guess):
        """
        Optimization execution
        """
        result = minimize(
            lambda p: self.objective_function(p, targets),
            initial_guess,
            method='Nelder-Mead',
            options={'maxiter': 1000}
        )

        return result

# Example 1: Plating process optimization
print("=== Electroplating Process Optimization ===")
optimizer_plating = SurfaceTreatmentOptimizer('electroplating')

targets_plating = {
    'thickness': 20.0  # target20Œºm
}

initial_guess_plating = [2.0, 1.0, 0.95]  # [Current density, time, efficiency]

result_plating = optimizer_plating.optimize(targets_plating, initial_guess_plating)

print(f"targetPlatingThickness: {targets_plating['thickness']} Œºm")
print(f"Optimal parameters:")
print(f"  Current density: {result_plating.x[0]:.2f} A/dm¬≤")
print(f"  Plating time: {result_plating.x[1]:.2f} hour")
print(f"  Current efficiency: {result_plating.x[2]:.3f}")

# Achieved film thickness
achieved_thickness = calculate_plating_thickness(
    result_plating.x[0], result_plating.x[1] * 3600, 100, 'Cu', result_plating.x[2]
)
print(f"‚û° Achieved thickness: {achieved_thickness:.2f} Œºm")
print(f"  Error: {abs(achieved_thickness - targets_plating['thickness']):.2f} Œºm")

# Example 2: Anodizing process optimization
print("\n=== Anodizing Process Optimization ===")
optimizer_anodizing = SurfaceTreatmentOptimizer('anodizing')

targets_anodizing = {
    'thickness': 15.0  # target15Œºm
}

initial_guess_anodizing = [50.0, 30.0]  # [Voltage V, hour min]

result_anodizing = optimizer_anodizing.optimize(targets_anodizing, initial_guess_anodizing)

print(f"targetfilm thickness: {targets_anodizing['thickness']} Œºm")
print(f"Optimal parameters:")
print(f"  Voltage: {result_anodizing.x[0]:.1f} V")
print(f"  Treatment Time: {result_anodizing.x[1]:.1f} min")

# Achieved film thickness
_, achieved_thickness_anodizing = anodization_thickness(
    result_anodizing.x[0], 'Al', 'H2SO4', result_anodizing.x[1]
)
print(f"‚û° Achieved thickness: {achieved_thickness_anodizing:.2f} Œºm")
print(f"  Error: {abs(achieved_thickness_anodizing - targets_anodizing['thickness']):.2f} Œºm")

# Parameter sensitivity analysis (plating)
current_densities_scan = np.linspace(0.5, 5.0, 30)
times_scan = np.linspace(0.5, 2.5, 30)

CD, T = np.meshgrid(current_densities_scan, times_scan)
Thickness = np.zeros_like(CD)

for i in range(len(times_scan)):
    for j in range(len(current_densities_scan)):
        cd = CD[i, j]
        t = T[i, j]
        thick = calculate_plating_thickness(cd, t * 3600, 100, 'Cu', 0.95)
        Thickness[i, j] = thick

plt.figure(figsize=(10, 7))
contour = plt.contourf(CD, T, Thickness, levels=20, cmap='viridis')
plt.colorbar(contour, label='PlatingThickness [Œºm]')
plt.contour(CD, T, Thickness, levels=[20], colors='red', linewidths=2)
plt.scatter([result_plating.x[0]], [result_plating.x[1]],
            color='red', s=200, marker='*', edgecolors='white', linewidths=2,
            label='Optimal point')
plt.xlabel('Current density [A/dm¬≤]', fontsize=12)
plt.ylabel('Plating time [hour]', fontsize=12)
plt.title('Plating Process Parameter Map (target 20Œºm)', fontsize=14, fontweight='bold')
plt.legend()
plt.grid(True, alpha=0.3)
plt.tight_layout()
plt.show()
</code></pre>
<h2>3.6 Practice Exercises</h2>
<div class="exercise-box">
<h4>Exercise3.1 (Easy): PlatingThicknessCalculation</h4>
<p>In a copper plating process, calculate the plating thickness under the conditions of 2A current, 1 hour plating time, 100cm¬≤ plating area, and 95% current efficiency.</p>
<details class="solution-box">
<summary>Show Solution</summary>
<p><strong>Calculation Procedure</strong>:</p>
<ol>
<li>Faraday's law: $m = \frac{M \cdot I \cdot t}{n \cdot F} \cdot \eta$</li>
<li>Copper parameters: M = 63.55 g/mol, n = 2, œÅ = 8.96 g/cm¬≥</li>
<li>$m = \frac{63.55 \times 2.0 \times 3600}{2 \times 96485} \times 0.95 = 2.25$ g</li>
<li>$d = \frac{2.25}{8.96 \times 100} \times 10^4 = 25.1$ Œºm</li>
</ol>
<p><strong>Answer</strong>: PlatingThickness = 25.1 Œºm</p>
<pre><code class="language-python">thickness = calculate_plating_thickness(2.0, 3600, 100, 'Cu', 0.95)
print(f"PlatingThickness: {thickness:.2f} Œºm")  # 25.11 Œºm
</code></pre>
</details>
</div>
<div class="exercise-box">
<h4>Exercise 3.2 (Easy): Anodizing Voltage Determination</h4>
<p>In aluminum anodizing, we want to form a 50nm barrier layer. When using a sulfuric acid bath, find the required applied voltage (empirical rule: 1.4 nm/V).</p>
<details class="solution-box">
<summary>Show Solution</summary>
<p><strong>Calculation</strong>:</p>
<p>$V = \frac{d_{\text{barrier}}}{k} = \frac{50}{1.4} = 35.7$ V</p>
<p><strong>Answer</strong>: Required voltage = 35.7 V (in practice36-40V)</p>
</details>
</div>
<div class="exercise-box">
<h4>Exercise3.3 (Easy): Surface Treatment Technology Selection</h4>
<p>We want to provide corrosion resistance and wear resistance to aircraft engine parts (titanium alloy). The temperature reaches 300-600¬∞C. Select an appropriate surface treatment technology and explain the reason.</p>
<details class="solution-box">
<summary>Show Solution</summary>
<p><strong>Recommended technology</strong>: Thermal spray (plasma spray or HVOF) with ceramic coating (Al‚ÇÇO‚ÇÉ or YSZ)</p>
<p><strong>Reason</strong>:</p>
<ul>
<li>Plating and anodizing are unsuitable in high-temperature environments (300-600¬∞C)</li>
<li>ceramic coatingare resistant to high-temperature oxidation</li>
<li>Thermal Spray thick films (100-500Œºm)can formWear resistanceare excellent for</li>
<li>HVOFmethod has high adhesion and is suitable for high-speed rotating parts</li>
</ul>
</details>
</div>
<div class="exercise-box">
<h4>Exercise3.4 (Medium): Improving Throwing Power</h4>
<p>In plating of complex-shaped parts, the plating thickness is non-uniform with 25Œºm on convex areas and 15Œºm in concave areas. Propose three methods to improve uniformity and explain the effects of each.</p>
<details class="solution-box">
<summary>Show Solution</summary>
<p><strong>Improvement Methods</strong>:</p>
<ol>
<li><strong>Current density reduction</strong>
<ul>
<li>Effect: Homogenization of potential distribution, transition to diffusion-controlled regime</li>
<li>Implementation: 2 A/dm¬≤ ‚Üí 0.8 A/dm¬≤reduction, compensate with extended plating time</li>
</ul>
</li>
<li><strong>Add leveling agent</strong>
<ul>
<li>Effect: Selectively suppress deposition rate on convex areas, preferential deposition in concave areas</li>
<li>Implementation: Add thiourea etc. at several ppm</li>
</ul>
</li>
<li><strong>Enhanced bath agitation</strong>
<ul>
<li>Effect: Homogenization of metal ion diffusion layer thickness</li>
<li>Implementation: Aeration, sample rotation, pump circulation</li>
</ul>
</li>
</ol>
<p><strong>Expected effect</strong>: Thickness ratio 25:15 ‚Üí 22:18 range (uniformity 60% ‚Üí 82%)</p>
</details>
</div>
<div class="exercise-box">
<h4>Exercise 3.5 (Medium): Ion Implantation Dose Calculation</h4>
<p>Implant nitrogen ions into a silicon substrate to achieve a peak concentration of 5√ó10¬≤‚Å∞ atoms/cm¬≥ at a depth of 50nm from the silicon substrate surface. For an energy of 50 keV (Rp = 80 nm, ŒîRp = 24 nm), calculate the required dose.</p>
<details class="solution-box">
<summary>Show Solution</summary>
<p><strong>Calculation Procedure</strong>:</p>
<p>Gaussian distribution at peak concentration (x = Rp):</p>
<p>$$C_{\text{peak}} = \frac{\Phi}{\sqrt{2\pi} \Delta R_p}$$</p>
<p>In the problem, x = 50 nm ‚â† Rp = 80 nm, so:</p>
<p>$$C(50) = \frac{\Phi}{\sqrt{2\pi} \cdot 24} \exp\left(-\frac{(50 - 80)^2}{2 \times 24^2}\right)$$</p>
<p>$$5 \times 10^{20} = \frac{\Phi}{\sqrt{2\pi} \cdot 24 \times 10^{-7}} \times 0.557$$</p>
<p>$$\Phi = \frac{5 \times 10^{20} \times \sqrt{2\pi} \times 24 \times 10^{-7}}{0.557} = 1.7 \times 10^{16} \text{ ions/cm}^2$$</p>
<p><strong>Answer</strong>: Dose = 1.7√ó10¬π‚Å∂ ions/cm¬≤</p>
</details>
</div>
<div class="exercise-box">
<h4>Exercise 3.6 (Medium): Thermal Spray Process Parameter Selection</h4>
<p>Apply WC-Co coating by HVOF spray. Under the conditions of particle size 40Œºm and spray distance 150mm, verify that the particle velocity and temperature upon substrate arrival are 600 m/s or higher and 2500¬∞C or higher. Using code example 3.6, verify if these conditions are met, and if not, propose improvement measures.</p>
<details class="solution-box">
<summary>Show Solution</summary>
<p><strong>Verification</strong>:</p>
<pre><code class="language-python">v, T, d = thermal_spray_particle_dynamics(40, 'WC-Co', 'HVOF', 150)
print(f"Impact velocity: {v[-1]:.1f} m/s")  # approximately 650 m/s ‚úì
print(f"Arrival temperature: {T[-1]:.1f} ¬∞C")   # approximately 2400 ¬∞C ‚úó
</code></pre>
<p><strong>Judgment</strong>: Velocity is satisfied, but temperature is insufficient (2400¬∞C &lt; 2500¬∞C)</p>
<p><strong>Improvement Measures</strong>:</p>
<ol>
<li><strong>Spray distance reduction</strong>: 150 mm ‚Üí 120 mm to reduce temperature loss</li>
<li><strong>Reduce particle size</strong>: 40 Œºm ‚Üí 30 Œºmreduces cooling rate (heat capacity/surface area ratio‚Üë)</li>
<li><strong>Initial temperature increase</strong>: Adjust fuel/oxygen ratio, enhance preheating</li>
</ol>
<p><strong>Final recommendation</strong>: Spray distance 120 mm + particle size 35 Œºm ‚Üí arrival temperature approximately 2550¬∞C (target achieved)</p>
</details>
</div>
<div class="exercise-box">
<h4>Exercise3.7 (Hard): Multi-layer Coating Design</h4>
<p>We want to provide both wear resistance and corrosion resistance to automotive engine parts (steel). Design a multi-layer coating under the following conditions:</p>
<ul>
<li>Innermost layer: Adhesion layer (thin film)</li>
<li>Middle layer: Wear-resistant layer (thick film)</li>
<li>Outermost layer: Corrosion-resistant layer (medium film)</li>
</ul>
<p>Select the material, thickness, and method for each layer, and explain the design rationale.</p>
<details class="solution-box">
<summary>Show Solution</summary>
<p><strong>Multi-layer Coating Design</strong>:</p>
<table>
<thead>
<tr>
<th>layer</th>
<th>Material</th>
<th>Thickness</th>
<th>Method</th>
<th>Reason</th>
</tr>
</thead>
<tbody>
<tr>
<td>Adhesion layer</td>
<td>Ni</td>
<td>5Œºm</td>
<td>Electroplating</td>
<td>Good adhesion to steel, stress relaxation</td>
</tr>
<tr>
<td>Wear-resistant layer</td>
<td>WC-Co</td>
<td>150Œºm</td>
<td>HVOF spray</td>
<td>High hardness (HV1200)„ÄÅWear resistance</td>
</tr>
<tr>
<td>Corrosion-resistant layer</td>
<td>Cr‚ÇÉC‚ÇÇ-NiCr</td>
<td>50Œºm</td>
<td>HVOF spray</td>
<td>Oxidation resistance, high-temperature corrosion resistance</td>
</tr>
</tbody>
</table>
<p><strong>Process Sequence</strong>:</p>
<ol>
<li>Steel substrate pretreatment (degreasing, sandblasting, Ra = 3-5Œºm)</li>
<li>Electroplating with NiAdhesion layer (Current density2 A/dm¬≤, 1hour)</li>
<li>HVOF spray WC-Co layer (particle size 30Œºm, spray distance 120mm, velocity 800m/s)</li>
<li>HVOF spray Cr‚ÇÉC‚ÇÇ-NiCr layer (particle size 40Œºm, spray distance 150mm)</li>
<li>Post-treatment (polishing, sealing as needed)</li>
</ol>
<p><strong>Expected Performance</strong>:</p>
<ul>
<li>Wear resistance: Coefficient of friction0.3„ÄÅwear rate &lt; 10‚Åª‚Å∂ mm¬≥/Nm</li>
<li>Corrosion resistance: Salt spray test1000hour</li>
<li>Adhesion strength: &gt; 50 MPa</li>
</ul>
</details>
</div>
<div class="exercise-box">
<h4>Exercise3.8 (Hard): Process Troubleshooting</h4>
<p>The following defects occurred in the copper plating process. Propose the causes and countermeasures for each defect:</p>
<ul>
<li><strong>Defect A</strong>: Many small protrusions (nodules) appeared on the plating surface</li>
<li><strong>DefectB</strong>: PlatingThickness target20Œºmagainst target12Œºmonly achieves</li>
<li><strong>Defect C</strong>: Peeling occurred in the adhesion test (tape test) after plating</li>
</ul>
<details class="solution-box">
<summary>Show Solution</summary>
<p><strong>Defect A: Nodules (Surface Protrusions)</strong></p>
<p><strong>Candidate Causes</strong>:</p>
<ul>
<li>Impurities and particles in the plating bath (dust, other metal ions)</li>
<li>Insufficient bath filtration</li>
<li>Dendritic growth due to excessive current density</li>
</ul>
<p><strong>Countermeasures</strong>:</p>
<ol>
<li>Plating bath filtration (5Œºm cartridge filter, 24-hour circulation)</li>
<li>Activated carbon treatment of anode (impurity removal)</li>
<li>Current density reduction (5 A/dm¬≤ ‚Üí 2 A/dm¬≤)</li>
<li>Strengthen sample pretreatment (degreasing ‚Üí pickling ‚Üí pure water rinse)</li>
</ol>
<p><strong>DefectB: Insufficient Film Thickness</strong></p>
<p><strong>Candidate Causes</strong>:</p>
<ul>
<li>Decrease in current efficiency (due to side reactions)</li>
<li>Insufficient metal ion concentration</li>
<li>Actual current value lower than set value</li>
</ul>
<p><strong>Verification</strong>:</p>
<pre><code class="language-python"># Theoretical thickness (efficiency 95%)
d_theoretical = calculate_plating_thickness(2.0, 3600, 100, 'Cu', 0.95)
print(f"theoryfilm thickness: {d_theoretical:.1f} Œºm")  # 25.1 Œºm

# Current efficiency back-calculated from actual 12Œºm
actual_efficiency = 12 / d_theoretical * 0.95
print(f"Actual current efficiency: {actual_efficiency:.1%}")  # approximately 45% (significant decrease)
</code></pre>
<p><strong>Countermeasures</strong>:</p>
<ol>
<li>Bath composition analysis (CuSO‚ÇÑConcentration„ÄÅH‚ÇÇSO‚ÇÑConcentration)‚Üí replenish if insufficient</li>
<li>Check ammeter calibration</li>
<li>Check bath temperature (current efficiency decreases at low temperature) ‚Üí maintain at 25¬±2¬∞C</li>
<li>Check balance of anode and cathode area (1:1-2:1is ideal)</li>
</ol>
<p><strong>Defect C: Adhesion defect</strong></p>
<p><strong>Candidate Causes</strong>:</p>
<ul>
<li>Contamination on substrate surface (oils, oxide film)</li>
<li>Insufficient pretreatment</li>
<li>Stress due to thermal expansion coefficient mismatch with substrate</li>
</ul>
<p><strong>Countermeasures</strong>:</p>
<ol>
<li>Review pretreatment process
                        <ul>
<li>Degreasing: Alkaline degreasing (60¬∞C, 10min) + ultrasonic cleaning</li>
<li>Pickling: 10% H‚ÇÇSO‚ÇÑ (room temperature, 1min) for oxide film removal</li>
<li>Activation: 5% HCl (room temperature, 30 seconds) immediate pretreatment</li>
</ul>
</li>
<li>Strike plating (thin Ni or Cu layer) to improve adhesion</li>
<li>Post-plating baking (150¬∞C, 1 hour) to remove hydrogen embrittlement and improve adhesion</li>
</ol>
<p><strong>Verification method</strong>:</p>
<ul>
<li>Adhesion test: JIS H8504 (cross-cut ‚Üí tape test)</li>
<li>Tensile test: ASTM B571 (tensile adhesion strength &gt; 20 MPa target)</li>
</ul>
</details>
</div>
<h2>3.7 Learning Confirmation Checklist</h2>
<h3>Basic Understanding (5 items)</h3>
<ul>
<li>‚ñ° Can calculate plating thickness using Faraday's law</li>
<li>‚ñ° Can explain the difference between barrier layer and porous layer in anodizing</li>
<li>‚ñ° Ion ImplantationUnderstand the relationship between range and dose</li>
<li>‚ñ° Understand the classification of coating technologies (plating, thermal spray, PVD/CVD)</li>
<li>‚ñ° Can explain the effects of thermal spray particle velocity and temperature on adhesion</li>
</ul>
<h3>Practical Skills (5 items)</h3>
<ul>
<li>‚ñ° Can design plating conditions considering current density and current efficiency</li>
<li>‚ñ° Can calculate the relationship between anodizing voltage and film thickness</li>
<li>‚ñ° Ion ImplantationCan simulate profiles in Python</li>
<li>‚ñ° Can utilize surface treatment technology selection flowchart</li>
<li>‚ñ° PlatingDefect (nodules„ÄÅInsufficient Film Thickness„ÄÅAdhesion defect Can estimate causes of plating defects</li>
</ul>
<h3>Applied Skills (5 items)</h3>
<ul>
<li>‚ñ° Can propose methods to improve uniformity for complex-shaped parts</li>
<li>‚ñ° Can design multi-layer coating and select material, thickness, and method for each layer</li>
<li>‚ñ° Can optimize thermal spray process parameters (particle size, spray distance)</li>
<li>‚ñ° Can select surface treatment technology according to required properties (corrosion resistance, wear resistance, conductivity, etc.)</li>
<li>‚ñ° Can troubleshoot process anomalies</li>
</ul>
<h2>3.8 References</h2>
<ol>
<li>Kanani, N. (2004). <em>Electroplating: Basic Principles, Processes and Practice</em>. Elsevier, <strong>pp. 56-89</strong> (Faraday's law and electrochemical fundamentals).</li>
<li>Wernick, S., Pinner, R., Sheasby, P.G. (1987). <em>The Surface Treatment and Finishing of Aluminum and Its Alloys</em> (5th ed.). ASM International, <strong>pp. 234-267</strong> (Anodizingprocess and film structure).</li>
<li>Davis, J.R. (Ed.) (2004). <em>Handbook of Thermal Spray Technology</em>. ASM International, <strong>pp. 123-156</strong> (Thermal Sprayprocesses and coating properties).</li>
<li>Pawlowski, L. (2008). <em>The Science and Engineering of Thermal Spray Coatings</em> (2nd ed.). Wiley, <strong>pp. 189-223</strong> (HVOFspray and particle dynamics).</li>
<li>Townsend, P.D., Chandler, P.J., Zhang, L. (1994). <em>Optical Effects of Ion Implantation</em>. Cambridge University Press, <strong>pp. 45-78</strong> (Ion Implantationtheory and LSS model).</li>
<li>Inagaki, M., Toyoda, M., Soneda, Y., Morishita, T. (2014). "Nitrogen-doped carbon materials." <em>Carbon</em>, 132, 104-140, <strong>pp. 115-128</strong>, DOI: 10.1016/j.carbon.2014.01.027 (Plasma nitriding process).</li>
<li>Fauchais, P.L., Heberlein, J.V.R., Boulos, M.I. (2014). <em>Thermal Spray Fundamentals: From Powder to Part</em>. Springer, <strong>pp. 567-612</strong> (Thermal Sprayfundamentals and applications).</li>
<li>Schlesinger, M., Paunovic, M. (Eds.) (2010). <em>Modern Electroplating</em> (5th ed.). Wiley, <strong>pp. 209-248</strong> (Latest plating technology and troubleshooting).</li>
</ol>
<h2>Summary</h2>
<p>In this chapter, we learned from the fundamentals to practice of material surface treatment technologies. In electroplating, we studied film thickness calculation using Faraday's law and current density optimization; in anodizing, the formation mechanisms of barrier layer and porous layer; in ion implantation, concentration profile modeling; and in thermal spray, the relationship between particle dynamics and adhesion strength.</p>
<p>Surface treatment technology is an important process technology that provides surface functions (corrosion resistance, wear resistance, conductivity, decorativeness, etc.) without changing the internal properties of materials. Appropriate technology selection and parameter optimization can significantly improve product performance and lifespan.</p>
<p>In the next chapter, we will learn about powder sintering processes. We will acquire the fundamentals and practice of powder metallurgy, including sintering mechanisms, densification models, hot pressing, and SPS.</p>
<div class="navigation">
<a class="nav-button" href="chapter-2.html">‚Üê Chapter 2: Heat Treatment Process</a>
<a class="nav-button" href="index.html">Return to Table of Contents</a>
<a class="nav-button" href="chapter-4.html">Chapter 4: Sintering Process ‚Üí</a>
</div>
</main>
<section class="disclaimer">
<h3>Disclaimer</h3>
<ul>
<li>This content is for educational, research, and informational purposes only and does not provide professional advice (legal, accounting, technical guarantees, etc.).</li>
<li>This content and accompanying code examples are provided "AS IS" without any warranties, express or implied, including merchantability, fitness for a particular purpose, non-infringement, accuracy, completeness, operability, safety, etc.</li>
<li>The author and Tohoku University assume no responsibility for the content, availability, or safety of external links, data, tools, libraries, etc. provided by third parties.</li>
<li>To the maximum extent permitted by applicable law, the authors and Tohoku University shall not be liable for any direct, indirect, incidental, special, consequential, or punitive damages arising from the use, execution, or interpretation of this content„ÄÇ</li>
<li>The content of this material may be changed, updated, or discontinued without notice„ÄÇ</li>
<li>The copyright and license of this content are subject to the stated conditions (e.g., CC BY 4.0). Such licenses typically include warranty disclaimers„ÄÇ</li>
</ul>
</section>
<footer>
<p><strong>Author</strong>: MS Knowledge Hub Content Team</p>
<p><strong>Version</strong>: 1.0 | <strong>Date</strong>: 2025-10-28</p>
<p><strong>License</strong>: Creative Commons BY 4.0</p>
<p>¬© 2025 MS Terakoya. All rights reserved.</p>
</footer>
</body>
</html>
