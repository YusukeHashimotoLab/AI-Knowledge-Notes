<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 3 ProcessOptimization - FoodProcessã¸ã®AIå¿œç”¨</title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        <link rel="stylesheet" href="../../assets/css/knowledge-base.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
</head>
<body>
        <nav class="breadcrumb">
        <div class="breadcrumb-content">
            <a href="../../index.html">AI Terakoya Top</a><span class="breadcrumb-separator">â€º</span><a href="../../PI/index.html">Process Informatics</a><span class="breadcrumb-separator">â€º</span><a href="../../PI/food-process-ai/index.html">Food Process Ai</a><span class="breadcrumb-separator">â€º</span><span class="breadcrumb-current">Chapter 3</span>
        </div>
    </nav>

    <header>
        <h1>Chapter 3 ProcessOptimization</h1>
        <p>Process Optimization</p>
    </header>

    <main>
        <h2>3.1 FoodProcessOptimizationã®èª²é¡Œ</h2>
        <p>
            FoodManufacturingProcessã®Optimizationã¯ã€å“è³ªå‘ä¸Šã€ã‚³ã‚¹ãƒˆå‰Šæ¸›ã€ã‚¨ãƒãƒ«ã‚®ãƒ¼åŠ¹ç‡æ”¹å–„ã®è¦³ç‚¹ã‹ã‚‰æ¥µã‚ã¦é‡è¦ã§ã™ã€‚
            ã—ã‹ã—ã€åŸææ–™ã®å¤‰å‹•æ€§ã€è¤‡é›‘ãªéç·šå½¢é–¢ä¿‚ã€å¤šç›®çš„Optimizationã®å¿…è¦æ€§ãªã©ã€å¤šãã®èª²é¡ŒãŒã‚ã‚Šã¾ã™ã€‚
            AIæŠ€è¡“ã€ç‰¹ã«Bayesian Optimizationã‚„éºä¼çš„ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã¯ã€ã“ã‚Œã‚‰ã®èª²é¡Œã«å¯¾å‡¦ã™ã‚‹å¼·åŠ›ãªæ‰‹æ³•ã§ã™ã€‚
        </p>

        <h3>FoodProcessOptimizationã®ä¸»è¦ãªèª²é¡Œ</h3>
        <ul>
            <li><strong>å¤šå¤‰æ•°ãƒ»éç·šå½¢æ€§</strong>: æ¸©åº¦ã€ hoursã€pHã€é…åˆæ¯”ãªã©å¤šæ•°ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãŒè¤‡é›‘ã«ç›¸äº’ä½œç”¨</li>
            <li><strong>è©•ä¾¡ã‚³ã‚¹ãƒˆã®é«˜ã•</strong>: å®Ÿé¨“è©•ä¾¡ã« hoursã¨ã‚³ã‚¹ãƒˆãŒã‹ã‹ã‚‹ï¼ˆ1å®Ÿé¨“ã‚ãŸã‚Šæ•° hoursã€œæ•°æ—¥ï¼‰</li>
            <li><strong>å¤šç›®çš„Optimization</strong>: å“è³ªã€ã‚³ã‚¹ãƒˆã€ã‚¨ãƒãƒ«ã‚®ãƒ¼åŠ¹ç‡ã‚’åŒæ™‚ã«Optimization</li>
            <li><strong>åˆ¶ç´„æ¡ä»¶</strong>: FoodSafetyåŸºæº–ï¼ˆHACCPï¼‰ã€è£…ç½®èƒ½åŠ›ã®åˆ¶ç´„</li>
            <li><strong>ãƒãƒƒãƒé–“å¤‰å‹•</strong>: åŸææ–™ã®å­£ç¯€å¤‰å‹•ã€ãƒ­ãƒƒãƒˆå·®</li>
        </ul>

        <div class="info-box">
            <h3>ğŸ¯ Optimizationæ‰‹æ³•ã®é¸æŠã‚¬ã‚¤ãƒ‰</h3>
            <table>
                <thead>
                    <tr>
                        <th>æ‰‹æ³•</th>
                        <th>é©ç”¨å ´é¢</th>
                        <th>é•·æ‰€</th>
                        <th>çŸ­æ‰€</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Bayesian Optimization</strong></td>
                        <td>è©•ä¾¡ã‚³ã‚¹ãƒˆãŒé«˜ã„ã€å°‘æ•°ã®å®Ÿé¨“ã§Optimization</td>
                        <td>ã‚µãƒ³ãƒ—ãƒ«åŠ¹ç‡ãŒé«˜ã„ã€ä¸ç¢ºå®Ÿæ€§ã‚’è€ƒæ…®</td>
                        <td>è¨ˆç®—ã‚³ã‚¹ãƒˆã‚„ã‚„é«˜ã„</td>
                    </tr>
                    <tr>
                        <td><strong>éºä¼çš„ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ </strong></td>
                        <td>å¤šç›®çš„Optimizationã€é›¢æ•£å¤‰æ•°ã‚’å«ã‚€</td>
                        <td>å¤§åŸŸçš„æœ€é©è§£æ¢ç´¢ã€å®Ÿè£…ãŒå®¹æ˜“</td>
                        <td>åæŸã« hoursãŒã‹ã‹ã‚‹</td>
                    </tr>
                    <tr>
                        <td><strong>å¿œç­”æ›²é¢æ³•ï¼ˆRSMï¼‰</strong></td>
                        <td>Design of Experimentsã¨çµ„ã¿åˆã‚ã›</td>
                        <td>çµ±è¨ˆçš„æ ¹æ‹ ã€å¯è¦–åŒ–ãŒå®¹æ˜“</td>
                        <td>éç·šå½¢æ€§ãŒå¼·ã„ã¨ç²¾åº¦ä½ä¸‹</td>
                    </tr>
                    <tr>
                        <td><strong>ç²’å­ç¾¤Optimizationï¼ˆPSOï¼‰</strong></td>
                        <td>é€£ç¶šå¤‰æ•°ã®Optimization</td>
                        <td>å®Ÿè£…ãŒç°¡å˜ã€ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿èª¿æ•´ãŒå°‘ãªã„</td>
                        <td>å±€æ‰€è§£ã«é™¥ã‚Šã‚„ã™ã„</td>
                    </tr>
                </tbody>
            </table>
        </div>

        <div class="code-example"><pre><code class="language-python">
            <div class="code-header">ğŸ“Š Code Examples1: Bayesian Optimizationã«ã‚ˆã‚‹åŠ ç†±æ¡ä»¶ã®Optimization</code></pre></div>
            <pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
from sklearn.gaussian_process import GaussianProcessRegressor
from sklearn.gaussian_process.kernels import RBF, ConstantKernel as C
from scipy.stats import norm
import warnings
warnings.filterwarnings('ignore')

# FoodåŠ ç†±Processã®ç›®çš„é–¢æ•°ï¼ˆå®Ÿéš›ã®Processã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆï¼‰
def food_processing_objective(temperature, time):
    """
    ç›®çš„é–¢æ•°: å“è³ªã‚¹ã‚³ã‚¢ã‚’æœ€å¤§åŒ–ï¼ˆæ¸©åº¦ã¨ hoursã®é–¢æ•°ï¼‰
    æœ€é©ç‚¹ä»˜è¿‘: temperature=90Â°C, time=20 minutes
    """
    # è¤‡é›‘ãªéç·šå½¢é–¢æ•°ï¼ˆå®Ÿéš›ã®FoodProcessã‚’æ¨¡æ“¬ï¼‰
    quality = (
        100 * np.exp(-0.5 * ((temperature - 90)/10)**2) * 
        np.exp(-0.5 * ((time - 20)/5)**2) +
        10 * np.sin(temperature / 10) * np.cos(time / 5) +
        np.random.normal(0, 2)  # æ¸¬å®šãƒã‚¤ã‚º
    )
    return quality

# Bayesian Optimizationã®å®Ÿè£…
class BayesianOptimizer:
    def __init__(self, bounds, n_init=5):
        self.bounds = np.array(bounds)
        self.n_init = n_init
        self.X_sample = []
        self.y_sample = []
        
        # ã‚¬ã‚¦ã‚¹éç¨‹å›å¸°ãƒ¢ãƒ‡ãƒ«
        kernel = C(1.0, (1e-3, 1e3)) * RBF([10, 10], (1e-2, 1e2))
        self.gp = GaussianProcessRegressor(kernel=kernel, n_restarts_optimizer=10,
                                           alpha=1e-6, normalize_y=True)
    
    def acquisition_function(self, X, xi=0.01):
        """
        ç²å¾—é–¢æ•°: Expected Improvement (EI)
        """
        mu, sigma = self.gp.predict(X, return_std=True)
        mu_sample_opt = np.max(self.y_sample)
        
        with np.errstate(divide='warn'):
            imp = mu - mu_sample_opt - xi
            Z = imp / sigma
            ei = imp * norm.cdf(Z) + sigma * norm.pdf(Z)
            ei[sigma == 0.0] = 0.0
        
        return ei
    
    def propose_location(self):
        """
        æ¬¡ã®è©•ä¾¡ç‚¹ã‚’ææ¡ˆï¼ˆEIã‚’æœ€å¤§åŒ–ï¼‰
        """
        dim = self.bounds.shape[0]
        min_val = float('inf')
        min_x = None
        
        # ãƒ©ãƒ³ãƒ€ãƒ ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚° + Optimization
        n_restarts = 25
        for _ in range(n_restarts):
            x0 = np.random.uniform(self.bounds[:, 0], self.bounds[:, 1], size=dim)
            res = self._minimize_acquisition(x0)
            if res < min_val:
                min_val = res
                min_x = x0
        
        return min_x
    
    def _minimize_acquisition(self, x0):
        """
        ç²å¾—é–¢æ•°ã®æœ€å°åŒ–ï¼ˆè² ã®EIã‚’æœ€å°åŒ–ï¼‰
        """
        from scipy.optimize import minimize
        
        def objective(x):
            return -self.acquisition_function(x.reshape(1, -1))
        
        bounds_list = [(self.bounds[i, 0], self.bounds[i, 1]) 
                       for i in range(self.bounds.shape[0])]
        
        res = minimize(objective, x0, bounds=bounds_list, method='L-BFGS-B')
        return res.fun
    
    def optimize(self, objective_func, n_iter=20):
        """
        Bayesian Optimizationã®å®Ÿè¡Œ
        """
        # åˆæœŸãƒ©ãƒ³ãƒ€ãƒ ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°
        for _ in range(self.n_init):
            x = np.random.uniform(self.bounds[:, 0], self.bounds[:, 1], 
                                  size=self.bounds.shape[0])
            y = objective_func(x[0], x[1])
            self.X_sample.append(x)
            self.y_sample.append(y)
        
        # Bayesian Optimizationãƒ«ãƒ¼ãƒ—
        for i in range(n_iter):
            # GPãƒ¢ãƒ‡ãƒ«æ›´æ–°
            self.gp.fit(np.array(self.X_sample), np.array(self.y_sample))
            
            # æ¬¡ã®è©•ä¾¡ç‚¹ã‚’ææ¡ˆ
            x_next = self.propose_location()
            y_next = objective_func(x_next[0], x_next[1])
            
            self.X_sample.append(x_next)
            self.y_sample.append(y_next)
            
            if (i + 1) % 5 == 0:
                print(f"Iteration {i+1}: Best quality = {np.max(self.y_sample):.2f} "
                      f"at T={self.X_sample[np.argmax(self.y_sample)][0]:.1f}Â°C, "
                      f"t={self.X_sample[np.argmax(self.y_sample)][1]:.1f}min")
        
        return np.array(self.X_sample), np.array(self.y_sample)

# Optimizationå®Ÿè¡Œ
bounds = [[75, 105], [10, 30]]  # [æ¸©åº¦ç¯„å›²,  hoursç¯„å›²]
optimizer = BayesianOptimizer(bounds, n_init=5)
X_sample, y_sample = optimizer.optimize(food_processing_objective, n_iter=25)

# æœ€é©è§£
best_idx = np.argmax(y_sample)
best_temp, best_time = X_sample[best_idx]
best_quality = y_sample[best_idx]

print(f"\n=== Optimizationçµæœ ===")
print(f"æœ€é©æ¸©åº¦: {best_temp:.2f}Â°C")
print(f"æœ€é© hours: {best_time:.2f} minutes")
print(f"æœ€å¤§å“è³ªã‚¹ã‚³ã‚¢: {best_quality:.2f}")
print(f"ç·è©•ä¾¡å›æ•°: {len(X_sample)}")

# å¯è¦–åŒ–
fig = plt.figure(figsize=(16, 10))
gs = fig.add_gridspec(2, 2, hspace=0.3, wspace=0.3)

# 1. çœŸã®ç›®çš„é–¢æ•°ï¼ˆå‚è€ƒï¼‰
ax1 = fig.add_subplot(gs[0, 0])
T_grid = np.linspace(75, 105, 100)
t_grid = np.linspace(10, 30, 100)
T_mesh, t_mesh = np.meshgrid(T_grid, t_grid)
quality_grid = np.zeros_like(T_mesh)
for i in range(T_mesh.shape[0]):
    for j in range(T_mesh.shape[1]):
        quality_grid[i, j] = food_processing_objective(T_mesh[i, j], t_mesh[i, j])

contour = ax1.contourf(T_mesh, t_mesh, quality_grid, levels=20, cmap='viridis', alpha=0.8)
ax1.scatter(X_sample[:5, 0], X_sample[:5, 1], c='red', s=100, 
            marker='o', edgecolors='white', linewidth=2, label='åˆæœŸã‚µãƒ³ãƒ—ãƒ«', zorder=5)
ax1.scatter(X_sample[5:, 0], X_sample[5:, 1], c='white', s=80, 
            marker='s', edgecolors='black', linewidth=1.5, label='BOææ¡ˆç‚¹', zorder=5)
ax1.scatter(best_temp, best_time, c='gold', s=300, marker='*', 
            edgecolors='red', linewidth=2, label='æœ€é©è§£', zorder=10)
ax1.set_xlabel('æ¸©åº¦ (Â°C)', fontsize=12)
ax1.set_ylabel(' hours ( minutes)', fontsize=12)
ax1.set_title('Bayesian Optimizationã®æ¢ç´¢éç¨‹', fontsize=14, fontweight='bold')
ax1.legend(fontsize=10)
plt.colorbar(contour, ax=ax1, label='å“è³ªã‚¹ã‚³ã‚¢')

# 2. å“è³ªã‚¹ã‚³ã‚¢ã®æ¨ç§»
ax2 = fig.add_subplot(gs[0, 1])
iterations = np.arange(1, len(y_sample) + 1)
best_so_far = np.maximum.accumulate(y_sample)
ax2.plot(iterations, y_sample, 'o-', color='#11998e', alpha=0.6, 
         linewidth=2, markersize=6, label='å„è©•ä¾¡ç‚¹ã®å“è³ª')
ax2.plot(iterations, best_so_far, 'r-', linewidth=3, label='æœ€è‰¯å€¤ã®æ¨ç§»')
ax2.axvline(x=5, color='gray', linestyle='--', alpha=0.5, label='åˆæœŸã‚µãƒ³ãƒ—ãƒ«çµ‚äº†')
ax2.set_xlabel('è©•ä¾¡å›æ•°', fontsize=12)
ax2.set_ylabel('å“è³ªã‚¹ã‚³ã‚¢', fontsize=12)
ax2.set_title('Optimizationã®åæŸéç¨‹', fontsize=14, fontweight='bold')
ax2.legend(fontsize=10)
ax2.grid(True, alpha=0.3)

# 3. ã‚¬ã‚¦ã‚¹éç¨‹ã«ã‚ˆã‚‹Predictionï¼ˆæ¸©åº¦æ–¹å‘ã®ã‚¹ãƒ©ã‚¤ã‚¹ã€ hours=best_timeï¼‰
ax3 = fig.add_subplot(gs[1, 0])
T_test = np.linspace(75, 105, 200).reshape(-1, 1)
t_test = np.full_like(T_test, best_time)
X_test = np.hstack([T_test, t_test])

mu, sigma = optimizer.gp.predict(X_test, return_std=True)

ax3.plot(T_test, mu, 'b-', linewidth=2, label='GPPredictionå¹³å‡')
ax3.fill_between(T_test.ravel(), mu - 1.96*sigma, mu + 1.96*sigma,
                 alpha=0.3, color='blue', label='95%ä¿¡é ¼åŒºé–“')
ax3.scatter(X_sample[:, 0], y_sample, c='red', s=80, marker='o', 
            edgecolors='white', linewidth=1.5, label='è¦³æ¸¬ç‚¹', zorder=5)
ax3.axvline(x=best_temp, color='green', linestyle='--', linewidth=2, label='æœ€é©æ¸©åº¦')
ax3.set_xlabel('æ¸©åº¦ (Â°C)', fontsize=12)
ax3.set_ylabel('å“è³ªã‚¹ã‚³ã‚¢', fontsize=12)
ax3.set_title(f'ã‚¬ã‚¦ã‚¹éç¨‹Predictionï¼ˆ hours={best_time:.1f} minuteså›ºå®šï¼‰', fontsize=14, fontweight='bold')
ax3.legend(fontsize=10)
ax3.grid(True, alpha=0.3)

# 4. ç²å¾—é–¢æ•°ï¼ˆExpected Improvementï¼‰
ax4 = fig.add_subplot(gs[1, 1])
ei = optimizer.acquisition_function(X_test)
ax4.plot(T_test, ei, 'g-', linewidth=2)
ax4.fill_between(T_test.ravel(), 0, ei, alpha=0.3, color='green')
ax4.set_xlabel('æ¸©åº¦ (Â°C)', fontsize=12)
ax4.set_ylabel('Expected Improvement', fontsize=12)
ax4.set_title('ç²å¾—é–¢æ•°ï¼ˆæ¬¡ã®è©•ä¾¡ç‚¹ã®é¸æŠåŸºæº–ï¼‰', fontsize=14, fontweight='bold')
ax4.grid(True, alpha=0.3)

plt.savefig('bayesian_optimization_food.png', dpi=300, bbox_inches='tight')
plt.show()</code></pre>
        </div>

        <h2>3.2 éºä¼çš„ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã«ã‚ˆã‚‹å¤šç›®çš„Optimization</h2>
        <p>
            FoodProcessã§ã¯ã€å“è³ªã€ã‚³ã‚¹ãƒˆã€ã‚¨ãƒãƒ«ã‚®ãƒ¼åŠ¹ç‡ãªã©è¤‡æ•°ã®ç›®çš„ã‚’åŒæ™‚ã«Optimizationã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚
            éºä¼çš„ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ï¼ˆGAï¼‰ã€ç‰¹ã«NSGA-IIï¼ˆNon-dominated Sorting Genetic Algorithm IIï¼‰ã¯ã€
            ãƒ‘ãƒ¬ãƒ¼ãƒˆæœ€é©è§£ã‚’åŠ¹ç‡çš„ã«æ¢ç´¢ã§ãã¾ã™ã€‚
        </p>

        <div class="code-example"><pre><code class="language-python">
            <div class="code-header">ğŸ“Š Code Examples2: å¤šç›®çš„Optimizationï¼ˆå“è³ª vs ã‚³ã‚¹ãƒˆï¼‰</code></pre></div>
            <pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import differential_evolution

# å¤šç›®çš„Optimizationå•é¡Œã®å®šç¾©
class FoodProcessMultiObjective:
    def __init__(self):
        # ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ç¯„å›²
        self.bounds = [
            (75, 105),   # æ¸©åº¦ (Â°C)
            (10, 30),    #  hours ( minutes)
            (3.0, 5.0),  # pH
            (50, 150),   # æµé‡ (L/min)
        ]
    
    def quality_objective(self, params):
        """
        ç›®çš„é–¢æ•°1: å“è³ªã‚¹ã‚³ã‚¢ã‚’æœ€å¤§åŒ–ï¼ˆæœ€å°åŒ–å•é¡Œãªã®ã§è² å€¤ï¼‰
        """
        temp, time, ph, flow = params
        
        # å“è³ªé–¢æ•°ï¼ˆéç·šå½¢ï¼‰
        quality = (
            100 * np.exp(-0.5 * ((temp - 90)/10)**2) *
            np.exp(-0.5 * ((time - 20)/5)**2) *
            np.exp(-0.5 * ((ph - 4.0)/0.5)**2) *
            (1 + 0.1 * np.sin(flow / 20))
        )
        
        return -quality  # æœ€å°åŒ–å•é¡Œã«å¤‰æ›
    
    def cost_objective(self, params):
        """
        ç›®çš„é–¢æ•°2: ã‚³ã‚¹ãƒˆã‚’æœ€å°åŒ–
        """
        temp, time, ph, flow = params
        
        # ã‚¨ãƒãƒ«ã‚®ãƒ¼ã‚³ã‚¹ãƒˆï¼ˆæ¸©åº¦ã¨ hoursã«ä¾å­˜ï¼‰
        energy_cost = 0.1 * (temp - 70) * time
        
        # pHèª¿æ•´å‰¤ã‚³ã‚¹ãƒˆ
        ph_cost = 5 * abs(ph - 4.0)
        
        # ãƒãƒ³ãƒ—é‹è»¢ã‚³ã‚¹ãƒˆ
        pump_cost = 0.05 * flow * time
        
        total_cost = energy_cost + ph_cost + pump_cost
        
        return total_cost
    
    def constraints_check(self, params):
        """
        åˆ¶ç´„æ¡ä»¶ã®ãƒã‚§ãƒƒã‚¯ï¼ˆHACCPåŸºæº–ãªã©ï¼‰
        """
        temp, time, ph, flow = params
        
        # Få€¤ï¼ˆæ®ºèŒåŠ¹æœï¼‰ã®è¨ˆç®—: F0 = time * 10^((temp-121)/10)
        F0 = time * (10 ** ((temp - 121) / 10))
        
        # æœ€å°Få€¤è¦æ±‚ï¼ˆä¾‹: F0 >= 3ï¼‰
        if F0 < 3:
            return False
        
        # pHç¯„å›²åˆ¶ç´„
        if not (3.0 <= ph <= 5.0):
            return False
        
        return True

# ç°¡æ˜“çš„ãªãƒ‘ãƒ¬ãƒ¼ãƒˆOptimizationï¼ˆã‚°ãƒªãƒƒãƒ‰ã‚µãƒ¼ãƒ + ãƒ‘ãƒ¬ãƒ¼ãƒˆåˆ¤å®šï¼‰
problem = FoodProcessMultiObjective()

# ãƒ©ãƒ³ãƒ€ãƒ ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ã§ãƒ‘ãƒ¬ãƒ¼ãƒˆãƒ•ãƒ­ãƒ³ãƒˆè¿‘ä¼¼
np.random.seed(42)
n_samples = 1000

# ãƒ©ãƒ³ãƒ€ãƒ ã‚µãƒ³ãƒ—ãƒ«ç”Ÿæˆ
samples = []
qualities = []
costs = []

for _ in range(n_samples):
    params = [
        np.random.uniform(low, high) 
        for low, high in problem.bounds
    ]
    
    if problem.constraints_check(params):
        quality = -problem.quality_objective(params)  # å…ƒã«æˆ»ã™ï¼ˆæœ€å¤§åŒ–ï¼‰
        cost = problem.cost_objective(params)
        
        samples.append(params)
        qualities.append(quality)
        costs.append(cost)

samples = np.array(samples)
qualities = np.array(qualities)
costs = np.array(costs)

# ãƒ‘ãƒ¬ãƒ¼ãƒˆæœ€é©è§£ã®åˆ¤å®š
def is_pareto_efficient(costs_qualities):
    """
    ãƒ‘ãƒ¬ãƒ¼ãƒˆæœ€é©è§£ã‚’åˆ¤å®šï¼ˆ2ç›®çš„ã®å ´åˆï¼‰
    cost: æœ€å°åŒ–, quality: æœ€å¤§åŒ–
    """
    is_efficient = np.ones(costs_qualities.shape[0], dtype=bool)
    for i, c in enumerate(costs_qualities):
        if is_efficient[i]:
            # ä»–ã®è§£ãŒã“ã®è§£ã‚’æ”¯é…ã—ã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
            # æ”¯é…: cost <= c[0] ã‹ã¤ quality >= c[1] ã§ã©ã¡ã‚‰ã‹ãŒçœŸã«å„ªã‚Œã¦ã„ã‚‹
            dominated = np.logical_and(
                costs_qualities[:, 0] <= c[0],  # ã‚³ã‚¹ãƒˆãŒåŒã˜ã‹å°‘ãªã„
                costs_qualities[:, 1] >= c[1]   # å“è³ªãŒåŒã˜ã‹é«˜ã„
            )
            # çœŸã«å„ªã‚Œã¦ã„ã‚‹ï¼ˆç­‰ã—ããªã„ï¼‰
            strictly_better = np.logical_or(
                costs_qualities[:, 0] < c[0],
                costs_qualities[:, 1] > c[1]
            )
            dominated = np.logical_and(dominated, strictly_better)
            
            if np.any(dominated):
                is_efficient[i] = False
    
    return is_efficient

# ãƒ‘ãƒ¬ãƒ¼ãƒˆæœ€é©è§£ã®æŠ½å‡º
costs_qualities = np.column_stack([costs, qualities])
pareto_mask = is_pareto_efficient(costs_qualities)
pareto_samples = samples[pareto_mask]
pareto_costs = costs[pareto_mask]
pareto_qualities = qualities[pareto_mask]

# ãƒ‘ãƒ¬ãƒ¼ãƒˆãƒ•ãƒ­ãƒ³ãƒˆã‚’ã‚³ã‚¹ãƒˆã§ã‚½ãƒ¼ãƒˆ
sorted_indices = np.argsort(pareto_costs)
pareto_costs_sorted = pareto_costs[sorted_indices]
pareto_qualities_sorted = pareto_qualities[sorted_indices]
pareto_samples_sorted = pareto_samples[sorted_indices]

# ä»£è¡¨çš„ãª3ã¤ã®è§£ã‚’é¸æŠ
n_pareto = len(pareto_costs_sorted)
representative_indices = [0, n_pareto // 2, n_pareto - 1]
representative_solutions = []

for idx in representative_indices:
    sol = {
        'params': pareto_samples_sorted[idx],
        'quality': pareto_qualities_sorted[idx],
        'cost': pareto_costs_sorted[idx],
        'label': ['ã‚³ã‚¹ãƒˆé‡è¦–', 'ãƒãƒ©ãƒ³ã‚¹å‹', 'å“è³ªé‡è¦–'][representative_indices.index(idx)]
    }
    representative_solutions.append(sol)

# å¯è¦–åŒ–
fig = plt.figure(figsize=(16, 10))
gs = fig.add_gridspec(2, 2, hspace=0.3, wspace=0.3)

# 1. ãƒ‘ãƒ¬ãƒ¼ãƒˆãƒ•ãƒ­ãƒ³ãƒˆ
ax1 = fig.add_subplot(gs[0, :])
ax1.scatter(costs, qualities, c='lightgray', alpha=0.4, s=30, label='å…¨ã‚µãƒ³ãƒ—ãƒ«')
ax1.plot(pareto_costs_sorted, pareto_qualities_sorted, 'r-', linewidth=2.5, 
         label='ãƒ‘ãƒ¬ãƒ¼ãƒˆãƒ•ãƒ­ãƒ³ãƒˆ', zorder=10)
ax1.scatter(pareto_costs_sorted, pareto_qualities_sorted, c='red', s=100, 
            marker='o', edgecolors='white', linewidth=2, label='ãƒ‘ãƒ¬ãƒ¼ãƒˆæœ€é©è§£', zorder=11)

# ä»£è¡¨è§£ã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆ
colors_rep = ['#1f77b4', '#ff7f0e', '#2ca02c']
for i, sol in enumerate(representative_solutions):
    ax1.scatter(sol['cost'], sol['quality'], c=colors_rep[i], s=300, 
                marker='*', edgecolors='black', linewidth=2, 
                label=sol['label'], zorder=12)
    ax1.annotate(sol['label'], 
                xy=(sol['cost'], sol['quality']),
                xytext=(15, 15), textcoords='offset points',
                fontsize=11, fontweight='bold',
                bbox=dict(boxstyle='round,pad=0.5', fc=colors_rep[i], alpha=0.7),
                arrowprops=dict(arrowstyle='->', connectionstyle='arc3,rad=0'))

ax1.set_xlabel('ã‚³ã‚¹ãƒˆï¼ˆå††/ãƒãƒƒãƒï¼‰', fontsize=13)
ax1.set_ylabel('å“è³ªã‚¹ã‚³ã‚¢', fontsize=13)
ax1.set_title('å¤šç›®çš„Optimizationï¼šãƒ‘ãƒ¬ãƒ¼ãƒˆãƒ•ãƒ­ãƒ³ãƒˆ', fontsize=15, fontweight='bold')
ax1.legend(fontsize=11, loc='upper right')
ax1.grid(True, alpha=0.3)

# 2-4. ä»£è¡¨è§£ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿æ¯”è¼ƒ
param_names = ['æ¸©åº¦ (Â°C)', ' hours ( minutes)', 'pH', 'æµé‡ (L/min)']
axes = [fig.add_subplot(gs[1, 0]), fig.add_subplot(gs[1, 1])]

# æ¸©åº¦ã¨ hours
ax2 = axes[0]
x_pos = np.arange(len(representative_solutions))
width = 0.35

temp_values = [sol['params'][0] for sol in representative_solutions]
time_values = [sol['params'][1] for sol in representative_solutions]

ax2_twin = ax2.twinx()
bars1 = ax2.bar(x_pos - width/2, temp_values, width, label='æ¸©åº¦', color='#ff6b6b', alpha=0.8)
bars2 = ax2_twin.bar(x_pos + width/2, time_values, width, label=' hours', color='#4ecdc4', alpha=0.8)

ax2.set_xlabel('è§£ã®ã‚¿ã‚¤ãƒ—', fontsize=12)
ax2.set_ylabel('æ¸©åº¦ (Â°C)', fontsize=12, color='#ff6b6b')
ax2_twin.set_ylabel(' hours ( minutes)', fontsize=12, color='#4ecdc4')
ax2.set_title('ä»£è¡¨è§£ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿æ¯”è¼ƒï¼ˆæ¸©åº¦ãƒ» hoursï¼‰', fontsize=13, fontweight='bold')
ax2.set_xticks(x_pos)
ax2.set_xticklabels([sol['label'] for sol in representative_solutions])
ax2.tick_params(axis='y', labelcolor='#ff6b6b')
ax2_twin.tick_params(axis='y', labelcolor='#4ecdc4')
ax2.grid(True, alpha=0.3, axis='y')

# pH ã¨æµé‡
ax3 = axes[1]
ph_values = [sol['params'][2] for sol in representative_solutions]
flow_values = [sol['params'][3] for sol in representative_solutions]

ax3_twin = ax3.twinx()
bars3 = ax3.bar(x_pos - width/2, ph_values, width, label='pH', color='#95e1d3', alpha=0.8)
bars4 = ax3_twin.bar(x_pos + width/2, flow_values, width, label='æµé‡', color='#f38181', alpha=0.8)

ax3.set_xlabel('è§£ã®ã‚¿ã‚¤ãƒ—', fontsize=12)
ax3.set_ylabel('pH', fontsize=12, color='#95e1d3')
ax3_twin.set_ylabel('æµé‡ (L/min)', fontsize=12, color='#f38181')
ax3.set_title('ä»£è¡¨è§£ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿æ¯”è¼ƒï¼ˆpHãƒ»æµé‡ï¼‰', fontsize=13, fontweight='bold')
ax3.set_xticks(x_pos)
ax3.set_xticklabels([sol['label'] for sol in representative_solutions])
ax3.tick_params(axis='y', labelcolor='#95e1d3')
ax3_twin.tick_params(axis='y', labelcolor='#f38181')
ax3.grid(True, alpha=0.3, axis='y')

plt.savefig('multi_objective_optimization.png', dpi=300, bbox_inches='tight')
plt.show()

# ãƒ¬ãƒãƒ¼ãƒˆå‡ºåŠ›
print("=== å¤šç›®çš„Optimizationçµæœ ===")
print(f"ç·ã‚µãƒ³ãƒ—ãƒ«æ•°: {n_samples}")
print(f"åˆ¶ç´„ã‚’æº€ãŸã™ã‚µãƒ³ãƒ—ãƒ«æ•°: {len(samples)}")
print(f"ãƒ‘ãƒ¬ãƒ¼ãƒˆæœ€é©è§£æ•°: {len(pareto_samples)}")

print("\n=== ä»£è¡¨çš„ãª3ã¤ã®è§£ ===")
for i, sol in enumerate(representative_solutions):
    print(f"\n{i+1}. {sol['label']}")
    print(f"   æ¸©åº¦: {sol['params'][0]:.2f}Â°C")
    print(f"    hours: {sol['params'][1]:.2f} minutes")
    print(f"   pH: {sol['params'][2]:.2f}")
    print(f"   æµé‡: {sol['params'][3]:.2f} L/min")
    print(f"   å“è³ªã‚¹ã‚³ã‚¢: {sol['quality']:.2f}")
    print(f"   ã‚³ã‚¹ãƒˆ: {sol['cost']:.2f} å††/ãƒãƒƒãƒ")
    
    # Få€¤è¨ˆç®—
    F0 = sol['params'][1] * (10 ** ((sol['params'][0] - 121) / 10))
    print(f"   æ®ºèŒåŠ¹æœï¼ˆF0å€¤ï¼‰: {F0:.2f}")</code></pre>
        </div>

        <h2>3.3 å¿œç­”æ›²é¢æ³•ï¼ˆRSMï¼‰ã«ã‚ˆã‚‹Optimization</h2>
        <p>
            å¿œç­”æ›²é¢æ³•ï¼ˆResponse Surface Methodology: RSMï¼‰ã¯ã€Design of Experimentsã¨çµ±è¨ˆãƒ¢ãƒ‡ãƒªãƒ³ã‚°ã‚’çµ„ã¿åˆã‚ã›ãŸOptimizationæ‰‹æ³•ã§ã™ã€‚
            æ¯”è¼ƒçš„å°‘ãªã„å®Ÿé¨“å›æ•°ã§ã€Processãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¨å¿œç­”å¤‰æ•°ã®é–¢ä¿‚ã‚’2æ¬¡å¤šé …å¼ã§ãƒ¢ãƒ‡ãƒ«åŒ–ã—ã€æœ€é©æ¡ä»¶ã‚’æ¢ç´¢ã—ã¾ã™ã€‚
        </p>

        <div class="code-example"><pre><code class="language-python">
            <div class="code-header">ğŸ“Š Code Examples3: å¿œç­”æ›²é¢æ³•ï¼ˆBox-Behnkenè¨ˆç”»ï¼‰</code></pre></div>
            <pre><code class="language-python">import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.preprocessing import PolynomialFeatures
from sklearn.linear_model import LinearRegression
from mpl_toolkits.mplot3d import Axes3D

# Box-Behnkenå®Ÿé¨“è¨ˆç”»ï¼ˆ3å› å­ï¼‰
def box_behnken_design(factors):
    """
    Box-Behnkenå®Ÿé¨“è¨ˆç”»ã‚’ç”Ÿæˆï¼ˆ3å› å­ã®å ´åˆï¼‰
    """
    # ç¬¦å·åŒ–Level: -1, 0, +1
    design = np.array([
        [-1, -1,  0], [1, -1,  0], [-1,  1,  0], [1,  1,  0],
        [-1,  0, -1], [1,  0, -1], [-1,  0,  1], [1,  0,  1],
        [ 0, -1, -1], [0,  1, -1], [ 0, -1,  1], [0,  1,  1],
        [ 0,  0,  0], [0,  0,  0], [ 0,  0,  0]  # ä¸­å¿ƒç‚¹ï¼ˆ3å›åå¾©ï¼‰
    ])
    
    # å®Ÿéš›ã®å€¤ã«å¤‰æ›
    actual_design = []
    for row in design:
        actual_row = []
        for i, level in enumerate(row):
            low, center, high = factors[i]
            if level == -1:
                actual_row.append(low)
            elif level == 0:
                actual_row.append(center)
            else:  # level == 1
                actual_row.append(high)
        actual_design.append(actual_row)
    
    return np.array(actual_design)

# å› å­Levelè¨­å®šï¼ˆä½ãƒ»ä¸­ãƒ»é«˜ï¼‰
factors = [
    (80, 90, 100),   # æ¸©åº¦ (Â°C)
    (15, 20, 25),    #  hours ( minutes)
    (3.5, 4.0, 4.5), # pH
]
factor_names = ['æ¸©åº¦', ' hours', 'pH']

# å®Ÿé¨“è¨ˆç”»ç”Ÿæˆ
X_design = box_behnken_design(factors)

# å¿œç­”å¤‰æ•°ï¼ˆå“è³ªã‚¹ã‚³ã‚¢ï¼‰ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ
def response_function(temp, time, ph):
    """
    çœŸã®å¿œç­”é–¢æ•°ï¼ˆ2æ¬¡å¤šé …å¼ + äº¤äº’ä½œç”¨ + ãƒã‚¤ã‚ºï¼‰
    """
    response = (
        50 +
        2 * (temp - 90) + 0.5 * (time - 20) + 10 * (ph - 4.0) +
        -0.05 * (temp - 90)**2 - 0.1 * (time - 20)**2 - 15 * (ph - 4.0)**2 +
        0.02 * (temp - 90) * (time - 20) +
        0.5 * (temp - 90) * (ph - 4.0) +
        np.random.normal(0, 0.5)  # å®Ÿé¨“èª¤å·®
    )
    return response

y_response = np.array([response_function(x[0], x[1], x[2]) for x in X_design])

# ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ¬ãƒ¼ãƒ ä½œæˆ
df_experiment = pd.DataFrame(X_design, columns=factor_names)
df_experiment['å“è³ªã‚¹ã‚³ã‚¢'] = y_response

print("=== Box-Behnkenå®Ÿé¨“è¨ˆç”» ===")
print(df_experiment)

# 2æ¬¡å¿œç­”æ›²é¢ãƒ¢ãƒ‡ãƒ«ã®æ§‹ç¯‰
poly = PolynomialFeatures(degree=2, include_bias=True)
X_poly = poly.fit_transform(X_design)
model = LinearRegression()
model.fit(X_poly, y_response)

# ãƒ¢ãƒ‡ãƒ«æ€§èƒ½
y_pred = model.predict(X_poly)
r2_score = model.score(X_poly, y_response)
print(f"\n=== å¿œç­”æ›²é¢ãƒ¢ãƒ‡ãƒ« ===")
print(f"RÂ² ã‚¹ã‚³ã‚¢: {r2_score:.4f}")

# ä¿‚æ•°ã®è¡¨ç¤º
feature_names = poly.get_feature_names_out(factor_names)
coefficients = pd.DataFrame({
    'é …': feature_names,
    'ä¿‚æ•°': model.coef_
})
print("\n=== ãƒ¢ãƒ‡ãƒ«ä¿‚æ•° ===")
print(coefficients)

# Optimizationï¼šã‚°ãƒªãƒƒãƒ‰ã‚µãƒ¼ãƒã§æœ€å¤§å€¤ã‚’æ¢ç´¢
temp_range = np.linspace(80, 100, 50)
time_range = np.linspace(15, 25, 50)
ph_fixed = 4.0  # pHã‚’å›ºå®š

T_mesh, t_mesh = np.meshgrid(temp_range, time_range)
response_mesh = np.zeros_like(T_mesh)

for i in range(T_mesh.shape[0]):
    for j in range(T_mesh.shape[1]):
        X_test = np.array([[T_mesh[i, j], t_mesh[i, j], ph_fixed]])
        X_test_poly = poly.transform(X_test)
        response_mesh[i, j] = model.predict(X_test_poly)[0]

# æœ€é©ç‚¹
max_idx = np.unravel_index(np.argmax(response_mesh), response_mesh.shape)
optimal_temp = T_mesh[max_idx]
optimal_time = t_mesh[max_idx]
optimal_response = response_mesh[max_idx]

print(f"\n=== æœ€é©æ¡ä»¶ï¼ˆpH={ph_fixed}å›ºå®šï¼‰ ===")
print(f"æœ€é©æ¸©åº¦: {optimal_temp:.2f}Â°C")
print(f"æœ€é© hours: {optimal_time:.2f} minutes")
print(f"Predictionå“è³ªã‚¹ã‚³ã‚¢: {optimal_response:.2f}")

# å¯è¦–åŒ–
fig = plt.figure(figsize=(16, 12))

# 1. 3Då¿œç­”æ›²é¢
ax1 = fig.add_subplot(2, 2, 1, projection='3d')
surf = ax1.plot_surface(T_mesh, t_mesh, response_mesh, cmap='viridis', alpha=0.8)
ax1.scatter(X_design[:, 0], X_design[:, 1], y_response, c='red', s=100, 
            marker='o', edgecolors='white', linewidth=2, label='å®Ÿé¨“ç‚¹')
ax1.scatter(optimal_temp, optimal_time, optimal_response, c='gold', s=300, 
            marker='*', edgecolors='red', linewidth=2, label='æœ€é©ç‚¹')
ax1.set_xlabel('æ¸©åº¦ (Â°C)', fontsize=11)
ax1.set_ylabel(' hours ( minutes)', fontsize=11)
ax1.set_zlabel('å“è³ªã‚¹ã‚³ã‚¢', fontsize=11)
ax1.set_title(f'å¿œç­”æ›²é¢ï¼ˆpH={ph_fixed}å›ºå®šï¼‰', fontsize=13, fontweight='bold')
plt.colorbar(surf, ax=ax1, shrink=0.5, label='å“è³ªã‚¹ã‚³ã‚¢')

# 2. ç­‰é«˜ç·šå›³
ax2 = fig.add_subplot(2, 2, 2)
contour = ax2.contourf(T_mesh, t_mesh, response_mesh, levels=15, cmap='viridis', alpha=0.9)
contour_lines = ax2.contour(T_mesh, t_mesh, response_mesh, levels=10, colors='white', 
                             linewidths=0.5, alpha=0.7)
ax2.clabel(contour_lines, inline=True, fontsize=8, fmt='%.1f')
ax2.scatter(X_design[:, 0], X_design[:, 1], c='red', s=100, 
            marker='o', edgecolors='white', linewidth=2, label='å®Ÿé¨“ç‚¹')
ax2.scatter(optimal_temp, optimal_time, c='gold', s=300, 
            marker='*', edgecolors='red', linewidth=2, label='æœ€é©ç‚¹')
ax2.set_xlabel('æ¸©åº¦ (Â°C)', fontsize=12)
ax2.set_ylabel(' hours ( minutes)', fontsize=12)
ax2.set_title(f'ç­‰é«˜ç·šå›³ï¼ˆpH={ph_fixed}å›ºå®šï¼‰', fontsize=13, fontweight='bold')
ax2.legend(fontsize=10)
plt.colorbar(contour, ax=ax2, label='å“è³ªã‚¹ã‚³ã‚¢')

# 3. Predictionvså®Ÿæ¸¬å€¤
ax3 = fig.add_subplot(2, 2, 3)
ax3.scatter(y_response, y_pred, c='#11998e', s=100, alpha=0.7, edgecolors='white', linewidth=1.5)
ax3.plot([y_response.min(), y_response.max()], [y_response.min(), y_response.max()],
         'r--', linewidth=2, label='ç†æƒ³ãƒ©ã‚¤ãƒ³')
ax3.set_xlabel('å®Ÿæ¸¬å€¤', fontsize=12)
ax3.set_ylabel('Predictionå€¤', fontsize=12)
ax3.set_title(f'Predictionç²¾åº¦ï¼ˆRÂ²={r2_score:.4f}ï¼‰', fontsize=13, fontweight='bold')
ax3.legend(fontsize=10)
ax3.grid(True, alpha=0.3)

# 4. ä¸»åŠ¹æœãƒ—ãƒ­ãƒƒãƒˆï¼ˆæ¸©åº¦ã®åŠ¹æœï¼‰
ax4 = fig.add_subplot(2, 2, 4)
temp_test = np.linspace(80, 100, 100)
time_fixed = 20
ph_test_fixed = 4.0

response_temp_effect = []
for t in temp_test:
    X_test = np.array([[t, time_fixed, ph_test_fixed]])
    X_test_poly = poly.transform(X_test)
    response_temp_effect.append(model.predict(X_test_poly)[0])

ax4.plot(temp_test, response_temp_effect, linewidth=2.5, color='#11998e', label='Predictionå¿œç­”')
ax4.scatter(X_design[:, 0], y_response, c='red', s=80, alpha=0.6, 
            edgecolors='white', linewidth=1.5, label='å®Ÿé¨“ç‚¹')
ax4.axvline(x=optimal_temp, color='green', linestyle='--', linewidth=2, label='æœ€é©æ¸©åº¦')
ax4.set_xlabel('æ¸©åº¦ (Â°C)', fontsize=12)
ax4.set_ylabel('å“è³ªã‚¹ã‚³ã‚¢', fontsize=12)
ax4.set_title(f'ä¸»åŠ¹æœãƒ—ãƒ­ãƒƒãƒˆï¼ˆ hours={time_fixed} minutes, pH={ph_test_fixed}å›ºå®šï¼‰', 
              fontsize=13, fontweight='bold')
ax4.legend(fontsize=10)
ax4.grid(True, alpha=0.3)

plt.tight_layout()
plt.savefig('response_surface_method.png', dpi=300, bbox_inches='tight')
plt.show()</code></pre>
        </div>

        <div class="warning-box">
            <h3>âš ï¸ Optimizationå®Ÿè£…æ™‚ã®æ³¨æ„ç‚¹</h3>
            <ul>
                <li><strong>å±€æ‰€æœ€é©è§£</strong>: éç·šå½¢æ€§ãŒå¼·ã„å ´åˆã€å±€æ‰€è§£ã«é™¥ã‚‹å¯èƒ½æ€§ã‚ã‚Šã€‚è¤‡æ•°ã®åˆæœŸå€¤ã‹ã‚‰Optimizationã‚’å®Ÿè¡Œ</li>
                <li><strong>åˆ¶ç´„æ¡ä»¶ã®å³å®ˆ</strong>: FoodSafetyåŸºæº–ï¼ˆHACCPã€Få€¤ï¼‰ã¯å¿…ãšæº€ãŸã™</li>
                <li><strong>å®Ÿé¨“èª¤å·®ã®è€ƒæ…®</strong>: ä¸­å¿ƒç‚¹ã‚’è¤‡æ•°å›ç¹°ã‚Šè¿”ã—ã¦ç´”èª¤å·®ã‚’æ¨å®š</li>
                <li><strong>å¤–æŒ¿ã®å±é™ºæ€§</strong>: å®Ÿé¨“ç¯„å›²å¤–ã§ã®Predictionã¯ä¿¡é ¼æ€§ãŒä½ã„</li>
                <li><strong>ãƒãƒƒãƒé–“å¤‰å‹•</strong>: åŸææ–™å¤‰å‹•ã‚’è€ƒæ…®ã—ãŸãƒ­ãƒã‚¹ãƒˆOptimizationãŒæœ›ã¾ã—ã„</li>
                <li><strong>Scale-up</strong>: ãƒ©ãƒœã‚¹ã‚±ãƒ¼ãƒ«ã®æœ€é©æ¡ä»¶ãŒå·¥å ´ã‚¹ã‚±ãƒ¼ãƒ«ã§å†ç¾ã•ã‚Œãªã„å ´åˆãŒã‚ã‚‹</li>
            </ul>
        </div>

        <h2>Summary</h2>
        <p>æœ¬ Chapterã§ã¯ã€FoodProcessã®Optimizationæ‰‹æ³•ã‚’å­¦ã³ã¾ã—ãŸï¼š</p>
        <ul>
            <li>Bayesian Optimizationã«ã‚ˆã‚‹åŠ¹ç‡çš„ãªå®Ÿé¨“è¨ˆç”»ã¨æœ€é©æ¡ä»¶æ¢ç´¢</li>
            <li>éºä¼çš„ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã«ã‚ˆã‚‹å¤šç›®çš„Optimizationï¼ˆå“è³ªãƒ»ã‚³ã‚¹ãƒˆãƒ»ã‚¨ãƒãƒ«ã‚®ãƒ¼ï¼‰</li>
            <li>å¿œç­”æ›²é¢æ³•ï¼ˆBox-Behnkenè¨ˆç”»ï¼‰ã«ã‚ˆã‚‹çµ±è¨ˆçš„Optimization</li>
            <li>åˆ¶ç´„æ¡ä»¶ï¼ˆHACCPã€FoodSafetyåŸºæº–ï¼‰ã‚’è€ƒæ…®ã—ãŸå®Ÿç”¨çš„Optimization</li>
        </ul>
        <p>æ¬¡ Chapterã§ã¯ã€äºˆçŸ¥ä¿å…¨ã¨ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã®å®Ÿè·µçš„æ‰‹æ³•ã‚’å­¦ã³ã¾ã™ã€‚</p>

        <div class="nav-buttons">
            <a href="chapter-2.html" class="nav-button">â† Chapter 2: ProcessMonitoringã¨Quality Control</a>
            <a href="chapter-4.html" class="nav-button">Chapter 4: äºˆçŸ¥ä¿å…¨ã¨ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚° â†’</a>
        </div>
    </main>

    <footer>
        <p>&copy; 2025 Process Informaticsé“å ´ - FoodProcessã¸ã®AIå¿œç”¨</p>
        <p>Food Process AI Application Series | Chapter 3</p>
    </footer>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
</body>
</html>
