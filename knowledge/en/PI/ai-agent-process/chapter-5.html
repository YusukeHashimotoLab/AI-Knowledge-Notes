<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Chapter 5: Real Plant Deployment and Safety - Autonomous Process Operation with AI Agents</title>
<meta content="Learn safety assurance methods when deploying reinforcement learning agents to real plants. Covers sim-to-real transfer, safe exploration, conservative Q-learning, human override, and uncertainty quantification with implementation examples." name="description"/>
<!-- CSS -->
<link href="../../../../../assets/css/variables.css" rel="stylesheet"/>
<link href="../../../../../assets/css/reset.css" rel="stylesheet"/>
<link href="../../../../../assets/css/base.css" rel="stylesheet"/>
<link href="../../../../../assets/css/components.css" rel="stylesheet"/>
<link href="../../../../../assets/css/layout.css" rel="stylesheet"/>
<link href="../../../../../assets/css/responsive.css" rel="stylesheet"/>
<link href="../../../../../assets/css/article.css" rel="stylesheet"/>
<!-- Prism.js for syntax highlighting -->
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet"/>
<!-- MathJax for mathematical expressions -->
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<!-- Mermaid for diagrams -->
<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
<link href="../../assets/css/knowledge-base.css" rel="stylesheet"/>
</head>
<body>
<nav class="breadcrumb">
<div class="breadcrumb-content">
<a href="../index.html">AI Terakoya Top</a><span class="breadcrumb-separator">‚Ä∫</span><a href="../../PI/index.html">Process Informatics</a><span class="breadcrumb-separator">‚Ä∫</span><a href="../../PI/ai-agent-process/index.html">AI Agent Process</a><span class="breadcrumb-separator">‚Ä∫</span><span class="breadcrumb-current">Chapter 5</span>
</div>
</nav><div class="locale-switcher">
<span class="current-locale">üåê EN</span>
<span class="locale-separator">|</span>

<span class="locale-meta">Last sync: 2025-11-16</span>
</div>

<header>
<div class="container">
<div class="site-title">
<a href="../../../../index.html">Hashimoto Laboratory</a>
</div>
<nav aria-label="Main navigation" class="main-nav" role="navigation">
<ul>
<li><a href="../../../../../en/research.html">Research</a></li>
<li><a href="../../../../../en/publications.html">Publications</a></li>
<li><a href="../../../../../en/members.html">Members</a></li>
<li><a href="../../../../../en/equipment.html">Equipment</a></li>
<li><a href="../../../../../en/talks.html">Talks</a></li>
<li><a href="../../../../../en/contact.html">Contact</a></li>
</ul>
</nav>
</div>
</header>
<main class="article-content">
<article>
<div class="series-header">
<div class="series-title">Autonomous Process Operation with AI Agents Series</div>
<h1 class="chapter-title">Chapter 5: Real Plant Deployment and Safety</h1>
<div class="chapter-nav">
<a href="chapter-4.html">‚Üê Chapter 4: Multi-Agent Cooperative Control</a>
<a href="index.html">Series Contents</a>
</div>
</div>
<section id="overview">
<h2>Chapter 5 Overview</h2>
<p>
                    Training reinforcement learning agents in simulation environments alone is not sufficient.
                    When deploying to real plants, there are many challenges including <strong>ensuring safety</strong>, <strong>overcoming the gap between simulation and reality</strong>,
                    and <strong>dealing with uncertainty</strong>.
                </p>
<p>
                    This chapter explains seven key technologies for real plant deployment with implementation examples.
                    Chemical plants handle high temperatures, high pressures, and hazardous materials, requiring particularly careful approaches to autonomous control by AI.
                </p>
<div class="warning-box">
<h4>Important Safety Notice</h4>
<p>
                        The technologies covered in this chapter assume deployment to real plants.
                        Actual deployment requires process safety expertise, regulatory compliance, and thorough verification and testing.
                        This code is for educational purposes, and appropriate safety assessment is essential for use in real plants.
                    </p>
</div>
<div class="key-points">
<h3>What You Will Learn in This Chapter</h3>
<ul>
<li><strong>Sim-to-Real Transfer</strong>: Robustness improvement through domain randomization</li>
<li><strong>Safe Exploration</strong>: Avoiding dangerous regions with action constraints</li>
<li><strong>Conservative Q-Learning (CQL)</strong>: Offline learning to prevent overestimation</li>
<li><strong>Human Override</strong>: Emergency human intervention mechanism</li>
<li><strong>Uncertainty Quantification</strong>: Confidence interval estimation using Bayesian NNs and ensembles</li>
<li><strong>Performance Monitoring and Drift Detection</strong>: Continuous monitoring</li>
<li><strong>Integrated Deployment Framework</strong>: Implementation combining all elements</li>
</ul>
</div>
</section>
<section id="deployment-challenges">
<h2>Real Plant Deployment Challenges</h2>
<h3>Sim-to-Real Gap</h3>
<div class="mermaid">
                graph LR
                    A[Simulation Environment] --&gt;|Ideal Model| B[Perfect Control]
                    C[Real Plant] --&gt;|Model Error<br/>Disturbance<br/>Sensor Noise| D[Performance Degradation]
                    B -.-&gt;|Sim-to-Real Gap| D
                    E[Domain Randomization] --&gt; F[Robust Policy]
                    F --&gt; C
                </div>
<h3>Safety Hierarchy</h3>
<table style="width: 100%; border-collapse: collapse; margin: 1.5rem 0;">
<thead style="background: var(--pi-primary); color: white;">
<tr>
<th style="padding: 0.75rem; border: 1px solid #ddd;">Layer</th>
<th style="padding: 0.75rem; border: 1px solid #ddd;">Function</th>
<th style="padding: 0.75rem; border: 1px solid #ddd;">Implementation</th>
</tr>
</thead>
<tbody>
<tr>
<td style="padding: 0.75rem; border: 1px solid #ddd;">1. Action Constraints</td>
<td style="padding: 0.75rem; border: 1px solid #ddd;">Prohibition of dangerous actions</td>
<td style="padding: 0.75rem; border: 1px solid #ddd;">Hard limits, safety filters</td>
</tr>
<tr>
<td style="padding: 0.75rem; border: 1px solid #ddd;">2. Uncertainty Consideration</td>
<td style="padding: 0.75rem; border: 1px solid #ddd;">Confidence interval assessment</td>
<td style="padding: 0.75rem; border: 1px solid #ddd;">Bayesian NN, ensembles</td>
</tr>
<tr>
<td style="padding: 0.75rem; border: 1px solid #ddd;">3. Performance Monitoring</td>
<td style="padding: 0.75rem; border: 1px solid #ddd;">Anomaly detection</td>
<td style="padding: 0.75rem; border: 1px solid #ddd;">Drift detection, KPI monitoring</td>
</tr>
<tr>
<td style="padding: 0.75rem; border: 1px solid #ddd;">4. Human Intervention</td>
<td style="padding: 0.75rem; border: 1px solid #ddd;">Emergency stop</td>
<td style="padding: 0.75rem; border: 1px solid #ddd;">Override mechanism</td>
</tr>
</tbody>
</table>
</section>
<section id="example1">
<div class="example-box">
<div class="example-title">
<span class="example-number">1</span>
                        Sim-to-Real Transfer Through Domain Randomization
                    </div>
<p>
                        By learning with randomized parameters in simulation environments,
                        acquire policies that are robust to uncertainties in real environments.
                    </p>
<div class="formula-box">
<p><strong>Domain Randomization:</strong></p>
                        \[
                        \theta \sim p(\Theta), \quad \pi^* = \arg\max_\pi \mathbb{E}_{\theta \sim p(\Theta)} [J(\pi; \theta)]
                        \]
                        <p>Where \(\theta\) is environment parameter, \(p(\Theta)\) is parameter distribution</p>
</div>
<pre><code class="language-python"># Requirements:
# - Python 3.9+
# - numpy&gt;=1.24.0, &lt;2.0.0
# - torch&gt;=2.0.0, &lt;2.3.0

# Domain Randomization Implementation
import numpy as np
import torch
import torch.nn as nn
import torch.optim as optim

class RandomizedCSTREnv:
    &quot;&quot;&quot;CSTR environment with randomized parameters&quot;&quot;&quot;
    def __init__(self, randomize=True):
        self.randomize = randomize
        self.reset()

    def _sample_parameters(self):
        &quot;&quot;&quot;Random sampling of physical parameters&quot;&quot;&quot;
        if self.randomize:
            # Activation energy (¬±20% variation)
            self.Ea = np.random.uniform(40000, 60000)

            # Reaction enthalpy (¬±15% variation)
            self.dHr = np.random.uniform(-57500, -42500)

            # Heat transfer coefficient (¬±25% variation)
            self.U = np.random.uniform(300, 500)

            # Volume (manufacturing variation ¬±5%)
            self.V = np.random.uniform(950, 1050)

            # Sensor noise standard deviation
            self.temp_noise = np.random.uniform(0.1, 1.0)
            self.conc_noise = np.random.uniform(0.01, 0.05)

            # Control delay (communication delay + valve response)
            self.control_delay = np.random.randint(1, 4)
        else:
            # Nominal values
            self.Ea = 50000
            self.dHr = -50000
            self.U = 400
            self.V = 1000
            self.temp_noise = 0.5
            self.conc_noise = 0.02
            self.control_delay = 2

    def reset(self):
        self._sample_parameters()
        self.state = np.array([350.0, 2.0])  # [temperature, concentration]
        self.action_buffer = [0.5] * self.control_delay
        return self._get_observation()

    def _get_observation(self):
        &quot;&quot;&quot;Noisy observation&quot;&quot;&quot;
        T, CA = self.state
        T_obs = T + np.random.normal(0, self.temp_noise)
        CA_obs = CA + np.random.normal(0, self.conc_noise)
        return np.array([T_obs, CA_obs])

    def step(self, action):
        &quot;&quot;&quot;Step with control delay&quot;&quot;&quot;
        # Apply delayed action
        self.action_buffer.append(action)
        actual_action = self.action_buffer.pop(0)

        T, CA = self.state

        # Reaction rate (randomized parameters)
        R = 8.314
        k = 1e10 * np.exp(-self.Ea / (R * T))

        # CSTR dynamics
        dt = 0.1
        F = 100  # Flow rate [L/min]
        CA_in = 2.5
        Tin = 350
        rho = 1000
        Cp = 4.18

        # Cooling amount (action)
        Q_cool = actual_action * 10000  # 0-10000 W

        # Material balance
        dCA = (F / self.V) * (CA_in - CA) - k * CA
        CA_new = CA + dCA * dt

        # Energy balance
        Q_rxn = -self.dHr * k * CA * self.V
        Q_jacket = self.U * 10 * (T - Tin) + Q_cool
        dT = (Q_rxn - Q_jacket) / (self.V * rho * Cp)
        T_new = T + dT * dt

        self.state = np.array([T_new, max(0, CA_new)])

        # Reward
        temp_penalty = -abs(T_new - 350) ** 2 * 0.01
        production = k * CA * 10
        reward = temp_penalty + production

        done = T_new &gt; 400 or T_new &lt; 300  # Outside safe range
        return self._get_observation(), reward, done

# Robust SAC learning
class RobustSACAgent:
    &quot;&quot;&quot;SAC agent using domain randomization&quot;&quot;&quot;
    def __init__(self, obs_dim, action_dim):
        self.actor = nn.Sequential(
            nn.Linear(obs_dim, 128), nn.ReLU(),
            nn.Linear(128, 128), nn.ReLU(),
            nn.Linear(128, action_dim), nn.Tanh()
        )
        self.optimizer = optim.Adam(self.actor.parameters(), lr=3e-4)

    def select_action(self, obs):
        with torch.no_grad():
            return self.actor(torch.FloatTensor(obs)).numpy()

# Training: train in randomized environment
train_env = RandomizedCSTREnv(randomize=True)
agent = RobustSACAgent(obs_dim=2, action_dim=1)

print(&quot;Training in randomized environment...&quot;)
for episode in range(500):
    obs = train_env.reset()
    episode_reward = 0

    for step in range(100):
        action = agent.select_action(obs)
        next_obs, reward, done = train_env.step(action[0])
        episode_reward += reward
        obs = next_obs

        if done:
            break

    if episode % 100 == 0:
        print(f&quot;Episode {episode}, Reward: {episode_reward:.2f}&quot;)
        print(f&quot;  Env params: Ea={train_env.Ea:.0f}, V={train_env.V:.0f}, &quot;
              f&quot;delay={train_env.control_delay}&quot;)

# Evaluation: test in nominal environment (assuming real plant)
test_env = RandomizedCSTREnv(randomize=False)
print(&quot;\nTesting in nominal environment...&quot;)

obs = test_env.reset()
test_reward = 0
temps = []

for step in range(100):
    action = agent.select_action(obs)
    obs, reward, done = test_env.step(action[0])
    test_reward += reward
    temps.append(obs[0])

    if done:
        break

print(f&quot;Test Reward: {test_reward:.2f}&quot;)
print(f&quot;Temp Mean: {np.mean(temps):.2f}K, Std: {np.std(temps):.2f}K&quot;)</code></pre>
</div>
</section>
<section id="example2">
<div class="example-box">
<div class="example-title">
<span class="example-number">2</span>
                        Safe Exploration: Safety Filter with Action Constraints
                    </div>
<p>
                        Impose physical and safety constraints to prevent reinforcement learning agents from taking dangerous actions.
                        Implement Control Barrier Functions (CBF) and safety layers.
                    </p>
<div class="mermaid">
                    graph LR
                        A[RL Policy œÄ] --&gt;|Dangerous Action?| B[Safety Filter]
                        B --&gt;|Safe Action| C[Execute]
                        B --&gt;|Constraint Violation| D[Safe Alternative Action]
                        D --&gt; C
                    </div>
<pre><code class="language-python"># Requirements:
# - Python 3.9+
# - numpy&gt;=1.24.0, &lt;2.0.0
# - torch&gt;=2.0.0, &lt;2.3.0

# Safe Exploration: Safety Filter Implementation
import numpy as np
import torch
import torch.nn as nn

class SafetyConstraints:
    &quot;&quot;&quot;Safety constraints for CSTR&quot;&quot;&quot;
    def __init__(self):
        # Temperature constraints
        self.T_min = 310.0  # [K]
        self.T_max = 390.0  # [K]
        self.T_target = 350.0

        # Concentration constraints
        self.CA_min = 0.1  # [mol/L]
        self.CA_max = 3.0

        # Control input constraints
        self.u_min = -100.0  # Maximum cooling [kW]
        self.u_max = 50.0    # Maximum heating [kW]

        # Rate of change constraints
        self.du_max = 20.0  # [kW/step]

    def is_safe_state(self, state):
        &quot;&quot;&quot;Check if state is safe&quot;&quot;&quot;
        T, CA = state
        return (self.T_min &lt;= T &lt;= self.T_max and
                self.CA_min &lt;= CA &lt;= self.CA_max)

    def is_safe_action(self, state, action, prev_action):
        &quot;&quot;&quot;Check if action is safe&quot;&quot;&quot;
        # Control input range
        if not (self.u_min &lt;= action &lt;= self.u_max):
            return False

        # Rate of change constraint
        if abs(action - prev_action) &gt; self.du_max:
            return False

        return True

    def project_to_safe(self, action, prev_action):
        &quot;&quot;&quot;Project action to safe region&quot;&quot;&quot;
        # Range constraint
        action = np.clip(action, self.u_min, self.u_max)

        # Rate of change constraint
        delta = action - prev_action
        if abs(delta) &gt; self.du_max:
            action = prev_action + np.sign(delta) * self.du_max

        return action

class ControlBarrierFunction:
    &quot;&quot;&quot;Safety assurance with Control Barrier Function (CBF)&quot;&quot;&quot;
    def __init__(self, safety_constraints):
        self.constraints = safety_constraints
        self.alpha = 0.5  # Class K function gain

    def barrier_function(self, state):
        &quot;&quot;&quot;Barrier function h(x) &gt;= 0 is safe region&quot;&quot;&quot;
        T, CA = state

        # Temperature barrier (distance function)
        h_T_min = T - self.constraints.T_min
        h_T_max = self.constraints.T_max - T

        # Concentration barrier
        h_CA_min = CA - self.constraints.CA_min
        h_CA_max = self.constraints.CA_max - CA

        # Minimum value (strictest constraint)
        return min(h_T_min, h_T_max, h_CA_min, h_CA_max)

    def safe_action(self, state, desired_action, env_model):
        &quot;&quot;&quot;Calculate safe action satisfying CBF constraint&quot;&quot;&quot;
        h = self.barrier_function(state)

        # Do nothing if in safe region
        if h &gt; 10.0:
            return desired_action

        # Impose constraint near boundary
        # Simple implementation: check barrier condition for predicted next state
        next_state_pred = env_model.predict(state, desired_action)
        h_next = self.barrier_function(next_state_pred)

        # CBF condition: h_next &gt;= -alpha * h
        if h_next &gt;= -self.alpha * h:
            return desired_action
        else:
            # Modify to safe side (conservative action)
            T, CA = state
            if T &gt; self.constraints.T_target:
                # Enhance cooling
                return max(desired_action, 0)
            else:
                # Suppress heating
                return min(desired_action, 0)

class SimpleCSTRModel:
    &quot;&quot;&quot;Simple prediction model for CSTR&quot;&quot;&quot;
    def predict(self, state, action, dt=0.1):
        T, CA = state
        k = 1e10 * np.exp(-50000 / (8.314 * T))

        # Simple dynamics
        dCA = -k * CA * dt
        dT = (action * 1000 - 400 * (T - 350)) / 4180 * dt

        return np.array([T + dT, CA + dCA])

# Usage example
safety = SafetyConstraints()
cbf = ControlBarrierFunction(safety)
model = SimpleCSTRModel()

# Apply safety filter to RL agent actions
class SafeRLAgent:
    def __init__(self, base_agent, safety_filter):
        self.base_agent = base_agent
        self.safety_filter = safety_filter
        self.prev_action = 0.0

    def select_safe_action(self, state):
        # Base agent action
        desired_action = self.base_agent.select_action(state)[0] * 100

        # Apply safety filter
        safe_action = self.safety_filter.project_to_safe(
            desired_action, self.prev_action)

        # CBF constraint
        safe_action = cbf.safe_action(state, safe_action, model)

        self.prev_action = safe_action
        return safe_action

# Simulation
from example1 import RobustSACAgent, RandomizedCSTREnv

base_agent = RobustSACAgent(obs_dim=2, action_dim=1)
safe_agent = SafeRLAgent(base_agent, safety)
env = RandomizedCSTREnv(randomize=False)

print(&quot;Running with safety constraints...&quot;)
state = env.reset()
unsafe_count = 0

for step in range(200):
    action = safe_agent.select_safe_action(state)
    next_state, reward, done = env.step(action / 100)

    if not safety.is_safe_state(state):
        unsafe_count += 1
        print(f&quot;Step {step}: UNSAFE STATE! T={state[0]:.1f}K, CA={state[1]:.3f}&quot;)

    state = next_state

    if done:
        break

print(f&quot;\nUnsafe states encountered: {unsafe_count} / {step+1}&quot;)
print(f&quot;Safety rate: {(1 - unsafe_count/(step+1))*100:.1f}%&quot;)</code></pre>
</div>
</section>
<section id="example3">
<div class="example-box">
<div class="example-title">
<span class="example-number">3</span>
                        Conservative Q-Learning (CQL): Conservative Offline Learning
                    </div>
<p>
                        In real plants, exploration is dangerous, so we learn offline from historical data.
                        CQL underestimates Q-values for out-of-distribution actions, learning safe policies.
                    </p>
<div class="formula-box">
<p><strong>CQL Objective Function:</strong></p>
                        \[
                        \min_Q \alpha \cdot \mathbb{E}_{s \sim \mathcal{D}} \left[ \log \sum_a \exp(Q(s,a)) - \mathbb{E}_{a \sim \mu(a|s)} [Q(s,a)] \right] + \mathcal{L}_{TD}(Q)
                        \]
                        <p>First term: lower Q-values for out-of-distribution actions, second term: maintain Q-values for in-data actions</p>
</div>
<pre><code class="language-python"># Requirements:
# - Python 3.9+
# - numpy&gt;=1.24.0, &lt;2.0.0
# - torch&gt;=2.0.0, &lt;2.3.0

# Conservative Q-Learning (CQL) Implementation
import torch
import torch.nn as nn
import torch.optim as optim
import numpy as np
from collections import deque
import random

class CQLQNetwork(nn.Module):
    &quot;&quot;&quot;Q function for CQL&quot;&quot;&quot;
    def __init__(self, state_dim, action_dim):
        super().__init__()
        self.net = nn.Sequential(
            nn.Linear(state_dim + action_dim, 256), nn.ReLU(),
            nn.Linear(256, 256), nn.ReLU(),
            nn.Linear(256, 1)
        )

    def forward(self, state, action):
        x = torch.cat([state, action], dim=-1)
        return self.net(x)

class CQLAgent:
    &quot;&quot;&quot;Conservative Q-Learning Agent&quot;&quot;&quot;
    def __init__(self, state_dim, action_dim, alpha=1.0):
        self.state_dim = state_dim
        self.action_dim = action_dim
        self.alpha = alpha  # CQL regularization coefficient

        self.q_net = CQLQNetwork(state_dim, action_dim)
        self.target_q = CQLQNetwork(state_dim, action_dim)
        self.target_q.load_state_dict(self.q_net.state_dict())

        self.policy = nn.Sequential(
            nn.Linear(state_dim, 256), nn.ReLU(),
            nn.Linear(256, action_dim), nn.Tanh()
        )

        self.q_optimizer = optim.Adam(self.q_net.parameters(), lr=3e-4)
        self.policy_optimizer = optim.Adam(self.policy.parameters(), lr=3e-4)

    def select_action(self, state, deterministic=False):
        with torch.no_grad():
            state_t = torch.FloatTensor(state).unsqueeze(0)
            action = self.policy(state_t)
            if not deterministic:
                action += torch.randn_like(action) * 0.1
            return action.squeeze().numpy()

    def train_step(self, batch):
        &quot;&quot;&quot;CQL update&quot;&quot;&quot;
        states, actions, rewards, next_states, dones = batch

        states_t = torch.FloatTensor(states)
        actions_t = torch.FloatTensor(actions)
        rewards_t = torch.FloatTensor(rewards).unsqueeze(1)
        next_states_t = torch.FloatTensor(next_states)
        dones_t = torch.FloatTensor(dones).unsqueeze(1)

        # Q function update
        # 1. Bellman error
        with torch.no_grad():
            next_actions = self.policy(next_states_t)
            target_q = rewards_t + 0.99 * self.target_q(
                next_states_t, next_actions) * (1 - dones_t)

        current_q = self.q_net(states_t, actions_t)
        bellman_loss = nn.MSELoss()(current_q, target_q)

        # 2. CQL regularization term
        # Calculate Q values for random actions
        num_random = 10
        random_actions = torch.FloatTensor(
            np.random.uniform(-1, 1, (states_t.shape[0], num_random, self.action_dim)))

        random_q = []
        for i in range(num_random):
            q = self.q_net(states_t, random_actions[:, i, :])
            random_q.append(q)
        random_q = torch.cat(random_q, dim=1)

        # Q values for policy actions
        policy_actions = self.policy(states_t)
        policy_q = self.q_net(states_t, policy_actions)

        # CQL term: estimate random action Q-values high, in-data actions low
        cql_loss = (torch.logsumexp(random_q, dim=1).mean() -
                    policy_q.mean())

        # Total loss
        q_loss = bellman_loss + self.alpha * cql_loss

        self.q_optimizer.zero_grad()
        q_loss.backward()
        self.q_optimizer.step()

        # 3. Policy update (maximize Q-value)
        policy_loss = -self.q_net(states_t, self.policy(states_t)).mean()

        self.policy_optimizer.zero_grad()
        policy_loss.backward()
        self.policy_optimizer.step()

        # Target update
        for target_param, param in zip(self.target_q.parameters(),
                                        self.q_net.parameters()):
            target_param.data.copy_(0.995 * target_param.data + 0.005 * param.data)

        return q_loss.item(), cql_loss.item(), policy_loss.item()

# Offline dataset generation (past operational data)
def generate_offline_data(n_trajectories=100):
    from example1 import RandomizedCSTREnv

    env = RandomizedCSTREnv(randomize=True)
    dataset = []

    for _ in range(n_trajectories):
        state = env.reset()
        for _ in range(50):
            # Random policy + noise (realistic data)
            action = np.random.uniform(-1, 1, 1)
            next_state, reward, done = env.step(action[0])
            dataset.append((state, action, reward, next_state, done))
            state = next_state
            if done:
                break

    return dataset

# CQL learning
print(&quot;Generating offline data...&quot;)
offline_data = generate_offline_data(n_trajectories=200)
print(f&quot;Dataset size: {len(offline_data)}&quot;)

agent = CQLAgent(state_dim=2, action_dim=1, alpha=1.0)

print(&quot;\nCQL training in progress...&quot;)
batch_size = 256
for epoch in range(100):
    # Mini-batch sampling
    batch = random.sample(offline_data, min(batch_size, len(offline_data)))
    states, actions, rewards, next_states, dones = zip(*batch)

    batch_tuple = (
        np.array(states),
        np.array(actions),
        np.array(rewards),
        np.array(next_states),
        np.array(dones)
    )

    q_loss, cql_loss, p_loss = agent.train_step(batch_tuple)

    if epoch % 20 == 0:
        print(f&quot;Epoch {epoch}: Q_loss={q_loss:.3f}, CQL_loss={cql_loss:.3f}, &quot;
              f&quot;Policy_loss={p_loss:.3f}&quot;)

# Test
print(&quot;\nTesting CQL policy...&quot;)
from example1 import RandomizedCSTREnv
test_env = RandomizedCSTREnv(randomize=False)

state = test_env.reset()
total_reward = 0

for step in range(100):
    action = agent.select_action(state, deterministic=True)
    next_state, reward, done = test_env.step(action[0])
    total_reward += reward
    state = next_state
    if done:
        break

print(f&quot;Test Reward: {total_reward:.2f}&quot;)</code></pre>
</div>
</section>
<section id="example4">
<div class="example-box">
<div class="example-title">
<span class="example-number">4</span>
                        Human-in-the-Loop: Human Override Mechanism
                    </div>
<p>
                        When AI agents take unexpected actions, operators need to be able to intervene.
                        Implement intervention decision-making, smooth transitions, and history recording.
                    </p>
<div class="mermaid">
                    graph TD
                        A[AI Control] --&gt;|Anomaly Detection| B{Human Decision}
                        B --&gt;|OK| A
                        B --&gt;|Intervene| C[Manual Control]
                        C --&gt;|Stabilization| D{Return Condition}
                        D --&gt;|Satisfied| A
                        D --&gt;|Not Satisfied| C
                    </div>
<pre><code class="language-python"># Requirements:
# - Python 3.9+
# - numpy&gt;=1.24.0, &lt;2.0.0

# Human-in-the-Loop System Implementation
import numpy as np
import time
from datetime import datetime
from enum import Enum

class ControlMode(Enum):
    &quot;&quot;&quot;Control mode&quot;&quot;&quot;
    AI_CONTROL = &quot;AI&quot;
    HUMAN_OVERRIDE = &quot;Human&quot;
    TRANSITION = &quot;Transition&quot;

class HumanOverrideSystem:
    &quot;&quot;&quot;Human intervention system&quot;&quot;&quot;
    def __init__(self):
        self.mode = ControlMode.AI_CONTROL
        self.intervention_history = []
        self.confidence_threshold = 0.7

    def check_intervention_needed(self, state, ai_action, confidence):
        &quot;&quot;&quot;Check if intervention is needed&quot;&quot;&quot;
        T, CA = state

        # Trigger conditions
        triggers = {
            'high_temp': T &gt; 380,
            'low_temp': T &lt; 320,
            'low_confidence': confidence &lt; self.confidence_threshold,
            'extreme_action': abs(ai_action) &gt; 0.9,
            'unstable_state': CA &lt; 0.2 or CA &gt; 2.8
        }

        if any(triggers.values()):
            reason = [k for k, v in triggers.items() if v]
            return True, reason
        return False, []

    def request_human_action(self, state, ai_suggestion):
        &quot;&quot;&quot;Request action from operator (GUI/CLI in practice)&quot;&quot;&quot;
        T, CA = state
        print(f&quot;\n{'='*60}&quot;)
        print(f&quot;Human Intervention Requested!&quot;)
        print(f&quot;Current State: T={T:.2f}K, CA={CA:.3f}mol/L&quot;)
        print(f&quot;AI Suggested Action: {ai_suggestion:.3f}&quot;)
        print(f&quot;{'='*60}&quot;)

        # Simplified: simulate with rule-based
        # In practice, wait for operator input
        if T &gt; 380:
            human_action = -0.8  # Strong cooling
            override = True
        elif T &lt; 320:
            human_action = 0.6   # Heating
            override = True
        else:
            human_action = ai_suggestion
            override = False

        return human_action, override

    def smooth_transition(self, from_action, to_action, alpha=0.3):
        &quot;&quot;&quot;Smooth control transition&quot;&quot;&quot;
        return alpha * to_action + (1 - alpha) * from_action

    def log_intervention(self, timestamp, state, ai_action, human_action, reason):
        &quot;&quot;&quot;Log intervention history&quot;&quot;&quot;
        log_entry = {
            'timestamp': timestamp,
            'state': state.copy(),
            'ai_action': ai_action,
            'human_action': human_action,
            'reason': reason
        }
        self.intervention_history.append(log_entry)

    def generate_report(self):
        &quot;&quot;&quot;Generate intervention report&quot;&quot;&quot;
        if not self.intervention_history:
            return &quot;No interventions recorded.&quot;

        report = &quot;\n&quot; + &quot;=&quot;*60 + &quot;\n&quot;
        report += &quot;Human Intervention Report\n&quot;
        report += &quot;=&quot;*60 + &quot;\n&quot;
        report += f&quot;Total interventions: {len(self.intervention_history)}\n\n&quot;

        for i, entry in enumerate(self.intervention_history):
            report += f&quot;Intervention {i+1}:\n&quot;
            report += f&quot;  Time: {entry['timestamp']}\n&quot;
            report += f&quot;  State: T={entry['state'][0]:.2f}K, CA={entry['state'][1]:.3f}\n&quot;
            report += f&quot;  AI action: {entry['ai_action']:.3f}\n&quot;
            report += f&quot;  Human action: {entry['human_action']:.3f}\n&quot;
            report += f&quot;  Reason: {', '.join(entry['reason'])}\n\n&quot;

        return report

class HITLController:
    &quot;&quot;&quot;Human-in-the-Loop control system&quot;&quot;&quot;
    def __init__(self, ai_agent, override_system):
        self.ai_agent = ai_agent
        self.override_system = override_system
        self.prev_action = 0.0

    def select_action(self, state, confidence=1.0):
        &quot;&quot;&quot;Action selection considering human intervention&quot;&quot;&quot;
        # AI suggestion
        ai_action = self.ai_agent.select_action(state)[0]

        # Intervention decision
        need_intervention, reasons = self.override_system.check_intervention_needed(
            state, ai_action, confidence)

        if need_intervention:
            # Query human
            human_action, overridden = self.override_system.request_human_action(
                state, ai_action)

            if overridden:
                # Record intervention
                self.override_system.log_intervention(
                    datetime.now(), state, ai_action, human_action, reasons)
                self.override_system.mode = ControlMode.HUMAN_OVERRIDE
                final_action = human_action
            else:
                final_action = ai_action
        else:
            final_action = ai_action
            self.override_system.mode = ControlMode.AI_CONTROL

        # Smooth transition
        final_action = self.override_system.smooth_transition(
            self.prev_action, final_action)

        self.prev_action = final_action
        return final_action

# Usage example
from example1 import RobustSACAgent, RandomizedCSTREnv

print(&quot;Launching Human-in-the-Loop system...&quot;)

ai_agent = RobustSACAgent(obs_dim=2, action_dim=1)
override_system = HumanOverrideSystem()
controller = HITLController(ai_agent, override_system)

env = RandomizedCSTREnv(randomize=True)
state = env.reset()

# Test under severe conditions
for step in range(50):
    # Simulate confidence (high uncertainty situation)
    confidence = np.random.uniform(0.5, 1.0)

    action = controller.select_action(state, confidence)
    next_state, reward, done = env.step(action)

    print(f&quot;Step {step}: Mode={override_system.mode.value}, &quot;
          f&quot;T={state[0]:.1f}K, Action={action:.3f}&quot;)

    state = next_state

    if done:
        print(&quot;Episode ended (abnormal state)&quot;)
        break

# Generate report
print(override_system.generate_report())</code></pre>
</div>
</section>
<section id="example5">
<div class="example-box">
<div class="example-title">
<span class="example-number">5</span>
                        Uncertainty Quantification: Bayesian NN and Ensemble Methods
                    </div>
<p>
                        By quantifying how confident AI predictions are, take conservative actions in situations with high uncertainty.
                        Estimate confidence intervals using Bayesian neural networks or ensemble methods.
                    </p>
<pre><code class="language-python"># Requirements:
# - Python 3.9+
# - numpy&gt;=1.24.0, &lt;2.0.0
# - torch&gt;=2.0.0, &lt;2.3.0

# Uncertainty Quantification: Ensemble and Bayesian Approximation
import torch
import torch.nn as nn
import numpy as np

class EnsembleQNetwork:
    &quot;&quot;&quot;Ensemble of Q functions&quot;&quot;&quot;
    def __init__(self, state_dim, action_dim, n_models=5):
        self.n_models = n_models
        self.models = [
            nn.Sequential(
                nn.Linear(state_dim + action_dim, 128), nn.ReLU(),
                nn.Linear(128, 128), nn.ReLU(),
                nn.Linear(128, 1)
            ) for _ in range(n_models)
        ]
        self.optimizers = [
            torch.optim.Adam(m.parameters(), lr=1e-3) for m in self.models
        ]

    def predict_with_uncertainty(self, state, action):
        &quot;&quot;&quot;Return prediction mean and uncertainty (standard deviation)&quot;&quot;&quot;
        state_t = torch.FloatTensor(state).unsqueeze(0)
        action_t = torch.FloatTensor(action).unsqueeze(0)
        x = torch.cat([state_t, action_t], dim=-1)

        predictions = []
        for model in self.models:
            with torch.no_grad():
                pred = model(x).item()
            predictions.append(pred)

        mean = np.mean(predictions)
        std = np.std(predictions)

        return mean, std

    def train_step(self, batch):
        &quot;&quot;&quot;Train all models with different bootstrap samples&quot;&quot;&quot;
        states, actions, targets = batch

        losses = []
        for i, (model, opt) in enumerate(zip(self.models, self.optimizers)):
            # Bootstrap sampling
            indices = np.random.choice(len(states), len(states), replace=True)
            s = torch.FloatTensor(states[indices])
            a = torch.FloatTensor(actions[indices])
            t = torch.FloatTensor(targets[indices])

            x = torch.cat([s, a], dim=-1)
            pred = model(x).squeeze()

            loss = nn.MSELoss()(pred, t)
            opt.zero_grad()
            loss.backward()
            opt.step()

            losses.append(loss.item())

        return np.mean(losses)

class MCDropoutQNetwork(nn.Module):
    &quot;&quot;&quot;Monte Carlo Dropout (Bayesian approximation)&quot;&quot;&quot;
    def __init__(self, state_dim, action_dim, dropout_rate=0.1):
        super().__init__()
        self.net = nn.Sequential(
            nn.Linear(state_dim + action_dim, 128),
            nn.ReLU(),
            nn.Dropout(dropout_rate),
            nn.Linear(128, 128),
            nn.ReLU(),
            nn.Dropout(dropout_rate),
            nn.Linear(128, 1)
        )

    def forward(self, state, action):
        x = torch.cat([state, action], dim=-1)
        return self.net(x)

    def predict_with_uncertainty(self, state, action, n_samples=20):
        &quot;&quot;&quot;Uncertainty estimation with MC Dropout&quot;&quot;&quot;
        self.train()  # Enable Dropout

        state_t = torch.FloatTensor(state).unsqueeze(0)
        action_t = torch.FloatTensor(action).unsqueeze(0)

        predictions = []
        for _ in range(n_samples):
            pred = self.forward(state_t, action_t).item()
            predictions.append(pred)

        mean = np.mean(predictions)
        std = np.std(predictions)

        return mean, std

class UncertaintyAwareAgent:
    &quot;&quot;&quot;Agent considering uncertainty&quot;&quot;&quot;
    def __init__(self, state_dim, action_dim, method='ensemble'):
        self.method = method
        if method == 'ensemble':
            self.q_network = EnsembleQNetwork(state_dim, action_dim, n_models=5)
        else:
            self.q_network = MCDropoutQNetwork(state_dim, action_dim)

        self.policy = nn.Sequential(
            nn.Linear(state_dim, 128), nn.ReLU(),
            nn.Linear(128, action_dim), nn.Tanh()
        )
        self.uncertainty_threshold = 0.5  # Uncertainty threshold

    def select_action(self, state):
        &quot;&quot;&quot;Action selection considering uncertainty&quot;&quot;&quot;
        with torch.no_grad():
            nominal_action = self.policy(torch.FloatTensor(state)).numpy()

        # Evaluate uncertainty of multiple candidates
        action_candidates = [
            nominal_action,
            nominal_action * 0.5,  # Conservative
            np.zeros_like(nominal_action)  # Maintain current
        ]

        best_action = nominal_action
        min_uncertainty = float('inf')

        for action in action_candidates:
            if self.method == 'ensemble':
                q_mean, q_std = self.q_network.predict_with_uncertainty(state, action)
            else:
                q_mean, q_std = self.q_network.predict_with_uncertainty(state, action)

            # Select action with low uncertainty and high Q-value
            if q_std &lt; self.uncertainty_threshold and q_std &lt; min_uncertainty:
                best_action = action
                min_uncertainty = q_std

        return best_action, min_uncertainty

# Demonstration
print(&quot;Uncertainty Quantification Demo\n&quot;)

# Ensemble method
ensemble_agent = UncertaintyAwareAgent(state_dim=2, action_dim=1, method='ensemble')

test_states = [
    np.array([350.0, 1.5]),  # Normal
    np.array([385.0, 0.8]),  # High temperature
    np.array([310.0, 2.5])   # Low temperature
]

print(&quot;Ensemble Method:&quot;)
for i, state in enumerate(test_states):
    action, uncertainty = ensemble_agent.select_action(state)
    print(f&quot;State {i+1}: T={state[0]}K, CA={state[1]}&quot;)
    print(f&quot;  Action: {action[0]:.3f}, Uncertainty: {uncertainty:.3f}&quot;)

    if uncertainty &gt; ensemble_agent.uncertainty_threshold:
        print(f&quot;  WARNING: High uncertainty! Consider human oversight.&quot;)
    print()

# MC Dropout method
mc_agent = UncertaintyAwareAgent(state_dim=2, action_dim=1, method='mcdropout')

print(&quot;\nMC Dropout Method:&quot;)
for i, state in enumerate(test_states):
    action, uncertainty = mc_agent.select_action(state)
    print(f&quot;State {i+1}: T={state[0]}K, CA={state[1]}&quot;)
    print(f&quot;  Action: {action[0]:.3f}, Uncertainty: {uncertainty:.3f}&quot;)

    if uncertainty &gt; mc_agent.uncertainty_threshold:
        print(f&quot;  WARNING: High uncertainty!&quot;)
    print()</code></pre>
</div>
</section>
<section id="example6">
<div class="example-box">
<div class="example-title">
<span class="example-number">6</span>
                        Performance Monitoring and Drift Detection
                    </div>
<p>
                        Continuously monitor performance after deployment to detect plant aging and model drift.
                        Implement KPI monitoring, statistical testing, and anomaly detection.
                    </p>
<pre><code class="language-python"># Requirements:
# - Python 3.9+
# - numpy&gt;=1.24.0, &lt;2.0.0
# - scipy&gt;=1.11.0

# Performance Monitoring and Drift Detection System
import numpy as np
from collections import deque
from scipy import stats

class PerformanceMonitor:
    &quot;&quot;&quot;Performance monitoring system&quot;&quot;&quot;
    def __init__(self, window_size=100):
        self.window_size = window_size

        # KPI history
        self.rewards = deque(maxlen=window_size)
        self.temperatures = deque(maxlen=window_size)
        self.concentrations = deque(maxlen=window_size)
        self.actions = deque(maxlen=window_size)

        # Baseline statistics
        self.baseline_reward_mean = None
        self.baseline_reward_std = None

        # Anomaly counter
        self.anomaly_count = 0
        self.total_steps = 0

    def update(self, state, action, reward):
        &quot;&quot;&quot;Update KPI&quot;&quot;&quot;
        T, CA = state
        self.rewards.append(reward)
        self.temperatures.append(T)
        self.concentrations.append(CA)
        self.actions.append(action)
        self.total_steps += 1

    def set_baseline(self):
        &quot;&quot;&quot;Set baseline performance&quot;&quot;&quot;
        if len(self.rewards) &gt;= self.window_size:
            self.baseline_reward_mean = np.mean(self.rewards)
            self.baseline_reward_std = np.std(self.rewards)
            print(f&quot;Baseline set: Œº={self.baseline_reward_mean:.2f}, &quot;
                  f&quot;œÉ={self.baseline_reward_std:.2f}&quot;)

    def detect_drift(self, alpha=0.05):
        &quot;&quot;&quot;Statistical drift detection (t-test)&quot;&quot;&quot;
        if self.baseline_reward_mean is None or len(self.rewards) &lt; 50:
            return False, None

        current_mean = np.mean(list(self.rewards)[-50:])

        # t-test
        t_stat, p_value = stats.ttest_1samp(
            list(self.rewards)[-50:],
            self.baseline_reward_mean
        )

        drift_detected = p_value &lt; alpha and current_mean &lt; self.baseline_reward_mean

        return drift_detected, {
            't_stat': t_stat,
            'p_value': p_value,
            'current_mean': current_mean,
            'baseline_mean': self.baseline_reward_mean
        }

    def detect_anomaly(self, state, action):
        &quot;&quot;&quot;Anomaly detection (3-sigma rule)&quot;&quot;&quot;
        if len(self.rewards) &lt; 30:
            return False

        T, CA = state

        # Temperature anomaly
        temp_mean = np.mean(self.temperatures)
        temp_std = np.std(self.temperatures)
        temp_anomaly = abs(T - temp_mean) &gt; 3 * temp_std

        # Concentration anomaly
        conc_mean = np.mean(self.concentrations)
        conc_std = np.std(self.concentrations)
        conc_anomaly = abs(CA - conc_mean) &gt; 3 * conc_std

        # Action anomaly
        action_mean = np.mean(self.actions)
        action_std = np.std(self.actions)
        action_anomaly = abs(action - action_mean) &gt; 3 * action_std

        is_anomaly = temp_anomaly or conc_anomaly or action_anomaly

        if is_anomaly:
            self.anomaly_count += 1

        return is_anomaly

    def generate_report(self):
        &quot;&quot;&quot;Generate monitoring report&quot;&quot;&quot;
        if len(self.rewards) == 0:
            return &quot;No data collected.&quot;

        report = &quot;\n&quot; + &quot;=&quot;*60 + &quot;\n&quot;
        report += &quot;Performance Monitoring Report\n&quot;
        report += &quot;=&quot;*60 + &quot;\n\n&quot;

        report += f&quot;Total steps: {self.total_steps}\n&quot;
        report += f&quot;Anomalies detected: {self.anomaly_count} &quot;
        report += f&quot;({self.anomaly_count/self.total_steps*100:.2f}%)\n\n&quot;

        report += &quot;KPI Statistics (last {} steps):\n&quot;.format(len(self.rewards))
        report += f&quot;  Reward: Œº={np.mean(self.rewards):.2f}, &quot;
        report += f&quot;œÉ={np.std(self.rewards):.2f}\n&quot;
        report += f&quot;  Temperature: Œº={np.mean(self.temperatures):.2f}K, &quot;
        report += f&quot;œÉ={np.std(self.temperatures):.2f}K\n&quot;
        report += f&quot;  Concentration: Œº={np.mean(self.concentrations):.3f}, &quot;
        report += f&quot;œÉ={np.std(self.concentrations):.3f}\n&quot;
        report += f&quot;  Action: Œº={np.mean(self.actions):.3f}, &quot;
        report += f&quot;œÉ={np.std(self.actions):.3f}\n\n&quot;

        # Drift detection
        drift, drift_info = self.detect_drift()
        if drift:
            report += &quot;WARNING: Performance drift detected!\n&quot;
            report += f&quot;  Current mean reward: {drift_info['current_mean']:.2f}\n&quot;
            report += f&quot;  Baseline mean reward: {drift_info['baseline_mean']:.2f}\n&quot;
            report += f&quot;  p-value: {drift_info['p_value']:.4f}\n&quot;
        else:
            report += &quot;No significant drift detected.\n&quot;

        report += &quot;=&quot;*60 + &quot;\n&quot;
        return report

class DriftDetector:
    &quot;&quot;&quot;More advanced drift detection (ADWIN)&quot;&quot;&quot;
    def __init__(self, delta=0.002):
        self.delta = delta
        self.window = deque()
        self.drift_detected = False

    def add_element(self, value):
        &quot;&quot;&quot;Add data point and check for drift&quot;&quot;&quot;
        self.window.append(value)

        # Simplified ADWIN: split window in half and compare means
        if len(self.window) &gt; 50:
            mid = len(self.window) // 2
            window1 = list(self.window)[:mid]
            window2 = list(self.window)[mid:]

            # Welch's t-test (does not assume equal variance)
            t_stat, p_value = stats.ttest_ind(window1, window2, equal_var=False)

            if p_value &lt; self.delta:
                self.drift_detected = True
                self.window.clear()  # Reset after drift detection
                return True

        return False

# Demonstration
from example1 import RandomizedCSTREnv, RobustSACAgent

print(&quot;Launching performance monitoring system...\n&quot;)

env = RandomizedCSTREnv(randomize=False)
agent = RobustSACAgent(obs_dim=2, action_dim=1)
monitor = PerformanceMonitor(window_size=100)
drift_detector = DriftDetector()

# Phase 1: Normal operation (baseline setting)
print(&quot;Phase 1: Setting baseline...&quot;)
state = env.reset()

for step in range(100):
    action = agent.select_action(state)
    next_state, reward, done = env.step(action[0])

    monitor.update(state, action[0], reward)

    state = next_state if not done else env.reset()

monitor.set_baseline()

# Phase 2: Degradation simulation
print(&quot;\nPhase 2: Simulating plant degradation...&quot;)

for step in range(200):
    action = agent.select_action(state)

    # Simulate performance degradation over time
    degradation = step / 200 * 0.3
    next_state, reward, done = env.step(action[0])
    reward -= degradation * 10  # Performance decline

    monitor.update(state, action[0], reward)

    # Anomaly detection
    if monitor.detect_anomaly(state, action[0]):
        print(f&quot;Step {step+100}: Anomaly detected!&quot;)

    # Drift detection
    if drift_detector.add_element(reward):
        print(f&quot;Step {step+100}: DRIFT DETECTED by ADWIN!&quot;)

    state = next_state if not done else env.reset()

    # Periodic drift check
    if step % 50 == 0:
        drift, info = monitor.detect_drift()
        if drift:
            print(f&quot;\nStep {step+100}: Statistical drift detected!&quot;)
            print(f&quot;  Current: {info['current_mean']:.2f}, &quot;
                  f&quot;Baseline: {info['baseline_mean']:.2f}&quot;)

# Final report
print(monitor.generate_report())</code></pre>
</div>
</section>
<section id="example7">
<div class="example-box">
<div class="example-title">
<span class="example-number">7</span>
                        Integrated Deployment Framework
                    </div>
<p>
                        A practical deployment system integrating all previous elements (domain randomization, safety constraints, human override,
                        uncertainty quantification, performance monitoring).
                    </p>
<div class="mermaid">
                    graph TD
                        A[Sensor Data] --&gt; B[Preprocessing]
                        B --&gt; C[Uncertainty Estimation]
                        C --&gt; D{High Uncertainty?}
                        D --&gt;|Yes| E[Conservative Action]
                        D --&gt;|No| F[AI Policy]
                        F --&gt; G[Safety Filter]
                        E --&gt; G
                        G --&gt; H{Safe?}
                        H --&gt;|No| I[Human Override]
                        H --&gt;|Yes| J[Actuator]
                        I --&gt; J
                        J --&gt; K[Performance Monitoring]
                        K --&gt; L{Drift?}
                        L --&gt;|Yes| M[Alert + Retraining]
                        L --&gt;|No| A
                    </div>
<pre><code class="language-python"># Requirements:
# - Python 3.9+
# - numpy&gt;=1.24.0, &lt;2.0.0
# - torch&gt;=2.0.0, &lt;2.3.0

# Integrated Deployment Framework
import numpy as np
import torch
from datetime import datetime

class IntegratedDeploymentSystem:
    &quot;&quot;&quot;Fully integrated deployment system&quot;&quot;&quot;
    def __init__(self, agent, env):
        # Components
        self.agent = agent
        self.env = env

        # Example 2: Safety constraints
        from example2 import SafetyConstraints, ControlBarrierFunction, SimpleCSTRModel
        self.safety = SafetyConstraints()
        self.cbf = ControlBarrierFunction(self.safety)
        self.model = SimpleCSTRModel()

        # Example 4: Human override
        from example4 import HumanOverrideSystem, ControlMode
        self.override_system = HumanOverrideSystem()

        # Example 5: Uncertainty quantification
        from example5 import EnsembleQNetwork
        self.uncertainty_estimator = EnsembleQNetwork(
            state_dim=2, action_dim=1, n_models=5)

        # Example 6: Performance monitoring
        from example6 import PerformanceMonitor, DriftDetector
        self.monitor = PerformanceMonitor(window_size=100)
        self.drift_detector = DriftDetector()

        # System state
        self.prev_action = 0.0
        self.running = True
        self.emergency_stop = False

    def preprocess_observation(self, raw_obs):
        &quot;&quot;&quot;Preprocess sensor data&quot;&quot;&quot;
        # Outlier removal (simple)
        T, CA = raw_obs
        T = np.clip(T, 250, 450)
        CA = np.clip(CA, 0, 5)
        return np.array([T, CA])

    def estimate_uncertainty(self, state, action):
        &quot;&quot;&quot;Estimate uncertainty&quot;&quot;&quot;
        q_mean, q_std = self.uncertainty_estimator.predict_with_uncertainty(
            state, action)
        return q_std

    def apply_safety_filter(self, state, action):
        &quot;&quot;&quot;Apply safety filter&quot;&quot;&quot;
        # Constraint projection
        safe_action = self.safety.project_to_safe(action, self.prev_action)

        # CBF constraint
        safe_action = self.cbf.safe_action(state, safe_action, self.model)

        return safe_action

    def check_human_override(self, state, action, uncertainty):
        &quot;&quot;&quot;Check for human intervention&quot;&quot;&quot;
        need_intervention, reasons = self.override_system.check_intervention_needed(
            state, action, confidence=1.0 - uncertainty)

        if need_intervention:
            human_action, overridden = self.override_system.request_human_action(
                state, action)

            if overridden:
                self.override_system.log_intervention(
                    datetime.now(), state, action, human_action, reasons)
                return human_action, True

        return action, False

    def monitor_performance(self, state, action, reward):
        &quot;&quot;&quot;Performance monitoring and drift detection&quot;&quot;&quot;
        self.monitor.update(state, action, reward)

        # Anomaly detection
        if self.monitor.detect_anomaly(state, action):
            print(f&quot;  [MONITOR] Anomaly detected at step {self.monitor.total_steps}&quot;)

        # Drift detection
        if self.drift_detector.add_element(reward):
            print(f&quot;  [MONITOR] Performance drift detected!&quot;)
            return True  # Retraining trigger

        # Periodic statistical drift check
        if self.monitor.total_steps % 100 == 0:
            drift, info = self.monitor.detect_drift()
            if drift:
                print(f&quot;  [MONITOR] Statistical drift: &quot;
                      f&quot;current={info['current_mean']:.2f}, &quot;
                      f&quot;baseline={info['baseline_mean']:.2f}&quot;)
                return True

        return False

    def control_loop(self, n_steps=500):
        &quot;&quot;&quot;Main control loop&quot;&quot;&quot;
        print(&quot;Integrated Deployment System Launch\n&quot;)
        print(&quot;=&quot;*60)

        state = self.env.reset()
        state = self.preprocess_observation(state)

        # Baseline setting
        for step in range(100):
            action = self.agent.select_action(state)[0]
            next_state, reward, done = self.env.step(action)
            next_state = self.preprocess_observation(next_state)

            self.monitor.update(state, action, reward)
            state = next_state if not done else self.env.reset()

        self.monitor.set_baseline()
        print(&quot;Baseline setting complete\n&quot;)

        # Main loop
        for step in range(n_steps):
            if self.emergency_stop:
                print(&quot;Emergency stop!&quot;)
                break

            # 1. AI policy
            raw_action = self.agent.select_action(state)[0]

            # 2. Uncertainty estimation
            uncertainty = self.estimate_uncertainty(state, np.array([raw_action]))

            # Conservative when high uncertainty
            if uncertainty &gt; 0.5:
                raw_action *= 0.5
                print(f&quot;  [UNCERTAINTY] High uncertainty ({uncertainty:.3f}), &quot;
                      f&quot;conservative action&quot;)

            # 3. Safety filter
            safe_action = self.apply_safety_filter(state, raw_action)

            # 4. Human override
            final_action, overridden = self.check_human_override(
                state, safe_action, uncertainty)

            # 5. Execute
            next_state, reward, done = self.env.step(final_action)
            next_state = self.preprocess_observation(next_state)

            # 6. Performance monitoring
            need_retraining = self.monitor_performance(state, final_action, reward)

            if need_retraining:
                print(f&quot;  [SYSTEM] Retraining recommended&quot;)

            # Periodic reporting
            if step % 100 == 0:
                print(f&quot;\nStep {step}:&quot;)
                print(f&quot;  State: T={state[0]:.2f}K, CA={state[1]:.3f}&quot;)
                print(f&quot;  Action: {final_action:.3f}, Uncertainty: {uncertainty:.3f}&quot;)
                print(f&quot;  Mode: {self.override_system.mode.value}&quot;)
                print(f&quot;  Anomalies: {self.monitor.anomaly_count}&quot;)

            self.prev_action = final_action
            state = next_state if not done else self.env.reset()

        # Final report
        print(&quot;\n&quot; + &quot;=&quot;*60)
        print(&quot;Operation ended&quot;)
        print(&quot;=&quot;*60)
        print(self.monitor.generate_report())
        print(self.override_system.generate_report())

# Execution
from example1 import RobustSACAgent, RandomizedCSTREnv

print(&quot;Integrated Deployment System Demonstration\n&quot;)

env = RandomizedCSTREnv(randomize=True)
agent = RobustSACAgent(obs_dim=2, action_dim=1)

system = IntegratedDeploymentSystem(agent, env)
system.control_loop(n_steps=300)</code></pre>
</div>
</section>
<section id="summary">
<h2>Chapter 5 Summary</h2>
<div class="key-points">
<h3>What We Learned</h3>
<ul>
<li><strong>Sim-to-Real Transfer</strong>: Achieving robustness through domain randomization</li>
<li><strong>Safe Exploration</strong>: Danger avoidance with safety filters and CBF</li>
<li><strong>Conservative Q-Learning</strong>: Safe learning from offline data</li>
<li><strong>Human Override</strong>: Emergency intervention mechanism</li>
<li><strong>Uncertainty Quantification</strong>: Confidence assessment with ensemble or MC Dropout</li>
<li><strong>Performance Monitoring</strong>: Drift detection and anomaly detection</li>
<li><strong>Integrated Framework</strong>: Practical system combining all elements</li>
</ul>
</div>
<h3>Deployment Maturity Model</h3>
<table style="width: 100%; border-collapse: collapse; margin: 1.5rem 0;">
<thead style="background: var(--pi-primary); color: white;">
<tr>
<th style="padding: 0.75rem; border: 1px solid #ddd;">Level</th>
<th style="padding: 0.75rem; border: 1px solid #ddd;">Description</th>
<th style="padding: 0.75rem; border: 1px solid #ddd;">Required Technology</th>
</tr>
</thead>
<tbody>
<tr>
<td style="padding: 0.75rem; border: 1px solid #ddd;">L1: Laboratory</td>
<td style="padding: 0.75rem; border: 1px solid #ddd;">Simulation only</td>
<td style="padding: 0.75rem; border: 1px solid #ddd;">Basic RL</td>
</tr>
<tr>
<td style="padding: 0.75rem; border: 1px solid #ddd;">L2: Testing</td>
<td style="padding: 0.75rem; border: 1px solid #ddd;">Pilot plant</td>
<td style="padding: 0.75rem; border: 1px solid #ddd;">Sim-to-real, safety constraints</td>
</tr>
<tr>
<td style="padding: 0.75rem; border: 1px solid #ddd;">L3: Supervised</td>
<td style="padding: 0.75rem; border: 1px solid #ddd;">Real plant (human supervision)</td>
<td style="padding: 0.75rem; border: 1px solid #ddd;">Override, performance monitoring</td>
</tr>
<tr>
<td style="padding: 0.75rem; border: 1px solid #ddd;">L4: Autonomous</td>
<td style="padding: 0.75rem; border: 1px solid #ddd;">Fully autonomous operation</td>
<td style="padding: 0.75rem; border: 1px solid #ddd;">Full integration, continual learning</td>
</tr>
</tbody>
</table>
<h3>Real Plant Deployment Checklist</h3>
<ul>
<li>‚úì Sufficient simulation validation (1000+ episodes)</li>
<li>‚úì Validity confirmation of parameter randomization</li>
<li>‚úì Comprehensive definition of safety constraints</li>
<li>‚úì Implementation and testing of emergency stop protocol</li>
<li>‚úì Operator training and manual preparation</li>
<li>‚úì Construction of performance monitoring dashboard</li>
<li>‚úì Periodic performance evaluation and retraining plan</li>
<li>‚úì Reporting structure to regulatory authorities</li>
</ul>
<div class="warning-box">
<h4>Final Cautionary Note</h4>
<p>
                        Real plant deployment of reinforcement learning is still an emerging technology.
                        Especially in safety-critical environments like chemical plants, a phased approach is essential:
                    </p>
<ol>
<li>Thorough validation in simulation</li>
<li>Demonstration in pilot plant</li>
<li>Limited operation under human supervision</li>
<li>Gradual increase in autonomy level</li>
</ol>
<p>
                        It is important to always collaborate with human experts and use AI as a tool.
                    </p>
</div>
</section>
<div style="margin-top: 3rem; padding: 2rem; background: linear-gradient(135deg, rgba(17, 153, 142, 0.1) 0%, rgba(56, 239, 125, 0.1) 100%); border-radius: 8px;">
<h3 style="color: var(--pi-primary); margin-top: 0;">Series Complete</h3>
<p><strong>Congratulations!</strong></p>
<p>
                    You have completed all 5 chapters of the "Autonomous Process Operation with AI Agents" series.
                    You have acquired a wide range of knowledge from reinforcement learning basics to real plant deployment.
                </p>
<p>
<a href="index.html" style="color: var(--pi-primary);">Return to Series Contents</a>
</p>
<p>
                    For further learning, please also use the following series:
                </p>
<ul>
<li></li>
<li></li>
</ul>
</div>
</article>
<section>
            <h2>References</h2>
            <ol>
                <li>Montgomery, D. C. (2019). <em>Design and Analysis of Experiments</em> (9th ed.). Wiley.</li>
                <li>Box, G. E. P., Hunter, J. S., &amp; Hunter, W. G. (2005). <em>Statistics for Experimenters: Design, Innovation, and Discovery</em> (2nd ed.). Wiley.</li>
                <li>Seborg, D. E., Edgar, T. F., Mellichamp, D. A., &amp; Doyle III, F. J. (2016). <em>Process Dynamics and Control</em> (4th ed.). Wiley.</li>
                <li>McKay, M. D., Beckman, R. J., &amp; Conover, W. J. (2000). "A Comparison of Three Methods for Selecting Values of Input Variables in the Analysis of Output from a Computer Code." <em>Technometrics</em>, 42(1), 55-61.</li>
            </ol>
        </section>

</main>
<footer>
<div class="footer-content">
<p>¬© 2025 Hashimoto Laboratory, Tohoku University. All rights reserved.</p>
</div>
</footer>
<!-- Prism.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
<!-- Mermaid -->
<script>
        mermaid.initialize({
            startOnLoad: true,
            theme: 'default',
            themeVariables: {
                primaryColor: '#11998e',
                primaryTextColor: '#fff',
                primaryBorderColor: '#0e7c74',
                lineColor: '#11998e',
                secondaryColor: '#38ef7d',
                tertiaryColor: '#f0f0f0'
            }
        });
    </script>
</body>
</html>
