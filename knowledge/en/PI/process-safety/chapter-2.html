<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<meta content="Chapter 2: HAZOP and Risk Assessment - Introduction to Process Safety Evaluation Series" name="description"/>
<title>Chapter 2: HAZOP and Risk Assessment - Introduction to Process Safety Evaluation | PI Terakoya</title>
<link href="../../assets/css/knowledge-base.css" rel="stylesheet"/>
<script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
<script>
        mermaid.initialize({ startOnLoad: true, theme: 'default', securityLevel: 'strict' });
    </script>
<!-- MathJax for LaTeX equation rendering -->
<script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true,
                processEnvironments: true
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
                ignoreHtmlClass: 'mermaid'
            }
        };
    </script>
<script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
<nav class="breadcrumb">
<div class="breadcrumb-content">
<a href="../index.html">AI Terakoya Home</a><span class="breadcrumb-separator">‚Ä∫</span><a href="../../PI/index.html">Process Informatics</a><span class="breadcrumb-separator">‚Ä∫</span><a href="../../PI/process-safety/index.html">Process Safety</a><span class="breadcrumb-separator">‚Ä∫</span><span class="breadcrumb-current">Chapter 2</span>
</div>
</nav><div class="locale-switcher">
<span class="current-locale">üåê EN</span>
<span class="locale-separator">|</span>

<span class="locale-meta">Last sync: 2025-11-16</span>
</div>

<header>
<div class="container">
<h1>Chapter 2: HAZOP and Risk Assessment</h1>
<p class="subtitle">Complete Implementation of Guide Word Application, Deviation Analysis, and Quantitative Risk Assessment (QRA)</p>
<div class="meta">
<span class="meta">üìñ Reading Time: 30-35 minutes</span>
<span class="meta">üìä Difficulty: Intermediate</span>
<span class="meta">üíª Code Examples: 8</span>
</div>
</div>
</header>
<main class="container">
<div class="learning-objectives">
<h2>Learning Objectives</h2>
<p>By completing this chapter, you will master:</p>
<ul>
<li>‚úÖ Understanding and practicing HAZOP study methodology</li>
<li>‚úÖ Applying Guide Words (No, More, Less, Reverse, etc.)</li>
<li>‚úÖ Conducting Deviation Analysis</li>
<li>‚úÖ Implementing Quantitative Risk Assessment (QRA)</li>
<li>‚úÖ Creating F-N curves and making risk judgments</li>
<li>‚úÖ Auto-generating HAZOP reports</li>
</ul>
</div>
<hr/>
<h2>2.1 Fundamentals of HAZOP Study</h2>
<h3>What is HAZOP?</h3>
<p><strong>HAZOP (Hazard and Operability Study)</strong> is a methodology for systematically identifying hazards and operational problems at the process design stage. Developed by ICI in the 1960s, it is now a standard for chemical plant design.</p>
<h3>HAZOP Principles</h3>
<p>HAZOP applies <strong>Guide Words</strong> to <strong>Process Parameters</strong> to generate <strong>Deviations</strong>, then analyzes their causes, consequences, and countermeasures.</p>
<p>$$
\text{Deviation} = \text{Guide Word} + \text{Process Parameter}
$$</p>
<h3>Key Guide Words</h3>
<table>
<thead>
<tr>
<th>Guide Word</th>
<th>Meaning</th>
<th>Application Example</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>No/Not/None</strong></td>
<td>Complete negation</td>
<td>No flow, No pressure</td>
</tr>
<tr>
<td><strong>More</strong></td>
<td>Quantitative increase</td>
<td>More flow, More temperature</td>
</tr>
<tr>
<td><strong>Less</strong></td>
<td>Quantitative decrease</td>
<td>Less flow, Less pressure</td>
</tr>
<tr>
<td><strong>As Well As</strong></td>
<td>Addition</td>
<td>Impurity as well as product</td>
</tr>
<tr>
<td><strong>Part Of</strong></td>
<td>Partial absence</td>
<td>Part of composition (missing component)</td>
</tr>
<tr>
<td><strong>Reverse</strong></td>
<td>Opposite direction</td>
<td>Reverse flow</td>
</tr>
<tr>
<td><strong>Other Than</strong></td>
<td>Completely different</td>
<td>Other than normal operation</td>
</tr>
</tbody>
</table>
<h3>Example 1: HAZOP Guide Word Engine</h3>
<pre><code class="language-python"># ===================================
# Example 1: HAZOP Guide Word Engine
# ===================================

from dataclasses import dataclass
from typing import List, Dict
from enum import Enum

class GuideWord(Enum):
    """HAZOP Guide Words"""
    NO = "No/Not/None"
    MORE = "More"
    LESS = "Less"
    AS_WELL_AS = "As Well As"
    PART_OF = "Part Of"
    REVERSE = "Reverse"
    OTHER_THAN = "Other Than"

class ProcessParameter(Enum):
    """Process Parameters"""
    FLOW = "Flow"
    PRESSURE = "Pressure"
    TEMPERATURE = "Temperature"
    LEVEL = "Level"
    COMPOSITION = "Composition"
    VISCOSITY = "Viscosity"
    TIME = "Time"
    MIXING = "Mixing"

@dataclass
class Deviation:
    """Deviation"""
    guide_word: GuideWord
    parameter: ProcessParameter
    description: str
    potential_causes: List[str]
    potential_consequences: List[str]
    existing_safeguards: List[str]
    recommendations: List[str]
    risk_rank: str  # High/Medium/Low

class HAZOPGuideWordEngine:
    """HAZOP Guide Word Application Engine"""

    def __init__(self):
        # Guide word and parameter combination rules
        self.valid_combinations = {
            GuideWord.NO: [ProcessParameter.FLOW, ProcessParameter.PRESSURE,
                           ProcessParameter.LEVEL, ProcessParameter.MIXING],
            GuideWord.MORE: [ProcessParameter.FLOW, ProcessParameter.PRESSURE,
                             ProcessParameter.TEMPERATURE, ProcessParameter.LEVEL],
            GuideWord.LESS: [ProcessParameter.FLOW, ProcessParameter.PRESSURE,
                             ProcessParameter.TEMPERATURE, ProcessParameter.LEVEL],
            GuideWord.REVERSE: [ProcessParameter.FLOW],
            GuideWord.AS_WELL_AS: [ProcessParameter.COMPOSITION],
            GuideWord.PART_OF: [ProcessParameter.COMPOSITION],
            GuideWord.OTHER_THAN: [ProcessParameter.COMPOSITION, ProcessParameter.TIME]
        }

    def is_valid_combination(self, guide_word: GuideWord,
                             parameter: ProcessParameter) -> bool:
        """Check if guide word and parameter combination is valid"""
        if guide_word in self.valid_combinations:
            return parameter in self.valid_combinations[guide_word]
        return False

    def generate_deviation_description(self, guide_word: GuideWord,
                                        parameter: ProcessParameter,
                                        node_name: str = "Node") -> str:
        """Generate deviation description"""
        return f"{guide_word.value} {parameter.value} at {node_name}"

    def apply_guide_words(self, node_name: str,
                          parameters: List[ProcessParameter]) -> List[str]:
        """Apply guide words to a node"""
        deviations = []

        for param in parameters:
            for guide_word in GuideWord:
                if self.is_valid_combination(guide_word, param):
                    deviation = self.generate_deviation_description(
                        guide_word, param, node_name
                    )
                    deviations.append(deviation)

        return deviations


# Usage example
hazop_engine = HAZOPGuideWordEngine()

# Node: Reactor feed line
node = "Reactor Feed Line (P&ID: R-101)"
parameters = [
    ProcessParameter.FLOW,
    ProcessParameter.PRESSURE,
    ProcessParameter.TEMPERATURE,
    ProcessParameter.COMPOSITION
]

# Apply guide words
deviations = hazop_engine.apply_guide_words(node, parameters)

print(f"=== HAZOP Node: {node} ===\n")
print(f"Total Deviations Generated: {len(deviations)}\n")
print("Deviations:")
for i, dev in enumerate(deviations, 1):
    print(f"{i:2d}. {dev}")

# Expected output:
# === HAZOP Node: Reactor Feed Line (P&ID: R-101) ===
#
# Total Deviations Generated: 13
#
# Deviations:
#  1. No/Not/None Flow at Reactor Feed Line (P&ID: R-101)
#  2. More Flow at Reactor Feed Line (P&ID: R-101)
#  3. Less Flow at Reactor Feed Line (P&ID: R-101)
#  4. Reverse Flow at Reactor Feed Line (P&ID: R-101)
#  5. No/Not/None Pressure at Reactor Feed Line (P&ID: R-101)
#  6. More Pressure at Reactor Feed Line (P&ID: R-101)
#  7. Less Pressure at Reactor Feed Line (P&ID: R-101)
#  8. More Temperature at Reactor Feed Line (P&ID: R-101)
#  9. Less Temperature at Reactor Feed Line (P&ID: R-101)
# 10. As Well As Composition at Reactor Feed Line (P&ID: R-101)
# 11. Part Of Composition at Reactor Feed Line (P&ID: R-101)
# 12. Other Than Composition at Reactor Feed Line (P&ID: R-101)
# 13. Other Than Time at Reactor Feed Line (P&ID: R-101)
</code></pre>
<hr/>
<h2>2.2 Deviation Analysis</h2>
<h3>Example 2: Deviation Analysis System Implementation</h3>
<p>Analyze causes, consequences, existing safeguards, and recommendations for each deviation.</p>
<pre><code class="language-python"># Requirements:
# - Python 3.9+
# - pandas&gt;=2.0.0, &lt;2.2.0

# ===================================
# Example 2: Deviation Analysis System
# ===================================

import pandas as pd

class DeviationAnalyzer:
    &quot;&quot;&quot;Deviation Analysis System&quot;&quot;&quot;

    def __init__(self, node_name: str, equipment_type: str):
        self.node_name = node_name
        self.equipment_type = equipment_type
        self.deviations: List[Deviation] = []
        self._load_knowledge_base()

    def _load_knowledge_base(self):
        &quot;&quot;&quot;Load knowledge base (typical causes and consequences)&quot;&quot;&quot;
        # In actual systems, learn from past HAZOP databases

        self.knowledge_base = {
            (&quot;NO&quot;, &quot;FLOW&quot;): {
                &quot;causes&quot;: [
                    &quot;Pump failure&quot;,
                    &quot;Valve closed (inadvertent or maintenance)&quot;,
                    &quot;Line blockage (solidification, fouling)&quot;,
                    &quot;Suction strainer plugged&quot;,
                    &quot;Upstream vessel empty&quot;
                ],
                &quot;consequences&quot;: [
                    &quot;Reactor starvation (loss of cooling/reactant)&quot;,
                    &quot;Pump cavitation/damage&quot;,
                    &quot;Product off-spec&quot;,
                    &quot;Temperature excursion (if flow is coolant)&quot;
                ],
                &quot;safeguards&quot;: [
                    &quot;Low flow alarm&quot;,
                    &quot;Pump status indication&quot;,
                    &quot;Level indication on upstream vessel&quot;
                ]
            },
            (&quot;MORE&quot;, &quot;FLOW&quot;): {
                &quot;causes&quot;: [
                    &quot;Control valve fails open&quot;,
                    &quot;Pump speed increase (VFD malfunction)&quot;,
                    &quot;Upstream pressure increase&quot;,
                    &quot;Parallel line opened unintentionally&quot;
                ],
                &quot;consequences&quot;: [
                    &quot;Reactor flooding&quot;,
                    &quot;Downstream vessel overflow&quot;,
                    &quot;Product off-spec (dilution)&quot;,
                    &quot;Increased pressure drop&quot;
                ],
                &quot;safeguards&quot;: [
                    &quot;High flow alarm&quot;,
                    &quot;Level high alarm on receiving vessel&quot;,
                    &quot;Flow control with override&quot;
                ]
            },
            (&quot;MORE&quot;, &quot;TEMPERATURE&quot;): {
                &quot;causes&quot;: [
                    &quot;Cooling system failure&quot;,
                    &quot;Heat exchanger fouling (reduced heat transfer)&quot;,
                    &quot;Exothermic reaction runaway&quot;,
                    &quot;External fire&quot;,
                    &quot;Temperature transmitter failure&quot;
                ],
                &quot;consequences&quot;: [
                    &quot;Thermal decomposition&quot;,
                    &quot;Reactor overpressure&quot;,
                    &quot;Product degradation&quot;,
                    &quot;Equipment damage (metallurgy limits)&quot;
                ],
                &quot;safeguards&quot;: [
                    &quot;High temperature alarm&quot;,
                    &quot;Independent high temperature interlock&quot;,
                    &quot;Pressure relief valve&quot;,
                    &quot;Emergency cooling system&quot;
                ]
            },
            (&quot;REVERSE&quot;, &quot;FLOW&quot;): {
                &quot;causes&quot;: [
                    &quot;Pump stopped with downstream pressure higher&quot;,
                    &quot;Check valve failure&quot;,
                    &quot;Incorrect valve lineup&quot;,
                    &quot;Siphon effect&quot;
                ],
                &quot;consequences&quot;: [
                    &quot;Contamination of upstream system&quot;,
                    &quot;Pump damage (reverse rotation)&quot;,
                    &quot;Loss of containment&quot;,
                    &quot;Mixing of incompatible materials&quot;
                ],
                &quot;safeguards&quot;: [
                    &quot;Check valve&quot;,
                    &quot;Backflow prevention valve&quot;,
                    &quot;Pump discharge valve&quot;
                ]
            }
        }

    def analyze_deviation(self, guide_word: GuideWord,
                          parameter: ProcessParameter) -&gt; Deviation:
        &quot;&quot;&quot;Analyze deviation&quot;&quot;&quot;

        # Retrieve information from knowledge base
        key = (guide_word.name, parameter.name)
        kb_entry = self.knowledge_base.get(key, {
            &quot;causes&quot;: [&quot;To be determined in HAZOP meeting&quot;],
            &quot;consequences&quot;: [&quot;To be determined in HAZOP meeting&quot;],
            &quot;safeguards&quot;: [&quot;To be determined in HAZOP meeting&quot;]
        })

        # Risk ranking (simplified)
        high_risk_combos = [
            (&quot;NO&quot;, &quot;FLOW&quot;), (&quot;MORE&quot;, &quot;TEMPERATURE&quot;), (&quot;MORE&quot;, &quot;PRESSURE&quot;)
        ]
        risk_rank = &quot;High&quot; if key in high_risk_combos else &quot;Medium&quot;

        # Generate recommendations
        recommendations = self._generate_recommendations(
            guide_word, parameter, kb_entry[&quot;safeguards&quot;]
        )

        deviation = Deviation(
            guide_word=guide_word,
            parameter=parameter,
            description=f&quot;{guide_word.value} {parameter.value} at {self.node_name}&quot;,
            potential_causes=kb_entry[&quot;causes&quot;],
            potential_consequences=kb_entry[&quot;consequences&quot;],
            existing_safeguards=kb_entry[&quot;safeguards&quot;],
            recommendations=recommendations,
            risk_rank=risk_rank
        )

        self.deviations.append(deviation)
        return deviation

    def _generate_recommendations(self, guide_word: GuideWord,
                                   parameter: ProcessParameter,
                                   existing_safeguards: List[str]) -&gt; List[str]:
        &quot;&quot;&quot;Generate recommendations&quot;&quot;&quot;
        recommendations = []

        # Check for missing alarms
        if &quot;alarm&quot; not in ' '.join(existing_safeguards).lower():
            recommendations.append(
                f&quot;Install {parameter.value.lower()} alarm&quot;
            )

        # Check for missing interlocks
        if guide_word in [GuideWord.MORE, GuideWord.NO] and \
           &quot;interlock&quot; not in ' '.join(existing_safeguards).lower():
            recommendations.append(
                f&quot;Consider {parameter.value.lower()} interlock (SIL assessment required)&quot;
            )

        # Redundancy check
        if len(existing_safeguards) &lt; 2:
            recommendations.append(
                &quot;Review adequacy of protection layers (LOPA recommended)&quot;
            )

        if not recommendations:
            recommendations.append(&quot;Existing safeguards adequate - continue routine maintenance&quot;)

        return recommendations

    def generate_hazop_worksheet(self) -&gt; pd.DataFrame:
        &quot;&quot;&quot;Generate HAZOP worksheet&quot;&quot;&quot;
        data = []

        for dev in self.deviations:
            data.append({
                'Node': self.node_name,
                'Deviation': dev.description,
                'Causes': '; '.join(dev.potential_causes[:2]) + '...',  # First 2
                'Consequences': '; '.join(dev.potential_consequences[:2]) + '...',
                'Safeguards': '; '.join(dev.existing_safeguards[:2]) + '...',
                'Risk': dev.risk_rank,
                'Actions': '; '.join(dev.recommendations[:1])  # Top priority recommendation
            })

        return pd.DataFrame(data)


# Usage example
analyzer = DeviationAnalyzer(
    node_name=&quot;Reactor Feed Line (R-101)&quot;,
    equipment_type=&quot;Piping&quot;
)

# Analyze critical deviations
critical_deviations = [
    (GuideWord.NO, ProcessParameter.FLOW),
    (GuideWord.MORE, ProcessParameter.FLOW),
    (GuideWord.MORE, ProcessParameter.TEMPERATURE),
    (GuideWord.REVERSE, ProcessParameter.FLOW)
]

for gw, param in critical_deviations:
    analyzer.analyze_deviation(gw, param)

# Generate HAZOP worksheet
worksheet = analyzer.generate_hazop_worksheet()

print(&quot;=== HAZOP Worksheet ===\n&quot;)
print(worksheet.to_string(index=False))

print(&quot;\n=== Detailed Analysis: No Flow ===&quot;)
no_flow_dev = analyzer.deviations[0]
print(f&quot;\nDeviation: {no_flow_dev.description}&quot;)
print(f&quot;\nPotential Causes:&quot;)
for cause in no_flow_dev.potential_causes:
    print(f&quot;  - {cause}&quot;)
print(f&quot;\nPotential Consequences:&quot;)
for cons in no_flow_dev.potential_consequences:
    print(f&quot;  - {cons}&quot;)
print(f&quot;\nRecommendations:&quot;)
for rec in no_flow_dev.recommendations:
    print(f&quot;  - {rec}&quot;)

# Expected output:
# === HAZOP Worksheet ===
#
#                     Node                           Deviation  Risk ...
#  Reactor Feed Line (R-101)    No/Not/None Flow at Reactor... High ...
#  Reactor Feed Line (R-101)          More Flow at Reactor... Medium ...
#  Reactor Feed Line (R-101)   More Temperature at Reactor... High ...
#  Reactor Feed Line (R-101)       Reverse Flow at Reactor... Medium ...
</code></pre>
<hr/>
<h2>2.3 HAZOP Automation System</h2>
<h3>Example 3: P&amp;ID Analysis and HAZOP Auto-generation</h3>
<p>Automatically generate HAZOP nodes and deviations from P&amp;ID (Piping and Instrumentation Diagram) information.</p>
<pre><code class="language-python"># ===================================
# Example 3: P&ID Analysis and HAZOP Auto-generation
# ===================================

from dataclasses import dataclass
from typing import List, Dict, Set

@dataclass
class PIDElement:
    """P&ID Element"""
    id: str
    element_type: str  # Vessel, Pump, HeatExchanger, Valve, Line
    fluid: str
    design_pressure: float  # MPa
    design_temperature: float  # ¬∞C
    connected_to: List[str]  # Connected element IDs

@dataclass
class HAZOPNode:
    """HAZOP Node (study unit)"""
    id: str
    name: str
    elements: List[PIDElement]
    intent: str  # Design Intent
    parameters_of_interest: List[ProcessParameter]

class PIDHAZOPAutomation:
    """P&ID-based HAZOP Automation System"""

    def __init__(self):
        self.pid_elements: Dict[str, PIDElement] = {}
        self.hazop_nodes: List[HAZOPNode] = []

    def add_pid_element(self, element: PIDElement):
        """Add P&ID element"""
        self.pid_elements[element.id] = element

    def identify_hazop_nodes(self) -> List[HAZOPNode]:
        """Automatically identify HAZOP nodes

        Node division criteria:
          - Functional units (reaction, separation, heat exchange)
          - Process condition change points (phase change, temperature/pressure change)
          - Control loop boundaries
        """
        nodes = []

        # Simplified: Treat each major equipment as a node
        for elem_id, elem in self.pid_elements.items():
            if elem.element_type in ['Vessel', 'Pump', 'HeatExchanger']:
                # Infer design intent
                intent = self._infer_design_intent(elem)

                # Determine relevant parameters
                parameters = self._determine_parameters(elem)

                node = HAZOPNode(
                    id=f"NODE-{elem_id}",
                    name=f"{elem.element_type}: {elem_id}",
                    elements=[elem],
                    intent=intent,
                    parameters_of_interest=parameters
                )

                nodes.append(node)

        self.hazop_nodes = nodes
        return nodes

    def _infer_design_intent(self, element: PIDElement) -> str:
        """Infer design intent"""
        intents = {
            'Vessel': f"Contain {element.fluid} at {element.design_pressure} MPa, {element.design_temperature}¬∞C",
            'Pump': f"Transfer {element.fluid} at design flow rate",
            'HeatExchanger': f"Heat/cool {element.fluid} to target temperature"
        }
        return intents.get(element.element_type, "To be determined")

    def _determine_parameters(self, element: PIDElement) -> List[ProcessParameter]:
        """Determine parameters to study"""
        param_map = {
            'Vessel': [ProcessParameter.LEVEL, ProcessParameter.PRESSURE,
                       ProcessParameter.TEMPERATURE, ProcessParameter.COMPOSITION],
            'Pump': [ProcessParameter.FLOW, ProcessParameter.PRESSURE],
            'HeatExchanger': [ProcessParameter.FLOW, ProcessParameter.TEMPERATURE,
                              ProcessParameter.PRESSURE]
        }
        return param_map.get(element.element_type,
                             [ProcessParameter.FLOW, ProcessParameter.PRESSURE])

    def generate_hazop_study(self) -> Dict:
        """Generate complete HAZOP study"""

        # Identify nodes
        if not self.hazop_nodes:
            self.identify_hazop_nodes()

        # Conduct HAZOP for each node
        study_results = []

        for node in self.hazop_nodes:
            analyzer = DeviationAnalyzer(node.name, node.elements[0].element_type)

            # Apply guide words
            for param in node.parameters_of_interest:
                for guide_word in GuideWord:
                    if analyzer._load_knowledge_base() or True:  # simplified
                        # Analyze only valid combinations
                        engine = HAZOPGuideWordEngine()
                        if engine.is_valid_combination(guide_word, param):
                            try:
                                deviation = analyzer.analyze_deviation(guide_word, param)
                                study_results.append({
                                    'Node': node.name,
                                    'Intent': node.intent,
                                    'Deviation': deviation.description,
                                    'Risk': deviation.risk_rank
                                })
                            except:
                                pass

        return {
            'total_nodes': len(self.hazop_nodes),
            'total_deviations': len(study_results),
            'results': pd.DataFrame(study_results)
        }


# Usage example: Build P&ID for simple process
pid_system = PIDHAZOPAutomation()

# Add P&ID elements
pid_system.add_pid_element(PIDElement(
    id="R-101",
    element_type="Vessel",
    fluid="Ethylene/Catalyst",
    design_pressure=3.0,
    design_temperature=150,
    connected_to=["P-101", "E-101"]
))

pid_system.add_pid_element(PIDElement(
    id="P-101",
    element_type="Pump",
    fluid="Product mixture",
    design_pressure=5.0,
    design_temperature=80,
    connected_to=["R-101", "T-201"]
))

pid_system.add_pid_element(PIDElement(
    id="E-101",
    element_type="HeatExchanger",
    fluid="Reactor coolant",
    design_pressure=1.5,
    design_temperature=100,
    connected_to=["R-101"]
))

# Automatically identify HAZOP nodes
nodes = pid_system.identify_hazop_nodes()
print(f"=== HAZOP Nodes Identified: {len(nodes)} ===\n")
for node in nodes:
    print(f"Node: {node.name}")
    print(f"  Intent: {node.intent}")
    print(f"  Parameters: {[p.value for p in node.parameters_of_interest]}\n")

# Auto-generate HAZOP study
study = pid_system.generate_hazop_study()
print(f"\n=== HAZOP Study Summary ===")
print(f"Total Nodes: {study['total_nodes']}")
print(f"Total Deviations: {study['total_deviations']}\n")
print(study['results'].head(10).to_string(index=False))

# Expected output:
# === HAZOP Nodes Identified: 3 ===
#
# Node: Vessel: R-101
#   Intent: Contain Ethylene/Catalyst at 3.0 MPa, 150¬∞C
#   Parameters: ['Level', 'Pressure', 'Temperature', 'Composition']
#
# Node: Pump: P-101
#   Intent: Transfer Product mixture at design flow rate
#   Parameters: ['Flow', 'Pressure']
# ...
</code></pre>
<hr/>
<h2>2.4 Quantitative Risk Assessment (QRA)</h2>
<h3>Example 4: Event Tree Analysis (ETA)</h3>
<p>Probabilistically evaluate the event sequence from initiating event to final outcome.</p>
<pre><code class="language-python"># Requirements:
# - Python 3.9+
# - matplotlib&gt;=3.7.0
# - numpy&gt;=1.24.0, &lt;2.0.0

# ===================================
# Example 4: Event Tree Analysis (ETA)
# ===================================

from dataclasses import dataclass
from typing import List, Optional
import matplotlib.pyplot as plt
import numpy as np

@dataclass
class EventNode:
    &quot;&quot;&quot;Event tree node&quot;&quot;&quot;
    name: str
    success_probability: float
    failure_probability: float

    def __post_init__(self):
        assert abs(self.success_probability + self.failure_probability - 1.0) &lt; 1e-6, \
            &quot;Success + Failure probability must equal 1.0&quot;

@dataclass
class Outcome:
    &quot;&quot;&quot;Final outcome&quot;&quot;&quot;
    path: List[str]
    probability: float
    consequence: str
    severity: str  # Catastrophic, Critical, Marginal, Negligible

class EventTreeAnalysis:
    &quot;&quot;&quot;Event Tree Analysis System&quot;&quot;&quot;

    def __init__(self, initiating_event: str, frequency: float):
        &quot;&quot;&quot;
        Args:
            initiating_event: Initiating event name
            frequency: Initiating event frequency (events/year)
        &quot;&quot;&quot;
        self.initiating_event = initiating_event
        self.frequency = frequency
        self.safety_functions: List[EventNode] = []
        self.outcomes: List[Outcome] = []

    def add_safety_function(self, node: EventNode):
        &quot;&quot;&quot;Add safety function&quot;&quot;&quot;
        self.safety_functions.append(node)

    def calculate_outcomes(self):
        &quot;&quot;&quot;Calculate all outcome paths and probabilities&quot;&quot;&quot;
        self.outcomes = []

        # Generate all possible combinations (2^n paths)
        n_functions = len(self.safety_functions)
        for i in range(2 ** n_functions):
            path = []
            probability = self.frequency

            # Determine Success/Failure using binary representation
            binary = format(i, f'0{n_functions}b')

            for j, bit in enumerate(binary):
                function = self.safety_functions[j]
                if bit == '0':  # Success
                    path.append(f&quot;{function.name}: Success&quot;)
                    probability *= function.success_probability
                else:  # Failure
                    path.append(f&quot;{function.name}: Failure&quot;)
                    probability *= function.failure_probability

            # Determine consequence severity
            failure_count = binary.count('1')
            consequence, severity = self._determine_consequence(failure_count)

            self.outcomes.append(Outcome(
                path=path,
                probability=probability,
                consequence=consequence,
                severity=severity
            ))

    def _determine_consequence(self, failure_count: int) -&gt; tuple:
        &quot;&quot;&quot;Determine consequence based on failure count&quot;&quot;&quot;
        n = len(self.safety_functions)

        if failure_count == 0:
            return &quot;Safe shutdown&quot;, &quot;Negligible&quot;
        elif failure_count == 1:
            return &quot;Minor release (contained by secondary barrier)&quot;, &quot;Marginal&quot;
        elif failure_count == 2:
            return &quot;Significant release (requires emergency response)&quot;, &quot;Critical&quot;
        else:
            return &quot;Major release (offsite consequences)&quot;, &quot;Catastrophic&quot;

    def generate_eta_report(self) -&gt; str:
        &quot;&quot;&quot;Generate event tree analysis report&quot;&quot;&quot;
        if not self.outcomes:
            self.calculate_outcomes()

        report = f&quot;&quot;&quot;
{'='*80}
EVENT TREE ANALYSIS (ETA) REPORT
{'='*80}

Initiating Event: {self.initiating_event}
Frequency: {self.frequency:.2e} events/year

Safety Functions:
&quot;&quot;&quot;

        for i, sf in enumerate(self.safety_functions, 1):
            report += f&quot;{i}. {sf.name}\n&quot;
            report += f&quot;   Success Prob: {sf.success_probability:.4f} ({sf.success_probability*100:.2f}%)\n&quot;
            report += f&quot;   Failure Prob: {sf.failure_probability:.4f} ({sf.failure_probability*100:.2f}%)\n\n&quot;

        report += f&quot;&quot;&quot;
{'='*80}
OUTCOMES
{'='*80}
&quot;&quot;&quot;

        # Sort by severity
        severity_order = {&quot;Catastrophic&quot;: 0, &quot;Critical&quot;: 1, &quot;Marginal&quot;: 2, &quot;Negligible&quot;: 3}
        sorted_outcomes = sorted(self.outcomes,
                                 key=lambda x: (severity_order[x.severity], -x.probability))

        for i, outcome in enumerate(sorted_outcomes, 1):
            report += f&quot;\nOutcome {i}: {outcome.consequence}\n&quot;
            report += f&quot;  Severity: {outcome.severity}\n&quot;
            report += f&quot;  Frequency: {outcome.probability:.2e} events/year\n&quot;
            report += f&quot;  Path:\n&quot;
            for step in outcome.path:
                report += f&quot;    ‚Üí {step}\n&quot;

        # Calculate total risk
        total_risk = sum(o.probability for o in self.outcomes)
        catastrophic_risk = sum(o.probability for o in self.outcomes
                                if o.severity == &quot;Catastrophic&quot;)

        report += f&quot;&quot;&quot;
{'='*80}
RISK SUMMARY
{'='*80}
Total Event Frequency (all paths): {total_risk:.2e} events/year
Catastrophic Outcome Frequency: {catastrophic_risk:.2e} events/year

Risk Acceptance Criteria (example):
  Catastrophic: &lt; 1e-6 events/year  {'‚úÖ ACCEPTABLE' if catastrophic_risk &lt; 1e-6 else '‚ùå UNACCEPTABLE'}
  Critical:     &lt; 1e-4 events/year
&quot;&quot;&quot;

        return report


# Usage example: ETA for flammable gas leak scenario
eta = EventTreeAnalysis(
    initiating_event=&quot;Large flange gasket failure causing H2 release&quot;,
    frequency=1e-3  # 0.001 events/year (once per 1000 years)
)

# Add safety functions (multiple protection layers)
eta.add_safety_function(EventNode(
    name=&quot;Gas detection system activates&quot;,
    success_probability=0.95,
    failure_probability=0.05
))

eta.add_safety_function(EventNode(
    name=&quot;Automatic isolation valve closes&quot;,
    success_probability=0.98,
    failure_probability=0.02
))

eta.add_safety_function(EventNode(
    name=&quot;Ignition prevention (no ignition sources)&quot;,
    success_probability=0.90,
    failure_probability=0.10
))

# Execute event tree analysis
report = eta.generate_eta_report()
print(report)

# Detailed analysis: Worst case scenario
worst_case = max(eta.outcomes, key=lambda x: x.probability
                 if x.severity == &quot;Catastrophic&quot; else 0)

print(&quot;\n=== WORST CASE SCENARIO ===&quot;)
print(f&quot;Consequence: {worst_case.consequence}&quot;)
print(f&quot;Frequency: {worst_case.probability:.2e} events/year&quot;)
print(f&quot;Return Period: {1/worst_case.probability:.0f} years&quot;)

# Expected output:
# ============================================================================
# EVENT TREE ANALYSIS (ETA) REPORT
# ============================================================================
#
# Initiating Event: Large flange gasket failure causing H2 release
# Frequency: 1.00e-03 events/year
#
# Safety Functions:
# 1. Gas detection system activates
#    Success Prob: 0.9500 (95.00%)
#    Failure Prob: 0.0500 (5.00%)
#
# 2. Automatic isolation valve closes
#    Success Prob: 0.9800 (98.00%)
#    Failure Prob: 0.0200 (2.00%)
# ...
#
# Outcome 1: Major release (offsite consequences)
#   Severity: Catastrophic
#   Frequency: 1.00e-07 events/year  (All 3 safety functions fail)
#   Path:
#     ‚Üí Gas detection system activates: Failure
#     ‚Üí Automatic isolation valve closes: Failure
#     ‚Üí Ignition prevention (no ignition sources): Failure
</code></pre>
<hr/>
<h2>2.5 Failure Frequency Data and Reliability</h2>
<h3>Example 5: Generic Failure Rate Database</h3>
<pre><code class="language-python"># Requirements:
# - Python 3.9+
# - pandas&gt;=2.0.0, &lt;2.2.0

# ===================================
# Example 5: Generic Failure Rate Database
# ===================================

import pandas as pd
from dataclasses import dataclass
from typing import Dict

@dataclass
class FailureRateData:
    &quot;&quot;&quot;Failure rate data&quot;&quot;&quot;
    equipment_type: str
    failure_mode: str
    failure_rate: float  # failures per million hours (10^-6/hr)
    source: str  # Data source (OREDA, PDS, etc.)
    confidence_factor: float  # 1.0 = nominal, &gt;1.0 = conservative

class GenericFailureRateDatabase:
    &quot;&quot;&quot;Generic failure rate database&quot;&quot;&quot;

    def __init__(self):
        self.database: Dict[str, FailureRateData] = {}
        self._initialize_database()

    def _initialize_database(self):
        &quot;&quot;&quot;Initialize database (based on OREDA, PDS, etc. data)&quot;&quot;&quot;

        failure_rates = [
            # Valves
            (&quot;Isolation Valve&quot;, &quot;Fail to close on demand&quot;, 5.0, &quot;OREDA 2015&quot;, 1.0),
            (&quot;Control Valve&quot;, &quot;Fail open&quot;, 10.0, &quot;PDS 2010&quot;, 1.0),
            (&quot;Check Valve&quot;, &quot;Reverse flow (fail to close)&quot;, 50.0, &quot;API 581&quot;, 1.5),
            (&quot;Pressure Relief Valve&quot;, &quot;Fail to open on demand&quot;, 10.0, &quot;API 581&quot;, 1.0),

            # Pumps
            (&quot;Centrifugal Pump&quot;, &quot;Fail to start&quot;, 5.0, &quot;OREDA 2015&quot;, 1.0),
            (&quot;Centrifugal Pump&quot;, &quot;Fail to run (shutdown)&quot;, 50.0, &quot;OREDA 2015&quot;, 1.0),

            # Instrumentation
            (&quot;Pressure Transmitter&quot;, &quot;Out of calibration&quot;, 2.0, &quot;EXIDA&quot;, 1.0),
            (&quot;Temperature Transmitter&quot;, &quot;Fail dangerous&quot;, 1.5, &quot;EXIDA&quot;, 1.0),
            (&quot;Level Transmitter&quot;, &quot;Fail dangerous&quot;, 3.0, &quot;EXIDA&quot;, 1.0),
            (&quot;Gas Detector&quot;, &quot;Fail to detect&quot;, 100.0, &quot;Industry avg&quot;, 2.0),

            # Safety Systems
            (&quot;SIS Logic Solver&quot;, &quot;Fail dangerous&quot;, 0.5, &quot;IEC 61508&quot;, 1.0),
            (&quot;Emergency Shutdown Valve&quot;, &quot;Fail to close&quot;, 3.0, &quot;API 581&quot;, 1.0),

            # Vessels &amp; Piping
            (&quot;Pressure Vessel&quot;, &quot;Catastrophic rupture&quot;, 0.01, &quot;API 579&quot;, 1.0),
            (&quot;Piping (per km)&quot;, &quot;Major leak (&gt;10% cross-section)&quot;, 0.5, &quot;UKOPA&quot;, 1.0),
            (&quot;Flange Gasket&quot;, &quot;Leak&quot;, 10.0, &quot;Industry avg&quot;, 1.5),

            # Heat Exchangers
            (&quot;Shell &amp; Tube HX&quot;, &quot;Tube leak&quot;, 20.0, &quot;OREDA 2015&quot;, 1.0)
        ]

        for eq_type, mode, rate, source, cf in failure_rates:
            key = f&quot;{eq_type}_{mode}&quot;
            self.database[key] = FailureRateData(eq_type, mode, rate, source, cf)

    def get_failure_rate(self, equipment_type: str, failure_mode: str,
                         apply_confidence_factor: bool = True) -&gt; float:
        &quot;&quot;&quot;Get failure rate

        Returns:
            Failure rate in failures per year
        &quot;&quot;&quot;
        key = f&quot;{equipment_type}_{failure_mode}&quot;
        data = self.database.get(key)

        if not data:
            raise ValueError(f&quot;No data for {equipment_type} - {failure_mode}&quot;)

        rate_per_year = data.failure_rate * 8760 / 1e6  # 10^-6/hr ‚Üí /year

        if apply_confidence_factor:
            rate_per_year *= data.confidence_factor

        return rate_per_year

    def get_pfd_from_test_interval(self, equipment_type: str, failure_mode: str,
                                    test_interval_months: int = 12) -&gt; float:
        &quot;&quot;&quot;Calculate Probability of Failure on Demand (PFD)

        Simplified formula: PFD ‚âà Œª * T / 2
        Œª: failure rate (/year)
        T: test interval (year)
        &quot;&quot;&quot;
        failure_rate = self.get_failure_rate(equipment_type, failure_mode)
        test_interval_years = test_interval_months / 12.0

        pfd = (failure_rate * test_interval_years) / 2.0

        return min(pfd, 1.0)  # PFD max 1.0

    def generate_reliability_datasheet(self, equipment_list: List[tuple]) -&gt; pd.DataFrame:
        &quot;&quot;&quot;Generate reliability datasheet

        Args:
            equipment_list: [(equipment_type, failure_mode, test_interval_months), ...]
        &quot;&quot;&quot;
        data = []

        for eq_type, mode, test_interval in equipment_list:
            failure_rate = self.get_failure_rate(eq_type, mode)
            pfd = self.get_pfd_from_test_interval(eq_type, mode, test_interval)

            # SIL capability determination
            if pfd &lt; 1e-4:
                sil_capability = &quot;SIL 3&quot;
            elif pfd &lt; 1e-3:
                sil_capability = &quot;SIL 2&quot;
            elif pfd &lt; 1e-2:
                sil_capability = &quot;SIL 1&quot;
            else:
                sil_capability = &quot;No SIL&quot;

            data.append({
                'Equipment': eq_type,
                'Failure Mode': mode,
                'Failure Rate': f&quot;{failure_rate:.2e} /yr&quot;,
                'Test Interval': f&quot;{test_interval} months&quot;,
                'PFD': f&quot;{pfd:.2e}&quot;,
                'SIL Capability': sil_capability,
                'MTTF': f&quot;{1/failure_rate:.1f} years&quot; if failure_rate &gt; 0 else &quot;N/A&quot;
            })

        return pd.DataFrame(data)


# Usage example
failure_db = GenericFailureRateDatabase()

# Create reliability datasheet
equipment_list = [
    (&quot;Isolation Valve&quot;, &quot;Fail to close on demand&quot;, 12),
    (&quot;Pressure Relief Valve&quot;, &quot;Fail to open on demand&quot;, 24),
    (&quot;Gas Detector&quot;, &quot;Fail to detect&quot;, 3),
    (&quot;SIS Logic Solver&quot;, &quot;Fail dangerous&quot;, 12),
    (&quot;Emergency Shutdown Valve&quot;, &quot;Fail to close&quot;, 6)
]

reliability_sheet = failure_db.generate_reliability_datasheet(equipment_list)

print(&quot;=== Reliability Datasheet ===\n&quot;)
print(reliability_sheet.to_string(index=False))

# Get individual failure rate
prv_failure_rate = failure_db.get_failure_rate(
    &quot;Pressure Relief Valve&quot;,
    &quot;Fail to open on demand&quot;
)
print(f&quot;\n=== PRV Reliability ===&quot;)
print(f&quot;Failure Rate: {prv_failure_rate:.2e} /year&quot;)
print(f&quot;MTTF: {1/prv_failure_rate:.1f} years&quot;)

# Expected output:
# === Reliability Datasheet ===
#
#                   Equipment              Failure Mode Failure Rate Test Interval      PFD SIL Capability  MTTF
#          Isolation Valve  Fail to close on demand   4.38e-05 /yr     12 months 2.19e-05        SIL 3  22831.1 years
#  Pressure Relief Valve  Fail to open on demand   8.76e-05 /yr     24 months 8.76e-05        SIL 3  11415.5 years
#            Gas Detector            Fail to detect   8.76e-04 /yr      3 months 1.09e-04        SIL 3  1141.6 years
#       SIS Logic Solver           Fail dangerous   4.38e-06 /yr     12 months 2.19e-06        SIL 4  228310.5 years
# Emergency Shutdown Valve            Fail to close   2.63e-05 /yr      6 months 6.57e-06        SIL 4  38041.8 years
</code></pre>
<hr/>
<h2>2.6 F-N Curve and Risk Criteria</h2>
<h3>Example 6: F-N Curve (Frequency-Number curve)</h3>
<p>Create F-N curves to assess societal risk.</p>
<pre><code class="language-python"># Requirements:
# - Python 3.9+
# - matplotlib&gt;=3.7.0
# - numpy&gt;=1.24.0, &lt;2.0.0

# ===================================
# Example 6: F-N Curve and Risk Criteria
# ===================================

import matplotlib.pyplot as plt
import numpy as np
from dataclasses import dataclass
from typing import List

@dataclass
class RiskScenario:
    &quot;&quot;&quot;Risk scenario&quot;&quot;&quot;
    name: str
    frequency: float  # events/year
    fatalities: int   # Expected number of fatalities

class FNCurveAnalysis:
    &quot;&quot;&quot;F-N Curve Analysis System&quot;&quot;&quot;

    def __init__(self, facility_name: str):
        self.facility_name = facility_name
        self.scenarios: List[RiskScenario] = []

        # Risk acceptance criteria lines (Dutch criteria example)
        self.alarp_upper_limit = lambda N: 1e-3 / (N**2)  # Upper ALARP
        self.alarp_lower_limit = lambda N: 1e-5 / (N**2)  # Lower ALARP
        self.negligible_limit = lambda N: 1e-7 / (N**2)   # Negligible

    def add_scenario(self, scenario: RiskScenario):
        &quot;&quot;&quot;Add scenario&quot;&quot;&quot;
        self.scenarios.append(scenario)

    def calculate_fn_curve_data(self) -&gt; tuple:
        &quot;&quot;&quot;Calculate F-N curve data

        Returns:
            (N_values, F_values): Number of fatalities and cumulative frequency
        &quot;&quot;&quot;
        # Sort by fatalities
        sorted_scenarios = sorted(self.scenarios, key=lambda x: x.fatalities)

        N_values = []
        F_values = []

        for scenario in sorted_scenarios:
            N = scenario.fatalities
            # Cumulative frequency of events with N or more fatalities
            F = sum(s.frequency for s in self.scenarios if s.fatalities &gt;= N)

            N_values.append(N)
            F_values.append(F)

        return np.array(N_values), np.array(F_values)

    def plot_fn_curve(self, save_path: str = None):
        &quot;&quot;&quot;Plot F-N curve&quot;&quot;&quot;
        N, F = self.calculate_fn_curve_data()

        fig, ax = plt.subplots(figsize=(10, 8))

        # Plot F-N curve
        ax.loglog(N, F, 'bo-', linewidth=2, markersize=8,
                  label='Facility Risk Profile', zorder=5)

        # Plot individual scenarios
        for scenario in self.scenarios:
            ax.plot(scenario.fatalities, scenario.frequency,
                    'rx', markersize=10, markeredgewidth=2)
            ax.annotate(scenario.name,
                        xy=(scenario.fatalities, scenario.frequency),
                        xytext=(10, 10), textcoords='offset points',
                        fontsize=8, alpha=0.7)

        # Risk acceptance criteria lines
        N_range = np.logspace(0, 3, 100)  # 1-1000 people

        ax.loglog(N_range, [self.alarp_upper_limit(n) for n in N_range],
                  'r--', linewidth=2, label='ALARP Upper Limit (Unacceptable)')
        ax.loglog(N_range, [self.alarp_lower_limit(n) for n in N_range],
                  'y--', linewidth=2, label='ALARP Lower Limit')
        ax.loglog(N_range, [self.negligible_limit(n) for n in N_range],
                  'g--', linewidth=2, label='Negligible Risk')

        # Fill ALARP region
        ax.fill_between(N_range,
                        [self.alarp_lower_limit(n) for n in N_range],
                        [self.alarp_upper_limit(n) for n in N_range],
                        alpha=0.2, color='yellow', label='ALARP Region')

        ax.set_xlabel('Number of Fatalities (N)', fontsize=12, fontweight='bold')
        ax.set_ylabel('Cumulative Frequency (F) [events/year]', fontsize=12, fontweight='bold')
        ax.set_title(f'F-N Curve: {self.facility_name}\nSocietal Risk Assessment',
                     fontsize=14, fontweight='bold')
        ax.grid(True, which='both', alpha=0.3)
        ax.legend(loc='upper right')

        ax.set_xlim([1, 1000])
        ax.set_ylim([1e-8, 1e-2])

        plt.tight_layout()

        if save_path:
            plt.savefig(save_path, dpi=300, bbox_inches='tight')

        return fig

    def assess_alarp_status(self) -&gt; Dict:
        &quot;&quot;&quot;Assess ALARP status&quot;&quot;&quot;
        results = {
            'unacceptable': [],
            'alarp': [],
            'broadly_acceptable': []
        }

        for scenario in self.scenarios:
            N = scenario.fatalities
            F = scenario.frequency

            if F &gt; self.alarp_upper_limit(N):
                results['unacceptable'].append(scenario)
            elif F &gt; self.alarp_lower_limit(N):
                results['alarp'].append(scenario)
            else:
                results['broadly_acceptable'].append(scenario)

        return results

    def generate_alarp_report(self) -&gt; str:
        &quot;&quot;&quot;Generate ALARP report&quot;&quot;&quot;
        status = self.assess_alarp_status()

        report = f&quot;&quot;&quot;
{'='*80}
F-N CURVE ANALYSIS - ALARP ASSESSMENT
{'='*80}

Facility: {self.facility_name}
Total Scenarios Analyzed: {len(self.scenarios)}

{'='*80}
RISK CLASSIFICATION
{'='*80}

UNACCEPTABLE REGION (Above ALARP Upper Limit):
  Scenarios: {len(status['unacceptable'])}
&quot;&quot;&quot;

        if status['unacceptable']:
            for s in status['unacceptable']:
                report += f&quot;  ‚ùå {s.name}: F={s.frequency:.2e}/yr, N={s.fatalities}\n&quot;
            report += &quot;  ACTION: Immediate risk reduction REQUIRED\n&quot;
        else:
            report += &quot;  ‚úÖ No scenarios in unacceptable region\n&quot;

        report += f&quot;&quot;&quot;
ALARP REGION (Risk Reduction As Low As Reasonably Practicable):
  Scenarios: {len(status['alarp'])}
&quot;&quot;&quot;

        if status['alarp']:
            for s in status['alarp']:
                report += f&quot;  ‚ö†Ô∏è  {s.name}: F={s.frequency:.2e}/yr, N={s.fatalities}\n&quot;
            report += &quot;  ACTION: Demonstrate ALARP (cost-benefit analysis)\n&quot;
        else:
            report += &quot;  ‚úÖ No scenarios in ALARP region\n&quot;

        report += f&quot;&quot;&quot;
BROADLY ACCEPTABLE REGION (Below ALARP Lower Limit):
  Scenarios: {len(status['broadly_acceptable'])}
&quot;&quot;&quot;

        if status['broadly_acceptable']:
            for s in status['broadly_acceptable']:
                report += f&quot;  ‚úÖ {s.name}: F={s.frequency:.2e}/yr, N={s.fatalities}\n&quot;
            report += &quot;  ACTION: Maintain current safety measures\n&quot;

        report += f&quot;\n{'='*80}\n&quot;

        return report


# Usage example: F-N curve analysis for LNG receiving terminal
fn_analysis = FNCurveAnalysis(facility_name=&quot;LNG Import Terminal&quot;)

# Add risk scenarios
fn_analysis.add_scenario(RiskScenario(
    name=&quot;Small LNG leak (no ignition)&quot;,
    frequency=1e-2,
    fatalities=0
))

fn_analysis.add_scenario(RiskScenario(
    name=&quot;Medium LNG leak ‚Üí jet fire&quot;,
    frequency=5e-4,
    fatalities=2
))

fn_analysis.add_scenario(RiskScenario(
    name=&quot;Large LNG leak ‚Üí pool fire&quot;,
    frequency=1e-4,
    fatalities=10
))

fn_analysis.add_scenario(RiskScenario(
    name=&quot;Catastrophic tank failure ‚Üí VCE&quot;,
    frequency=1e-6,
    fatalities=100
))

fn_analysis.add_scenario(RiskScenario(
    name=&quot;LNG carrier collision ‚Üí BLEVE&quot;,
    frequency=5e-7,
    fatalities=300
))

# Generate ALARP report
alarp_report = fn_analysis.generate_alarp_report()
print(alarp_report)

# Plot F-N curve
fig = fn_analysis.plot_fn_curve()
# plt.show()

# Expected output:
# ============================================================================
# F-N CURVE ANALYSIS - ALARP ASSESSMENT
# ============================================================================
#
# Facility: LNG Import Terminal
# Total Scenarios Analyzed: 5
#
# ============================================================================
# RISK CLASSIFICATION
# ============================================================================
#
# UNACCEPTABLE REGION (Above ALARP Upper Limit):
#   Scenarios: 0
#   ‚úÖ No scenarios in unacceptable region
#
# ALARP REGION (Risk Reduction As Low As Reasonably Practicable):
#   Scenarios: 2
#   ‚ö†Ô∏è  Medium LNG leak ‚Üí jet fire: F=5.00e-04/yr, N=2
#   ‚ö†Ô∏è  Large LNG leak ‚Üí pool fire: F=1.00e-04/yr, N=10
#   ACTION: Demonstrate ALARP (cost-benefit analysis)
#
# BROADLY ACCEPTABLE REGION (Below ALARP Lower Limit):
#   Scenarios: 2
#   ‚úÖ Catastrophic tank failure ‚Üí VCE: F=1.00e-06/yr, N=100
#   ‚úÖ LNG carrier collision ‚Üí BLEVE: F=5.00e-07/yr, N=300
#   ACTION: Maintain current safety measures
</code></pre>
<hr/>
<h2>2.7 HAZOP Report Auto-generation</h2>
<h3>Example 7: Comprehensive HAZOP Report Generator</h3>
<pre><code class="language-python"># ===================================
# Example 7: HAZOP Report Auto-generation
# ===================================

from datetime import datetime
import json

class HAZOPReportGenerator:
    """HAZOP study complete report generation system"""

    def __init__(self, project_info: Dict):
        self.project_info = project_info
        self.hazop_nodes = []
        self.team_members = []

    def add_team_member(self, name: str, role: str):
        """Add team member"""
        self.team_members.append({'name': name, 'role': role})

    def generate_full_report(self, deviations_by_node: Dict[str, List[Deviation]]) -> str:
        """Generate complete HAZOP report

        Args:
            deviations_by_node: {node_name: [Deviation, ...], ...}
        """

        report = self._generate_cover_page()
        report += self._generate_executive_summary(deviations_by_node)
        report += self._generate_methodology_section()
        report += self._generate_detailed_worksheets(deviations_by_node)
        report += self._generate_action_items(deviations_by_node)
        report += self._generate_appendices()

        return report

    def _generate_cover_page(self) -> str:
        """Cover page"""
        return f"""
{'='*80}
HAZARD AND OPERABILITY STUDY (HAZOP)
FINAL REPORT
{'='*80}

Project:     {self.project_info.get('name', 'N/A')}
Facility:    {self.project_info.get('facility', 'N/A')}
Location:    {self.project_info.get('location', 'N/A')}

Study Date:  {self.project_info.get('study_date', datetime.now().strftime('%Y-%m-%d'))}
Report Date: {datetime.now().strftime('%Y-%m-%d')}

Document No: {self.project_info.get('doc_number', 'HAZOP-001')}
Revision:    {self.project_info.get('revision', '0')}

{'='*80}
STUDY TEAM
{'='*80}

"""

    def _generate_executive_summary(self, deviations_by_node: Dict) -> str:
        """Executive summary"""

        total_deviations = sum(len(devs) for devs in deviations_by_node.values())
        high_risk = sum(1 for devs in deviations_by_node.values()
                        for dev in devs if dev.risk_rank == "High")

        summary = f"""
EXECUTIVE SUMMARY
{'='*80}

Study Scope:
  - Total HAZOP Nodes:     {len(deviations_by_node)}
  - Total Deviations:      {total_deviations}
  - High Risk Scenarios:   {high_risk}

Key Findings:
  1. {high_risk} high-risk scenarios identified requiring immediate attention
  2. All scenarios have been assessed with existing safeguards documented
  3. Recommendations provided for risk reduction where needed

Overall Assessment:
"""

        if high_risk == 0:
            summary += "  ‚úÖ No high-risk scenarios. Facility design is robust.\n"
        elif high_risk <= 3:
            summary += f"  ‚ö†Ô∏è  {high_risk} high-risk scenarios require mitigation.\n"
        else:
            summary += f"  ‚ùå {high_risk} high-risk scenarios - major design review recommended.\n"

        return summary + "\n"

    def _generate_methodology_section(self) -> str:
        """Methodology section"""
        return f"""
METHODOLOGY
{'='*80}

1. HAZOP Technique:
   - Guide Words applied to process parameters
   - Systematic deviation analysis
   - Cause-Consequence-Safeguard approach

2. Risk Ranking:
   - High:   Immediate action required
   - Medium: Risk reduction should be considered
   - Low:    Acceptable with existing safeguards

3. Documentation:
   - P&ID reviewed: {self.project_info.get('pid_revision', 'Rev 0')}
   - Process conditions: {self.project_info.get('process_basis', 'Normal operation')}

"""

    def _generate_detailed_worksheets(self, deviations_by_node: Dict) -> str:
        """Detailed worksheets"""
        worksheets = f"""
DETAILED HAZOP WORKSHEETS
{'='*80}

"""

        for node_name, deviations in deviations_by_node.items():
            worksheets += f"\nNode: {node_name}\n"
            worksheets += f"{'-'*80}\n\n"

            for i, dev in enumerate(deviations, 1):
                worksheets += f"Deviation {i}: {dev.description}\n"
                worksheets += f"Risk Rank: {dev.risk_rank}\n\n"

                worksheets += "Potential Causes:\n"
                for cause in dev.potential_causes:
                    worksheets += f"  - {cause}\n"

                worksheets += "\nPotential Consequences:\n"
                for cons in dev.potential_consequences:
                    worksheets += f"  - {cons}\n"

                worksheets += "\nExisting Safeguards:\n"
                for sg in dev.existing_safeguards:
                    worksheets += f"  - {sg}\n"

                worksheets += "\nRecommendations:\n"
                for rec in dev.recommendations:
                    worksheets += f"  - {rec}\n"

                worksheets += "\n" + "-"*80 + "\n\n"

        return worksheets

    def _generate_action_items(self, deviations_by_node: Dict) -> str:
        """Action items"""
        actions = f"""
ACTION ITEM REGISTER
{'='*80}

"""

        action_id = 1
        for node_name, deviations in deviations_by_node.items():
            for dev in deviations:
                for rec in dev.recommendations:
                    if "adequate" not in rec.lower():  # Skip no-action recommendations
                        priority = "HIGH" if dev.risk_rank == "High" else "MEDIUM"
                        actions += f"Action {action_id:03d}: [{priority}] {rec}\n"
                        actions += f"  Node: {node_name}\n"
                        actions += f"  Deviation: {dev.description}\n"
                        actions += f"  Responsible: TBD\n"
                        actions += f"  Target Date: TBD\n\n"
                        action_id += 1

        return actions

    def _generate_appendices(self) -> str:
        """Appendices"""
        return f"""
APPENDICES
{'='*80}

Appendix A: P&ID Drawings
Appendix B: Study Team Attendance Records
Appendix C: Risk Matrix Definition
Appendix D: Abbreviations and Definitions

"""

    def export_to_json(self, deviations_by_node: Dict, filepath: str):
        """Export to JSON format"""
        export_data = {
            'project_info': self.project_info,
            'study_date': datetime.now().isoformat(),
            'nodes': {}
        }

        for node_name, deviations in deviations_by_node.items():
            export_data['nodes'][node_name] = [
                {
                    'description': dev.description,
                    'guide_word': dev.guide_word.value,
                    'parameter': dev.parameter.value,
                    'causes': dev.potential_causes,
                    'consequences': dev.potential_consequences,
                    'safeguards': dev.existing_safeguards,
                    'recommendations': dev.recommendations,
                    'risk_rank': dev.risk_rank
                }
                for dev in deviations
            ]

        with open(filepath, 'w', encoding='utf-8') as f:
            json.dump(export_data, f, indent=2, ensure_ascii=False)


# Usage example
project_info = {
    'name': 'Ethylene Polymerization Plant',
    'facility': 'Reactor Section',
    'location': 'Yokkaichi, Japan',
    'study_date': '2025-10-15',
    'doc_number': 'HAZOP-EPP-001',
    'revision': '0',
    'pid_revision': 'Rev 2',
    'process_basis': 'Normal operation at 85% capacity'
}

report_gen = HAZOPReportGenerator(project_info)

# Add team members
report_gen.add_team_member("Dr. Smith", "HAZOP Leader")
report_gen.add_team_member("Eng. Tanaka", "Process Engineer")
report_gen.add_team_member("Eng. Kim", "Instrument Engineer")

# Deviation data (generated from Example 2)
analyzer = DeviationAnalyzer("Reactor R-101", "Vessel")
analyzer.analyze_deviation(GuideWord.NO, ProcessParameter.FLOW)
analyzer.analyze_deviation(GuideWord.MORE, ProcessParameter.TEMPERATURE)

deviations_data = {
    "Reactor R-101": analyzer.deviations
}

# Generate report
full_report = report_gen.generate_full_report(deviations_data)
print(full_report[:2000])  # Display first 2000 characters

# JSON export
# report_gen.export_to_json(deviations_data, "hazop_study_results.json")
# print("\n‚úÖ HAZOP study exported to hazop_study_results.json")

# Expected output:
# ============================================================================
# HAZARD AND OPERABILITY STUDY (HAZOP)
# FINAL REPORT
# ============================================================================
#
# Project:     Ethylene Polymerization Plant
# Facility:    Reactor Section
# Location:    Yokkaichi, Japan
# ...
</code></pre>
<hr/>
<h2>2.8 Risk Ranking and Prioritization</h2>
<h3>Example 8: Multi-Criteria Decision Analysis (MCDA)</h3>
<p>Comprehensively evaluate multiple risk scenarios and determine countermeasure priorities.</p>
<pre><code class="language-python"># Requirements:
# - Python 3.9+
# - numpy&gt;=1.24.0, &lt;2.0.0
# - pandas&gt;=2.0.0, &lt;2.2.0

# ===================================
# Example 8: Multi-Criteria Decision Analysis (MCDA)
# ===================================

import pandas as pd
import numpy as np
from dataclasses import dataclass
from typing import List, Dict

@dataclass
class RiskCriteria:
    &quot;&quot;&quot;Risk assessment criteria&quot;&quot;&quot;
    likelihood: float       # 1-5
    severity_people: float  # 1-5 (people impact)
    severity_env: float     # 1-5 (environmental impact)
    severity_asset: float   # 1-5 (asset loss)
    detectability: float    # 1-5 (detectability, lower is better)

class MultiCriteriaRiskRanking:
    &quot;&quot;&quot;Multi-criteria risk ranking system&quot;&quot;&quot;

    def __init__(self):
        # Criteria weights (sum to 1.0)
        self.weights = {
            'likelihood': 0.25,
            'severity_people': 0.35,  # Highest weight on people impact
            'severity_env': 0.20,
            'severity_asset': 0.15,
            'detectability': 0.05
        }

    def calculate_risk_priority_number(self, criteria: RiskCriteria) -&gt; float:
        &quot;&quot;&quot;Calculate Risk Priority Number (RPN)&quot;&quot;&quot;

        # Weighted average score
        weighted_score = (
            criteria.likelihood * self.weights['likelihood'] +
            criteria.severity_people * self.weights['severity_people'] +
            criteria.severity_env * self.weights['severity_env'] +
            criteria.severity_asset * self.weights['severity_asset'] +
            criteria.detectability * self.weights['detectability']
        )

        # Normalize to 0-100 scale
        rpn = weighted_score * 20

        return rpn

    def rank_scenarios(self, scenarios: Dict[str, RiskCriteria]) -&gt; pd.DataFrame:
        &quot;&quot;&quot;Rank scenarios&quot;&quot;&quot;

        data = []

        for scenario_name, criteria in scenarios.items():
            rpn = self.calculate_risk_priority_number(criteria)

            # Determine priority level
            if rpn &gt;= 80:
                priority = &quot;Critical (P1)&quot;
            elif rpn &gt;= 60:
                priority = &quot;High (P2)&quot;
            elif rpn &gt;= 40:
                priority = &quot;Medium (P3)&quot;
            else:
                priority = &quot;Low (P4)&quot;

            data.append({
                'Scenario': scenario_name,
                'Likelihood': criteria.likelihood,
                'Sev_People': criteria.severity_people,
                'Sev_Env': criteria.severity_env,
                'Sev_Asset': criteria.severity_asset,
                'Detectability': criteria.detectability,
                'RPN': f&quot;{rpn:.1f}&quot;,
                'Priority': priority
            })

        df = pd.DataFrame(data)
        df = df.sort_values('RPN', ascending=False, key=lambda x: x.astype(float))

        return df

    def sensitivity_analysis(self, criteria: RiskCriteria, scenario_name: str):
        &quot;&quot;&quot;Sensitivity analysis: Impact of each criterion change on RPN&quot;&quot;&quot;

        baseline_rpn = self.calculate_risk_priority_number(criteria)

        print(f&quot;\n=== Sensitivity Analysis: {scenario_name} ===&quot;)
        print(f&quot;Baseline RPN: {baseline_rpn:.1f}\n&quot;)

        print(&quot;Impact of +1 change in each criterion:&quot;)

        # Likelihood +1
        temp_criteria = RiskCriteria(
            criteria.likelihood + 1,
            criteria.severity_people,
            criteria.severity_env,
            criteria.severity_asset,
            criteria.detectability
        )
        new_rpn = self.calculate_risk_priority_number(temp_criteria)
        print(f&quot;  Likelihood +1:        {baseline_rpn:.1f} ‚Üí {new_rpn:.1f} (Œî{new_rpn-baseline_rpn:+.1f})&quot;)

        # Severity_People +1
        temp_criteria = RiskCriteria(
            criteria.likelihood,
            min(criteria.severity_people + 1, 5),
            criteria.severity_env,
            criteria.severity_asset,
            criteria.detectability
        )
        new_rpn = self.calculate_risk_priority_number(temp_criteria)
        print(f&quot;  Severity_People +1:   {baseline_rpn:.1f} ‚Üí {new_rpn:.1f} (Œî{new_rpn-baseline_rpn:+.1f})&quot;)

        # Detectability -1 (lower is better)
        temp_criteria = RiskCriteria(
            criteria.likelihood,
            criteria.severity_people,
            criteria.severity_env,
            criteria.severity_asset,
            max(criteria.detectability - 1, 1)
        )
        new_rpn = self.calculate_risk_priority_number(temp_criteria)
        print(f&quot;  Detectability -1:     {baseline_rpn:.1f} ‚Üí {new_rpn:.1f} (Œî{new_rpn-baseline_rpn:+.1f})&quot;)


# Usage example
mcda = MultiCriteriaRiskRanking()

# Evaluate multiple risk scenarios
scenarios = {
    &quot;Reactor overpressure (no relief)&quot;: RiskCriteria(
        likelihood=2,         # Occasional
        severity_people=5,    # Catastrophic
        severity_env=4,       # Critical
        severity_asset=5,     # Catastrophic
        detectability=2       # Good detection (pressure transmitter)
    ),

    &quot;Toxic gas release (H2S)&quot;: RiskCriteria(
        likelihood=3,         # Probable
        severity_people=4,    # Critical
        severity_env=3,       # Marginal
        severity_asset=2,     # Negligible
        detectability=3       # Moderate detection
    ),

    &quot;Loss of cooling water&quot;: RiskCriteria(
        likelihood=4,         # Frequent
        severity_people=2,    # Negligible
        severity_env=1,       # Minimal
        severity_asset=3,     # Marginal
        detectability=1       # Excellent detection (flow transmitter)
    ),

    &quot;Runaway polymerization&quot;: RiskCriteria(
        likelihood=2,         # Occasional
        severity_people=4,    # Critical
        severity_env=3,       # Marginal
        severity_asset=4,     # Critical
        detectability=3       # Moderate detection
    ),

    &quot;Flange gasket leak&quot;: RiskCriteria(
        likelihood=3,         # Probable
        severity_people=2,    # Negligible
        severity_env=2,       # Negligible
        severity_asset=1,     # Minimal
        detectability=4       # Poor detection (visual inspection)
    )
}

# Perform ranking
ranking = mcda.rank_scenarios(scenarios)

print(&quot;=== Multi-Criteria Risk Ranking ===\n&quot;)
print(ranking.to_string(index=False))

# Sensitivity analysis for highest risk scenario
top_scenario_name = ranking.iloc[0]['Scenario']
top_scenario_criteria = scenarios[top_scenario_name]

mcda.sensitivity_analysis(top_scenario_criteria, top_scenario_name)

# Expected output:
# === Multi-Criteria Risk Ranking ===
#
#                        Scenario  Likelihood  Sev_People  Sev_Env  Sev_Asset  Detectability    RPN      Priority
#  Reactor overpressure (no relief)           2           5        4          5              2   80.0  Critical (P1)
#         Runaway polymerization           2           4        3          4              3   66.0      High (P2)
#          Toxic gas release (H2S)           3           4        3          2              3   66.0      High (P2)
#            Loss of cooling water           4           2        1          3              1   48.0    Medium (P3)
#                Flange gasket leak           3           2        2          1              4   44.0    Medium (P3)
#
# === Sensitivity Analysis: Reactor overpressure (no relief) ===
# Baseline RPN: 80.0
#
# Impact of +1 change in each criterion:
#   Likelihood +1:        80.0 ‚Üí 85.0 (Œî+5.0)
#   Severity_People +1:   80.0 ‚Üí 80.0 (Œî+0.0)  # Already at max (5)
#   Detectability -1:     80.0 ‚Üí 79.0 (Œî-1.0)
</code></pre>
<hr/>
<h2>Learning Objectives Review</h2>
<p>Upon completing this chapter, you should be able to explain:</p>
<h3>Fundamental Understanding</h3>
<ul>
<li>‚úÖ Understand HAZOP principles and guide word application methods</li>
<li>‚úÖ Know the deviation analysis process (cause-consequence-safeguards)</li>
<li>‚úÖ Understand the differences between QRA and event tree analysis</li>
<li>‚úÖ Explain F-N curves and ALARP concepts</li>
</ul>
<h3>Practical Skills</h3>
<ul>
<li>‚úÖ Systematically apply HAZOP guide words</li>
<li>‚úÖ Identify HAZOP nodes from P&amp;IDs</li>
<li>‚úÖ Evaluate event sequences using event tree analysis</li>
<li>‚úÖ Calculate PFD using failure rate databases</li>
<li>‚úÖ Create F-N curves and make ALARP judgments</li>
<li>‚úÖ Generate comprehensive HAZOP reports</li>
</ul>
<h3>Application Skills</h3>
<ul>
<li>‚úÖ Conduct HAZOP studies on actual chemical processes</li>
<li>‚úÖ Practice quantitative risk assessment (QRA)</li>
<li>‚úÖ Determine countermeasure priorities using multi-criteria decision analysis</li>
<li>‚úÖ Auto-generate HAZOP reports to support decision-making</li>
</ul>
<hr/>
<h2>Next Steps</h2>
<p>In Chapter 2, we learned about HAZOP, QRA, and F-N curves.</p>
<p><strong>In Chapter 3:</strong></p>
<ul>
<li>üìã FMEA (Failure Mode and Effects Analysis)</li>
<li>üìã Reliability engineering and MTBF calculation</li>
<li>üìã Fault Tree Analysis (FTA)</li>
<li>üìã Preventive maintenance optimization (RCM)</li>
</ul>
<p>will be covered.</p>
<div class="navigation">
<a class="nav-button" href="chapter-1.html">‚Üê Return to Chapter 1</a>
<a class="nav-button" href="./index.html">Series Index</a>
</div>
</main>
<section>
            <h2>References</h2>
            <ol>
                <li>Montgomery, D. C. (2019). <em>Design and Analysis of Experiments</em> (9th ed.). Wiley.</li>
                <li>Box, G. E. P., Hunter, J. S., &amp; Hunter, W. G. (2005). <em>Statistics for Experimenters: Design, Innovation, and Discovery</em> (2nd ed.). Wiley.</li>
                <li>Seborg, D. E., Edgar, T. F., Mellichamp, D. A., &amp; Doyle III, F. J. (2016). <em>Process Dynamics and Control</em> (4th ed.). Wiley.</li>
                <li>McKay, M. D., Beckman, R. J., &amp; Conover, W. J. (2000). "A Comparison of Three Methods for Selecting Values of Input Variables in the Analysis of Output from a Computer Code." <em>Technometrics</em>, 42(1), 55-61.</li>
            </ol>
        </section>

<section class="disclaimer">
<h3>Disclaimer</h3>
<ul>
<li>This content is provided for educational, research, and informational purposes only and does not constitute professional advice.</li>
<li>HAZOP studies should be conducted by trained professional teams. HAZOP based solely on this content is incomplete.</li>
<li>Failure rate data represents generic values; actual equipment varies depending on operating conditions and maintenance status.</li>
<li>Risk criteria (F-N curves) must comply with regulations in each country/region. This example is a simplified model for educational purposes.</li>
<li>The authors and Tohoku University assume no responsibility for any damages arising from the use of this content.</li>
</ul>
</section>
<footer>
<div class="container">
<p>¬© 2025 PI Knowledge Hub - Dr. Yusuke Hashimoto, Tohoku University</p>
<p>Licensed under CC BY 4.0</p>
</div>
</footer>
</body>
</html>
