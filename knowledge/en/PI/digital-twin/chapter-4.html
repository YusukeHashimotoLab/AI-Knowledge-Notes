<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Chapter 4ï¼šä»®æƒ³ProcessOptimization - Digital Twinå…¥é–€ Series">
    <title>Chapter 4ï¼šä»®æƒ³ProcessOptimization - Digital Twinå…¥é–€ | PI Terakoya</title>

            <link rel="stylesheet" href="../../assets/css/knowledge-base.css">
</head>
<body>
            <nav class="breadcrumb">
        <div class="breadcrumb-content">
            <a href="../../index.html">AI Terakoya Top</a><span class="breadcrumb-separator">â€º</span><a href="../../PI/index.html">Process Informatics</a><span class="breadcrumb-separator">â€º</span><a href="../../PI/digital-twin/index.html">Digital Twin</a><span class="breadcrumb-separator">â€º</span><span class="breadcrumb-current">Chapter 4</span>
        </div>
    </nav>

        <header>
        <div class="container">
            <h1>Chapter 4ï¼šä»®æƒ³ProcessOptimization</h1>
            <p class="subtitle">Digital Twinã§å®Ÿç¾ã™ã‚‹Safetyã§åŠ¹ç‡çš„ãªOptimization</p>
            <div class="meta">
                <span class="meta">ğŸ“š Difficulty: Intermediate</span>
                <span class="meta">â±ï¸ Reading Time: 30-35 minutes</span>
                <span class="meta">ğŸ”§ Pythonå®Ÿè£…: 7ä¾‹</span>
            </div>
        </div>
    </header>

    <main class="container">
        <section>
            <h2>4.1 What-ifã‚·ãƒŠãƒªã‚ª minutesæ</h2>

            <p>Digital Twinã®æœ€å¤§ã®ä¾¡å€¤ã¯ã€å®ŸProcessã«å½±éŸ¿ã‚’ä¸ãˆãšã«æ§˜ã€…ãªã€Œã‚‚ã—ã‚‚ã€ã‚·ãƒŠãƒªã‚ªã‚’è©¦ã›ã‚‹ã“ã¨ã§ã™ã€‚æ¡ä»¶å¤‰æ›´ã®å½±éŸ¿ã‚’äº‹å‰è©•ä¾¡ã—ã€æœ€é©ãªé‹è»¢æˆ¦ç•¥ã‚’è¦‹å‡ºã—ã¾ã™ã€‚</p>

            <h3>4.1.1 åŸºæœ¬çš„ãªWhat-if minutesæ</h3>

<pre><code>import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy.optimize import differential_evolution

class WhatIfAnalyzer:
    """Digital Twinã‚’ä½¿ã£ãŸWhat-ifã‚·ãƒŠãƒªã‚ª minutesæ"""

    def __init__(self, digital_twin_model):
        self.model = digital_twin_model
        self.scenarios = []

    def create_scenario(self, name, parameter_changes):
        """ã‚·ãƒŠãƒªã‚ªä½œæˆ

        Args:
            name: ã‚·ãƒŠãƒªã‚ªå
            parameter_changes: {param: value}ã®è¾æ›¸
        """
        baseline = self.model.get_current_state()

        # ã‚·ãƒŠãƒªã‚ªé©ç”¨
        modified_state = baseline.copy()
        modified_state.update(parameter_changes)

        # Simulationå®Ÿè¡Œ
        result = self.model.simulate(modified_state)

        scenario = {
            'name': name,
            'changes': parameter_changes,
            'baseline': baseline,
            'result': result,
            'impact': self._calculate_impact(baseline, result)
        }

        self.scenarios.append(scenario)
        return scenario

    def _calculate_impact(self, baseline, result):
        """å½±éŸ¿åº¦è¨ˆç®—"""
        return {
            'yield_change': ((result['yield'] - baseline['yield']) /
                           baseline['yield'] * 100),
            'quality_change': result['quality'] - baseline['quality'],
            'cost_change': result['cost'] - baseline['cost']
        }

    def compare_scenarios(self):
        """ã‚·ãƒŠãƒªã‚ªæ¯”è¼ƒ"""
        df = pd.DataFrame([
            {
                'Scenario': s['name'],
                'Yield Change (%)': s['impact']['yield_change'],
                'Quality Change': s['impact']['quality_change'],
                'Cost Change': s['impact']['cost_change']
            }
            for s in self.scenarios
        ])
        return df

# ä½¿ç”¨ä¾‹
class SimpleReactorModel:
    def __init__(self):
        self.state = {'temp': 350, 'pressure': 5.0, 'flow': 100}

    def get_current_state(self):
        return self.state.copy()

    def simulate(self, state):
        # ç°¡æ˜“åå¿œå™¨ãƒ¢ãƒ‡ãƒ«
        temp = state['temp']
        pressure = state['pressure']
        flow = state['flow']

        # åç‡ãƒ¢ãƒ‡ãƒ«ï¼ˆæœ€é©ç‚¹: 360â„ƒ, 6 barï¼‰
        yield_val = 85 - 0.05*(temp-360)**2 - 2*(pressure-6)**2
        quality = 95 - 0.02*abs(temp-360)
        cost = 0.5*temp + 10*pressure + 0.1*flow

        return {
            'yield': max(0, yield_val),
            'quality': quality,
            'cost': cost,
            **state
        }

# å®Ÿè¡Œ
model = SimpleReactorModel()
analyzer = WhatIfAnalyzer(model)

# ã‚·ãƒŠãƒªã‚ª1: æ¸©åº¦ä¸Šæ˜‡
analyzer.create_scenario('High Temp', {'temp': 370})

# ã‚·ãƒŠãƒªã‚ª2: åœ§åŠ›å¢—åŠ 
analyzer.create_scenario('High Pressure', {'pressure': 7.0})

# ã‚·ãƒŠãƒªã‚ª3: åŒæ™‚å¤‰æ›´
analyzer.create_scenario('Combined', {'temp': 365, 'pressure': 6.5})

# æ¯”è¼ƒ
print(analyzer.compare_scenarios())
# å‡ºåŠ›:
#        Scenario  Yield Change (%)  Quality Change  Cost Change
# 0     High Temp            -5.88           -0.20        10.00
# 1  High Pressure            -7.06            0.00        20.00
# 2      Combined             3.53           -0.10        27.50
</code></pre>

            <div class="callout callout-tip">
                <strong>ğŸ’¡ å®Ÿå‹™Tips:</strong>
                <ul>
                    <li>ãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ³ã¨ã®å·® minutesã‚’å¸¸ã«å¯è¦–åŒ–ã™ã‚‹</li>
                    <li>åˆ¶ç´„æ¡ä»¶ï¼ˆSafetyé™ç•Œï¼‰ã‚’æ˜ç¤ºã™ã‚‹</li>
                    <li>ä¸ç¢ºå®Ÿæ€§ã‚’è€ƒæ…®ã—ãŸæ„Ÿåº¦ minutesæã‚‚å®Ÿæ–½</li>
                </ul>
            </div>

            <h2>4.2 ä»®æƒ³ã‚»ãƒ³ã‚µãƒ¼ï¼ˆã‚½ãƒ•ãƒˆã‚»ãƒ³ã‚µãƒ¼ï¼‰</h2>

            <p>æ¸¬å®šå›°é›£ã¾ãŸã¯é«˜ã‚³ã‚¹ãƒˆãªå¤‰æ•°ã‚’ã€æ¸¬å®šå¯èƒ½ãªå¤‰æ•°ã‹ã‚‰æ¨å®šã™ã‚‹ã‚½ãƒ•ãƒˆã‚»ãƒ³ã‚µãƒ¼ã‚’Digital Twinã«çµ±åˆã—ã¾ã™ã€‚</p>

            <h3>4.2.1 Machine Learningãƒ™ãƒ¼ã‚¹ã‚½ãƒ•ãƒˆã‚»ãƒ³ã‚µãƒ¼</h3>

<pre><code>from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import train_test_split
from sklearn.metrics import r2_score, mean_absolute_error
import joblib

class SoftSensor:
    """Machine Learningãƒ™ãƒ¼ã‚¹ã®ã‚½ãƒ•ãƒˆã‚»ãƒ³ã‚µãƒ¼"""

    def __init__(self, target_variable):
        self.target = target_variable
        self.model = RandomForestRegressor(
            n_estimators=100,
            max_depth=10,
            random_state=42
        )
        self.feature_names = None
        self.is_trained = False

    def train(self, X, y, test_size=0.2):
        """ãƒ¢ãƒ‡ãƒ«è¨“ç·´

        Args:
            X: æ¸¬å®šå¯èƒ½ãªå¤‰æ•°ï¼ˆDataFrameï¼‰
            y: ç›®æ¨™å¤‰æ•°ï¼ˆæ¸¬å®šå›°é›£ãªå¤‰æ•°ï¼‰
        """
        self.feature_names = X.columns.tolist()

        X_train, X_test, y_train, y_test = train_test_split(
            X, y, test_size=test_size, random_state=42
        )

        self.model.fit(X_train, y_train)

        # æ€§èƒ½è©•ä¾¡
        y_pred = self.model.predict(X_test)
        r2 = r2_score(y_test, y_pred)
        mae = mean_absolute_error(y_test, y_pred)

        self.is_trained = True

        return {
            'r2_score': r2,
            'mae': mae,
            'n_train': len(X_train),
            'n_test': len(X_test)
        }

    def predict(self, X):
        """ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ¨å®š"""
        if not self.is_trained:
            raise ValueError("Model not trained")

        return self.model.predict(X)

    def get_feature_importance(self):
        """ç‰¹å¾´é‡é‡è¦åº¦"""
        if not self.is_trained:
            return None

        importance = pd.DataFrame({
            'feature': self.feature_names,
            'importance': self.model.feature_importances_
        }).sort_values('importance', ascending=False)

        return importance

    def save(self, filepath):
        """ãƒ¢ãƒ‡ãƒ«ä¿å­˜"""
        joblib.dump({
            'model': self.model,
            'feature_names': self.feature_names,
            'target': self.target
        }, filepath)

# ä½¿ç”¨ä¾‹
# è£½å“å“è³ªï¼ˆæ¸¬å®šå›°é›£ï¼‰ã‚’é‹è»¢æ¡ä»¶ï¼ˆæ¸¬å®šå®¹æ˜“ï¼‰ã‹ã‚‰æ¨å®š
np.random.seed(42)
n_samples = 500

# è¨“ç·´ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆï¼ˆå®Ÿéš›ã¯Processãƒ‡ãƒ¼ã‚¿ï¼‰
data = pd.DataFrame({
    'temp': np.random.uniform(340, 370, n_samples),
    'pressure': np.random.uniform(4, 8, n_samples),
    'flow': np.random.uniform(80, 120, n_samples),
    'residence_time': np.random.uniform(10, 30, n_samples)
})

# ç›®æ¨™å¤‰æ•°ï¼ˆè£½å“ç´”åº¦ï¼‰
data['purity'] = (
    92 + 0.2*data['temp'] - 0.01*data['temp']**2 +
    2*data['pressure'] + 0.1*data['residence_time'] +
    np.random.normal(0, 1, n_samples)
)

# ã‚½ãƒ•ãƒˆã‚»ãƒ³ã‚µãƒ¼è¨“ç·´
X = data[['temp', 'pressure', 'flow', 'residence_time']]
y = data['purity']

soft_sensor = SoftSensor('product_purity')
metrics = soft_sensor.train(X, y)

print(f"RÂ² Score: {metrics['r2_score']:.3f}")
print(f"MAE: {metrics['mae']:.3f}")
print("\nFeature Importance:")
print(soft_sensor.get_feature_importance())

# ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ¨å®š
new_data = pd.DataFrame({
    'temp': [360],
    'pressure': [6.0],
    'flow': [100],
    'residence_time': [20]
})
predicted_purity = soft_sensor.predict(new_data)
print(f"\nPredicted Purity: {predicted_purity[0]:.2f}%")
</code></pre>

            <h2>4.3 äºˆçŸ¥ä¿å…¨</h2>

            <p>Digital Twinã§è¨­å‚™åŠ£åŒ–ã‚’Predictionã—ã€æ•…éšœå‰ã«ãƒ¡ãƒ³ãƒ†ãƒŠãƒ³ã‚¹ã‚’å®Ÿæ–½ã—ã¾ã™ã€‚</p>

<pre><code>import warnings
warnings.filterwarnings('ignore')

class PredictiveMaintenanceSystem:
    """äºˆçŸ¥ä¿å…¨ã‚·ã‚¹ãƒ†ãƒ """

    def __init__(self, equipment_name):
        self.equipment = equipment_name
        self.health_index = 100  # å¥å…¨åº¦æŒ‡æ•°
        self.degradation_rate = 0.1
        self.threshold_warning = 70
        self.threshold_critical = 50

    def update_health(self, operating_hours, stress_factors):
        """å¥å…¨åº¦æ›´æ–°

        Args:
            operating_hours: ç¨¼åƒ hours
            stress_factors: ã‚¹ãƒˆãƒ¬ã‚¹è¦å› è¾æ›¸
        """
        # åŸºæœ¬åŠ£åŒ–
        degradation = self.degradation_rate * operating_hours

        # ã‚¹ãƒˆãƒ¬ã‚¹è¦å› ã«ã‚ˆã‚‹åŠ é€ŸåŠ£åŒ–
        temp_stress = max(0, stress_factors.get('temp_excess', 0)) * 0.5
        vibration_stress = stress_factors.get('vibration', 0) * 0.3
        load_stress = stress_factors.get('overload', 0) * 0.4

        total_degradation = degradation + temp_stress + vibration_stress + load_stress

        self.health_index -= total_degradation
        self.health_index = max(0, self.health_index)

        return self.health_index

    def predict_remaining_life(self, current_stress_factors):
        """æ®‹å­˜å¯¿å‘½Prediction"""
        if self.health_index <= 0:
            return 0

        # ç¾åœ¨ã®åŠ£åŒ–é€Ÿåº¦è¨ˆç®—
        temp_stress = max(0, current_stress_factors.get('temp_excess', 0)) * 0.5
        vibration_stress = current_stress_factors.get('vibration', 0) * 0.3
        load_stress = current_stress_factors.get('overload', 0) * 0.4

        degradation_per_hour = (self.degradation_rate +
                                temp_stress + vibration_stress + load_stress)

        if degradation_per_hour <= 0:
            return float('inf')

        # è‡¨ç•Œå€¤åˆ°é”ã¾ã§ã® hours
        remaining_hours = (self.health_index - self.threshold_critical) / degradation_per_hour

        return max(0, remaining_hours)

    def get_maintenance_recommendation(self):
        """ãƒ¡ãƒ³ãƒ†ãƒŠãƒ³ã‚¹æ¨å¥¨"""
        if self.health_index >= self.threshold_warning:
            return {
                'status': 'HEALTHY',
                'action': 'None',
                'urgency': 'Low',
                'health': self.health_index
            }
        elif self.health_index >= self.threshold_critical:
            return {
                'status': 'WARNING',
                'action': 'Schedule maintenance within 7 days',
                'urgency': 'Medium',
                'health': self.health_index
            }
        else:
            return {
                'status': 'CRITICAL',
                'action': 'Immediate maintenance required',
                'urgency': 'High',
                'health': self.health_index
            }

# ä½¿ç”¨ä¾‹
pm_system = PredictiveMaintenanceSystem('Heat Exchanger HX-101')

# Simulation: 100 hoursç¨¼åƒ
for hour in range(1, 101):
    stress = {
        'temp_excess': 5 if hour % 20 == 0 else 0,  # æ™‚ã€…éç†±
        'vibration': 2 if hour > 50 else 1,  # æŒ¯å‹•å¢—åŠ 
        'overload': 3 if hour > 80 else 0  # å¾ŒåŠã«éè² è·
    }

    health = pm_system.update_health(1, stress)

    if hour % 25 == 0:
        remaining = pm_system.predict_remaining_life(stress)
        rec = pm_system.get_maintenance_recommendation()
        print(f"Hour {hour}: Health={health:.1f}%, "
              f"Remaining Life={remaining:.1f}h, "
              f"Status={rec['status']}")

# æœ€çµ‚æ¨å¥¨
final_rec = pm_system.get_maintenance_recommendation()
print(f"\nFinal Recommendation: {final_rec['action']}")
</code></pre>

            <h2>4.4 ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ Optimizationï¼ˆRTOï¼‰</h2>

            <p>Digital Twinã‚’ä½¿ã£ã¦ç¾åœ¨ã®çŠ¶æ…‹ã‹ã‚‰æœ€é©ãªé‹è»¢æ¡ä»¶ã‚’å‹•çš„ã«è¨ˆç®—ã—ã¾ã™ã€‚</p>

<pre><code>from scipy.optimize import minimize

class RealTimeOptimizer:
    """ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ Optimizationã‚·ã‚¹ãƒ†ãƒ """

    def __init__(self, digital_twin, objective='profit'):
        self.twin = digital_twin
        self.objective = objective

    def objective_function(self, x, weights):
        """ç›®çš„é–¢æ•°

        Args:
            x: æ±ºå®šå¤‰æ•° [temp, pressure, flow]
            weights: é‡ã¿ä¿‚æ•°
        """
        temp, pressure, flow = x

        # Digital Twinã§Simulation
        state = {'temp': temp, 'pressure': pressure, 'flow': flow}
        result = self.twin.simulate(state)

        # è¤‡åˆç›®çš„é–¢æ•°ï¼ˆåˆ©ç›Šæœ€å¤§åŒ–ï¼‰
        revenue = result['yield'] * weights['product_price']
        cost = result['cost']
        quality_penalty = max(0, 90 - result['quality']) * weights['quality_penalty']

        profit = revenue - cost - quality_penalty

        return -profit  # æœ€å°åŒ–å•é¡Œã¨ã—ã¦

    def optimize(self, initial_guess, bounds, constraints=None):
        """Optimizationå®Ÿè¡Œ

        Args:
            initial_guess: åˆæœŸå€¤ [temp, pressure, flow]
            bounds: å¤‰æ•°ç¯„å›² [(min, max), ...]
            constraints: åˆ¶ç´„æ¡ä»¶
        """
        weights = {
            'product_price': 10.0,
            'quality_penalty': 50.0
        }

        # åˆ¶ç´„æ¡ä»¶
        cons = []
        if constraints:
            # Safetyåˆ¶ç´„
            cons.append({
                'type': 'ineq',
                'fun': lambda x: constraints['max_temp'] - x[0]
            })
            cons.append({
                'type': 'ineq',
                'fun': lambda x: constraints['max_pressure'] - x[1]
            })

        # Optimization
        result = minimize(
            self.objective_function,
            initial_guess,
            args=(weights,),
            method='SLSQP',
            bounds=bounds,
            constraints=cons if cons else None
        )

        if result.success:
            opt_temp, opt_pressure, opt_flow = result.x
            opt_state = {
                'temp': opt_temp,
                'pressure': opt_pressure,
                'flow': opt_flow
            }
            opt_result = self.twin.simulate(opt_state)

            return {
                'success': True,
                'optimal_conditions': opt_state,
                'expected_performance': opt_result,
                'profit': -result.fun
            }
        else:
            return {'success': False, 'message': result.message}

# ä½¿ç”¨ä¾‹
twin = SimpleReactorModel()
rto = RealTimeOptimizer(twin, objective='profit')

# Optimizationå®Ÿè¡Œ
initial = [350, 5.0, 100]
bounds = [(340, 380), (4.0, 8.0), (80, 120)]
constraints = {
    'max_temp': 375,
    'max_pressure': 7.5
}

opt_result = rto.optimize(initial, bounds, constraints)

if opt_result['success']:
    print("Optimal Conditions:")
    print(f"  Temperature: {opt_result['optimal_conditions']['temp']:.1f}Â°C")
    print(f"  Pressure: {opt_result['optimal_conditions']['pressure']:.1f} bar")
    print(f"  Flow: {opt_result['optimal_conditions']['flow']:.1f} kg/h")
    print(f"\nExpected Performance:")
    print(f"  Yield: {opt_result['expected_performance']['yield']:.1f}%")
    print(f"  Quality: {opt_result['expected_performance']['quality']:.1f}")
    print(f"  Profit: {opt_result['profit']:.2f}")
</code></pre>

            <h2>4.5 ãƒ¢ãƒ‡ãƒ«PredictionControlï¼ˆMPCï¼‰çµ±åˆ</h2>

            <p>Digital Twinã¨MPCã‚’çµ±åˆã—ã€Predictionãƒ›ãƒ©ã‚¤ã‚ºãƒ³ã‚’è€ƒæ…®ã—ãŸæœ€é©Controlã‚’å®Ÿç¾ã—ã¾ã™ã€‚</p>

<pre><code>class ModelPredictiveController:
    """ãƒ¢ãƒ‡ãƒ«PredictionControlï¼ˆç°¡æ˜“ç‰ˆï¼‰"""

    def __init__(self, digital_twin, horizon=10, dt=1.0):
        self.twin = digital_twin
        self.horizon = horizon  # Predictionãƒ›ãƒ©ã‚¤ã‚ºãƒ³
        self.dt = dt  # ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚° hours

    def predict_trajectory(self, initial_state, control_sequence):
        """è»Œé“Prediction

        Args:
            initial_state: åˆæœŸçŠ¶æ…‹
            control_sequence: Controlå…¥åŠ›ç³»åˆ—
        """
        trajectory = [initial_state]
        state = initial_state.copy()

        for control in control_sequence:
            # çŠ¶æ…‹æ›´æ–°ï¼ˆç°¡æ˜“é›¢æ•£åŒ–ãƒ¢ãƒ‡ãƒ«ï¼‰
            state = self.twin.simulate({**state, **control})
            trajectory.append(state)

        return trajectory

    def optimize_control(self, current_state, setpoint):
        """Controlå…¥åŠ›Optimization

        Args:
            current_state: ç¾åœ¨çŠ¶æ…‹
            setpoint: ç›®æ¨™å€¤ {'yield': 85, 'quality': 95}
        """
        def mpc_objective(u_flat):
            # Controlå…¥åŠ›ã‚’å†æ§‹æˆ [temp1, pres1, temp2, pres2, ...]
            controls = []
            for i in range(0, len(u_flat), 2):
                controls.append({
                    'temp': u_flat[i],
                    'pressure': u_flat[i+1]
                })

            # è»Œé“Prediction
            trajectory = self.predict_trajectory(current_state, controls)

            # ã‚³ã‚¹ãƒˆè¨ˆç®—
            tracking_cost = 0
            control_cost = 0

            for state in trajectory[1:]:
                # ãƒˆãƒ©ãƒƒã‚­ãƒ³ã‚°èª¤å·®
                tracking_cost += (state['yield'] - setpoint['yield'])**2
                tracking_cost += (state['quality'] - setpoint['quality'])**2

                # Controlã‚³ã‚¹ãƒˆ
                control_cost += 0.01 * state['cost']

            return tracking_cost + control_cost

        # åˆæœŸæ¨å®šï¼ˆç¾åœ¨å€¤ã‚’ç¶­æŒï¼‰
        u0 = []
        for _ in range(self.horizon):
            u0.extend([current_state['temp'], current_state['pressure']])

        # åˆ¶ç´„
        bounds = [(340, 380), (4.0, 8.0)] * self.horizon

        # Optimization
        result = minimize(
            mpc_objective,
            u0,
            method='L-BFGS-B',
            bounds=bounds
        )

        # æœ€åˆã®Controlå…¥åŠ›ã®ã¿é©ç”¨ï¼ˆãƒªã‚»ãƒ‡ã‚£ãƒ³ã‚°ãƒ›ãƒ©ã‚¤ã‚ºãƒ³ï¼‰
        optimal_temp = result.x[0]
        optimal_pressure = result.x[1]

        return {
            'temp': optimal_temp,
            'pressure': optimal_pressure,
            'flow': current_state['flow']  # æµé‡ã¯å›ºå®š
        }

# ä½¿ç”¨ä¾‹
twin = SimpleReactorModel()
mpc = ModelPredictiveController(twin, horizon=5)

current = {'temp': 350, 'pressure': 5.0, 'flow': 100}
target = {'yield': 85, 'quality': 95}

optimal_control = mpc.optimize_control(current, target)

print("MPC Optimal Control:")
print(f"  Temperature setpoint: {optimal_control['temp']:.1f}Â°C")
print(f"  Pressure setpoint: {optimal_control['pressure']:.2f} bar")

# Controlé©ç”¨å¾Œã®Prediction
future_state = twin.simulate(optimal_control)
print(f"\nPredicted Performance:")
print(f"  Yield: {future_state['yield']:.1f}%")
print(f"  Quality: {future_state['quality']:.1f}")
</code></pre>

            <h2>4.6 å¤šç›®çš„Optimization</h2>

            <p>åç‡ã€å“è³ªã€ã‚³ã‚¹ãƒˆã€ç’°å¢ƒè² è·ãªã©è¤‡æ•°ã®ç›®æ¨™ã‚’åŒæ™‚ã«è€ƒæ…®ã—ãŸãƒ‘ãƒ¬ãƒ¼ãƒˆæœ€é©è§£ã‚’æ¢ç´¢ã—ã¾ã™ã€‚</p>

<pre><code>from scipy.optimize import differential_evolution

class MultiObjectiveOptimizer:
    """å¤šç›®çš„Optimization"""

    def __init__(self, digital_twin):
        self.twin = digital_twin
        self.pareto_solutions = []

    def evaluate_objectives(self, x):
        """è¤‡æ•°ç›®çš„é–¢æ•°è©•ä¾¡

        Returns:
            [yield, quality, cost, energy]
        """
        state = {'temp': x[0], 'pressure': x[1], 'flow': x[2]}
        result = self.twin.simulate(state)

        # ã‚¨ãƒãƒ«ã‚®ãƒ¼æ¶ˆè²»é‡æ¨å®š
        energy = 0.5*x[0] + 20*x[1]**1.5  # ç°¡æ˜“ãƒ¢ãƒ‡ãƒ«

        return {
            'yield': result['yield'],
            'quality': result['quality'],
            'cost': result['cost'],
            'energy': energy
        }

    def weighted_sum_method(self, bounds, weights):
        """é‡ã¿ä»˜ã‘å’Œæ³•

        Args:
            bounds: [(min, max), ...]
            weights: {'yield': w1, 'quality': w2, ...}
        """
        def objective(x):
            obj = self.evaluate_objectives(x)

            # æ­£è¦åŒ–ï¼ˆä»®ã®æœ€å¤§å€¤ï¼‰
            yield_norm = obj['yield'] / 100
            quality_norm = obj['quality'] / 100
            cost_norm = obj['cost'] / 500
            energy_norm = obj['energy'] / 300

            # é‡ã¿ä»˜ã‘å’Œï¼ˆã‚³ã‚¹ãƒˆã¨ã‚¨ãƒãƒ«ã‚®ãƒ¼ã¯æœ€å°åŒ–ï¼‰
            score = (weights.get('yield', 0) * yield_norm +
                    weights.get('quality', 0) * quality_norm -
                    weights.get('cost', 0) * cost_norm -
                    weights.get('energy', 0) * energy_norm)

            return -score  # æœ€å¤§åŒ–â†’æœ€å°åŒ–

        result = differential_evolution(objective, bounds, seed=42)

        if result.success:
            optimal_x = result.x
            objectives = self.evaluate_objectives(optimal_x)

            return {
                'conditions': {
                    'temp': optimal_x[0],
                    'pressure': optimal_x[1],
                    'flow': optimal_x[2]
                },
                'objectives': objectives
            }
        return None

    def pareto_frontier(self, bounds, n_points=10):
        """ãƒ‘ãƒ¬ãƒ¼ãƒˆãƒ•ãƒ­ãƒ³ãƒ†ã‚£ã‚¢æ¢ç´¢"""
        pareto_solutions = []

        # ç•°ãªã‚‹é‡ã¿è¨­å®šã§Optimization
        for i in range(n_points):
            alpha = i / (n_points - 1)

            weights = {
                'yield': alpha,
                'quality': 1 - alpha,
                'cost': 0.5,
                'energy': 0.3
            }

            solution = self.weighted_sum_method(bounds, weights)
            if solution:
                pareto_solutions.append(solution)

        self.pareto_solutions = pareto_solutions
        return pareto_solutions

# ä½¿ç”¨ä¾‹
twin = SimpleReactorModel()
mo_optimizer = MultiObjectiveOptimizer(twin)

bounds = [(340, 380), (4.0, 8.0), (80, 120)]

# ã‚·ãƒŠãƒªã‚ª1: åç‡é‡è¦–
solution1 = mo_optimizer.weighted_sum_method(
    bounds,
    {'yield': 1.0, 'quality': 0.3, 'cost': 0.5, 'energy': 0.2}
)

print("Scenario 1: Yield Priority")
print(f"  Conditions: {solution1['conditions']}")
print(f"  Yield: {solution1['objectives']['yield']:.1f}%")
print(f"  Quality: {solution1['objectives']['quality']:.1f}")
print(f"  Cost: {solution1['objectives']['cost']:.1f}")

# ã‚·ãƒŠãƒªã‚ª2: å“è³ªé‡è¦–
solution2 = mo_optimizer.weighted_sum_method(
    bounds,
    {'yield': 0.3, 'quality': 1.0, 'cost': 0.5, 'energy': 0.2}
)

print("\nScenario 2: Quality Priority")
print(f"  Conditions: {solution2['conditions']}")
print(f"  Yield: {solution2['objectives']['yield']:.1f}%")
print(f"  Quality: {solution2['objectives']['quality']:.1f}")
</code></pre>

            <h2>4.7 ãƒªã‚¹ã‚¯è©•ä¾¡ã¨ã‚·ãƒŠãƒªã‚ªãƒ—ãƒ©ãƒ³ãƒ‹ãƒ³ã‚°</h2>

            <p>Digital Twinã§å¤–ä¹±ã‚„æ•…éšœã®ã‚·ãƒŠãƒªã‚ªã‚’è©•ä¾¡ã—ã€ãƒªã‚¹ã‚¯ã‚’å®šé‡åŒ–ã—ã¾ã™ã€‚</p>

<pre><code>import random

class RiskAssessmentSystem:
    """ãƒªã‚¹ã‚¯è©•ä¾¡ã‚·ã‚¹ãƒ†ãƒ """

    def __init__(self, digital_twin):
        self.twin = digital_twin
        self.risk_scenarios = []

    def define_risk_scenario(self, name, disturbances, probability):
        """ãƒªã‚¹ã‚¯ã‚·ãƒŠãƒªã‚ªå®šç¾©

        Args:
            name: ã‚·ãƒŠãƒªã‚ªå
            disturbances: å¤–ä¹± {'temp': +10, ...}
            probability: ç™ºç”Ÿç¢ºç‡
        """
        self.risk_scenarios.append({
            'name': name,
            'disturbances': disturbances,
            'probability': probability
        })

    def monte_carlo_simulation(self, baseline_state, n_simulations=1000):
        """ãƒ¢ãƒ³ãƒ†ã‚«ãƒ«ãƒ­Simulation"""
        results = []

        for _ in range(n_simulations):
            # ãƒ©ãƒ³ãƒ€ãƒ ã«ã‚·ãƒŠãƒªã‚ªé¸æŠ
            scenario = random.choices(
                self.risk_scenarios,
                weights=[s['probability'] for s in self.risk_scenarios]
            )[0]

            # å¤–ä¹±é©ç”¨
            disturbed_state = baseline_state.copy()
            for key, disturbance in scenario['disturbances'].items():
                disturbed_state[key] = disturbed_state.get(key, 0) + disturbance

            # Simulation
            result = self.twin.simulate(disturbed_state)
            result['scenario'] = scenario['name']
            results.append(result)

        return pd.DataFrame(results)

    def calculate_risk_metrics(self, simulation_results):
        """ãƒªã‚¹ã‚¯æŒ‡æ¨™è¨ˆç®—"""
        # Value at Risk (VaR): 5%ã‚¿ã‚¤ãƒ«å€¤
        var_yield = simulation_results['yield'].quantile(0.05)
        var_quality = simulation_results['quality'].quantile(0.05)

        # æœŸå¾…å€¤
        expected_yield = simulation_results['yield'].mean()
        expected_quality = simulation_results['quality'].mean()

        # æ¨™æº–åå·®
        std_yield = simulation_results['yield'].std()
        std_quality = simulation_results['quality'].std()

        return {
            'expected_yield': expected_yield,
            'expected_quality': expected_quality,
            'var_yield_5%': var_yield,
            'var_quality_5%': var_quality,
            'std_yield': std_yield,
            'std_quality': std_quality
        }

# ä½¿ç”¨ä¾‹
twin = SimpleReactorModel()
risk_system = RiskAssessmentSystem(twin)

# ãƒªã‚¹ã‚¯ã‚·ãƒŠãƒªã‚ªå®šç¾©
risk_system.define_risk_scenario(
    'Normal Operation',
    {'temp': 0, 'pressure': 0},
    probability=0.70
)

risk_system.define_risk_scenario(
    'Heat Exchanger Fouling',
    {'temp': -10},  # å†·å´èƒ½åŠ›ä½ä¸‹
    probability=0.15
)

risk_system.define_risk_scenario(
    'Feed Composition Shift',
    {'temp': 5, 'pressure': -0.5},
    probability=0.10
)

risk_system.define_risk_scenario(
    'Compressor Failure',
    {'pressure': -2.0},
    probability=0.05
)

# ãƒ¢ãƒ³ãƒ†ã‚«ãƒ«ãƒ­Simulation
baseline = {'temp': 360, 'pressure': 6.0, 'flow': 100}
mc_results = risk_system.monte_carlo_simulation(baseline, n_simulations=1000)

# ãƒªã‚¹ã‚¯æŒ‡æ¨™
risk_metrics = risk_system.calculate_risk_metrics(mc_results)

print("Risk Assessment Results:")
print(f"Expected Yield: {risk_metrics['expected_yield']:.2f}%")
print(f"Yield VaR (5%): {risk_metrics['var_yield_5%']:.2f}%")
print(f"Yield Std Dev: {risk_metrics['std_yield']:.2f}%")
print(f"\nExpected Quality: {risk_metrics['expected_quality']:.2f}")
print(f"Quality VaR (5%): {risk_metrics['var_quality_5%']:.2f}")

# ã‚·ãƒŠãƒªã‚ªåˆ¥é›†è¨ˆ
scenario_stats = mc_results.groupby('scenario')['yield'].agg(['mean', 'std', 'min'])
print("\nYield by Scenario:")
print(scenario_stats)
</code></pre>

            <div class="callout callout-info">
                <strong>ğŸ“Š ç”£æ¥­å®Ÿç¸¾:</strong>
                <ul>
                    <li><strong>Shell:</strong> Digital Twinã¨RTOã§ç²¾è£½Processã®åç›Šã‚’å¹´é–“$æ•°ç™¾ä¸‡æ”¹å–„</li>
                    <li><strong>BASF:</strong> ä»®æƒ³Optimizationã§æ–°è£½å“é–‹ç™ºæœŸé–“ã‚’30%çŸ­ç¸®</li>
                    <li><strong>Dow Chemical:</strong> äºˆçŸ¥ä¿å…¨ã§è¨ˆç”»å¤–åœæ­¢ã‚’40%å‰Šæ¸›</li>
                </ul>
            </div>

            <h2>Learning Objectivesã®ç¢ºèª</h2>

            <p>ã“ã® Chapterã‚’å®Œäº†ã™ã‚‹ã¨ã€ä»¥ä¸‹ã‚’èª¬æ˜ãƒ»å®Ÿè£…ã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ï¼š</p>

            <h3>åŸºæœ¬ç†è§£</h3>
            <ul>
                <li>âœ… What-ifã‚·ãƒŠãƒªã‚ª minutesæã®ç›®çš„ã¨ä¾¡å€¤ã‚’èª¬æ˜ã§ãã‚‹</li>
                <li>âœ… ã‚½ãƒ•ãƒˆã‚»ãƒ³ã‚µãƒ¼ã®å½¹å‰²ã¨é©ç”¨å ´é¢ã‚’ç†è§£ã—ã¦ã„ã‚‹</li>
                <li>âœ… äºˆçŸ¥ä¿å…¨ãŒå¾“æ¥ä¿å…¨ã‚ˆã‚Šå„ªã‚Œã‚‹ç†ç”±ã‚’èª¬æ˜ã§ãã‚‹</li>
                <li>âœ… RTOã¨MPCã®é•ã„ã‚’ç†è§£ã—ã¦ã„ã‚‹</li>
            </ul>

            <h3>å®Ÿè·µã‚¹ã‚­ãƒ«</h3>
            <ul>
                <li>âœ… Pythonã§ã‚·ãƒŠãƒªã‚ª minutesæã‚·ã‚¹ãƒ†ãƒ ã‚’å®Ÿè£…ã§ãã‚‹</li>
                <li>âœ… Machine Learningãƒ™ãƒ¼ã‚¹ã®ã‚½ãƒ•ãƒˆã‚»ãƒ³ã‚µãƒ¼ã‚’æ§‹ç¯‰ã§ãã‚‹</li>
                <li>âœ… äºˆçŸ¥ä¿å…¨ã‚·ã‚¹ãƒ†ãƒ ã®åŸºæœ¬çš„ãªå®Ÿè£…ãŒã§ãã‚‹</li>
                <li>âœ… scipy.optimizeã‚’ä½¿ã£ãŸOptimizationã‚’å®Ÿè£…ã§ãã‚‹</li>
                <li>âœ… ãƒ¢ãƒ³ãƒ†ã‚«ãƒ«ãƒ­æ³•ã§ãƒªã‚¹ã‚¯è©•ä¾¡ãŒã§ãã‚‹</li>
            </ul>

            <h3>å¿œç”¨åŠ›</h3>
            <ul>
                <li>âœ… è‡ªç¤¾Processã«é©ã—ãŸOptimizationæˆ¦ç•¥ã‚’è¨­è¨ˆã§ãã‚‹</li>
                <li>âœ… å¤šç›®çš„Optimizationå•é¡Œã‚’ãƒ¢ãƒ‡ãƒ«åŒ–ã§ãã‚‹</li>
                <li>âœ… ãƒªã‚¹ã‚¯ã‚·ãƒŠãƒªã‚ªã‚’å®šé‡çš„ã«è©•ä¾¡ã§ãã‚‹</li>
            </ul>

            <h2>Exercises</h2>

            <h3>Easyï¼ˆåŸºç¤ç¢ºèªï¼‰</h3>

            <p><strong>Q1:</strong> ã‚½ãƒ•ãƒˆã‚»ãƒ³ã‚µãƒ¼ãŒç‰¹ã«æœ‰ç”¨ãªã®ã¯ã©ã®ã‚ˆã†ãªå ´åˆã§ã™ã‹ï¼Ÿ</p>

            <details>
                <summary>è§£ç­”ã‚’è¦‹ã‚‹</summary>

                <p><strong>æ­£è§£:</strong> ä»¥ä¸‹ã®å ´åˆã«ã‚½ãƒ•ãƒˆã‚»ãƒ³ã‚µãƒ¼ãŒæœ‰ç”¨ã§ã™ï¼š</p>
                <ol>
                    <li>æ¸¬å®šè£…ç½®ãŒé«˜ã‚³ã‚¹ãƒˆï¼ˆè³ªé‡ minutesæè¨ˆãªã©ï¼‰</li>
                    <li>æ¸¬å®šã« hoursãŒã‹ã‹ã‚‹ï¼ˆãƒ©ãƒœ minutesæãŒå¿…è¦ï¼‰</li>
                    <li>ã‚ªãƒ³ãƒ©ã‚¤ãƒ³æ¸¬å®šãŒå›°é›£ï¼ˆè£½å“å“è³ªãªã©ï¼‰</li>
                    <li>ã‚»ãƒ³ã‚µãƒ¼ãŒéé…·ç’°å¢ƒã§ä½¿ãˆãªã„</li>
                </ol>

                <p><strong>è§£èª¬:</strong> ã‚½ãƒ•ãƒˆã‚»ãƒ³ã‚µãƒ¼ã¯æ¸¬å®šå¯èƒ½ãªå¤‰æ•°ï¼ˆæ¸©åº¦ã€åœ§åŠ›ãªã©ï¼‰ã‹ã‚‰æ¸¬å®šå›°é›£ãªå¤‰æ•°ã‚’æ¨å®šã—ã¾ã™ã€‚ä¾‹ãˆã°ã€åå¿œå™¨å†…ã®æˆ minutesçµ„æˆã‚’ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ã§æ¸¬å®šã™ã‚‹ã®ã¯å›°é›£ã§ã™ãŒã€æ¸©åº¦ãƒ»åœ§åŠ›ãƒ»æµé‡ã‹ã‚‰Machine Learningãƒ¢ãƒ‡ãƒ«ã§æ¨å®šã§ãã¾ã™ã€‚</p>
            </details>

            <h3>Mediumï¼ˆå¿œç”¨ï¼‰</h3>

            <p><strong>Q2:</strong> RTOã¨MPCã®ä¸»ãªé•ã„ã‚’3ã¤æŒ™ã’ã¦ãã ã•ã„ã€‚</p>

            <details>
                <summary>è§£ç­”ã‚’è¦‹ã‚‹</summary>

                <p><strong>æ­£è§£:</strong></p>
                <table>
                    <tr>
                        <th>é …ç›®</th>
                        <th>RTOï¼ˆReal-Time Optimizationï¼‰</th>
                        <th>MPCï¼ˆModel Predictive Controlï¼‰</th>
                    </tr>
                    <tr>
                        <td>å®Ÿè¡Œé »åº¦</td>
                        <td>ä½é »åº¦ï¼ˆæ•° hoursï½æ—¥å˜ä½ï¼‰</td>
                        <td>é«˜é »åº¦ï¼ˆç§’ï½ minuteså˜ä½ï¼‰</td>
                    </tr>
                    <tr>
                        <td>ç›®çš„</td>
                        <td>å®šå¸¸çŠ¶æ…‹ã®çµŒæ¸ˆOptimization</td>
                        <td>å‹•çš„Controlã¨åˆ¶ç´„ç®¡ç†</td>
                    </tr>
                    <tr>
                        <td>å‡ºåŠ›</td>
                        <td>ç›®æ¨™è¨­å®šå€¤ï¼ˆsetpointsï¼‰</td>
                        <td>ç›´æ¥çš„ãªControlå…¥åŠ›</td>
                    </tr>
                </table>

                <p><strong>è§£èª¬:</strong> RTOã¯çµŒæ¸ˆçš„Optimizationã«ç„¦ç‚¹ã‚’å½“ã¦ã€MPCã¯ãã®ç›®æ¨™å€¤ã‚’é”æˆã™ã‚‹ãŸã‚ã®å‹•çš„Controlã‚’æ‹…å½“ã—ã¾ã™ã€‚å®Ÿå‹™ã§ã¯ä¸¡è€…ã‚’éšå±¤çš„ã«çµ„ã¿åˆã‚ã›ã‚‹ã“ã¨ãŒå¤šã„ã§ã™ã€‚</p>
            </details>

            <h3>Hardï¼ˆç™ºå±•ï¼‰</h3>

            <p><strong>Q3:</strong> æä¾›ã•ã‚ŒãŸWhatIfAnalyzerã‚¯ãƒ©ã‚¹ã‚’æ‹¡å¼µã—ã€ä¸ç¢ºå®Ÿæ€§ã‚’è€ƒæ…®ã—ãŸã‚·ãƒŠãƒªã‚ª minutesæã‚’å®Ÿè£…ã—ã¦ãã ã•ã„ã€‚å„ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã«Â±5%ã®å¤‰å‹•ã‚’ä¸ãˆã€100å›ã®ãƒ¢ãƒ³ãƒ†ã‚«ãƒ«ãƒ­Simulationã§çµæœã® minuteså¸ƒã‚’è©•ä¾¡ã™ã‚‹ã‚³ãƒ¼ãƒ‰ã‚’æ›¸ã„ã¦ãã ã•ã„ã€‚</p>

            <details>
                <summary>è§£ç­”ä¾‹ã‚’è¦‹ã‚‹</summary>

<pre><code>class UncertaintyWhatIfAnalyzer(WhatIfAnalyzer):
    """ä¸ç¢ºå®Ÿæ€§ã‚’è€ƒæ…®ã—ãŸWhat-if minutesæ"""

    def create_uncertain_scenario(self, name, parameter_changes,
                                  uncertainty=0.05, n_sim=100):
        """ä¸ç¢ºå®Ÿæ€§ã‚’è€ƒæ…®ã—ãŸã‚·ãƒŠãƒªã‚ª minutesæ

        Args:
            name: ã‚·ãƒŠãƒªã‚ªå
            parameter_changes: åç›®å€¤
            uncertainty: å¤‰å‹•å¹…ï¼ˆÂ±5% = 0.05ï¼‰
            n_sim: Simulationå›æ•°
        """
        results = []

        for _ in range(n_sim):
            # ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã«ä¸ç¢ºå®Ÿæ€§ã‚’è¿½åŠ 
            uncertain_changes = {}
            for param, value in parameter_changes.items():
                noise = np.random.uniform(-uncertainty, uncertainty)
                uncertain_changes[param] = value * (1 + noise)

            # ãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ³å–å¾—
            baseline = self.model.get_current_state()
            modified_state = baseline.copy()
            modified_state.update(uncertain_changes)

            # Simulation
            result = self.model.simulate(modified_state)
            results.append(result)

        # çµ±è¨ˆ minutesæ
        df = pd.DataFrame(results)

        return {
            'name': name,
            'nominal_changes': parameter_changes,
            'mean_yield': df['yield'].mean(),
            'std_yield': df['yield'].std(),
            'yield_5_percentile': df['yield'].quantile(0.05),
            'yield_95_percentile': df['yield'].quantile(0.95),
            'mean_quality': df['quality'].mean(),
            'std_quality': df['quality'].std()
        }

# ä½¿ç”¨ä¾‹
model = SimpleReactorModel()
uncertain_analyzer = UncertaintyWhatIfAnalyzer(model)

uncertain_result = uncertain_analyzer.create_uncertain_scenario(
    'High Temp with Uncertainty',
    {'temp': 370},
    uncertainty=0.05,
    n_sim=100
)

print(f"Scenario: {uncertain_result['name']}")
print(f"Mean Yield: {uncertain_result['mean_yield']:.2f}% "
      f"Â± {uncertain_result['std_yield']:.2f}%")
print(f"Yield 90% Confidence Interval: "
      f"[{uncertain_result['yield_5_percentile']:.2f}, "
      f"{uncertain_result['yield_95_percentile']:.2f}]%")
</code></pre>

                <p><strong>è§£èª¬:</strong> ã“ã®å®Ÿè£…ã§ã¯ã€å„ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã«æ­£è¦ minuteså¸ƒãƒã‚¤ã‚ºã‚’åŠ ãˆã€ãƒ¢ãƒ³ãƒ†ã‚«ãƒ«ãƒ­æ³•ã§çµæœã® minuteså¸ƒã‚’è©•ä¾¡ã—ã¦ã„ã¾ã™ã€‚å®Ÿå‹™ã§ã¯ã€ä¸ç¢ºå®Ÿæ€§ã®å®šé‡åŒ–ãŒãƒªã‚¹ã‚¯ç®¡ç†ã«ä¸å¯æ¬ ã§ã™ã€‚</p>
            </details>

            <h2>Next Steps</h2>

            <p>Chapter 4ã§ã¯ã€Digital Twinã‚’ä½¿ã£ãŸä»®æƒ³Optimizationã®å„ç¨®æ‰‹æ³•ã‚’å­¦ã³ã¾ã—ãŸã€‚æ¬¡ Chapterã§ã¯ã€ã“ã‚Œã‚‰ã‚’ã©ã®ã‚ˆã†ã«å®Ÿç’°å¢ƒã«ãƒ‡ãƒ—ãƒ­ã‚¤ã™ã‚‹ã‹ã€æœ¬ç•ªé‹ç”¨ã®ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹ã‚’è§£èª¬ã—ã¾ã™ã€‚</p>

            <div class="nav-buttons">
                <a href="chapter-3.html" class="nav-button">â† Chapter 3: ãƒ‡ãƒ¼ã‚¿åŒåŒ–</a>
                <a href="chapter-5.html" class="nav-button">Chapter 5: ãƒ‡ãƒ—ãƒ­ã‚¤ã¨é‹ç”¨ â†’</a>
            </div>
        </section>
    </main>

    <footer style="background-color: var(--color-bg-alt); padding: var(--spacing-lg); text-align: center; margin-top: var(--spacing-xl); border-top: 1px solid var(--color-border);">
        <p><a href="index.html">Series Contentsã«æˆ»ã‚‹</a> | <a href="../index.html">PIãƒŠãƒ¬ãƒƒã‚¸ãƒ™ãƒ¼ã‚¹ãƒˆãƒƒãƒ—</a></p>
        <p style="margin-top: var(--spacing-sm); color: var(--color-text-light); font-size: 0.9rem;">
            &copy; 2025 PI Terakoya | æ±åŒ—å¤§å­¦ æ©‹æœ¬é›„ä»‹ç ”ç©¶å®¤
        </p>
    </footer>
</body>
</html>
