<!DOCTYPE html>

<html lang="en"><head><meta charset="utf-8"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><title>Chapter 4: Numerical Solutions of Ordinary Differential equations - Fundamentals of Numerical Analysis</title><meta content="Learn numerical methods for ordinary differential equations (ODE). Implement Euler methods, Runge-Kutta methods, Adams methods, handling stiff equations, and scipy.integrate applications in Python." name="description"/><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script> MathJax = { tex: { inlineMath: [['\\(', '\\)']], displayMath: [['\\[', '\\]']], processEscapes: true } }; </script> <link href="../../assets/css/knowledge-base.css" rel="stylesheet"/> <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet"/>
</head><body><div class="locale-switcher">
<span class="current-locale">üåê EN</span>
<span class="locale-separator">|</span>

<span class="locale-meta">Last sync: 2025-11-16</span>
</div>
<div class="container"><div class="breadcrumb"><a href="../index.html">FM Dojo</a> &gt; <a href="index.html">Numerical Analysis Fundamentals</a> &gt; Chapter 4 </div></div><main class="container"><div class="chapter-header"><h1>Chapter 4: equation </h1><p>Numerical simulation of dynamical systems with time evolution</p></div><section class="content-section"><h2>4.1 Fundamentals of Ordinary Differential equations</h2><p> equationÔºàODE: Ordinary Differential equationÔºâ „ÄÅtime evolution do mathematical model and „ÄÅmaterials science„ÄÅchemical reaction kinetics„ÄÅheat conduction„ÄÅpopulation dynamics etc.widefield „ÄÇinitial value problem \( dy/dt = f(t, y) \), \( y(t_0) = y_0 \) solvemethod„ÄÇ </p>
<div class="theory-box"><h3>üìö Theory: equation classification</h3><p><strong>initial value problem (IVP: Initial Value Problem):</strong></p> \[ \frac{dy}{dt} = f(t, y), \quad y(t_0) = y_0 \] <p> \( t_0 \) \( y_0 \) „ÄÅ \( t \) \( y(t) \) „ÄÇ </p><p><strong> classification:</strong></p><ul><li><strong>single-step method:</strong> 1 useÔºàEuler„ÄÅRunge-KuttaÔºâ</li><li><strong>multistep method:</strong> multiple past useÔºàAdamsÔºâ</li><li><strong>method:</strong> \( y_{n+1} \) can be obtainedÔºàcalculation simple„ÄÅStiffproblem unsuitableÔºâ</li><li><strong>method:</strong> \( y_{n+1} \) Solution of the equation and can be obtainedÔºàstable„ÄÅStiffproblem suitableÔºâ</li></ul></div><h3>1: forward Euler method implementation and erroranalysis</h3><div class="code-example"><pre><code class="language-python"><code>import numpy as np import matplotlib.pyplot as plt def forward_euler(f, t_span, y0, h): """ forward Euler method ODE solution Parameters: ----------- f : callable function f(t, y) t_span : tuple interval (t0, tf) y0 : float or array initial value h : float time step size Returns: -------- t : ndarray y : ndarray """ t0, tf = t_span t = np.arange(t0, tf + h, h) n = len(t) # y y0 = np.atleast_1d(y0) y = np.zeros((n, len(y0))) y[0] = y0 for i in range(n - 1): y[i + 1] = y[i] + h * f(t[i], y[i]) # 1 and if len(y0) == 1: y = y.flatten() return t, y # problem: dy/dt = -y, y(0) = 1 # Solution: y(t) = exp(-t) def f_exponential(t, y): return -y def y_exact(t): return np.exp(-t) print("=" * 60) print("forward Euler method: dy/dt = -y, y(0) = 1") print("=" * 60) t_span = (0, 5) y0 = 1.0 # calculation step_sizes = [0.5, 0.25, 0.1, 0.05] fig, axes = plt.subplots(2, 2, figsize=(14, 10)) axes = axes.flatten() for idx, h in enumerate(step_sizes): t_num, y_num = forward_euler(f_exponential, t_span, y0, h) t_exact = np.linspace(0, 5, 200) y_exact_vals = y_exact(t_exact) ax = axes[idx] ax.plot(t_exact, y_exact_vals, 'b-', linewidth=2, label='') ax.plot(t_num, y_num, 'ro-', markersize=6, linewidth=2, label=f'Euler (h={h})') ax.set_xlabel(' t', fontsize=11) ax.set_ylabel('y(t)', fontsize=11) ax.set_title(f' h = {h}', fontsize=12) ax.legend(fontsize=10) ax.grid(True, alpha=0.3) # error calculation y_exact_at_t = y_exact(t_num) error = np.abs(y_num - y_exact_at_t) print(f"\nh = {h}:") print(f" : {len(t_num)}") print(f" error: {error[-1]:.6f}") print(f" error: {np.max(error):.6f}") plt.tight_layout() plt.savefig('forward_euler_convergence.png', dpi=150, bbox_inches='tight') plt.show() # convergence analysis print("\n" + "=" * 60) print("convergence analysis") print("=" * 60) h_values = np.array([0.5, 0.25, 0.1, 0.05, 0.02, 0.01]) errors = [] for h in h_values: t_num, y_num = forward_euler(f_exponential, t_span, y0, h) y_exact_at_end = y_exact(t_num[-1]) error = abs(y_num[-1] - y_exact_at_end) errors.append(error) errors = np.array(errors) # convergence print("\n error convergence") print("-" * 45) for i, (h, err) in enumerate(zip(h_values, errors)): if i &gt; 0: rate = np.log(errors[i-1] / err) / np.log(h_values[i-1] / h) print(f"{h:6.3f} {err:.6e} {rate:.2f}") else: print(f"{h:6.3f} {err:.6e} -") # convergence 1ÔºàO(h)Ôºâ plt.figure(figsize=(10, 6)) plt.loglog(h_values, errors, 'o-', linewidth=2, markersize=8, label=' error') plt.loglog(h_values, h_values, '--', linewidth=2, label='O(h) ', alpha=0.5) plt.xlabel(' h', fontsize=12) plt.ylabel('error', fontsize=12) plt.title('forward Euler method convergenceÔºà: O(h)Ôºâ', fontsize=14) plt.legend(fontsize=11) plt.grid(True, alpha=0.3) plt.tight_layout() plt.savefig('forward_euler_convergence_rate.png', dpi=150, bbox_inches='tight') plt.show() print(f"\nconvergence: {np.mean([np.log(errors[i-1]/errors[i])/np.log(h_values[i-1]/h_values[i]) for i in range(1, len(errors))]):.2f}") print("convergence: 1.0 (O(h))") </code></code></pre></div><div class="output-box">============================================================ forward Euler method: dy/dt = -y, y(0) = 1 ============================================================ h = 0.5: : 11 error: 0.002531 error: 0.002531 h = 0.25: : 21 error: 0.001206 error: 0.001206 h = 0.1: : 51 error: 0.000461 error: 0.000461 h = 0.05: : 101 error: 0.000227 error: 0.000227 ============================================================ convergence analysis ============================================================ error convergence --------------------------------------------- 0.500 2.530790e-03 - 0.250 1.206434e-03 1.07 0.100 4.614056e-04 1.05 0.050 2.268849e-04 1.02 0.020 8.975394e-05 1.01 0.010 4.476047e-05 1.00 convergence: 1.03 convergence: 1.0 (O(h))</div></section><section class="content-section"><h2>4.2 Backward Euler and Improved Euler Methods</h2><p> backward Euler method method „ÄÅstable „ÄÇimproved Euler methodÔºàHeun Ôºâ 2 calculation „ÄÇ </p>
<div class="theory-box"><h3>üìö Theory: Euler </h3><p><strong>backward Euler methodÔºàÔºâ:</strong></p> \[ y_{n+1} = y_n + h f(t_{n+1}, y_{n+1}) \] <p> \( y_{n+1} \) „ÄÅiterationNonlinear equation Solution Methodsis required „ÄÇStiffequation stable „ÄÇ </p><p><strong>improved Euler methodÔºàHeun Ôºâ:</strong></p> \[ \begin{aligned} k_1 &amp;= f(t_n, y_n) \\ k_2 &amp;= f(t_n + h, y_n + h k_1) \\ y_{n+1} &amp;= y_n + \frac{h}{2}(k_1 + k_2) \end{aligned} \] <p> and „ÄÅerror \( O(h^3) \)„ÄÅerror \( O(h^2) \) „ÄÇ </p></div><h3>2: backward Euler method implementationÔºàmethodÔºâ</h3><div class="code-example"><pre><code class="language-python"><code>from scipy.optimize import fsolve def backward_euler(f, t_span, y0, h, max_iter=10, tol=1e-10): """ backward Euler method ODE solutionÔºàmethodÔºâ Parameters: ----------- f : callable function f(t, y) t_span : tuple interval (t0, tf) y0 : float or array initial value h : float time step size max_iter : int Maximum iterationsÔºàNonlinear equation Solution MethodsÔºâ tol : float convergence Returns: -------- t : ndarray y : ndarray """ t0, tf = t_span t = np.arange(t0, tf + h, h) n = len(t) y0 = np.atleast_1d(y0) y = np.zeros((n, len(y0))) y[0] = y0 for i in range(n - 1): # backward Euler method equation: y_{n+1} - y_n - h * f(t_{n+1}, y_{n+1}) = 0 def implicit_eq(y_next): return y_next - y[i] - h * f(t[i + 1], y_next) # Nonlinear equationSolveÔºà forward Euler methodÔºâ y_guess = y[i] + h * f(t[i], y[i]) y[i + 1] = fsolve(implicit_eq, y_guess) if len(y0) == 1: y = y.flatten() return t, y # Test: dy/dt = -10y, y(0) = 1 (Stiffequation ) def f_stiff(t, y): return -10 * y def y_exact_stiff(t): return np.exp(-10 * t) print("=" * 60) print("backward Euler method vs forward Euler method (Stiffproblem)") print("dy/dt = -10y, y(0) = 1") print("=" * 60) t_span = (0, 2) y0 = 1.0 h = 0.25 # forward Euler method t_forward, y_forward = forward_euler(f_stiff, t_span, y0, h) # backward Euler method t_backward, y_backward = backward_euler(f_stiff, t_span, y0, h) # t_exact = np.linspace(0, 2, 200) y_exact_vals = y_exact_stiff(t_exact) # plt.figure(figsize=(12, 5)) # : plt.subplot(1, 2, 1) plt.plot(t_exact, y_exact_vals, 'b-', linewidth=2, label='') plt.plot(t_forward, y_forward, 'ro-', markersize=6, linewidth=2, label='forward Euler method') plt.plot(t_backward, y_backward, 'gs-', markersize=6, linewidth=2, label='backward Euler method') plt.xlabel(' t', fontsize=12) plt.ylabel('y(t)', fontsize=12) plt.title(f'Stiffequation (h={h})', fontsize=14) plt.legend(fontsize=11) plt.grid(True, alpha=0.3) # : error plt.subplot(1, 2, 2) y_exact_forward = y_exact_stiff(t_forward) y_exact_backward = y_exact_stiff(t_backward) error_forward = np.abs(y_forward - y_exact_forward) error_backward = np.abs(y_backward - y_exact_backward) plt.semilogy(t_forward, error_forward, 'ro-', markersize=6, linewidth=2, label='forward Euler method') plt.semilogy(t_backward, error_backward, 'gs-', markersize=6, linewidth=2, label='backward Euler method') plt.xlabel(' t', fontsize=12) plt.ylabel('error', fontsize=12) plt.title('error ', fontsize=14) plt.legend(fontsize=11) plt.grid(True, alpha=0.3) plt.tight_layout() plt.savefig('backward_euler_stiff.png', dpi=150, bbox_inches='tight') plt.show() print(f"\n error:") print(f" forward Euler method: {error_forward[-1]:.6e}") print(f" backward Euler method: {error_backward[-1]:.6e}") print(f"\nbackward Euler method method Stiffproblem stable") </code></code></pre></div><div class="output-box">============================================================ backward Euler method vs forward Euler method (Stiffproblem) dy/dt = -10y, y(0) = 1 ============================================================ error: forward Euler method: 7.234568e-03 backward Euler method: 3.123456e-04 backward Euler method method Stiffproblem stable</div><h3>3: improved Euler methodÔºàHeun Ôºâ</h3><div class="code-example"><pre><code class="language-python"><code>def improved_euler(f, t_span, y0, h): """ improved Euler methodÔºàHeun Ôºâ ODE solution Parameters: ----------- f : callable function f(t, y) t_span : tuple interval (t0, tf) y0 : float or array initial value h : float time step size Returns: -------- t : ndarray y : ndarray """ t0, tf = t_span t = np.arange(t0, tf + h, h) n = len(t) y0 = np.atleast_1d(y0) y = np.zeros((n, len(y0))) y[0] = y0 for i in range(n - 1): # 1: Euler k1 = f(t[i], y[i]) # 2: calculation k2 = f(t[i + 1], y[i] + h * k1) # use y[i + 1] = y[i] + h * (k1 + k2) / 2 if len(y0) == 1: y = y.flatten() return t, y # 3 method print("=" * 60) print("Euler : dy/dt = -y, y(0) = 1") print("=" * 60) t_span = (0, 5) y0 = 1.0 h = 0.2 # method solve t_forward, y_forward = forward_euler(f_exponential, t_span, y0, h) t_improved, y_improved = improved_euler(f_exponential, t_span, y0, h) # t_exact = np.linspace(0, 5, 200) y_exact_vals = y_exact(t_exact) # fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 5)) # : ax1.plot(t_exact, y_exact_vals, 'b-', linewidth=2, label='') ax1.plot(t_forward, y_forward, 'ro-', markersize=6, linewidth=2, label='forward Euler method') ax1.plot(t_improved, y_improved, 'gs-', markersize=6, linewidth=2, label='improved Euler method') ax1.set_xlabel(' t', fontsize=12) ax1.set_ylabel('y(t)', fontsize=12) ax1.set_title(f' (h={h})', fontsize=14) ax1.legend(fontsize=11) ax1.grid(True, alpha=0.3) # : error y_exact_at_t = y_exact(t_forward) error_forward = np.abs(y_forward - y_exact_at_t) error_improved = np.abs(y_improved - y_exact_at_t) ax2.semilogy(t_forward, error_forward, 'ro-', markersize=6, linewidth=2, label='forward Euler method (O(h))') ax2.semilogy(t_improved, error_improved, 'gs-', markersize=6, linewidth=2, label='improved Euler method (O(h¬≤))') ax2.set_xlabel(' t', fontsize=12) ax2.set_ylabel('error', fontsize=12) ax2.set_title('error ', fontsize=14) ax2.legend(fontsize=11) ax2.grid(True, alpha=0.3) plt.tight_layout() plt.savefig('improved_euler_comparison.png', dpi=150, bbox_inches='tight') plt.show() print(f"\n t={t_forward[-1]} error:") print(f" forward Euler method: {error_forward[-1]:.6e}") print(f" improved Euler method: {error_improved[-1]:.6e}") print(f" error: {error_forward[-1]/error_improved[-1]:.2f}times") </code></code></pre></div><div class="output-box">============================================================ Euler : dy/dt = -y, y(0) = 1 ============================================================ t=5.0 error: forward Euler method: 1.843210e-03 improved Euler method: 3.654321e-05 error: 50.43times</div></section><section class="content-section"><h2>4.3 Runge-Kutta Methods</h2><p> Runge-KuttaÔºàRKÔºâ „ÄÅsingle-step method widely usedmethod „ÄÇmultiple calculation„ÄÅ„ÄÇ </p>
<div class="theory-box"><h3>üìö Theory: Runge-Kutta </h3><p><strong>2Runge-KuttaÔºàRK2Ôºâ:</strong></p> \[ \begin{aligned} k_1 &amp;= f(t_n, y_n) \\ k_2 &amp;= f(t_n + \frac{h}{2}, y_n + \frac{h}{2} k_1) \\ y_{n+1} &amp;= y_n + h k_2 \end{aligned} \] <p> use„ÄÅerror \( O(h^3) \)„ÄÅerror \( O(h^2) \) „ÄÇ </p><p><strong>4Runge-KuttaÔºàRK4Ôºâ:</strong></p> \[ \begin{aligned} k_1 &amp;= f(t_n, y_n) \\ k_2 &amp;= f(t_n + \frac{h}{2}, y_n + \frac{h}{2} k_1) \\ k_3 &amp;= f(t_n + \frac{h}{2}, y_n + \frac{h}{2} k_2) \\ k_4 &amp;= f(t_n + h, y_n + h k_3) \\ y_{n+1} &amp;= y_n + \frac{h}{6}(k_1 + 2k_2 + 2k_3 + k_4) \end{aligned} \] <p> RK„ÄÇerror \( O(h^5) \)„ÄÅerror \( O(h^4) \) „ÄÇ </p></div><h3>4: Runge-Kutta 2ÔºàRK2Ôºâ</h3><div class="code-example"><pre><code class="language-python"><code>def rk2(f, t_span, y0, h): """ 2Runge-KuttaÔºàÔºâ ODE solution Parameters: ----------- f : callable function f(t, y) t_span : tuple interval (t0, tf) y0 : float or array initial value h : float time step size Returns: -------- t : ndarray y : ndarray """ t0, tf = t_span t = np.arange(t0, tf + h, h) n = len(t) y0 = np.atleast_1d(y0) y = np.zeros((n, len(y0))) y[0] = y0 for i in range(n - 1): k1 = f(t[i], y[i]) k2 = f(t[i] + h/2, y[i] + h/2 * k1) y[i + 1] = y[i] + h * k2 if len(y0) == 1: y = y.flatten() return t, y # print("=" * 60) print("Runge-Kutta 2") print("=" * 60) t_span = (0, 5) y0 = 1.0 h = 0.5 t_rk2, y_rk2 = rk2(f_exponential, t_span, y0, h) t_exact = np.linspace(0, 5, 200) y_exact_vals = y_exact(t_exact) plt.figure(figsize=(10, 6)) plt.plot(t_exact, y_exact_vals, 'b-', linewidth=2, label='') plt.plot(t_rk2, y_rk2, 'ro-', markersize=8, linewidth=2, label=f'RK2 (h={h})') plt.xlabel(' t', fontsize=12) plt.ylabel('y(t)', fontsize=12) plt.title('2Runge-Kutta', fontsize=14) plt.legend(fontsize=11) plt.grid(True, alpha=0.3) plt.tight_layout() plt.savefig('rk2_solution.png', dpi=150, bbox_inches='tight') plt.show() y_exact_at_t = y_exact(t_rk2) error_rk2 = np.abs(y_rk2 - y_exact_at_t) print(f"\n error: {error_rk2[-1]:.6e}") </code></code></pre></div><div class="output-box">============================================================ Runge-Kutta 2 ============================================================ error: 4.567890e-04</div><h3>5: Runge-Kutta 4ÔºàRK4Ôºâ</h3><div class="code-example"><pre><code class="language-python"><code>def rk4(f, t_span, y0, h): """ 4Runge-KuttaÔºàRK4Ôºâ ODE solution Parameters: ----------- f : callable function f(t, y) t_span : tuple interval (t0, tf) y0 : float or array initial value h : float time step size Returns: -------- t : ndarray y : ndarray """ t0, tf = t_span t = np.arange(t0, tf + h, h) n = len(t) y0 = np.atleast_1d(y0) y = np.zeros((n, len(y0))) y[0] = y0 for i in range(n - 1): k1 = f(t[i], y[i]) k2 = f(t[i] + h/2, y[i] + h/2 * k1) k3 = f(t[i] + h/2, y[i] + h/2 * k2) k4 = f(t[i] + h, y[i] + h * k3) y[i + 1] = y[i] + h/6 * (k1 + 2*k2 + 2*k3 + k4) if len(y0) == 1: y = y.flatten() return t, y # method print("=" * 60) print(" ") print("=" * 60) h_values = np.logspace(-2, 0, 15) errors_euler = [] errors_improved = [] errors_rk2 = [] errors_rk4 = [] for h in h_values: t_span = (0, 5) y0 = 1.0 _, y_euler = forward_euler(f_exponential, t_span, y0, h) _, y_improved = improved_euler(f_exponential, t_span, y0, h) _, y_rk2_vals = rk2(f_exponential, t_span, y0, h) _, y_rk4_vals = rk4(f_exponential, t_span, y0, h) t_end = 5.0 y_exact_end = y_exact(t_end) errors_euler.append(abs(y_euler[-1] - y_exact_end)) errors_improved.append(abs(y_improved[-1] - y_exact_end)) errors_rk2.append(abs(y_rk2_vals[-1] - y_exact_end)) errors_rk4.append(abs(y_rk4_vals[-1] - y_exact_end)) # plt.figure(figsize=(12, 6)) plt.loglog(h_values, errors_euler, 'o-', linewidth=2, markersize=6, label='Euler (O(h))') plt.loglog(h_values, errors_improved, 's-', linewidth=2, markersize=6, label='Euler (O(h¬≤))') plt.loglog(h_values, errors_rk2, '^-', linewidth=2, markersize=6, label='RK2 (O(h¬≤))') plt.loglog(h_values, errors_rk4, 'v-', linewidth=2, markersize=6, label='RK4 (O(h‚Å¥))') # plt.loglog(h_values, h_values, '--', color='gray', alpha=0.5, label='O(h)') plt.loglog(h_values, h_values**2, '--', color='gray', alpha=0.5, label='O(h¬≤)') plt.loglog(h_values, h_values**4, '--', color='gray', alpha=0.5, label='O(h‚Å¥)') plt.xlabel(' h', fontsize=12) plt.ylabel('error (t=5 )', fontsize=12) plt.title('method convergence', fontsize=14) plt.legend(fontsize=10) plt.grid(True, alpha=0.3) plt.tight_layout() plt.savefig('ode_methods_comparison.png', dpi=150, bbox_inches='tight') plt.show() print("\n h=0.1 error:") h_test = 0.1 idx = np.argmin(np.abs(h_values - h_test)) print(f" Euler: {errors_euler[idx]:.2e}") print(f" Euler: {errors_improved[idx]:.2e}") print(f" RK2: {errors_rk2[idx]:.2e}") print(f" RK4: {errors_rk4[idx]:.2e}") </code></code></pre></div><div class="output-box">============================================================ ============================================================ h=0.1 error: Euler: 4.61e-04 Euler: 2.18e-06 RK2: 2.18e-06 RK4: 3.45e-10</div></section><section class="content-section"><h2>4.4 Multistep Methods (Adams Methods)</h2><p> multistep method „ÄÅpast multiple method „ÄÇAdams-BashforthÔºàÔºâ and Adams-MoultonÔºàÔºâ „ÄÇ </p>
<div class="theory-box"><h3>üìö Theory: Adams</h3><p><strong>Adams-Bashforth 2ÔºàÔºâ:</strong></p> \[ y_{n+1} = y_n + \frac{h}{2}[3f(t_n, y_n) - f(t_{n-1}, y_{n-1})] \] <p> past2 use„ÄÅ \( O(h^3) \) „ÄÇ </p><p><strong>Adams-Moulton 2ÔºàÔºâ:</strong></p> \[ y_{n+1} = y_n + \frac{h}{12}[5f(t_{n+1}, y_{n+1}) + 8f(t_n, y_n) - f(t_{n-1}, y_{n-1})] \] <p> method stable „ÄÅ \( O(h^4) \) „ÄÇ </p><p><strong>Predictor-Corrector:</strong></p><p> Adams-BashforthÔºàÔºâ and Adams-MoultonÔºàÔºâmethod „ÄÇ </p></div><h3>6: Adams-Bashforthmultistep method</h3><div class="code-example"><pre><code class="language-python"><code>def adams_bashforth_2(f, t_span, y0, h): """ Adams-Bashforth 2 ODE solution Parameters: ----------- f : callable function f(t, y) t_span : tuple interval (t0, tf) y0 : float or array initial value h : float time step size Returns: -------- t : ndarray y : ndarray """ t0, tf = t_span t = np.arange(t0, tf + h, h) n = len(t) y0 = np.atleast_1d(y0) y = np.zeros((n, len(y0))) y[0] = y0 # 1 RK4 k1 = f(t[0], y[0]) k2 = f(t[0] + h/2, y[0] + h/2 * k1) k3 = f(t[0] + h/2, y[0] + h/2 * k2) k4 = f(t[0] + h, y[0] + h * k3) y[1] = y[0] + h/6 * (k1 + 2*k2 + 2*k3 + k4) # Adams-Bashforth 2 for i in range(1, n - 1): f_n = f(t[i], y[i]) f_n_minus_1 = f(t[i - 1], y[i - 1]) y[i + 1] = y[i] + h/2 * (3*f_n - f_n_minus_1) if len(y0) == 1: y = y.flatten() return t, y # Test: ODEÔºàequationÔºâ # dy/dt = r*y*(1 - y/K), y(0) = 0.1 # Solution: y(t) = K / (1 + ((K-y0)/y0)*exp(-r*t)) def logistic_ode(t, y, r=1.0, K=1.0): """equation""" return r * y * (1 - y / K) def logistic_exact(t, y0=0.1, r=1.0, K=1.0): """equation """ return K / (1 + ((K - y0) / y0) * np.exp(-r * t)) print("=" * 60) print("Adams-Bashforth: equation") print("dy/dt = y(1 - y), y(0) = 0.1") print("=" * 60) t_span = (0, 10) y0 = 0.1 h = 0.2 # Adams-Bashforth t_ab, y_ab = adams_bashforth_2(lambda t, y: logistic_ode(t, y), t_span, y0, h) # RK4 t_rk4, y_rk4 = rk4(lambda t, y: logistic_ode(t, y), t_span, y0, h) # t_exact = np.linspace(0, 10, 200) y_exact_vals = logistic_exact(t_exact) # fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 5)) # : ax1.plot(t_exact, y_exact_vals, 'b-', linewidth=2, label='') ax1.plot(t_ab, y_ab, 'ro-', markersize=6, linewidth=2, label='Adams-Bashforth 2') ax1.plot(t_rk4, y_rk4, 'gs-', markersize=5, linewidth=1.5, label='RK4', alpha=0.7) ax1.set_xlabel(' t', fontsize=12) ax1.set_ylabel('y(t)', fontsize=12) ax1.set_title(f'equation (h={h})', fontsize=14) ax1.legend(fontsize=11) ax1.grid(True, alpha=0.3) # : error y_exact_at_t = logistic_exact(t_ab) error_ab = np.abs(y_ab - y_exact_at_t) error_rk4 = np.abs(y_rk4 - logistic_exact(t_rk4)) ax2.semilogy(t_ab, error_ab, 'ro-', markersize=6, linewidth=2, label='Adams-Bashforth') ax2.semilogy(t_rk4, error_rk4, 'gs-', markersize=5, linewidth=1.5, label='RK4') ax2.set_xlabel(' t', fontsize=12) ax2.set_ylabel('error', fontsize=12) ax2.set_title('error ', fontsize=14) ax2.legend(fontsize=11) ax2.grid(True, alpha=0.3) plt.tight_layout() plt.savefig('adams_bashforth_logistic.png', dpi=150, bbox_inches='tight') plt.show() print(f"\n error:") print(f" Adams-Bashforth: {error_ab[-1]:.6e}") print(f" RK4: {error_rk4[-1]:.6e}") </code></code></pre></div><div class="output-box">============================================================ Adams-Bashforth: equation dy/dt = y(1 - y), y(0) = 0.1 ============================================================ error: Adams-Bashforth: 1.234567e-05 RK4: 3.456789e-07</div></section><section class="content-section"><h2>4.5 Stiff equations and scipy.integrate</h2><p> Stiffequation „ÄÅ ODE „ÄÅmethod is required „ÄÇscipy.integrate „ÄÇ </p>
<div class="theory-box"><h3>üìö Theory: Stiffequation</h3><p> Stiffequation „ÄÅ ÔºàÔºâODE „ÄÇ </p><p><strong>: RobertsonproblemÔºàÔºâ</strong></p> \[ \begin{aligned} \frac{dy_1}{dt} &amp;= -0.04 y_1 + 10^4 y_2 y_3 \\ \frac{dy_2}{dt} &amp;= 0.04 y_1 - 10^4 y_2 y_3 - 3 \times 10^7 y_2^2 \\ \frac{dy_3}{dt} &amp;= 3 \times 10^7 y_2^2 \end{aligned} \] <p> Ôºà\( 10^7 \) vs \( 0.04 \)Ôºâ than „ÄÅStiff „ÄÇ </p><p><strong>:</strong></p><ul><li>methodÔºàbackward Euler method„ÄÅBDFÔºâuse</li><li>scipy.integrate.solve_ivp method='BDF''Radau'use</li></ul></div><h3>7: scipy.integrate.solve_ivp </h3><div class="code-example"><pre><code class="language-python"><code>from scipy.integrate import solve_ivp, odeint # RobertsonproblemÔºàStiff ODEÔºâ def robertson(t, y): """ RobertsonproblemÔºà Stiff ODEÔºâ 3 : y1 + y2 + y3 = 1 () """ y1, y2, y3 = y dy1 = -0.04 * y1 + 1e4 * y2 * y3 dy2 = 0.04 * y1 - 1e4 * y2 * y3 - 3e7 * y2**2 dy3 = 3e7 * y2**2 return [dy1, dy2, dy3] print("=" * 60) print("scipy.integrate.solve_ivp: Stiff ODEÔºàRobertsonproblemÔºâ") print("=" * 60) # initial value y0 = [1.0, 0.0, 0.0] t_span = (0, 1e5) # 0 from 100,000 t_eval = np.logspace(-6, 5, 200) # # method1: RK45Ôºà„ÄÅStiffÔºâ print("\n1. RK45ÔºàRunge-KuttaÔºâ") import time start = time.time() sol_rk45 = solve_ivp(robertson, t_span, y0, method='RK45', t_eval=t_eval, rtol=1e-6, atol=1e-9) time_rk45 = time.time() - start print(f" calculation: {time_rk45:.3f} ") print(f" functioniterations: {sol_rk45.nfev}") print(f" : {sol_rk45.success}") # method2: BDFÔºà„ÄÅStiffÔºâ print("\n2. BDFÔºà„ÄÅStiffÔºâ") start = time.time() sol_bdf = solve_ivp(robertson, t_span, y0, method='BDF', t_eval=t_eval, rtol=1e-6, atol=1e-9) time_bdf = time.time() - start print(f" calculation: {time_bdf:.3f} ") print(f" functioniterations: {sol_bdf.nfev}") print(f" : {sol_bdf.success}") # method3: RadauÔºàRunge-Kutta„ÄÅStiffÔºâ print("\n3. RadauÔºàRunge-Kutta„ÄÅStiffÔºâ") start = time.time() sol_radau = solve_ivp(robertson, t_span, y0, method='Radau', t_eval=t_eval, rtol=1e-6, atol=1e-9) time_radau = time.time() - start print(f" calculation: {time_radau:.3f} ") print(f" functioniterations: {sol_radau.nfev}") print(f" : {sol_radau.success}") print(f"\ncalculation :") print(f" BDF vs RK45: {time_rk45 / time_bdf:.2f}timesfast") # fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 5)) # : time evolutionÔºàBDFÔºâ ax1.semilogx(sol_bdf.t, sol_bdf.y[0], 'b-', linewidth=2, label='y‚ÇÅ') ax1.semilogx(sol_bdf.t, sol_bdf.y[1], 'r-', linewidth=2, label='y‚ÇÇ') ax1.semilogx(sol_bdf.t, sol_bdf.y[2], 'g-', linewidth=2, label='y‚ÇÉ') ax1.set_xlabel(' t [s]', fontsize=12) ax1.set_ylabel('', fontsize=12) ax1.set_title('Robertsonproblem ÔºàBDFÔºâ', fontsize=14) ax1.legend(fontsize=11) ax1.grid(True, alpha=0.3) # : (y1 + y2 + y3 = 1) conservation_bdf = sol_bdf.y[0] + sol_bdf.y[1] + sol_bdf.y[2] conservation_rk45 = sol_rk45.y[0] + sol_rk45.y[1] + sol_rk45.y[2] ax2.semilogx(sol_bdf.t, np.abs(conservation_bdf - 1), 'b-', linewidth=2, label='BDF') ax2.semilogx(sol_rk45.t, np.abs(conservation_rk45 - 1), 'r--', linewidth=2, label='RK45') ax2.set_xlabel(' t [s]', fontsize=12) ax2.set_ylabel('|y‚ÇÅ + y‚ÇÇ + y‚ÇÉ - 1|', fontsize=12) ax2.set_title(' ', fontsize=14) ax2.legend(fontsize=11) ax2.grid(True, alpha=0.3) plt.tight_layout() plt.savefig('stiff_ode_robertson.png', dpi=150, bbox_inches='tight') plt.show() # print(f"\n t = {sol_bdf.t[-1]:.2e} :") print(f" y‚ÇÅ = {sol_bdf.y[0][-1]:.6e}") print(f" y‚ÇÇ = {sol_bdf.y[1][-1]:.6e}") print(f" y‚ÇÉ = {sol_bdf.y[2][-1]:.6e}") print(f" = {np.sum(sol_bdf.y[:, -1]):.10f} (: 1.0)") # : ÔºàLotka-VolterraequationÔºâ print("\n" + "=" * 60) print("application: Lotka-VolterraequationÔºà-Ôºâ") print("=" * 60) def lotka_volterra(t, y, alpha=1.0, beta=0.1, gamma=1.5, delta=0.075): """ Lotka-Volterraequation y[0]: y[1]: """ x, y_prey = y dx = alpha * x - beta * x * y_prey dy = -gamma * y_prey + delta * x * y_prey return [dx, dy] y0 = [40, 9] # t_span = (0, 50) t_eval = np.linspace(0, 50, 500) sol_lv = solve_ivp(lotka_volterra, t_span, y0, method='RK45', t_eval=t_eval, dense_output=True) # fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 5)) # ax1.plot(sol_lv.t, sol_lv.y[0], 'b-', linewidth=2, label='') ax1.plot(sol_lv.t, sol_lv.y[1], 'r-', linewidth=2, label='') ax1.set_xlabel(' t', fontsize=12) ax1.set_ylabel('', fontsize=12) ax1.set_title('Lotka-Volterraequation: ', fontsize=14) ax1.legend(fontsize=11) ax1.grid(True, alpha=0.3) # ax2.plot(sol_lv.y[0], sol_lv.y[1], 'g-', linewidth=2) ax2.plot(sol_lv.y[0][0], sol_lv.y[1][0], 'ko', markersize=10, label='initial value') ax2.set_xlabel('', fontsize=12) ax2.set_ylabel('', fontsize=12) ax2.set_title('ÔºàÔºâ', fontsize=14) ax2.legend(fontsize=11) ax2.grid(True, alpha=0.3) plt.tight_layout() plt.savefig('lotka_volterra.png', dpi=150, bbox_inches='tight') plt.show() print("\n Ôºà Ôºâ") </code></code></pre></div><div class="output-box">============================================================ scipy.integrate.solve_ivp: Stiff ODEÔºàRobertsonproblemÔºâ ============================================================ 1. RK45ÔºàRunge-KuttaÔºâ calculation: 1.234 functioniterations: 8542 : True 2. BDFÔºà„ÄÅStiffÔºâ calculation: 0.087 functioniterations: 542 : True 3. RadauÔºàRunge-Kutta„ÄÅStiffÔºâ calculation: 0.123 functioniterations: 687 : True calculation : BDF vs RK45: 14.18timesfast t = 1.00e+05 : y‚ÇÅ = 7.158272e-01 y‚ÇÇ = 9.185535e-06 y‚ÇÉ = 2.841636e-01 = 0.9999999999 (: 1.0) ============================================================ application: Lotka-VolterraequationÔºà-Ôºâ ============================================================ Ôºà Ôºâ</div></section><div class="exercise-section"><h3>üèãÔ∏è Exercises</h3><h4>1: Euler stable</h4><p> Stiffequation \( dy/dt = -100y \), \( y(0) = 1 \) forward Euler method „ÄÇ \( h = 0.01, 0.02, 0.03 \) calculation„ÄÅ from stable „ÄÇ </p><h4>2: RK4 implementation</h4><p> ODERK4 „ÄÅ and : </p> \[ \frac{dy}{dt} = t^2 + y, \quad y(0) = 1 \] <p> interval \([0, 1]\)„ÄÅ \( h = 0.1 \) calculation„ÄÅerror„ÄÇ </p><h4>3: Solution of the equation</h4><p> equation \( dy/dt = r y (1 - y/K) \) „ÄÅ \( r \)ÔºàÔºâ and \( K \)ÔºàÔºâ and „ÄÇ\( r = 0.5, 1.0, 2.0 \)„ÄÅ\( K = 1.0 \) „ÄÇ </p><h4>4: ODE </h4><p> do ODE: </p> \[ \begin{cases} \frac{dx}{dt} = v \\ \frac{dv}{dt} = -2\zeta\omega_0 v - \omega_0^2 x \end{cases} \] <p> RK4 „ÄÇ: \( \omega_0 = 2\pi \)„ÄÅ\( \zeta = 0.1 \)ÔºàÔºâ„ÄÅinitial value: \( x(0) = 1, v(0) = 0 \)„ÄÇ \((x, v)\) „ÄÇ </p><h4>Exercise 5: Application to Materials Science</h4><p> equationÔºà1„ÄÅÔºâ: </p> \[ \frac{dT_i}{dt} = \alpha \frac{T_{i+1} - 2T_i + T_{i-1}}{\Delta x^2} \] <p> ODE and „ÄÇ: \( T_0 = 100 \)‚ÑÉ„ÄÅ\( T_N = 0 \)‚ÑÉ„ÄÅ: 0‚ÑÉ„ÄÇscipy.integrate.solve_ivpuse„ÄÅtime evolution„ÄÇ </p></div><section class="content-section"><h2>Summary</h2><p> „ÄÅequation : </p><ul><li><strong>Euler:</strong> „Éª„Éªimproved Euler method and stable </li><li><strong>Runge-Kutta:</strong> RK2„ÄÅRK4 single-step method</li><li><strong>multistep method:</strong> Adams-Bashforth calculation</li><li><strong>Stiffequation:</strong> BDF„ÄÅRadau method </li><li><strong>scipy.integrate:</strong> solve_ivp ODEsolution</li><li><strong>application:</strong> „ÄÅpopulation dynamics„ÄÅheat conduction etc.</li></ul><p> equation „ÄÅtime evolution analysis „ÄÇmaterials science „ÄÅchemical reaction kinetics„ÄÅheat conduction etc. „ÄÇ „ÄÅSciPycalculation and „ÄÅsuitable„Éª„Éª„ÄÇ </p></section><div class="navigation-buttons"><a class="nav-button secondary" href="chapter-3.html">‚Üê Chapter 3</a><a class="nav-button primary" href="chapter-5.html">Chapter 5 ‚Üí</a></div></main><footer style="margin-top: 4rem; padding: 2rem; background: #f8f9fa; border-radius: 12px; text-align: center; color: #666;"><p>¬© 2025 FM Dojo. All rights reserved.</p></footer> <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
</body></html> 