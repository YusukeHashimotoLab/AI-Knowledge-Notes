<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Chapter 3: Grand Canonical Ensemble and Chemical Potential | Fundamental Mathematics Dojo - Introduction to Classical Statistical Mechanics</title>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\(', '\)']],
                displayMath: [['$$', '$$'], ['\[', '\]']],
                processEscapes: true
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
            }
        };
    </script>
<script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<link href="../../assets/css/knowledge-base.css" rel="stylesheet"/>
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet"/>
</head>
<body><div class="locale-switcher">
<span class="current-locale">üåê EN</span>
<span class="locale-separator">|</span>
<a class="locale-link" href="../../../jp/FM/classical-statistical-mechanics/chapter-3.html">Êó•Êú¨Ë™û</a>
<span class="locale-meta">Last sync: 2025-11-16</span>
</div>

<header>
<h1>Chapter 3: Grand Canonical Ensemble and Chemical Potential</h1>
</header>
<div class="container">
<div class="breadcrumb">
<a href="../index.html">Fundamental Mathematics Dojo</a> &gt;
            <a href="index.html">Introduction to Classical Statistical Mechanics</a> &gt;
            Chapter 3
        </div>
<div class="content">
<h2>üéØ Learning Objectives</h2>
<ul>
<li>Understand the concept of the grand canonical ensemble and situations where it applies</li>
<li>Learn the relationship between the grand partition function and chemical potential</li>
<li>Master methods for calculating particle number fluctuations</li>
<li>Derive the Langmuir adsorption isotherm and learn applications to materials</li>
<li>Understand the correspondence between the lattice gas model and Ising model</li>
<li>Learn the fundamentals of quantum statistics (Fermi-Dirac distribution, Bose-Einstein distribution)</li>
<li>Understand applications to chemical reaction equilibrium</li>
<li>Simulate adsorption phenomena in materials science</li>
</ul>
</div>
<div class="content">
<h2>üìñ What is the Grand Canonical Ensemble</h2>
<div class="definition">
<h3>Grand Canonical Ensemble</h3>
<p>A system with fixed temperature \(T\) and chemical potential \(\mu\) that can exchange particles and energy with a particle reservoir.</p>
<ul>
<li>Volume \(V\), temperature \(T\), and chemical potential \(\mu\) are fixed</li>
<li>Particle number \(N\) and energy \(E\) fluctuate</li>
<li>Important for adsorption, chemical reactions, and open systems</li>
</ul>
<p><strong>Grand partition function</strong>:</p>
<p>\[
                \Xi(\mu, V, T) = \sum_{N=0}^\infty \sum_i e^{\beta(\mu N - E_i)} = \sum_{N=0}^\infty e^{\beta\mu N} Z(N, V, T)
                \]</p>
<p>where \(\beta = 1/(k_B T)\) and \(Z(N, V, T)\) is the canonical partition function.</p>
</div>
<div class="definition">
<h3>Grand Potential and Chemical Potential</h3>
<p>Grand potential:</p>
<p>\[
                \Omega = -k_B T \ln \Xi = F - \mu N
                \]</p>
<p>Derivation of thermodynamic quantities:</p>
<ul>
<li>Average particle number: \(\langle N \rangle = -\frac{\partial \Omega}{\partial \mu} = \frac{1}{\beta}\frac{\partial \ln \Xi}{\partial \mu}\)</li>
<li>Pressure: \(P = -\frac{\partial \Omega}{\partial V}\)</li>
<li>Particle number fluctuation: \(\langle (\Delta N)^2 \rangle = k_B T \left(\frac{\partial \langle N \rangle}{\partial \mu}\right)_{V,T}\)</li>
</ul>
<p>The <strong>chemical potential</strong> \(\mu\) is "the free energy required to add one particle".</p>
</div>
</div>
<div class="content">
<h2>üíª Example 3.1: Grand Partition Function of an Ideal Gas</h2>
<div class="definition">
<h3>Grand Canonical Calculation for an Ideal Gas</h3>
<p>Using the single-particle partition function \(z_1 = V/\lambda_T^3\) (where \(\lambda_T\) is the thermal de Broglie wavelength):</p>
<p>\[
                \Xi = \sum_{N=0}^\infty \frac{(z_1 e^{\beta\mu})^N}{N!} = \exp(z_1 e^{\beta\mu})
                \]</p>
<p>Average particle number:</p>
<p>\[
                \langle N \rangle = z_1 e^{\beta\mu}
                \]</p>
<p>Solving for the chemical potential:</p>
<p>\[
                \mu = k_B T \ln\left(\frac{\langle N \rangle \lambda_T^3}{V}\right)
                \]</p>
</div>
<div class="code-title">Python Implementation: Chemical Potential of an Ideal Gas</div>
<div class="code-example"><pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt

k_B = 1.380649e-23  # J/K
h = 6.62607015e-34  # J¬∑s
m_Ar = 6.63e-26  # Mass of Ar atom (kg)

def thermal_wavelength(T, m, h, k_B):
    """Thermal de Broglie wavelength"""
    return h / np.sqrt(2 * np.pi * m * k_B * T)

def chemical_potential_ideal_gas(N, V, T, m, h, k_B):
    """Chemical potential of ideal gas"""
    lambda_T = thermal_wavelength(T, m, h, k_B)
    return k_B * T * np.log((N / V) * lambda_T**3)

def fugacity(mu, T, k_B):
    """Fugacity z = exp(Œ≤Œº)"""
    return np.exp(mu / (k_B * T))

# Ar gas near standard conditions
N_A = 6.022e23
N_molar = N_A
V_molar = 0.0224  # m¬≥

T_range = np.linspace(100, 1000, 100)

# Density dependence (fixed temperature)
T_fixed = 300  # K
V_range = np.linspace(0.001, 0.1, 100)  # m¬≥
n_range = N_molar / V_range  # Number density

mu_vs_V = [chemical_potential_ideal_gas(N_molar, V, T_fixed, m_Ar, h, k_B)
           for V in V_range]

# Temperature dependence (fixed volume)
mu_vs_T = [chemical_potential_ideal_gas(N_molar, V_molar, T, m_Ar, h, k_B)
           for T in T_range]

# Visualization
fig, axes = plt.subplots(2, 2, figsize=(14, 10))

# Chemical potential density dependence
ax1 = axes[0, 0]
ax1.plot(n_range / 1e25, np.array(mu_vs_V) / (k_B * T_fixed), 'b-', linewidth=2)
ax1.set_xlabel('Number density (10¬≤‚Åµ m‚Åª¬≥)')
ax1.set_ylabel('Œº / (k_B T)')
ax1.set_title(f'Chemical Potential Density Dependence (T = {T_fixed} K)')
ax1.grid(True, alpha=0.3)

# Chemical potential temperature dependence
ax2 = axes[0, 1]
ax2.plot(T_range, np.array(mu_vs_T) / 1e-21, 'r-', linewidth=2)
ax2.set_xlabel('Temperature (K)')
ax2.set_ylabel('Œº (10‚Åª¬≤¬π J)')
ax2.set_title('Chemical Potential Temperature Dependence (V = 22.4 L)')
ax2.grid(True, alpha=0.3)

# Fugacity
ax3 = axes[1, 0]
z_vals = [fugacity(mu, T_fixed, k_B) for mu in mu_vs_V]
ax3.semilogy(n_range / 1e25, z_vals, 'g-', linewidth=2)
ax3.set_xlabel('Number density (10¬≤‚Åµ m‚Åª¬≥)')
ax3.set_ylabel('Fugacity z = exp(Œ≤Œº)')
ax3.set_title(f'Fugacity (T = {T_fixed} K)')
ax3.grid(True, alpha=0.3, which='both')

# Particle number fluctuation
ax4 = axes[1, 1]
# &lt;(ŒîN)¬≤&gt; = k_B T (‚àÇ<n>/‚àÇŒº) = <n> (ideal gas)
fluctuation_ratio = 1 / np.sqrt(n_range * V_molar)  # œÉ_N / <n> = 1/‚àö<n>
ax4.loglog(n_range / 1e25, fluctuation_ratio, 'm-', linewidth=2)
ax4.set_xlabel('Number density (10¬≤‚Åµ m‚Åª¬≥)')
ax4.set_ylabel('œÉ_N / <n>')
ax4.set_title('Relative Fluctuation')
ax4.grid(True, alpha=0.3, which='both')

plt.tight_layout()
plt.savefig('stat_mech_grand_canonical_ideal_gas.png', dpi=300, bbox_inches='tight')
plt.show()

# Numerical results
print("=== Grand Canonical Statistics of Ideal Gas ===\n")
print(f"Ar gas (1 mol, near standard conditions)\n")

T_std = 298.15  # K
V_std = V_molar
mu_std = chemical_potential_ideal_gas(N_molar, V_std, T_std, m_Ar, h, k_B)
lambda_T_std = thermal_wavelength(T_std, m_Ar, h, k_B)

print(f"T = {T_std} K, V = {V_std*1000:.1f} L")
print(f"Thermal de Broglie wavelength: Œª_T = {lambda_T_std*1e9:.4f} nm")
print(f"Chemical potential: Œº = {mu_std:.6e} J")
print(f"                  Œº/(k_B T) = {mu_std/(k_B*T_std):.4f}")
print(f"Fugacity: z = {fugacity(mu_std, T_std, k_B):.6e}")
print(f"\nRelative fluctuation: œÉ_N/<n> = 1/‚àö<n> = {1/np.sqrt(N_molar):.6e}")
print(f"            = {1/np.sqrt(N_molar):.2e} (extremely small)")
</n></n></n></n></n></n></n></code></pre></div>
</div>
<div class="content">
<h2>üíª Example 3.2: Langmuir Adsorption Isotherm</h2>
<div class="definition">
<h3>Langmuir Adsorption Model</h3>
<p>There are \(M\) adsorption sites, each able to adsorb at most one particle:</p>
<p>Grand partition function (per site):</p>
<p>\[
                \xi = 1 + e^{\beta(\mu - \varepsilon)}
                \]</p>
<p>where \(\varepsilon\) is the adsorption energy (negative value).</p>
<p>Coverage \(\theta\):</p>
<p>\[
                \theta = \frac{\langle N \rangle}{M} = \frac{e^{\beta(\mu - \varepsilon)}}{1 + e^{\beta(\mu - \varepsilon)}} = \frac{1}{1 + e^{-\beta(\mu - \varepsilon)}}
                \]</p>
<p>Relationship with gas phase pressure \(P\) (where \(\mu = k_B T \ln(P/P_0)\)):</p>
<p>\[
                \theta = \frac{KP}{1 + KP}, \quad K = e^{-\beta\varepsilon} / P_0
                \]</p>
<p>This is the <strong>Langmuir adsorption isotherm</strong>.</p>
</div>
<div class="code-title">Python Implementation: Langmuir Adsorption Isotherm</div>
<div class="code-example"><pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt

k_B = 1.380649e-23  # J/K

def langmuir_coverage(P, K):
    """Langmuir adsorption isotherm"""
    return K * P / (1 + K * P)

def freundlich_isotherm(P, k_F, n):
    """Freundlich adsorption isotherm (empirical formula, multilayer adsorption)"""
    return k_F * P**(1/n)

def bet_isotherm(P, P0, c):
    """BET adsorption isotherm (multilayer adsorption)"""
    x = P / P0
    return (c * x) / ((1 - x) * (1 + (c - 1) * x))

# Different adsorption energies
T = 300  # K
epsilon_values = [-0.1, -0.3, -0.5, -0.8]  # eV
epsilon_J = [eps * 1.602e-19 for eps in epsilon_values]  # J
P0 = 1e5  # Pa (standard pressure)

K_values = [np.exp(-eps / (k_B * T)) / P0 for eps in epsilon_J]

P_range = np.logspace(-2, 6, 200)  # Pa

fig, axes = plt.subplots(2, 2, figsize=(14, 10))

# Langmuir isotherm (linear plot)
ax1 = axes[0, 0]
colors = ['blue', 'green', 'orange', 'red']
for epsilon, K, color in zip(epsilon_values, K_values, colors):
    theta = langmuir_coverage(P_range, K)
    ax1.plot(P_range / 1e3, theta, color=color, linewidth=2,
             label=f'Œµ = {epsilon} eV')

ax1.set_xlabel('Pressure (kPa)')
ax1.set_ylabel('Coverage Œ∏')
ax1.set_title('Langmuir Adsorption Isotherm')
ax1.legend()
ax1.grid(True, alpha=0.3)
ax1.set_xlim([0, 100])

# Langmuir isotherm (log plot)
ax2 = axes[0, 1]
for epsilon, K, color in zip(epsilon_values, K_values, colors):
    theta = langmuir_coverage(P_range, K)
    ax2.semilogx(P_range, theta, color=color, linewidth=2,
                 label=f'Œµ = {epsilon} eV')

ax2.set_xlabel('Pressure (Pa)')
ax2.set_ylabel('Coverage Œ∏')
ax2.set_title('Langmuir Isotherm (Log Scale)')
ax2.legend()
ax2.grid(True, alpha=0.3)

# Langmuir plot (P/Œ∏ vs P)
ax3 = axes[1, 0]
K_demo = K_values[2]
theta_demo = langmuir_coverage(P_range, K_demo)
# P/Œ∏ = 1/K + P (becomes linear)
P_over_theta = P_range / theta_demo

ax3.plot(P_range / 1e3, P_over_theta / 1e3, 'b-', linewidth=2)
ax3.set_xlabel('Pressure (kPa)')
ax3.set_ylabel('P/Œ∏ (kPa)')
ax3.set_title('Langmuir Plot (Linearity Check)')
ax3.grid(True, alpha=0.3)
ax3.set_xlim([0, 100])

# Temperature dependence
ax4 = axes[1, 1]
temperatures = [250, 300, 350, 400]
epsilon_fixed = epsilon_J[2]
P_fixed_range = np.logspace(2, 5, 100)

for T_val, color in zip(temperatures, colors):
    K_T = np.exp(-epsilon_fixed / (k_B * T_val)) / P0
    theta_T = langmuir_coverage(P_fixed_range, K_T)
    ax4.semilogx(P_fixed_range, theta_T, color=color, linewidth=2,
                 label=f'T = {T_val} K')

ax4.set_xlabel('Pressure (Pa)')
ax4.set_ylabel('Coverage Œ∏')
ax4.set_title(f'Temperature Dependence (Œµ = {epsilon_values[2]} eV)')
ax4.legend()
ax4.grid(True, alpha=0.3)

plt.tight_layout()
plt.savefig('stat_mech_langmuir_adsorption.png', dpi=300, bbox_inches='tight')
plt.show()

# Numerical results
print("=== Langmuir Adsorption Isotherm ===\n")
print(f"Temperature T = {T} K\n")

for epsilon, K in zip(epsilon_values, K_values):
    print(f"Adsorption energy Œµ = {epsilon} eV:")
    print(f"  Adsorption equilibrium constant K = {K:.6e} Pa‚Åª¬π")

    # Half-coverage pressure (Œ∏ = 0.5)
    P_half = 1 / K
    print(f"  Half-coverage pressure P‚ÇÅ/‚ÇÇ = {P_half:.2e} Pa = {P_half/1e3:.2f} kPa\n")

print("Characteristics of Langmuir isotherm:")
print("  - Low pressure: Œ∏ ‚âà KP (Henry's law)")
print("  - High pressure: Œ∏ ‚Üí 1 (saturation)")
print("  - Assumes monolayer adsorption")
</code></pre></div>
</div>
<div class="content">
<h2>üíª Example 3.3: Lattice Gas Model</h2>
<div class="definition">
<h3>Lattice Gas Model</h3>
<p>There are \(M\) lattice sites, and each site has two states: occupied (particle present) or empty (no particle):</p>
<p>Energy: \(E = -\varepsilon_0 N - \frac{1}{2}J \sum_{\langle i,j \rangle} n_i n_j\)</p>
<p>where \(n_i = 0, 1\) is the occupation number and \(J\) is the nearest-neighbor interaction.</p>
<p><strong>Correspondence with Ising model</strong>: Substituting \(s_i = 2n_i - 1\) reduces to the Ising model of a spin system.</p>
<p>In mean field approximation, with \(\langle n \rangle = \theta\) (coverage):</p>
<p>\[
                \theta = \frac{1}{1 + e^{-\beta(\mu - \varepsilon_0 + Jz\theta)}}
                \]</p>
<p>where \(z\) is the coordination number.</p>
</div>
<div class="code-title">Python Implementation: Mean Field Theory of Lattice Gas</div>
<div class="code-example"><pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import fsolve

k_B = 1.380649e-23  # J/K

def mean_field_equation(theta, mu, epsilon_0, J, z, T, k_B):
    """Mean field equation"""
    beta = 1 / (k_B * T)
    effective_mu = mu - epsilon_0 + J * z * theta
    return theta - 1 / (1 + np.exp(-beta * effective_mu))

def solve_mean_field_coverage(mu, epsilon_0, J, z, T, k_B, theta_init=0.5):
    """Solve mean field equation to obtain coverage"""
    sol = fsolve(mean_field_equation, theta_init,
                  args=(mu, epsilon_0, J, z, T, k_B))
    return sol[0]

# Parameters
epsilon_0 = -0.5 * 1.602e-19  # Adsorption energy (J)
z = 4  # Coordination number of 2D square lattice
T = 300  # K

# Cases with different interaction strengths
J_values = [0, -0.1e-19, -0.2e-19, -0.3e-19]  # J (attractive)
J_eV = [J / 1.602e-19 for J in J_values]
colors = ['blue', 'green', 'orange', 'red']

# Chemical potential range
mu_range = np.linspace(-1.0e-19, 0.5e-19, 200)

fig, axes = plt.subplots(2, 2, figsize=(14, 10))

# Coverage vs chemical potential
ax1 = axes[0, 0]
for J, J_ev, color in zip(J_values, J_eV, colors):
    theta_list = []
    for mu in mu_range:
        theta = solve_mean_field_coverage(mu, epsilon_0, J, z, T, k_B)
        theta_list.append(theta)

    ax1.plot(mu_range / 1.602e-19, theta_list, color=color, linewidth=2,
             label=f'J = {J_ev:.2f} eV')

ax1.set_xlabel('Chemical potential Œº (eV)')
ax1.set_ylabel('Coverage Œ∏')
ax1.set_title('Coverage (Mean Field Theory)')
ax1.legend()
ax1.grid(True, alpha=0.3)

# Temperature dependence
ax2 = axes[0, 1]
temperatures = [200, 300, 400, 500]
J_fixed = J_values[2]
mu_fixed = -0.3e-19  # J

for T_val, color in zip(temperatures, colors):
    theta_T_list = []
    for mu in mu_range:
        theta = solve_mean_field_coverage(mu, epsilon_0, J_fixed, z, T_val, k_B)
        theta_T_list.append(theta)

    ax2.plot(mu_range / 1.602e-19, theta_T_list, color=color, linewidth=2,
             label=f'T = {T_val} K')

ax2.set_xlabel('Chemical potential Œº (eV)')
ax2.set_ylabel('Coverage Œ∏')
ax2.set_title(f'Temperature Dependence (J = {J_fixed/1.602e-19:.2f} eV)')
ax2.legend()
ax2.grid(True, alpha=0.3)

# Phase transition due to interaction (low temperature)
ax3 = axes[1, 0]
T_low = 200  # K
J_strong = -0.4e-19  # Strong attraction

# Multiple solutions of self-consistent equation
theta_init_values = [0.1, 0.5, 0.9]
markers = ['o', 's', '^']

for mu in mu_range[::10]:
    for theta_init, marker in zip(theta_init_values, markers):
        try:
            theta_sol = solve_mean_field_coverage(mu, epsilon_0, J_strong, z, T_low, k_B, theta_init)
            ax3.plot(mu / 1.602e-19, theta_sol, marker, color='blue', markersize=4)
        except:
            pass

ax3.set_xlabel('Chemical potential Œº (eV)')
ax3.set_ylabel('Coverage Œ∏')
ax3.set_title(f'Phase Transition (T = {T_low} K, J = {J_strong/1.602e-19:.2f} eV)')
ax3.grid(True, alpha=0.3)

# Compressibility
ax4 = axes[1, 1]
J_demo = J_values[1]
mu_demo_range = np.linspace(-0.8e-19, 0.2e-19, 100)
theta_demo = [solve_mean_field_coverage(mu, epsilon_0, J_demo, z, T, k_B)
              for mu in mu_demo_range]

# Compressibility Œ∫ ‚àù ‚àÇŒ∏/‚àÇŒº
dtheta_dmu = np.gradient(theta_demo, mu_demo_range)

ax4.plot(mu_demo_range / 1.602e-19, dtheta_dmu * 1.602e-19, 'purple', linewidth=2)
ax4.set_xlabel('Chemical potential Œº (eV)')
ax4.set_ylabel('‚àÇŒ∏/‚àÇŒº (eV‚Åª¬π)')
ax4.set_title('Response Function (Compressibility)')
ax4.grid(True, alpha=0.3)

plt.tight_layout()
plt.savefig('stat_mech_lattice_gas.png', dpi=300, bbox_inches='tight')
plt.show()

print("=== Lattice Gas Model (Mean Field Theory) ===\n")
print(f"Adsorption energy Œµ‚ÇÄ = {epsilon_0/1.602e-19:.2f} eV")
print(f"Coordination number z = {z}")
print(f"Temperature T = {T} K\n")

for J, J_ev in zip(J_values, J_eV):
    print(f"Interaction J = {J_ev:.2f} eV:")

    # Coverage at Œº = 0
    theta_0 = solve_mean_field_coverage(0, epsilon_0, J, z, T, k_B)
    print(f"  Coverage at Œº=0: Œ∏ = {theta_0:.4f}\n")

print("Correspondence with Ising model:")
print("  n_i = 0, 1 ‚Üí s_i = 2n_i - 1 = -1, +1")
print("  Lattice gas ‚Üî Spin system")
</code></pre></div>
</div>
<div class="content">
<h2>üíª Example 3.4: Fermi-Dirac and Bose-Einstein Distributions</h2>
<div class="definition">
<h3>Quantum Statistics</h3>
<p><strong>Fermi-Dirac distribution</strong> (fermions):</p>
<p>\[
                \langle n_i \rangle = \frac{1}{e^{\beta(\varepsilon_i - \mu)} + 1}
                \]</p>
<p>Due to the Pauli exclusion principle, each state can have at most one particle.</p>
<p><strong>Bose-Einstein distribution</strong> (bosons):</p>
<p>\[
                \langle n_i \rangle = \frac{1}{e^{\beta(\varepsilon_i - \mu)} - 1}
                \]</p>
<p>Multiple particles can occupy each state.</p>
<p><strong>Classical limit</strong> (high temperature or low density):</p>
<p>\[
                \langle n_i \rangle \approx e^{-\beta(\varepsilon_i - \mu)} \quad (\text{Maxwell-Boltzmann distribution})
                \]</p>
</div>
<div class="code-title">Python Implementation: Comparison of Quantum Statistical Distributions</div>
<div class="code-example"><pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt

k_B = 1.380649e-23  # J/K

def fermi_dirac(epsilon, mu, T, k_B):
    """Fermi-Dirac distribution"""
    beta = 1 / (k_B * T)
    x = beta * (epsilon - mu)
    # Avoid overflow
    if x &gt; 100:
        return 0
    elif x &lt; -100:
        return 1
    return 1 / (np.exp(x) + 1)

def bose_einstein(epsilon, mu, T, k_B):
    """Bose-Einstein distribution"""
    beta = 1 / (k_B * T)
    x = beta * (epsilon - mu)
    if x &lt;= 0:
        return np.inf  # Œº &lt; Œµ required
    if x &lt; 0.01:
        return 1 / x  # Approximation
    return 1 / (np.exp(x) - 1)

def maxwell_boltzmann(epsilon, mu, T, k_B):
    """Maxwell-Boltzmann distribution"""
    beta = 1 / (k_B * T)
    x = beta * (epsilon - mu)
    if x &gt; 100:
        return 0
    return np.exp(-x)

# Energy range (chemical potential set to 0)
mu = 0
epsilon_range = np.linspace(-5, 5, 500)  # In units of k_B T

# Different temperatures (normalized in k_B T units)
k_B_T = 1  # Normalized unit

fig, axes = plt.subplots(2, 2, figsize=(14, 10))

# Distribution at T = 1 (in k_B T units)
ax1 = axes[0, 0]
n_FD = [fermi_dirac(eps * k_B_T, mu, 1, k_B) for eps in epsilon_range]
n_BE = [bose_einstein(eps * k_B_T, mu, 1, k_B) if eps &gt; 0 else 0 for eps in epsilon_range]
n_MB = [maxwell_boltzmann(eps * k_B_T, mu, 1, k_B) for eps in epsilon_range]

ax1.plot(epsilon_range, n_FD, 'b-', linewidth=2, label='Fermi-Dirac')
ax1.plot(epsilon_range, n_BE, 'r-', linewidth=2, label='Bose-Einstein')
ax1.plot(epsilon_range, n_MB, 'g--', linewidth=2, label='Maxwell-Boltzmann')
ax1.axvline(0, color='k', linestyle=':', linewidth=1, label='Œº = 0')
ax1.set_xlabel('(Œµ - Œº) / (k_B T)')
ax1.set_ylabel('Occupation number ‚ü®n‚ü©')
ax1.set_title('Quantum Statistical Distributions (T = 1)')
ax1.legend()
ax1.grid(True, alpha=0.3)
ax1.set_ylim([0, 3])

# Fermi-Dirac at low temperature
ax2 = axes[0, 1]
temperatures_FD = [0.1, 0.5, 1.0, 2.0]
colors_FD = ['blue', 'green', 'orange', 'red']

for T_val, color in zip(temperatures_FD, colors_FD):
    n_FD_T = [fermi_dirac(eps * k_B_T, mu, T_val, k_B) for eps in epsilon_range]
    ax2.plot(epsilon_range, n_FD_T, color=color, linewidth=2,
             label=f'k_B T = {T_val}')

ax2.axvline(0, color='k', linestyle=':', linewidth=1)
ax2.set_xlabel('(Œµ - Œº) / (E_F)')
ax2.set_ylabel('‚ü®n‚ü©')
ax2.set_title('Temperature Dependence of Fermi-Dirac Distribution')
ax2.legend()
ax2.grid(True, alpha=0.3)

# Bose-Einstein distribution and Bose condensation
ax3 = axes[1, 0]
epsilon_BE = np.linspace(0.01, 5, 100)
temperatures_BE = [0.5, 1.0, 2.0, 5.0]

for T_val, color in zip(temperatures_BE, colors_FD):
    n_BE_T = [bose_einstein(eps * k_B_T, mu * 0.9, T_val, k_B) for eps in epsilon_BE]
    ax3.semilogy(epsilon_BE, n_BE_T, color=color, linewidth=2,
                 label=f'k_B T = {T_val}')

ax3.set_xlabel('(Œµ - Œº) / (k_B T)')
ax3.set_ylabel('‚ü®n‚ü© (log scale)')
ax3.set_title('Bose-Einstein Distribution')
ax3.legend()
ax3.grid(True, alpha=0.3, which='both')

# Classical limit verification
ax4 = axes[1, 1]
epsilon_classical = np.linspace(0, 10, 100)
T_high = 5  # High temperature

n_FD_high = [fermi_dirac(eps * k_B_T, mu, T_high, k_B) for eps in epsilon_classical]
n_BE_high = [bose_einstein(eps * k_B_T, mu * 0.5, T_high, k_B) for eps in epsilon_classical]
n_MB_high = [maxwell_boltzmann(eps * k_B_T, mu * 0.5, T_high, k_B) for eps in epsilon_classical]

ax4.semilogy(epsilon_classical, n_FD_high, 'b-', linewidth=2, label='Fermi-Dirac')
ax4.semilogy(epsilon_classical, n_BE_high, 'r-', linewidth=2, label='Bose-Einstein')
ax4.semilogy(epsilon_classical, n_MB_high, 'g--', linewidth=2, label='Maxwell-Boltzmann')
ax4.set_xlabel('(Œµ - Œº) / (k_B T)')
ax4.set_ylabel('‚ü®n‚ü© (log scale)')
ax4.set_title(f'Classical Limit (k_B T = {T_high})')
ax4.legend()
ax4.grid(True, alpha=0.3, which='both')

plt.tight_layout()
plt.savefig('stat_mech_quantum_statistics.png', dpi=300, bbox_inches='tight')
plt.show()

print("=== Quantum Statistics ===\n")

print("Fermi-Dirac distribution:")
print("  - Fermions (electrons, protons, neutrons, etc.)")
print("  - Pauli exclusion principle: ‚ü®n‚ü© ‚â§ 1")
print("  - Step function at T = 0 (Fermi surface)\n")

print("Bose-Einstein distribution:")
print("  - Bosons (photons, phonons, He-4, etc.)")
print("  - Multiple occupation possible: ‚ü®n‚ü© ‚â• 0")
print("  - Bose condensation at low temperature (Œº ‚Üí Œµ‚ÇÄ)\n")

print("Classical limit (high temperature):")
print("  - When e^{Œ≤(Œµ-Œº)} &gt;&gt; 1")
print("  - FD ‚âà BE ‚âà MB")
print("  - Quantum statistics ‚Üí classical statistics\n")

# Numerical example
epsilon_test = 2 * k_B_T
T_test = 300  # K
print(f"Numerical example (Œµ-Œº = 2k_BT, T = {T_test} K):")
n_FD_test = fermi_dirac(epsilon_test, mu, T_test, k_B)
n_BE_test = bose_einstein(epsilon_test, mu * 0.5, T_test, k_B)
n_MB_test = maxwell_boltzmann(epsilon_test, mu * 0.5, T_test, k_B)
print(f"  Fermi-Dirac: ‚ü®n‚ü© = {n_FD_test:.6f}")
print(f"  Bose-Einstein: ‚ü®n‚ü© = {n_BE_test:.6f}")
print(f"  Maxwell-Boltzmann: ‚ü®n‚ü© = {n_MB_test:.6f}")
</code></pre></div>
</div>
<div class="content">
<h2>üìö Summary</h2>
<ul>
<li>The <strong>grand canonical ensemble</strong> describes open systems with fluctuating particle numbers, where chemical potential is an important variable</li>
<li>From the <strong>grand partition function</strong> \(\Xi\), all thermodynamic quantities can be derived through the grand potential \(\Omega\)</li>
<li>The <strong>chemical potential</strong> is the free energy change when adding a particle and determines equilibrium conditions</li>
<li>The <strong>Langmuir adsorption isotherm</strong> describes monolayer adsorption and is widely applied in materials science</li>
<li>The <strong>lattice gas model</strong> is equivalent to the Ising model and describes phase transitions in interacting systems</li>
<li>The <strong>Fermi-Dirac distribution</strong> is the quantum statistics for fermions, essential for describing electron systems and metals</li>
<li>The <strong>Bose-Einstein distribution</strong> is the quantum statistics for bosons, describing phonon and photon systems</li>
<li>In the high-temperature limit, quantum statistics reduce to the classical Maxwell-Boltzmann distribution</li>
</ul>
</div>
<div class="exercise">
<h3>üí° Exercises</h3>
<ol>
<li><strong>Particle number fluctuation</strong>: For an ideal gas in the grand canonical ensemble, calculate \(\langle (\Delta N)^2 \rangle / \langle N \rangle\) and show that the relative fluctuation approaches zero as \(N \to \infty\).</li>
<li><strong>BET adsorption</strong>: Implement the BET theory for multilayer adsorption and visualize the differences from the Langmuir isotherm.</li>
<li><strong>Phase transition in lattice gas</strong>: Find the critical temperature \(T_c\) using mean field theory and investigate its dependence on \(J\) and \(z\).</li>
<li><strong>Fermi energy</strong>: Calculate the Fermi energy \(E_F\) of a 3D electron gas as a function of density and compare with typical values for metals.</li>
<li><strong>Planck distribution</strong>: Derive the Planck distribution for blackbody radiation from the Bose-Einstein distribution of photons (with \(\mu = 0\)).</li>
</ol>
</div>
<div class="nav-buttons">
<a class="nav-button" href="chapter-2.html">‚Üê Chapter 2: Canonical Ensemble and Partition Function</a>
<a class="nav-button" href="chapter-4.html">Chapter 4: Interacting Systems and Phase Transitions ‚Üí</a>
</div>
</div>


<footer>
<p>¬© 2025 AI Terakoya - Fundamental Mathematics Dojo</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
</body>
</html>
