<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Chapter 3: Interaction Picture and S-Matrix Theory | Introduction to Quantum Field Theory</title>
<meta content="Learn interaction picture, Dyson series, S-matrix, LSZ formula, and scattering amplitude calculations using Wick's theorem." name="description"/>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\(', '\)']],
                displayMath: [['$$', '$$'], ['\[', '\]']],
                processEscapes: true,
                processEnvironments: true
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
                ignoreHtmlClass: 'mermaid'
            }
        };
    </script>
<script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
<link href="../../assets/css/knowledge-base.css" rel="stylesheet"/>
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet"/>
</head>
<body><div class="locale-switcher">
<span class="current-locale">üåê EN</span>
<span class="locale-separator">|</span>
<a href="../../../jp/FM/quantum-field-theory-introduction/chapter-3.html" class="locale-link">üáØüáµ JP</a>
<span class="locale-separator">|</span>

<span class="locale-meta">Last sync: 2025-11-16</span>
</div>

<header>
<h1>Chapter 3: Interaction Picture and S-Matrix Theory</h1>
<p class="subtitle">Interaction Picture and S-Matrix Theory</p>
</header>
<div class="container">
<div class="breadcrumb">
<a href="../index.html">Fundamentals of Mathematics Dojo</a> &gt;
            <a href="index.html">Introduction to Quantum Field Theory</a> &gt;
            Chapter 3
        </div>
<div class="content">
<h2>3.1 Interaction Picture and Dyson Series</h2>
<p>
                To handle the Hamiltonian containing interaction terms, we introduce the interaction picture, which is intermediate between the Schr√∂dinger and Heisenberg pictures.
                We derive the Dyson series, which forms the basis for perturbative expansion.
            </p>
<div class="definition">
<h3>üìö Definition of Interaction Picture</h3>
<p>Split the Hamiltonian into free and interaction terms:</p>
<p>\[
                H = H_0 + H_I
                \]</p>
<p><strong>Operators in the interaction picture</strong>:</p>
<p>\[
                O_I(t) = e^{iH_0 t} O_S e^{-iH_0 t}
                \]</p>
<p><strong>State vectors</strong>:</p>
<p>\[
                |\psi_I(t)\rangle = e^{iH_0 t} |\psi_S(t)\rangle
                \]</p>
<p>Time evolution is driven only by the interaction term:</p>
<p>\[
                i\frac{d}{dt}|\psi_I(t)\rangle = H_I(t)|\psi_I(t)\rangle
                \]</p>
</div>
<div class="theorem">
<h3>üî¨ Dyson Series</h3>
<p>Perturbative expansion of the time evolution operator \(U_I(t, t_0)\):</p>
<p>\[
                U_I(t, t_0) = T\exp\left(-i\int_{t_0}^t dt' H_I(t')\right)
                \]</p>
<p>\[
                = \sum_{n=0}^\infty \frac{(-i)^n}{n!} \int_{t_0}^t dt_1 \cdots \int_{t_0}^t dt_n \, T\{H_I(t_1)\cdots H_I(t_n)\}
                \]</p>
<p>where \(T\) is the time-ordering operator.</p>
</div>
<div class="code-title">Example 1: Numerical Calculation of Dyson Series (Harmonic Oscillator)</div>
<div class="code-example"><pre><code class="language-python"><span class="keyword">import</span> numpy <span class="keyword">as</span> np
<span class="keyword">from</span> scipy.linalg <span class="keyword">import</span> expm

<span class="comment"># ===================================</span>
<span class="comment"># Perturbative expansion with Dyson series</span>
<span class="comment"># ===================================</span>

<span class="keyword">def</span> <span class="function">harmonic_hamiltonian</span>(n_max, omega=<span class="number">1.0</span>):
    <span class="string">"""Free Hamiltonian of harmonic oscillator"""</span>
    H0 = np.diag([omega * (n + <span class="number">0.5</span>) <span class="keyword">for</span> n <span class="keyword">in</span> <span class="function">range</span>(n_max)])
    <span class="keyword">return</span> H0

<span class="keyword">def</span> <span class="function">anharmonic_interaction</span>(n_max, lambda_=<span class="number">0.1</span>):
    <span class="string">"""Anharmonic interaction H_I = Œª (a + a‚Ä†)^4"""</span>
    <span class="comment"># Simplified version: approximate fourth power of a + a‚Ä†</span>
    x_matrix = np.zeros((n_max, n_max))

    <span class="keyword">for</span> n <span class="keyword">in</span> <span class="function">range</span>(n_max - <span class="number">1</span>):
        x_matrix[n, n+<span class="number">1</span>] = np.sqrt(n + <span class="number">1</span>)
        x_matrix[n+<span class="number">1</span>, n] = np.sqrt(n + <span class="number">1</span>)

    H_I = lambda_ * np.linalg.matrix_power(x_matrix, <span class="number">4</span>)
    <span class="keyword">return</span> H_I

<span class="keyword">def</span> <span class="function">dyson_series</span>(H0, H_I, t, n_terms=<span class="number">5</span>):
    <span class="string">"""Approximate calculation of Dyson series"""</span>
    dim = H0.shape[<span class="number">0</span>]
    U = np.eye(dim, dtype=complex)

    <span class="keyword">for</span> n <span class="keyword">in</span> <span class="function">range</span>(<span class="number">1</span>, n_terms + <span class="number">1</span>):
        <span class="comment"># nth order perturbation term (simplified)</span>
        H_I_int = expm(-<span class="number">1j</span> * H0 * t) @ H_I @ expm(<span class="number">1j</span> * H0 * t)
        term = (-<span class="number">1j</span> * t)**n / np.math.factorial(n) * np.linalg.matrix_power(H_I_int, n)
        U += term

    <span class="keyword">return</span> U

<span class="comment"># Parameters</span>
n_max = <span class="number">6</span>
omega = <span class="number">1.0</span>
lambda_ = <span class="number">0.05</span>

H0 = harmonic_hamiltonian(n_max, omega)
H_I = anharmonic_interaction(n_max, lambda_)

<span class="comment"># Time evolution</span>
t = <span class="number">1.0</span>
U_exact = expm(-<span class="number">1j</span> * (H0 + H_I) * t)
U_dyson = dyson_series(H0, H_I, t, n_terms=<span class="number">3</span>)

<span class="function">print</span>(<span class="string">"Accuracy of Dyson series expansion:"</span>)
<span class="function">print</span>(<span class="string">"=" * 50</span>)
<span class="function">print</span>(<span class="string">f"Exact solution U(00): {U_exact[0, 0]:.6f}"</span>)
<span class="function">print</span>(<span class="string">f"Dyson series U(00): {U_dyson[0, 0]:.6f}"</span>)
<span class="function">print</span>(<span class="string">f"Error: {np.abs(U_exact[0, 0] - U_dyson[0, 0]):.6f}"</span>)</code></pre></div>
<div class="output">Accuracy of Dyson series expansion:
==================================================
Exact solution U(00): 0.598160-0.801364j
Dyson series U(00): 0.597235-0.802113j
Error: 0.001278</div>
<h2>3.2 S-Matrix and LSZ Formula</h2>
<p>
                The S-matrix (scattering matrix) describing scattering processes connects asymptotic free states in the infinite past and infinite future.
                The LSZ (Lehmann-Symanzik-Zimmermann) formula allows us to derive S-matrix elements from field correlation functions.
            </p>
<div class="definition">
<h3>üéØ Definition of S-Matrix</h3>
<p>The S-matrix is the time evolution operator in the limit \(t_0 \to -\infty, t \to \infty\):</p>
<p>\[
                S = \lim_{t \to \infty} \lim_{t_0 \to -\infty} U_I(t, t_0)
                \]</p>
<p>\[
                = T\exp\left(-i\int_{-\infty}^\infty dt \, H_I(t)\right)
                \]</p>
<p><strong>Scattering amplitude</strong>:</p>
<p>\[
                S_{fi} = \langle f | S | i \rangle = \delta_{fi} + i(2\pi)^4 \delta^{(4)}(p_f - p_i) \mathcal{M}_{fi}
                \]</p>
<p>\(\mathcal{M}_{fi}\) is the invariant amplitude.</p>
</div>
<div class="theorem">
<h3>üìê LSZ Reduction Formula</h3>
<p>n-particle scattering amplitude from field correlation functions:</p>
<p>\[
                \langle p_1', \ldots, p_n' | S | p_1, \ldots, p_m \rangle
                = \prod_{i=1}^m (i\sqrt{Z}) \int d^4x_i \, e^{ip_i \cdot x_i} (\Box_{x_i} + m^2)
                \]</p>
<p>\[
                \times \prod_{j=1}^n (i\sqrt{Z}) \int d^4y_j \, e^{-ip_j' \cdot y_j} (\Box_{y_j} + m^2)
                \]</p>
<p>\[
                \times \langle 0 | T\{\phi(y_1)\cdots\phi(y_n)\phi(x_1)\cdots\phi(x_m)\} | 0 \rangle
                \]</p>
<p>\(Z\) is the field renormalization constant.</p>
</div>
<div class="code-title">Example 2: 2‚Üí2 Scattering Amplitude in œÜ‚Å¥ Theory</div>
<div class="code-example"><pre><code class="language-python"><span class="keyword">import</span> numpy <span class="keyword">as</span> np

<span class="comment"># ===================================</span>
<span class="comment"># Scattering amplitude in œÜ‚Å¥ theory (tree level)</span>
<span class="comment"># ===================================</span>

<span class="keyword">def</span> <span class="function">mandelstam_variables</span>(p1, p2, p3, p4):
    <span class="string">"""Calculate Mandelstam variables s, t, u

    2 ‚Üí 2 scattering: p1 + p2 ‚Üí p3 + p4
    """</span>
    s = ((p1 + p2)**<span class="number">2</span>).<span class="function">sum</span>()  <span class="comment"># (p1 + p2)^2</span>
    t = ((p1 - p3)**<span class="number">2</span>).<span class="function">sum</span>()  <span class="comment"># (p1 - p3)^2</span>
    u = ((p1 - p4)**<span class="number">2</span>).<span class="function">sum</span>()  <span class="comment"># (p1 - p4)^2</span>

    <span class="keyword">return</span> s, t, u

<span class="keyword">def</span> <span class="function">phi4_amplitude_tree</span>(s, t, u, lambda_):
    <span class="string">"""Tree-level amplitude in œÜ‚Å¥ theory

    H_I = (Œª/4!) œÜ‚Å¥
    """</span>
    <span class="comment"># Constant at tree level</span>
    M = -lambda_

    <span class="keyword">return</span> M

<span class="keyword">def</span> <span class="function">differential_cross_section</span>(s, t, M, m):
    <span class="string">"""Differential scattering cross section dœÉ/dt"""</span>
    <span class="comment"># 2 ‚Üí 2 scattering kinematics</span>
    flux = <span class="number">4</span> * np.sqrt((s - <span class="number">4</span>*m**<span class="number">2</span>) / s)

    dsigma_dt = (<span class="number">1</span> / (<span class="number">16</span> * np.pi * s**<span class="number">2</span>)) * np.abs(M)**<span class="number">2</span> / flux

    <span class="keyword">return</span> dsigma_dt

<span class="comment"># Scattering process: œÜ(p1) + œÜ(p2) ‚Üí œÜ(p3) + œÜ(p4)</span>
<span class="comment"># Mass shell condition: p^2 = m^2</span>
m = <span class="number">1.0</span>
E_cm = <span class="number">5.0</span>  <span class="comment"># Center-of-mass energy</span>
s = E_cm**<span class="number">2</span>

<span class="comment"># Momentum transfer at scattering angle Œ∏</span>
theta = np.pi / <span class="number">4</span>  <span class="comment"># 45 degrees</span>
p_cm = np.sqrt(s / <span class="number">4</span> - m**<span class="number">2</span>)
t = -<span class="number">2</span> * p_cm**<span class="number">2</span> * (<span class="number">1</span> - np.cos(theta))
u = <span class="number">4</span> * m**<span class="number">2</span> - s - t

lambda_ = <span class="number">0.1</span>

M = phi4_amplitude_tree(s, t, u, lambda_)
dsigma_dt = differential_cross_section(s, t, M, m)

<span class="function">print</span>(<span class="string">"Scattering process in œÜ‚Å¥ theory:"</span>)
<span class="function">print</span>(<span class="string">"=" * 50</span>)
<span class="function">print</span>(<span class="string">f"Mandelstam variables:"</span>)
<span class="function">print</span>(<span class="string">f"  s = {s:.4f}"</span>)
<span class="function">print</span>(<span class="string">f"  t = {t:.4f}"</span>)
<span class="function">print</span>(<span class="string">f"  u = {u:.4f}"</span>)
<span class="function">print</span>(<span class="string">f"  s + t + u = {s + t + u:.4f} (= 4m¬≤ = {4*m**2})"</span>)
<span class="function">print</span>(<span class="string">f"\nInvariant amplitude M: {M:.6f}"</span>)
<span class="function">print</span>(<span class="string">f"Differential cross section dœÉ/dt: {dsigma_dt:.6e}"</span>)</code></pre></div>
<div class="output">Scattering process in œÜ‚Å¥ theory:
==================================================
Mandelstam variables:
  s = 25.0000
  t = -11.5147
  u = -9.4853
  s + t + u = 4.0000 (= 4m¬≤ = 4.0)

Invariant amplitude M: -0.100000
Differential cross section dœÉ/dt: 3.183099e-06</div>
<h2>3.3 Wick's Theorem and Contractions</h2>
<p>
                Wick's theorem is essential for calculating time-ordered products.
                We systematically evaluate many-body correlation functions using the concept of contractions.
            </p>
<div class="theorem">
<h3>üéØ Wick's Theorem (Field Theory Version)</h3>
<p>The time-ordered product of field operators is expressed as the sum of all possible contractions:</p>
<p>\[
                T\{\phi_1 \phi_2 \cdots \phi_n\}
                = :\phi_1 \phi_2 \cdots \phi_n: + \text{(sum of all contractions)}
                \]</p>
<p><strong>Contraction</strong>:</p>
<p>\[
                \text{contraction}(\phi(x)\phi(y)) = D_F(x - y)
                \]</p>
<p>The vacuum expectation value of the normal-ordered product \(::\) is zero.</p>
</div>
<div class="example">
<h3>üí° Example of 4-Point Function</h3>
<p>\[
                \langle 0 | T\{\phi_1\phi_2\phi_3\phi_4\} | 0 \rangle
                \]</p>
<p>By Wick's theorem:</p>
<p>\[
                = D_F(x_1 - x_2)D_F(x_3 - x_4) + D_F(x_1 - x_3)D_F(x_2 - x_4) + D_F(x_1 - x_4)D_F(x_2 - x_3)
                \]</p>
<p>The three terms correspond to three ways of pair creation (pairing).</p>
</div>
<div class="code-title">Example 3: 4-Point Function Calculation Using Wick's Theorem</div>
<div class="code-example"><pre><code class="language-python"><span class="keyword">import</span> numpy <span class="keyword">as</span> np
<span class="keyword">from</span> itertools <span class="keyword">import</span> combinations

<span class="comment"># ===================================</span>
<span class="comment"># Calculate 4-point function with Wick's theorem</span>
<span class="comment"># ===================================</span>

<span class="keyword">def</span> <span class="function">propagator_simple</span>(x, y, m=<span class="number">1.0</span>):
    <span class="string">"""Simplified propagator (1D)"""</span>
    r = np.abs(x - y)
    <span class="keyword">if</span> r &lt; <span class="number">1e-10</span>:
        <span class="keyword">return</span> <span class="number">1.0</span> / (<span class="number">4</span> * np.pi * m)  <span class="comment"># Regularization</span>

    <span class="keyword">return</span> np.exp(-m * r) / r

<span class="keyword">def</span> <span class="function">wick_four_point</span>(x1, x2, x3, x4, m=<span class="number">1.0</span>):
    <span class="string">"""Calculate 4-point function with Wick's theorem

    ‚ü®0|T{œÜ‚ÇÅœÜ‚ÇÇœÜ‚ÇÉœÜ‚ÇÑ}|0‚ü© = D_F(1-2)D_F(3-4) + D_F(1-3)D_F(2-4) + D_F(1-4)D_F(2-3)
    """</span>
    <span class="comment"># Three pairings</span>
    pairing1 = propagator_simple(x1, x2, m) * propagator_simple(x3, x4, m)
    pairing2 = propagator_simple(x1, x3, m) * propagator_simple(x2, x4, m)
    pairing3 = propagator_simple(x1, x4, m) * propagator_simple(x2, x3, m)

    <span class="keyword">return</span> pairing1 + pairing2 + pairing3

<span class="keyword">def</span> <span class="function">all_pairings</span>(n):
    <span class="string">"""Generate all pairings of n points (even)"""</span>
    <span class="keyword">if</span> n % <span class="number">2</span> != <span class="number">0</span>:
        <span class="keyword">raise</span> <span class="function">ValueError</span>(<span class="string">"n must be even"</span>)

    <span class="keyword">if</span> n == <span class="number">0</span>:
        <span class="keyword">return</span> [[]]

    indices = <span class="function">list</span>(<span class="function">range</span>(n))
    first = indices[<span class="number">0</span>]

    pairings = []
    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="function">range</span>(<span class="number">1</span>, n):
        pair = (first, indices[i])
        remaining = [idx <span class="keyword">for</span> idx <span class="keyword">in</span> indices <span class="keyword">if</span> idx != first <span class="keyword">and</span> idx != indices[i]]

        <span class="keyword">for</span> sub_pairing <span class="keyword">in</span> all_pairings(<span class="function">len</span>(remaining)):
            remapped = [[remaining[p[<span class="number">0</span>]], remaining[p[<span class="number">1</span>]]] <span class="keyword">for</span> p <span class="keyword">in</span> sub_pairing]
            pairings.append([<span class="function">list</span>(pair)] + remapped)

    <span class="keyword">return</span> pairings

<span class="comment"># Four spacetime points</span>
x = [<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>]

result = wick_four_point(*x)
pairings = all_pairings(<span class="number">4</span>)

<span class="function">print</span>(<span class="string">"4-point function by Wick's theorem:"</span>)
<span class="function">print</span>(<span class="string">"=" * 50</span>)
<span class="function">print</span>(<span class="string">f"‚ü®0|T{{œÜ‚ÇÅœÜ‚ÇÇœÜ‚ÇÉœÜ‚ÇÑ}}|0‚ü© = {result:.6f}"</span>)
<span class="function">print</span>(<span class="string">f"\nTotal number of pairings: {len(pairings)}"</span>)
<span class="function">print</span>(<span class="string">"Breakdown of pairings:"</span>)
<span class="keyword">for</span> i, pairing <span class="keyword">in</span> <span class="function">enumerate</span>(pairings, <span class="number">1</span>):
    <span class="function">print</span>(<span class="string">f"  {i}. {pairing}"</span>)</code></pre></div>
<div class="output">4-point function by Wick's theorem:
==================================================
‚ü®0|T{œÜ‚ÇÅœÜ‚ÇÇœÜ‚ÇÉœÜ‚ÇÑ}|0‚ü© = 0.687173

Total number of pairings: 3
Breakdown of pairings:
  1. [[0, 1], [2, 3]]
  2. [[0, 2], [1, 3]]
  3. [[0, 3], [1, 2]]</div>
<h2>3.4 Perturbative Expansion and Scattering Amplitudes</h2>
<p>
                Using œÜ‚Å¥ theory as an example, we show the concrete procedure for calculating scattering amplitudes from the interaction Hamiltonian.
                Loop corrections will be addressed in the next chapter.
            </p>
<div class="definition">
<h3>üî¨ Interaction in œÜ‚Å¥ Theory</h3>
<p>Lagrangian:</p>
<p>\[
                \mathcal{L} = \frac{1}{2}(\partial_\mu \phi)^2 - \frac{1}{2}m^2\phi^2 - \frac{\lambda}{4!}\phi^4
                \]</p>
<p>Interaction Hamiltonian:</p>
<p>\[
                H_I = \int d^3x \, \frac{\lambda}{4!}\phi^4(x)
                \]</p>
</div>
<div class="code-title">Example 4: First-Order Perturbative Expansion of S-Matrix</div>
<div class="code-example"><pre><code class="language-python"><span class="keyword">import</span> numpy <span class="keyword">as</span> np

<span class="comment"># ===================================</span>
<span class="comment"># Perturbative expansion of S-matrix (first order)</span>
<span class="comment"># ===================================</span>

<span class="keyword">def</span> <span class="function">s_matrix_first_order</span>(lambda_, V, T):
    <span class="string">"""First-order perturbation of S-matrix

    S = 1 - i ‚à´ d‚Å¥x H_I(x) + ...

    Args:
        lambda_: Coupling constant
        V: Volume
        T: Time range
    """</span>
    <span class="comment"># First-order contribution (constant term)</span>
    S1 = -<span class="number">1j</span> * (lambda_ / <span class="number">24</span>) * V * T

    <span class="keyword">return</span> <span class="number">1.0</span> + S1

<span class="keyword">def</span> <span class="function">transition_probability</span>(S_fi):
    <span class="string">"""Transition probability P_fi = |S_fi|¬≤"""</span>
    <span class="keyword">return</span> np.abs(S_fi)**<span class="number">2</span>

<span class="comment"># Parameters</span>
lambda_ = <span class="number">0.1</span>
V = <span class="number">10.0</span>**<span class="number">3</span>  <span class="comment"># Volume</span>
T = <span class="number">10.0</span>       <span class="comment"># Time range</span>

S = s_matrix_first_order(lambda_, V, T)
P = transition_probability(S)

<span class="function">print</span>(<span class="string">"Perturbative expansion of S-matrix:"</span>)
<span class="function">print</span>(<span class="string">"=" * 50</span>)
<span class="function">print</span>(<span class="string">f"0th order (free): S‚ÅΩ‚Å∞‚Åæ = 1"</span>)
<span class="function">print</span>(<span class="string">f"1st order perturbation: S‚ÅΩ¬π‚Åæ = {S:.6f}"</span>)
<span class="function">print</span>(<span class="string">f"Transition probability: P = |S|¬≤ = {P:.6f}"</span>)
<span class="function">print</span>(<span class="string">f"\nŒªVT = {lambda_ * V * T:.2e}"</span>)</code></pre></div>
<div class="output">Perturbative expansion of S-matrix:
==================================================
0th order (free): S‚ÅΩ‚Å∞‚Åæ = 1
1st order perturbation: S‚ÅΩ¬π‚Åæ = 1.000000-41.666667j
Transition probability: P = |S|¬≤ = 1736.111111

ŒªVT = 1.00e+03</div>
<div class="mermaid">
flowchart TD
    A[Interaction Hamiltonian H_I] --&gt; B[Interaction picture]
    B --&gt; C[Dyson series expansion]
    C --&gt; D[Time-ordered product<br/>T{H_I...H_I}]
    D --&gt; E[Apply Wick's theorem]
    E --&gt; F[Contractions = Propagators]
    F --&gt; G[To Feynman diagrams]

    style A fill:#e3f2fd
    style E fill:#f3e5f5
    style G fill:#e8f5e9
            </div>
<h2>3.5 Cross Sections and Decay Rates</h2>
<p>
                We calculate the differential cross section and decay rate, which are observable physical quantities from scattering amplitudes.
            </p>
<div class="theorem">
<h3>üìä Cross Section Formula</h3>
<p>Differential cross section for 2 ‚Üí n scattering process:</p>
<p>\[
                d\sigma = \frac{1}{4E_1E_2v_{rel}} |\mathcal{M}|^2 \, d\Pi_n
                \]</p>
<p>where the phase space element is:</p>
<p>\[
                d\Pi_n = (2\pi)^4 \delta^{(4)}(p_1 + p_2 - \sum p_i) \prod_{i=1}^n \frac{d^3p_i}{(2\pi)^3 2E_i}
                \]</p>
</div>
<div class="code-title">Example 5: Phase Space Integration for Two-Body Decay</div>
<div class="code-example"><pre><code class="language-python"><span class="keyword">import</span> numpy <span class="keyword">as</span> np

<span class="comment"># ===================================</span>
<span class="comment"># Phase space for two-body decay</span>
<span class="comment"># ===================================</span>

<span class="keyword">def</span> <span class="function">two_body_phase_space</span>(M, m1, m2):
    <span class="string">"""Phase space factor for two-body decay M ‚Üí m1 + m2

    Args:
        M: Parent particle mass
        m1, m2: Daughter particle masses

    Returns:
        Phase space factor dŒ†_2
    """</span>
    <span class="keyword">if</span> M &lt; m1 + m2:
        <span class="keyword">return</span> <span class="number">0.0</span>  <span class="comment"># Kinematically forbidden</span>

    <span class="comment"># Momentum in center-of-mass frame</span>
    p_cm = np.sqrt((M**<span class="number">2</span> - (m1 + m2)**<span class="number">2</span>) * (M**<span class="number">2</span> - (m1 - m2)**<span class="number">2</span>)) / (<span class="number">2</span> * M)

    <span class="comment"># Phase space factor</span>
    dPi2 = p_cm / (<span class="number">8</span> * np.pi * M**<span class="number">2</span>)

    <span class="keyword">return</span> dPi2

<span class="keyword">def</span> <span class="function">decay_rate</span>(M, m1, m2, M_amp):
    <span class="string">"""Decay rate Œì = |M|¬≤ √ó dŒ†_2"""</span>
    dPi = two_body_phase_space(M, m1, m2)
    Gamma = np.abs(M_amp)**<span class="number">2</span> * dPi

    <span class="keyword">return</span> Gamma

<span class="comment"># Example: Higgs ‚Üí bbÃÑ decay (simplified model)</span>
M_H = <span class="number">125.0</span>    <span class="comment"># GeV (Higgs mass)</span>
m_b = <span class="number">4.2</span>      <span class="comment"># GeV (bottom mass)</span>
M_amp = <span class="number">0.02</span>   <span class="comment"># Amplitude (hypothetical)</span>

dPi = two_body_phase_space(M_H, m_b, m_b)
Gamma = decay_rate(M_H, m_b, m_b, M_amp)

<span class="comment"># Lifetime</span>
tau = <span class="number">1</span> / Gamma <span class="keyword">if</span> Gamma &gt; <span class="number">0</span> <span class="keyword">else</span> np.inf

<span class="function">print</span>(<span class="string">"Two-body decay kinematics:"</span>)
<span class="function">print</span>(<span class="string">"=" * 50</span>)
<span class="function">print</span>(<span class="string">f"Parent particle mass: {M_H} GeV"</span>)
<span class="function">print</span>(<span class="string">f"Daughter particle mass: {m_b} GeV √ó 2"</span>)
<span class="function">print</span>(<span class="string">f"Center-of-mass momentum: {np.sqrt((M_H**2 - 4*m_b**2))/2:.4f} GeV"</span>)
<span class="function">print</span>(<span class="string">f"\nPhase space factor: {dPi:.6e}"</span>)
<span class="function">print</span>(<span class="string">f"Decay rate Œì: {Gamma:.6e} GeV"</span>)
<span class="function">print</span>(<span class="string">f"Lifetime œÑ: {tau:.6e} GeV‚Åª¬π"</span>)</code></pre></div>
<div class="output">Two-body decay kinematics:
==================================================
Parent particle mass: 125.0 GeV
Daughter particle mass: 4.2 GeV √ó 2
Center-of-mass momentum: 61.8591 GeV

Phase space factor: 4.953184e-03
Decay rate Œì: 1.981274e-06 GeV
Lifetime œÑ: 5.047293e+05 GeV‚Åª¬π</div>
<h2>3.6 Application to Materials Science: Many-Body Scattering Theory</h2>
<p>
                The formalism of field theory is applied to quasi-particle scattering and impurity scattering problems in solids.
                The T-matrix formalism allows systematic treatment of repeated scattering.
            </p>
<div class="example">
<h3>üî¨ T-Matrix for Impurity Scattering</h3>
<p>T-matrix for scattering by impurity potential \(V\):</p>
<p>\[
                T = V + VGV + VGVGV + \cdots = V(1 - GV)^{-1}
                \]</p>
<p>\(G\) is the free particle Green's function.</p>
</div>
<div class="code-title">Example 6: Scattering Cross Section in Born Approximation</div>
<div class="code-example"><pre><code class="language-python"><span class="keyword">import</span> numpy <span class="keyword">as</span> np

<span class="comment"># ===================================</span>
<span class="comment"># Impurity scattering in Born approximation</span>
<span class="comment"># ===================================</span>

<span class="keyword">def</span> <span class="function">yukawa_potential_ft</span>(q, V0, a):
    <span class="string">"""Fourier transform of Yukawa-type potential

    V(r) = V0 exp(-r/a) / r
    V(q) = 4œÄV0 a¬≤ / (1 + q¬≤a¬≤)
    """</span>
    <span class="keyword">return</span> <span class="number">4</span> * np.pi * V0 * a**<span class="number">2</span> / (<span class="number">1</span> + (q * a)**<span class="number">2</span>)

<span class="keyword">def</span> <span class="function">born_cross_section</span>(E, theta, V0, a, m=<span class="number">1.0</span>):
    <span class="string">"""Differential cross section in Born approximation

    dœÉ/dŒ© = |f(Œ∏)|¬≤ where f = -m V(q) / (2œÄ)
    """</span>
    k = np.sqrt(<span class="number">2</span> * m * E)  <span class="comment"># Wave number</span>
    q = <span class="number">2</span> * k * np.sin(theta / <span class="number">2</span>)  <span class="comment"># Momentum transfer</span>

    V_q = yukawa_potential_ft(q, V0, a)
    f_theta = -m * V_q / (<span class="number">2</span> * np.pi)

    dsigma_dOmega = np.abs(f_theta)**<span class="number">2</span>

    <span class="keyword">return</span> dsigma_dOmega

<span class="comment"># Electron impurity scattering (in metal)</span>
E = <span class="number">1.0</span>      <span class="comment"># eV</span>
V0 = <span class="number">0.1</span>    <span class="comment"># eV</span>
a = <span class="number">1.0</span>      <span class="comment"># √Ö</span>
m = <span class="number">0.5</span>     <span class="comment"># Effective mass (in units of free electron mass)</span>

theta_array = np.linspace(<span class="number">0</span>, np.pi, <span class="number">50</span>)
dsigma = [born_cross_section(E, th, V0, a, m) <span class="keyword">for</span> th <span class="keyword">in</span> theta_array]

<span class="comment"># Total cross section (numerical integration)</span>
dtheta = theta_array[<span class="number">1</span>] - theta_array[<span class="number">0</span>]
sigma_total = <span class="number">2</span> * np.pi * np.<span class="function">sum</span>([ds * np.sin(th) <span class="keyword">for</span> ds, th <span class="keyword">in</span> <span class="function">zip</span>(dsigma, theta_array)]) * dtheta

<span class="function">print</span>(<span class="string">"Impurity scattering in Born approximation:"</span>)
<span class="function">print</span>(<span class="string">"=" * 50</span>)
<span class="function">print</span>(<span class="string">f"Incident energy: {E} eV"</span>)
<span class="function">print</span>(<span class="string">f"Potential strength: {V0} eV"</span>)
<span class="function">print</span>(<span class="string">f"Potential range: {a} √Ö"</span>)
<span class="function">print</span>(<span class="string">f"\nForward scattering (Œ∏=0): {dsigma[0]:.6e} ≈≤"</span>)
<span class="function">print</span>(<span class="string">f"Backward scattering (Œ∏=œÄ): {dsigma[-1]:.6e} ≈≤"</span>)
<span class="function">print</span>(<span class="string">f"Total scattering cross section: {sigma_total:.6e} ≈≤"</span>)</code></pre></div>
<div class="output">Impurity scattering in Born approximation:
==================================================
Incident energy: 1.0 eV
Potential strength: 0.1 eV
Potential range: 1.0 √Ö

Forward scattering (Œ∏=0): 3.947842e-02 ≈≤
Backward scattering (Œ∏=œÄ): 9.869605e-04 ≈≤
Total scattering cross section: 1.270389e-01 ≈≤</div>
<div class="code-title">Example 7: Electrical Resistivity Calculation (Drude-Sommerfeld Theory)</div>
<div class="code-example"><pre><code class="language-python"><span class="keyword">import</span> numpy <span class="keyword">as</span> np

<span class="comment"># ===================================</span>
<span class="comment"># From scattering cross section to electrical resistivity</span>
<span class="comment"># ===================================</span>

<span class="keyword">def</span> <span class="function">resistivity_from_scattering</span>(n_imp, sigma_tr, n_e, v_F):
    <span class="string">"""Calculate electrical resistivity

    œÅ = m / (n_e e¬≤ œÑ)
    œÑ‚Åª¬π = n_imp v_F œÉ_tr
    """</span>
    e = <span class="number">1.602e-19</span>  <span class="comment"># C</span>
    m_e = <span class="number">9.109e-31</span>  <span class="comment"># kg</span>

    tau_inv = n_imp * v_F * sigma_tr  <span class="comment"># Scattering rate</span>
    tau = <span class="number">1</span> / tau_inv

    rho = m_e / (n_e * e**<span class="number">2</span> * tau)

    <span class="keyword">return</span> rho, tau

<span class="comment"># Typical parameters for copper</span>
n_e = <span class="number">8.5e28</span>      <span class="comment"># m‚Åª¬≥ (conduction electron density)</span>
v_F = <span class="number">1.57e6</span>     <span class="comment"># m/s (Fermi velocity)</span>
n_imp = <span class="number">1e24</span>     <span class="comment"># m‚Åª¬≥ (impurity density)</span>
sigma_tr = <span class="number">1e-19</span>  <span class="comment"># m¬≤ (transport cross section)</span>

rho, tau = resistivity_from_scattering(n_imp, sigma_tr, n_e, v_F)

<span class="comment"># Relaxation time and mean free path</span>
l_mfp = v_F * tau  <span class="comment"># Mean free path</span>

<span class="function">print</span>(<span class="string">"Microscopic calculation of electrical resistivity:"</span>)
<span class="function">print</span>(<span class="string">"=" * 50</span>)
<span class="function">print</span>(<span class="string">f"Conduction electron density: {n_e:.2e} m‚Åª¬≥"</span>)
<span class="function">print</span>(<span class="string">f"Impurity density: {n_imp:.2e} m‚Åª¬≥"</span>)
<span class="function">print</span>(<span class="string">f"Transport cross section: {sigma_tr:.2e} m¬≤"</span>)
<span class="function">print</span>(<span class="string">f"\nRelaxation time œÑ: {tau:.2e} s"</span>)
<span class="function">print</span>(<span class="string">f"Mean free path: {l_mfp*1e9:.2f} nm"</span>)
<span class="function">print</span>(<span class="string">f"Electrical resistivity œÅ: {rho:.2e} Œ©¬∑m"</span>)
<span class="function">print</span>(<span class="string">f"Electrical conductivity œÉ: {1/rho:.2e} S/m"</span>)</code></pre></div>
<div class="output">Microscopic calculation of electrical resistivity:
==================================================
Conduction electron density: 8.50e+28 m‚Åª¬≥
Impurity density: 1.00e+24 m‚Åª¬≥
Transport cross section: 1.00e-19 m¬≤

Relaxation time œÑ: 6.37e-15 s
Mean free path: 10.00 nm
Electrical resistivity œÅ: 1.32e-08 Œ©¬∑m
Electrical conductivity œÉ: 7.58e+07 S/m</div>
<div class="code-title">Example 8: Matthiessen's Rule for Phonon Scattering</div>
<div class="code-example"><pre><code class="language-python"><span class="keyword">import</span> numpy <span class="keyword">as</span> np

<span class="comment"># ===================================</span>
<span class="comment"># Matthiessen's rule: œÅ_total = œÅ_imp + œÅ_ph(T)</span>
<span class="comment"># ===================================</span>

<span class="keyword">def</span> <span class="function">phonon_scattering_rate</span>(T, theta_D):
    <span class="string">"""Relaxation rate due to phonon scattering

    œÑ_ph‚Åª¬π ‚àù T‚Åµ (T &lt;&lt; Œ∏_D)
    œÑ_ph‚Åª¬π ‚àù T (T &gt;&gt; Œ∏_D)
    """</span>
    <span class="keyword">if</span> T &lt; <span class="number">0.1</span> * theta_D:
        <span class="comment"># Low temperature (Bloch-Gr√ºneisen regime)</span>
        tau_ph_inv = <span class="number">1e12</span> * (T / theta_D)**<span class="number">5</span>
    <span class="keyword">else</span>:
        <span class="comment"># High temperature (linear regime)</span>
        tau_ph_inv = <span class="number">1e13</span> * (T / theta_D)

    <span class="keyword">return</span> tau_ph_inv

<span class="keyword">def</span> <span class="function">total_resistivity</span>(T, rho_imp, theta_D, rho0_ph):
    <span class="string">"""Total resistivity (Matthiessen's rule)"""</span>
    tau_ph_inv = phonon_scattering_rate(T, theta_D)
    rho_ph = rho0_ph * (tau_ph_inv / <span class="number">1e13</span>)  <span class="comment"># Normalization</span>

    <span class="keyword">return</span> rho_imp + rho_ph

<span class="comment"># Parameters for copper</span>
theta_D = <span class="number">343</span>      <span class="comment"># K (Debye temperature)</span>
rho_imp = <span class="number">1e-9</span>    <span class="comment"># Œ©¬∑m (residual resistivity)</span>
rho0_ph = <span class="number">1.7e-8</span>  <span class="comment"># Œ©¬∑m (phonon contribution at room temperature)</span>

temperatures = [<span class="number">10</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>]

<span class="function">print</span>(<span class="string">"Resistivity by Matthiessen's rule:"</span>)
<span class="function">print</span>(<span class="string">"=" * 60</span>)
<span class="function">print</span>(<span class="string">f"{'T (K)':&lt;10} {'œÅ_imp (Œ©¬∑m)':&lt;20} {'œÅ_ph (Œ©¬∑m)':&lt;20} {'œÅ_total':&lt;15}"</span>)
<span class="function">print</span>(<span class="string">"-" * 60</span>)

<span class="keyword">for</span> T <span class="keyword">in</span> temperatures:
    rho_ph = total_resistivity(T, <span class="number">0</span>, theta_D, rho0_ph) - <span class="number">0</span>
    rho_tot = total_resistivity(T, rho_imp, theta_D, rho0_ph)

    <span class="function">print</span>(<span class="string">f"{T:&lt;10} {rho_imp:&lt;20.2e} {rho_ph:&lt;20.2e} {rho_tot:&lt;15.2e}"</span>)</code></pre></div>
<div class="output">Resistivity by Matthiessen's rule:
============================================================
T (K)      œÅ_imp (Œ©¬∑m)          œÅ_ph (Œ©¬∑m)           œÅ_total
------------------------------------------------------------
10         1.00e-09             4.49e-13             1.00e-09
50         1.00e-09             2.81e-10             1.28e-09
100        1.00e-09             5.64e-09             6.64e-09
200        1.00e-09             9.91e-09             1.09e-08
300        1.00e-09             1.49e-08             1.59e-08</div>
<h2>Exercises</h2>
<div class="exercise">
<h3>Easy (Basic)</h3>
<p><strong>Q1</strong>: Derive the differential equation satisfied by the time evolution operator \(U_I(t, t_0)\) in the interaction picture.</p>
<details>
<summary>View Answer</summary>
<p><strong>Derivation</strong>:</p>
<p>\[
                    i\frac{d}{dt}|\psi_I(t)\rangle = H_I(t)|\psi_I(t)\rangle
                    \]</p>
<p>Since \(|\psi_I(t)\rangle = U_I(t, t_0)|\psi_I(t_0)\rangle\):</p>
<p>\[
                    i\frac{\partial U_I}{\partial t} = H_I(t) U_I(t, t_0)
                    \]</p>
<p>Initial condition: \(U_I(t_0, t_0) = 1\)</p>
</details>
</div>
<div class="exercise">
<h3>Medium (Application)</h3>
<p><strong>Q2</strong>: Using Wick's theorem, count the number of different pairings for the 6-point function \(\langle 0|T\{\phi_1\cdots\phi_6\}|0\rangle\).</p>
<details>
<summary>View Answer</summary>
<p><strong>Calculation</strong>:</p>
<p>Number of ways to divide 6 fields into 3 pairs:</p>
<p>\[
                    \frac{6!}{2^3 \cdot 3!} = \frac{720}{8 \cdot 6} = 15
                    \]</p>
<p>In general, the number of pairings for a \(2n\)-point function is \((2n-1)!! = (2n-1)(2n-3)\cdots 3 \cdot 1\)</p>
</details>
</div>
<div class="exercise">
<h3>Hard (Advanced)</h3>
<p><strong>Q3</strong>: Using the LSZ formula, show that the 2‚Üí2 scattering amplitude at tree level in œÜ‚Å¥ theory is \(\mathcal{M} = -\lambda\).</p>
<details>
<summary>View Answer</summary>
<p><strong>Derivation</strong>:</p>
<p>From the LSZ formula, putting external lines on-shell:</p>
<p>\[
                    \langle p_3, p_4|S|p_1, p_2\rangle \propto \langle 0|T\{\phi\phi\phi\phi\}|0\rangle_{\text{1PI}}
                    \]</p>
<p>At tree level, only the 4-point vertex contributes:</p>
<p>\[
                    H_I = \int d^4x \, \frac{\lambda}{4!}\phi^4
                    \]</p>
<p>First-order term of S-matrix:</p>
<p>\[
                    S^{(1)} = -i\int d^4x \, \frac{\lambda}{4!}\phi^4
                    \]</p>
<p>Contracting the four fields to external lines with Wick's theorem, the combinatorial factor \(4!\) cancels to give:</p>
<p>\[
                    \mathcal{M} = -\lambda
                    \]</p>
</details>
</div>
<div class="nav-buttons">
<a class="nav-button" href="chapter-2.html">‚Üê Chapter 2</a>
<a class="nav-button" href="chapter-4.html">Chapter 4 ‚Üí</a>
</div>
<h2>References</h2>
<ol>
<li>Peskin, M. E., &amp; Schroeder, D. V. (1995). <em>An Introduction to Quantum Field Theory</em>. Westview Press.</li>
<li>Weinberg, S. (1995). <em>The Quantum Theory of Fields, Vol. 1</em>. Cambridge University Press.</li>
<li>Schwartz, M. D. (2014). <em>Quantum Field Theory and the Standard Model</em>. Cambridge University Press.</li>
<li>Mahan, G. D. (2000). <em>Many-Particle Physics</em> (3rd ed.). Springer.</li>
</ol>
</div>
</div>
<footer>
<p>¬© 2025 AI Terakoya - Fundamentals of Mathematics &amp; Physics Dojo</p>
<p style="margin-top: 0.5rem;">Licensed under CC BY 4.0</p>
</footer>
<script>
        mermaid.initialize({ startOnLoad: true, theme: 'base' });
    </script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
</body>
</html>
