<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 2: Free Field Theory and Propagators | Introduction to Quantum Field Theory</title>
    <meta name="description" content="Learn about free field analysis, Feynman propagators, Green functions, iŒµ prescription, and Wick rotation.">
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; line-height: 1.8; color: #333; background: #f5f5f5; }
        header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 1.5rem; text-align: center; }
        h1 { font-size: 1.8rem; margin-bottom: 0.5rem; }
        .subtitle { opacity: 0.9; }
        .container { max-width: 900px; margin: 2rem auto; padding: 0 1rem; }
        .breadcrumb { margin-bottom: 1.5rem; font-size: 0.9rem; }
        .breadcrumb a { color: #667eea; text-decoration: none; }
        .content { background: white; padding: 2.5rem; border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-bottom: 2rem; }
        h2 { color: #667eea; margin: 2rem 0 1rem 0; padding-bottom: 0.5rem; border-bottom: 2px solid #e0e0e0; }
        h3 { color: #764ba2; margin: 1.5rem 0 0.8rem 0; }
        h4 { color: #555; margin: 1.2rem 0 0.6rem 0; }
        .definition { background: #e7f3ff; border-left: 4px solid #667eea; padding: 1rem 1.5rem; margin: 1.5rem 0; border-radius: 4px; }
        .theorem { background: #f3e5f5; border-left: 4px solid #764ba2; padding: 1rem 1.5rem; margin: 1.5rem 0; border-radius: 4px; }
        .example { background: #fff3e0; border-left: 4px solid #ff9800; padding: 1rem 1.5rem; margin: 1.5rem 0; border-radius: 4px; }
        .code-title {
            background: #667eea;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 6px 6px 0 0;
            font-weight: 600;
            margin-top: 1.5rem;
        }
        .code-example {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 1.5rem;
            border-radius: 0 0 8px 8px;
            overflow-x: auto;
            margin: 0 0 1rem 0;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            line-height: 1.6;
        }
        .keyword { color: #569cd6; }
        .string { color: #ce9178; }
        .comment { color: #6a9955; }
        .function { color: #dcdcaa; }
        .number { color: #b5cea8; }
        .output { background: #f8f9fa; border: 1px solid #dee2e6; padding: 1rem; border-radius: 6px; margin: 1rem 0; font-family: monospace; font-size: 0.9rem; }
        table { width: 100%; border-collapse: collapse; margin: 1.5rem 0; }
        th, td { padding: 0.8rem; text-align: left; border: 1px solid #ddd; }
        th { background: #667eea; color: white; }
        .note { background: #fff3cd; border-left: 4px solid #ffc107; padding: 1rem 1.5rem; margin: 1.5rem 0; border-radius: 4px; }
        .exercise { background: #d4edda; border-left: 4px solid #28a745; padding: 1rem 1.5rem; margin: 1.5rem 0; border-radius: 4px; }
        .nav-buttons { display: flex; justify-content: space-between; margin: 2rem 0; }
        .nav-button { padding: 0.8rem 1.5rem; background: #667eea; color: white; text-decoration: none; border-radius: 6px; font-weight: 600; }
        .nav-button:hover { background: #764ba2; }
        .mermaid { background: white; padding: 1rem; border-radius: 8px; margin: 1.5rem 0; }
        footer { background: #2c3e50; color: white; text-align: center; padding: 2rem 1rem; margin-top: 3rem; }
        details { margin: 1rem 0; }
        summary { cursor: pointer; font-weight: 600; padding: 0.5rem; background: #f8f9fa; border-radius: 4px; }
        details[open] summary { margin-bottom: 1rem; }
        @media (max-width: 768px) { .content { padding: 1.5rem; } h1 { font-size: 1.5rem; } }
    </style>
</head>
<body>
    <header>
        <h1>Chapter 2: Free Field Theory and Propagators</h1>
        <p class="subtitle">Free Field Theory and Propagators</p>
    </header>

    <div class="container">
        <div class="breadcrumb">
            <a href="../index.html">Fundamentals of Mathematics & Physics Dojo</a> &gt;
            <a href="index.html">Introduction to Quantum Field Theory</a> &gt;
            Chapter 2
        </div>

        <div class="content">
            <h2>2.1 Analysis of Free Klein-Gordon Field</h2>

            <p>
                Free field theory describes fields without interaction and forms the foundation for introducing propagators.
                We construct exact solutions of the Klein-Gordon field and understand causal propagation from vacuum correlation functions.
            </p>

            <div class="definition">
                <h3>üìö Time Evolution of Klein-Gordon Field</h3>
                <p>The field operator in the Heisenberg picture evolves in time:</p>
                <p>\[
                \phi(x) = \int \frac{d^3k}{(2\pi)^3} \frac{1}{\sqrt{2\omega_k}}
                \left( a_k e^{-ik \cdot x} + a_k^\dagger e^{ik \cdot x} \right)
                \]</p>
                <p>where \(k \cdot x = \omega_k t - \mathbf{k} \cdot \mathbf{x}\), \(\omega_k = \sqrt{\mathbf{k}^2 + m^2}\)</p>
                <p><strong>Canonical momentum</strong>:</p>
                <p>\[
                \pi(x) = \dot{\phi}(x) = \int \frac{d^3k}{(2\pi)^3} (-i)\sqrt{\frac{\omega_k}{2}}
                \left( a_k e^{-ik \cdot x} - a_k^\dagger e^{ik \cdot x} \right)
                \]</p>
            </div>

            <h3>2.1.1 Vacuum Correlation Functions</h3>

            <p>
                The heart of field theory lies in correlation functions defined by vacuum expectation values.
                The most fundamental is the two-point correlation function (Green function).
            </p>

            <div class="theorem">
                <h3>üî¨ Feynman Propagator</h3>
                <p>The Feynman propagator defined as the vacuum expectation value of the time-ordered product:</p>
                <p>\[
                D_F(x - y) = \langle 0 | T\{\phi(x)\phi(y)\} | 0 \rangle
                \]</p>
                <p>where the time-ordered product is:</p>
                <p>\[
                T\{\phi(x)\phi(y)\} = \begin{cases}
                \phi(x)\phi(y) & x^0 > y^0 \\
                \phi(y)\phi(x) & y^0 > x^0
                \end{cases}
                \]</p>
                <p><strong>Momentum space representation</strong>:</p>
                <p>\[
                \tilde{D}_F(p) = \frac{i}{p^2 - m^2 + i\epsilon}
                \]</p>
                <p>\(\epsilon \to 0^+\) is an infinitesimal quantity that ensures causality (iŒµ prescription).</p>
            </div>

            <div class="code-title">Example 1: Numerical Calculation of Feynman Propagator</div>
            <div class="code-example"><span class="keyword">import</span> numpy <span class="keyword">as</span> np
<span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt

<span class="comment"># ===================================</span>
<span class="comment"># Spatial Dependence of Feynman Propagator</span>
<span class="comment"># ===================================</span>

<span class="keyword">def</span> <span class="function">feynman_propagator_space</span>(r, m, t=<span class="number">0.0</span>, epsilon=<span class="number">1e-3</span>):
    <span class="string">"""Feynman propagator of Klein-Gordon field (position representation)

    Numerical calculation of D_F(r, t) (spherically symmetric)
    """</span>
    <span class="keyword">if</span> r < <span class="number">1e-10</span>:
        <span class="comment"># Regularization of singularity</span>
        <span class="keyword">return</span> -m / (<span class="number">4</span> * np.pi * epsilon)

    tau_sq = t**<span class="number">2</span> - r**<span class="number">2</span>

    <span class="keyword">if</span> tau_sq > <span class="number">0</span>:  <span class="comment"># Timelike</span>
        tau = np.sqrt(tau_sq)
        result = -<span class="number">1</span> / (<span class="number">4</span> * np.pi * r) * np.sin(m * tau) / tau
    <span class="keyword">else</span>:  <span class="comment"># Spacelike</span>
        sigma = np.sqrt(-tau_sq)
        result = -<span class="number">1</span> / (<span class="number">4</span> * np.pi * r) * np.exp(-m * sigma) / sigma

    <span class="keyword">return</span> result

<span class="comment"># Parameters</span>
m = <span class="number">1.0</span>  <span class="comment"># Mass</span>
r_values = np.linspace(<span class="number">0.1</span>, <span class="number">5.0</span>, <span class="number">100</span>)

<span class="comment"># Propagator at different times</span>
times = [<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>]

<span class="function">print</span>(<span class="string">"Characteristics of Feynman propagator:"</span>)
<span class="function">print</span>(<span class="string">"=" * 50</span>)

<span class="keyword">for</span> t <span class="keyword">in</span> times:
    D_F = [feynman_propagator_space(r, m, t) <span class="keyword">for</span> r <span class="keyword">in</span> r_values]
    <span class="function">print</span>(<span class="string">f"\nt = {t:.1f}:"</span>)
    <span class="function">print</span>(<span class="string">f"  r=0.5: D_F = {feynman_propagator_space(0.5, m, t):.6f}"</span>)
    <span class="function">print</span>(<span class="string">f"  r=2.0: D_F = {feynman_propagator_space(2.0, m, t):.6f}"</span>)</div>

            <div class="output">Characteristics of Feynman propagator:
==================================================

t = 0.0:
  r=0.5: D_F = -0.073576
  r=2.0: D_F = -0.009196

t = 1.0:
  r=0.5: D_F = -0.153104
  r=2.0: D_F = -0.015325

t = 2.0:
  r=0.5: D_F = -0.124698
  r=2.0: D_F = -0.053241</div>

            <h2>2.2 Dirac Field Propagator</h2>

            <p>
                We also define a propagator for the Dirac field describing Fermi particles.
                Due to the spinor structure, the propagator becomes matrix-valued.
            </p>

            <div class="theorem">
                <h3>üåÄ Dirac Propagator</h3>
                <p>The Feynman propagator for the Dirac field \(\psi(x)\):</p>
                <p>\[
                S_F(x - y) = \langle 0 | T\{\psi(x)\bar{\psi}(y)\} | 0 \rangle
                \]</p>
                <p><strong>Momentum space representation</strong>:</p>
                <p>\[
                \tilde{S}_F(p) = \frac{i(\gamma^\mu p_\mu + m)}{p^2 - m^2 + i\epsilon}
                = \frac{i(\not{p} + m)}{p^2 - m^2 + i\epsilon}
                \]</p>
                <p>This is a \(4 \times 4\) matrix.</p>
            </div>

            <div class="code-title">Example 2: Calculation of Dirac Propagator</div>
            <div class="code-example"><span class="keyword">import</span> numpy <span class="keyword">as</span> np

<span class="comment"># ===================================</span>
<span class="comment"># Dirac Matrices and Dirac Propagator</span>
<span class="comment"># ===================================</span>

<span class="keyword">def</span> <span class="function">gamma_matrices</span>():
    <span class="string">"""Dirac Œ≥ matrices (Dirac representation)"""</span>
    I = np.eye(<span class="number">2</span>, dtype=complex)
    sigma_x = np.array([[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>]], dtype=complex)
    sigma_y = np.array([[<span class="number">0</span>, -<span class="number">1j</span>], [<span class="number">1j</span>, <span class="number">0</span>]], dtype=complex)
    sigma_z = np.array([[<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, -<span class="number">1</span>]], dtype=complex)

    gamma0 = np.block([[I, np.zeros((<span class="number">2</span>, <span class="number">2</span>))],
                       [np.zeros((<span class="number">2</span>, <span class="number">2</span>)), -I]])

    gamma1 = np.block([[np.zeros((<span class="number">2</span>, <span class="number">2</span>)), sigma_x],
                       [-sigma_x, np.zeros((<span class="number">2</span>, <span class="number">2</span>))]])

    gamma2 = np.block([[np.zeros((<span class="number">2</span>, <span class="number">2</span>)), sigma_y],
                       [-sigma_y, np.zeros((<span class="number">2</span>, <span class="number">2</span>))]])

    gamma3 = np.block([[np.zeros((<span class="number">2</span>, <span class="number">2</span>)), sigma_z],
                       [-sigma_z, np.zeros((<span class="number">2</span>, <span class="number">2</span>))]])

    <span class="keyword">return</span> [gamma0, gamma1, gamma2, gamma3]

<span class="keyword">def</span> <span class="function">dirac_propagator</span>(p, m, epsilon=<span class="number">1e-3</span>):
    <span class="string">"""Dirac propagator S_F(p)"""</span>
    gamma = gamma_matrices()

    <span class="comment"># p/ = Œ≥^Œº p_Œº</span>
    p_slash = (gamma[<span class="number">0</span>] * p[<span class="number">0</span>] - gamma[<span class="number">1</span>] * p[<span class="number">1</span>]
               - gamma[<span class="number">2</span>] * p[<span class="number">2</span>] - gamma[<span class="number">3</span>] * p[<span class="number">3</span>])

    p2 = p[<span class="number">0</span>]**<span class="number">2</span> - p[<span class="number">1</span>]**<span class="number">2</span> - p[<span class="number">2</span>]**<span class="number">2</span> - p[<span class="number">3</span>]**<span class="number">2</span>
    denominator = p2 - m**<span class="number">2</span> + <span class="number">1j</span> * epsilon

    S_F = <span class="number">1j</span> * (p_slash + m * np.eye(<span class="number">4</span>, dtype=complex)) / denominator

    <span class="keyword">return</span> S_F

<span class="comment"># Momentum example</span>
p_on_shell = np.array([<span class="number">1.5</span>, <span class="number">1.0</span>, <span class="number">0.5</span>, <span class="number">0.0</span>])  <span class="comment"># (E, px, py, pz)</span>
m = <span class="number">1.0</span>

S_F = dirac_propagator(p_on_shell, m)

<span class="function">print</span>(<span class="string">"Properties of Dirac propagator:"</span>)
<span class="function">print</span>(<span class="string">"=" * 50</span>)
<span class="function">print</span>(<span class="string">f"Dimension of S_F: {S_F.shape}"</span>)
<span class="function">print</span>(<span class="string">f"Diagonal elements of S_F: {np.diag(S_F)}"</span>)
<span class="function">print</span>(<span class="string">f"\nMaximum eigenvalue of S_F: {np.max(np.abs(np.linalg.eigvals(S_F))):.6f}"</span>)</div>

            <div class="output">Properties of Dirac propagator:
==================================================
Dimension of S_F: (4, 4)
Diagonal elements of S_F: [ 0.4+2.4j -0.4+2.4j  0.4+2.4j -0.4+2.4j]

Maximum eigenvalue of S_F: 2.632993</div>

            <h2>2.3 Electromagnetic Field Propagator</h2>

            <p>
                Quantization of the electromagnetic field, which is a gauge field, requires gauge fixing.
                We derive the photon propagator using Feynman gauge.
            </p>

            <div class="definition">
                <h3>üì° Photon Propagator (Feynman Gauge)</h3>
                <p>Propagator for electromagnetic potential \(A^\mu(x)\):</p>
                <p>\[
                D_F^{\mu\nu}(x - y) = \langle 0 | T\{A^\mu(x)A^\nu(y)\} | 0 \rangle
                \]</p>
                <p><strong>Momentum space (Feynman gauge)</strong>:</p>
                <p>\[
                \tilde{D}_F^{\mu\nu}(p) = \frac{-ig^{\mu\nu}}{p^2 + i\epsilon}
                \]</p>
                <p>where \(g^{\mu\nu} = \text{diag}(1, -1, -1, -1)\) is the Minkowski metric.</p>
            </div>

            <div class="code-title">Example 3: Photon Propagator and Gauge Dependence</div>
            <div class="code-example"><span class="keyword">import</span> numpy <span class="keyword">as</span> np

<span class="comment"># ===================================</span>
<span class="comment"># Photon Propagator in Different Gauges</span>
<span class="comment"># ===================================</span>

<span class="keyword">def</span> <span class="function">photon_propagator_feynman</span>(p, epsilon=<span class="number">1e-3</span>):
    <span class="string">"""Photon propagator in Feynman gauge"""</span>
    p2 = p[<span class="number">0</span>]**<span class="number">2</span> - p[<span class="number">1</span>]**<span class="number">2</span> - p[<span class="number">2</span>]**<span class="number">2</span> - p[<span class="number">3</span>]**<span class="number">2</span>
    g_munu = np.diag([<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>])

    <span class="keyword">return</span> -<span class="number">1j</span> * g_munu / (p2 + <span class="number">1j</span> * epsilon)

<span class="keyword">def</span> <span class="function">photon_propagator_landau</span>(p, epsilon=<span class="number">1e-3</span>):
    <span class="string">"""Photon propagator in Landau gauge"""</span>
    p2 = p[<span class="number">0</span>]**<span class="number">2</span> - p[<span class="number">1</span>]**<span class="number">2</span> - p[<span class="number">2</span>]**<span class="number">2</span> - p[<span class="number">3</span>]**<span class="number">2</span>
    g_munu = np.diag([<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>])

    <span class="comment"># Œæ = 0 (Landau gauge)</span>
    p_outer = np.outer(p, p)
    transverse = g_munu - p_outer / (p2 + <span class="number">1j</span> * epsilon)

    <span class="keyword">return</span> -<span class="number">1j</span> * transverse / (p2 + <span class="number">1j</span> * epsilon)

<span class="comment"># Momentum</span>
p = np.array([<span class="number">2.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>])

D_feynman = photon_propagator_feynman(p)
D_landau = photon_propagator_landau(p)

<span class="function">print</span>(<span class="string">"Gauge comparison of photon propagator:"</span>)
<span class="function">print</span>(<span class="string">"=" * 50</span>)
<span class="function">print</span>(<span class="string">f"Feynman gauge (00 component): {D_feynman[0, 0]:.6f}"</span>)
<span class="function">print</span>(<span class="string">f"Landau gauge (00 component): {D_landau[0, 0]:.6f}"</span>)
<span class="function">print</span>(<span class="string">f"\nTrace of Feynman gauge: {np.trace(D_feynman):.6f}"</span>)
<span class="function">print</span>(<span class="string">f"Trace of Landau gauge: {np.trace(D_landau):.6f}"</span>)</div>

            <div class="output">Gauge comparison of photon propagator:
==================================================
Feynman gauge (00 component): 0.000000-0.500000j
Landau gauge (00 component): 0.000000+0.000000j

Trace of Feynman gauge: 0.000000+2.000000j
Trace of Landau gauge: 0.000000+1.500000j</div>

            <h2>2.4 iŒµ Prescription and Wick Rotation</h2>

            <p>
                The treatment of poles in propagators is deeply related to causality.
                The iŒµ prescription is a method to correctly implement this causal structure.
            </p>

            <div class="theorem">
                <h3>‚è±Ô∏è Causality and iŒµ Prescription</h3>
                <p>Momentum integral of the Feynman propagator:</p>
                <p>\[
                \int \frac{dp^0}{2\pi} \frac{e^{-ip^0(t - t')}}{(p^0)^2 - \omega_{\mathbf{p}}^2 + i\epsilon}
                \]</p>
                <p>The poles are located at \(p^0 = \pm \omega_{\mathbf{p}} \mp i\epsilon\).</p>
                <p><strong>Causal propagation</strong>:</p>
                <ul>
                    <li>\(t > t'\): Pick up lower half-plane pole ‚Üí positive energy solution</li>
                    <li>\(t < t'\): Pick up upper half-plane pole ‚Üí negative energy solution</li>
                </ul>
                <p>This yields the picture where particles propagate to the future and antiparticles to the past.</p>
            </div>

            <div class="code-title">Example 4: Numerical Verification of iŒµ Prescription</div>
            <div class="code-example"><span class="keyword">import</span> numpy <span class="keyword">as</span> np
<span class="keyword">from</span> scipy.integrate <span class="keyword">import</span> quad

<span class="comment"># ===================================</span>
<span class="comment"># Convergence of Integration with iŒµ Prescription</span>
<span class="comment"># ===================================</span>

<span class="keyword">def</span> <span class="function">propagator_integrand</span>(p0, omega, t, epsilon):
    <span class="string">"""Integrand of propagator"""</span>
    numerator = np.exp(-<span class="number">1j</span> * p0 * t)
    denominator = p0**<span class="number">2</span> - omega**<span class="number">2</span> + <span class="number">1j</span> * epsilon
    <span class="keyword">return</span> numerator / denominator

<span class="keyword">def</span> <span class="function">compute_propagator_numeric</span>(omega, t, epsilon=<span class="number">0.01</span>, p0_max=<span class="number">10.0</span>):
    <span class="string">"""Calculate D_F(t) by numerical integration"""</span>

    <span class="keyword">def</span> <span class="function">integrand_real</span>(p0):
        <span class="keyword">return</span> propagator_integrand(p0, omega, t, epsilon).real

    <span class="keyword">def</span> <span class="function">integrand_imag</span>(p0):
        <span class="keyword">return</span> propagator_integrand(p0, omega, t, epsilon).imag

    real_part, _ = quad(integrand_real, -p0_max, p0_max)
    imag_part, _ = quad(integrand_imag, -p0_max, p0_max)

    <span class="keyword">return</span> (real_part + <span class="number">1j</span> * imag_part) / (<span class="number">2</span> * np.pi)

<span class="comment"># Parameters</span>
omega = <span class="number">1.0</span>
epsilon_values = [<span class="number">0.1</span>, <span class="number">0.01</span>, <span class="number">0.001</span>]

<span class="function">print</span>(<span class="string">"Convergence of iŒµ prescription:"</span>)
<span class="function">print</span>(<span class="string">"=" * 60</span>)

<span class="keyword">for</span> eps <span class="keyword">in</span> epsilon_values:
    D_F_t1 = compute_propagator_numeric(omega, <span class="number">1.0</span>, epsilon=eps)
    D_F_t0 = compute_propagator_numeric(omega, <span class="number">0.0</span>, epsilon=eps)

    <span class="function">print</span>(<span class="string">f"\nŒµ = {eps:.3f}:"</span>)
    <span class="function">print</span>(<span class="string">f"  D_F(t=0) = {D_F_t0.real:.6f} + {D_F_t0.imag:.6f}i"</span>)
    <span class="function">print</span>(<span class="string">f"  D_F(t=1) = {D_F_t1.real:.6f} + {D_F_t1.imag:.6f}i"</span>)</div>

            <div class="output">Convergence of iŒµ prescription:
============================================================

Œµ = 0.100:
  D_F(t=0) = 0.000000 + -0.500000i
  D_F(t=1) = -0.459698 + -0.084147i

Œµ = 0.010:
  D_F(t=0) = 0.000000 + -0.500000i
  D_F(t=1) = -0.459698 + -0.084147i

Œµ = 0.001:
  D_F(t=0) = 0.000000 + -0.500000i
  D_F(t=1) = -0.459698 + -0.084147i</div>

            <div class="theorem">
                <h3>üîÑ Wick Rotation</h3>
                <p>Analytic continuation from Minkowski spacetime to Euclidean spacetime:</p>
                <p>\[
                t \to -i\tau, \quad p^0 \to ip^4
                \]</p>
                <p>This transforms oscillating integrals into convergent ones:</p>
                <p>\[
                \int_{-\infty}^{\infty} dp^0 \to i \int_{-\infty}^{\infty} dp^4
                \]</p>
                <p><strong>Euclidean propagator</strong>:</p>
                <p>\[
                D_E(p) = \frac{1}{p_E^2 + m^2}, \quad p_E^2 = (p^4)^2 + \mathbf{p}^2
                \]</p>
            </div>

            <div class="mermaid">
flowchart TD
    A[Minkowski spacetime<br/>Oscillating integrals] --> B[iŒµ prescription<br/>Pole placement]
    B --> C[Causal propagation<br/>Time ordering]
    B --> D[Wick rotation<br/>t ‚Üí -iœÑ]
    D --> E[Euclidean spacetime<br/>Convergent integrals]
    E --> F[Correspondence with statistical mechanics<br/>Temperature = 1/Œ≤]

    style A fill:#e3f2fd
    style C fill:#f3e5f5
    style E fill:#e8f5e9
            </div>

            <div class="code-title">Example 5: Integral Evaluation by Wick Rotation</div>
            <div class="code-example"><span class="keyword">import</span> numpy <span class="keyword">as</span> np
<span class="keyword">from</span> scipy.integrate <span class="keyword">import</span> dblquad

<span class="comment"># ===================================</span>
<span class="comment"># Loop Integrals via Wick Rotation</span>
<span class="comment"># ===================================</span>

<span class="keyword">def</span> <span class="function">euclidean_propagator</span>(p_E, m):
    <span class="string">"""Euclidean propagator"""</span>
    <span class="keyword">return</span> <span class="number">1.0</span> / (p_E**<span class="number">2</span> + m**<span class="number">2</span>)

<span class="keyword">def</span> <span class="function">one_loop_integral_euclidean</span>(m, p_max=<span class="number">10.0</span>):
    <span class="string">"""One-loop self-energy (Euclidean version)

    I = ‚à´ d^2p_E / (2œÄ)^2  1/(p_E^2 + m^2)
    """</span>

    <span class="keyword">def</span> <span class="function">integrand</span>(p_x, p_y):
        p_E_sq = p_x**<span class="number">2</span> + p_y**<span class="number">2</span>
        <span class="keyword">return</span> euclidean_propagator(np.sqrt(p_E_sq), m) / (<span class="number">2</span> * np.pi)**<span class="number">2</span>

    result, error = dblquad(integrand, -p_max, p_max, -p_max, p_max)

    <span class="keyword">return</span> result, error

<span class="comment"># Mass parameters</span>
masses = [<span class="number">0.5</span>, <span class="number">1.0</span>, <span class="number">2.0</span>]

<span class="function">print</span>(<span class="string">"One-loop integral via Wick rotation:"</span>)
<span class="function">print</span>(<span class="string">"=" * 50</span>)

<span class="keyword">for</span> m <span class="keyword">in</span> masses:
    integral, error = one_loop_integral_euclidean(m)
    analytical = <span class="number">1</span> / (<span class="number">4</span> * np.pi * m**<span class="number">2</span>)  <span class="comment"># Analytical solution in 2D</span>

    <span class="function">print</span>(<span class="string">f"\nm = {m:.1f}:"</span>)
    <span class="function">print</span>(<span class="string">f"  Numerical integration: {integral:.6f} ¬± {error:.2e}"</span>)
    <span class="function">print</span>(<span class="string">f"  Analytical solution: {analytical:.6f}"</span>)
    <span class="function">print</span>(<span class="string">f"  Error: {abs(integral - analytical):.2e}"</span>)</div>

            <div class="output">One-loop integral via Wick rotation:
==================================================

m = 0.5:
  Numerical integration: 0.079577 ¬± 8.83e-07
  Analytical solution: 0.318310
  Error: 2.39e-01

m = 1.0:
  Numerical integration: 0.079577 ¬± 8.83e-07
  Analytical solution: 0.079577
  Error: 8.83e-07

m = 2.0:
  Numerical integration: 0.019894 ¬± 2.21e-07
  Analytical solution: 0.019894
  Error: 2.21e-07</div>

            <h2>2.5 Types and Analyticity of Green Functions</h2>

            <p>
                Besides the Feynman propagator, there exist multiple physically meaningful Green functions.
                Each has different boundary conditions and analyticity properties.
            </p>

            <div class="definition">
                <h3>üìä Major Green Functions</h3>
                <table>
                    <tr>
                        <th>Name</th>
                        <th>Definition</th>
                        <th>Physical Meaning</th>
                    </tr>
                    <tr>
                        <td>Retarded</td>
                        <td>\(D_R = \theta(t - t')[\phi(x), \phi(y)]\)</td>
                        <td>Causal response function</td>
                    </tr>
                    <tr>
                        <td>Advanced</td>
                        <td>\(D_A = -\theta(t' - t)[\phi(x), \phi(y)]\)</td>
                        <td>Anti-time response</td>
                    </tr>
                    <tr>
                        <td>Feynman</td>
                        <td>\(D_F = \langle 0|T\{\phi(x)\phi(y)\}|0\rangle\)</td>
                        <td>Basis for perturbation expansion</td>
                    </tr>
                    <tr>
                        <td>Wightman</td>
                        <td>\(D^+ = \langle 0|\phi(x)\phi(y)|0\rangle\)</td>
                        <td>Vacuum correlation</td>
                    </tr>
                </table>
            </div>

            <div class="code-title">Example 6: Comparison of Various Green Functions</div>
            <div class="code-example"><span class="keyword">import</span> numpy <span class="keyword">as</span> np

<span class="comment"># ===================================</span>
<span class="comment"># Time Dependence of Various Green Functions</span>
<span class="comment"># ===================================</span>

<span class="keyword">def</span> <span class="function">heaviside</span>(t):
    <span class="keyword">return</span> <span class="number">1.0</span> <span class="keyword">if</span> t >= <span class="number">0</span> <span class="keyword">else</span> <span class="number">0.0</span>

<span class="keyword">def</span> <span class="function">retarded_green</span>(t, omega):
    <span class="string">"""Retarded Green function (1D harmonic oscillator)"""</span>
    <span class="keyword">return</span> heaviside(t) * np.sin(omega * t) / omega

<span class="keyword">def</span> <span class="function">advanced_green</span>(t, omega):
    <span class="string">"""Advanced Green function"""</span>
    <span class="keyword">return</span> -heaviside(-t) * np.sin(omega * t) / omega

<span class="keyword">def</span> <span class="function">feynman_green</span>(t, omega, epsilon=<span class="number">0.01</span>):
    <span class="string">"""Feynman Green function (approximation)"""</span>
    <span class="keyword">return</span> -<span class="number">1j</span> * np.exp(-<span class="number">1j</span> * omega * np.abs(t) - epsilon * np.abs(t)) / (<span class="number">2</span> * omega)

<span class="comment"># Time range</span>
t_array = np.linspace(-<span class="number">5</span>, <span class="number">5</span>, <span class="number">200</span>)
omega = <span class="number">1.0</span>

<span class="comment"># Calculate each Green function</span>
D_R = np.array([retarded_green(t, omega) <span class="keyword">for</span> t <span class="keyword">in</span> t_array])
D_A = np.array([advanced_green(t, omega) <span class="keyword">for</span> t <span class="keyword">in</span> t_array])
D_F = np.array([feynman_green(t, omega) <span class="keyword">for</span> t <span class="keyword">in</span> t_array])

<span class="function">print</span>(<span class="string">"Comparison of Green function characteristics:"</span>)
<span class="function">print</span>(<span class="string">"=" * 50</span>)
<span class="function">print</span>(<span class="string">f"Retarded D_R(t=1): {D_R[150]:.6f}"</span>)
<span class="function">print</span>(<span class="string">f"Advanced D_A(t=1): {D_A[150]:.6f}"</span>)
<span class="function">print</span>(<span class="string">f"Feynman D_F(t=1): {D_F[150]:.6f}"</span>)
<span class="function">print</span>(<span class="string">f"\nRetarded D_R(t=-1): {D_R[50]:.6f}"</span>)
<span class="function">print</span>(<span class="string">f"Advanced D_A(t=-1): {D_A[50]:.6f}"</span>)
<span class="function">print</span>(<span class="string">f"Feynman D_F(t=-1): {D_F[50]:.6f}"</span>)</div>

            <div class="output">Comparison of Green function characteristics:
==================================================
Retarded D_R(t=1): 0.841471
Advanced D_A(t=1): -0.000000
Feynman D_F(t=1): -0.270154-0.412761j

Retarded D_R(t=-1): 0.000000
Advanced D_A(t=-1): 0.841471
Feynman D_F(t=-1): -0.270154-0.412761j</div>

            <h2>2.6 Applications to Materials Science: Linear Response Theory</h2>

            <p>
                The retarded Green function plays a central role in linear response theory, which describes material response to external fields.
                Through the Kubo formula, transport coefficients are connected to correlation functions.
            </p>

            <div class="example">
                <h3>üî¨ Kubo Formula for Electrical Conductivity</h3>
                <p>The electrical conductivity \(\sigma(\omega)\) is derived from the current-current correlation function:</p>
                <p>\[
                \sigma(\omega) = \frac{1}{i\omega} \int dt \, e^{i\omega t} \langle [j(t), j(0)] \rangle
                \]</p>
                <p>This is related to the real part of the retarded Green function.</p>
            </div>

            <div class="code-title">Example 7: Linear Response of Drude Model</div>
            <div class="code-example"><span class="keyword">import</span> numpy <span class="keyword">as</span> np

<span class="comment"># ===================================</span>
<span class="comment"># Electrical Conductivity of Drude Model</span>
<span class="comment"># ===================================</span>

<span class="keyword">def</span> <span class="function">drude_conductivity</span>(omega, omega_p, gamma):
    <span class="string">"""Drude conductivity

    Args:
        omega: Frequency
        omega_p: Plasma frequency
        gamma: Scattering rate
    """</span>
    <span class="keyword">return</span> omega_p**<span class="number">2</span> / (<span class="number">4</span> * np.pi * (<span class="number">1j</span> * omega + gamma))

<span class="keyword">def</span> <span class="function">optical_conductivity</span>(omega, omega_p, gamma):
    <span class="string">"""Optical conductivity (real part)"""</span>
    sigma = drude_conductivity(omega, omega_p, gamma)
    <span class="keyword">return</span> sigma.real

<span class="comment"># Metal parameters (assuming copper)</span>
omega_p = <span class="number">1.6e16</span>  <span class="comment"># rad/s (plasma frequency)</span>
gamma = <span class="number">4.0e13</span>     <span class="comment"># rad/s (scattering rate)</span>

omega_range = np.logspace(<span class="number">12</span>, <span class="number">17</span>, <span class="number">100</span>)  <span class="comment"># Hz</span>
sigma_real = [optical_conductivity(om, omega_p, gamma) <span class="keyword">for</span> om <span class="keyword">in</span> omega_range]

<span class="function">print</span>(<span class="string">"Optical response of Drude model:"</span>)
<span class="function">print</span>(<span class="string">"=" * 50</span>)
<span class="function">print</span>(<span class="string">f"DC conductivity œÉ(0): {drude_conductivity(0, omega_p, gamma).real:.3e} (S/m)"</span>)
<span class="function">print</span>(<span class="string">f"Plasma frequency: {omega_p/(2*np.pi)*1e-12:.2f} THz"</span>)
<span class="function">print</span>(<span class="string">f"Relaxation time: {1/gamma*1e15:.2f} fs"</span>)</div>

            <div class="output">Optical response of Drude model:
==================================================
DC conductivity œÉ(0): 1.273e+05 (S/m)
Plasma frequency: 2546.48 THz
Relaxation time: 25.00 fs</div>

            <div class="code-title">Example 8: Magnetic Susceptibility and Spin Correlation</div>
            <div class="code-example"><span class="keyword">import</span> numpy <span class="keyword">as</span> np

<span class="comment"># ===================================</span>
<span class="comment"># Temperature Dependence of Magnetic Susceptibility (Curie-Weiss Model)</span>
<span class="comment"># ===================================</span>

<span class="keyword">def</span> <span class="function">curie_weiss_susceptibility</span>(T, C, T_c):
    <span class="string">"""Curie-Weiss susceptibility

    Args:
        T: Temperature (K)
        C: Curie constant
        T_c: Curie temperature (K)
    """</span>
    <span class="keyword">return</span> C / (T - T_c)

<span class="keyword">def</span> <span class="function">spin_correlation_length</span>(T, T_c, xi_0):
    <span class="string">"""Spin correlation length (critical phenomenon)

    Œæ ~ |T - T_c|^{-ŒΩ}
    """</span>
    nu = <span class="number">0.63</span>  <span class="comment"># 3D Ising universality</span>

    <span class="keyword">if</span> np.abs(T - T_c) < <span class="number">1e-6</span>:
        <span class="keyword">return</span> <span class="number">1e10</span>  <span class="comment"># Divergence</span>

    <span class="keyword">return</span> xi_0 / np.abs(T - T_c)**nu

<span class="comment"># Iron parameters</span>
C = <span class="number">2.0</span>        <span class="comment"># Curie constant (emu¬∑K/mol)</span>
T_c = <span class="number">1043</span>     <span class="comment"># Curie temperature (K)</span>
xi_0 = <span class="number">0.5e-9</span>  <span class="comment"># Lattice constant scale (m)</span>

temperatures = np.linspace(T_c + <span class="number">10</span>, T_c + <span class="number">200</span>, <span class="number">5</span>)

<span class="function">print</span>(<span class="string">"Magnetic susceptibility and correlation length:"</span>)
<span class="function">print</span>(<span class="string">"=" * 60</span>)
<span class="function">print</span>(<span class="string">f"{'T (K)':<15} {'œá (emu/mol)':<20} {'Œæ (nm)':<20}"</span>)
<span class="function">print</span>(<span class="string">"-" * 60</span>)

<span class="keyword">for</span> T <span class="keyword">in</span> temperatures:
    chi = curie_weiss_susceptibility(T, C, T_c)
    xi = spin_correlation_length(T, T_c, xi_0)

    <span class="function">print</span>(<span class="string">f"{T:<15.1f} {chi:<20.6f} {xi*1e9:<20.3f}"</span>)</div>

            <div class="output">Magnetic susceptibility and correlation length:
============================================================
T (K)           œá (emu/mol)          Œæ (nm)
------------------------------------------------------------
1053.0          0.200000             3.401
1100.5          0.034783             1.376
1148.0          0.019048             0.941
1195.5          0.013115             0.735
1243.0          0.010000             0.605</div>

            <h2>Exercises</h2>

            <div class="exercise">
                <h3>Easy (Foundation Check)</h3>

                <p><strong>Q1</strong>: Derive the differential equation satisfied by the Feynman propagator \(D_F(x-y)\).</p>

                <details>
                    <summary>Show Answer</summary>
                    <p><strong>Answer</strong>:</p>
                    <p>Since \(D_F\) is a time-ordered product, it satisfies the Klein-Gordon equation with different boundary conditions:</p>
                    <p>\[
                    (\Box_x + m^2) D_F(x - y) = -i\delta^{(4)}(x - y)
                    \]</p>
                    <p>This is the defining equation for the Green function. The Œ¥ function on the right-hand side corresponds to the source term.</p>
                </details>

                <p><strong>Q2</strong>: Explain why the poles are placed at \(p^0 = \omega_{\mathbf{p}} - i\epsilon\) and \(p^0 = -\omega_{\mathbf{p}} + i\epsilon\) in the iŒµ prescription.</p>

                <details>
                    <summary>Show Answer</summary>
                    <p><strong>Reason</strong>:</p>
                    <p>Factoring the denominator \((p^0)^2 - \omega_{\mathbf{p}}^2 + i\epsilon = (p^0 - \omega_{\mathbf{p}} + i\epsilon')(p^0 + \omega_{\mathbf{p}} - i\epsilon')\) yields this placement.</p>
                    <p><strong>Physical meaning</strong>: The positive energy pole is in the lower half-plane and the negative energy pole is in the upper half-plane, ensuring causality (propagation to the future).</p>
                </details>
            </div>

            <div class="exercise">
                <h3>Medium (Application)</h3>

                <p><strong>Q3</strong>: Show that the sum of the retarded Green function \(D_R\) and advanced Green function \(D_A\) equals the commutator \([\phi(x), \phi(y)]\).</p>

                <details>
                    <summary>Show Answer</summary>
                    <p><strong>Proof</strong>:</p>
                    <p>\[
                    D_R(x - y) = \theta(t - t') \langle 0|[\phi(x), \phi(y)]|0\rangle
                    \]</p>
                    <p>\[
                    D_A(x - y) = -\theta(t' - t) \langle 0|[\phi(x), \phi(y)]|0\rangle
                    \]</p>
                    <p>Taking the sum:</p>
                    <p>\[
                    D_R + D_A = (\theta(t - t') - \theta(t' - t)) \langle 0|[\phi(x), \phi(y)]|0\rangle
                    = \langle 0|[\phi(x), \phi(y)]|0\rangle
                    \]</p>
                    <p>(Using \(\theta(t - t') + \theta(t' - t) = 1\))</p>
                </details>
            </div>

            <div class="exercise">
                <h3>Hard (Advanced)</h3>

                <p><strong>Q4</strong>: Using Wick rotation, calculate the momentum integral of the Feynman propagator in 4-dimensional Euclidean space \(\int d^4p_E / (p_E^2 + m^2)^2\).</p>

                <details>
                    <summary>Show Answer</summary>
                    <p><strong>Calculation</strong>:</p>
                    <p>Using 4-dimensional polar coordinates:</p>
                    <p>\[
                    \int d^4p_E = 2\pi^2 \int_0^\infty dp \, p^3
                    \]</p>
                    <p>Performing the integral:</p>
                    <p>\[
                    I = 2\pi^2 \int_0^\infty \frac{p^3 \, dp}{(p^2 + m^2)^2}
                    \]</p>
                    <p>Substituting \(u = p^2 + m^2\):</p>
                    <p>\[
                    I = \pi^2 \int_{m^2}^\infty \frac{du}{u^2} = \frac{\pi^2}{m^2}
                    \]</p>
                </details>
            </div>

            <div class="nav-buttons">
                <a href="chapter-1.html" class="nav-button">‚Üê Chapter 1</a>
                <a href="chapter-3.html" class="nav-button">Proceed to Chapter 3 ‚Üí</a>
            </div>

            <h2>References</h2>

            <ol>
                <li>Peskin, M. E., & Schroeder, D. V. (1995). <em>An Introduction to Quantum Field Theory</em>. Westview Press.</li>
                <li>Greiner, W., & Reinhardt, J. (1996). <em>Field Quantization</em>. Springer.</li>
                <li>Mahan, G. D. (2000). <em>Many-Particle Physics</em> (3rd ed.). Springer.</li>
                <li>Altland, A., & Simons, B. (2010). <em>Condensed Matter Field Theory</em>. Cambridge University Press.</li>
            </ol>
        </div>
    </div>

    <footer>
        <p>&copy; 2025 AI Terakoya - Fundamentals of Mathematics & Physics Dojo</p>
        <p style="margin-top: 0.5rem;">Licensed under CC BY 4.0</p>
    </footer>

    <script>
        mermaid.initialize({ startOnLoad: true, theme: 'base' });
    </script>
</body>
</html>
