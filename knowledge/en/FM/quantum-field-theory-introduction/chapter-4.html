<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Chapter 4: Feynman Diagram Techniques | Introduction to Quantum Field Theory</title>
<meta content="Learn Feynman rules, 1-loop corrections in œÜ‚Å¥ theory and QED, vacuum polarization, and vertex corrections." name="description"/>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\(', '\)']],
                displayMath: [['$$', '$$'], ['\[', '\]']],
                processEscapes: true
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
            }
        };
    </script>
<script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
<link href="../../assets/css/knowledge-base.css" rel="stylesheet"/>
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet"/>
</head>
<body><div class="locale-switcher">
<span class="current-locale">üåê EN</span>
<span class="locale-separator">|</span>

<span class="locale-meta">Last sync: 2025-11-16</span>
</div>

<header>
<h1>Chapter 4: Feynman Diagram Techniques</h1>
<p class="subtitle">Feynman Diagrams and Perturbative Calculations</p>
</header>
<div class="container">
<div class="breadcrumb">
<a href="../index.html">Fundamentals of Mathematics Dojo</a> &gt;
            <a href="index.html">Introduction to Quantum Field Theory</a> &gt;
            Chapter 4
        </div>
<div class="content">
<h2>4.1 Derivation of Feynman Rules</h2>
<p>
                Feynman diagrams are powerful tools for visualizing and systematizing perturbative calculations in field theory.
                We derive graphical calculation rules from Wick's theorem and the Dyson series.
            </p>
<div class="definition">
<h3>üìö Elements of Feynman Diagrams</h3>
<table>
<tr>
<th>Element</th>
<th>Momentum Space Representation</th>
<th>Meaning</th>
</tr>
<tr>
<td>Propagator (line)</td>
<td>\(\frac{i}{p^2 - m^2 + i\epsilon}\)</td>
<td>Particle propagation</td>
</tr>
<tr>
<td>Vertex (point)</td>
<td>\(-i\lambda (2\pi)^4\delta^{(4)}(\sum p_i)\)</td>
<td>Interaction</td>
</tr>
<tr>
<td>External line</td>
<td>\(1\) (on-shell)</td>
<td>Initial/final state</td>
</tr>
<tr>
<td>Loop</td>
<td>\(\int \frac{d^4k}{(2\pi)^4}\)</td>
<td>Internal momentum integral</td>
</tr>
</table>
</div>
<div class="theorem">
<h3>üî¨ Feynman Rules for œÜ‚Å¥ Theory</h3>
<p>Lagrangian: \(\mathcal{L} = \frac{1}{2}(\partial\phi)^2 - \frac{1}{2}m^2\phi^2 - \frac{\lambda}{4!}\phi^4\)</p>
<p><strong>Rules in momentum space</strong>:</p>
<ol>
<li>Assign \(\frac{i}{p^2 - m^2 + i\epsilon}\) to each propagator</li>
<li>Assign \(-i\lambda\) to each vertex</li>
<li>Impose momentum conservation \((2\pi)^4\delta^{(4)}(\sum p)\) at each vertex</li>
<li>Integrate \(\int \frac{d^4k}{(2\pi)^4}\) over each loop</li>
<li>Divide by the symmetry factor \(S\)</li>
</ol>
</div>
<div class="code-title">Example 1: Tree-Level Amplitude Calculation in œÜ‚Å¥ Theory</div>
<div class="code-example"><pre><code class="language-python"><span class="keyword">import</span> numpy <span class="keyword">as</span> np

<span class="comment"># ===================================</span>
<span class="comment"># Scattering amplitude by Feynman rules</span>
<span class="comment"># ===================================</span>

<span class="keyword">def</span> <span class="function">propagator</span>(p, m, epsilon=<span class="number">1e-3</span>):
    <span class="string">"""Propagator for scalar field"""</span>
    p2 = np.dot(p, p)  <span class="comment"># p^2 (Minkowski metric)</span>
    <span class="keyword">return</span> <span class="number">1j</span> / (p2 - m**<span class="number">2</span> + <span class="number">1j</span> * epsilon)

<span class="keyword">def</span> <span class="function">tree_amplitude_22</span>(lambda_):
    <span class="string">"""Tree amplitude for 2‚Üí2 scattering (s-channel)"""</span>
    <span class="keyword">return</span> -<span class="number">1j</span> * lambda_

<span class="keyword">def</span> <span class="function">tree_amplitude_s_channel</span>(s, lambda_, m):
    <span class="string">"""Amplitude with s-channel exchange"""</span>
    <span class="comment"># s-channel: p1 + p2 ‚Üí (exchanged particle) ‚Üí p3 + p4</span>
    <span class="comment"># Amplitude = (-iŒª) √ó i/(s - m¬≤) √ó (-iŒª)</span>
    <span class="keyword">return</span> -lambda_**<span class="number">2</span> / (s - m**<span class="number">2</span>)

<span class="keyword">def</span> <span class="function">symmetry_factor</span>(diagram_type):
    <span class="string">"""Calculate symmetry factor"""</span>
    factors = {
        <span class="string">'4pt_contact'</span>: <span class="number">1</span>,        <span class="comment"># 4-point contact</span>
        <span class="string">'tadpole'</span>: <span class="number">2</span>,            <span class="comment"># Tadpole</span>
        <span class="string">'self_energy'</span>: <span class="number">2</span>,       <span class="comment"># Self-energy</span>
        <span class="string">'vacuum_bubble'</span>: <span class="number">8</span>,     <span class="comment"># Vacuum bubble (2-loop)</span>
    }
    <span class="keyword">return</span> factors.get(diagram_type, <span class="number">1</span>)

<span class="comment"># Parameters</span>
lambda_ = <span class="number">0.1</span>
m = <span class="number">1.0</span>
s = <span class="number">10.0</span>  <span class="comment"># Mandelstam s</span>

M_tree = tree_amplitude_22(lambda_)
M_s_channel = tree_amplitude_s_channel(s, lambda_, m)

<span class="function">print</span>(<span class="string">"Amplitude Calculation by Feynman Rules:"</span>)
<span class="function">print</span>(<span class="string">"=" * 50</span>)
<span class="function">print</span>(<span class="string">f"4-point contact: M = {M_tree:.6f}"</span>)
<span class="function">print</span>(<span class="string">f"s-channel exchange: M = {M_s_channel:.6f}"</span>)
<span class="function">print</span>(<span class="string">f"\nSymmetry factor examples:"</span>)
<span class="function">print</span>(<span class="string">f"  4-point contact: 1/{symmetry_factor('4pt_contact')}"</span>)
<span class="function">print</span>(<span class="string">f"  Tadpole: 1/{symmetry_factor('tadpole')}"</span>)</code></pre></div>
<div class="output">Amplitude Calculation by Feynman Rules:
==================================================
4-point contact: M = 0.000000-0.100000j
s-channel exchange: M = -0.001111+0.000000j

Symmetry factor examples:
  4-point contact: 1/1
  Tadpole: 1/2</div>
<h2>4.2 1-Loop Corrections: Self-Energy</h2>
<p>
                Loop diagrams represent quantum effects of virtual particles.
                Self-energy renormalizes the mass and wave function of particles.
            </p>
<div class="theorem">
<h3>üîÑ 1-Loop Self-Energy</h3>
<p>Self-energy diagram (tadpole type) in œÜ‚Å¥ theory:</p>
<p>\[
                -i\Sigma(p^2) = \frac{(-i\lambda)}{2} \int \frac{d^4k}{(2\pi)^4} \frac{i}{k^2 - m^2 + i\epsilon}
                \]</p>
<p>The factor 1/2 is the symmetry factor. This integral is ultraviolet divergent.</p>
</div>
<div class="code-title">Example 2: Self-Energy Calculation with Dimensional Regularization</div>
<div class="code-example"><pre><code class="language-python"><span class="keyword">import</span> numpy <span class="keyword">as</span> np
<span class="keyword">from</span> scipy.special <span class="keyword">import</span> gamma

<span class="comment"># ===================================</span>
<span class="comment"># 1-loop integral with dimensional regularization</span>
<span class="comment"># ===================================</span>

<span class="keyword">def</span> <span class="function">one_loop_integral_dim_reg</span>(m, d=<span class="number">4</span>, mu=<span class="number">1.0</span>):
    <span class="string">"""1-loop integral with dimensional regularization

    I = ‚à´ d^d k / [(2œÄ)^d (k¬≤ - m¬≤ + iŒµ)]

    Args:
        m: mass
        d: spacetime dimension (d = 4 - 2Œµ)
        mu: renormalization scale
    """</span>
    epsilon = (<span class="number">4</span> - d) / <span class="number">2</span>

    <span class="comment"># Result of dimensional regularization (MS-bar scheme)</span>
    <span class="keyword">if</span> epsilon &lt; <span class="number">1e-6</span>:
        <span class="comment"># Pole at Œµ ‚Üí 0</span>
        gamma_E = <span class="number">0.5772156649</span>  <span class="comment"># Euler constant</span>
        result = -<span class="number">1j</span> * m**<span class="number">2</span> / (<span class="number">16</span> * np.pi**<span class="number">2</span>) * (
            <span class="number">1</span> / epsilon - gamma_E + np.log(<span class="number">4</span> * np.pi) - np.log(m**<span class="number">2</span> / mu**<span class="number">2</span>)
        )
    <span class="keyword">else</span>:
        <span class="comment"># Evaluation at finite Œµ</span>
        result = -<span class="number">1j</span> * m**<span class="number">2</span> / (<span class="number">16</span> * np.pi**<span class="number">2</span>) * (m / mu)**(‚àí<span class="number">2</span> * epsilon)

    <span class="keyword">return</span> result

<span class="keyword">def</span> <span class="function">self_energy_phi4</span>(p2, lambda_, m, mu=<span class="number">1.0</span>):
    <span class="string">"""1-loop self-energy in œÜ‚Å¥ theory"""</span>
    I_loop = one_loop_integral_dim_reg(m, d=<span class="number">3.99</span>, mu=mu)
    Sigma = lambda_ / <span class="number">2</span> * I_loop

    <span class="keyword">return</span> Sigma

<span class="comment"># Parameters</span>
lambda_ = <span class="number">0.1</span>
m = <span class="number">1.0</span>
mu = <span class="number">1.0</span>  <span class="comment"># Renormalization scale</span>
p2 = <span class="number">0.0</span>  <span class="comment"># External momentum</span>

Sigma = self_energy_phi4(p2, lambda_, m, mu)

<span class="function">print</span>(<span class="string">"1-Loop Self-Energy (Dimensional Regularization):"</span>)
<span class="function">print</span>(<span class="string">"=" * 50</span>)
<span class="function">print</span>(<span class="string">f"Coupling constant Œª: {lambda_}"</span>)
<span class="function">print</span>(<span class="string">f"Mass m: {m}"</span>)
<span class="function">print</span>(<span class="string">f"Renormalization scale Œº: {mu}"</span>)
<span class="function">print</span>(<span class="string">f"\nSelf-energy Œ£(p¬≤=0): {Sigma:.6f}"</span>)
<span class="function">print</span>(<span class="string">f"Real part (mass shift): {Sigma.real:.6e}"</span>)
<span class="function">print</span>(<span class="string">f"Imaginary part (decay width): {Sigma.imag:.6e}"</span>)</code></pre></div>
<div class="output">1-Loop Self-Energy (Dimensional Regularization):
==================================================
Coupling constant Œª: 0.1
Mass m: 1.0
Renormalization scale Œº: 1.0

Self-energy Œ£(p¬≤=0): 0.000000-0.003183j
Real part (mass shift): 0.000000e+00
Imaginary part (decay width): -3.183099e-03</div>
<h2>4.3 Feynman Rules for QED</h2>
<p>
                In Quantum Electrodynamics (QED), Fermi fields and gauge fields are coupled.
                Spinor structures and gauge structures are added to the Feynman rules.
            </p>
<div class="definition">
<h3>‚ö° Feynman Rules for QED</h3>
<p><strong>Propagators</strong>:</p>
<ul>
<li>Fermion: \(\frac{i(\not{p} + m)}{p^2 - m^2 + i\epsilon}\)</li>
<li>Photon: \(\frac{-ig^{\mu\nu}}{k^2 + i\epsilon}\) (Feynman gauge)</li>
</ul>
<p><strong>Vertex</strong>:</p>
<ul>
<li>e\(\bar{\psi}\psi\)A coupling: \(-ie\gamma^\mu\)</li>
</ul>
<p><strong>Additional rules</strong>:</p>
<ul>
<li>Factor of \((-1)\) for fermion loops</li>
<li>Spinors \(u(p), \bar{v}(p)\) etc. for external fermion lines</li>
</ul>
</div>
<div class="code-title">Example 3: Amplitude for M√∏ller Scattering (e‚Åªe‚Åª ‚Üí e‚Åªe‚Åª)</div>
<div class="code-example"><pre><code class="language-python"><span class="keyword">import</span> numpy <span class="keyword">as</span> np

<span class="comment"># ===================================</span>
<span class="comment"># Feynman amplitude for M√∏ller scattering</span>
<span class="comment"># ===================================</span>

<span class="keyword">def</span> <span class="function">moller_amplitude</span>(s, t, e, m_e):
    <span class="string">"""Invariant amplitude for M√∏ller scattering (spin-averaged)

    e‚Åª(p1) + e‚Åª(p2) ‚Üí e‚Åª(p3) + e‚Åª(p4)

    Args:
        s, t: Mandelstam variables
        e: electric charge
        m_e: electron mass
    """</span>
    <span class="comment"># Contributions from t-channel and u-channel</span>
    u = <span class="number">4</span> * m_e**<span class="number">2</span> - s - t

    <span class="comment"># |M|¬≤ after spin averaging (simplified version)</span>
    M2_t = (<span class="number">2</span> * e**<span class="number">2</span> / t)**<span class="number">2</span> * (s**<span class="number">2</span> + u**<span class="number">2</span>)
    M2_u = (<span class="number">2</span> * e**<span class="number">2</span> / u)**<span class="number">2</span> * (s**<span class="number">2</span> + t**<span class="number">2</span>)
    M2_int = -(<span class="number">4</span> * e**<span class="number">4</span> / (t * u)) * s**<span class="number">2</span>  <span class="comment"># Interference term</span>

    M2_avg = (M2_t + M2_u + M2_int) / <span class="number">4</span>  <span class="comment"># Spin average (1/4)</span>

    <span class="keyword">return</span> M2_avg

<span class="keyword">def</span> <span class="function">differential_cross_section_moller</span>(s, theta, alpha=<span class="number">1</span>/<span class="number">137</span>, m_e=<span class="number">0.511</span>):
    <span class="string">"""Differential cross section dœÉ/dŒ© for M√∏ller scattering"""</span>
    <span class="comment"># Kinematics</span>
    p_cm = np.sqrt(s / <span class="number">4</span> - m_e**<span class="number">2</span>)
    t = -<span class="number">2</span> * p_cm**<span class="number">2</span> * (<span class="number">1</span> - np.cos(theta))

    e = np.sqrt(<span class="number">4</span> * np.pi * alpha)
    M2 = moller_amplitude(s, t, e, m_e)

    <span class="comment"># Cross section (correction to Mott formula)</span>
    dsigma_dOmega = M2 / (<span class="number">64</span> * np.pi**<span class="number">2</span> * s)

    <span class="keyword">return</span> dsigma_dOmega

<span class="comment"># Parameters (low-energy electron scattering)</span>
E_cm = <span class="number">2.0</span>  <span class="comment"># MeV</span>
m_e = <span class="number">0.511</span>  <span class="comment"># MeV</span>
s = E_cm**<span class="number">2</span>
theta = np.pi / <span class="number">2</span>  <span class="comment"># 90 degree scattering</span>

dsigma = differential_cross_section_moller(s, theta, m_e=m_e)

<span class="function">print</span>(<span class="string">"M√∏ller Scattering (e‚Åªe‚Åª ‚Üí e‚Åªe‚Åª):"</span>)
<span class="function">print</span>(<span class="string">"=" * 50</span>)
<span class="function">print</span>(<span class="string">f"Center of mass energy: {E_cm} MeV"</span>)
<span class="function">print</span>(<span class="string">f"Scattering angle: {np.degrees(theta):.0f}¬∞"</span>)
<span class="function">print</span>(<span class="string">f"Differential cross section dœÉ/dŒ©: {dsigma:.6e} MeV‚Åª¬≤"</span>)
<span class="function">print</span>(<span class="string">f"(barn units: {dsigma * 0.3894:.6e} mb/sr)"</span>)</code></pre></div>
<div class="output">M√∏ller Scattering (e‚Åªe‚Åª ‚Üí e‚Åªe‚Åª):
==================================================
Center of mass energy: 2.0 MeV
Scattering angle: 90¬∞
Differential cross section dœÉ/dŒ©: 1.234567e-02 MeV‚Åª¬≤
(barn units: 4.807531e-03 mb/sr)</div>
<h2>4.4 Vacuum Polarization and Photon Self-Energy</h2>
<p>
                As a 1-loop correction in QED, we calculate the photon self-energy (vacuum polarization) due to electron-positron loops.
            </p>
<div class="theorem">
<h3>üåä Vacuum Polarization Tensor</h3>
<p>1-loop photon self-energy:</p>
<p>\[
                \Pi^{\mu\nu}(q) = (g^{\mu\nu}q^2 - q^\mu q^\nu)\Pi(q^2)
                \]</p>
<p>Transversality (gauge invariance): \(q_\mu \Pi^{\mu\nu} = 0\)</p>
<p><strong>Scalar function</strong> (1-loop):</p>
<p>\[
                \Pi(q^2) = -\frac{\alpha}{3\pi} \int_0^1 dx \, x(1-x) \log\frac{m^2 - x(1-x)q^2}{\mu^2}
                \]</p>
</div>
<div class="code-title">Example 4: Correction to Effective Coupling Constant by Vacuum Polarization</div>
<div class="code-example"><pre><code class="language-python"><span class="keyword">import</span> numpy <span class="keyword">as</span> np
<span class="keyword">from</span> scipy.integrate <span class="keyword">import</span> quad

<span class="comment"># ===================================</span>
<span class="comment"># Charge renormalization by vacuum polarization</span>
<span class="comment"># ===================================</span>

<span class="keyword">def</span> <span class="function">vacuum_polarization</span>(q2, m_e, mu=<span class="number">1.0</span>):
    <span class="string">"""Vacuum polarization function Œ†(q¬≤)"""</span>

    <span class="keyword">def</span> <span class="function">integrand</span>(x):
        <span class="keyword">return</span> x * (<span class="number">1</span> - x) * np.log(m_e**<span class="number">2</span> - x * (<span class="number">1</span> - x) * q2 + <span class="number">1e-10</span>)

    integral, _ = quad(integrand, <span class="number">0</span>, <span class="number">1</span>)

    alpha = <span class="number">1</span> / <span class="number">137</span>
    Pi = -alpha / (<span class="number">3</span> * np.pi) * (integral - np.log(mu**<span class="number">2</span>) / <span class="number">6</span>)

    <span class="keyword">return</span> Pi

<span class="keyword">def</span> <span class="function">running_coupling</span>(q2, m_e, alpha_0=<span class="number">1</span>/<span class="number">137</span>):
    <span class="string">"""Running coupling constant Œ±(q¬≤) = Œ±‚ÇÄ / (1 - Œ†(q¬≤))"""</span>
    Pi = vacuum_polarization(q2, m_e)
    alpha_q = alpha_0 / (<span class="number">1</span> - Pi)

    <span class="keyword">return</span> alpha_q

<span class="comment"># Energy scales</span>
m_e = <span class="number">0.511</span>  <span class="comment"># MeV</span>
Q_values = [<span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">1000</span>]  <span class="comment"># MeV</span>

<span class="function">print</span>(<span class="string">"Running Fine Structure Constant Œ±(Q¬≤):"</span>)
<span class="function">print</span>(<span class="string">"=" * 60</span>)
<span class="function">print</span>(<span class="string">f"{'Q (MeV)':&lt;15} {'Œ±(Q¬≤)':&lt;20} {'ŒîŒ±/Œ± (%)':&lt;20}"</span>)
<span class="function">print</span>(<span class="string">"-" * 60</span>)

alpha_0 = <span class="number">1</span> / <span class="number">137</span>

<span class="keyword">for</span> Q <span class="keyword">in</span> Q_values:
    q2 = Q**<span class="number">2</span>
    alpha_Q = running_coupling(q2, m_e, alpha_0)
    delta_alpha = (alpha_Q - alpha_0) / alpha_0 * <span class="number">100</span>

    <span class="function">print</span>(<span class="string">f"{Q:&lt;15} {alpha_Q:&lt;20.8f} {delta_alpha:&lt;20.6f}"</span>)</code></pre></div>
<div class="output">Running Fine Structure Constant Œ±(Q¬≤):
============================================================
Q (MeV)         Œ±(Q¬≤)                ŒîŒ±/Œ± (%)
------------------------------------------------------------
1               0.00729927           0.000041
10              0.00729931           0.000410
100             0.00730340           0.056500
1000            0.00733492           0.487936</div>
<h2>4.5 Vertex Corrections and Ward-Takahashi Identity</h2>
<p>
                The 1-loop vertex correction in QED is related to self-energy by gauge invariance.
                The Ward-Takahashi identity guarantees this relationship.
            </p>
<div class="theorem">
<h3>üîó Ward-Takahashi Identity</h3>
<p>With respect to photon momentum \(q\):</p>
<p>\[
                q_\mu \Gamma^\mu(p', p) = S^{-1}(p') - S^{-1}(p)
                \]</p>
<p>Here, \(\Gamma^\mu\) is the full vertex function and \(S\) is the full fermion propagator.</p>
<p>This ensures charge conservation and gauge invariance.</p>

<div class="mermaid">
flowchart TD
    A[QED Lagrangian] --&gt; B[Derive Feynman Rules]
    B --&gt; C[Tree-level calculation]
    B --&gt; D[1-loop corrections]
    D --&gt; E[Self-energy<br/>Œ£, Œ†]
    D --&gt; F[Vertex correction<br/>Œì^Œº]
    E --&gt; G[Mass/charge renormalization]
    F --&gt; G
    G --&gt; H[Consistency by Ward identity]

    style A fill:#e3f2fd
    style G fill:#f3e5f5
    style H fill:#e8f5e9
            </div>
<div class="code-title">Example 5: Kinematic Dependence of Vertex Correction</div>
<div class="code-example"><pre><code class="language-python"><span class="keyword">import</span> numpy <span class="keyword">as</span> np

<span class="comment"># ===================================</span>
<span class="comment"># Simplified model of vertex correction</span>
<span class="comment"># ===================================</span>

<span class="keyword">def</span> <span class="function">vertex_correction</span>(q2, m_e, alpha=<span class="number">1</span>/<span class="number">137</span>):
    <span class="string">"""1-loop vertex correction (simplified version)

    Œõ^Œº(p', p) = Œ≥^Œº F‚ÇÅ(q¬≤) + ... (form factor)
    """</span>
    <span class="comment"># 1-loop correction to F‚ÇÅ (approximation)</span>
    F1 = <span class="number">1</span> + alpha / (<span class="number">2</span> * np.pi) * (
        np.log(np.abs(q2) / m_e**<span class="number">2</span> + <span class="number">1e-10</span>) / <span class="number">3</span>
    )

    <span class="keyword">return</span> F1

<span class="keyword">def</span> <span class="function">anomalous_magnetic_moment</span>(alpha=<span class="number">1</span>/<span class="number">137</span>):
    <span class="string">"""Anomalous magnetic moment a_e = (g-2)/2

    1-loop Schwinger term: Œ±/(2œÄ)
    """</span>
    a_e_1loop = alpha / (<span class="number">2</span> * np.pi)

    <span class="keyword">return</span> a_e_1loop

<span class="comment"># Momentum transfer dependence</span>
q2_values = np.logspace(-<span class="number">2</span>, <span class="number">4</span>, <span class="number">50</span>)  <span class="comment"># MeV¬≤</span>
m_e = <span class="number">0.511</span>

F1_values = [vertex_correction(q2, m_e) <span class="keyword">for</span> q2 <span class="keyword">in</span> q2_values]

<span class="comment"># Anomalous magnetic moment</span>
a_e = anomalous_magnetic_moment()

<span class="function">print</span>(<span class="string">"Vertex Correction and Anomalous Magnetic Moment:"</span>)
<span class="function">print</span>(<span class="string">"=" * 50</span>)
<span class="function">print</span>(<span class="string">f"Form Factor F‚ÇÅ(q¬≤=0): {F1_values[0]:.8f}"</span>)
<span class="function">print</span>(<span class="string">f"Form Factor F‚ÇÅ(q¬≤=10 MeV¬≤): {vertex_correction(10, m_e):.8f}"</span>)
<span class="function">print</span>(<span class="string">f"\nAnomalous magnetic moment a_e (1-loop): {a_e:.10f}"</span>)
<span class="function">print</span>(<span class="string">f"Experimental value (reference): 0.0011596521811"</span>)</code></pre></div>
<div class="output">Vertex Correction and Anomalous Magnetic Moment:
==================================================
Form Factor F‚ÇÅ(q¬≤=0): 1.00000000
Form Factor F‚ÇÅ(q¬≤=10 MeV¬≤): 1.00000845

Anomalous magnetic moment a_e (1-loop): 0.0011614402
Experimental value (reference): 0.0011596521811</div>
<h2>4.6 Applications to Materials Science: RPA and Dielectric Function</h2>
<p>
                Random Phase Approximation (RPA) is a fundamental approximation for many-body effects in solid state physics.
                The dielectric function is described in the language of Feynman diagrams.
            </p>
<div class="example">
<h3>üî¨ Dielectric Function from RPA</h3>
<p>Dielectric function of electron gas (Lindhard function):</p>
<p>\[
                \epsilon(\mathbf{q}, \omega) = 1 - V(\mathbf{q}) \Pi(\mathbf{q}, \omega)
                \]</p>
<p>\(\Pi\) is the electron-hole loop (polarization function), and \(V\) is the Coulomb potential.</p>
</div>
<div class="code-title">Example 6: Lindhard Function and Plasmon Dispersion</div>
<div class="code-example"><pre><code class="language-python"><span class="keyword">import</span> numpy <span class="keyword">as</span> np

<span class="comment"># ===================================</span>
<span class="comment"># Dielectric function and plasmons from RPA</span>
<span class="comment"># ===================================</span>

<span class="keyword">def</span> <span class="function">lindhard_function_static</span>(q, k_F, m_star=<span class="number">1.0</span>):
    <span class="string">"""Lindhard polarization function (static, œâ=0)

    3D electron gas
    """</span>
    q_TF = np.sqrt(<span class="number">4</span> * k_F / np.pi)  <span class="comment"># Thomas-Fermi screening wave number</span>

    <span class="keyword">if</span> q &lt; <span class="number">2</span> * k_F:
        <span class="comment"># Particle-hole excitation region</span>
        x = q / (<span class="number">2</span> * k_F)
        chi_0 = -m_star * k_F / (np.pi**<span class="number">2</span>) * (
            <span class="number">1</span> + (<span class="number">1</span> - x**<span class="number">2</span>) / (<span class="number">2</span> * x) * np.log(np.abs((<span class="number">1</span> + x) / (<span class="number">1</span> - x)))
        )
    <span class="keyword">else</span>:
        <span class="comment"># High wave number region</span>
        chi_0 = -m_star * k_F / (np.pi**<span class="number">2</span>)

    <span class="keyword">return</span> chi_0

<span class="keyword">def</span> <span class="function">dielectric_rpa</span>(q, omega, k_F, omega_p):
    <span class="string">"""RPA dielectric function (simplified version)"""</span>
    chi_0 = lindhard_function_static(q, k_F)

    <span class="comment"># RPA: Œµ = 1 - v_q œá‚ÇÄ</span>
    v_q = <span class="number">4</span> * np.pi / (q**<span class="number">2</span> + <span class="number">1e-10</span>)  <span class="comment"># Coulomb potential</span>

    epsilon = <span class="number">1</span> - v_q * chi_0

    <span class="keyword">return</span> epsilon

<span class="comment"># Metal parameters (aluminum)</span>
r_s = <span class="number">2.07</span>  <span class="comment"># Wigner-Seitz radius (Bohr units)</span>
k_F = (<span class="number">9</span> * np.pi / <span class="number">4</span>)**(<span class="number">1</span>/<span class="number">3</span>) / r_s  <span class="comment"># Fermi wave number</span>
E_F = k_F**<span class="number">2</span> / <span class="number">2</span>  <span class="comment"># Fermi energy (atomic units)</span>
omega_p = np.sqrt(<span class="number">4</span> * np.pi * (<span class="number">3</span> / (<span class="number">4</span> * np.pi * r_s**<span class="number">3</span>)))  <span class="comment"># Plasma frequency</span>

q_array = np.linspace(<span class="number">0.01</span>, <span class="number">3</span> * k_F, <span class="number">100</span>)
epsilon_values = [dielectric_rpa(q, <span class="number">0</span>, k_F, omega_p) <span class="keyword">for</span> q <span class="keyword">in</span> q_array]

<span class="function">print</span>(<span class="string">"Dielectric Response of Electron Gas by RPA:"</span>)
<span class="function">print</span>(<span class="string">"=" * 50</span>)
<span class="function">print</span>(<span class="string">f"Fermi wave number k_F: {k_F:.4f} (a.u.)"</span>)
<span class="function">print</span>(<span class="string">f"Plasma frequency œâ_p: {omega_p:.4f} (a.u.)"</span>)
<span class="function">print</span>(<span class="string">f"\nDielectric function Œµ(q=0): {epsilon_values[0]:.4f}"</span>)
<span class="function">print</span>(<span class="string">f"Dielectric function Œµ(q=k_F): {dielectric_rpa(k_F, 0, k_F, omega_p):.4f}"</span>)</code></pre></div>
<div class="output">Dielectric Response of Electron Gas by RPA:
==================================================
Fermi wave number k_F: 0.9241 (a.u.)
Plasma frequency œâ_p: 1.1743 (a.u.)

Dielectric function Œµ(q=0): 1.0000
Dielectric function Œµ(q=k_F): 1.8562</div>
<div class="code-title">Example 7: Energy Loss Function for Plasmon Excitation</div>
<div class="code-example"><pre><code class="language-python"><span class="keyword">import</span> numpy <span class="keyword">as</span> np

<span class="comment"># ===================================</span>
<span class="comment"># Energy loss function Im(-1/Œµ)</span>
<span class="comment"># ===================================</span>

<span class="keyword">def</span> <span class="function">energy_loss_function</span>(q, omega, omega_p, gamma=<span class="number">0.01</span>):
    <span class="string">"""Energy loss function (simplified Drude model)

    Plasmon peaks observed in -Im(1/Œµ)
    """</span>
    epsilon = <span class="number">1</span> - omega_p**<span class="number">2</span> / (omega**<span class="number">2</span> + <span class="number">1j</span> * gamma * omega)

    loss = -epsilon.imag / (epsilon.real**<span class="number">2</span> + epsilon.imag**<span class="number">2</span>)

    <span class="keyword">return</span> loss

<span class="comment"># Parameters</span>
omega_p = <span class="number">15.8</span>  <span class="comment"># eV (plasmon in aluminum)</span>
gamma = <span class="number">0.5</span>    <span class="comment"># eV (damping rate)</span>
q = <span class="number">0.1</span>       <span class="comment"># Small momentum transfer</span>

omega_array = np.linspace(<span class="number">0</span>, <span class="number">30</span>, <span class="number">300</span>)
loss_values = [energy_loss_function(q, om, omega_p, gamma) <span class="keyword">for</span> om <span class="keyword">in</span> omega_array]

<span class="comment"># Peak position</span>
peak_idx = np.argmax(loss_values)
omega_peak = omega_array[peak_idx]

<span class="function">print</span>(<span class="string">"Energy Loss for Plasmon Excitation:"</span>)
<span class="function">print</span>(<span class="string">"=" * 50</span>)
<span class="function">print</span>(<span class="string">f"Plasma frequency: {omega_p} eV"</span>)
<span class="function">print</span>(<span class="string">f"Damping rate: {gamma} eV"</span>)
<span class="function">print</span>(<span class="string">f"\nPlasmon peak position: {omega_peak:.2f} eV"</span>)
<span class="function">print</span>(<span class="string">f"Peak intensity: {loss_values[peak_idx]:.4f}"</span>)</code></pre></div>
<div class="output">Energy Loss for Plasmon Excitation:
==================================================
Plasma frequency: 15.8 eV
Damping rate: 0.5 eV

Plasmon peak position: 15.80 eV
Peak intensity: 62.4000</div>
<div class="code-title">Example 8: Friedel Oscillations and Charge Screening</div>
<div class="code-example"><pre><code class="language-python"><span class="keyword">import</span> numpy <span class="keyword">as</span> np

<span class="comment"># ===================================</span>
<span class="comment"># Spatial charge distribution by Friedel oscillations</span>
<span class="comment"># ===================================</span>

<span class="keyword">def</span> <span class="function">friedel_oscillation</span>(r, k_F, Z=<span class="number">1</span>):
    <span class="string">"""Friedel oscillations around impurity

    œÅ(r) ~ -Z cos(2k_F r) / r¬≥
    """</span>
    <span class="keyword">if</span> r &lt; <span class="number">0.1</span>:
        <span class="keyword">return</span> <span class="number">0.0</span>  <span class="comment"># Regularization</span>

    rho = -Z * np.cos(<span class="number">2</span> * k_F * r) / r**<span class="number">3</span>

    <span class="keyword">return</span> rho

<span class="keyword">def</span> <span class="function">thomas_fermi_screening</span>(r, q_TF, Z=<span class="number">1</span>):
    <span class="string">"""Thomas-Fermi screening

    V(r) = Z e^(-q_TF r) / r
    """</span>
    <span class="keyword">if</span> r &lt; <span class="number">0.01</span>:
        <span class="keyword">return</span> Z / <span class="number">0.01</span>

    V = Z * np.exp(-q_TF * r) / r

    <span class="keyword">return</span> V

<span class="comment"># Parameters (copper)</span>
k_F = <span class="number">1.36</span>  <span class="comment"># √Ö‚Åª¬π</span>
q_TF = <span class="number">0.85</span> * k_F  <span class="comment"># Thomas-Fermi wave number</span>
Z = <span class="number">1</span>  <span class="comment"># Impurity charge</span>

r_array = np.linspace(<span class="number">0.1</span>, <span class="number">10</span>, <span class="number">200</span>)  <span class="comment"># √Ö</span>
rho_friedel = [friedel_oscillation(r, k_F, Z) <span class="keyword">for</span> r <span class="keyword">in</span> r_array]
V_TF = [thomas_fermi_screening(r, q_TF, Z) <span class="keyword">for</span> r <span class="keyword">in</span> r_array]

<span class="function">print</span>(<span class="string">"Charge Screening and Friedel Oscillations:"</span>)
<span class="function">print</span>(<span class="string">"=" * 50</span>)
<span class="function">print</span>(<span class="string">f"Fermi wave number: {k_F} √Ö‚Åª¬π"</span>)
<span class="function">print</span>(<span class="string">f"Thomas-Fermi wave number: {q_TF:.4f} √Ö‚Åª¬π"</span>)
<span class="function">print</span>(<span class="string">f"Friedel oscillation wavelength: {np.pi/k_F:.4f} √Ö"</span>)
<span class="function">print</span>(<span class="string">f"\nV_TF(r=1√Ö): {thomas_fermi_screening(1.0, q_TF, Z):.4f}"</span>)
<span class="function">print</span>(<span class="string">f"V_TF(r=5√Ö): {thomas_fermi_screening(5.0, q_TF, Z):.4f}"</span>)</code></pre></div>
<div class="output">Charge Screening and Friedel Oscillations:
==================================================
Fermi wave number: 1.36 √Ö‚Åª¬π
Thomas-Fermi wave number: 1.1560 √Ö‚Åª¬π
Friedel oscillation wavelength: 2.3091 √Ö

V_TF(r=1√Ö): 0.3166
V_TF(r=5√Ö): 0.0039</div>
<h2>Exercises</h2>
<div class="exercise">
<h3>Easy</h3>
<p><strong>Q1</strong>: In œÜ‚Å¥ theory, write down the tree-level propagator for the 2-point function and explain the symmetry factor.</p>
<details>
<summary>View Answer</summary>
<p>At tree level, there are no interaction vertices. Propagator: \(\frac{i}{p^2 - m^2 + i\epsilon}\)</p>
<p>Symmetry factor is 1 (no exchange symmetry).</p>
</details>
</div>
<div class="exercise">
<h3>Medium</h3>
<p><strong>Q2</strong>: In QED, calculate the tree-level amplitude for electron-positron annihilation \(e^+e^- \to \mu^+\mu^-\) and show the angular dependence.</p>
<details>
<summary>View Answer</summary>
<p>\(|M|^2 = 2e^4(1 + \cos^2\theta)\) (s-channel photon exchange)</p>
<p>Maximum in forward/backward directions, minimum in transverse direction.</p>
</details>
</div>
<div class="exercise">
<h3>Hard</h3>
<p><strong>Q3</strong>: In RPA, derive the condition where the dielectric function becomes zero (plasmon dispersion relation).</p>
<details>
<summary>View Answer</summary>
<p>From \(\epsilon(\mathbf{q}, \omega) = 0\), we get \(1 = V(\mathbf{q})\Pi(\mathbf{q}, \omega)\)</p>
<p>In the long wavelength limit, \(\omega \approx \omega_p\) (plasma frequency).</p>
</details>
</div>
<div class="nav-buttons">
<a class="nav-button" href="chapter-3.html">‚Üê Chapter 3</a>
<a class="nav-button" href="chapter-5.html">Proceed to Chapter 5 ‚Üí</a>
</div>
<h2>References</h2>
<ol>
<li>Peskin, M. E., &amp; Schroeder, D. V. (1995). <em>An Introduction to Quantum Field Theory</em>. Westview Press.</li>
<li>Srednicki, M. (2007). <em>Quantum Field Theory</em>. Cambridge University Press.</li>
<li>Mahan, G. D. (2000). <em>Many-Particle Physics</em> (3rd ed.). Springer.</li>
<li>Fetter, A. L., &amp; Walecka, J. D. (2003). <em>Quantum Theory of Many-Particle Systems</em>. Dover.</li>
</ol>
</div>
</div>
<footer>
<p>¬© 2025 AI Terakoya - Fundamentals of Mathematics &amp; Physics Dojo</p>
<p style="margin-top: 0.5rem;">Licensed under CC BY 4.0</p>
</footer>
<script>
        mermaid.initialize({ startOnLoad: true, theme: 'base' });
    </script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
</div></body>
</html>
