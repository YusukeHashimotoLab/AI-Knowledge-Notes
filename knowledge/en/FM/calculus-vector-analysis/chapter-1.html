<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Chapter 1: Fundamentals of Differentiation and Numerical Differentiation | Introduction to Calculus and Vector Analysis</title>
<meta content="Learn from the definition of differentiation to derivatives, higher-order derivatives, and NumPy numerical differentiation implementation." name="description"/>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\(', '\)']],
                displayMath: [['$$', '$$'], ['\[', '\]']],
                processEscapes: true
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
            }
        };
    </script>
<script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<link href="../../assets/css/knowledge-base.css" rel="stylesheet"/>
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet"/>
</head>
<body><div class="locale-switcher">
<span class="current-locale">üåê EN</span>
<span class="locale-separator">|</span>

<span class="locale-meta">Last sync: 2025-11-16</span>
</div>

<header>
<h1>Chapter 1: Fundamentals of Differentiation and Numerical Differentiation</h1>
<p class="subtitle">Fundamentals of Differentiation and Numerical Differentiation</p>
</header>
<div class="container">
<div class="breadcrumb">
<a href="../index.html">AI Terakoya Top</a> &gt;
            <a href="../index.html">FM Dojo</a> &gt;
            <a href="index.html">Calculus &amp; Vector Analysis</a> &gt;
            Chapter 1
        </div>
<div class="content">
<h2>1.1 Definition and Derivatives of Differentiation</h2>
<div class="definition">
<strong>üìê Definition: Differentiation</strong><br/>
                The derivative of function \(f(x)\) at \(x = a\) is defined as the limit:
                \[
                f'(a) = \lim_{h \to 0} \frac{f(a+h) - f(a)}{h}
                \]
                This value represents the slope of the tangent line at point \((a, f(a))\).
            </div>
<p>
                Differentiation represents the concept of "instantaneous rate of change" of a function. In materials science, it appears as the rate of change of physical properties with respect to temperature,
                in process engineering as reaction rates, and in machine learning as gradients of loss functions.
            </p>
<h3>üíª Code Example 1: Numerical Calculation of Derivatives (Forward Difference Method)</h3>
<div class="code-title">Python Implementation: Numerical Differentiation Using Forward Difference Method</div>
<div class="code-example"><pre><code class="language-python"># Requirements:
# - Python 3.9+
# - matplotlib&gt;=3.7.0
# - numpy&gt;=1.24.0, &lt;2.0.0

import numpy as np
import matplotlib.pyplot as plt

# Function definition: f(x) = x^2
def f(x):
    return x**2

# Approximation of derivative using forward difference method
def forward_difference(f, x, h=1e-5):
    &quot;&quot;&quot;Forward difference method: f'(x) ‚âà [f(x+h) - f(x)] / h&quot;&quot;&quot;
    return (f(x + h) - f(x)) / h

# Calculate derivative at x = 2
x0 = 2.0
numerical_derivative = forward_difference(f, x0)
analytical_derivative = 2 * x0  # Analytical solution: f'(x) = 2x

print(f&quot;Numerical derivative: f'({x0}) ‚âà {numerical_derivative:.6f}&quot;)
print(f&quot;Analytical solution:  f'({x0}) = {analytical_derivative:.6f}&quot;)
print(f&quot;Error:                {abs(numerical_derivative - analytical_derivative):.2e}&quot;)

# Visualization
x = np.linspace(0, 4, 100)
y = f(x)
tangent_y = analytical_derivative * (x - x0) + f(x0)

plt.figure(figsize=(8, 6))
plt.plot(x, y, label='f(x) = x¬≤', linewidth=2)
plt.plot(x, tangent_y, '--', label=f&quot;Tangent line (slope={analytical_derivative})&quot;, linewidth=2)
plt.scatter([x0], [f(x0)], color='red', s=100, zorder=5)
plt.xlabel('x', fontsize=12)
plt.ylabel('f(x)', fontsize=12)
plt.title('Derivative and Tangent Line', fontsize=14)
plt.legend()
plt.grid(True, alpha=0.3)
plt.show()
</code></pre></div>
<div class="output">
Numerical derivative: f'(2.0) ‚âà 4.000010
Analytical solution:  f'(2.0) = 4.000000
Error:                1.00e-05
            </div>
<h2>1.2 Differentiation Rules</h2>
<div class="theorem">
<strong>üìê Theorem: Basic Differentiation Formulas</strong><br/>
<ul style="margin-top: 0.5rem;">
<li>\((c)' = 0\) (constant function)</li>
<li>\((x^n)' = nx^{n-1}\) (power function)</li>
<li>\((e^x)' = e^x\) (exponential function)</li>
<li>\((\ln x)' = \frac{1}{x}\) (logarithmic function)</li>
<li>\((\sin x)' = \cos x, (\cos x)' = -\sin x\) (trigonometric functions)</li>
<li>\((cf)' = cf'\) (constant multiple)</li>
<li>\((f + g)' = f' + g'\) (sum rule)</li>
<li>\((fg)' = f'g + fg'\) (product rule)</li>
<li>\(\left(\frac{f}{g}\right)' = \frac{f'g - fg'}{g^2}\) (quotient rule)</li>
</ul>
</div>
<h3>üíª Code Example 2: Symbolic Differentiation Using SymPy</h3>
<div class="code-title">Python Implementation: Symbolic Differentiation Using SymPy</div>
<div class="code-example"><pre><code class="language-python">import sympy as sp

# Define symbolic variable
x = sp.Symbol('x')

# Differentiation of various functions
functions = [
    x**3,
    sp.exp(x),
    sp.ln(x),
    sp.sin(x),
    x**2 * sp.exp(x),
    sp.sin(x) / x
]

print("Examples of symbolic differentiation:")
for func in functions:
    derivative = sp.diff(func, x)
    print(f"d/dx({func}) = {derivative}")
</code></pre></div>
<div class="output">
Examples of symbolic differentiation:
d/dx(x**3) = 3*x**2
d/dx(exp(x)) = exp(x)
d/dx(log(x)) = 1/x
d/dx(sin(x)) = cos(x)
d/dx(x**2*exp(x)) = x**2*exp(x) + 2*x*exp(x)
d/dx(sin(x)/x) = -sin(x)/x**2 + cos(x)/x
            </div>
<h2>1.3 Comparison of Numerical Differentiation Methods</h2>
<p>
                In actual data analysis, numerical differentiation is often necessary when the functional form is unknown.
                Representative numerical differentiation methods include forward difference, backward difference, and central difference methods.
            </p>
<h3>üíª Code Example 3: Comparison of Forward, Backward, and Central Difference Methods</h3>
<div class="code-title">Python Implementation: Accuracy Comparison of Numerical Differentiation Methods</div>
<div class="code-example"><pre><code class="language-python">def forward_diff(f, x, h):
    """Forward difference method: O(h)"""
    return (f(x + h) - f(x)) / h

def backward_diff(f, x, h):
    """Backward difference method: O(h)"""
    return (f(x) - f(x - h)) / h

def central_diff(f, x, h):
    """Central difference method: O(h¬≤) - higher accuracy"""
    return (f(x + h) - f(x - h)) / (2 * h)

# Test function: f(x) = sin(x), f'(x) = cos(x)
f = np.sin
f_prime_exact = np.cos

x0 = np.pi / 4  # 45 degrees
exact = f_prime_exact(x0)

# Evaluate error for various step sizes
h_values = np.logspace(-10, -1, 50)
errors_forward = []
errors_backward = []
errors_central = []

for h in h_values:
    errors_forward.append(abs(forward_diff(f, x0, h) - exact))
    errors_backward.append(abs(backward_diff(f, x0, h) - exact))
    errors_central.append(abs(central_diff(f, x0, h) - exact))

# Visualization
plt.figure(figsize=(10, 6))
plt.loglog(h_values, errors_forward, label='Forward difference', marker='o', markersize=3)
plt.loglog(h_values, errors_backward, label='Backward difference', marker='s', markersize=3)
plt.loglog(h_values, errors_central, label='Central difference', marker='^', markersize=3)
plt.loglog(h_values, h_values, '--', label='O(h)', alpha=0.5)
plt.loglog(h_values, h_values**2, '--', label='O(h¬≤)', alpha=0.5)
plt.xlabel('Step size h', fontsize=12)
plt.ylabel('Absolute error', fontsize=12)
plt.title('Accuracy Comparison of Numerical Differentiation Methods', fontsize=14)
plt.legend()
plt.grid(True, alpha=0.3)
plt.show()

print(f"Analytical solution: cos(œÄ/4) = {exact:.10f}")
print(f"Forward difference (h=1e-5): {forward_diff(f, x0, 1e-5):.10f}")
print(f"Central difference (h=1e-5): {central_diff(f, x0, 1e-5):.10f}")</code></pre></div>
<div class="note">
<strong>üìù Note:</strong> The central difference method has higher accuracy (O(h¬≤)) than forward/backward difference methods,
                but requires twice the computational cost. In practice, choose based on the balance between accuracy and computational cost.
            </div>
<h2>1.4 Higher-Order Derivatives</h2>
<p>
                Further differentiation of a derivative is called higher-order derivatives. The second derivative f''(x) characterizes the convexity of the function,
                and third and higher-order derivatives characterize finer shape details.
            </p>
<h3>üíª Code Example 4: Numerical Calculation of Higher-Order Derivatives</h3>
<div class="code-block"><pre><code>def second_derivative(f, x, h=1e-5):
    """Second derivative: f''(x) ‚âà [f(x+h) - 2f(x) + f(x-h)] / h¬≤"""
    return (f(x + h) - 2*f(x) + f(x - h)) / h**2

def third_derivative(f, x, h=1e-4):
    """Third derivative (central difference)"""
    return (f(x + 2*h) - 2*f(x + h) + 2*f(x - h) - f(x - 2*h)) / (2 * h**3)

# Test function: f(x) = x^4
f = lambda x: x**4
x0 = 2.0

# Comparison of analytical and numerical solutions
print("Higher-order derivatives of f(x) = x^4 (x=2):")
print(f"f'(x) = 4x¬≥     ‚Üí f'(2) = {4 * x0**3:.1f} (analytical)")
print(f"f'(x)           ‚Üí f'(2) ‚âà {central_diff(f, x0, 1e-5):.6f} (numerical)")
print(f"f''(x) = 12x¬≤   ‚Üí f''(2) = {12 * x0**2:.1f} (analytical)")
print(f"f''(x)          ‚Üí f''(2) ‚âà {second_derivative(f, x0):.6f} (numerical)")
print(f"f'''(x) = 24x   ‚Üí f'''(2) = {24 * x0:.1f} (analytical)")
print(f"f'''(x)         ‚Üí f'''(2) ‚âà {third_derivative(f, x0):.6f} (numerical)")</code></pre></div>
<h2>1.5 Application to Materials Science: Thermal Expansion Coefficient</h2>
<div class="example">
<strong>üî¨ Application Example:</strong> The thermal expansion coefficient Œ± of a material is defined as the rate of change of length L with respect to temperature T:
                \[\alpha = \frac{1}{L}\frac{dL}{dT}\]
                Calculate the thermal expansion coefficient from measured data using numerical differentiation.
            </div>
<h3>üíª Code Example 5: Numerical Calculation of Thermal Expansion Coefficient</h3>
<div class="code-block"><pre><code># Experimental data: Temperature T (K) vs Length L (mm)
temperature = np.array([300, 350, 400, 450, 500, 550, 600])
length = np.array([100.000, 100.087, 100.175, 100.265, 100.357, 100.450, 100.545])

# Create smooth function using spline interpolation
from scipy.interpolate import UnivariateSpline
spline = UnivariateSpline(temperature, length, s=0, k=3)

# Obtain dL/dT by differentiation
dL_dT = spline.derivative()(temperature)

# Thermal expansion coefficient Œ± = (1/L) * dL/dT
alpha = dL_dT / length

# Display results
print("Thermal expansion coefficient calculation results:")
print("T (K)\tL (mm)\tdL/dT (mm/K)\tŒ± (1/K)")
for T, L, dLdT, a in zip(temperature, length, dL_dT, alpha):
    print(f"{T:.0f}\t{L:.3f}\t{dLdT:.6f}\t{a:.2e}")

# Visualization
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 5))

# Left plot: Temperature dependence of length
T_fine = np.linspace(300, 600, 100)
ax1.plot(temperature, length, 'o', label='Experimental data', markersize=8)
ax1.plot(T_fine, spline(T_fine), '-', label='Spline interpolation', linewidth=2)
ax1.set_xlabel('Temperature T (K)', fontsize=12)
ax1.set_ylabel('Length L (mm)', fontsize=12)
ax1.set_title('Thermal Expansion Curve', fontsize=14)
ax1.legend()
ax1.grid(True, alpha=0.3)

# Right plot: Temperature dependence of thermal expansion coefficient
ax2.plot(temperature, alpha * 1e6, 'o-', linewidth=2, markersize=8)
ax2.set_xlabel('Temperature T (K)', fontsize=12)
ax2.set_ylabel('Thermal expansion coefficient Œ± (10‚Åª‚Å∂/K)', fontsize=12)
ax2.set_title('Temperature Dependence of Thermal Expansion Coefficient', fontsize=14)
ax2.grid(True, alpha=0.3)

plt.tight_layout()
plt.show()</code></pre></div>
<h2>1.6 High-Precision Richardson Extrapolation</h2>
<p>
                Richardson extrapolation is a technique that combines numerical differentiation results at different step sizes
                to obtain more accurate approximations.
            </p>
<h3>üíª Code Example 6: Richardson Extrapolation</h3>
<div class="code-block"><pre><code>def richardson_extrapolation(f, x, h, order=4):
    """High-precision numerical differentiation using Richardson extrapolation"""
    # Central difference with different step sizes
    D1 = central_diff(f, x, h)
    D2 = central_diff(f, x, h/2)

    # First-order extrapolation (O(h‚Å¥) accuracy)
    D_improved = (4 * D2 - D1) / 3

    return D_improved

# Test: f(x) = exp(x), f'(x) = exp(x)
f = np.exp
x0 = 1.0
exact = np.exp(x0)

h = 0.1
D_central = central_diff(f, x0, h)
D_richardson = richardson_extrapolation(f, x0, h)

print(f"Analytical solution:     {exact:.10f}")
print(f"Central difference (h=0.1): {D_central:.10f}, error = {abs(D_central - exact):.2e}")
print(f"Richardson extrapolation:   {D_richardson:.10f}, error = {abs(D_richardson - exact):.2e}")
print(f"Accuracy improvement: {abs(D_central - exact) / abs(D_richardson - exact):.1f}x")</code></pre></div>
<h2>1.7 Practice Problems</h2>
<div class="exercise">
<strong>‚úèÔ∏è Exercise 1:</strong>
                For function f(x) = x¬≥ - 3x¬≤ + 2x + 1, find the derivative at x = 2
                (1) analytically, (2) using forward difference method, (3) using central difference method.
            </div>
<div class="exercise">
<strong>‚úèÔ∏è Exercise 2:</strong>
                A process variable y(t) is given as y(t) = 10 + 5sin(œÄt/10) with respect to time t.
                Find the rate of change dy/dt at t = 5 using numerical differentiation and determine the need for control.
            </div>
<h3>üíª Code Example 7: Solutions to Practice Problems</h3>
<div class="code-block"><pre><code># Solution to Exercise 1
x = sp.Symbol('x')
f_sym = x**3 - 3*x**2 + 2*x + 1
f_prime_sym = sp.diff(f_sym, x)
f_prime_at_2 = f_prime_sym.subs(x, 2)

f_num = lambda x: x**3 - 3*x**2 + 2*x + 1
x0 = 2.0

print("Solution to Exercise 1:")
print(f"(1) Analytical solution: f'(2) = {f_prime_at_2}")
print(f"(2) Forward difference: f'(2) ‚âà {forward_diff(f_num, x0, 1e-5):.6f}")
print(f"(3) Central difference: f'(2) ‚âà {central_diff(f_num, x0, 1e-5):.6f}")

# Solution to Exercise 2
def y(t):
    return 10 + 5 * np.sin(np.pi * t / 10)

t0 = 5.0
dy_dt = central_diff(y, t0, 0.01)

print(f"\nSolution to Exercise 2:")
print(f"dy/dt at t = 5 = {dy_dt:.4f}")
print(f"Analytical solution: dy/dt = (5œÄ/10)cos(œÄ¬∑5/10) = {5*np.pi/10 * np.cos(np.pi*5/10):.4f}")
if abs(dy_dt) &gt; 0.5:
    print("‚Üí Control intervention required due to large rate of change")</code></pre></div>
<h2>Summary</h2>
<ul>
<li>Differentiation represents the instantaneous rate of change of a function and can be geometrically interpreted as the slope of a tangent line</li>
<li>In numerical differentiation, the central difference method has higher accuracy (O(h¬≤)) than forward/backward difference methods</li>
<li>Richardson extrapolation enables even higher-precision numerical differentiation</li>
<li>In materials science, differentiation is used to calculate various physical properties such as thermal expansion coefficient and reaction rates</li>
<li>It is important to use symbolic differentiation with SymPy and numerical differentiation with NumPy appropriately</li>
</ul>
<div class="nav-buttons">
<a class="nav-button" href="index.html">‚Üê Series Top</a>
<a class="nav-button" href="chapter-2.html">Chapter 2: Fundamentals of Integration ‚Üí</a>
</div>
</div>
</div>
<footer>
<p>¬© 2025 AI Terakoya - Fundamentals of Mathematics</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
</body>
</html>
