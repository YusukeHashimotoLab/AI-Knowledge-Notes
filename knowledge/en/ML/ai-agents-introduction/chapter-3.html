<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<meta content="Multi-Agent Systems - AI Agents Introduction Series Chapter 3" name="description"/>
<title>Chapter 3: Multi-Agent Systems - AI Agents Introduction Series</title>
<!-- MathJax for formulas -->
<script src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js"></script>
<!-- CSS Styling -->
<link href="../../assets/css/knowledge-base.css" rel="stylesheet"/>
<script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
<script>
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof mermaid !== 'undefined') {
                mermaid.initialize({ startOnLoad: true, theme: 'default' });
            }
        });
    </script>
</head>
<body>
<nav class="breadcrumb">
<div class="breadcrumb-content">
<a href="../index.html">AI Terakoya Top</a><span class="breadcrumb-separator">‚Ä∫</span><a href="../../ML/index.html">Machine Learning</a><span class="breadcrumb-separator">‚Ä∫</span><a href="../../ML/ai-agents-introduction/index.html">AI Agents</a><span class="breadcrumb-separator">‚Ä∫</span><span class="breadcrumb-current">Chapter 3</span>
</div>
</nav>
<header>
<div class="container">
<h1>Chapter 3: Multi-Agent Systems</h1>
<p style="font-size: 1.1rem; margin-top: 0.5rem; opacity: 0.95;">Solving Complex Tasks Through Collaboration of Multiple Agents</p>
<div class="meta">
<span>üìñ Reading Time: 30-35 minutes</span>
<span>üìä Difficulty: Advanced</span>
<span>üíª Code Examples: 5</span>
</div>
</div>
</header>
<main class="container">
<h2 id="intro">What are Multi-Agent Systems</h2>
<h3>Why Multiple Agents are Needed</h3>
<p>Complex tasks that are difficult for a single agent to solve can be handled more efficiently and with higher quality when multiple specialized agents collaborate.</p>
<p><strong>Advantages of Multi-Agent Systems</strong>:</p>
<ul>
<li>‚úÖ <strong>Specialization</strong>: Each agent specializes in a specific role</li>
<li>‚úÖ <strong>Parallel Processing</strong>: Independent tasks executed simultaneously</li>
<li>‚úÖ <strong>Scalability</strong>: Number of agents can be dynamically adjusted</li>
<li>‚úÖ <strong>Fault Tolerance</strong>: Partial failures covered by others</li>
<li>‚úÖ <strong>Modularity</strong>: Easy to add or remove agents</li>
</ul>
<h3>Types of Multi-Agent Architectures</h3>
<table>
<thead>
<tr>
<th>Architecture</th>
<th>Characteristics</th>
<th>Application Scenarios</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Parallel</strong></td>
<td>Agents execute independently in parallel</td>
<td>Data collection, multi-perspective analysis</td>
</tr>
<tr>
<td><strong>Sequential</strong></td>
<td>Agents pass processing sequentially</td>
<td>Pipeline processing, incremental improvement</td>
</tr>
<tr>
<td><strong>Hierarchical</strong></td>
<td>Manager controls subordinate workers</td>
<td>Separation of complex planning and execution</td>
</tr>
<tr>
<td><strong>Interactive</strong></td>
<td>Agents discuss and negotiate</td>
<td>Decision making, consensus building</td>
</tr>
</tbody>
</table>
<h2 id="design">Multi-Agent Design</h2>
<h3>Agent Role Division</h3>
<div class="mermaid">
graph TD
    M[Manager Agent<br/>Task decomposition and coordination] --&gt; R[Researcher Agent<br/>Information gathering]
    M --&gt; W[Writer Agent<br/>Document creation]
    M --&gt; C[Critic Agent<br/>Review and evaluation]

    R --&gt; M
    W --&gt; M
    C --&gt; M

    style M fill:#e3f2fd
    style R fill:#fff3e0
    style W fill:#f3e5f5
    style C fill:#e8f5e9
</div>
<h3>Example of Role-Based Design</h3>
<pre><code class="language-python">from typing import List, Dict, Any
from dataclasses import dataclass

@dataclass
class AgentRole:
    """Agent role definition"""
    name: str
    description: str
    capabilities: List[str]
    system_prompt: str

# Define agent roles
RESEARCHER_ROLE = AgentRole(
    name="Researcher",
    description="Expert in information gathering and analysis",
    capabilities=["web_search", "database_query", "data_analysis"],
    system_prompt="""You are an excellent researcher.

Role:
- Collect relevant information from web searches and databases
- Evaluate the reliability of collected information
- Summarize key points and report to the team

Important notes:
- Cite information sources
- Cross-check multiple sources
- Explicitly indicate uncertain information"""
)

WRITER_ROLE = AgentRole(
    name="Writer",
    description="Expert in document creation",
    capabilities=["content_generation", "formatting", "editing"],
    system_prompt="""You are an excellent writer.

Role:
- Create high-quality documents based on researcher's information
- Readable and logical structure
- Appropriate style and tone for target audience

Important notes:
- Clear and concise expression
- Appropriate headings and paragraph structure
- Proper use of citations and references"""
)

CRITIC_ROLE = AgentRole(
    name="Critic",
    description="Expert in quality review",
    capabilities=["quality_check", "fact_verification", "feedback"],
    system_prompt="""You are a reviewer with critical thinking.

Role:
- Critically review created documents
- Verify factual accuracy
- Present specific improvement points

Important notes:
- Constructive feedback
- Specific improvement suggestions
- Clearly point out critical issues"""
)
</code></pre>
<h2 id="communication">Communication Protocols</h2>
<h3>Message Passing</h3>
<p>Communication between agents occurs through structured messages.</p>
<pre><code class="language-python">from dataclasses import dataclass
from typing import Optional, Dict, Any
from datetime import datetime
from enum import Enum

class MessageType(Enum):
    """Message types"""
    TASK = "task"              # Task instruction
    RESULT = "result"          # Task result
    QUERY = "query"            # Information request
    RESPONSE = "response"      # Information response
    ERROR = "error"            # Error notification
    STATUS = "status"          # Status update

@dataclass
class Message:
    """Inter-agent message"""
    type: MessageType
    sender: str
    receiver: str
    content: Dict[str, Any]
    timestamp: datetime
    message_id: str
    reply_to: Optional[str] = None

class MessageBus:
    """Message bus (inter-agent communication)"""

    def __init__(self):
        self.messages: List[Message] = []
        self.subscribers: Dict[str, List[callable]] = {}

    def subscribe(self, agent_name: str, callback: callable):
        """Register agent for message reception"""
        if agent_name not in self.subscribers:
            self.subscribers[agent_name] = []
        self.subscribers[agent_name].append(callback)

    def publish(self, message: Message):
        """Deliver message"""
        self.messages.append(message)

        # Deliver message to receiver
        if message.receiver in self.subscribers:
            for callback in self.subscribers[message.receiver]:
                callback(message)

    def broadcast(self, message: Message):
        """Broadcast to all agents"""
        self.messages.append(message)

        for agent_name, callbacks in self.subscribers.items():
            if agent_name != message.sender:
                for callback in callbacks:
                    callback(message)

# Usage example
import uuid

bus = MessageBus()

def researcher_receive(message: Message):
    print(f"Researcher received: {message.type.value} from {message.sender}")

def writer_receive(message: Message):
    print(f"Writer received: {message.type.value} from {message.sender}")

# Register agents
bus.subscribe("researcher", researcher_receive)
bus.subscribe("writer", writer_receive)

# Send message
task_message = Message(
    type=MessageType.TASK,
    sender="manager",
    receiver="researcher",
    content={"task": "Research AI trends in 2024"},
    timestamp=datetime.now(),
    message_id=str(uuid.uuid4())
)

bus.publish(task_message)
</code></pre>
<h3>Shared Memory Approach</h3>
<pre><code class="language-python">from typing import Dict, Any, Optional
import threading

class SharedMemory:
    """Shared memory between agents"""

    def __init__(self):
        self.data: Dict[str, Any] = {}
        self.lock = threading.Lock()
        self.subscribers: Dict[str, List[callable]] = {}

    def write(self, key: str, value: Any, agent_name: str):
        """Write data"""
        with self.lock:
            self.data[key] = {
                "value": value,
                "author": agent_name,
                "timestamp": datetime.now()
            }

            # Notify changes
            self._notify_subscribers(key, value, agent_name)

    def read(self, key: str) -&gt; Optional[Any]:
        """Read data"""
        with self.lock:
            if key in self.data:
                return self.data[key]["value"]
            return None

    def subscribe_to_key(self, key: str, callback: callable):
        """Monitor changes to specific key"""
        if key not in self.subscribers:
            self.subscribers[key] = []
        self.subscribers[key].append(callback)

    def _notify_subscribers(self, key: str, value: Any, agent_name: str):
        """Notify subscribers"""
        if key in self.subscribers:
            for callback in self.subscribers[key]:
                callback(key, value, agent_name)

# Usage example
memory = SharedMemory()

def on_research_complete(key, value, agent_name):
    print(f"Research completed by {agent_name}: {value}")

memory.subscribe_to_key("research_result", on_research_complete)

# Researcher writes result
memory.write("research_result", "Major AI trends in 2024...", "researcher")
</code></pre>
<h2 id="patterns">Collaboration Patterns</h2>
<h3>1. Parallel Execution Pattern</h3>
<pre><code class="language-python">import asyncio
from typing import List, Dict, Any

class ParallelAgentSystem:
    """Parallel execution agent system"""

    def __init__(self, agents: List[Any]):
        self.agents = agents

    async def execute_parallel(self, task: str) -&gt; List[Dict[str, Any]]:
        """Execute all agents in parallel"""
        tasks = [
            agent.process(task)
            for agent in self.agents
        ]

        results = await asyncio.gather(*tasks, return_exceptions=True)

        # Aggregate results
        successful_results = []
        for i, result in enumerate(results):
            if isinstance(result, Exception):
                print(f"Agent {i} failed: {str(result)}")
            else:
                successful_results.append({
                    "agent": self.agents[i].name,
                    "result": result
                })

        return successful_results

# Usage example (pseudo-code)
class ResearchAgent:
    def __init__(self, name: str, specialty: str):
        self.name = name
        self.specialty = specialty

    async def process(self, query: str) -&gt; Dict[str, Any]:
        # Execute research asynchronously
        await asyncio.sleep(1)  # Simulate API call
        return {
            "specialty": self.specialty,
            "findings": f"Research results on {query} regarding {self.specialty}"
        }

# Execute multiple specialized agents in parallel
agents = [
    ResearchAgent("Tech Researcher", "Technology trends"),
    ResearchAgent("Market Researcher", "Market analysis"),
    ResearchAgent("Academic Researcher", "Academic research")
]

system = ParallelAgentSystem(agents)
results = asyncio.run(system.execute_parallel("AI in 2024"))
print(results)
</code></pre>
<h3>2. Sequential Execution (Pipeline) Pattern</h3>
<pre><code class="language-python">from typing import Any, List, Callable

class SequentialAgentSystem:
    """Sequential execution agent system (pipeline)"""

    def __init__(self):
        self.pipeline: List[Callable] = []

    def add_stage(self, agent: Callable):
        """Add agent to pipeline"""
        self.pipeline.append(agent)

    def execute(self, initial_input: Any) -&gt; Any:
        """Execute pipeline"""
        current_data = initial_input

        for i, agent in enumerate(self.pipeline):
            print(f"Stage {i+1}: {agent.__name__}")
            current_data = agent(current_data)
            print(f"  Output: {current_data}\n")

        return current_data

# Pipeline stage agents
def data_collector(query: str) -&gt; Dict[str, Any]:
    """Stage 1: Data collection"""
    return {
        "query": query,
        "raw_data": f"Raw data on {query}...",
        "sources": ["source1", "source2"]
    }

def data_analyzer(data: Dict[str, Any]) -&gt; Dict[str, Any]:
    """Stage 2: Data analysis"""
    data["analysis"] = "Analysis results: Main trends are..."
    data["insights"] = ["Insight 1", "Insight 2"]
    return data

def report_generator(data: Dict[str, Any]) -&gt; str:
    """Stage 3: Report generation"""
    report = f"""
Research Report: {data['query']}

Analysis Results:
{data['analysis']}

Key Insights:
- {data['insights'][0]}
- {data['insights'][1]}

Sources: {', '.join(data['sources'])}
    """
    return report.strip()

# Build and execute pipeline
pipeline = SequentialAgentSystem()
pipeline.add_stage(data_collector)
pipeline.add_stage(data_analyzer)
pipeline.add_stage(report_generator)

final_report = pipeline.execute("Latest trends in AI agents")
print("=== Final Report ===")
print(final_report)
</code></pre>
<h3>3. Hierarchical (Manager-Worker) Pattern</h3>
<pre><code class="language-python">from typing import List, Dict, Any
from openai import OpenAI

class ManagerAgent:
    """Manager agent (task decomposition and coordination)"""

    def __init__(self, api_key: str, workers: List[Any]):
        self.client = OpenAI(api_key=api_key)
        self.workers = workers
        self.task_history = []

    def execute(self, user_request: str) -&gt; str:
        """Process user request"""
        # Step 1: Decompose task
        subtasks = self.decompose_task(user_request)

        # Step 2: Delegate to workers
        results = self.delegate_to_workers(subtasks)

        # Step 3: Synthesize results
        final_result = self.synthesize_results(user_request, results)

        return final_result

    def decompose_task(self, request: str) -&gt; List[Dict[str, Any]]:
        """Decompose task into subtasks"""
        worker_capabilities = "\n".join([
            f"- {w.name}: {w.capabilities}"
            for w in self.workers
        ])

        prompt = f"""Decompose the following request into subtasks to be assigned to available workers.

Request: {request}

Available workers:
{worker_capabilities}

Output each subtask in the following format:
1. [Worker name] Task description
2. [Worker name] Task description
..."""

        response = self.client.chat.completions.create(
            model="gpt-4",
            messages=[{"role": "user", "content": prompt}],
            temperature=0
        )

        # Parse subtasks (simplified version)
        subtasks = []
        for line in response.choices[0].message.content.split('\n'):
            if line.strip() and line[0].isdigit():
                parts = line.split(']', 1)
                if len(parts) == 2:
                    worker_name = parts[0].split('[')[1].strip()
                    task_desc = parts[1].strip()
                    subtasks.append({
                        "worker": worker_name,
                        "task": task_desc
                    })

        return subtasks

    def delegate_to_workers(self, subtasks: List[Dict[str, Any]]) -&gt; List[Dict[str, Any]]:
        """Delegate tasks to workers"""
        results = []

        for subtask in subtasks:
            worker_name = subtask["worker"]
            task = subtask["task"]

            # Find corresponding worker
            worker = next((w for w in self.workers if w.name == worker_name), None)

            if worker:
                result = worker.execute(task)
                results.append({
                    "worker": worker_name,
                    "task": task,
                    "result": result
                })
            else:
                results.append({
                    "worker": worker_name,
                    "task": task,
                    "result": f"Error: Worker {worker_name} not found"
                })

        return results

    def synthesize_results(self, original_request: str, results: List[Dict[str, Any]]) -&gt; str:
        """Synthesize results to generate final answer"""
        results_text = "\n\n".join([
            f"{r['worker']}'s result:\n{r['result']}"
            for r in results
        ])

        prompt = f"""Generate a final answer by synthesizing the results from each worker for the following request.

Original request: {original_request}

Worker results:
{results_text}

Generate synthesized answer:"""

        response = self.client.chat.completions.create(
            model="gpt-4",
            messages=[{"role": "user", "content": prompt}],
            temperature=0.7
        )

        return response.choices[0].message.content

class WorkerAgent:
    """Worker agent"""

    def __init__(self, name: str, capabilities: str, system_prompt: str, api_key: str):
        self.name = name
        self.capabilities = capabilities
        self.system_prompt = system_prompt
        self.client = OpenAI(api_key=api_key)

    def execute(self, task: str) -&gt; str:
        """Execute task"""
        response = self.client.chat.completions.create(
            model="gpt-4",
            messages=[
                {"role": "system", "content": self.system_prompt},
                {"role": "user", "content": task}
            ],
            temperature=0.7
        )

        return response.choices[0].message.content

# Usage example
researcher = WorkerAgent(
    name="Researcher",
    capabilities="Web search, data collection",
    system_prompt="You are a research expert.",
    api_key="your-api-key"
)

writer = WorkerAgent(
    name="Writer",
    capabilities="Document creation, editing",
    system_prompt="You are a document creation expert.",
    api_key="your-api-key"
)

manager = ManagerAgent(
    api_key="your-api-key",
    workers=[researcher, writer]
)

result = manager.execute("Create a 1000-word report on AI trends in 2024")
print(result)
</code></pre>
<h2 id="orchestration">Orchestration Strategies</h2>
<h3>Dynamic Task Assignment</h3>
<pre><code class="language-python">from typing import List, Dict, Any
import time

class TaskOrchestrator:
    """Task orchestrator"""

    def __init__(self, agents: List[Any]):
        self.agents = agents
        self.task_queue = []
        self.agent_status = {agent.name: "idle" for agent in agents}

    def add_task(self, task: Dict[str, Any]):
        """Add task to queue"""
        self.task_queue.append(task)

    def get_available_agent(self, required_capability: str = None):
        """Get available agent"""
        for agent in self.agents:
            if self.agent_status[agent.name] == "idle":
                if required_capability is None or required_capability in agent.capabilities:
                    return agent
        return None

    def execute_tasks(self):
        """Process task queue"""
        while self.task_queue:
            task = self.task_queue.pop(0)

            # Find appropriate agent
            agent = self.get_available_agent(task.get("required_capability"))

            if agent:
                print(f"Assigning task '{task['name']}' to {agent.name}")
                self.agent_status[agent.name] = "busy"

                # Execute task (assuming async)
                result = agent.execute(task)

                self.agent_status[agent.name] = "idle"
                print(f"{agent.name} completed task '{task['name']}'")
            else:
                # If agent is unavailable, return to queue
                self.task_queue.append(task)
                time.sleep(1)
</code></pre>
<h2 id="state">State Management and Conflict Resolution</h2>
<h3>Distributed State Synchronization</h3>
<pre><code class="language-python">from typing import Dict, Any, Optional
from datetime import datetime
import json

class StateManager:
    """State management between agents"""

    def __init__(self):
        self.state: Dict[str, Any] = {}
        self.version: Dict[str, int] = {}
        self.history: List[Dict[str, Any]] = []

    def update_state(self, key: str, value: Any, agent_name: str) -&gt; bool:
        """Update state (with version management)"""
        current_version = self.version.get(key, 0)

        # Record update
        update_record = {
            "key": key,
            "value": value,
            "agent": agent_name,
            "version": current_version + 1,
            "timestamp": datetime.now().isoformat()
        }

        self.state[key] = value
        self.version[key] = current_version + 1
        self.history.append(update_record)

        return True

    def get_state(self, key: str, version: Optional[int] = None) -&gt; Optional[Any]:
        """Get state (supports specific version)"""
        if version is None:
            return self.state.get(key)

        # Search history for specific version
        for record in reversed(self.history):
            if record["key"] == key and record["version"] == version:
                return record["value"]

        return None

    def resolve_conflict(self, key: str, conflicting_values: List[Dict[str, Any]]) -&gt; Any:
        """Resolve conflict"""
        # Adopt value with latest timestamp (Last-Write-Wins)
        latest = max(conflicting_values, key=lambda x: x["timestamp"])
        return latest["value"]

# Usage example
state_manager = StateManager()

# Multiple agents update same key
state_manager.update_state("document_title", "Introduction to AI Agents", "agent1")
state_manager.update_state("document_title", "Complete Guide to AI Agents", "agent2")

# Get latest value
current_title = state_manager.get_state("document_title")
print(f"Current title: {current_title}")

# Check history
print("\nUpdate history:")
for record in state_manager.history:
    print(f"  v{record['version']}: {record['value']} (by {record['agent']})")
</code></pre>
<h2 id="summary">Summary</h2>
<h3>What We Learned in This Chapter</h3>
<ul>
<li>‚úÖ <strong>Multi-agent design</strong>: Role division and specialization</li>
<li>‚úÖ <strong>Communication protocols</strong>: Message passing and shared memory</li>
<li>‚úÖ <strong>Collaboration patterns</strong>: Parallel, sequential, and hierarchical implementations</li>
<li>‚úÖ <strong>Orchestration</strong>: Task assignment and coordination</li>
<li>‚úÖ <strong>State management</strong>: Distributed state synchronization and conflict resolution</li>
</ul>
<h3>Design Principles</h3>
<blockquote>
<p><strong>Effective multi-agent systems</strong> are realized through clear role division, efficient communication, appropriate orchestration, and robust state management</p>
</blockquote>
<div class="nav-buttons">
<a class="nav-button" href="./chapter2-tool-use.html">‚Üê Chapter 2: Tool Use</a>
<a class="nav-button" href="./chapter4-applications.html">Chapter 4: Practical Applications ‚Üí</a>
</div>
</main>
<div class="feedback-notice">
<h3>‚ö†Ô∏è Help Us Improve Content Quality</h3>
<p>This content was created with AI assistance. If you find errors or areas for improvement, please report them through one of the following methods:</p>
<div class="feedback-options">
<a class="feedback-button" href="https://forms.gle/9GfVBa2Qa7Uy9taQA" target="_blank">
                    üìù Correction Request Form
                </a>
<a class="feedback-button" href="mailto:yusuke.hashimoto.d8@tohoku.ac.jp">
                    ‚úâÔ∏è Contact by Email
                </a>
</div>
</div>
<footer>
<div class="container">
<p>¬© 2025 AI Terakoya - Dr. Yusuke Hashimoto, Tohoku University</p>
<p>Licensed under CC BY 4.0</p>
</div>
</footer>
</body>
</html>
