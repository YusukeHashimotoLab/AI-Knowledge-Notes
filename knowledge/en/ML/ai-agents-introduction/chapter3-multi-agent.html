<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Multi-Agent Systems - AI Agents Introduction Series Chapter 3">
    <title>Chapter 3: Multi-Agent Systems - AI Agents Introduction Series</title>

    <!-- MathJax for formulas -->
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js"></script>

    <!-- CSS Styling -->
    <style>
        :root {
            --primary-color: #2c3e50;
            --secondary-color: #667eea;
            --accent-color: #764ba2;
            --bg-color: #ffffff;
            --text-color: #333333;
            --border-color: #e0e0e0;
            --code-bg: #f5f5f5;
            --link-color: #667eea;
            --link-hover: #764ba2;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Hiragino Sans", "Hiragino Kaku Gothic ProN", Meiryo, sans-serif;
            line-height: 1.8;
            color: var(--text-color);
            background: var(--bg-color);
            padding: 0;
            margin: 0;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 2rem 1.5rem;
        }

        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 2rem 0;
            margin-bottom: 2rem;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        header .container {
            padding: 0 1.5rem;
        }

        h1 {
            font-size: 2rem;
            margin-bottom: 0.5rem;
            font-weight: 700;
        }

        .meta {
            display: flex;
            gap: 1.5rem;
            flex-wrap: wrap;
            font-size: 0.9rem;
            opacity: 0.95;
            margin-top: 1rem;
        }

        .meta span {
            display: inline-flex;
            align-items: center;
            gap: 0.3rem;
        }

        h2 {
            font-size: 1.75rem;
            margin-top: 2.5rem;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 3px solid var(--secondary-color);
            color: var(--primary-color);
        }

        h3 {
            font-size: 1.4rem;
            margin-top: 2rem;
            margin-bottom: 0.8rem;
            color: var(--primary-color);
        }

        h4 {
            font-size: 1.2rem;
            margin-top: 1.5rem;
            margin-bottom: 0.6rem;
            color: var(--primary-color);
        }

        p {
            margin-bottom: 1.2rem;
        }

        a {
            color: var(--link-color);
            text-decoration: none;
            transition: color 0.2s;
        }

        a:hover {
            color: var(--link-hover);
            text-decoration: underline;
        }

        ul, ol {
            margin-left: 2rem;
            margin-bottom: 1.2rem;
        }

        li {
            margin-bottom: 0.5rem;
        }

        code {
            background: var(--code-bg);
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
            font-size: 0.9em;
        }

        pre {
            background: var(--code-bg);
            padding: 1.5rem;
            border-radius: 8px;
            overflow-x: auto;
            margin-bottom: 1.5rem;
            border: 1px solid var(--border-color);
        }

        pre code {
            background: none;
            padding: 0;
            font-size: 0.9rem;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 1.5rem;
            overflow-x: auto;
            display: block;
        }

        thead {
            display: table;
            width: 100%;
            table-layout: fixed;
        }

        tbody {
            display: table;
            width: 100%;
            table-layout: fixed;
        }

        th, td {
            padding: 0.8rem;
            text-align: left;
            border: 1px solid var(--border-color);
        }

        th {
            background: var(--primary-color);
            color: white;
            font-weight: 600;
        }

        tr:nth-child(even) {
            background: #f9f9f9;
        }

        blockquote {
            border-left: 4px solid var(--secondary-color);
            padding-left: 1.5rem;
            margin: 1.5rem 0;
            font-style: italic;
            color: #666;
        }

        img {
            max-width: 100%;
            height: auto;
            border-radius: 8px;
            margin: 1rem 0;
        }

        .mermaid {
            text-align: center;
            margin: 2rem 0;
            background: white;
            padding: 1rem;
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        details {
            margin: 1rem 0;
            padding: 1rem;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        summary {
            cursor: pointer;
            font-weight: 600;
            color: var(--primary-color);
            padding: 0.5rem;
        }

        summary:hover {
            color: var(--secondary-color);
        }

        footer {
            margin-top: 4rem;
            padding: 2rem 0;
            border-top: 2px solid var(--border-color);
            text-align: center;
            color: #666;
            font-size: 0.9rem;
        }

        .nav-buttons {
            display: flex;
            justify-content: space-between;
            margin: 3rem 0;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .nav-button {
            display: inline-block;
            padding: 0.8rem 1.5rem;
            background: var(--secondary-color);
            color: white;
            border-radius: 6px;
            text-decoration: none;
            transition: all 0.3s;
            font-weight: 600;
        }

        .nav-button:hover {
            background: var(--link-hover);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
            text-decoration: none;
        }

        @media (max-width: 768px) {
            .container {
                padding: 1rem;
            }

            h1 {
                font-size: 1.6rem;
            }

            h2 {
                font-size: 1.4rem;
            }

            .meta {
                font-size: 0.85rem;
            }

            pre {
                padding: 1rem;
                font-size: 0.85rem;
            }

            table {
                font-size: 0.9rem;
            }
        }

        .feedback-notice {
            background: #fff3cd;
            border: 2px solid #ffc107;
            border-radius: 8px;
            padding: 2rem;
            margin: 3rem auto;
            max-width: 900px;
        }

        .feedback-notice h3 {
            color: #856404;
            font-size: 1.3rem;
            margin-bottom: 1rem;
            text-align: center;
        }

        .feedback-notice p {
            color: #856404;
            font-size: 1rem;
            margin-bottom: 1.5rem;
            text-align: center;
        }

        .feedback-options {
            display: flex;
            justify-content: center;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .feedback-button {
            display: inline-block;
            padding: 0.8rem 1.5rem;
            background: #3498db;
            color: white;
            text-decoration: none;
            border-radius: 6px;
            font-weight: 600;
            transition: all 0.3s;
        }

        .feedback-button:hover {
            background: #2980b9;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
        }




        /* Breadcrumb styles */
        .breadcrumb {
            background: #f7fafc;
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #e2e8f0;
            font-size: 0.9rem;
        }

        .breadcrumb-content {
            max-width: 900px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .breadcrumb a {
            color: #667eea;
            text-decoration: none;
            transition: color 0.2s;
        }

        .breadcrumb a:hover {
            color: #764ba2;
            text-decoration: underline;
        }

        .breadcrumb-separator {
            color: #a0aec0;
            margin: 0 0.25rem;
        }

        .breadcrumb-current {
            color: #4a5568;
            font-weight: 500;
        }
    </style>

    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof mermaid !== 'undefined') {
                mermaid.initialize({ startOnLoad: true, theme: 'default' });
            }
        });
    </script>
</head>
<body>
            <nav class="breadcrumb">
        <div class="breadcrumb-content">
            <a href="../../index.html">AI Terakoya Home</a><span class="breadcrumb-separator">‚Ä∫</span><a href="../../ML/index.html">Machine Learning</a><span class="breadcrumb-separator">‚Ä∫</span><a href="../../ML/ai-agents-introduction/index.html">AI Agents</a><span class="breadcrumb-separator">‚Ä∫</span><span class="breadcrumb-current">Chapter 3</span>
        </div>
    </nav>

        <header>
        <div class="container">
            <h1>Chapter 3: Multi-Agent Systems</h1>
            <p style="font-size: 1.1rem; margin-top: 0.5rem; opacity: 0.95;">Solving Complex Tasks through Collaboration of Multiple Agents</p>
            <div class="meta">
                <span>üìñ Reading Time: 30-35 minutes</span>
                <span>üìä Difficulty: Advanced</span>
                <span>üíª Code Examples: 5</span>
            </div>
        </div>
    </header>

    <main class="container">
        <h2 id="intro">What are Multi-Agent Systems?</h2>

        <h3>Why Multiple Agents are Needed</h3>
        <p>Complex tasks that are difficult to solve with a single agent can be processed more efficiently and with higher quality when multiple specialized agents collaborate.</p>

        <p><strong>Advantages of Multi-Agent Systems</strong>:</p>
        <ul>
            <li>‚úÖ <strong>Specialization</strong>: Each agent specializes in a specific role</li>
            <li>‚úÖ <strong>Parallel Processing</strong>: Execute independent tasks simultaneously</li>
            <li>‚úÖ <strong>Scalability</strong>: Dynamically adjust the number of agents</li>
            <li>‚úÖ <strong>Fault Tolerance</strong>: Others can cover for partial failures</li>
            <li>‚úÖ <strong>Modularity</strong>: Easy to add or remove agents</li>
        </ul>

        <h3>Types of Multi-Agent Architectures</h3>

        <table>
            <thead>
                <tr>
                    <th>Architecture</th>
                    <th>Characteristics</th>
                    <th>Application Scenarios</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>Parallel</strong></td>
                    <td>Agents execute independently in parallel</td>
                    <td>Data collection, multi-perspective analysis</td>
                </tr>
                <tr>
                    <td><strong>Sequential</strong></td>
                    <td>Agents hand over processing in sequence</td>
                    <td>Pipeline processing, incremental refinement</td>
                </tr>
                <tr>
                    <td><strong>Hierarchical</strong></td>
                    <td>Manager controls subordinate workers</td>
                    <td>Separation of complex planning and execution</td>
                </tr>
                <tr>
                    <td><strong>Interactive</strong></td>
                    <td>Agents discuss and negotiate among themselves</td>
                    <td>Decision making, consensus building</td>
                </tr>
            </tbody>
        </table>

        <h2 id="design">Multi-Agent Design</h2>

        <h3>Agent Role Distribution</h3>

        <div class="mermaid">
graph TD
    M[Manager Agent<br/>Task decomposition and coordination] --> R[Researcher Agent<br/>Information gathering]
    M --> W[Writer Agent<br/>Document creation]
    M --> C[Critic Agent<br/>Review and evaluation]

    R --> M
    W --> M
    C --> M

    style M fill:#e3f2fd
    style R fill:#fff3e0
    style W fill:#f3e5f5
    style C fill:#e8f5e9
</div>

        <h3>Example of Role-Based Design</h3>

        <pre><code class="language-python">from typing import List, Dict, Any
from dataclasses import dataclass

@dataclass
class AgentRole:
    """Agent role definition"""
    name: str
    description: str
    capabilities: List[str]
    system_prompt: str

# Agent role definitions
RESEARCHER_ROLE = AgentRole(
    name="Researcher",
    description="Expert in information gathering and analysis",
    capabilities=["web_search", "database_query", "data_analysis"],
    system_prompt="""You are an excellent researcher.

Role:
- Gather related information from web searches and databases
- Evaluate the credibility of collected information
- Summarize key points and report to the team

Important points:
- Clearly cite information sources
- Cross-check multiple information sources
- Explicitly indicate uncertain information"""
)

WRITER_ROLE = AgentRole(
    name="Writer",
    description="Expert in document creation",
    capabilities=["content_generation", "formatting", "editing"],
    system_prompt="""You are an excellent writer.

Role:
- Create high-quality documents based on researcher's information
- Readable and logical structure
- Writing style and tone appropriate for the target audience

Important points:
- Clear and concise expression
- Appropriate heading and paragraph structure
- Proper use of citations and references"""
)

CRITIC_ROLE = AgentRole(
    name="Critic",
    description="Expert in quality review",
    capabilities=["quality_check", "fact_verification", "feedback"],
    system_prompt="""You are a reviewer with critical thinking skills.

Role:
- Critically review created documents
- Verify factual accuracy
- Provide specific improvement points

Important points:
- Constructive feedback
- Specific improvement suggestions
- Clearly point out serious issues"""
)
</code></pre>

        <h2 id="communication">Communication Protocols</h2>

        <h3>Message Passing</h3>
        <p>Communication between agents is conducted through structured messages.</p>

        <pre><code class="language-python">from dataclasses import dataclass
from typing import Optional, Dict, Any
from datetime import datetime
from enum import Enum

class MessageType(Enum):
    """Message types"""
    TASK = "task"              # Task instruction
    RESULT = "result"          # Task result
    QUERY = "query"            # Information request
    RESPONSE = "response"      # Information response
    ERROR = "error"            # Error notification
    STATUS = "status"          # Status update

@dataclass
class Message:
    """Inter-agent message"""
    type: MessageType
    sender: str
    receiver: str
    content: Dict[str, Any]
    timestamp: datetime
    message_id: str
    reply_to: Optional[str] = None

class MessageBus:
    """Message bus (inter-agent communication)"""

    def __init__(self):
        self.messages: List[Message] = []
        self.subscribers: Dict[str, List[callable]] = {}

    def subscribe(self, agent_name: str, callback: callable):
        """Register agent for message reception"""
        if agent_name not in self.subscribers:
            self.subscribers[agent_name] = []
        self.subscribers[agent_name].append(callback)

    def publish(self, message: Message):
        """Deliver message"""
        self.messages.append(message)

        # Deliver message to receiver
        if message.receiver in self.subscribers:
            for callback in self.subscribers[message.receiver]:
                callback(message)

    def broadcast(self, message: Message):
        """Broadcast to all agents"""
        self.messages.append(message)

        for agent_name, callbacks in self.subscribers.items():
            if agent_name != message.sender:
                for callback in callbacks:
                    callback(message)

# Usage example
import uuid

bus = MessageBus()

def researcher_receive(message: Message):
    print(f"Researcher received: {message.type.value} from {message.sender}")

def writer_receive(message: Message):
    print(f"Writer received: {message.type.value} from {message.sender}")

# Register agents
bus.subscribe("researcher", researcher_receive)
bus.subscribe("writer", writer_receive)

# Send message
task_message = Message(
    type=MessageType.TASK,
    sender="manager",
    receiver="researcher",
    content={"task": "Research AI trends in 2024"},
    timestamp=datetime.now(),
    message_id=str(uuid.uuid4())
)

bus.publish(task_message)
</code></pre>

        <h3>Shared Memory Approach</h3>

        <pre><code class="language-python">from typing import Dict, Any, Optional
import threading

class SharedMemory:
    """Shared memory between agents"""

    def __init__(self):
        self.data: Dict[str, Any] = {}
        self.lock = threading.Lock()
        self.subscribers: Dict[str, List[callable]] = {}

    def write(self, key: str, value: Any, agent_name: str):
        """Write data"""
        with self.lock:
            self.data[key] = {
                "value": value,
                "author": agent_name,
                "timestamp": datetime.now()
            }

            # Notify changes
            self._notify_subscribers(key, value, agent_name)

    def read(self, key: str) -> Optional[Any]:
        """Read data"""
        with self.lock:
            if key in self.data:
                return self.data[key]["value"]
            return None

    def subscribe_to_key(self, key: str, callback: callable):
        """Watch for changes to a specific key"""
        if key not in self.subscribers:
            self.subscribers[key] = []
        self.subscribers[key].append(callback)

    def _notify_subscribers(self, key: str, value: Any, agent_name: str):
        """Notify subscribers"""
        if key in self.subscribers:
            for callback in self.subscribers[key]:
                callback(key, value, agent_name)

# Usage example
memory = SharedMemory()

def on_research_complete(key, value, agent_name):
    print(f"Research completed by {agent_name}: {value}")

memory.subscribe_to_key("research_result", on_research_complete)

# Researcher writes result
memory.write("research_result", "Major AI trends in 2024...", "researcher")
</code></pre>

        <h2 id="patterns">Collaboration Patterns</h2>

        <h3>1. Parallel Execution Pattern</h3>

        <pre><code class="language-python">import asyncio
from typing import List, Dict, Any

class ParallelAgentSystem:
    """Parallel execution agent system"""

    def __init__(self, agents: List[Any]):
        self.agents = agents

    async def execute_parallel(self, task: str) -> List[Dict[str, Any]]:
        """Execute all agents in parallel"""
        tasks = [
            agent.process(task)
            for agent in self.agents
        ]

        results = await asyncio.gather(*tasks, return_exceptions=True)

        # Aggregate results
        successful_results = []
        for i, result in enumerate(results):
            if isinstance(result, Exception):
                print(f"Agent {i} failed: {str(result)}")
            else:
                successful_results.append({
                    "agent": self.agents[i].name,
                    "result": result
                })

        return successful_results

# Usage example (pseudo-code)
class ResearchAgent:
    def __init__(self, name: str, specialty: str):
        self.name = name
        self.specialty = specialty

    async def process(self, query: str) -> Dict[str, Any]:
        # Execute research asynchronously
        await asyncio.sleep(1)  # Simulate API call
        return {
            "specialty": self.specialty,
            "findings": f"Research results on {query} regarding {self.specialty}"
        }

# Execute multiple specialized agents in parallel
agents = [
    ResearchAgent("Tech Researcher", "Technology trends"),
    ResearchAgent("Market Researcher", "Market analysis"),
    ResearchAgent("Academic Researcher", "Academic research")
]

system = ParallelAgentSystem(agents)
results = asyncio.run(system.execute_parallel("AI in 2024"))
print(results)
</code></pre>

        <h3>2. Sequential Execution (Pipeline) Pattern</h3>

        <pre><code class="language-python">from typing import Any, List, Callable

class SequentialAgentSystem:
    """Sequential execution agent system (pipeline)"""

    def __init__(self):
        self.pipeline: List[Callable] = []

    def add_stage(self, agent: Callable):
        """Add agent to pipeline"""
        self.pipeline.append(agent)

    def execute(self, initial_input: Any) -> Any:
        """Execute pipeline"""
        current_data = initial_input

        for i, agent in enumerate(self.pipeline):
            print(f"Stage {i+1}: {agent.__name__}")
            current_data = agent(current_data)
            print(f"  Output: {current_data}\n")

        return current_data

# Agents for each pipeline stage
def data_collector(query: str) -> Dict[str, Any]:
    """Stage 1: Data collection"""
    return {
        "query": query,
        "raw_data": f"Raw data regarding {query}...",
        "sources": ["source1", "source2"]
    }

def data_analyzer(data: Dict[str, Any]) -> Dict[str, Any]:
    """Stage 2: Data analysis"""
    data["analysis"] = "Analysis results: Main trends are..."
    data["insights"] = ["Insight 1", "Insight 2"]
    return data

def report_generator(data: Dict[str, Any]) -> str:
    """Stage 3: Report generation"""
    report = f"""
Research Report: {data['query']}

Analysis Results:
{data['analysis']}

Key Insights:
- {data['insights'][0]}
- {data['insights'][1]}

Sources: {', '.join(data['sources'])}
    """
    return report.strip()

# Build and execute pipeline
pipeline = SequentialAgentSystem()
pipeline.add_stage(data_collector)
pipeline.add_stage(data_analyzer)
pipeline.add_stage(report_generator)

final_report = pipeline.execute("Latest AI agent trends")
print("=== Final Report ===")
print(final_report)
</code></pre>

        <h3>3. Hierarchical (Manager-Worker) Pattern</h3>

        <pre><code class="language-python">from typing import List, Dict, Any
from openai import OpenAI

class ManagerAgent:
    """Manager agent (task decomposition and coordination)"""

    def __init__(self, api_key: str, workers: List[Any]):
        self.client = OpenAI(api_key=api_key)
        self.workers = workers
        self.task_history = []

    def execute(self, user_request: str) -> str:
        """Process user request"""
        # Step 1: Decompose task
        subtasks = self.decompose_task(user_request)

        # Step 2: Delegate to workers
        results = self.delegate_to_workers(subtasks)

        # Step 3: Synthesize results
        final_result = self.synthesize_results(user_request, results)

        return final_result

    def decompose_task(self, request: str) -> List[Dict[str, Any]]:
        """Decompose task into subtasks"""
        worker_capabilities = "\n".join([
            f"- {w.name}: {w.capabilities}"
            for w in self.workers
        ])

        prompt = f"""Please decompose the following request into subtasks to be assigned to available workers.

Request: {request}

Available workers:
{worker_capabilities}

Output each subtask in the following format:
1. [Worker name] Task description
2. [Worker name] Task description
..."""

        response = self.client.chat.completions.create(
            model="gpt-4",
            messages=[{"role": "user", "content": prompt}],
            temperature=0
        )

        # Parse subtasks (simplified version)
        subtasks = []
        for line in response.choices[0].message.content.split('\n'):
            if line.strip() and line[0].isdigit():
                parts = line.split(']', 1)
                if len(parts) == 2:
                    worker_name = parts[0].split('[')[1].strip()
                    task_desc = parts[1].strip()
                    subtasks.append({
                        "worker": worker_name,
                        "task": task_desc
                    })

        return subtasks

    def delegate_to_workers(self, subtasks: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Delegate tasks to workers"""
        results = []

        for subtask in subtasks:
            worker_name = subtask["worker"]
            task = subtask["task"]

            # Find the corresponding worker
            worker = next((w for w in self.workers if w.name == worker_name), None)

            if worker:
                result = worker.execute(task)
                results.append({
                    "worker": worker_name,
                    "task": task,
                    "result": result
                })
            else:
                results.append({
                    "worker": worker_name,
                    "task": task,
                    "result": f"Error: Worker {worker_name} not found"
                })

        return results

    def synthesize_results(self, original_request: str, results: List[Dict[str, Any]]) -> str:
        """Synthesize results and generate final answer"""
        results_text = "\n\n".join([
            f"{r['worker']}'s results:\n{r['result']}"
            for r in results
        ])

        prompt = f"""Please synthesize the results from each worker and generate a final answer for the following request.

Original request: {original_request}

Worker results:
{results_text}

Generate the synthesized answer:"""

        response = self.client.chat.completions.create(
            model="gpt-4",
            messages=[{"role": "user", "content": prompt}],
            temperature=0.7
        )

        return response.choices[0].message.content

class WorkerAgent:
    """Worker agent"""

    def __init__(self, name: str, capabilities: str, system_prompt: str, api_key: str):
        self.name = name
        self.capabilities = capabilities
        self.system_prompt = system_prompt
        self.client = OpenAI(api_key=api_key)

    def execute(self, task: str) -> str:
        """Execute task"""
        response = self.client.chat.completions.create(
            model="gpt-4",
            messages=[
                {"role": "system", "content": self.system_prompt},
                {"role": "user", "content": task}
            ],
            temperature=0.7
        )

        return response.choices[0].message.content

# Usage example
researcher = WorkerAgent(
    name="Researcher",
    capabilities="Web search, data collection",
    system_prompt="You are a research expert.",
    api_key="your-api-key"
)

writer = WorkerAgent(
    name="Writer",
    capabilities="Document creation, editing",
    system_prompt="You are a document creation expert.",
    api_key="your-api-key"
)

manager = ManagerAgent(
    api_key="your-api-key",
    workers=[researcher, writer]
)

result = manager.execute("Please create a 1000-word report on AI trends in 2024")
print(result)
</code></pre>

        <h2 id="orchestration">Orchestration Strategies</h2>

        <h3>Dynamic Task Assignment</h3>

        <pre><code class="language-python">from typing import List, Dict, Any
import time

class TaskOrchestrator:
    """Task orchestrator"""

    def __init__(self, agents: List[Any]):
        self.agents = agents
        self.task_queue = []
        self.agent_status = {agent.name: "idle" for agent in agents}

    def add_task(self, task: Dict[str, Any]):
        """Add task to queue"""
        self.task_queue.append(task)

    def get_available_agent(self, required_capability: str = None):
        """Get available agent"""
        for agent in self.agents:
            if self.agent_status[agent.name] == "idle":
                if required_capability is None or required_capability in agent.capabilities:
                    return agent
        return None

    def execute_tasks(self):
        """Process task queue"""
        while self.task_queue:
            task = self.task_queue.pop(0)

            # Find appropriate agent
            agent = self.get_available_agent(task.get("required_capability"))

            if agent:
                print(f"Assigning task '{task['name']}' to {agent.name}")
                self.agent_status[agent.name] = "busy"

                # Execute task (assuming asynchronous)
                result = agent.execute(task)

                self.agent_status[agent.name] = "idle"
                print(f"{agent.name} completed task '{task['name']}'")
            else:
                # If agent unavailable, return to queue
                self.task_queue.append(task)
                time.sleep(1)
</code></pre>

        <h2 id="state">State Management and Conflict Resolution</h2>

        <h3>Distributed State Synchronization</h3>

        <pre><code class="language-python">from typing import Dict, Any, Optional
from datetime import datetime
import json

class StateManager:
    """State management between agents"""

    def __init__(self):
        self.state: Dict[str, Any] = {}
        self.version: Dict[str, int] = {}
        self.history: List[Dict[str, Any]] = []

    def update_state(self, key: str, value: Any, agent_name: str) -> bool:
        """Update state (with versioning)"""
        current_version = self.version.get(key, 0)

        # Record update
        update_record = {
            "key": key,
            "value": value,
            "agent": agent_name,
            "version": current_version + 1,
            "timestamp": datetime.now().isoformat()
        }

        self.state[key] = value
        self.version[key] = current_version + 1
        self.history.append(update_record)

        return True

    def get_state(self, key: str, version: Optional[int] = None) -> Optional[Any]:
        """Get state (with specific version support)"""
        if version is None:
            return self.state.get(key)

        # Search for specific version in history
        for record in reversed(self.history):
            if record["key"] == key and record["version"] == version:
                return record["value"]

        return None

    def resolve_conflict(self, key: str, conflicting_values: List[Dict[str, Any]]) -> Any:
        """Resolve conflict"""
        # Adopt value with latest timestamp (Last-Write-Wins)
        latest = max(conflicting_values, key=lambda x: x["timestamp"])
        return latest["value"]

# Usage example
state_manager = StateManager()

# Multiple agents update same key
state_manager.update_state("document_title", "Introduction to AI Agents", "agent1")
state_manager.update_state("document_title", "Complete Guide to AI Agents", "agent2")

# Get latest value
current_title = state_manager.get_state("document_title")
print(f"Current title: {current_title}")

# Check history
print("\nUpdate history:")
for record in state_manager.history:
    print(f"  v{record['version']}: {record['value']} (by {record['agent']})")
</code></pre>

        <h2 id="summary">Summary</h2>

        <h3>What We Learned in This Chapter</h3>
        <ul>
            <li>‚úÖ <strong>Multi-Agent Design</strong>: Role distribution and specialization</li>
            <li>‚úÖ <strong>Communication Protocols</strong>: Message passing and shared memory</li>
            <li>‚úÖ <strong>Collaboration Patterns</strong>: Implementation of parallel, sequential, and hierarchical approaches</li>
            <li>‚úÖ <strong>Orchestration</strong>: Task assignment and coordination</li>
            <li>‚úÖ <strong>State Management</strong>: Distributed state synchronization and conflict resolution</li>
        </ul>

        <h3>Design Principles</h3>
        <blockquote>
            <p><strong>Effective multi-agent systems</strong> are realized through clear role distribution, efficient communication, appropriate orchestration, and robust state management</p>
        </blockquote>

        <div class="nav-buttons">
            <a href="./chapter2-tool-use.html" class="nav-button">‚Üê Chapter 2: Tool Use</a>
            <a href="./chapter4-applications.html" class="nav-button">Chapter 4: Practical Applications ‚Üí</a>
        </div>
    </main>


        <div class="feedback-notice">
            <h3>‚ö†Ô∏è Please Help Us Improve Content Quality</h3>
            <p>This content was created with AI assistance. If you find errors or areas for improvement, please report them using one of the following methods:</p>
            <div class="feedback-options">
                <a href="https://forms.gle/9GfVBa2Qa7Uy9taQA" target="_blank" class="feedback-button">
                    üìù Correction Request Form
                </a>
                <a href="mailto:yusuke.hashimoto.d8@tohoku.ac.jp" class="feedback-button">
                    ‚úâÔ∏è Contact via Email
                </a>
            </div>
        </div>

    <footer>
        <div class="container">
            <p>&copy; 2025 AI Terakoya - Dr. Yusuke Hashimoto, Tohoku University</p>
            <p>Licensed under CC BY 4.0</p>
        </div>
    </footer>
</body>
</html>
