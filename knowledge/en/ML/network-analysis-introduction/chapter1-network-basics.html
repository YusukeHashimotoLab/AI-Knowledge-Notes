<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 1: Fundamentals of Network Analysis - AI Terakoya</title>

    <style>
        :root {
            --color-primary: #2c3e50;
            --color-primary-dark: #1a252f;
            --color-accent: #7b2cbf;
            --color-accent-light: #9d4edd;
            --color-text: #2d3748;
            --color-text-light: #4a5568;
            --color-bg: #ffffff;
            --color-bg-alt: #f7fafc;
            --color-border: #e2e8f0;
            --color-code-bg: #f8f9fa;
            --color-link: #3182ce;
            --color-link-hover: #2c5aa0;

            --spacing-xs: 0.5rem;
            --spacing-sm: 1rem;
            --spacing-md: 1.5rem;
            --spacing-lg: 2rem;
            --spacing-xl: 3rem;

            --font-body: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            --font-mono: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;

            --border-radius: 8px;
            --box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-body);
            line-height: 1.7;
            color: var(--color-text);
            background-color: var(--color-bg);
            font-size: 16px;
        }

        header {
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            color: white;
            padding: var(--spacing-xl) var(--spacing-md);
            margin-bottom: var(--spacing-xl);
            box-shadow: var(--box-shadow);
        }

        .header-content {
            max-width: 900px;
            margin: 0 auto;
        }

        h1 {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: var(--spacing-sm);
            line-height: 1.2;
        }

        .subtitle {
            font-size: 1.1rem;
            opacity: 0.95;
            font-weight: 400;
            margin-bottom: var(--spacing-md);
        }

        .meta {
            display: flex;
            flex-wrap: wrap;
            gap: var(--spacing-md);
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .meta-item {
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 0 var(--spacing-md) var(--spacing-xl);
        }

        h2 {
            font-size: 1.75rem;
            color: var(--color-primary);
            margin-top: var(--spacing-xl);
            margin-bottom: var(--spacing-md);
            padding-bottom: var(--spacing-xs);
            border-bottom: 3px solid var(--color-accent);
        }

        h3 {
            font-size: 1.4rem;
            color: var(--color-primary);
            margin-top: var(--spacing-lg);
            margin-bottom: var(--spacing-sm);
        }

        h4 {
            font-size: 1.1rem;
            color: var(--color-primary-dark);
            margin-top: var(--spacing-md);
            margin-bottom: var(--spacing-sm);
        }

        p {
            margin-bottom: var(--spacing-md);
            color: var(--color-text);
        }

        a {
            color: var(--color-link);
            text-decoration: none;
            transition: color 0.2s;
        }

        a:hover {
            color: var(--color-link-hover);
            text-decoration: underline;
        }

        ul, ol {
            margin-left: var(--spacing-lg);
            margin-bottom: var(--spacing-md);
        }

        li {
            margin-bottom: var(--spacing-xs);
            color: var(--color-text);
        }

        pre {
            background-color: var(--color-code-bg);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            overflow-x: auto;
            margin-bottom: var(--spacing-md);
            font-family: var(--font-mono);
            font-size: 0.9rem;
            line-height: 1.5;
        }

        code {
            font-family: var(--font-mono);
            font-size: 0.9em;
            background-color: var(--color-code-bg);
            padding: 0.2em 0.4em;
            border-radius: 3px;
        }

        pre code {
            background-color: transparent;
            padding: 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: var(--spacing-md);
            font-size: 0.95rem;
        }

        th, td {
            border: 1px solid var(--color-border);
            padding: var(--spacing-sm);
            text-align: left;
        }

        th {
            background-color: var(--color-bg-alt);
            font-weight: 600;
            color: var(--color-primary);
        }

        blockquote {
            border-left: 4px solid var(--color-accent);
            padding-left: var(--spacing-md);
            margin: var(--spacing-md) 0;
            color: var(--color-text-light);
            font-style: italic;
            background-color: var(--color-bg-alt);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        .mermaid {
            text-align: center;
            margin: var(--spacing-lg) 0;
            background-color: var(--color-bg-alt);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        details {
            background-color: var(--color-bg-alt);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            margin-bottom: var(--spacing-md);
        }

        summary {
            cursor: pointer;
            font-weight: 600;
            color: var(--color-primary);
            user-select: none;
            padding: var(--spacing-xs);
            margin: calc(-1 * var(--spacing-md));
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        summary:hover {
            background-color: rgba(123, 44, 191, 0.1);
        }

        details[open] summary {
            margin-bottom: var(--spacing-md);
            border-bottom: 1px solid var(--color-border);
        }

        .navigation {
            display: flex;
            justify-content: space-between;
            gap: var(--spacing-md);
            margin: var(--spacing-xl) 0;
            padding-top: var(--spacing-lg);
            border-top: 2px solid var(--color-border);
        }

        .nav-button {
            flex: 1;
            padding: var(--spacing-md);
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            color: white;
            border-radius: var(--border-radius);
            text-align: center;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: var(--box-shadow);
        }

        .nav-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            text-decoration: none;
        }

        footer {
            margin-top: var(--spacing-xl);
            padding: var(--spacing-lg) var(--spacing-md);
            background-color: var(--color-bg-alt);
            border-top: 1px solid var(--color-border);
            text-align: center;
            font-size: 0.9rem;
            color: var(--color-text-light);
        }
        .disclaimer {
            max-width: 900px;
            margin: 2rem auto;
            padding: 1.5rem;
            background: #f8f9fa;
            border-left: 4px solid #6c757d;
            border-radius: 4px;
        }

        .disclaimer h3 {
            color: #495057;
            margin-bottom: 1rem;
            font-size: 1.1rem;
        }

        .disclaimer ul {
            list-style: none;
            padding-left: 0;
        }

        .disclaimer li {
            padding: 0.5rem 0;
            padding-left: 1.5rem;
            position: relative;
            font-size: 0.9rem;
            color: #6c757d;
            line-height: 1.6;
        }

        .disclaimer li::before {
            content: "‚ö†Ô∏è";
            position: absolute;
            left: 0;
        }


        @media (max-width: 768px) {
            h1 {
                font-size: 1.5rem;
            }

            h2 {
                font-size: 1.4rem;
            }

            h3 {
                font-size: 1.2rem;
            }

            .meta {
                font-size: 0.85rem;
            }

            .navigation {
                flex-direction: column;
            }

            table {
                font-size: 0.85rem;
            }

            th, td {
                padding: var(--spacing-xs);
            }
        }



        /* Breadcrumb styles */
        .breadcrumb {
            background: #f7fafc;
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #e2e8f0;
            font-size: 0.9rem;
        }

        .breadcrumb-content {
            max-width: 900px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .breadcrumb a {
            color: #667eea;
            text-decoration: none;
            transition: color 0.2s;
        }

        .breadcrumb a:hover {
            color: #764ba2;
            text-decoration: underline;
        }

        .breadcrumb-separator {
            color: #a0aec0;
            margin: 0 0.25rem;
        }

        .breadcrumb-current {
            color: #4a5568;
            font-weight: 500;
        }
    </style>

    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ startOnLoad: true, theme: 'default' });
    </script>

    <!-- MathJax for LaTeX equation rendering -->
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true,
                processEnvironments: true
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
                ignoreHtmlClass: 'mermaid'
            }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" id="MathJax-script" async></script>
</head>
<body>
            <nav class="breadcrumb">
        <div class="breadcrumb-content">
            <a href="../../index.html">AI Terakoya Top</a><span class="breadcrumb-separator">‚Ä∫</span><a href="../../ML/index.html">Machine Learning</a><span class="breadcrumb-separator">‚Ä∫</span><a href="../../ML/network-analysis-introduction/index.html">Network Analysis</a><span class="breadcrumb-separator">‚Ä∫</span><span class="breadcrumb-current">Chapter 1</span>
        </div>
    </nav>

        <header>
        <div class="header-content">
            <h1>Chapter 1: Fundamentals of Network Analysis</h1>
            <p class="subtitle">From Graph Theory to Practical Network Data Analysis</p>
            <div class="meta">
                <span class="meta-item">üìñ Reading time: 20-25 minutes</span>
                <span class="meta-item">üìä Difficulty: Beginner</span>
                <span class="meta-item">üíª Code examples: 8</span>
            </div>
        </div>
    </header>

    <main class="container">

<h2>Learning Objectives</h2>
<p>By reading this chapter, you will master the following:</p>
<ul>
<li>‚úÖ Understand fundamental concepts of graph theory (nodes, edges, directed/undirected graphs)</li>
<li>‚úÖ Learn different network representation methods and their conversion techniques</li>
<li>‚úÖ Calculate and interpret basic network metrics</li>
<li>‚úÖ Understand special graph structures (random, small-world, scale-free)</li>
<li>‚úÖ Practice loading real data and performing basic analysis using NetworkX</li>
</ul>

<hr>

<h2>1.1 Fundamentals of Graph Theory</h2>

<h3>Graph Definition</h3>
<p>A <strong>graph</strong> is a collection of <strong>nodes (vertices)</strong> and <strong>edges (links)</strong>. Mathematically, it is represented as $G = (V, E)$.</p>

<ul>
<li><strong>Nodes ($V$)</strong>: Components of the system (people, web pages, proteins, etc.)</li>
<li><strong>Edges ($E$)</strong>: Relationships between nodes (friendships, links, interactions, etc.)</li>
</ul>

<div class="mermaid">
graph LR
    A((Node A)) --- B((Node B))
    B --- C((Node C))
    C --- A
    C --- D((Node D))

    style A fill:#e3f2fd
    style B fill:#e3f2fd
    style C fill:#e3f2fd
    style D fill:#e3f2fd
</div>

<h3>Directed vs Undirected Graphs</h3>

<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
<th>Examples</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Undirected Graph</strong></td>
<td>Edges have no direction (symmetric relationships)</td>
<td>Friendship networks, co-authorship, road networks</td>
</tr>
<tr>
<td><strong>Directed Graph</strong></td>
<td>Edges have direction (asymmetric relationships)</td>
<td>Twitter follows, citation networks, web links</td>
</tr>
<tr>
<td><strong>Weighted Graph</strong></td>
<td>Edges have weights (strength, distance, etc.)</td>
<td>Transportation networks, communication frequency, transaction amounts</td>
</tr>
</tbody>
</table>

<h3>Basic NetworkX Operations</h3>

<pre><code class="language-python">import networkx as nx
import matplotlib.pyplot as plt

# Create an undirected graph
G = nx.Graph()

# Add nodes
G.add_node(1)
G.add_nodes_from([2, 3, 4, 5])

# Add edges
G.add_edge(1, 2)
G.add_edges_from([(1, 3), (2, 3), (3, 4), (4, 5)])

# Basic information
print("=== Basic Graph Information ===")
print(f"Number of nodes: {G.number_of_nodes()}")
print(f"Number of edges: {G.number_of_edges()}")
print(f"List of nodes: {list(G.nodes())}")
print(f"List of edges: {list(G.edges())}")

# Visualization
plt.figure(figsize=(8, 6))
nx.draw(G, with_labels=True, node_color='lightblue',
        node_size=800, font_size=16, font_weight='bold')
plt.title('Basic Undirected Graph')
plt.axis('off')
plt.tight_layout()
plt.show()
</code></pre>

<p><strong>Output</strong>:</p>
<pre><code>=== Basic Graph Information ===
Number of nodes: 5
Number of edges: 5
List of nodes: [1, 2, 3, 4, 5]
List of edges: [(1, 2), (1, 3), (2, 3), (3, 4), (4, 5)]
</code></pre>

<hr>

<h2>1.2 Network Representations</h2>

<h3>Three Main Representation Methods</h3>

<p>Networks can be represented in multiple ways. Each has its own advantages and disadvantages, and they are used according to the application.</p>

<h4>1. Adjacency Matrix</h4>

<p>An $n \times n$ matrix $A$ where $A_{ij} = 1$ if nodes $i$ and $j$ are connected.</p>

<pre><code class="language-python">import numpy as np

# Create a graph
G = nx.Graph()
G.add_edges_from([(0, 1), (0, 2), (1, 2), (2, 3)])

# Get adjacency matrix
adj_matrix = nx.adjacency_matrix(G).todense()

print("=== Adjacency Matrix ===")
print(adj_matrix)

# Visualize the matrix
plt.figure(figsize=(6, 5))
plt.imshow(adj_matrix, cmap='Blues', interpolation='nearest')
plt.colorbar()
plt.title('Adjacency Matrix Visualization')
plt.xlabel('Node')
plt.ylabel('Node')
plt.tight_layout()
plt.show()
</code></pre>

<p><strong>Output</strong>:</p>
<pre><code>=== Adjacency Matrix ===
[[0 1 1 0]
 [1 0 1 0]
 [1 1 0 1]
 [0 0 1 0]]
</code></pre>

<h4>2. Adjacency List</h4>

<p>Maintains a list of connected nodes for each node. Efficient for sparse graphs.</p>

<pre><code class="language-python"># Get adjacency list
adj_list = dict(G.adjacency())

print("=== Adjacency List ===")
for node, neighbors in adj_list.items():
    neighbor_list = list(neighbors.keys())
    print(f"Node {node}: {neighbor_list}")

# Memory efficiency comparison
print(f"\nAdjacency matrix size: {adj_matrix.nbytes} bytes")
print(f"Adjacency list size (estimated): {len(str(adj_list))} bytes")
</code></pre>

<p><strong>Output</strong>:</p>
<pre><code>=== Adjacency List ===
Node 0: [1, 2]
Node 1: [0, 2]
Node 2: [0, 1, 3]
Node 3: [2]

Adjacency matrix size: 128 bytes
Adjacency list size (estimated): 71 bytes
</code></pre>

<h4>3. Edge List</h4>

<p>Records all edges as (source, target) pairs. Convenient for data storage.</p>

<pre><code class="language-python"># Create edge list
edge_list = list(G.edges())

print("=== Edge List ===")
for i, (u, v) in enumerate(edge_list):
    print(f"Edge {i}: {u} -- {v}")

# Weighted edge list
G_weighted = nx.Graph()
G_weighted.add_weighted_edges_from([
    (0, 1, 2.5), (0, 2, 1.8), (1, 2, 3.2), (2, 3, 1.5)
])

print("\n=== Weighted Edge List ===")
for u, v, weight in G_weighted.edges(data='weight'):
    print(f"{u} -- {v}: weight = {weight}")
</code></pre>

<p><strong>Output</strong>:</p>
<pre><code>=== Edge List ===
Edge 0: 0 -- 1
Edge 1: 0 -- 2
Edge 2: 1 -- 2
Edge 3: 2 -- 3

=== Weighted Edge List ===
0 -- 1: weight = 2.5
0 -- 2: weight = 1.8
1 -- 2: weight = 3.2
2 -- 3: weight = 1.5
</code></pre>

<h3>Comparison and Conversion of Representation Methods</h3>

<table>
<thead>
<tr>
<th>Representation</th>
<th>Memory Efficiency</th>
<th>Adjacency Check</th>
<th>Edge Traversal</th>
<th>Use Cases</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Adjacency Matrix</strong></td>
<td>$O(n^2)$</td>
<td>$O(1)$</td>
<td>$O(n^2)$</td>
<td>Dense graphs, matrix operations</td>
</tr>
<tr>
<td><strong>Adjacency List</strong></td>
<td>$O(n + m)$</td>
<td>$O(d)$</td>
<td>$O(m)$</td>
<td>Sparse graphs, general analysis</td>
</tr>
<tr>
<td><strong>Edge List</strong></td>
<td>$O(m)$</td>
<td>$O(m)$</td>
<td>$O(m)$</td>
<td>Data storage, I/O operations</td>
</tr>
</tbody>
</table>

<blockquote>
<p>$n$ = number of nodes, $m$ = number of edges, $d$ = degree (average connections)</p>
</blockquote>

<hr>

<h2>1.3 Basic Network Metrics</h2>

<h3>Degree</h3>

<p>The number of edges a node has. Represents "connectivity" within the network.</p>

<pre><code class="language-python">import networkx as nx
import matplotlib.pyplot as plt
import numpy as np

# Sample graph
G = nx.karate_club_graph()

# Calculate degrees
degrees = dict(G.degree())

print("=== Degree Statistics ===")
print(f"Average degree: {np.mean(list(degrees.values())):.2f}")
print(f"Maximum degree: {max(degrees.values())}")
print(f"Minimum degree: {min(degrees.values())}")

# Visualize degree distribution
plt.figure(figsize=(12, 5))

# Histogram
plt.subplot(1, 2, 1)
plt.hist(list(degrees.values()), bins=20, edgecolor='black', alpha=0.7)
plt.xlabel('Degree')
plt.ylabel('Number of Nodes')
plt.title('Degree Distribution')
plt.grid(True, alpha=0.3)

# Network visualization (node size by degree)
plt.subplot(1, 2, 2)
node_sizes = [v * 50 for v in degrees.values()]
nx.draw_spring(G, node_size=node_sizes, node_color='lightblue',
               with_labels=True, font_size=8)
plt.title('Node Size by Degree')

plt.tight_layout()
plt.show()
</code></pre>

<h3>Density</h3>

<p>The ratio of actual edges to possible edges. Indicates network "compactness".</p>

<p>$$\text{Density} = \frac{2m}{n(n-1)}$$ (for undirected graphs)</p>

<pre><code class="language-python"># Calculate density
density = nx.density(G)

print(f"\n=== Network Density ===")
print(f"Density: {density:.4f}")
print(f"Actual number of edges: {G.number_of_edges()}")

n = G.number_of_nodes()
max_edges = n * (n - 1) // 2
print(f"Maximum possible edges: {max_edges}")
print(f"Connection rate: {(G.number_of_edges() / max_edges) * 100:.2f}%")
</code></pre>

<h3>Diameter and Clustering Coefficient</h3>

<pre><code class="language-python"># Diameter (longest shortest path)
if nx.is_connected(G):
    diameter = nx.diameter(G)
    avg_path_length = nx.average_shortest_path_length(G)
    print(f"\n=== Path Metrics ===")
    print(f"Diameter: {diameter}")
    print(f"Average shortest path length: {avg_path_length:.2f}")

# Clustering coefficient (triangle density)
clustering = nx.clustering(G)
avg_clustering = nx.average_clustering(G)

print(f"\n=== Clustering Coefficient ===")
print(f"Average clustering coefficient: {avg_clustering:.4f}")
print(f"Top 5 nodes by clustering coefficient:")
sorted_clustering = sorted(clustering.items(), key=lambda x: x[1], reverse=True)
for node, coef in sorted_clustering[:5]:
    print(f"  Node {node}: {coef:.4f}")
</code></pre>

<p><strong>Example Output</strong>:</p>
<pre><code>=== Degree Statistics ===
Average degree: 4.59
Maximum degree: 17
Minimum degree: 1

=== Network Density ===
Density: 0.1390
Actual number of edges: 78
Maximum possible edges: 561
Connection rate: 13.90%

=== Path Metrics ===
Diameter: 5
Average shortest path length: 2.41

=== Clustering Coefficient ===
Average clustering coefficient: 0.5706
Top 5 nodes by clustering coefficient:
  Node 4: 1.0000
  Node 6: 1.0000
  Node 7: 1.0000
  Node 10: 1.0000
  Node 11: 1.0000
</code></pre>

<hr>

<h2>1.4 Special Graph Structures</h2>

<h3>Random Graphs (Erd≈ës-R√©nyi Model)</h3>

<p>A model where edges exist independently between each node pair with probability $p$.</p>

<pre><code class="language-python">import networkx as nx
import matplotlib.pyplot as plt

# Erd≈ës-R√©nyi random graph
n = 30  # Number of nodes
p = 0.1  # Edge probability

G_random = nx.erdos_renyi_graph(n, p, seed=42)

print("=== Erd≈ës-R√©nyi Random Graph ===")
print(f"Number of nodes: {G_random.number_of_nodes()}")
print(f"Number of edges: {G_random.number_of_edges()}")
print(f"Average degree: {np.mean([d for n, d in G_random.degree()]):.2f}")
print(f"Clustering coefficient: {nx.average_clustering(G_random):.4f}")

# Visualization
plt.figure(figsize=(8, 8))
nx.draw_spring(G_random, node_color='lightcoral', node_size=300,
               with_labels=True, font_size=8)
plt.title(f'Erd≈ës-R√©nyi Random Graph (n={n}, p={p})')
plt.tight_layout()
plt.show()
</code></pre>

<h3>Small-World Networks (Watts-Strogatz Model)</h3>

<p>A model that achieves both high clustering coefficient and short average path length. Commonly observed in real-world networks.</p>

<pre><code class="language-python"># Watts-Strogatz small-world network
n = 30
k = 4    # Number of neighboring nodes each node connects to
p = 0.3  # Edge rewiring probability

G_small_world = nx.watts_strogatz_graph(n, k, p, seed=42)

print("\n=== Watts-Strogatz Small-World Network ===")
print(f"Number of nodes: {G_small_world.number_of_nodes()}")
print(f"Number of edges: {G_small_world.number_of_edges()}")
print(f"Average degree: {np.mean([d for n, d in G_small_world.degree()]):.2f}")
print(f"Clustering coefficient: {nx.average_clustering(G_small_world):.4f}")
if nx.is_connected(G_small_world):
    print(f"Average shortest path length: {nx.average_shortest_path_length(G_small_world):.2f}")

# Visualization
plt.figure(figsize=(8, 8))
nx.draw_circular(G_small_world, node_color='lightgreen', node_size=300,
                 with_labels=True, font_size=8)
plt.title(f'Watts-Strogatz Small-World (n={n}, k={k}, p={p})')
plt.tight_layout()
plt.show()
</code></pre>

<h3>Scale-Free Networks (Barab√°si-Albert Model)</h3>

<p>A network generated by "the rich get richer" (preferential attachment). The degree distribution follows a power law.</p>

<pre><code class="language-python"># Barab√°si-Albert scale-free network
n = 30
m = 2  # Number of edges a new node connects to

G_scale_free = nx.barabasi_albert_graph(n, m, seed=42)

print("\n=== Barab√°si-Albert Scale-Free Network ===")
print(f"Number of nodes: {G_scale_free.number_of_nodes()}")
print(f"Number of edges: {G_scale_free.number_of_edges()}")
print(f"Average degree: {np.mean([d for n, d in G_scale_free.degree()]):.2f}")
print(f"Maximum degree: {max([d for n, d in G_scale_free.degree()])}")

degrees = [d for n, d in G_scale_free.degree()]

# Visualize degree distribution (logarithmic scale)
fig, axes = plt.subplots(1, 2, figsize=(14, 6))

# Network structure
node_sizes = [d * 100 for d in degrees]
nx.draw_spring(G_scale_free, ax=axes[0], node_size=node_sizes,
               node_color='lightyellow', with_labels=True, font_size=8)
axes[0].set_title(f'Barab√°si-Albert Scale-Free (n={n}, m={m})')

# Degree distribution (log plot)
degree_counts = {}
for d in degrees:
    degree_counts[d] = degree_counts.get(d, 0) + 1

axes[1].loglog(list(degree_counts.keys()), list(degree_counts.values()),
               'bo-', markersize=8)
axes[1].set_xlabel('Degree (log scale)')
axes[1].set_ylabel('Frequency (log scale)')
axes[1].set_title('Degree Distribution (Power Law)')
axes[1].grid(True, alpha=0.3)

plt.tight_layout()
plt.show()
</code></pre>

<p><strong>Comparison of Three Models</strong>:</p>

<table>
<thead>
<tr>
<th>Property</th>
<th>Random Graph</th>
<th>Small-World</th>
<th>Scale-Free</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Clustering</strong></td>
<td>Low</td>
<td>High</td>
<td>Moderate</td>
</tr>
<tr>
<td><strong>Average Path Length</strong></td>
<td>Short</td>
<td>Short</td>
<td>Short</td>
</tr>
<tr>
<td><strong>Degree Distribution</strong></td>
<td>Poisson</td>
<td>Nearly uniform</td>
<td>Power law</td>
</tr>
<tr>
<td><strong>Real-World Examples</strong></td>
<td>Theoretical model</td>
<td>Social networks, neural networks</td>
<td>WWW, citation networks</td>
</tr>
</tbody>
</table>

<hr>

<h2>1.5 Practice: Loading Network Data and Basic Analysis</h2>

<h3>Building Networks from CSV</h3>

<pre><code class="language-python">import networkx as nx
import pandas as pd
import matplotlib.pyplot as plt

# Create edge list CSV (sample)
edge_data = {
    'source': ['Alice', 'Alice', 'Bob', 'Bob', 'Charlie', 'David'],
    'target': ['Bob', 'Charlie', 'Charlie', 'David', 'David', 'Eve'],
    'weight': [3, 2, 5, 1, 4, 2]
}
df = pd.DataFrame(edge_data)

print("=== Edge List Data ===")
print(df)

# Convert to NetworkX graph
G = nx.from_pandas_edgelist(df, source='source', target='target',
                            edge_attr='weight', create_using=nx.Graph())

print(f"\nNumber of nodes: {G.number_of_nodes()}")
print(f"Number of edges: {G.number_of_edges()}")
print(f"List of nodes: {list(G.nodes())}")

# Visualization (weighted)
plt.figure(figsize=(10, 8))
pos = nx.spring_layout(G, seed=42)

# Change edge thickness by weight
edges = G.edges()
weights = [G[u][v]['weight'] for u, v in edges]

nx.draw_networkx_nodes(G, pos, node_color='lightblue',
                       node_size=1000, alpha=0.9)
nx.draw_networkx_labels(G, pos, font_size=12, font_weight='bold')
nx.draw_networkx_edges(G, pos, width=[w * 0.8 for w in weights],
                       alpha=0.6, edge_color='gray')

# Edge labels (weights)
edge_labels = nx.get_edge_attributes(G, 'weight')
nx.draw_networkx_edge_labels(G, pos, edge_labels, font_size=10)

plt.title('Weighted Network Visualization')
plt.axis('off')
plt.tight_layout()
plt.show()
</code></pre>

<h3>Calculating Basic Statistics</h3>

<pre><code class="language-python"># Comprehensive network analysis
print("\n=== Network Basic Statistics ===")

# Degree statistics
degrees = dict(G.degree())
print(f"Average degree: {np.mean(list(degrees.values())):.2f}")

# Weight statistics
total_weight = sum([d['weight'] for u, v, d in G.edges(data=True)])
avg_weight = total_weight / G.number_of_edges()
print(f"Total weight: {total_weight}")
print(f"Average edge weight: {avg_weight:.2f}")

# Connectivity
print(f"Number of connected components: {nx.number_connected_components(G)}")
print(f"Network density: {nx.density(G):.4f}")

if nx.is_connected(G):
    print(f"Diameter: {nx.diameter(G)}")
    print(f"Average shortest path length: {nx.average_shortest_path_length(G):.2f}")

# Centrality metrics
degree_centrality = nx.degree_centrality(G)
betweenness_centrality = nx.betweenness_centrality(G, weight='weight')

print("\n=== Centrality Rankings ===")
print("Degree centrality (top 3):")
for node, cent in sorted(degree_centrality.items(), key=lambda x: x[1], reverse=True)[:3]:
    print(f"  {node}: {cent:.4f}")

print("\nBetweenness centrality (top 3):")
for node, cent in sorted(betweenness_centrality.items(), key=lambda x: x[1], reverse=True)[:3]:
    print(f"  {node}: {cent:.4f}")
</code></pre>

<p><strong>Example Output</strong>:</p>
<pre><code>=== Edge List Data ===
    source   target  weight
0    Alice      Bob       3
1    Alice  Charlie       2
2      Bob  Charlie       5
3      Bob    David       1
4  Charlie    David       4
5    David      Eve       2

Number of nodes: 5
Number of edges: 6

=== Network Basic Statistics ===
Average degree: 2.40
Total weight: 17
Average edge weight: 2.83
Number of connected components: 1
Network density: 0.6000
Diameter: 3
Average shortest path length: 1.60

=== Centrality Rankings ===
Degree centrality (top 3):
  Bob: 0.7500
  Charlie: 0.7500
  David: 0.7500

Betweenness centrality (top 3):
  Charlie: 0.4000
  Bob: 0.4000
  David: 0.2667
</code></pre>

<h3>Saving and Loading in GraphML Format</h3>

<pre><code class="language-python"># Save network
output_file = 'sample_network.graphml'
nx.write_graphml(G, output_file)
print(f"\nNetwork saved to {output_file}")

# Load saved network
G_loaded = nx.read_graphml(output_file)
print(f"Loading complete: {G_loaded.number_of_nodes()} nodes, {G_loaded.number_of_edges()} edges")

# Other formats
# nx.write_edgelist(G, 'network.edgelist')  # Edge list
# nx.write_gexf(G, 'network.gexf')  # GEXF (for Gephi)
# nx.write_pajek(G, 'network.net')  # Pajek format
</code></pre>

<hr>

<h2>Chapter Summary</h2>

<h3>What We Learned</h3>

<ol>
<li><p><strong>Fundamentals of Graph Theory</strong></p>
<ul>
<li>Network representation using nodes and edges</li>
<li>Differences between directed, undirected, and weighted graphs</li>
<li>Basic operations with NetworkX</li>
</ul></li>

<li><p><strong>Network Representations</strong></p>
<ul>
<li>Characteristics of adjacency matrices, adjacency lists, and edge lists</li>
<li>Choosing representation methods according to use case</li>
<li>Trade-offs between computational complexity and memory efficiency</li>
</ul></li>

<li><p><strong>Basic Network Metrics</strong></p>
<ul>
<li>Degree, density, diameter, clustering coefficient</li>
<li>Centrality metrics (degree centrality, betweenness centrality)</li>
<li>Quantitative evaluation of network characteristics</li>
</ul></li>

<li><p><strong>Special Graph Structures</strong></p>
<ul>
<li>Random graphs, small-world, scale-free networks</li>
<li>Modeling real-world networks</li>
<li>Characteristics and application examples of each model</li>
</ul></li>

<li><p><strong>Practical Data Analysis</strong></p>
<ul>
<li>Loading data from CSV and GraphML</li>
<li>Calculating and interpreting basic statistics</li>
<li>Gaining insights through visualization</li>
</ul></li>
</ol>

<h3>Next Chapter</h3>

<p>In Chapter 2, we will learn about <strong>centrality metrics and community detection</strong>:</p>
<ul>
<li>Advanced centrality metrics (eigenvector centrality, PageRank)</li>
<li>Community detection algorithms</li>
<li>Modularity optimization</li>
<li>Hierarchical clustering</li>
<li>Community analysis on real data</li>
</ul>

<hr>

<div class="navigation">
    <a href="index.html" class="nav-button">‚Üê Series Contents</a>
    <a href="chapter2-centrality-community.html" class="nav-button">Next Chapter: Centrality and Community Detection ‚Üí</a>
</div>

    </main>


    <section class="disclaimer">
        <h3>Disclaimer</h3>
        <ul>
            <li>This content is provided for educational, research, and informational purposes only, and does not constitute professional advice (legal, accounting, technical guarantees, etc.).</li>
            <li>This content and accompanying code examples are provided "AS IS" without any warranties, express or implied, including but not limited to merchantability, fitness for a particular purpose, non-infringement, accuracy, completeness, or operational safety.</li>
            <li>The creators and Tohoku University assume no responsibility for the content, availability, or safety of external links, third-party data, tools, or libraries.</li>
            <li>To the maximum extent permitted by applicable law, the creators and Tohoku University shall not be liable for any direct, indirect, incidental, special, consequential, or punitive damages arising from the use, execution, or interpretation of this content.</li>
            <li>The content of this material may be changed, updated, or discontinued without notice.</li>
            <li>The copyright and license of this content are subject to the specified terms (e.g., CC BY 4.0). Such licenses typically include no-warranty clauses.</li>
        </ul>
    </section>

<footer>
        <p><strong>Authors</strong>: AI Terakoya Content Team</p>
        <p><strong>Version</strong>: 1.0 | <strong>Created</strong>: 2025-10-23</p>
        <p><strong>License</strong>: Creative Commons BY 4.0</p>
        <p>¬© 2025 AI Terakoya. All rights reserved.</p>
    </footer>
</body>
</html>
