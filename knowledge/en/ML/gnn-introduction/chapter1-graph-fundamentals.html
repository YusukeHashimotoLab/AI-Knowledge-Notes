<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 1 Chapterï¼šã‚°ãƒ©ãƒ•ã¨ã‚°ãƒ©ãƒ•è¡¨ç¾å­¦ç¿’ã®åŸºç¤ - AI Terakoya</title>

    <style>
        :root {
            --color-primary: #2c3e50;
            --color-primary-dark: #1a252f;
            --color-accent: #7b2cbf;
            --color-accent-light: #9d4edd;
            --color-text: #2d3748;
            --color-text-light: #4a5568;
            --color-bg: #ffffff;
            --color-bg-alt: #f7fafc;
            --color-border: #e2e8f0;
            --color-code-bg: #f8f9fa;
            --color-link: #3182ce;
            --color-link-hover: #2c5aa0;

            --spacing-xs: 0.5rem;
            --spacing-sm: 1rem;
            --spacing-md: 1.5rem;
            --spacing-lg: 2rem;
            --spacing-xl: 3rem;

            --font-body: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            --font-mono: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;

            --border-radius: 8px;
            --box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-body);
            line-height: 1.7;
            color: var(--color-text);
            background-color: var(--color-bg);
            font-size: 16px;
        }

        header {
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            color: white;
            padding: var(--spacing-xl) var(--spacing-md);
            margin-bottom: var(--spacing-xl);
            box-shadow: var(--box-shadow);
        }

        .header-content {
            max-width: 900px;
            margin: 0 auto;
        }

        h1 {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: var(--spacing-sm);
            line-height: 1.2;
        }

        .subtitle {
            font-size: 1.1rem;
            opacity: 0.95;
            font-weight: 400;
            margin-bottom: var(--spacing-md);
        }

        .meta {
            display: flex;
            flex-wrap: wrap;
            gap: var(--spacing-md);
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .meta-item {
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 0 var(--spacing-md) var(--spacing-xl);
        }

        h2 {
            font-size: 1.75rem;
            color: var(--color-primary);
            margin-top: var(--spacing-xl);
            margin-bottom: var(--spacing-md);
            padding-bottom: var(--spacing-xs);
            border-bottom: 3px solid var(--color-accent);
        }

        h3 {
            font-size: 1.4rem;
            color: var(--color-primary);
            margin-top: var(--spacing-lg);
            margin-bottom: var(--spacing-sm);
        }

        h4 {
            font-size: 1.1rem;
            color: var(--color-primary-dark);
            margin-top: var(--spacing-md);
            margin-bottom: var(--spacing-sm);
        }

        p {
            margin-bottom: var(--spacing-md);
            color: var(--color-text);
        }

        a {
            color: var(--color-link);
            text-decoration: none;
            transition: color 0.2s;
        }

        a:hover {
            color: var(--color-link-hover);
            text-decoration: underline;
        }

        ul, ol {
            margin-left: var(--spacing-lg);
            margin-bottom: var(--spacing-md);
        }

        li {
            margin-bottom: var(--spacing-xs);
            color: var(--color-text);
        }

        pre {
            background-color: var(--color-code-bg);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            overflow-x: auto;
            margin-bottom: var(--spacing-md);
            font-family: var(--font-mono);
            font-size: 0.9rem;
            line-height: 1.5;
        }

        code {
            font-family: var(--font-mono);
            font-size: 0.9em;
            background-color: var(--color-code-bg);
            padding: 0.2em 0.4em;
            border-radius: 3px;
        }

        pre code {
            background-color: transparent;
            padding: 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: var(--spacing-md);
            font-size: 0.95rem;
        }

        th, td {
            border: 1px solid var(--color-border);
            padding: var(--spacing-sm);
            text-align: left;
        }

        th {
            background-color: var(--color-bg-alt);
            font-weight: 600;
            color: var(--color-primary);
        }

        blockquote {
            border-left: 4px solid var(--color-accent);
            padding-left: var(--spacing-md);
            margin: var(--spacing-md) 0;
            color: var(--color-text-light);
            font-style: italic;
            background-color: var(--color-bg-alt);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        .mermaid {
            text-align: center;
            margin: var(--spacing-lg) 0;
            background-color: var(--color-bg-alt);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        details {
            background-color: var(--color-bg-alt);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            margin-bottom: var(--spacing-md);
        }

        summary {
            cursor: pointer;
            font-weight: 600;
            color: var(--color-primary);
            user-select: none;
            padding: var(--spacing-xs);
            margin: calc(-1 * var(--spacing-md));
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        summary:hover {
            background-color: rgba(123, 44, 191, 0.1);
        }

        details[open] summary {
            margin-bottom: var(--spacing-md);
            border-bottom: 1px solid var(--color-border);
        }

        .navigation {
            display: flex;
            justify-content: space-between;
            gap: var(--spacing-md);
            margin: var(--spacing-xl) 0;
            padding-top: var(--spacing-lg);
            border-top: 2px solid var(--color-border);
        }

        .nav-button {
            flex: 1;
            padding: var(--spacing-md);
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            color: white;
            border-radius: var(--border-radius);
            text-align: center;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: var(--box-shadow);
        }

        .nav-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            text-decoration: none;
        }

        footer {
            margin-top: var(--spacing-xl);
            padding: var(--spacing-lg) var(--spacing-md);
            background-color: var(--color-bg-alt);
            border-top: 1px solid var(--color-border);
            text-align: center;
            font-size: 0.9rem;
            color: var(--color-text-light);
        }
        .disclaimer {
            max-width: 900px;
            margin: 2rem auto;
            padding: 1.5rem;
            background: #f8f9fa;
            border-left: 4px solid #6c757d;
            border-radius: 4px;
        }

        .disclaimer h3 {
            color: #495057;
            margin-bottom: 1rem;
            font-size: 1.1rem;
        }

        .disclaimer ul {
            list-style: none;
            padding-left: 0;
        }

        .disclaimer li {
            padding: 0.5rem 0;
            padding-left: 1.5rem;
            position: relative;
            font-size: 0.9rem;
            color: #6c757d;
            line-height: 1.6;
        }

        .disclaimer li::before {
            content: "âš ï¸";
            position: absolute;
            left: 0;
        }


        @media (max-width: 768px) {
            h1 {
                font-size: 1.5rem;
            }

            h2 {
                font-size: 1.4rem;
            }

            h3 {
                font-size: 1.2rem;
            }

            .meta {
                font-size: 0.85rem;
            }

            .navigation {
                flex-direction: column;
            }

            table {
                font-size: 0.85rem;
            }

            th, td {
                padding: var(--spacing-xs);
            }
        }
    
        
    
        /* Breadcrumb styles */
        .breadcrumb {
            background: #f7fafc;
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #e2e8f0;
            font-size: 0.9rem;
        }

        .breadcrumb-content {
            max-width: 900px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .breadcrumb a {
            color: #667eea;
            text-decoration: none;
            transition: color 0.2s;
        }

        .breadcrumb a:hover {
            color: #764ba2;
            text-decoration: underline;
        }

        .breadcrumb-separator {
            color: #a0aec0;
            margin: 0 0.25rem;
        }

        .breadcrumb-current {
            color: #4a5568;
            font-weight: 500;
        }
    </style>

    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ startOnLoad: true, theme: 'default' });
    </script>

    <!-- MathJax for LaTeX equation rendering -->
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true,
                processEnvironments: true
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
                ignoreHtmlClass: 'mermaid'
            }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" id="MathJax-script" async></script>
</head>
<body>
            <nav class="breadcrumb">
        <div class="breadcrumb-content">
            <a href="../../index.html">AI Terakoya Top</a><span class="breadcrumb-separator">â€º</span><a href="../../ML/index.html">Machine Learning</a><span class="breadcrumb-separator">â€º</span><a href="../../ML/gnn-introduction/index.html">Gnn</a><span class="breadcrumb-separator">â€º</span><span class="breadcrumb-current">Chapter 1</span>
        </div>
    </nav>

        <header>
        <div class="header-content">
            <h1>Chapter 1 Chapterï¼šã‚°ãƒ©ãƒ•ã¨ã‚°ãƒ©ãƒ•è¡¨ç¾å­¦ç¿’ã®åŸºç¤</h1>
            <p class="subtitle">ã‚°ãƒ©ãƒ•ç†è«–ã®åŸºç¤ã€ã‚°ãƒ©ãƒ•è¡¨ç¾ã€ç‰¹å¾´é‡æŠ½å‡ºã€ã‚°ãƒ©ãƒ•åŸ‹ã‚è¾¼ã¿æ‰‹æ³•ã®ç†è§£</p>
            <div class="meta">
                <span class="meta-item">ğŸ“– Reading Time: 30-35 minutes</span>
                <span class="meta-item">ğŸ“Š Difficulty: Beginner to Intermediate</span>
                <span class="meta-item">ğŸ’» Code Examples: 12</span>
                <span class="meta-item">ğŸ“ Exercises: 6å•</span>
            </div>
        </div>
    </header>

    <main class="container">

<h2>Learning Objectives</h2>
<p>ã“ã® ChapterReadã“ã¨ã§ã€ä»¥ä¸‹ã‚’ç¿’å¾—ã§ãã¾ã™ï¼š</p>
<ul>
<li>âœ… ã‚°ãƒ©ãƒ•ã®åŸºæœ¬æ¦‚å¿µï¼ˆãƒãƒ¼ãƒ‰ã€ã‚¨ãƒƒã‚¸ã€æœ‰å‘/ç„¡å‘ã‚°ãƒ©ãƒ•ï¼‰ã‚’ç†è§£ã™ã‚‹</li>
<li>âœ… ã‚°ãƒ©ãƒ•ã®ç¨®é¡ï¼ˆæœ¨ã€DAGã€å®Œå…¨ã‚°ãƒ©ãƒ•ã€äºŒéƒ¨ã‚°ãƒ©ãƒ•ï¼‰ã‚’èª¬æ˜ã§ãã‚‹</li>
<li>âœ… ã‚°ãƒ©ãƒ•ã®è¡¨ç¾æ–¹æ³•ï¼ˆéš£æ¥è¡Œåˆ—ã€éš£æ¥ãƒªã‚¹ãƒˆã€ã‚¨ãƒƒã‚¸ãƒªã‚¹ãƒˆï¼‰ã‚’ä½¿ã„ minutesã‘ã‚‰ã‚Œã‚‹</li>
<li>âœ… NetworkXã‚’ä½¿ã£ã¦ã‚°ãƒ©ãƒ•ã‚’ä½œæˆãƒ»å¯è¦–åŒ–ã§ãã‚‹</li>
<li>âœ… ã‚°ãƒ©ãƒ•ã®ç‰¹å¾´é‡ï¼ˆæ¬¡æ•°ã€ã‚¯ãƒ©ã‚¹ã‚¿ãƒªãƒ³ã‚°ä¿‚æ•°ã€ä¸­å¿ƒæ€§æŒ‡æ¨™ï¼‰ã‚’è¨ˆç®—ã§ãã‚‹</li>
<li>âœ… PageRankã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã®åŸç†ã‚’ç†è§£ã—å®Ÿè£…ã§ãã‚‹</li>
<li>âœ… Random Walk based åŸ‹ã‚è¾¼ã¿æ‰‹æ³•ï¼ˆDeepWalkã€Node2Vecï¼‰ã‚’ç†è§£ã™ã‚‹</li>
<li>âœ… ã‚°ãƒ©ãƒ•åŸ‹ã‚è¾¼ã¿ã‚’ç”¨ã„ã¦ãƒãƒ¼ãƒ‰ classificationã‚„ãƒªãƒ³ã‚¯äºˆæ¸¬ã‚’å®Ÿè£…ã§ãã‚‹</li>
<li>âœ… ã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£æ¤œå‡ºã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚’é©ç”¨ã§ãã‚‹</li>
<li>âœ… ã‚½ãƒ¼ã‚·ãƒ£ãƒ«Network Analysisã‚’å®Ÿè·µã§ãã‚‹</li>
</ul>

<hr>

<h2>1.1 ã‚°ãƒ©ãƒ•ç†è«–ã®åŸºç¤</h2>

<h3>ã‚°ãƒ©ãƒ•ã¨ã¯ä½•ã‹</h3>

<p>ã‚°ãƒ©ãƒ•ã¯ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆé–“ã®é–¢ä¿‚ã‚’è¡¨ç¾ã™ã‚‹æ•°å­¦çš„æ§‹é€ ã§ã™ã€‚ã‚½ãƒ¼ã‚·ãƒ£ãƒ«ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã€ minuteså­æ§‹é€ ã€é“è·¯ç¶²ã€Knowledgeã‚°ãƒ©ãƒ•ãªã©ã€ç¾å®Ÿä¸–ç•Œã®å¤šãã®å•é¡Œã‚’ã‚°ãƒ©ãƒ•ã§è¡¨ç¾ã§ãã¾ã™ã€‚</p>

<blockquote>
<p>ã€Œã‚°ãƒ©ãƒ• $G$ ã¯ã€ãƒãƒ¼ãƒ‰ï¼ˆé ‚ç‚¹ï¼‰ã®é›†åˆ $V$ ã¨ã‚¨ãƒƒã‚¸ï¼ˆè¾ºï¼‰ã®é›†åˆ $E$ ã§å®šç¾©ã•ã‚Œã‚‹ï¼š$G = (V, E)$ã€</p>
</blockquote>

<h4>åŸºæœ¬ç”¨èª</h4>

<ul>
<li><strong>ãƒãƒ¼ãƒ‰ï¼ˆNode/Vertexï¼‰</strong>ï¼šã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã‚’è¡¨ã™ç‚¹ï¼ˆä¾‹ï¼šäººã€Webãƒšãƒ¼ã‚¸ã€åŸå­ï¼‰</li>
<li><strong>ã‚¨ãƒƒã‚¸ï¼ˆEdge/Linkï¼‰</strong>ï¼šãƒãƒ¼ãƒ‰é–“ã®é–¢ä¿‚ã‚’è¡¨ã™ç·šï¼ˆä¾‹ï¼šå‹äººé–¢ä¿‚ã€ãƒªãƒ³ã‚¯ã€åŒ–å­¦çµåˆï¼‰</li>
<li><strong>æœ‰å‘ã‚°ãƒ©ãƒ•ï¼ˆDirected Graphï¼‰</strong>ï¼šã‚¨ãƒƒã‚¸ã«æ–¹å‘æ€§ãŒã‚ã‚‹ï¼ˆä¾‹ï¼šTwitter ã®ãƒ•ã‚©ãƒ­ãƒ¼é–¢ä¿‚ï¼‰</li>
<li><strong>ç„¡å‘ã‚°ãƒ©ãƒ•ï¼ˆUndirected Graphï¼‰</strong>ï¼šã‚¨ãƒƒã‚¸ã«æ–¹å‘æ€§ãŒãªã„ï¼ˆä¾‹ï¼šFacebook ã®å‹äººé–¢ä¿‚ï¼‰</li>
<li><strong>é‡ã¿ä»˜ãã‚°ãƒ©ãƒ•ï¼ˆWeighted Graphï¼‰</strong>ï¼šã‚¨ãƒƒã‚¸ã«é‡ã¿ï¼ˆæ•°å€¤ï¼‰ãŒä»˜ä¸ã•ã‚Œã‚‹</li>
</ul>

<div class="mermaid">
graph LR
    subgraph "ç„¡å‘ã‚°ãƒ©ãƒ•"
    A1((A)) --- B1((B))
    B1 --- C1((C))
    C1 --- A1
    A1 --- D1((D))
    end

    subgraph "æœ‰å‘ã‚°ãƒ©ãƒ•"
    A2((A)) --> B2((B))
    B2 --> C2((C))
    C2 --> A2
    A2 --> D2((D))
    D2 --> B2
    end

    style A1 fill:#e3f2fd
    style B1 fill:#e3f2fd
    style C1 fill:#e3f2fd
    style D1 fill:#e3f2fd
    style A2 fill:#fff3e0
    style B2 fill:#fff3e0
    style C2 fill:#fff3e0
    style D2 fill:#fff3e0
</div>

<h3>ã‚°ãƒ©ãƒ•ã®ç¨®é¡</h3>

<table>
<thead>
<tr>
<th>ã‚°ãƒ©ãƒ•ã®ç¨®é¡</th>
<th>å®šç¾©</th>
<th>å…·ä½“ä¾‹</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>æœ¨ï¼ˆTreeï¼‰</strong></td>
<td>é–‰è·¯ã‚’æŒãŸãªã„é€£çµã‚°ãƒ©ãƒ•</td>
<td>ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã€çµ„ç¹”å›³</td>
</tr>
<tr>
<td><strong>DAG</strong></td>
<td>æœ‰å‘é–‰è·¯ã‚’æŒãŸãªã„æœ‰å‘ã‚°ãƒ©ãƒ•</td>
<td>ã‚¿ã‚¹ã‚¯ã®ä¾å­˜é–¢ä¿‚ã€å› æœã‚°ãƒ©ãƒ•</td>
</tr>
<tr>
<td><strong>å®Œå…¨ã‚°ãƒ©ãƒ•</strong></td>
<td>å…¨ãƒãƒ¼ãƒ‰é–“ã«ã‚¨ãƒƒã‚¸ãŒå­˜åœ¨</td>
<td>å®Œå…¨ã«æ¥ç¶šã•ã‚ŒãŸãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯</td>
</tr>
<tr>
<td><strong>äºŒéƒ¨ã‚°ãƒ©ãƒ•</strong></td>
<td>ãƒãƒ¼ãƒ‰ãŒ2ã¤ã®ã‚°ãƒ«ãƒ¼ãƒ—ã« minuteså‰²å¯èƒ½</td>
<td>æ¨è–¦ã‚·ã‚¹ãƒ†ãƒ ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼-ã‚¢ã‚¤ãƒ†ãƒ ï¼‰</td>
</tr>
<tr>
<td><strong>ã‚µã‚¤ã‚¯ãƒ«ã‚°ãƒ©ãƒ•</strong></td>
<td>å˜ä¸€ã®é–‰è·¯ã‚’å½¢æˆ</td>
<td>å¾ªç’°å‚ç…§ã€ãƒªãƒ³ã‚°æ§‹é€ </td>
</tr>
<tr>
<td><strong>æ­£å‰‡ã‚°ãƒ©ãƒ•</strong></td>
<td>å…¨ãƒãƒ¼ãƒ‰ã®æ¬¡æ•°ãŒç­‰ã—ã„</td>
<td>çµæ™¶æ ¼å­ã€ãƒˆãƒ¼ãƒ©ã‚¹ã‚°ãƒ©ãƒ•</td>
</tr>
</tbody>
</table>

<pre><code class="language-python">import networkx as nx
import matplotlib.pyplot as plt
import numpy as np

print("=== NetworkX ã«ã‚ˆã‚‹ã‚°ãƒ©ãƒ•ã®åŸºæœ¬æ“ä½œ ===\n")

# 1. ç„¡å‘ã‚°ãƒ©ãƒ•ã®ä½œæˆ
G_undirected = nx.Graph()
G_undirected.add_edges_from([
    ('A', 'B'), ('A', 'C'), ('A', 'D'),
    ('B', 'C'), ('C', 'D')
])

print("ç„¡å‘ã‚°ãƒ©ãƒ•:")
print(f"  ãƒãƒ¼ãƒ‰æ•°: {G_undirected.number_of_nodes()}")
print(f"  ã‚¨ãƒƒã‚¸æ•°: {G_undirected.number_of_edges()}")
print(f"  ãƒãƒ¼ãƒ‰: {list(G_undirected.nodes())}")
print(f"  ã‚¨ãƒƒã‚¸: {list(G_undirected.edges())}\n")

# 2. æœ‰å‘ã‚°ãƒ©ãƒ•ã®ä½œæˆ
G_directed = nx.DiGraph()
G_directed.add_edges_from([
    ('A', 'B'), ('B', 'C'), ('C', 'A'),
    ('A', 'D'), ('D', 'B')
])

print("æœ‰å‘ã‚°ãƒ©ãƒ•:")
print(f"  ãƒãƒ¼ãƒ‰æ•°: {G_directed.number_of_nodes()}")
print(f"  ã‚¨ãƒƒã‚¸æ•°: {G_directed.number_of_edges()}")
print(f"  ãƒãƒ¼ãƒ‰Aã®å‡ºæ¬¡æ•°: {G_directed.out_degree('A')}")
print(f"  ãƒãƒ¼ãƒ‰Aã®å…¥æ¬¡æ•°: {G_directed.in_degree('A')}\n")

# 3. é‡ã¿ä»˜ãã‚°ãƒ©ãƒ•ã®ä½œæˆ
G_weighted = nx.Graph()
G_weighted.add_weighted_edges_from([
    ('Tokyo', 'Osaka', 400),
    ('Tokyo', 'Nagoya', 350),
    ('Osaka', 'Nagoya', 180),
    ('Osaka', 'Fukuoka', 500)
])

print("é‡ã¿ä»˜ãã‚°ãƒ©ãƒ•ï¼ˆéƒ½å¸‚é–“è·é›¢ï¼‰:")
for u, v, weight in G_weighted.edges(data='weight'):
    print(f"  {u} - {v}: {weight}km")

# 4. ç‰¹æ®Šãªã‚°ãƒ©ãƒ•ã®ç”Ÿæˆ
print("\n=== ç‰¹æ®Šãªã‚°ãƒ©ãƒ•ã®ç”Ÿæˆ ===\n")

# å®Œå…¨ã‚°ãƒ©ãƒ•ï¼ˆK5: 5ãƒãƒ¼ãƒ‰ã®å®Œå…¨ã‚°ãƒ©ãƒ•ï¼‰
G_complete = nx.complete_graph(5)
print(f"å®Œå…¨ã‚°ãƒ©ãƒ• K5:")
print(f"  ãƒãƒ¼ãƒ‰æ•°: {G_complete.number_of_nodes()}")
print(f"  ã‚¨ãƒƒã‚¸æ•°: {G_complete.number_of_edges()} (ç†è«–å€¤: n(n-1)/2 = 10)\n")

# æœ¨ï¼ˆäºŒ minutesæœ¨ï¼‰
G_tree = nx.balanced_tree(r=2, h=3)  # r= branchingæ•°, h=æ·±ã•
print(f"äºŒ minutesæœ¨ (æ·±ã•3):")
print(f"  ãƒãƒ¼ãƒ‰æ•°: {G_tree.number_of_nodes()}")
print(f"  ã‚¨ãƒƒã‚¸æ•°: {G_tree.number_of_edges()}")
print(f"  æœ¨æ§‹é€ ã‹: {nx.is_tree(G_tree)}\n")

# äºŒéƒ¨ã‚°ãƒ©ãƒ•
G_bipartite = nx.complete_bipartite_graph(3, 4)
print(f"å®Œå…¨äºŒéƒ¨ã‚°ãƒ©ãƒ• K(3,4):")
print(f"  ãƒãƒ¼ãƒ‰æ•°: {G_bipartite.number_of_nodes()}")
print(f"  ã‚¨ãƒƒã‚¸æ•°: {G_bipartite.number_of_edges()}")
print(f"  äºŒéƒ¨ã‚°ãƒ©ãƒ•ã‹: {nx.is_bipartite(G_bipartite)}\n")

# ã‚°ãƒ©ãƒ•ã®å¯è¦–åŒ–
fig, axes = plt.subplots(2, 3, figsize=(15, 10))

# ç„¡å‘ã‚°ãƒ©ãƒ•
nx.draw(G_undirected, ax=axes[0, 0], with_labels=True,
        node_color='lightblue', node_size=800, font_size=12)
axes[0, 0].set_title('ç„¡å‘ã‚°ãƒ©ãƒ•', fontsize=14)

# æœ‰å‘ã‚°ãƒ©ãƒ•
nx.draw(G_directed, ax=axes[0, 1], with_labels=True,
        node_color='lightcoral', node_size=800, font_size=12,
        arrows=True, arrowsize=20)
axes[0, 1].set_title('æœ‰å‘ã‚°ãƒ©ãƒ•', fontsize=14)

# é‡ã¿ä»˜ãã‚°ãƒ©ãƒ•
pos = nx.spring_layout(G_weighted, seed=42)
nx.draw(G_weighted, pos, ax=axes[0, 2], with_labels=True,
        node_color='lightgreen', node_size=1000, font_size=10)
edge_labels = nx.get_edge_attributes(G_weighted, 'weight')
nx.draw_networkx_edge_labels(G_weighted, pos, edge_labels, ax=axes[0, 2])
axes[0, 2].set_title('é‡ã¿ä»˜ãã‚°ãƒ©ãƒ•', fontsize=14)

# å®Œå…¨ã‚°ãƒ©ãƒ•
nx.draw(G_complete, ax=axes[1, 0], with_labels=True,
        node_color='lightyellow', node_size=800)
axes[1, 0].set_title('å®Œå…¨ã‚°ãƒ©ãƒ• K5', fontsize=14)

# æœ¨
nx.draw(G_tree, ax=axes[1, 1], with_labels=True,
        node_color='lavender', node_size=600, font_size=8)
axes[1, 1].set_title('äºŒ minutesæœ¨ (æ·±ã•3)', fontsize=14)

# äºŒéƒ¨ã‚°ãƒ©ãƒ•
nx.draw(G_bipartite, ax=axes[1, 2], with_labels=True,
        node_color='peachpuff', node_size=600)
axes[1, 2].set_title('å®Œå…¨äºŒéƒ¨ã‚°ãƒ©ãƒ• K(3,4)', fontsize=14)

plt.tight_layout()
plt.savefig('graph_types.png', dpi=150, bbox_inches='tight')
print("ã‚°ãƒ©ãƒ•ã‚’ 'graph_types.png' ã«ä¿å­˜ã—ã¾ã—ãŸã€‚")
</code></pre>

<details>
<summary>å®Ÿè¡Œçµæœã®ä¾‹</summary>

<pre>
=== NetworkX ã«ã‚ˆã‚‹ã‚°ãƒ©ãƒ•ã®åŸºæœ¬æ“ä½œ ===

ç„¡å‘ã‚°ãƒ©ãƒ•:
  ãƒãƒ¼ãƒ‰æ•°: 4
  ã‚¨ãƒƒã‚¸æ•°: 5
  ãƒãƒ¼ãƒ‰: ['A', 'B', 'C', 'D']
  ã‚¨ãƒƒã‚¸: [('A', 'B'), ('A', 'C'), ('A', 'D'), ('B', 'C'), ('C', 'D')]

æœ‰å‘ã‚°ãƒ©ãƒ•:
  ãƒãƒ¼ãƒ‰æ•°: 4
  ã‚¨ãƒƒã‚¸æ•°: 5
  ãƒãƒ¼ãƒ‰Aã®å‡ºæ¬¡æ•°: 2
  ãƒãƒ¼ãƒ‰Aã®å…¥æ¬¡æ•°: 1

é‡ã¿ä»˜ãã‚°ãƒ©ãƒ•ï¼ˆéƒ½å¸‚é–“è·é›¢ï¼‰:
  Tokyo - Osaka: 400km
  Tokyo - Nagoya: 350km
  Osaka - Nagoya: 180km
  Osaka - Fukuoka: 500km

=== ç‰¹æ®Šãªã‚°ãƒ©ãƒ•ã®ç”Ÿæˆ ===

å®Œå…¨ã‚°ãƒ©ãƒ• K5:
  ãƒãƒ¼ãƒ‰æ•°: 5
  ã‚¨ãƒƒã‚¸æ•°: 10 (ç†è«–å€¤: n(n-1)/2 = 10)

äºŒ minutesæœ¨ (æ·±ã•3):
  ãƒãƒ¼ãƒ‰æ•°: 15
  ã‚¨ãƒƒã‚¸æ•°: 14
  æœ¨æ§‹é€ ã‹: True

å®Œå…¨äºŒéƒ¨ã‚°ãƒ©ãƒ• K(3,4):
  ãƒãƒ¼ãƒ‰æ•°: 7
  ã‚¨ãƒƒã‚¸æ•°: 12
  äºŒéƒ¨ã‚°ãƒ©ãƒ•ã‹: True
</pre>

</details>

<hr>

<h2>1.2 ã‚°ãƒ©ãƒ•ã®è¡¨ç¾æ–¹æ³•</h2>

<h3>3ã¤ã®ä¸»è¦ãªè¡¨ç¾å½¢å¼</h3>

<p>ã‚°ãƒ©ãƒ•ã‚’ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ã§æ‰±ã†ã«ã¯ã€é©åˆ‡ãªãƒ‡ãƒ¼ã‚¿æ§‹é€ ã§è¡¨ç¾ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ä¸»ãªè¡¨ç¾æ–¹æ³•ã¯ä»¥ä¸‹ã®3ã¤ã§ã™ï¼š</p>

<h4>1. éš£æ¥è¡Œåˆ—ï¼ˆAdjacency Matrixï¼‰</h4>

<p>$n$ ã®ãƒãƒ¼ãƒ‰ã‚’æŒã¤ã‚°ãƒ©ãƒ•ã«å¯¾ã—ã¦ã€$n \times n$ ã®è¡Œåˆ— $A$ ã§è¡¨ç¾ã—ã¾ã™ï¼š</p>

$$
A_{ij} = \begin{cases}
1 & \text{if } (i, j) \in E \\
0 & \text{otherwise}
\end{cases}
$$

<p><strong>ç‰¹å¾´</strong>ï¼š</p>
<ul>
<li>ã‚¨ãƒƒã‚¸ã®å­˜åœ¨ç¢ºèªãŒ $O(1)$ ã§å¯èƒ½</li>
<li>å¯†ã‚°ãƒ©ãƒ•ã«é©ã—ã¦ã„ã‚‹</li>
<li>ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ï¼š$O(n^2)$</li>
<li>ç„¡å‘ã‚°ãƒ©ãƒ•ã®å ´åˆã€è¡Œåˆ—ã¯å¯¾ç§°</li>
</ul>

<h4>2. éš£æ¥ãƒªã‚¹ãƒˆï¼ˆAdjacency Listï¼‰</h4>

<p>å„ãƒãƒ¼ãƒ‰ã«ã¤ã„ã¦ã€éš£æ¥ã™ã‚‹ãƒãƒ¼ãƒ‰ã®ãƒªã‚¹ãƒˆã‚’ä¿æŒã—ã¾ã™ï¼š</p>

<p><strong>ç‰¹å¾´</strong>ï¼š</p>
<ul>
<li>ç–ã‚°ãƒ©ãƒ•ã«é©ã—ã¦ã„ã‚‹</li>
<li>ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ï¼š$O(n + m)$ï¼ˆ$m$ ã¯ã‚¨ãƒƒã‚¸æ•°ï¼‰</li>
<li>è¿‘å‚ãƒãƒ¼ãƒ‰ã®èµ°æŸ»ãŒåŠ¹ç‡çš„</li>
</ul>

<h4>3. ã‚¨ãƒƒã‚¸ãƒªã‚¹ãƒˆï¼ˆEdge Listï¼‰</h4>

<p>å˜ç´”ã«ã‚¨ãƒƒã‚¸ã®é›†åˆã¨ã—ã¦è¡¨ç¾ï¼š$E = \{(u_1, v_1), (u_2, v_2), \ldots\}$</p>

<p><strong>ç‰¹å¾´</strong>ï¼š</p>
<ul>
<li>æœ€ã‚‚ã‚·ãƒ³ãƒ—ãƒ«ãªè¡¨ç¾</li>
<li>ã‚°ãƒ©ãƒ•å…¨ä½“ã®èµ°æŸ»ã«é©ã—ã¦ã„ã‚‹</li>
<li>ç‰¹å®šã‚¨ãƒƒã‚¸ã®æ¤œç´¢ã¯éåŠ¹ç‡ï¼ˆ$O(m)$ï¼‰</li>
</ul>

<table>
<thead>
<tr>
<th>æ“ä½œ</th>
<th>éš£æ¥è¡Œåˆ—</th>
<th>éš£æ¥ãƒªã‚¹ãƒˆ</th>
<th>ã‚¨ãƒƒã‚¸ãƒªã‚¹ãƒˆ</th>
</tr>
</thead>
<tbody>
<tr>
<td>ã‚¨ãƒƒã‚¸ã®å­˜åœ¨ç¢ºèª</td>
<td>$O(1)$</td>
<td>$O(d)$</td>
<td>$O(m)$</td>
</tr>
<tr>
<td>éš£æ¥ãƒãƒ¼ãƒ‰ã®å–å¾—</td>
<td>$O(n)$</td>
<td>$O(d)$</td>
<td>$O(m)$</td>
</tr>
<tr>
<td>å…¨ã‚¨ãƒƒã‚¸ã®èµ°æŸ»</td>
<td>$O(n^2)$</td>
<td>$O(n+m)$</td>
<td>$O(m)$</td>
</tr>
<tr>
<td>ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡</td>
<td>$O(n^2)$</td>
<td>$O(n+m)$</td>
<td>$O(m)$</td>
</tr>
</tbody>
</table>

<p>â€» $d$ ã¯ãƒãƒ¼ãƒ‰ã®æ¬¡æ•°ã€$m$ ã¯ã‚¨ãƒƒã‚¸æ•°ã€$n$ ã¯ãƒãƒ¼ãƒ‰æ•°</p>

<pre><code class="language-python">import networkx as nx
import numpy as np
import pandas as pd

print("=== ã‚°ãƒ©ãƒ•ã®è¡¨ç¾æ–¹æ³•ã®æ¯”è¼ƒ ===\n")

# ã‚µãƒ³ãƒ—ãƒ«ã‚°ãƒ©ãƒ•ã®ä½œæˆ
G = nx.Graph()
edges = [
    ('A', 'B'), ('A', 'C'), ('A', 'D'),
    ('B', 'C'), ('C', 'D')
]
G.add_edges_from(edges)

print("ã‚°ãƒ©ãƒ•æ§‹é€ :")
print(f"  ãƒãƒ¼ãƒ‰: {list(G.nodes())}")
print(f"  ã‚¨ãƒƒã‚¸: {list(G.edges())}\n")

# 1. éš£æ¥è¡Œåˆ—ï¼ˆAdjacency Matrixï¼‰
print("1. éš£æ¥è¡Œåˆ—ï¼ˆAdjacency Matrixï¼‰")
print("-" * 40)
adj_matrix = nx.adjacency_matrix(G).todense()
node_list = sorted(G.nodes())

print("è¡Œåˆ—å½¢å¼:")
df_adj = pd.DataFrame(adj_matrix, index=node_list, columns=node_list)
print(df_adj)

print("\nNumPyé…åˆ—å½¢å¼:")
print(adj_matrix)

# éš£æ¥è¡Œåˆ—ã®æ€§è³ª
print(f"\nå¯¾ç§°è¡Œåˆ—ã‹: {np.allclose(adj_matrix, adj_matrix.T)}")
print(f"ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡: O(nÂ²) = O({len(G.nodes())}Â²) = {len(G.nodes())**2} è¦ç´ ")

# 2. éš£æ¥ãƒªã‚¹ãƒˆï¼ˆAdjacency Listï¼‰
print("\n2. éš£æ¥ãƒªã‚¹ãƒˆï¼ˆAdjacency Listï¼‰")
print("-" * 40)
adj_list = {node: list(G.neighbors(node)) for node in G.nodes()}
for node, neighbors in sorted(adj_list.items()):
    print(f"  {node}: {neighbors}")

print(f"\nãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡: O(n+m) = O({len(G.nodes())}+{len(G.edges())}) "
      f"= {len(G.nodes()) + len(G.edges())} è¦ç´ ")

# 3. ã‚¨ãƒƒã‚¸ãƒªã‚¹ãƒˆï¼ˆEdge Listï¼‰
print("\n3. ã‚¨ãƒƒã‚¸ãƒªã‚¹ãƒˆï¼ˆEdge Listï¼‰")
print("-" * 40)
edge_list = list(G.edges())
for edge in edge_list:
    print(f"  {edge}")

print(f"\nãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡: O(m) = O({len(G.edges())}) = {len(G.edges())} ã‚¨ãƒƒã‚¸")

# 4. å„è¡¨ç¾ã§ã®æ“ä½œã®æ¯”è¼ƒ
print("\n" + "=" * 50)
print("å„è¡¨ç¾ã§ã®åŸºæœ¬æ“ä½œ")
print("=" * 50)

# ã‚¨ãƒƒã‚¸ã®å­˜åœ¨ç¢ºèª
print("\nã€ã‚¨ãƒƒã‚¸ã®å­˜åœ¨ç¢ºèªã€‘")
u, v = 'A', 'C'
print(f"ã‚¨ãƒƒã‚¸ ({u}, {v}) ã¯å­˜åœ¨ã™ã‚‹ã‹?\n")

# éš£æ¥è¡Œåˆ—ã§ã®ç¢ºèª
u_idx = node_list.index(u)
v_idx = node_list.index(v)
exists_matrix = adj_matrix[u_idx, v_idx] == 1
print(f"  éš£æ¥è¡Œåˆ—: {exists_matrix} (O(1)  hours)")

# éš£æ¥ãƒªã‚¹ãƒˆã§ã®ç¢ºèª
exists_list = v in adj_list[u]
print(f"  éš£æ¥ãƒªã‚¹ãƒˆ: {exists_list} (O(d)  hours)")

# ã‚¨ãƒƒã‚¸ãƒªã‚¹ãƒˆã§ã®ç¢ºèª
exists_edges = (u, v) in edge_list or (v, u) in edge_list
print(f"  ã‚¨ãƒƒã‚¸ãƒªã‚¹ãƒˆ: {exists_edges} (O(m)  hours)")

# éš£æ¥ãƒãƒ¼ãƒ‰ã®å–å¾—
print(f"\nã€ãƒãƒ¼ãƒ‰ {u} ã®éš£æ¥ãƒãƒ¼ãƒ‰ã€‘\n")

# éš£æ¥è¡Œåˆ—ã‹ã‚‰å–å¾—
neighbors_matrix = [node_list[i] for i in range(len(node_list))
                   if adj_matrix[u_idx, i] == 1]
print(f"  éš£æ¥è¡Œåˆ—: {neighbors_matrix} (O(n)  hours)")

# éš£æ¥ãƒªã‚¹ãƒˆã‹ã‚‰å–å¾—
neighbors_list = adj_list[u]
print(f"  éš£æ¥ãƒªã‚¹ãƒˆ: {neighbors_list} (O(d)  hours)")

# ã‚¨ãƒƒã‚¸ãƒªã‚¹ãƒˆã‹ã‚‰å–å¾—
neighbors_edges = list(set([v for (s, t) in edge_list
                           for v in [s, t] if (s == u or t == u) and v != u]))
print(f"  ã‚¨ãƒƒã‚¸ãƒªã‚¹ãƒˆ: {neighbors_edges} (O(m)  hours)")

# 5. æœ‰å‘ã‚°ãƒ©ãƒ•ã¨é‡ã¿ä»˜ãã‚°ãƒ©ãƒ•ã®è¡¨ç¾
print("\n" + "=" * 50)
print("æœ‰å‘ã‚°ãƒ©ãƒ•ã¨é‡ã¿ä»˜ãã‚°ãƒ©ãƒ•ã®è¡¨ç¾")
print("=" * 50)

# æœ‰å‘ã‚°ãƒ©ãƒ•
G_directed = nx.DiGraph()
G_directed.add_edges_from([('A', 'B'), ('B', 'C'), ('C', 'A')])

print("\næœ‰å‘ã‚°ãƒ©ãƒ•ã®éš£æ¥è¡Œåˆ—:")
adj_directed = nx.adjacency_matrix(G_directed).todense()
print(pd.DataFrame(adj_directed,
                  index=sorted(G_directed.nodes()),
                  columns=sorted(G_directed.nodes())))
print(f"å¯¾ç§°è¡Œåˆ—ã‹: {np.allclose(adj_directed, adj_directed.T)}")

# é‡ã¿ä»˜ãã‚°ãƒ©ãƒ•
G_weighted = nx.Graph()
G_weighted.add_weighted_edges_from([
    ('A', 'B', 0.5),
    ('A', 'C', 1.2),
    ('B', 'C', 0.8)
])

print("\né‡ã¿ä»˜ãã‚°ãƒ©ãƒ•ã®éš£æ¥è¡Œåˆ—:")
adj_weighted = nx.adjacency_matrix(G_weighted).todense()
print(pd.DataFrame(adj_weighted,
                  index=sorted(G_weighted.nodes()),
                  columns=sorted(G_weighted.nodes())))

print("\né‡ã¿ã‚’å«ã‚€éš£æ¥ãƒªã‚¹ãƒˆ:")
for node in sorted(G_weighted.nodes()):
    neighbors_with_weight = [(neighbor, G_weighted[node][neighbor]['weight'])
                            for neighbor in G_weighted.neighbors(node)]
    print(f"  {node}: {neighbors_with_weight}")
</code></pre>

<details>
<summary>å®Ÿè¡Œçµæœã®ä¾‹</summary>

<pre>
=== ã‚°ãƒ©ãƒ•ã®è¡¨ç¾æ–¹æ³•ã®æ¯”è¼ƒ ===

ã‚°ãƒ©ãƒ•æ§‹é€ :
  ãƒãƒ¼ãƒ‰: ['A', 'B', 'C', 'D']
  ã‚¨ãƒƒã‚¸: [('A', 'B'), ('A', 'C'), ('A', 'D'), ('B', 'C'), ('C', 'D')]

1. éš£æ¥è¡Œåˆ—ï¼ˆAdjacency Matrixï¼‰
----------------------------------------
è¡Œåˆ—å½¢å¼:
   A  B  C  D
A  0  1  1  1
B  1  0  1  0
C  1  1  0  1
D  1  0  1  0

å¯¾ç§°è¡Œåˆ—ã‹: True
ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡: O(nÂ²) = O(4Â²) = 16 è¦ç´ 

2. éš£æ¥ãƒªã‚¹ãƒˆï¼ˆAdjacency Listï¼‰
----------------------------------------
  A: ['B', 'C', 'D']
  B: ['A', 'C']
  C: ['A', 'B', 'D']
  D: ['A', 'C']

ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡: O(n+m) = O(4+5) = 9 è¦ç´ 

3. ã‚¨ãƒƒã‚¸ãƒªã‚¹ãƒˆï¼ˆEdge Listï¼‰
----------------------------------------
  ('A', 'B')
  ('A', 'C')
  ('A', 'D')
  ('B', 'C')
  ('C', 'D')

ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡: O(m) = O(5) = 5 ã‚¨ãƒƒã‚¸
</pre>

</details>

<hr>

<h2>1.3 ã‚°ãƒ©ãƒ•ã®ç‰¹å¾´é‡</h2>

<h3>ãƒãƒ¼ãƒ‰Levelã®ç‰¹å¾´é‡</h3>

<p>Graph Neural Networksã§ã¯ã€ãƒãƒ¼ãƒ‰ã‚„ã‚¨ãƒƒã‚¸ã®ç‰¹å¾´é‡ãŒé‡è¦ã§ã™ã€‚ä»¥ä¸‹ã¯ä»£è¡¨çš„ãªç‰¹å¾´é‡ã§ã™ï¼š</p>

<h4>1. æ¬¡æ•°ï¼ˆDegreeï¼‰</h4>

<p>ãƒãƒ¼ãƒ‰ $v$ ã«æ¥ç¶šã•ã‚Œã¦ã„ã‚‹ã‚¨ãƒƒã‚¸ã®æ•°ï¼š</p>

$$
d(v) = |\{u \in V : (v, u) \in E\}|
$$

<ul>
<li><strong>ç„¡å‘ã‚°ãƒ©ãƒ•</strong>ï¼šå˜ç´”ã«æ¥ç¶šã‚¨ãƒƒã‚¸æ•°</li>
<li><strong>æœ‰å‘ã‚°ãƒ©ãƒ•</strong>ï¼šå…¥æ¬¡æ•°ï¼ˆin-degreeï¼‰ã¨å‡ºæ¬¡æ•°ï¼ˆout-degreeï¼‰</li>
</ul>

<h4>2. ã‚¯ãƒ©ã‚¹ã‚¿ãƒªãƒ³ã‚°ä¿‚æ•°ï¼ˆClustering Coefficientï¼‰</h4>

<p>ãƒãƒ¼ãƒ‰ã®è¿‘å‚ãŒã©ã‚Œã ã‘å¯†ã«æ¥ç¶šã•ã‚Œã¦ã„ã‚‹ã‹ã‚’ç¤ºã™æŒ‡æ¨™ï¼š</p>

$$
C(v) = \frac{2 \cdot |\{(u, w) : u, w \in N(v), (u, w) \in E\}|}{d(v) \cdot (d(v) - 1)}
$$

<p>$N(v)$ ã¯ãƒãƒ¼ãƒ‰ $v$ ã®è¿‘å‚ãƒãƒ¼ãƒ‰é›†åˆã€‚å€¤ã¯ $[0, 1]$ ã®ç¯„å›²ã§ã€1ã«è¿‘ã„ã»ã©è¿‘å‚ãŒå¯†ã«æ¥ç¶šã•ã‚Œã¦ã„ã¾ã™ã€‚</p>

<h4>3. ä¸­å¿ƒæ€§æŒ‡æ¨™ï¼ˆCentrality Measuresï¼‰</h4>

<p>ãƒãƒ¼ãƒ‰ã®ã€Œé‡è¦åº¦ã€ã‚’æ¸¬ã‚‹æŒ‡æ¨™ã§ã™ï¼š</p>

<table>
<thead>
<tr>
<th>ä¸­å¿ƒæ€§</th>
<th>å®šç¾©</th>
<th>æ„å‘³</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>æ¬¡æ•°ä¸­å¿ƒæ€§</strong></td>
<td>$C_D(v) = d(v)$</td>
<td>æ¥ç¶šæ•°ãŒå¤šã„ = é‡è¦</td>
</tr>
<tr>
<td><strong>è¿‘æ¥ä¸­å¿ƒæ€§</strong></td>
<td>$C_C(v) = \frac{n-1}{\sum_{u} d(v,u)}$</td>
<td>ä»–ãƒãƒ¼ãƒ‰ã¸è¿‘ã„ = é‡è¦</td>
</tr>
<tr>
<td><strong>åª’ä»‹ä¸­å¿ƒæ€§</strong></td>
<td>$C_B(v) = \sum_{s \neq v \neq t} \frac{\sigma_{st}(v)}{\sigma_{st}}$</td>
<td>æœ€çŸ­çµŒè·¯ä¸Šã«ã‚ã‚‹ = é‡è¦</td>
</tr>
<tr>
<td><strong>å›ºæœ‰ãƒ™ã‚¯ãƒˆãƒ«ä¸­å¿ƒæ€§</strong></td>
<td>$A \mathbf{x} = \lambda \mathbf{x}$</td>
<td>é‡è¦ãªãƒãƒ¼ãƒ‰ã¨æ¥ç¶š = é‡è¦</td>
</tr>
<tr>
<td><strong>PageRank</strong></td>
<td>åå¾©è¨ˆç®—ã«ã‚ˆã‚‹é‡è¦åº¦</td>
<td>Googleæ¤œç´¢ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ </td>
</tr>
</tbody>
</table>

<pre><code class="language-python">import networkx as nx
import matplotlib.pyplot as plt
import numpy as np

print("=== ã‚°ãƒ©ãƒ•ã®ç‰¹å¾´é‡è¨ˆç®— ===\n")

# Zachary Karate Club ã‚°ãƒ©ãƒ•ï¼ˆæœ‰åãªç¤¾ä¼šãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ï¼‰
G = nx.karate_club_graph()
print(f"Zachary Karate Club ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯:")
print(f"  ãƒãƒ¼ãƒ‰æ•°: {G.number_of_nodes()}")
print(f"  ã‚¨ãƒƒã‚¸æ•°: {G.number_of_edges()}\n")

# 1. æ¬¡æ•°ï¼ˆDegreeï¼‰
print("=" * 60)
print("1. æ¬¡æ•°ï¼ˆDegreeï¼‰")
print("=" * 60)

degrees = dict(G.degree())
print("\nå„ãƒãƒ¼ãƒ‰ã®æ¬¡æ•°ï¼ˆä¸Šä½5ãƒãƒ¼ãƒ‰ï¼‰:")
sorted_degrees = sorted(degrees.items(), key=lambda x: x[1], reverse=True)
for node, degree in sorted_degrees[:5]:
    print(f"  ãƒãƒ¼ãƒ‰ {node:2d}: æ¬¡æ•° {degree}")

avg_degree = np.mean(list(degrees.values()))
print(f"\nå¹³å‡æ¬¡æ•°: {avg_degree:.2f}")

# 2. ã‚¯ãƒ©ã‚¹ã‚¿ãƒªãƒ³ã‚°ä¿‚æ•°ï¼ˆClustering Coefficientï¼‰
print("\n" + "=" * 60)
print("2. ã‚¯ãƒ©ã‚¹ã‚¿ãƒªãƒ³ã‚°ä¿‚æ•°ï¼ˆClustering Coefficientï¼‰")
print("=" * 60)

clustering_coeffs = nx.clustering(G)
print("\nã‚¯ãƒ©ã‚¹ã‚¿ãƒªãƒ³ã‚°ä¿‚æ•°ï¼ˆä¸Šä½5ãƒãƒ¼ãƒ‰ï¼‰:")
sorted_clustering = sorted(clustering_coeffs.items(),
                          key=lambda x: x[1], reverse=True)
for node, coeff in sorted_clustering[:5]:
    print(f"  ãƒãƒ¼ãƒ‰ {node:2d}: {coeff:.3f}")

avg_clustering = nx.average_clustering(G)
print(f"\nå¹³å‡ã‚¯ãƒ©ã‚¹ã‚¿ãƒªãƒ³ã‚°ä¿‚æ•°: {avg_clustering:.3f}")

# 3. ä¸­å¿ƒæ€§æŒ‡æ¨™ï¼ˆCentrality Measuresï¼‰
print("\n" + "=" * 60)
print("3. ä¸­å¿ƒæ€§æŒ‡æ¨™ï¼ˆCentrality Measuresï¼‰")
print("=" * 60)

# æ¬¡æ•°ä¸­å¿ƒæ€§
degree_centrality = nx.degree_centrality(G)
print("\næ¬¡æ•°ä¸­å¿ƒæ€§ï¼ˆä¸Šä½5ãƒãƒ¼ãƒ‰ï¼‰:")
sorted_dc = sorted(degree_centrality.items(), key=lambda x: x[1], reverse=True)
for node, centrality in sorted_dc[:5]:
    print(f"  ãƒãƒ¼ãƒ‰ {node:2d}: {centrality:.3f}")

# è¿‘æ¥ä¸­å¿ƒæ€§
closeness_centrality = nx.closeness_centrality(G)
print("\nè¿‘æ¥ä¸­å¿ƒæ€§ï¼ˆä¸Šä½5ãƒãƒ¼ãƒ‰ï¼‰:")
sorted_cc = sorted(closeness_centrality.items(), key=lambda x: x[1], reverse=True)
for node, centrality in sorted_cc[:5]:
    print(f"  ãƒãƒ¼ãƒ‰ {node:2d}: {centrality:.3f}")

# åª’ä»‹ä¸­å¿ƒæ€§
betweenness_centrality = nx.betweenness_centrality(G)
print("\nåª’ä»‹ä¸­å¿ƒæ€§ï¼ˆä¸Šä½5ãƒãƒ¼ãƒ‰ï¼‰:")
sorted_bc = sorted(betweenness_centrality.items(), key=lambda x: x[1], reverse=True)
for node, centrality in sorted_bc[:5]:
    print(f"  ãƒãƒ¼ãƒ‰ {node:2d}: {centrality:.3f}")

# å›ºæœ‰ãƒ™ã‚¯ãƒˆãƒ«ä¸­å¿ƒæ€§
eigenvector_centrality = nx.eigenvector_centrality(G)
print("\nå›ºæœ‰ãƒ™ã‚¯ãƒˆãƒ«ä¸­å¿ƒæ€§ï¼ˆä¸Šä½5ãƒãƒ¼ãƒ‰ï¼‰:")
sorted_ec = sorted(eigenvector_centrality.items(), key=lambda x: x[1], reverse=True)
for node, centrality in sorted_ec[:5]:
    print(f"  ãƒãƒ¼ãƒ‰ {node:2d}: {centrality:.3f}")

# PageRank
pagerank = nx.pagerank(G)
print("\nPageRankï¼ˆä¸Šä½5ãƒãƒ¼ãƒ‰ï¼‰:")
sorted_pr = sorted(pagerank.items(), key=lambda x: x[1], reverse=True)
for node, rank in sorted_pr[:5]:
    print(f"  ãƒãƒ¼ãƒ‰ {node:2d}: {rank:.3f}")

# 4. ã‚°ãƒ©ãƒ•Levelã®ç‰¹å¾´é‡
print("\n" + "=" * 60)
print("4. ã‚°ãƒ©ãƒ•Levelã®ç‰¹å¾´é‡")
print("=" * 60)

# ç›´å¾„ï¼ˆDiameterï¼‰ï¼šæœ€é•·ã®æœ€çŸ­çµŒè·¯
diameter = nx.diameter(G)
print(f"\nç›´å¾„ï¼ˆDiameterï¼‰: {diameter}")

# å¹³å‡æœ€çŸ­çµŒè·¯é•·
avg_shortest_path = nx.average_shortest_path_length(G)
print(f"å¹³å‡æœ€çŸ­çµŒè·¯é•·: {avg_shortest_path:.3f}")

# å¯†åº¦ï¼ˆDensityï¼‰
density = nx.density(G)
print(f"å¯†åº¦ï¼ˆDensityï¼‰: {density:.3f}")

# æ¨ç§»æ€§ï¼ˆTransitivityï¼‰ï¼šã‚°ãƒ©ãƒ•å…¨ä½“ã®ã‚¯ãƒ©ã‚¹ã‚¿ãƒªãƒ³ã‚°ä¿‚æ•°
transitivity = nx.transitivity(G)
print(f"æ¨ç§»æ€§ï¼ˆTransitivityï¼‰: {transitivity:.3f}")

# é€£çµæˆ minutesæ•°
num_components = nx.number_connected_components(G)
print(f"é€£çµæˆ minutesæ•°: {num_components}")

# 5. å¯è¦–åŒ–ï¼šä¸­å¿ƒæ€§æŒ‡æ¨™ã®æ¯”è¼ƒ
fig, axes = plt.subplots(2, 3, figsize=(18, 12))

pos = nx.spring_layout(G, seed=42)

# ãƒãƒ¼ãƒ‰ã‚µã‚¤ã‚ºã‚’ä¸­å¿ƒæ€§ã§èª¿æ•´
def draw_with_centrality(ax, centrality, title):
    node_sizes = [v * 3000 for v in centrality.values()]
    nx.draw(G, pos, ax=ax, node_size=node_sizes,
            node_color=list(centrality.values()),
            cmap='YlOrRd', with_labels=True, font_size=8,
            edge_color='gray', alpha=0.6)
    ax.set_title(title, fontsize=14, fontweight='bold')

draw_with_centrality(axes[0, 0], degree_centrality, 'æ¬¡æ•°ä¸­å¿ƒæ€§')
draw_with_centrality(axes[0, 1], closeness_centrality, 'è¿‘æ¥ä¸­å¿ƒæ€§')
draw_with_centrality(axes[0, 2], betweenness_centrality, 'åª’ä»‹ä¸­å¿ƒæ€§')
draw_with_centrality(axes[1, 0], eigenvector_centrality, 'å›ºæœ‰ãƒ™ã‚¯ãƒˆãƒ«ä¸­å¿ƒæ€§')
draw_with_centrality(axes[1, 1], pagerank, 'PageRank')

# æ¬¡æ•° minuteså¸ƒ
axes[1, 2].hist(list(degrees.values()), bins=15, color='skyblue', edgecolor='black')
axes[1, 2].set_xlabel('æ¬¡æ•°', fontsize=12)
axes[1, 2].set_ylabel('é »åº¦', fontsize=12)
axes[1, 2].set_title('æ¬¡æ•° minuteså¸ƒ', fontsize=14, fontweight='bold')
axes[1, 2].grid(alpha=0.3)

plt.tight_layout()
plt.savefig('graph_features.png', dpi=150, bbox_inches='tight')
print("\nå¯è¦–åŒ–ã‚’ 'graph_features.png' ã«ä¿å­˜ã—ã¾ã—ãŸã€‚")
</code></pre>

<details>
<summary>å®Ÿè¡Œçµæœã®ä¾‹</summary>

<pre>
=== ã‚°ãƒ©ãƒ•ã®ç‰¹å¾´é‡è¨ˆç®— ===

Zachary Karate Club ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯:
  ãƒãƒ¼ãƒ‰æ•°: 34
  ã‚¨ãƒƒã‚¸æ•°: 78

============================================================
1. æ¬¡æ•°ï¼ˆDegreeï¼‰
============================================================

å„ãƒãƒ¼ãƒ‰ã®æ¬¡æ•°ï¼ˆä¸Šä½5ãƒãƒ¼ãƒ‰ï¼‰:
  ãƒãƒ¼ãƒ‰ 33: æ¬¡æ•° 17
  ãƒãƒ¼ãƒ‰  0: æ¬¡æ•° 16
  ãƒãƒ¼ãƒ‰ 32: æ¬¡æ•° 12
  ãƒãƒ¼ãƒ‰  2: æ¬¡æ•° 10
  ãƒãƒ¼ãƒ‰  1: æ¬¡æ•° 9

å¹³å‡æ¬¡æ•°: 4.59

============================================================
2. ã‚¯ãƒ©ã‚¹ã‚¿ãƒªãƒ³ã‚°ä¿‚æ•°ï¼ˆClustering Coefficientï¼‰
============================================================

ã‚¯ãƒ©ã‚¹ã‚¿ãƒªãƒ³ã‚°ä¿‚æ•°ï¼ˆä¸Šä½5ãƒãƒ¼ãƒ‰ï¼‰:
  ãƒãƒ¼ãƒ‰  5: 0.667
  ãƒãƒ¼ãƒ‰  6: 0.600
  ãƒãƒ¼ãƒ‰ 11: 0.545
  ãƒãƒ¼ãƒ‰  4: 0.500
  ãƒãƒ¼ãƒ‰ 10: 0.467

å¹³å‡ã‚¯ãƒ©ã‚¹ã‚¿ãƒªãƒ³ã‚°ä¿‚æ•°: 0.571

============================================================
3. ä¸­å¿ƒæ€§æŒ‡æ¨™ï¼ˆCentrality Measuresï¼‰
============================================================

æ¬¡æ•°ä¸­å¿ƒæ€§ï¼ˆä¸Šä½5ãƒãƒ¼ãƒ‰ï¼‰:
  ãƒãƒ¼ãƒ‰ 33: 0.515
  ãƒãƒ¼ãƒ‰  0: 0.485
  ãƒãƒ¼ãƒ‰ 32: 0.364
  ãƒãƒ¼ãƒ‰  2: 0.303
  ãƒãƒ¼ãƒ‰  1: 0.273

åª’ä»‹ä¸­å¿ƒæ€§ï¼ˆä¸Šä½5ãƒãƒ¼ãƒ‰ï¼‰:
  ãƒãƒ¼ãƒ‰  0: 0.438
  ãƒãƒ¼ãƒ‰ 33: 0.304
  ãƒãƒ¼ãƒ‰ 32: 0.145
  ãƒãƒ¼ãƒ‰  2: 0.143
  ãƒãƒ¼ãƒ‰ 31: 0.138

PageRankï¼ˆä¸Šä½5ãƒãƒ¼ãƒ‰ï¼‰:
  ãƒãƒ¼ãƒ‰ 33: 0.101
  ãƒãƒ¼ãƒ‰  0: 0.097
  ãƒãƒ¼ãƒ‰ 32: 0.071
  ãƒãƒ¼ãƒ‰  2: 0.057
  ãƒãƒ¼ãƒ‰  1: 0.053
</pre>

</details>

<h3>PageRankã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã®å®Ÿè£…</h3>

<p>PageRankã¯ã€Webãƒšãƒ¼ã‚¸ã®é‡è¦åº¦ã‚’è¨ˆç®—ã™ã‚‹Googleã®æ¤œç´¢ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã§ã™ã€‚åŸºæœ¬çš„ãªã‚¢ã‚¤ãƒ‡ã‚¢ã¯ï¼š</p>

<blockquote>
<p>ã€Œé‡è¦ãªãƒšãƒ¼ã‚¸ã‹ã‚‰ãƒªãƒ³ã‚¯ã•ã‚Œã¦ã„ã‚‹ãƒšãƒ¼ã‚¸ã¯é‡è¦ã§ã‚ã‚‹ã€</p>
</blockquote>

<p>PageRankã¯åå¾©è¨ˆç®—ã«ã‚ˆã‚Šæ±‚ã‚ã‚‰ã‚Œã¾ã™ï¼š</p>

$$
PR(v) = \frac{1-d}{N} + d \sum_{u \in N_{in}(v)} \frac{PR(u)}{d_{out}(u)}
$$

<p>ã“ã“ã§ï¼š</p>
<ul>
<li>$d$: ãƒ€ãƒ³ãƒ”ãƒ³ã‚°ä¿‚æ•°ï¼ˆé€šå¸¸0.85ï¼‰</li>
<li>$N$: ã‚°ãƒ©ãƒ•å†…ã®ãƒãƒ¼ãƒ‰ç·æ•°</li>
<li>$N_{in}(v)$: ãƒãƒ¼ãƒ‰ $v$ ã¸ã®å…¥ãƒªãƒ³ã‚¯ã‚’æŒã¤ãƒãƒ¼ãƒ‰é›†åˆ</li>
<li>$d_{out}(u)$: ãƒãƒ¼ãƒ‰ $u$ ã®å‡ºæ¬¡æ•°</li>
</ul>

<pre><code class="language-python">import numpy as np
import networkx as nx
import matplotlib.pyplot as plt

print("=== PageRank ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã®å®Ÿè£… ===\n")

def pagerank_custom(G, d=0.85, max_iter=100, tol=1e-6):
    """
    PageRankã®è‡ªä½œå®Ÿè£…

    Parameters:
    -----------
    G : NetworkX graph
        æœ‰å‘ã‚°ãƒ©ãƒ•
    d : float
        ãƒ€ãƒ³ãƒ”ãƒ³ã‚°ä¿‚æ•°ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: 0.85ï¼‰
    max_iter : int
        æœ€å¤§åå¾©å›æ•°
    tol : float
        åæŸåˆ¤å®šã®é–¾å€¤

    Returns:
    --------
    dict : ãƒãƒ¼ãƒ‰ã”ã¨ã®PageRankã‚¹ã‚³ã‚¢
    """
    N = len(G.nodes())
    nodes = list(G.nodes())

    # PageRankã®åˆæœŸåŒ–ï¼ˆå…¨ãƒãƒ¼ãƒ‰ã«å‡ç­‰ã« minutesé…ï¼‰
    pr = {node: 1.0 / N for node in nodes}

    print(f"ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿:")
    print(f"  ãƒãƒ¼ãƒ‰æ•°: {N}")
    print(f"  ãƒ€ãƒ³ãƒ”ãƒ³ã‚°ä¿‚æ•°: {d}")
    print(f"  æœ€å¤§åå¾©å›æ•°: {max_iter}")
    print(f"  åæŸé–¾å€¤: {tol}\n")

    for iteration in range(max_iter):
        pr_new = {}

        for node in nodes:
            # ãƒ©ãƒ³ãƒ€ãƒ ã‚¸ãƒ£ãƒ³ãƒ—ã®å¯„ä¸
            rank = (1 - d) / N

            # å…¥ãƒªãƒ³ã‚¯ã‹ã‚‰ã®å¯„ä¸
            for neighbor in G.predecessors(node):
                out_degree = G.out_degree(neighbor)
                if out_degree > 0:
                    rank += d * pr[neighbor] / out_degree

            pr_new[node] = rank

        # åæŸåˆ¤å®š
        diff = sum(abs(pr_new[node] - pr[node]) for node in nodes)

        if (iteration + 1) % 10 == 0 or iteration == 0:
            print(f"åå¾© {iteration + 1:3d}: å·® minutes = {diff:.6f}")

        if diff < tol:
            print(f"\nåæŸã—ã¾ã—ãŸï¼ˆåå¾©å›æ•°: {iteration + 1}ï¼‰\n")
            break

        pr = pr_new

    # æ­£è¦åŒ–ï¼ˆåˆè¨ˆãŒ1ã«ãªã‚‹ã‚ˆã†ã«ï¼‰
    total = sum(pr.values())
    pr = {node: score / total for node, score in pr.items()}

    return pr

# ãƒ†ã‚¹ãƒˆã‚°ãƒ©ãƒ•ã®ä½œæˆ
print("=" * 60)
print("ç°¡å˜ãªæœ‰å‘ã‚°ãƒ©ãƒ•ã§ã®ãƒ†ã‚¹ãƒˆ")
print("=" * 60 + "\n")

G_simple = nx.DiGraph()
G_simple.add_edges_from([
    ('A', 'B'), ('A', 'C'),
    ('B', 'C'), ('B', 'D'),
    ('C', 'A'), ('D', 'C')
])

print("ã‚°ãƒ©ãƒ•æ§‹é€ :")
for node in G_simple.nodes():
    out_neighbors = list(G_simple.successors(node))
    in_neighbors = list(G_simple.predecessors(node))
    print(f"  {node}: å‡ºãƒªãƒ³ã‚¯ â†’ {out_neighbors}, å…¥ãƒªãƒ³ã‚¯ â† {in_neighbors}")

print("\n")

# è‡ªä½œPageRankã®å®Ÿè¡Œ
pr_custom = pagerank_custom(G_simple, d=0.85)

print("è‡ªä½œPageRankçµæœ:")
for node, score in sorted(pr_custom.items(), key=lambda x: x[1], reverse=True):
    print(f"  {node}: {score:.4f}")

# NetworkXã®PageRankã¨æ¯”è¼ƒ
pr_nx = nx.pagerank(G_simple, alpha=0.85)
print("\nNetworkX PageRankçµæœ:")
for node, score in sorted(pr_nx.items(), key=lambda x: x[1], reverse=True):
    print(f"  {node}: {score:.4f}")

print("\nå·® minutes:")
for node in G_simple.nodes():
    diff = abs(pr_custom[node] - pr_nx[node])
    print(f"  {node}: {diff:.6f}")

# ã‚ˆã‚Šå¤§ããªã‚°ãƒ©ãƒ•ã§ã®ãƒ†ã‚¹ãƒˆ
print("\n" + "=" * 60)
print("ã‚¹ã‚±ãƒ¼ãƒ«ãƒ•ãƒªãƒ¼ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã§ã®ãƒ†ã‚¹ãƒˆ")
print("=" * 60 + "\n")

# BarabÃ¡si-Albert ãƒ¢ãƒ‡ãƒ«ï¼ˆã‚¹ã‚±ãƒ¼ãƒ«ãƒ•ãƒªãƒ¼ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ï¼‰
G_large = nx.barabasi_albert_graph(n=100, m=3, seed=42)
G_large_directed = G_large.to_directed()

pr_large = pagerank_custom(G_large_directed, d=0.85, max_iter=50)

print("ä¸Šä½10ãƒãƒ¼ãƒ‰ã®PageRank:")
sorted_pr = sorted(pr_large.items(), key=lambda x: x[1], reverse=True)
for i, (node, score) in enumerate(sorted_pr[:10], 1):
    degree = G_large_directed.degree(node)
    print(f"  {i:2d}. ãƒãƒ¼ãƒ‰ {node:3d}: PageRank = {score:.5f}, æ¬¡æ•° = {degree}")

# PageRankã¨æ¬¡æ•°ã®é–¢ä¿‚ã‚’å¯è¦–åŒ–
fig, axes = plt.subplots(1, 2, figsize=(14, 6))

# å·¦ï¼šã‚°ãƒ©ãƒ•å¯è¦–åŒ–ï¼ˆPageRankã§ãƒãƒ¼ãƒ‰ã‚µã‚¤ã‚ºèª¿æ•´ï¼‰
pos = nx.spring_layout(G_simple, seed=42)
node_sizes = [pr_custom[node] * 5000 for node in G_simple.nodes()]
node_colors = [pr_custom[node] for node in G_simple.nodes()]

nx.draw(G_simple, pos, ax=axes[0],
        node_size=node_sizes,
        node_color=node_colors,
        cmap='YlOrRd',
        with_labels=True,
        font_size=14,
        font_weight='bold',
        arrows=True,
        arrowsize=20,
        edge_color='gray',
        width=2)
axes[0].set_title('PageRankã«ã‚ˆã‚‹ãƒãƒ¼ãƒ‰ã®é‡è¦åº¦\nï¼ˆå¤§ãã„ã»ã©é‡è¦ï¼‰',
                  fontsize=14, fontweight='bold')

# å³ï¼šPageRankã¨æ¬¡æ•°ã®æ•£å¸ƒå›³
degrees = [G_large_directed.degree(node) for node in G_large_directed.nodes()]
pageranks = [pr_large[node] for node in G_large_directed.nodes()]

axes[1].scatter(degrees, pageranks, alpha=0.6, s=50, color='steelblue')
axes[1].set_xlabel('æ¬¡æ•°', fontsize=12)
axes[1].set_ylabel('PageRank', fontsize=12)
axes[1].set_title('æ¬¡æ•°ã¨PageRankã®é–¢ä¿‚\nï¼ˆã‚¹ã‚±ãƒ¼ãƒ«ãƒ•ãƒªãƒ¼ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ï¼‰',
                  fontsize=14, fontweight='bold')
axes[1].grid(alpha=0.3)

# ç›¸é–¢ä¿‚æ•°ã‚’è¨ˆç®—
correlation = np.corrcoef(degrees, pageranks)[0, 1]
axes[1].text(0.05, 0.95, f'ç›¸é–¢ä¿‚æ•°: {correlation:.3f}',
            transform=axes[1].transAxes,
            fontsize=12, verticalalignment='top',
            bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.5))

plt.tight_layout()
plt.savefig('pagerank_implementation.png', dpi=150, bbox_inches='tight')
print("\nå¯è¦–åŒ–ã‚’ 'pagerank_implementation.png' ã«ä¿å­˜ã—ã¾ã—ãŸã€‚")
</code></pre>

<hr>

<h2>1.4 ã‚°ãƒ©ãƒ•åŸ‹ã‚è¾¼ã¿ï¼ˆGraph Embeddingï¼‰</h2>

<h3>ãªãœã‚°ãƒ©ãƒ•åŸ‹ã‚è¾¼ã¿ãŒå¿…è¦ã‹</h3>

<p>ã‚°ãƒ©ãƒ•æ§‹é€ ãƒ‡ãƒ¼ã‚¿ã‚’Machine Learningãƒ¢ãƒ‡ãƒ«ã§æ‰±ã†ã«ã¯ã€ãƒãƒ¼ãƒ‰ã‚„ã‚°ãƒ©ãƒ•å…¨ä½“ã‚’ä½æ¬¡å…ƒã®é€£ç¶šãƒ™ã‚¯ãƒˆãƒ«ç©ºé–“ã«åŸ‹ã‚è¾¼ã‚€å¿…è¦ãŒã‚ã‚Šã¾ã™ï¼š</p>

<blockquote>
<p>ã€Œã‚°ãƒ©ãƒ•åŸ‹ã‚è¾¼ã¿ã¯ã€ã‚°ãƒ©ãƒ•ã®æ§‹é€ æƒ…å ±ã‚’ä¿æŒã—ãªãŒã‚‰ã€ãƒãƒ¼ãƒ‰ã‚’ä½æ¬¡å…ƒãƒ™ã‚¯ãƒˆãƒ«è¡¨ç¾ã«å¤‰æ›ã™ã‚‹æŠ€è¡“ã§ã‚ã‚‹ã€‚ã€</p>
</blockquote>

<h4>ã‚°ãƒ©ãƒ•åŸ‹ã‚è¾¼ã¿ã®ç›®æ¨™</h4>

<ul>
<li>ã‚°ãƒ©ãƒ•ã®æ§‹é€ çš„æ€§è³ªã‚’ä¿æŒ</li>
<li>è¿‘å‚ãƒãƒ¼ãƒ‰ãŒåŸ‹ã‚è¾¼ã¿ç©ºé–“ã§ã‚‚è¿‘ãã«é…ç½®ã•ã‚Œã‚‹</li>
<li>é¡ä¼¼ã—ãŸå½¹å‰²ã‚’æŒã¤ãƒãƒ¼ãƒ‰ãŒè¿‘ãã«é…ç½®ã•ã‚Œã‚‹</li>
<li>è¨ˆç®—åŠ¹ç‡ãŒé«˜ã„</li>
</ul>

<table>
<thead>
<tr>
<th>æ‰‹æ³•</th>
<th>ã‚¢ãƒ—ãƒ­ãƒ¼ãƒ</th>
<th>ç‰¹å¾´</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>DeepWalk</strong></td>
<td>ãƒ©ãƒ³ãƒ€ãƒ ã‚¦ã‚©ãƒ¼ã‚¯ + Skip-gram</td>
<td>ç„¡å‘ã‚°ãƒ©ãƒ•ã€æ§‹é€ ã®ä¿æŒ</td>
</tr>
<tr>
<td><strong>Node2Vec</strong></td>
<td>ãƒã‚¤ã‚¢ã‚¹ä»˜ããƒ©ãƒ³ãƒ€ãƒ ã‚¦ã‚©ãƒ¼ã‚¯</td>
<td>BFS/DFS ã®åˆ¶å¾¡å¯èƒ½</td>
</tr>
<tr>
<td><strong>LINE</strong></td>
<td>1æ¬¡ãƒ»2æ¬¡è¿‘æ¥æ€§ã®ä¿æŒ</td>
<td>å¤§è¦æ¨¡ã‚°ãƒ©ãƒ•ã«åŠ¹ç‡çš„</td>
</tr>
<tr>
<td><strong>GCN</strong></td>
<td>ã‚°ãƒ©ãƒ•ç•³ã¿è¾¼ã¿</td>
<td>ãƒãƒ¼ãƒ‰ç‰¹å¾´é‡ã‚’æ´»ç”¨</td>
</tr>
<tr>
<td><strong>GraphSAGE</strong></td>
<td>è¿‘å‚ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚° + é›†ç´„</td>
<td>å¸°ç´çš„å­¦ç¿’ãŒå¯èƒ½</td>
</tr>
</tbody>
</table>

<h3>DeepWalkã¨Node2Vec</h3>

<h4>DeepWalkã®åŸºæœ¬ã‚¢ã‚¤ãƒ‡ã‚¢</h4>

<ol>
<li>ã‚°ãƒ©ãƒ•ä¸Šã§ãƒ©ãƒ³ãƒ€ãƒ ã‚¦ã‚©ãƒ¼ã‚¯ã‚’å®Ÿè¡Œã—ã¦ãƒãƒ¼ãƒ‰ç³»åˆ—ã‚’ç”Ÿæˆ</li>
<li>ã“ã®ç³»åˆ—ã‚’ã€Œæ–‡ã€ã¨è¦‹ãªã—ã€Word2Vecï¼ˆSkip-gramï¼‰ã‚’é©ç”¨</li>
<li>è¿‘å‚ãƒãƒ¼ãƒ‰ãŒåŸ‹ã‚è¾¼ã¿ç©ºé–“ã§ã‚‚è¿‘ãã«ãªã‚‹ã‚ˆã†ã«å­¦ç¿’</li>
</ol>

<p>ç›®çš„é–¢æ•°ï¼š</p>

$$
\max_f \sum_{v \in V} \log P(N(v) | f(v))
$$

<p>ã“ã“ã§ $N(v)$ ã¯ãƒ©ãƒ³ãƒ€ãƒ ã‚¦ã‚©ãƒ¼ã‚¯ã§è¨ªã‚ŒãŸãƒãƒ¼ãƒ‰ $v$ ã®è¿‘å‚ã€$f(v)$ ã¯ãƒãƒ¼ãƒ‰ $v$ ã®åŸ‹ã‚è¾¼ã¿ãƒ™ã‚¯ãƒˆãƒ«ã€‚</p>

<h4>Node2Vecã®æ”¹è‰¯ç‚¹</h4>

<p>Node2Vecã¯ã€ãƒ©ãƒ³ãƒ€ãƒ ã‚¦ã‚©ãƒ¼ã‚¯ã«ãƒã‚¤ã‚¢ã‚¹ã‚’å°å…¥ã—ã¾ã™ï¼š</p>

<ul>
<li><strong>Return parameter ($p$)</strong>ï¼šç›´å‰ã®ãƒãƒ¼ãƒ‰ã«æˆ»ã‚‹ç¢ºç‡ã‚’åˆ¶å¾¡</li>
<li><strong>In-out parameter ($q$)</strong>ï¼šBFSï¼ˆå¹…å„ªå…ˆæ¢ç´¢ï¼‰çš„ vs DFSï¼ˆæ·±ã•å„ªå…ˆæ¢ç´¢ï¼‰çš„ãªæ¢ç´¢ã‚’åˆ¶å¾¡</li>
</ul>

<table>
<thead>
<tr>
<th>ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿è¨­å®š</th>
<th>æ¢ç´¢ã®ç‰¹æ€§</th>
<th>æ‰ãˆã‚‹æ§‹é€ </th>
</tr>
</thead>
<tbody>
<tr>
<td>$p$ ä½, $q$ é«˜</td>
<td>BFSçš„ï¼ˆåºƒã„æ¢ç´¢ï¼‰</td>
<td>å±€æ‰€çš„ãªã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£æ§‹é€ </td>
</tr>
<tr>
<td>$p$ é«˜, $q$ ä½</td>
<td>DFSçš„ï¼ˆæ·±ã„æ¢ç´¢ï¼‰</td>
<td>ã‚°ãƒ­ãƒ¼ãƒãƒ«ãªæ§‹é€ ã€å½¹å‰²</td>
</tr>
</tbody>
</table>

<pre><code class="language-python">import networkx as nx
import numpy as np
from sklearn.manifold import TSNE
from sklearn.decomposition import PCA
import matplotlib.pyplot as plt
from collections import defaultdict

print("=== DeepWalk / Node2Vec é¢¨ã®å®Ÿè£… ===\n")

class SimpleNode2Vec:
    """
    Node2Vecã®ç°¡æ˜“å®Ÿè£…
    """
    def __init__(self, G, embedding_dim=128, walk_length=80,
                 num_walks=10, p=1.0, q=1.0, window_size=10):
        """
        Parameters:
        -----------
        G : NetworkX graph
        embedding_dim : int
            åŸ‹ã‚è¾¼ã¿æ¬¡å…ƒæ•°
        walk_length : int
            1å›ã®ãƒ©ãƒ³ãƒ€ãƒ ã‚¦ã‚©ãƒ¼ã‚¯ã®é•·ã•
        num_walks : int
            å„ãƒãƒ¼ãƒ‰ã‹ã‚‰é–‹å§‹ã™ã‚‹ã‚¦ã‚©ãƒ¼ã‚¯æ•°
        p : float
            Return parameterï¼ˆç›´å‰ã®ãƒãƒ¼ãƒ‰ã«æˆ»ã‚‹ç¢ºç‡ã®é€†æ•°ï¼‰
        q : float
            In-out parameterï¼ˆBFS vs DFSï¼‰
        window_size : int
            Skip-gramã®ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚µã‚¤ã‚º
        """
        self.G = G
        self.embedding_dim = embedding_dim
        self.walk_length = walk_length
        self.num_walks = num_walks
        self.p = p
        self.q = q
        self.window_size = window_size
        self.embeddings = None

    def _get_alias_edge(self, src, dst):
        """
        ã‚¨ãƒƒã‚¸ã®é·ç§»ç¢ºç‡ã‚’è¨ˆç®—ï¼ˆNode2Vecã®ãƒã‚¤ã‚¢ã‚¹ä»˜ãï¼‰
        """
        G = self.G
        p = self.p
        q = self.q

        unnormalized_probs = []
        for dst_nbr in G.neighbors(dst):
            if dst_nbr == src:
                # ç›´å‰ã®ãƒãƒ¼ãƒ‰ã«æˆ»ã‚‹
                unnormalized_probs.append(1.0 / p)
            elif G.has_edge(dst_nbr, src):
                # è·é›¢1ã®ãƒãƒ¼ãƒ‰ï¼ˆå…±é€šã®éš£æ¥ãƒãƒ¼ãƒ‰ï¼‰
                unnormalized_probs.append(1.0)
            else:
                # è·é›¢2ã®ãƒãƒ¼ãƒ‰
                unnormalized_probs.append(1.0 / q)

        norm_const = sum(unnormalized_probs)
        normalized_probs = [float(u_prob) / norm_const
                          for u_prob in unnormalized_probs]

        return list(G.neighbors(dst)), normalized_probs

    def _node2vec_walk(self, start_node):
        """
        1å›ã®Node2Vecãƒ©ãƒ³ãƒ€ãƒ ã‚¦ã‚©ãƒ¼ã‚¯ã‚’å®Ÿè¡Œ
        """
        G = self.G
        walk = [start_node]

        while len(walk) < self.walk_length:
            cur = walk[-1]
            cur_nbrs = list(G.neighbors(cur))

            if len(cur_nbrs) == 0:
                break

            if len(walk) == 1:
                # æœ€åˆã®ã‚¹ãƒ†ãƒƒãƒ—ï¼šä¸€æ§˜ãƒ©ãƒ³ãƒ€ãƒ ã«é¸æŠ
                walk.append(np.random.choice(cur_nbrs))
            else:
                # 2ã‚¹ãƒ†ãƒƒãƒ—ç›®ä»¥é™ï¼šãƒã‚¤ã‚¢ã‚¹ä»˜ãé¸æŠ
                prev = walk[-2]
                neighbors, probs = self._get_alias_edge(prev, cur)
                walk.append(np.random.choice(neighbors, p=probs))

        return walk

    def _generate_walks(self):
        """
        å…¨ãƒãƒ¼ãƒ‰ã‹ã‚‰ãƒ©ãƒ³ãƒ€ãƒ ã‚¦ã‚©ãƒ¼ã‚¯ã‚’ç”Ÿæˆ
        """
        walks = []
        nodes = list(self.G.nodes())

        print(f"ãƒ©ãƒ³ãƒ€ãƒ ã‚¦ã‚©ãƒ¼ã‚¯ã‚’ç”Ÿæˆä¸­...")
        print(f"  å„ãƒãƒ¼ãƒ‰ã‹ã‚‰ {self.num_walks} å›ã®ã‚¦ã‚©ãƒ¼ã‚¯")
        print(f"  ã‚¦ã‚©ãƒ¼ã‚¯é•·: {self.walk_length}")
        print(f"  p={self.p}, q={self.q}\n")

        for walk_iter in range(self.num_walks):
            np.random.shuffle(nodes)
            for node in nodes:
                walks.append(self._node2vec_walk(node))

        print(f"ç”Ÿæˆå®Œäº†: {len(walks)} ã®ã‚¦ã‚©ãƒ¼ã‚¯\n")
        return walks

    def _skipgram_training(self, walks):
        """
        Skip-gramé¢¨ã®å­¦ç¿’ï¼ˆç°¡æ˜“ç‰ˆï¼‰
        å®Ÿéš›ã«ã¯Word2Vecã‚„Gensimã‚’ä½¿ç”¨ã™ã‚‹ãŒã€ã“ã“ã§ã¯èª¬æ˜ç”¨ã«ç°¡ç•¥åŒ–
        """
        nodes = list(self.G.nodes())
        node_to_idx = {node: idx for idx, node in enumerate(nodes)}

        # ãƒ©ãƒ³ãƒ€ãƒ ã«åˆæœŸåŒ–
        embeddings = np.random.randn(len(nodes), self.embedding_dim) * 0.01

        print("Skip-gramå­¦ç¿’ä¸­ï¼ˆç°¡æ˜“ç‰ˆï¼‰...")

        # å…±èµ·ã‚«ã‚¦ãƒ³ãƒˆ
        cooccurrence = defaultdict(lambda: defaultdict(int))

        for walk in walks:
            for i, node in enumerate(walk):
                # ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦å†…ã®ãƒãƒ¼ãƒ‰ã‚’ã‚«ã‚¦ãƒ³ãƒˆ
                start = max(0, i - self.window_size)
                end = min(len(walk), i + self.window_size + 1)

                for j in range(start, end):
                    if i != j:
                        context_node = walk[j]
                        cooccurrence[node][context_node] += 1

        # ç°¡æ˜“çš„ãªåŸ‹ã‚è¾¼ã¿å­¦ç¿’ï¼ˆå®Ÿéš›ã¯ãƒã‚¬ãƒ†ã‚£ãƒ–ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ãªã©ä½¿ç”¨ï¼‰
        # ã“ã“ã§ã¯å…±èµ·é »åº¦ã®é«˜ã„ãƒãƒ¼ãƒ‰å¯¾ãŒè¿‘ããªã‚‹ã‚ˆã†ã«èª¿æ•´
        learning_rate = 0.01
        epochs = 5

        for epoch in range(epochs):
            for node in nodes:
                node_idx = node_to_idx[node]

                for context_node, count in cooccurrence[node].items():
                    context_idx = node_to_idx[context_node]

                    # ç°¡æ˜“çš„ãªå‹¾é…æ›´æ–°ï¼ˆå®Ÿéš›ã¯ã‚‚ã£ã¨è¤‡é›‘ï¼‰
                    diff = embeddings[context_idx] - embeddings[node_idx]
                    embeddings[node_idx] += learning_rate * count * diff * 0.01

            if (epoch + 1) % 2 == 0:
                print(f"  Epoch {epoch + 1}/{epochs} å®Œäº†")

        print("å­¦ç¿’å®Œäº†\n")
        return embeddings

    def fit(self):
        """
        Node2VecåŸ‹ã‚è¾¼ã¿ã‚’å­¦ç¿’
        """
        walks = self._generate_walks()
        self.embeddings = self._skipgram_training(walks)
        return self

    def get_embeddings(self):
        """
        å­¦ç¿’æ¸ˆã¿åŸ‹ã‚è¾¼ã¿ã‚’å–å¾—
        """
        if self.embeddings is None:
            raise ValueError("ã¾ãš fit() ã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„")

        nodes = list(self.G.nodes())
        return {node: self.embeddings[i] for i, node in enumerate(nodes)}

# ãƒ†ã‚¹ãƒˆï¼šKarate Clubã‚°ãƒ©ãƒ•
print("=" * 60)
print("Zachary Karate Club ã§ã® Node2Vec")
print("=" * 60 + "\n")

G = nx.karate_club_graph()
print(f"ã‚°ãƒ©ãƒ•æƒ…å ±:")
print(f"  ãƒãƒ¼ãƒ‰æ•°: {G.number_of_nodes()}")
print(f"  ã‚¨ãƒƒã‚¸æ•°: {G.number_of_edges()}\n")

# Node2Vecå­¦ç¿’
model = SimpleNode2Vec(
    G,
    embedding_dim=64,
    walk_length=30,
    num_walks=10,
    p=1.0,  # DeepWalkç›¸å½“
    q=1.0,
    window_size=5
)

model.fit()
embeddings_dict = model.get_embeddings()

# åŸ‹ã‚è¾¼ã¿ãƒ™ã‚¯ãƒˆãƒ«ã‚’é…åˆ—ã«å¤‰æ›
nodes = list(G.nodes())
embeddings = np.array([embeddings_dict[node] for node in nodes])

print(f"åŸ‹ã‚è¾¼ã¿çµæœ:")
print(f"  å½¢çŠ¶: {embeddings.shape}")
print(f"  æœ€åˆã®ãƒãƒ¼ãƒ‰ã®åŸ‹ã‚è¾¼ã¿ï¼ˆæœ€åˆã®5æ¬¡å…ƒï¼‰: {embeddings[0, :5]}\n")

# t-SNEã§2æ¬¡å…ƒã«å¯è¦–åŒ–
print("t-SNEã§2æ¬¡å…ƒã«å‰Šæ¸›ä¸­...")
tsne = TSNE(n_components=2, random_state=42, perplexity=15)
embeddings_2d = tsne.fit_transform(embeddings)
print("å®Œäº†\n")

# å¯è¦–åŒ–
fig, axes = plt.subplots(1, 2, figsize=(16, 7))

# å·¦ï¼šå…ƒã®ã‚°ãƒ©ãƒ•
pos = nx.spring_layout(G, seed=42)
node_colors = [G.nodes[node]['club'] for node in G.nodes()]
nx.draw(G, pos, ax=axes[0],
        node_color=node_colors,
        cmap='Set1',
        with_labels=True,
        node_size=400,
        font_size=8,
        edge_color='gray',
        alpha=0.7)
axes[0].set_title('å…ƒã®ã‚°ãƒ©ãƒ•æ§‹é€ \nï¼ˆè‰² = æ‰€å±ã‚¯ãƒ©ãƒ–ï¼‰',
                  fontsize=14, fontweight='bold')

# å³ï¼šåŸ‹ã‚è¾¼ã¿ç©ºé–“ã§ã®å¯è¦–åŒ–
scatter = axes[1].scatter(embeddings_2d[:, 0], embeddings_2d[:, 1],
                         c=node_colors, cmap='Set1',
                         s=200, alpha=0.7, edgecolors='black')

for i, node in enumerate(nodes):
    axes[1].annotate(str(node),
                    (embeddings_2d[i, 0], embeddings_2d[i, 1]),
                    fontsize=8, ha='center', va='center')

axes[1].set_xlabel('t-SNE æ¬¡å…ƒ 1', fontsize=12)
axes[1].set_ylabel('t-SNE æ¬¡å…ƒ 2', fontsize=12)
axes[1].set_title('Node2Vec åŸ‹ã‚è¾¼ã¿ç©ºé–“\nï¼ˆt-SNEå¯è¦–åŒ–ï¼‰',
                  fontsize=14, fontweight='bold')
axes[1].grid(alpha=0.3)

plt.tight_layout()
plt.savefig('node2vec_embedding.png', dpi=150, bbox_inches='tight')
print("å¯è¦–åŒ–ã‚’ 'node2vec_embedding.png' ã«ä¿å­˜ã—ã¾ã—ãŸã€‚")
</code></pre>

<hr>

<h2>1.5 å®Ÿè·µï¼šã‚½ãƒ¼ã‚·ãƒ£ãƒ«Network Analysis</h2>

<h3>ã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£æ¤œå‡º</h3>

<p>ã‚½ãƒ¼ã‚·ãƒ£ãƒ«ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã«ã¯ã€å¯†ã«æ¥ç¶šã•ã‚ŒãŸãƒãƒ¼ãƒ‰ã®é›†å›£ï¼ˆã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£ï¼‰ãŒå­˜åœ¨ã—ã¾ã™ã€‚ã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£æ¤œå‡ºã¯ã€ã“ã®ã‚ˆã†ãªæ§‹é€ ã‚’è‡ªå‹•çš„ã«ç™ºè¦‹ã™ã‚‹æ‰‹æ³•ã§ã™ã€‚</p>

<h4>ä¸»ãªã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ </h4>

<ul>
<li><strong>Louvainæ³•</strong>ï¼šãƒ¢ã‚¸ãƒ¥ãƒ©ãƒªãƒ†ã‚£ã‚’æœ€å¤§åŒ–</li>
<li><strong>Label Propagation</strong>ï¼šãƒ©ãƒ™ãƒ«ã®ä¼æ’­ã«ã‚ˆã‚Š classification</li>
<li><strong>Girvan-Newmanæ³•</strong>ï¼šåª’ä»‹ä¸­å¿ƒæ€§ã®é«˜ã„ã‚¨ãƒƒã‚¸ã‚’é™¤å»</li>
<li><strong>ã‚¹ãƒšã‚¯ãƒˆãƒ©ãƒ«ã‚¯ãƒ©ã‚¹ã‚¿ãƒªãƒ³ã‚°</strong>ï¼šãƒ©ãƒ—ãƒ©ã‚·ã‚¢ãƒ³è¡Œåˆ—ã®å›ºæœ‰å€¤ minutesè§£</li>
</ul>

<h4>ãƒ¢ã‚¸ãƒ¥ãƒ©ãƒªãƒ†ã‚£ï¼ˆModularityï¼‰</h4>

<p>ã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£æ§‹é€ ã®å“è³ªã‚’è©•ä¾¡ã™ã‚‹æŒ‡æ¨™ï¼š</p>

$$
Q = \frac{1}{2m} \sum_{ij} \left[A_{ij} - \frac{k_i k_j}{2m}\right] \delta(c_i, c_j)
$$

<p>ã“ã“ã§ï¼š</p>
<ul>
<li>$m$: ã‚¨ãƒƒã‚¸æ•°</li>
<li>$A_{ij}$: éš£æ¥è¡Œåˆ—</li>
<li>$k_i$: ãƒãƒ¼ãƒ‰ $i$ ã®æ¬¡æ•°</li>
<li>$c_i$: ãƒãƒ¼ãƒ‰ $i$ ã®æ‰€å±ã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£</li>
<li>$\delta(c_i, c_j)$: åŒã˜ã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£ãªã‚‰1ã€ãã†ã§ãªã‘ã‚Œã°0</li>
</ul>

<pre><code class="language-python">import networkx as nx
import matplotlib.pyplot as plt
import numpy as np
from networkx.algorithms import community

print("=== ã‚½ãƒ¼ã‚·ãƒ£ãƒ«Network Analysisï¼šã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£æ¤œå‡º ===\n")

# Zachary Karate Clubã‚°ãƒ©ãƒ•
G = nx.karate_club_graph()

print("Zachary Karate Club ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯:")
print(f"  ãƒãƒ¼ãƒ‰æ•°: {G.number_of_nodes()}")
print(f"  ã‚¨ãƒƒã‚¸æ•°: {G.number_of_edges()}")
print("\nèƒŒæ™¯ï¼šç©ºæ‰‹ã‚¯ãƒ©ãƒ–ã®ãƒ¡ãƒ³ãƒãƒ¼é–“ã®å‹äººé–¢ä¿‚ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯")
print("   å¾Œã«æŒ‡å° learnerã®å¯¾ç«‹ã«ã‚ˆã‚Š2ã¤ã®ã‚°ãƒ«ãƒ¼ãƒ—ã« minutesè£‚\n")

# å®Ÿéš›ã® minutesè£‚æƒ…å ±
true_labels = [G.nodes[i]['club'] for i in G.nodes()]
print(f"å®Ÿéš›ã® minutesè£‚:")
print(f"  Officer's club: {true_labels.count('Officer')} äºº")
print(f"  Mr. Hi's club: {true_labels.count('Mr. Hi')} äºº\n")

print("=" * 60)
print("ã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£æ¤œå‡ºã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã®é©ç”¨")
print("=" * 60 + "\n")

# 1. Louvainæ³•
print("1. Louvainæ³•ï¼ˆãƒ¢ã‚¸ãƒ¥ãƒ©ãƒªãƒ†ã‚£æœ€å¤§åŒ–ï¼‰")
print("-" * 40)
communities_louvain = community.louvain_communities(G, seed=42)
modularity_louvain = community.modularity(G, communities_louvain)

print(f"æ¤œå‡ºã•ã‚ŒãŸã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£æ•°: {len(communities_louvain)}")
for i, comm in enumerate(communities_louvain):
    print(f"  ã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£ {i+1}: {len(comm)} ãƒãƒ¼ãƒ‰ - {sorted(comm)}")
print(f"ãƒ¢ã‚¸ãƒ¥ãƒ©ãƒªãƒ†ã‚£: {modularity_louvain:.4f}\n")

# 2. Label Propagation
print("2. Label Propagationï¼ˆãƒ©ãƒ™ãƒ«ä¼æ’­ï¼‰")
print("-" * 40)
communities_label_prop = community.label_propagation_communities(G)
communities_label_prop = list(communities_label_prop)
modularity_lp = community.modularity(G, communities_label_prop)

print(f"æ¤œå‡ºã•ã‚ŒãŸã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£æ•°: {len(communities_label_prop)}")
for i, comm in enumerate(communities_label_prop):
    print(f"  ã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£ {i+1}: {len(comm)} ãƒãƒ¼ãƒ‰ - {sorted(comm)}")
print(f"ãƒ¢ã‚¸ãƒ¥ãƒ©ãƒªãƒ†ã‚£: {modularity_lp:.4f}\n")

# 3. Girvan-Newmanæ³•
print("3. Girvan-Newmanæ³•ï¼ˆåª’ä»‹ä¸­å¿ƒæ€§ãƒ™ãƒ¼ã‚¹ï¼‰")
print("-" * 40)
communities_gn_generator = community.girvan_newman(G)
# 2ã¤ã®ã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£ã« minuteså‰²
communities_gn = next(communities_gn_generator)
communities_gn = [set(c) for c in communities_gn]
modularity_gn = community.modularity(G, communities_gn)

print(f"æ¤œå‡ºã•ã‚ŒãŸã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£æ•°: {len(communities_gn)}")
for i, comm in enumerate(communities_gn):
    print(f"  ã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£ {i+1}: {len(comm)} ãƒãƒ¼ãƒ‰ - {sorted(comm)}")
print(f"ãƒ¢ã‚¸ãƒ¥ãƒ©ãƒªãƒ†ã‚£: {modularity_gn:.4f}\n")

# 4. å®Ÿéš›ã® minutesè£‚ã¨ã®æ¯”è¼ƒ
print("=" * 60)
print("å®Ÿéš›ã® minutesè£‚ã¨ã®æ¯”è¼ƒ")
print("=" * 60 + "\n")

def compare_with_ground_truth(communities, true_labels, G):
    """
    æ¤œå‡ºã•ã‚ŒãŸã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£ã¨å®Ÿéš›ã®ãƒ©ãƒ™ãƒ«ã‚’æ¯”è¼ƒ
    """
    # ã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£ç•ªå·ã‚’å„ãƒãƒ¼ãƒ‰ã«å‰²ã‚Šå½“ã¦
    node_to_community = {}
    for comm_id, comm in enumerate(communities):
        for node in comm:
            node_to_community[node] = comm_id

    # æ··åŒè¡Œåˆ—çš„ãª minutesæ
    from collections import Counter

    for comm_id, comm in enumerate(communities):
        labels_in_comm = [G.nodes[node]['club'] for node in comm]
        counter = Counter(labels_in_comm)
        print(f"æ¤œå‡ºã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£ {comm_id + 1}:")
        for club, count in counter.items():
            print(f"  {club}: {count} äºº")

    # æ­£è§£ç‡ï¼ˆå¤šæ•°æ±ºï¼‰
    correct = 0
    for node in G.nodes():
        comm_id = node_to_community[node]
        # ã“ã®ã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£ã®å¤šæ•°æ´¾ãƒ©ãƒ™ãƒ«
        labels_in_comm = [G.nodes[n]['club'] for n in communities[comm_id]]
        majority_label = Counter(labels_in_comm).most_common(1)[0][0]

        if G.nodes[node]['club'] == majority_label:
            correct += 1

    accuracy = correct / len(G.nodes())
    return accuracy

print("Louvainæ³•:")
acc_louvain = compare_with_ground_truth(communities_louvain, true_labels, G)
print(f"æ­£è§£ç‡: {acc_louvain:.2%}\n")

print("Girvan-Newmanæ³•:")
acc_gn = compare_with_ground_truth(communities_gn, true_labels, G)
print(f"æ­£è§£ç‡: {acc_gn:.2%}\n")

# å¯è¦–åŒ–
fig, axes = plt.subplots(2, 2, figsize=(16, 14))

pos = nx.spring_layout(G, seed=42)

# å®Ÿéš›ã® minutesè£‚
true_community_map = {node: 0 if G.nodes[node]['club'] == 'Mr. Hi' else 1
                     for node in G.nodes()}
nx.draw(G, pos, ax=axes[0, 0],
        node_color=[true_community_map[node] for node in G.nodes()],
        cmap='Set1',
        with_labels=True,
        node_size=500,
        font_size=9,
        edge_color='gray',
        alpha=0.7)
axes[0, 0].set_title(f'å®Ÿéš›ã® minutesè£‚\nï¼ˆåŸºæº–ã¨ãªã‚‹ã‚°ãƒ©ãƒ³ãƒ‰ãƒˆã‚¥ãƒ«ãƒ¼ã‚¹ï¼‰',
                    fontsize=14, fontweight='bold')

# Louvainæ³•
louvain_map = {}
for comm_id, comm in enumerate(communities_louvain):
    for node in comm:
        louvain_map[node] = comm_id

nx.draw(G, pos, ax=axes[0, 1],
        node_color=[louvain_map[node] for node in G.nodes()],
        cmap='Set2',
        with_labels=True,
        node_size=500,
        font_size=9,
        edge_color='gray',
        alpha=0.7)
axes[0, 1].set_title(f'Louvainæ³•\nãƒ¢ã‚¸ãƒ¥ãƒ©ãƒªãƒ†ã‚£: {modularity_louvain:.3f}, æ­£è§£ç‡: {acc_louvain:.1%}',
                    fontsize=14, fontweight='bold')

# Label Propagation
lp_map = {}
for comm_id, comm in enumerate(communities_label_prop):
    for node in comm:
        lp_map[node] = comm_id

nx.draw(G, pos, ax=axes[1, 0],
        node_color=[lp_map[node] for node in G.nodes()],
        cmap='Set3',
        with_labels=True,
        node_size=500,
        font_size=9,
        edge_color='gray',
        alpha=0.7)
axes[1, 0].set_title(f'Label Propagation\nãƒ¢ã‚¸ãƒ¥ãƒ©ãƒªãƒ†ã‚£: {modularity_lp:.3f}',
                    fontsize=14, fontweight='bold')

# Girvan-Newman
gn_map = {}
for comm_id, comm in enumerate(communities_gn):
    for node in comm:
        gn_map[node] = comm_id

nx.draw(G, pos, ax=axes[1, 1],
        node_color=[gn_map[node] for node in G.nodes()],
        cmap='Pastel1',
        with_labels=True,
        node_size=500,
        font_size=9,
        edge_color='gray',
        alpha=0.7)
axes[1, 1].set_title(f'Girvan-Newmanæ³•\nãƒ¢ã‚¸ãƒ¥ãƒ©ãƒªãƒ†ã‚£: {modularity_gn:.3f}, æ­£è§£ç‡: {acc_gn:.1%}',
                    fontsize=14, fontweight='bold')

plt.tight_layout()
plt.savefig('community_detection.png', dpi=150, bbox_inches='tight')
print("å¯è¦–åŒ–ã‚’ 'community_detection.png' ã«ä¿å­˜ã—ã¾ã—ãŸã€‚")
</code></pre>

<h3>ãƒªãƒ³ã‚¯äºˆæ¸¬ï¼ˆLink Predictionï¼‰</h3>

<p>ãƒªãƒ³ã‚¯äºˆæ¸¬ã¯ã€ã‚°ãƒ©ãƒ•å†…ã§å°†æ¥å½¢æˆã•ã‚Œã‚‹å¯èƒ½æ€§ã®ã‚ã‚‹ã‚¨ãƒƒã‚¸ã‚’äºˆæ¸¬ã™ã‚‹ã‚¿ã‚¹ã‚¯ã§ã™ã€‚æ¨è–¦ã‚·ã‚¹ãƒ†ãƒ ã‚„Knowledgeã‚°ãƒ©ãƒ•ã®è£œå®Œã«å¿œç”¨ã•ã‚Œã¾ã™ã€‚</p>

<h4>åŸºæœ¬çš„ãªã‚¢ãƒ—ãƒ­ãƒ¼ãƒ</h4>

<ol>
<li><strong>å…±é€šéš£æ¥æ•°</strong>ï¼šå…±é€šã®å‹äººãŒå¤šã„ã»ã©ç¹‹ãŒã‚Šã‚„ã™ã„</li>
<li><strong>Jaccardä¿‚æ•°</strong>ï¼šéš£æ¥ãƒãƒ¼ãƒ‰é›†åˆã®é¡ä¼¼åº¦</li>
<li><strong>Adamic-AdaræŒ‡æ•°</strong>ï¼šå…±é€šéš£æ¥ã®å¸Œå°‘æ€§ã‚’è€ƒæ…®</li>
<li><strong>Preferential Attachment</strong>ï¼šæ¬¡æ•°ã®ç©ï¼ˆäººæ°— learneråŒå£«ãŒç¹‹ãŒã‚‹ï¼‰</li>
</ol>

<pre><code class="language-python">import networkx as nx
import numpy as np
from sklearn.metrics import roc_auc_score, average_precision_score
import matplotlib.pyplot as plt

print("=== ãƒªãƒ³ã‚¯äºˆæ¸¬ï¼ˆLink Predictionï¼‰===\n")

# ã‚°ãƒ©ãƒ•ã®æº–å‚™
G_original = nx.karate_club_graph()
print(f"å…ƒã®ã‚°ãƒ©ãƒ•:")
print(f"  ãƒãƒ¼ãƒ‰æ•°: {G_original.number_of_nodes()}")
print(f"  ã‚¨ãƒƒã‚¸æ•°: {G_original.number_of_edges()}\n")

# ã‚¨ãƒƒã‚¸ã‚’è¨“ç·´ç”¨ã¨ãƒ†ã‚¹ãƒˆç”¨ã« minuteså‰²
print("ã‚¨ãƒƒã‚¸ minuteså‰²:")
edges = list(G_original.edges())
np.random.seed(42)
np.random.shuffle(edges)

# 80%ã‚’è¨“ç·´ã€20%ã‚’ãƒ†ã‚¹ãƒˆ
split_idx = int(0.8 * len(edges))
train_edges = edges[:split_idx]
test_edges = edges[split_idx:]

print(f"  è¨“ç·´ã‚¨ãƒƒã‚¸: {len(train_edges)}")
print(f"  ãƒ†ã‚¹ãƒˆã‚¨ãƒƒã‚¸: {len(test_edges)}\n")

# è¨“ç·´ç”¨ã‚°ãƒ©ãƒ•ã®ä½œæˆ
G_train = nx.Graph()
G_train.add_nodes_from(G_original.nodes())
G_train.add_edges_from(train_edges)

print(f"è¨“ç·´ã‚°ãƒ©ãƒ•:")
print(f"  ãƒãƒ¼ãƒ‰æ•°: {G_train.number_of_nodes()}")
print(f"  ã‚¨ãƒƒã‚¸æ•°: {G_train.number_of_edges()}\n")

# è² ä¾‹ã®ç”Ÿæˆï¼ˆå­˜åœ¨ã—ãªã„ã‚¨ãƒƒã‚¸ï¼‰
def generate_negative_edges(G, num_samples):
    """å­˜åœ¨ã—ãªã„ã‚¨ãƒƒã‚¸ã‚’ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°"""
    non_edges = list(nx.non_edges(G))
    return [non_edges[i] for i in np.random.choice(
        len(non_edges), size=min(num_samples, len(non_edges)), replace=False
    )]

negative_edges = generate_negative_edges(G_train, len(test_edges))
print(f"è² ä¾‹ã‚¨ãƒƒã‚¸: {len(negative_edges)}\n")

# ãƒªãƒ³ã‚¯äºˆæ¸¬ã‚¹ã‚³ã‚¢ã®è¨ˆç®—
print("=" * 60)
print("ãƒªãƒ³ã‚¯äºˆæ¸¬æ‰‹æ³•ã®è©•ä¾¡")
print("=" * 60 + "\n")

def evaluate_link_prediction(scores, test_edges, negative_edges):
    """
    ãƒªãƒ³ã‚¯äºˆæ¸¬ã®è©•ä¾¡
    """
    # ãƒ†ã‚¹ãƒˆã‚¨ãƒƒã‚¸ï¼ˆæ­£ä¾‹ï¼‰ã®ã‚¹ã‚³ã‚¢
    positive_scores = [scores.get((u, v), scores.get((v, u), 0))
                      for u, v in test_edges]

    # è² ä¾‹ã‚¨ãƒƒã‚¸ã®ã‚¹ã‚³ã‚¢
    negative_scores = [scores.get((u, v), scores.get((v, u), 0))
                      for u, v in negative_edges]

    # ãƒ©ãƒ™ãƒ«ã¨ã‚¹ã‚³ã‚¢ã‚’çµåˆ
    y_true = [1] * len(positive_scores) + [0] * len(negative_scores)
    y_scores = positive_scores + negative_scores

    # è©•ä¾¡æŒ‡æ¨™
    auc = roc_auc_score(y_true, y_scores)
    ap = average_precision_score(y_true, y_scores)

    return auc, ap, y_scores, y_true

# 1. å…±é€šéš£æ¥æ•°ï¼ˆCommon Neighborsï¼‰
print("1. å…±é€šéš£æ¥æ•°ï¼ˆCommon Neighborsï¼‰")
print("-" * 40)
cn_scores = {}
for u, v in test_edges + negative_edges:
    common_neighbors = len(list(nx.common_neighbors(G_train, u, v)))
    cn_scores[(u, v)] = common_neighbors

auc_cn, ap_cn, _, _ = evaluate_link_prediction(cn_scores, test_edges, negative_edges)
print(f"AUC: {auc_cn:.4f}")
print(f"Average Precision: {ap_cn:.4f}\n")

# 2. Jaccardä¿‚æ•°
print("2. Jaccardä¿‚æ•°")
print("-" * 40)
jaccard_scores = {}
for u, v in test_edges + negative_edges:
    preds = list(nx.jaccard_coefficient(G_train, [(u, v)]))
    jaccard_scores[(u, v)] = preds[0][2] if preds else 0

auc_jc, ap_jc, _, _ = evaluate_link_prediction(jaccard_scores, test_edges, negative_edges)
print(f"AUC: {auc_jc:.4f}")
print(f"Average Precision: {ap_jc:.4f}\n")

# 3. Adamic-AdaræŒ‡æ•°
print("3. Adamic-AdaræŒ‡æ•°")
print("-" * 40)
aa_scores = {}
for u, v in test_edges + negative_edges:
    preds = list(nx.adamic_adar_index(G_train, [(u, v)]))
    aa_scores[(u, v)] = preds[0][2] if preds else 0

auc_aa, ap_aa, _, _ = evaluate_link_prediction(aa_scores, test_edges, negative_edges)
print(f"AUC: {auc_aa:.4f}")
print(f"Average Precision: {ap_aa:.4f}\n")

# 4. Preferential Attachment
print("4. Preferential Attachment")
print("-" * 40)
pa_scores = {}
for u, v in test_edges + negative_edges:
    preds = list(nx.preferential_attachment(G_train, [(u, v)]))
    pa_scores[(u, v)] = preds[0][2] if preds else 0

auc_pa, ap_pa, _, _ = evaluate_link_prediction(pa_scores, test_edges, negative_edges)
print(f"AUC: {auc_pa:.4f}")
print(f"Average Precision: {ap_pa:.4f}\n")

# çµæœã®å¯è¦–åŒ–
fig, axes = plt.subplots(1, 2, figsize=(14, 6))

# æ‰‹æ³•ã®æ¯”è¼ƒ
methods = ['Common\nNeighbors', 'Jaccard', 'Adamic-\nAdar', 'Preferential\nAttachment']
aucs = [auc_cn, auc_jc, auc_aa, auc_pa]
aps = [ap_cn, ap_jc, ap_aa, ap_pa]

x = np.arange(len(methods))
width = 0.35

bars1 = axes[0].bar(x - width/2, aucs, width, label='AUC', color='steelblue')
bars2 = axes[0].bar(x + width/2, aps, width, label='Average Precision', color='coral')

axes[0].set_xlabel('æ‰‹æ³•', fontsize=12)
axes[0].set_ylabel('ã‚¹ã‚³ã‚¢', fontsize=12)
axes[0].set_title('ãƒªãƒ³ã‚¯äºˆæ¸¬æ‰‹æ³•ã®æ€§èƒ½æ¯”è¼ƒ', fontsize=14, fontweight='bold')
axes[0].set_xticks(x)
axes[0].set_xticklabels(methods, fontsize=10)
axes[0].legend()
axes[0].grid(axis='y', alpha=0.3)
axes[0].set_ylim([0, 1.0])

# å€¤ã‚’ãƒãƒ¼ã«è¡¨ç¤º
for bars in [bars1, bars2]:
    for bar in bars:
        height = bar.get_height()
        axes[0].text(bar.get_x() + bar.get_width()/2., height,
                    f'{height:.3f}',
                    ha='center', va='bottom', fontsize=9)

# ã‚°ãƒ©ãƒ•å¯è¦–åŒ–ï¼ˆè¨“ç·´ã‚°ãƒ©ãƒ•ã¨ãƒ†ã‚¹ãƒˆã‚¨ãƒƒã‚¸ï¼‰
pos = nx.spring_layout(G_original, seed=42)

# è¨“ç·´ã‚¨ãƒƒã‚¸
nx.draw_networkx_edges(G_train, pos, ax=axes[1],
                       edge_color='gray', alpha=0.3, width=1)

# ãƒ†ã‚¹ãƒˆã‚¨ãƒƒã‚¸ï¼ˆæ­£ä¾‹ï¼‰
nx.draw_networkx_edges(G_original, pos, ax=axes[1],
                       edgelist=test_edges,
                       edge_color='green', width=2, alpha=0.7,
                       label='ãƒ†ã‚¹ãƒˆã‚¨ãƒƒã‚¸ï¼ˆæ­£ä¾‹ï¼‰')

# ãƒãƒ¼ãƒ‰
nx.draw_networkx_nodes(G_original, pos, ax=axes[1],
                      node_color='lightblue', node_size=300)
nx.draw_networkx_labels(G_original, pos, ax=axes[1], font_size=8)

axes[1].set_title('è¨“ç·´ã‚°ãƒ©ãƒ•ã¨ãƒ†ã‚¹ãƒˆã‚¨ãƒƒã‚¸', fontsize=14, fontweight='bold')
axes[1].legend(loc='upper right', fontsize=10)
axes[1].axis('off')

plt.tight_layout()
plt.savefig('link_prediction.png', dpi=150, bbox_inches='tight')
print("å¯è¦–åŒ–ã‚’ 'link_prediction.png' ã«ä¿å­˜ã—ã¾ã—ãŸã€‚")
</code></pre>

<hr>

<h2>Exercises</h2>

<details>
<summary>æ¼”ç¿’1ï¼šã‚°ãƒ©ãƒ•ã®åŸºæœ¬æ“ä½œ</summary>

<p><strong>å•é¡Œ</strong>ï¼šä»¥ä¸‹ã®æ¡ä»¶ã‚’æº€ãŸã™ã‚°ãƒ©ãƒ•ã‚’ä½œæˆã—ã€ãã®ç‰¹å¾´ã‚’ minutesæã—ã¦ãã ã•ã„ã€‚</p>

<ul>
<li>10ã®ãƒãƒ¼ãƒ‰ã‚’æŒã¤ãƒ©ãƒ³ãƒ€ãƒ ã‚°ãƒ©ãƒ•ï¼ˆErdÅ‘s-RÃ©nyi ãƒ¢ãƒ‡ãƒ«ã€$p=0.3$ï¼‰</li>
<li>ã‚°ãƒ©ãƒ•ã®æ¬¡æ•° minuteså¸ƒã‚’ãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ ã§å¯è¦–åŒ–</li>
<li>å¹³å‡ã‚¯ãƒ©ã‚¹ã‚¿ãƒªãƒ³ã‚°ä¿‚æ•°ã‚’è¨ˆç®—</li>
<li>æœ€ã‚‚ä¸­å¿ƒæ€§ã®é«˜ã„ãƒãƒ¼ãƒ‰ã‚’ç‰¹å®šï¼ˆæ¬¡æ•°ä¸­å¿ƒæ€§ã€åª’ä»‹ä¸­å¿ƒæ€§ã€PageRankï¼‰</li>
</ul>

<pre><code class="language-python">import networkx as nx
import matplotlib.pyplot as plt

# ãƒ’ãƒ³ãƒˆ
G = nx.erdos_renyi_graph(n=10, p=0.3, seed=42)

# 1. æ¬¡æ•° minuteså¸ƒã®å¯è¦–åŒ–
degrees = [G.degree(node) for node in G.nodes()]
# plt.hist(degrees, ...)

# 2. ã‚¯ãƒ©ã‚¹ã‚¿ãƒªãƒ³ã‚°ä¿‚æ•°
avg_clustering = nx.average_clustering(G)

# 3. ä¸­å¿ƒæ€§æŒ‡æ¨™
degree_centrality = nx.degree_centrality(G)
betweenness_centrality = nx.betweenness_centrality(G)
pagerank = nx.pagerank(G)
</code></pre>

</details>

<details>
<summary>æ¼”ç¿’2ï¼šã‚°ãƒ©ãƒ•è¡¨ç¾ã®å¤‰æ›</summary>

<p><strong>å•é¡Œ</strong>ï¼šä»¥ä¸‹ã®ã‚¨ãƒƒã‚¸ãƒªã‚¹ãƒˆã§å®šç¾©ã•ã‚Œã‚‹ã‚°ãƒ©ãƒ•ã‚’ã€éš£æ¥è¡Œåˆ—ã¨éš£æ¥ãƒªã‚¹ãƒˆã®ä¸¡æ–¹ã§è¡¨ç¾ã—ã¦ãã ã•ã„ã€‚</p>

<pre>
ã‚¨ãƒƒã‚¸ãƒªã‚¹ãƒˆ: [(0, 1), (0, 2), (1, 3), (2, 3), (3, 4)]
</pre>

<ul>
<li>éš£æ¥è¡Œåˆ—ã‚’NumPyé…åˆ—ã¨ã—ã¦å‡ºåŠ›</li>
<li>éš£æ¥ãƒªã‚¹ãƒˆã‚’è¾æ›¸ã¨ã—ã¦å‡ºåŠ›</li>
<li>ã©ã¡ã‚‰ã®è¡¨ç¾ãŒãƒ¡ãƒ¢ãƒªåŠ¹ç‡ãŒè‰¯ã„ã‹è€ƒå¯Ÿ</li>
</ul>

</details>

<details>
<summary>æ¼”ç¿’3ï¼šPageRankã®å®Ÿè£…ã¨æ¤œè¨¼</summary>

<p><strong>å•é¡Œ</strong>ï¼šç°¡å˜ãªæœ‰å‘ã‚°ãƒ©ãƒ•ã«å¯¾ã—ã¦PageRankã‚’æ‰‹å‹•è¨ˆç®—ã—ã€NetworkXã®çµæœã¨æ¯”è¼ƒã—ã¦ãã ã•ã„ã€‚</p>

<pre><code class="language-python">import networkx as nx

G = nx.DiGraph()
G.add_edges_from([('A', 'B'), ('B', 'C'), ('C', 'A'), ('B', 'D')])

# 1. æ‰‹å‹•ã§PageRankã‚’3å›åå¾©è¨ˆç®—
# 2. NetworkXã®PageRankã¨æ¯”è¼ƒ
# 3. åæŸã¾ã§ã«ä½•å›ã®åå¾©ãŒå¿…è¦ã‹èª¿æŸ»
</code></pre>

</details>

<details>
<summary>æ¼”ç¿’4ï¼šã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£æ¤œå‡ºã®æ¯”è¼ƒ</summary>

<p><strong>å•é¡Œ</strong>ï¼šLouvainæ³•ã¨Label Propagationã§æ¤œå‡ºã•ã‚ŒãŸã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£ã®é•ã„ã‚’ minutesæã—ã¦ãã ã•ã„ã€‚</p>

<ul>
<li>ä»»æ„ã®ã‚°ãƒ©ãƒ•ï¼ˆä¾‹ï¼šnx.karate_club_graph()ï¼‰ã‚’ä½¿ç”¨</li>
<li>å„æ‰‹æ³•ã§æ¤œå‡ºã•ã‚ŒãŸã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£æ•°ã‚’æ¯”è¼ƒ</li>
<li>ãƒ¢ã‚¸ãƒ¥ãƒ©ãƒªãƒ†ã‚£ã‚¹ã‚³ã‚¢ã‚’è¨ˆç®—</li>
<li>ä¸¡æ‰‹æ³•ã®çµæœã‚’å¯è¦–åŒ–ã—ã¦é•ã„ã‚’èª¬æ˜</li>
</ul>

</details>

<details>
<summary>æ¼”ç¿’5ï¼šNode2Vecã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿èª¿æ•´</summary>

<p><strong>å•é¡Œ</strong>ï¼šNode2Vecã® $p$ ã¨ $q$ ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’å¤‰ãˆã¦ã€åŸ‹ã‚è¾¼ã¿çµæœãŒã©ã†å¤‰ã‚ã‚‹ã‹è¦³å¯Ÿã—ã¦ãã ã•ã„ã€‚</p>

<ul>
<li>$(p=0.5, q=2.0)$ï¼ˆBFSçš„ï¼‰ã¨ $(p=2.0, q=0.5)$ï¼ˆDFSçš„ï¼‰ã‚’è©¦ã™</li>
<li>å„è¨­å®šã§ç”Ÿæˆã•ã‚ŒãŸåŸ‹ã‚è¾¼ã¿ã‚’t-SNEã§å¯è¦–åŒ–</li>
<li>ã©ã¡ã‚‰ãŒã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£æ§‹é€ ã‚’ã‚ˆã‚Šè‰¯ãæ‰ãˆã¦ã„ã‚‹ã‹è©•ä¾¡</li>
</ul>

</details>

<details>
<summary>æ¼”ç¿’6ï¼šãƒªãƒ³ã‚¯äºˆæ¸¬ã®å®Ÿè£…</summary>

<p><strong>å•é¡Œ</strong>ï¼šç‹¬è‡ªã®ã‚°ãƒ©ãƒ•ã«å¯¾ã—ã¦ãƒªãƒ³ã‚¯äºˆæ¸¬ã‚’å®Ÿè£…ã—ã€ç•°ãªã‚‹æ‰‹æ³•ã®æ€§èƒ½ã‚’æ¯”è¼ƒã—ã¦ãã ã•ã„ã€‚</p>

<ul>
<li>ä»»æ„ã®ã‚°ãƒ©ãƒ•ã‚’é¸æŠï¼ˆå®Ÿãƒ‡ãƒ¼ã‚¿ã¾ãŸã¯ç”Ÿæˆï¼‰</li>
<li>ã‚¨ãƒƒã‚¸ã‚’è¨“ç·´/ãƒ†ã‚¹ãƒˆã« minuteså‰²ï¼ˆ80/20ï¼‰</li>
<li>Common Neighborsã€Jaccardã€Adamic-Adarã‚’å®Ÿè£…</li>
<li>AUCã¨Average Precisionã§è©•ä¾¡</li>
<li>ã©ã®æ‰‹æ³•ãŒæœ€ã‚‚åŠ¹æœçš„ã‹ minutesæ</li>
</ul>

</details>

<hr>

<h2>Summary</h2>

<p>ã“ã® Chapterã§ã¯ã€ã‚°ãƒ©ãƒ•ã¨ã‚°ãƒ©ãƒ•è¡¨ç¾å­¦ç¿’ã®åŸºç¤ã‚’å­¦ã³ã¾ã—ãŸï¼š</p>

<ul>
<li>âœ… <strong>ã‚°ãƒ©ãƒ•ç†è«–ã®åŸºç¤</strong>ï¼šãƒãƒ¼ãƒ‰ã€ã‚¨ãƒƒã‚¸ã€æœ‰å‘/ç„¡å‘ã‚°ãƒ©ãƒ•ã€ã‚°ãƒ©ãƒ•ã®ç¨®é¡ï¼ˆæœ¨ã€DAGã€å®Œå…¨ã‚°ãƒ©ãƒ•ï¼‰</li>
<li>âœ… <strong>ã‚°ãƒ©ãƒ•ã®è¡¨ç¾</strong>ï¼šéš£æ¥è¡Œåˆ—ã€éš£æ¥ãƒªã‚¹ãƒˆã€ã‚¨ãƒƒã‚¸ãƒªã‚¹ãƒˆã®ç‰¹å¾´ã¨ä½¿ã„ minutesã‘</li>
<li>âœ… <strong>ã‚°ãƒ©ãƒ•ã®ç‰¹å¾´é‡</strong>ï¼šæ¬¡æ•°ã€ã‚¯ãƒ©ã‚¹ã‚¿ãƒªãƒ³ã‚°ä¿‚æ•°ã€ä¸­å¿ƒæ€§æŒ‡æ¨™ï¼ˆæ¬¡æ•°ã€è¿‘æ¥ã€åª’ä»‹ã€å›ºæœ‰ãƒ™ã‚¯ãƒˆãƒ«ã€PageRankï¼‰</li>
<li>âœ… <strong>ã‚°ãƒ©ãƒ•åŸ‹ã‚è¾¼ã¿</strong>ï¼šDeepWalkã€Node2Vecã«ã‚ˆã‚‹ãƒ©ãƒ³ãƒ€ãƒ ã‚¦ã‚©ãƒ¼ã‚¯ãƒ™ãƒ¼ã‚¹ã®åŸ‹ã‚è¾¼ã¿æ‰‹æ³•</li>
<li>âœ… <strong>å®Ÿè·µçš„å¿œç”¨</strong>ï¼šã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£æ¤œå‡ºã€ãƒªãƒ³ã‚¯äºˆæ¸¬ã€ã‚½ãƒ¼ã‚·ãƒ£ãƒ«Network Analysis</li>
</ul>

<p>æ¬¡ Chapterã§ã¯ã€ã“ã‚Œã‚‰ã®åŸºç¤Knowledgeã‚’è¸ã¾ãˆã¦ã€<strong>Graph Neural Networksï¼ˆGNNï¼‰</strong>ã®åŸºæœ¬åŸç†ã‚’å­¦ã³ã¾ã™ã€‚ã‚°ãƒ©ãƒ•ç•³ã¿è¾¼ã¿ã®ä»•çµ„ã¿ã€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ‘ãƒƒã‚·ãƒ³ã‚°ã€è¿‘å‚é›†ç´„ãªã©ã€GNNã®æ ¸å¿ƒçš„ãªæ¦‚å¿µã‚’ç†è§£ã—ã¦ã„ãã¾ã™ã€‚</p>

<blockquote>
<p><strong>é‡è¦ãªãƒã‚¤ãƒ³ãƒˆ</strong>ï¼šã‚°ãƒ©ãƒ•æ§‹é€ ãƒ‡ãƒ¼ã‚¿ã¯ã€ç”»åƒã‚„è‡ªç„¶è¨€èªã¨ã¯ç•°ãªã‚‹ç‰¹æ€§ã‚’æŒã¡ã¾ã™ã€‚å¯å¤‰ã‚µã‚¤ã‚ºã€éãƒ¦ãƒ¼ã‚¯ãƒªãƒƒãƒ‰æ§‹é€ ã€ç½®æ›ä¸å¤‰æ€§ãªã©ã®æ€§è³ªã‚’ç†è§£ã™ã‚‹ã“ã¨ãŒã€GNNã‚’åŠ¹æœçš„ã«ä½¿ã†éµã¨ãªã‚Šã¾ã™ã€‚</p>
</blockquote>

<div class="navigation">
    <a href="index.html" class="nav-button">â† ã‚³ãƒ¼ã‚¹æ¦‚è¦ã«æˆ»ã‚‹</a>
    <a href="chapter2-gnn-basics.html" class="nav-button">Chapter 2 Chapterï¼šGNNã®åŸºç¤ â†’</a>
</div>

    </main>

    
    <section class="disclaimer">
        <h3>Disclaimer</h3>
        <ul>
            <li>This content is provided solely for educational, research, and informational purposes and does not constitute professional advice (legal, accounting, technical guarantees, etc.).</li>
            <li>This content and accompanying code examples are provided "AS IS" without warranty of any kind, either express or implied, including but not limited to merchantability, fitness for a particular purpose, non-infringement, accuracy, completeness, operation, or safety.</li>
            <li>The creators and Tohoku University assume no responsibility for the content, availability, or safety of external links, third-party data, tools, libraries, etc.</li>
            <li>To the maximum extent permitted by applicable law, the creators and Tohoku University shall not be liable for any direct, indirect, incidental, special, consequential, or punitive damages arising from the use, execution, or interpretation of this content.</li>
            <li>The content of this material may be changed, updated, or discontinued without notice.</li>
            <li>The copyright and license of this content are subject to the specified terms (e.g., CC BY 4.0). Such licenses typically include warranty disclaimers.</li>
        </ul>
    </section>

<footer>
        <p>&copy; 2025 AI Terakoya. All rights reserved.</p>
        <p>ã“ã®ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã¯æ•™è‚²ç›®çš„ã§ä½œæˆã•ã‚Œã¦ã„ã¾ã™ã€‚</p>
    </footer>
</body>
</html>