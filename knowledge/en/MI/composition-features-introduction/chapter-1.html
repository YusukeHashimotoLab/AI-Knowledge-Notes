<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="Chapter 1: Fundamentals of Composition-Based Features - Composition-Based Features Introduction Series" name="description"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<meta content="Fundamentals of Composition-Based Features - Learn the principles of predicting material properties from chemical composition" name="description"/>
<title>Chapter 1: Fundamentals of Composition-Based Features - Composition-Based Features Introduction Series</title>
<!-- CSS Styling -->
<link href="../../assets/css/knowledge-base.css" rel="stylesheet"/>
<!-- Prism.js for syntax highlighting -->
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet"/>
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" rel="stylesheet"/>
<!-- Mermaid for diagrams -->
<script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
<script>
        document.addEventListener('DOMContentLoaded', function() {
            const mermaidCodeBlocks = document.querySelectorAll('pre.codehilite code.language-mermaid, pre code.language-mermaid');

            mermaidCodeBlocks.forEach(function(codeBlock) {
                const pre = codeBlock.parentElement;
                const mermaidCode = codeBlock.textContent;

                const mermaidDiv = document.createElement('div');
                mermaidDiv.className = 'mermaid';
                mermaidDiv.textContent = mermaidCode.trim();

                pre.parentNode.replaceChild(mermaidDiv, pre);
            });

            if (typeof mermaid !== 'undefined') {
                mermaid.initialize({ startOnLoad: true, theme: 'default' });
                mermaid.init(undefined, document.querySelectorAll('.mermaid'));
            }
        });
    </script>
<!-- MathJax for mathematical expressions -->
<script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\(', '\)']],
                displayMath: [['$$', '$$'], ['\[', '\]']],
                processEscapes: true,
                processEnvironments: true
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
                ignoreHtmlClass: 'mermaid'
            }
        };
    </script>
<script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
<nav class="breadcrumb">
<div class="breadcrumb-content">
<a href="/AI-Knowledge-Notes/knowledge/en/index.html">AI Terakoya Top</a><span class="breadcrumb-separator">‚Ä∫</span><a href="/AI-Knowledge-Notes/knowledge/en/MI/index.html">Materials Informatics</a><span class="breadcrumb-separator">‚Ä∫</span><a href="./index.html">Composition-Based Features Introduction</a><span class="breadcrumb-separator">‚Ä∫</span><span class="breadcrumb-current">Chapter 1</span>
</div>
</nav><div class="locale-switcher">
<span class="current-locale">üåê EN</span>
<span class="locale-separator">|</span>
<a href="../../../jp/MI/composition-features-introduction/chapter-1.html" class="locale-link">üáØüáµ JP</a>
<span class="locale-separator">|</span>
<span class="locale-meta">Last sync: 2025-11-16</span>
</div>
<header>
<div class="container">
<h1>Chapter 1: Fundamentals of Composition-Based Features</h1>
<p class="subtitle">Principles of Predicting Material Properties from Chemical Composition</p>
<div class="meta">
<span>üìñ Reading Time: 25-30 min</span>
<span>üìä Difficulty: Beginner</span>
<span>üíª Code Examples: 8</span>
<span>üìù Exercises: 10</span>
</div>
</div>
</header>
<main class="container">

<p class="chapter-description">This chapter covers the fundamentals of Fundamentals of Composition, which based features. You will learn essential concepts and techniques.</p>
<div class="objectives-box">
<h3>üéØ Learning Objectives for This Chapter</h3>
<h4>Fundamental Understanding</h4>
<ul>
<li>‚úÖ Explain the definition and role of composition-based features</li>
<li>‚úÖ Understand principles of statistical aggregation (mean, variance, max/min, range)</li>
<li>‚úÖ Understand prediction capabilities and limitations without structural information</li>
</ul>
<h4>Practical Skills</h4>
<ul>
<li>‚úÖ Parse chemical formulas and extract elemental information using pymatgen</li>
<li>‚úÖ Generate basic composition-based features using matminer</li>
<li>‚úÖ Utilize elemental property databases to calculate statistics</li>
</ul>
<h4>Application Abilities</h4>
<ul>
<li>‚úÖ Apply composition-based features to new material systems</li>
<li>‚úÖ Design prediction workflows integrated with machine learning models</li>
<li>‚úÖ Determine applicable and inappropriate tasks</li>
</ul>
</div>
<h2 id="section-1-1">1.1 Principles of Feature Extraction from Chemical Composition</h2>
<h3>What Are Composition-Based Features?</h3>
<p>In materials discovery, <strong>chemical composition</strong> (types and ratios of elements) is the most fundamental information. For example, the chemical formula "Fe<sub>2</sub>O<sub>3</sub>" for iron oxide means "2 iron atoms and 3 oxygen atoms." However, this string cannot be directly input into machine learning models.</p>
<p><strong>Composition-based features</strong> are techniques for converting chemical composition into <strong>numerical vectors</strong>. Specifically, using periodic table information for elements (atomic radius, ionization energy, electronegativity, etc.), the conversion proceeds as follows:</p>
<div class="mermaid">
graph LR
    A["Chemical Formula<br/>Fe‚ÇÇO‚ÇÉ"] --&gt; B["Element Extraction<br/>Fe: 2 atoms<br/>O: 3 atoms"]
    B --&gt; C["Elemental Property Retrieval<br/>Fe: Atomic Radius=1.26√Ö, IE=7.9eV<br/>O: Atomic Radius=0.66√Ö, IE=13.6eV"]
    C --&gt; D["Statistical Aggregation<br/>Mean Atomic Radius=0.92√Ö<br/>Mean IE=10.1eV<br/>..."]
    D --&gt; E["Feature Vector<br/>[0.92, 10.1, ...]<br/>(145 dimensions)"]
        </div>
<h3>Comparison of Information Content: Chemical Composition vs Crystal Structure</h3>
<p>There are two major approaches to describing materials:</p>
<table>
<thead>
<tr>
<th>Approach</th>
<th>Required Information</th>
<th>Information Content</th>
<th>Prediction Accuracy</th>
<th>Computation Speed</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Composition-Based</strong></td>
<td>Chemical formula only (e.g., Fe‚ÇÇO‚ÇÉ)</td>
<td>Low (~150 dimensions)</td>
<td>Medium (R¬≤=0.7-0.85)</td>
<td>Fast (1 million compounds in 1 second)</td>
</tr>
<tr>
<td><strong>Structure-Based</strong> (GNN)</td>
<td>Atomic coordinates, bonding information</td>
<td>High (~thousands of dimensions)</td>
<td>High (R¬≤=0.85-0.95)</td>
<td>Slow (1000 compounds in 1 minute)</td>
</tr>
</tbody>
</table>
<div class="highlight-box">
<h4>üí° Three Cases Where Composition-Based Approach is Advantageous</h4>
<ol>
<li><strong>Discovery of materials with unknown structures</strong>: Crystal structure is unknown for pre-synthesis candidate screening</li>
<li><strong>High-speed large-scale screening</strong>: Formation energy prediction for 1 million compounds (100x faster than GNN)</li>
<li><strong>Experimental data-driven approach</strong>: Learning from experimental data where structural information is difficult to obtain</li>
</ol>
</div>
<h3>Types and Materials Science Significance of Elemental Properties</h3>
<p>Composition-based features utilize <strong>elemental periodic table databases</strong>. Representative 22 types of elemental properties:</p>
<table>
<thead>
<tr>
<th>Category</th>
<th>Elemental Property</th>
<th>Materials Science Significance</th>
</tr>
</thead>
<tbody>
<tr>
<td rowspan="3"><strong>Atomic Structure</strong></td>
<td>Atomic Number</td>
<td>Basic element identifier</td>
</tr>
<tr>
<td>Period</td>
<td>Number of electron shells (indicator of chemical reactivity)</td>
</tr>
<tr>
<td>Group</td>
<td>Number of valence electrons (indicator of bonding tendency)</td>
</tr>
<tr>
<td rowspan="4"><strong>Atomic Size</strong></td>
<td>Atomic Radius</td>
<td>Crystal lattice size, packing fraction</td>
</tr>
<tr>
<td>Covalent Radius</td>
<td>Covalent bond length</td>
</tr>
<tr>
<td>Ionic Radius</td>
<td>Lattice constant of ionic crystals</td>
</tr>
<tr>
<td>Atomic Volume</td>
<td>Crystal density estimation</td>
</tr>
<tr>
<td rowspan="5"><strong>Electronic Properties</strong></td>
<td>Ionization Energy</td>
<td>Chemical bond strength, reactivity</td>
</tr>
<tr>
<td>Electron Affinity</td>
<td>Oxidation/reduction tendency</td>
</tr>
<tr>
<td>Electronegativity</td>
<td>Bond polarity, ionicity</td>
</tr>
<tr>
<td>Valence Electrons</td>
<td>Type of chemical bonding</td>
</tr>
<tr>
<td>Oxidation State</td>
<td>Charge balance in ionic bonding</td>
</tr>
<tr>
<td rowspan="4"><strong>Thermal &amp; Physical Properties</strong></td>
<td>Melting Point</td>
<td>Crystal stability, synthesis temperature</td>
</tr>
<tr>
<td>Boiling Point</td>
<td>Volatility</td>
</tr>
<tr>
<td>Density</td>
<td>Crystal packing fraction</td>
</tr>
<tr>
<td>Thermal Conductivity</td>
<td>Heat transport properties</td>
</tr>
<tr>
<td rowspan="6"><strong>Others</strong></td>
<td>Abundance (in Earth's crust)</td>
<td>Material cost, rarity</td>
</tr>
<tr>
<td>Discovery Year</td>
<td>Historical background of element</td>
</tr>
<tr>
<td>Specific Heat Capacity</td>
<td>Heat capacity estimation</td>
</tr>
<tr>
<td>Electrical Resistivity</td>
<td>Conductivity indicator</td>
</tr>
<tr>
<td>Magnetic Moment</td>
<td>Magnetic material design</td>
</tr>
<tr>
<td>Polarizability</td>
<td>Dielectric properties</td>
</tr>
</tbody>
</table>
<h3>Statistical Aggregation Methods (Mean, Variance, Max/Min, Range)</h3>
<p>For compounds consisting of multiple elements (e.g., Fe‚ÇÇO‚ÇÉ), properties of each element are <strong>statistically aggregated</strong>. Representative 6 statistics:</p>
<ol>
<li><strong>Mean</strong>: $\bar{x} = \frac{1}{n}\sum_{i=1}^{n} w_i x_i$ (weight $w_i$ is composition ratio)</li>
<li><strong>Variance</strong>: $\sigma^2 = \frac{1}{n}\sum_{i=1}^{n} w_i (x_i - \bar{x})^2$</li>
<li><strong>Standard Deviation</strong>: $\sigma = \sqrt{\sigma^2}$</li>
<li><strong>Maximum</strong>: $\max(x_1, x_2, \ldots, x_n)$</li>
<li><strong>Minimum</strong>: $\min(x_1, x_2, \ldots, x_n)$</li>
<li><strong>Range</strong>: $\text{range} = \max - \min$</li>
</ol>
<div class="highlight-box">
<h4>üîç Concrete Example: Atomic Radius Statistics for Fe‚ÇÇO‚ÇÉ</h4>
<ul>
<li>Fe atomic radius: 1.26 √Ö (composition ratio: 2/5 = 0.4)</li>
<li>O atomic radius: 0.66 √Ö (composition ratio: 3/5 = 0.6)</li>
</ul>
<p><strong>Calculation Results</strong>:</p>
<ul>
<li>Mean: $0.4 \times 1.26 + 0.6 \times 0.66 = 0.900$ √Ö</li>
<li>Variance: $0.4(1.26-0.90)^2 + 0.6(0.66-0.90)^2 = 0.086$ ≈≤</li>
<li>Max: 1.26 √Ö, Min: 0.66 √Ö, Range: 0.60 √Ö</li>
</ul>
</div>
<h3>Code Example 1: Basic Operations with pymatgen Composition Class</h3>
<a class="colab-badge" href="https://colab.research.google.com/github/AI-Terakoya/composition-features-tutorial/blob/main/chapter1_example1.ipynb">Open in Google Colab</a>
<pre><code class="language-python"># Parse chemical formula and extract elemental information
from pymatgen.core import Composition

# Create chemical formula
comp = Composition("Fe2O3")

# Retrieve basic information
print(f"Chemical Formula: {comp}")
print(f"Element Types: {comp.elements}")  # [Element Fe, Element O]
print(f"Total Atoms: {comp.num_atoms}")  # 5.0
print(f"Total Weight: {comp.weight:.2f} g/mol")  # 159.69 g/mol

# Composition ratio for each element
print("\nComposition ratio by element:")
for element, fraction in comp.get_atomic_fraction().items():
    print(f"  {element}: {fraction:.3f} ({fraction*comp.num_atoms:.0f} atoms)")
# Output:
#   Fe: 0.400 (2 atoms)
#   O: 0.600 (3 atoms)

# Check fractional notation
print(f"\nBefore reduction: {Composition('Fe4O6')}")  # Fe4 O6
print(f"After reduction: {Composition('Fe4O6').reduced_composition}")  # Fe2 O3</code></pre>
<h3>Code Example 2: Elemental Property Extraction and Visualization</h3>
<a class="colab-badge" href="https://colab.research.google.com/github/AI-Terakoya/composition-features-tutorial/blob/main/chapter1_example2.ipynb">Open in Google Colab</a>
<pre><code class="language-python"># Requirements:
# - Python 3.9+
# - matplotlib&gt;=3.7.0

"""
Example: Code Example 2: Elemental Property Extraction and Visualizat

Purpose: Demonstrate data visualization techniques
Target: Beginner to Intermediate
Execution time: 2-5 seconds
Dependencies: None
"""

# Extract elemental properties and visualize with matplotlib
import matplotlib.pyplot as plt
from pymatgen.core import Element

# Compare atomic radii of multiple elements
elements = [Element("Fe"), Element("O"), Element("Cu"), Element("Si")]
properties = {
    "Atomic Radius (√Ö)": [el.atomic_radius for el in elements],
    "Ionization Energy (eV)": [el.ionization_energy for el in elements],
    "Electronegativity (Pauling)": [el.X for el in elements]
}

# Visualization
fig, axes = plt.subplots(1, 3, figsize=(15, 4))
element_names = [el.symbol for el in elements]

for ax, (prop_name, values) in zip(axes, properties.items()):
    ax.bar(element_names, values, color=['#f093fb', '#f5576c', '#feca57', '#48dbfb'])
    ax.set_ylabel(prop_name, fontsize=12)
    ax.set_title(f"Elemental Property Comparison: {prop_name}", fontsize=14, fontweight='bold')
    ax.grid(axis='y', alpha=0.3)

plt.tight_layout()
plt.savefig('element_properties.png', dpi=150, bbox_inches='tight')
plt.show()

# Numerical output
print("Elemental Property Data:")
for prop_name, values in properties.items():
    print(f"\n{prop_name}:")
    for el, val in zip(element_names, values):
        print(f"  {el}: {val:.3f}")</code></pre>
<h3>Code Example 3: Statistics Calculation (Mean, Standard Deviation, Range)</h3>
<a class="colab-badge" href="https://colab.research.google.com/github/AI-Terakoya/composition-features-tutorial/blob/main/chapter1_example3.ipynb">Open in Google Colab</a>
<pre><code class="language-python"># Requirements:
# - Python 3.9+
# - numpy&gt;=1.24.0, &lt;2.0.0

# Manual calculation of composition-based statistics
import numpy as np
from pymatgen.core import Composition, Element

def compute_weighted_stats(comp, property_name):
    """Calculate statistics weighted by composition ratio"""
    # Extract elements and composition ratios
    fractions = comp.get_atomic_fraction()

    # Retrieve elemental properties
    values = []
    weights = []
    for element, frac in fractions.items():
        prop_value = getattr(Element(element), property_name)
        values.append(prop_value)
        weights.append(frac)

    values = np.array(values)
    weights = np.array(weights)

    # Calculate statistics
    mean = np.sum(weights * values)
    variance = np.sum(weights * (values - mean)**2)
    std = np.sqrt(variance)

    return {
        'mean': mean,
        'std': std,
        'variance': variance,
        'max': values.max(),
        'min': values.min(),
        'range': values.max() - values.min()
    }

# Calculate atomic radius statistics for Fe2O3
comp = Composition("Fe2O3")
stats = compute_weighted_stats(comp, 'atomic_radius')

print("Atomic Radius Statistics for Fe2O3:")
for stat_name, value in stats.items():
    print(f"  {stat_name}: {value:.4f} √Ö")

# Example output:
#   mean: 0.9000 √Ö
#   std: 0.2933 √Ö
#   variance: 0.0860 ≈≤
#   max: 1.2600 √Ö
#   min: 0.6600 √Ö
#   range: 0.6000 √Ö</code></pre>
<h2 id="section-1-2">1.2 Elemental Periodic Table and Material Properties</h2>
<h3>Periodicity and Correlation with Material Properties</h3>
<p>The periodic table is based on the periodic law, which states that <strong>elemental properties change periodically</strong>. This periodicity directly contributes to predicting material properties:</p>
<div class="mermaid">
graph TD
    A[Periodic Table] --&gt; B[Period]
    A --&gt; C[Group]
    B --&gt; D[Number of Electron Shells<br/>‚Üí Atomic Size]
    C --&gt; E[Valence Electrons<br/>‚Üí Bonding Nature]
    D --&gt; F[Crystal Lattice Constant<br/>Density]
    E --&gt; G[Ionicity<br/>Covalency]
    F --&gt; H[Material Properties<br/>Formation Energy<br/>Band Gap]
    G --&gt; H
        </div>
<h4>Effect of Period</h4>
<ul>
<li><strong>As period increases</strong> (top to bottom):
                <ul>
<li>Atomic radius increases ‚Üí Crystal lattice becomes larger</li>
<li>Ionization energy decreases ‚Üí Reactivity becomes higher</li>
<li>Metallic character increases ‚Üí Conductivity improves</li>
</ul>
</li>
</ul>
<h4>Effect of Group</h4>
<ul>
<li><strong>As group number increases</strong> (left to right):
                <ul>
<li>Valence electron count increases ‚Üí Diversity of oxidation states</li>
<li>Electronegativity increases ‚Üí Polarity of ionic bonding</li>
<li>Non-metallic character increases ‚Üí Insulating materials</li>
</ul>
</li>
</ul>
<h3>Trends in Element Groups (Transition Metals, Halogens, etc.)</h3>
<table>
<thead>
<tr>
<th>Element Group</th>
<th>Representative Elements</th>
<th>Characteristic Properties</th>
<th>Material Application Examples</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Alkali Metals</strong><br/>(Group 1)</td>
<td>Li, Na, K</td>
<td>„ÉªLow ionization energy<br/>„ÉªHigh reactivity<br/>„ÉªLightweight</td>
<td>Lithium-ion batteries<br/>Sodium-ion batteries</td>
</tr>
<tr>
<td><strong>Transition Metals</strong><br/>(Groups 3-12)</td>
<td>Fe, Co, Ni, Cu</td>
<td>„ÉªMultiple oxidation states<br/>„Éªd-orbital electrons<br/>„ÉªMagnetism</td>
<td>Catalysts, magnetic materials<br/>Structural materials</td>
</tr>
<tr>
<td><strong>Halogens</strong><br/>(Group 17)</td>
<td>F, Cl, Br, I</td>
<td>„ÉªHigh electronegativity<br/>„ÉªStrong oxidizing power<br/>„ÉªIonic bond formation</td>
<td>Perovskites<br/>Halide electrolytes</td>
</tr>
<tr>
<td><strong>Rare Earth Elements</strong><br/>(Lanthanides)</td>
<td>La, Ce, Nd, Gd</td>
<td>„Éª4f orbital electrons<br/>„ÉªMagnetic moment<br/>„ÉªFluorescence properties</td>
<td>Permanent magnets, phosphors<br/>Catalysts</td>
</tr>
<tr>
<td><strong>Metalloids</strong><br/>(Groups 13-16 boundary)</td>
<td>Si, Ge, As</td>
<td>„ÉªIntermediate between metals and non-metals<br/>„ÉªAdjustable band gap</td>
<td>Semiconductors, solar cells<br/>Thermoelectric materials</td>
</tr>
</tbody>
</table>
<h3>Structural Chemistry Background (Bond Types, Coordination Number)</h3>
<p>Elemental properties directly influence <strong>chemical bond types</strong> and <strong>coordination structures</strong>:</p>
<h4>Relationship Between Bond Types and Elemental Properties</h4>
<ol>
<li><strong>Ionic Bonding</strong>:
                <ul>
<li>Between elements with large electronegativity difference (e.g., Na-Cl, Ca-O)</li>
<li>Ionicity dominates when electronegativity difference $\Delta X &gt; 1.7$</li>
<li>Prediction: Large formation energy, hard, insulating</li>
</ul>
</li>
<li><strong>Covalent Bonding</strong>:
                <ul>
<li>Between elements with similar electronegativity (e.g., Si-Si, C-C)</li>
<li>Strong covalent bonding when $\Delta X &lt; 0.5$</li>
<li>Prediction: Directional bonding, semiconductor properties</li>
</ul>
</li>
<li><strong>Metallic Bonding</strong>:
                <ul>
<li>Between metallic elements (e.g., Fe-Fe, Cu-Cu)</li>
<li>Sharing of free electrons</li>
<li>Prediction: High conductivity, malleability and ductility</li>
</ul>
</li>
</ol>
<h4>Coordination Number and Atomic Radius Ratio</h4>
<p>In ionic crystals, the <strong>coordination number</strong> (number of ions around the central ion) is determined by the atomic radius ratio $r_{\text{cation}}/r_{\text{anion}}$:</p>
<table>
<thead>
<tr>
<th>Radius Ratio</th>
<th>Coordination Number</th>
<th>Coordination Structure</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td>0.225 - 0.414</td>
<td>4</td>
<td>Tetrahedral</td>
<td>ZnS (Zinc blende)</td>
</tr>
<tr>
<td>0.414 - 0.732</td>
<td>6</td>
<td>Octahedral</td>
<td>NaCl (Rock salt)</td>
</tr>
<tr>
<td>0.732 - 1.000</td>
<td>8</td>
<td>Cubic</td>
<td>CsCl (Cesium chloride)</td>
</tr>
<tr>
<td>&gt; 1.000</td>
<td>12</td>
<td>Close-packed</td>
<td>Metallic crystals</td>
</tr>
</tbody>
</table>
<div class="highlight-box">
<h4>üî¨ Real Example: Predicting Coordination Structure of TiO‚ÇÇ</h4>
<ul>
<li>Ti‚Å¥‚Å∫ ionic radius: 0.605 √Ö</li>
<li>O¬≤‚Åª ionic radius: 1.40 √Ö</li>
<li>Radius ratio: $0.605 / 1.40 = 0.432$</li>
<li><strong>Prediction</strong>: Coordination number 6 (octahedral structure)</li>
<li><strong>Reality</strong>: Rutile-type TiO‚ÇÇ indeed has Ti‚Å¥‚Å∫ in 6-fold coordination</li>
</ul>
</div>
<h3>Code Example 4: Generating Composition-Based Feature Vectors</h3>
<a class="colab-badge" href="https://colab.research.google.com/github/AI-Terakoya/composition-features-tutorial/blob/main/chapter1_example4.ipynb">Open in Google Colab</a>
<pre><code class="language-python"># Requirements:
# - Python 3.9+
# - pandas&gt;=2.0.0, &lt;2.2.0

"""
Example: Code Example 4: Generating Composition-Based Feature Vectors

Purpose: Demonstrate data manipulation and preprocessing
Target: Beginner to Intermediate
Execution time: 5-10 seconds
Dependencies: None
"""

# Generate feature vectors from composition using matminer
from matminer.featurizers.composition import ElementProperty
import pandas as pd

# Compound list
compounds = ["Fe2O3", "TiO2", "Al2O3", "SiO2", "CuO"]

# ElementProperty featurizer (simplified version, 3 statistics only)
featurizer = ElementProperty.from_preset("magpie")

# Create dataframe
df = pd.DataFrame({"composition": compounds})

# Generate features (may take some time)
df = featurizer.featurize_dataframe(df, col_id="composition")

# Display part of generated features
feature_cols = [col for col in df.columns if col != "composition"]
print(f"Number of generated features: {len(feature_cols)}")
print(f"\nFirst 5 features:")
print(df[feature_cols[:5]].head())

# Feature name examples
print(f"\nFeature name examples:")
for i, col in enumerate(feature_cols[:10]):
    print(f"  {i+1}. {col}")

# Example output:
# Number of generated features: 145
# Feature name examples:
#   1. MagpieData mean Number
#   2. MagpieData avg_dev Number
#   3. MagpieData range Number
#   ...</code></pre>
<h3>Code Example 5: Periodic Table Mapping (seaborn heatmap)</h3>
<a class="colab-badge" href="https://colab.research.google.com/github/AI-Terakoya/composition-features-tutorial/blob/main/chapter1_example5.ipynb">Open in Google Colab</a>
<pre><code class="language-python"># Requirements:
# - Python 3.9+
# - matplotlib&gt;=3.7.0
# - numpy&gt;=1.24.0, &lt;2.0.0
# - seaborn&gt;=0.12.0

"""
Example: Code Example 5: Periodic Table Mapping (seaborn heatmap)

Purpose: Demonstrate data visualization techniques
Target: Intermediate
Execution time: 2-5 seconds
Dependencies: None
"""

# Visualize periodic table with heatmap for specific elemental properties
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
from pymatgen.core import Element

# Part of periodic table (major elements)
periods = {
    2: ["Li", "Be", "B", "C", "N", "O", "F"],
    3: ["Na", "Mg", "Al", "Si", "P", "S", "Cl"],
    4: ["K", "Ca", "Sc", "Ti", "V", "Cr", "Mn", "Fe", "Co", "Ni", "Cu", "Zn"],
}

# Create heatmap data for electronegativity
max_cols = max(len(row) for row in periods.values())
heatmap_data = []
yticks = []

for period_num, elements in sorted(periods.items()):
    row = []
    for el_symbol in elements:
        el = Element(el_symbol)
        row.append(el.X if el.X is not None else 0)
    # Pad with zeros
    row.extend([0] * (max_cols - len(row)))
    heatmap_data.append(row)
    yticks.append(f"Period {period_num}")

# Draw heatmap
plt.figure(figsize=(14, 6))
sns.heatmap(heatmap_data, annot=False, cmap="RdYlBu_r",
            cbar_kws={'label': 'Electronegativity (Pauling)'},
            yticklabels=yticks)
plt.title("Periodic Table: Electronegativity Heatmap", fontsize=16, fontweight='bold')
plt.xlabel("Elements (left to right)", fontsize=12)
plt.ylabel("Period", fontsize=12)
plt.tight_layout()
plt.savefig('periodic_table_electronegativity.png', dpi=150, bbox_inches='tight')
plt.show()

print("Trends observable from the heatmap:")
print("- Top right (F, O, Cl) have high electronegativity (red)")
print("- Bottom left (Li, Na, K) have low electronegativity (blue)")
print("- Within the same group (vertical), decreases as you go down")</code></pre>
<h2 id="section-1-3">1.3 Success Cases of Composition-Based Prediction</h2>
<h3>OQMD/Materials Project Formation Energy Prediction (R¬≤ ‚â• 0.8)</h3>
<p>The most successful application of composition-based features is <strong>formation energy prediction</strong>. Ward et al. (2016) in the Magpie paper reported the following achievements:</p>
<table>
<thead>
<tr>
<th>Dataset</th>
<th>Sample Size</th>
<th>Model</th>
<th>R¬≤ Score</th>
<th>MAE</th>
</tr>
</thead>
<tbody>
<tr>
<td>OQMD (All compounds)</td>
<td>435,000</td>
<td>Random Forest</td>
<td>0.92</td>
<td>0.10 eV/atom</td>
</tr>
<tr>
<td>Materials Project</td>
<td>60,000</td>
<td>Gradient Boosting</td>
<td>0.89</td>
<td>0.12 eV/atom</td>
</tr>
<tr>
<td>OQMD (Oxides only)</td>
<td>50,000</td>
<td>Random Forest</td>
<td>0.94</td>
<td>0.08 eV/atom</td>
</tr>
</tbody>
</table>
<div class="highlight-box">
<h4>üìä What is Formation Energy?</h4>
<p>Formation energy is the energy change when a compound is formed from constituent elements in their standard states:</p>
<p>$$\Delta H_f = E_{\text{compound}} - \sum_i n_i E_{\text{element}_i}$$</p>
<ul>
<li><strong>Negative value</strong>: Compound is stable (spontaneously forms)</li>
<li><strong>Positive value</strong>: Compound is unstable (difficult to form)</li>
</ul>
<p>In materials discovery, compounds with negative formation energy and large absolute values are prioritized as easier to synthesize.</p>
</div>
<h3>Band Gap Prediction (MAE &lt; 0.5 eV)</h3>
<p>The <strong>band gap</strong>, important for semiconductor material design, can also be predicted with composition-based features:</p>
<table>
<thead>
<tr>
<th>Study</th>
<th>Dataset</th>
<th>Sample Size</th>
<th>MAE</th>
<th>R¬≤</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ward+ (2016)</td>
<td>Materials Project</td>
<td>10,000</td>
<td>0.45 eV</td>
<td>0.78</td>
</tr>
<tr>
<td>Jha+ (2018) ElemNet</td>
<td>OQMD</td>
<td>28,000</td>
<td>0.38 eV</td>
<td>0.83</td>
</tr>
<tr>
<td>Meredig+ (2014)</td>
<td>Experimental Data</td>
<td>1,200</td>
<td>0.62 eV</td>
<td>0.65</td>
</tr>
</tbody>
</table>
<p><strong>Caveat</strong>: Band gap is a property with <strong>strong structure dependence</strong>. In comparison with DFT calculated values, composition-based approaches have limitations, and GNN (structure-based) methods achieve higher accuracy (MAE &lt; 0.25 eV).</p>
<h3>Thermoelectric Property Prediction</h3>
<p>Successful prediction of the <strong>ZT value</strong>, a performance indicator for thermoelectric materials (converting heat to electricity):</p>
<ul>
<li><strong>Carrete et al. (2014)</strong>: ZT prediction for half-Heusler compounds (R¬≤ = 0.72)</li>
<li><strong>Feature importance</strong>:
                <ol>
<li>Mean atomic mass (affects thermal conductivity)</li>
<li>Variance of electronegativity (affects carrier mobility)</li>
<li>Mean valence electron count (affects electron concentration)</li>
</ol>
</li>
</ul>
<h3>Code Example 6: Composition Normalization Processing</h3>
<a class="colab-badge" href="https://colab.research.google.com/github/AI-Terakoya/composition-features-tutorial/blob/main/chapter1_example6.ipynb">Open in Google Colab</a>
<pre><code class="language-python"># Normalize composition formulas to per-atom basis
from pymatgen.core import Composition

# Various notations of composition formulas
formulas = ["Fe4O6", "Fe2O3", "Fe0.5O0.75", "FeO1.5"]

print("Composition Formula Normalization:")
for formula in formulas:
    comp = Composition(formula)
    reduced = comp.reduced_composition
    fractional = comp.fractional_composition

    print(f"\nOriginal formula: {formula}")
    print(f"  After reduction (integer ratio): {reduced}")
    print(f"  Per atom: {fractional}")
    print(f"  Total atoms: {comp.num_atoms:.2f}")
    print(f"  Fe/O ratio: {comp['Fe']/comp['O']:.3f}")

# Example output:
# Original formula: Fe4O6
#   After reduction (integer ratio): Fe2 O3
#   Per atom: Fe0.4 O0.6
#   Total atoms: 10.00
#   Fe/O ratio: 0.667</code></pre>
<h2 id="section-1-4">1.4 Why Composition-Based? Prediction Capability Without Structural Information</h2>
<h3>Advantages of High-Speed Screening</h3>
<p>The greatest advantage of composition-based features is <strong>computational speed</strong>. Comparison with structure-based (GNN) approaches:</p>
<table>
<thead>
<tr>
<th>Task</th>
<th>Composition-Based (Magpie + RF)</th>
<th>Structure-Based (CGCNN)</th>
<th>Speed Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Feature generation (1 compound)</td>
<td>0.001 seconds</td>
<td>0.1 seconds</td>
<td>100x faster</td>
</tr>
<tr>
<td>Inference (1 million compounds)</td>
<td>10 minutes</td>
<td>27 hours</td>
<td>162x faster</td>
</tr>
<tr>
<td>Model training (100k samples)</td>
<td>5 minutes</td>
<td>60 minutes</td>
<td>12x faster</td>
</tr>
</tbody>
</table>
<div class="highlight-box">
<h4>‚ö° Practical Example of High-Speed Screening</h4>
<p><strong>Scenario</strong>: From 1 million candidate compounds, find stable compounds with formation energy ‚â§ -2 eV/atom</p>
<ul>
<li><strong>Composition-based</strong>: Complete in 10 minutes ‚Üí Select 50,000 compounds ‚Üí Proceed to experimental validation</li>
<li><strong>Structure-based (GNN)</strong>: Takes 27 hours ‚Üí Not practical</li>
</ul>
<p><strong>Strategy</strong>: Narrow down candidates with composition-based approach, then precise prediction with GNN (hybrid approach)</p>
</div>
<h3>Application to Materials with Unknown Crystal Structure</h3>
<p>In new materials discovery, there are many cases where <strong>crystal structure is unknown</strong>:</p>
<ol>
<li><strong>Pre-synthesis candidate compounds</strong>: Composition can be determined, but structure is unknown
                <ul>
<li>Example: Composition search for Li-Ni-Mn-Co-O battery cathode materials</li>
<li>Narrow down candidates with composition-based ‚Üí Synthesize ‚Üí Structural analysis</li>
</ul>
</li>
<li><strong>Metastable phases</strong>: Structure prediction by DFT calculation is difficult
                <ul>
<li>Example: High-pressure synthesis materials, rapid quenching materials</li>
<li>Predict property trends from composition</li>
</ul>
</li>
<li><strong>Amorphous materials</strong>: No long-range order
                <ul>
<li>Example: Metallic glasses, oxide glasses</li>
<li>Composition is the only descriptor</li>
</ul>
</li>
</ol>
<h3>Compatibility with Experimental Data</h3>
<p>For experimental researchers, <strong>composition information is the most easily obtainable</strong> data:</p>
<table>
<thead>
<tr>
<th>Information Type</th>
<th>Experimental Acquisition Difficulty</th>
<th>Accuracy</th>
<th>Cost</th>
</tr>
</thead>
<tbody>
<tr>
<td>Chemical Composition</td>
<td>Low (EDX, ICP-MS)</td>
<td>High (¬±1%)</td>
<td>Low (few thousand yen/sample)</td>
</tr>
<tr>
<td>Crystal Structure</td>
<td>Medium (XRD, single crystal analysis)</td>
<td>Medium (Rietveld analysis required)</td>
<td>Medium (tens of thousands of yen/sample)</td>
</tr>
<tr>
<td>Atomic Coordinates (Precise)</td>
<td>High (Single crystal XRD, neutron diffraction)</td>
<td>High (√Ö precision)</td>
<td>High (hundreds of thousands of yen/sample)</td>
</tr>
</tbody>
</table>
<p><strong>Typical workflow for experimental data-driven materials discovery</strong>:</p>
<div class="mermaid">
graph LR
    A[Measure composition experimentally] --&gt; B[Generate composition-based features]
    B --&gt; C[Train machine learning model]
    C --&gt; D[Predict properties of new compositions]
    D --&gt; E[Experimental validation]
    E --&gt; F{Performance improved?}
    F --&gt;|Yes| G[Next-generation composition optimization]
    F --&gt;|No| C
    G --&gt; E
        </div>
<h3>Code Example 7: Feature Correlation Analysis (pandas, seaborn)</h3>
<a class="colab-badge" href="https://colab.research.google.com/github/AI-Terakoya/composition-features-tutorial/blob/main/chapter1_example7.ipynb">Open in Google Colab</a>
<pre><code class="language-python"># Requirements:
# - Python 3.9+
# - matplotlib&gt;=3.7.0
# - pandas&gt;=2.0.0, &lt;2.2.0
# - seaborn&gt;=0.12.0

"""
Example: Code Example 7: Feature Correlation Analysis (pandas, seabor

Purpose: Demonstrate data visualization techniques
Target: Intermediate
Execution time: 2-5 seconds
Dependencies: None
"""

# Analyze correlations between features and identify redundant features
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
from matminer.featurizers.composition import ElementProperty

# Sample data
compounds = ["Fe2O3", "TiO2", "Al2O3", "SiO2", "CuO", "ZnO", "MgO", "CaO"]
df = pd.DataFrame({"composition": compounds})

# Feature generation (simplified version, statistics only)
featurizer = ElementProperty(features=["Number", "AtomicWeight", "Row", "Column"],
                              stats=["mean", "std", "range"])
df = featurizer.featurize_dataframe(df, col_id="composition")

# Extract feature columns only
feature_cols = [col for col in df.columns if col != "composition"]

# Calculate correlation matrix
corr_matrix = df[feature_cols].corr()

# Draw heatmap
plt.figure(figsize=(12, 10))
sns.heatmap(corr_matrix, annot=True, fmt='.2f', cmap='coolwarm',
            center=0, square=True, linewidths=0.5,
            cbar_kws={"shrink": 0.8})
plt.title("Correlation Matrix of Composition-Based Features", fontsize=16, fontweight='bold')
plt.xticks(rotation=45, ha='right', fontsize=8)
plt.yticks(rotation=0, fontsize=8)
plt.tight_layout()
plt.savefig('feature_correlation.png', dpi=150, bbox_inches='tight')
plt.show()

# Detect highly correlated pairs (threshold: |r| &gt; 0.9)
high_corr_pairs = []
for i in range(len(corr_matrix.columns)):
    for j in range(i+1, len(corr_matrix.columns)):
        if abs(corr_matrix.iloc[i, j]) &gt; 0.9:
            high_corr_pairs.append((
                corr_matrix.columns[i],
                corr_matrix.columns[j],
                corr_matrix.iloc[i, j]
            ))

print("\nHighly correlated feature pairs (|r| &gt; 0.9):")
for feat1, feat2, corr_val in high_corr_pairs:
    print(f"  {feat1} ‚Üî {feat2}: r = {corr_val:.3f}")</code></pre>
<h3>Code Example 8: Simple Linear Regression Model Application (scikit-learn)</h3>
<a class="colab-badge" href="https://colab.research.google.com/github/AI-Terakoya/composition-features-tutorial/blob/main/chapter1_example8.ipynb">Open in Google Colab</a>
<pre><code class="language-python"># Requirements:
# - Python 3.9+
# - matplotlib&gt;=3.7.0
# - numpy&gt;=1.24.0, &lt;2.0.0
# - pandas&gt;=2.0.0, &lt;2.2.0

"""
Example: Code Example 8: Simple Linear Regression Model Application (

Purpose: Demonstrate data visualization techniques
Target: Intermediate
Execution time: 30-60 seconds
Dependencies: None
"""

# Predict formation energy with composition-based features (simulation data)
import numpy as np
import pandas as pd
from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_absolute_error, r2_score
from matminer.featurizers.composition import ElementProperty
import matplotlib.pyplot as plt

# Simulation data (in reality, obtained from Materials Project, etc.)
np.random.seed(42)
compounds = ["Fe2O3", "TiO2", "Al2O3", "SiO2", "CuO", "ZnO", "MgO", "CaO",
             "NiO", "CoO", "MnO", "V2O5", "Cr2O3", "SnO2", "In2O3", "Ga2O3"]
formation_energies = [-2.5, -3.1, -3.8, -2.9, -1.5, -1.8, -2.3, -2.7,
                      -1.4, -1.6, -1.9, -3.5, -2.8, -2.4, -2.1, -2.6]  # eV/atom (fictional values)

# Create dataframe
df = pd.DataFrame({"composition": compounds, "formation_energy": formation_energies})

# Generate features
featurizer = ElementProperty.from_preset("magpie")
df = featurizer.featurize_dataframe(df, col_id="composition")

# Separate features and target
feature_cols = [col for col in df.columns if col not in ["composition", "formation_energy"]]
X = df[feature_cols].values
y = df["formation_energy"].values

# Train/test split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

# Linear regression model
model = LinearRegression()
model.fit(X_train, y_train)

# Prediction
y_pred = model.predict(X_test)

# Evaluation
mae = mean_absolute_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)

print(f"Model Performance:")
print(f"  MAE: {mae:.3f} eV/atom")
print(f"  R¬≤: {r2:.3f}")

# Plot prediction vs actual
plt.figure(figsize=(8, 6))
plt.scatter(y_test, y_pred, color='#f5576c', s=100, alpha=0.7, edgecolors='black')
plt.plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()],
         'k--', lw=2, label='Perfect Prediction')
plt.xlabel('Actual Value (eV/atom)', fontsize=12)
plt.ylabel('Predicted Value (eV/atom)', fontsize=12)
plt.title(f'Formation Energy Prediction (Linear Regression)\nMAE={mae:.3f}, R¬≤={r2:.3f}',
          fontsize=14, fontweight='bold')
plt.legend()
plt.grid(alpha=0.3)
plt.tight_layout()
plt.savefig('linear_regression_prediction.png', dpi=150, bbox_inches='tight')
plt.show()

# Top 5 important features
feature_importance = pd.DataFrame({
    'feature': feature_cols,
    'coefficient': np.abs(model.coef_)
}).sort_values('coefficient', ascending=False)

print("\nTop 5 Important Features:")
print(feature_importance.head())</code></pre>
<h2 id="exercises">Exercises</h2>
<h3>Easy (Fundamental Level)</h3>
<details>
<summary>Exercise 1-1: Chemical Formula Analysis</summary>
<p><strong>Problem</strong>: Using pymatgen, extract the following from the chemical formula "Li3Fe2(PO4)3":</p>
<ol>
<li>Element types and counts</li>
<li>Total number of atoms</li>
<li>Total weight (g/mol)</li>
<li>Composition ratio (atomic fraction) for each element</li>
</ol>
<p><strong>Sample Solution</strong>:</p>
<pre><code class="language-python">from pymatgen.core import Composition

comp = Composition("Li3Fe2(PO4)3")

# 1. Element types and counts
print("Elements and counts:")
for el, count in comp.get_el_amt_dict().items():
    print(f"  {el}: {count} atoms")

# 2. Total atoms
print(f"\nTotal atoms: {comp.num_atoms}")

# 3. Total weight
print(f"Total weight: {comp.weight:.2f} g/mol")

# 4. Composition ratios
print("\nComposition ratios (atomic fractions):")
for el, frac in comp.get_atomic_fraction().items():
    print(f"  {el}: {frac:.4f}")

# Output:
# Elements and counts:
#   Li: 3 atoms
#   Fe: 2 atoms
#   P: 3 atoms
#   O: 12 atoms
# Total atoms: 20.0
# Total weight: 397.48 g/mol
# Composition ratios:
#   Li: 0.1500
#   Fe: 0.1000
#   P: 0.1500
#   O: 0.6000</code></pre>
</details>
<details>
<summary>Exercise 1-2: Basic Statistics Calculation</summary>
<p><strong>Problem</strong>: Calculate the mean, standard deviation, and range of atomic radius for the chemical formula "NaCl" (weighted by composition ratio).</p>
<p><strong>Hint</strong>: Na atomic radius=1.86√Ö, Cl atomic radius=1.75√Ö, composition ratio is 1:1</p>
<p><strong>Sample Solution</strong>:</p>
<pre><code class="language-python"># Requirements:
# - Python 3.9+
# - numpy&gt;=1.24.0, &lt;2.0.0

"""
Example: Sample Solution:

Purpose: Demonstrate core concepts and implementation patterns
Target: Beginner to Intermediate
Execution time: 10-30 seconds
Dependencies: None
"""

import numpy as np
from pymatgen.core import Composition, Element

comp = Composition("NaCl")
fractions = comp.get_atomic_fraction()

# Atomic radius data
radii = []
weights = []
for el, frac in fractions.items():
    radii.append(Element(el).atomic_radius)
    weights.append(frac)

radii = np.array(radii)
weights = np.array(weights)

# Calculate statistics
mean = np.sum(weights * radii)
variance = np.sum(weights * (radii - mean)**2)
std = np.sqrt(variance)
range_val = radii.max() - radii.min()

print(f"Atomic Radius Statistics for NaCl:")
print(f"  Mean: {mean:.4f} √Ö")
print(f"  Standard Deviation: {std:.4f} √Ö")
print(f"  Range: {range_val:.4f} √Ö")

# Output:
# Atomic Radius Statistics for NaCl:
#   Mean: 1.8050 √Ö
#   Standard Deviation: 0.0550 √Ö
#   Range: 0.1100 √Ö</code></pre>
</details>
<details>
<summary>Exercise 1-3: Element Count</summary>
<p><strong>Problem</strong>: Count the number of element types in the following chemical formulas:</p>
<ul>
<li>Fe2O3</li>
<li>CaTiO3</li>
<li>Li(Ni0.8Co0.15Al0.05)O2</li>
</ul>
<p><strong>Sample Solution</strong>:</p>
<pre><code class="language-python">from pymatgen.core import Composition

formulas = ["Fe2O3", "CaTiO3", "Li(Ni0.8Co0.15Al0.05)O2"]

for formula in formulas:
    comp = Composition(formula)
    num_elements = len(comp.elements)
    print(f"{formula}: {num_elements} element types")
    print(f"  Elements: {[el.symbol for el in comp.elements]}\n")

# Output:
# Fe2O3: 2 element types
#   Elements: ['Fe', 'O']
# CaTiO3: 3 element types
#   Elements: ['Ca', 'Ti', 'O']
# Li(Ni0.8Co0.15Al0.05)O2: 5 element types
#   Elements: ['Li', 'Ni', 'Co', 'Al', 'O']</code></pre>
</details>
<h3>Medium (Intermediate Level)</h3>
<details>
<summary>Exercise 1-4: Feature Generation with matminer</summary>
<p><strong>Problem</strong>: Using matminer's ElementProperty featurizer, generate features for the following compounds:</p>
<ul>
<li>Compounds: ["BaTiO3", "SrTiO3", "PbTiO3"]</li>
<li>Elemental properties: Number, AtomicWeight, Row</li>
<li>Statistics: mean, std, range</li>
</ul>
<p>Display the number of generated features and the first 3 features.</p>
<p><strong>Sample Solution</strong>:</p>
<pre><code class="language-python"># Requirements:
# - Python 3.9+
# - pandas&gt;=2.0.0, &lt;2.2.0

"""
Example: Sample Solution:

Purpose: Demonstrate data manipulation and preprocessing
Target: Beginner to Intermediate
Execution time: ~5 seconds
Dependencies: None
"""

import pandas as pd
from matminer.featurizers.composition import ElementProperty

# Data preparation
compounds = ["BaTiO3", "SrTiO3", "PbTiO3"]
df = pd.DataFrame({"composition": compounds})

# Featurizer setup
featurizer = ElementProperty(features=["Number", "AtomicWeight", "Row"],
                              stats=["mean", "std", "range"])

# Feature generation
df = featurizer.featurize_dataframe(df, col_id="composition")

# Display results
feature_cols = [col for col in df.columns if col != "composition"]
print(f"Number of generated features: {len(feature_cols)}")
print(f"\nFirst 3 features:")
print(df[feature_cols[:3]])

# Example output:
# Number of generated features: 9
# First 3 features:
#    mean Number  std Number  range Number
# 0    30.4      23.35         48.0
# 1    29.2      22.41         46.0
# 2    41.4      27.93         74.0</code></pre>
</details>
<details>
<summary>Exercise 1-5: Periodic Table Visualization</summary>
<p><strong>Problem</strong>: Visualize ionization energy for the following element groups using bar charts:</p>
<ul>
<li>Alkali metals: Li, Na, K, Rb, Cs</li>
<li>Halogens: F, Cl, Br, I</li>
</ul>
<p>Display both groups side by side for comparison.</p>
<p><strong>Sample Solution</strong>:</p>
<pre><code class="language-python"># Requirements:
# - Python 3.9+
# - matplotlib&gt;=3.7.0

"""
Example: Sample Solution:

Purpose: Demonstrate data visualization techniques
Target: Beginner to Intermediate
Execution time: 2-5 seconds
Dependencies: None
"""

import matplotlib.pyplot as plt
from pymatgen.core import Element

# Element groups
alkali = ["Li", "Na", "K", "Rb", "Cs"]
halogens = ["F", "Cl", "Br", "I"]

# Get ionization energies
alkali_ie = [Element(el).ionization_energy for el in alkali]
halogen_ie = [Element(el).ionization_energy for el in halogens]

# Visualization
fig, axes = plt.subplots(1, 2, figsize=(14, 5))

axes[0].bar(alkali, alkali_ie, color='#f093fb', edgecolor='black')
axes[0].set_ylabel('Ionization Energy (eV)', fontsize=12)
axes[0].set_title('Ionization Energy of Alkali Metals', fontsize=14, fontweight='bold')
axes[0].grid(axis='y', alpha=0.3)

axes[1].bar(halogens, halogen_ie, color='#f5576c', edgecolor='black')
axes[1].set_ylabel('Ionization Energy (eV)', fontsize=12)
axes[1].set_title('Ionization Energy of Halogens', fontsize=14, fontweight='bold')
axes[1].grid(axis='y', alpha=0.3)

plt.tight_layout()
plt.savefig('ionization_energy_comparison.png', dpi=150, bbox_inches='tight')
plt.show()

print("Observations:")
print("- Alkali metals: Decreases with increasing period (K &lt; Na &lt; Li)")
print("- Halogens: F is maximum, I is minimum")</code></pre>
</details>
<details>
<summary>Exercise 1-6: Correlation Analysis</summary>
<p><strong>Problem</strong>: Calculate correlation coefficients between the following elemental property pairs:</p>
<ul>
<li>Atomic radius vs Ionization energy</li>
<li>Electronegativity vs Ionization energy</li>
</ul>
<p>Target elements: Period 2 elements (Li, Be, B, C, N, O, F)</p>
<p><strong>Sample Solution</strong>:</p>
<pre><code class="language-python"># Requirements:
# - Python 3.9+
# - matplotlib&gt;=3.7.0
# - numpy&gt;=1.24.0, &lt;2.0.0

"""
Example: Sample Solution:

Purpose: Demonstrate data visualization techniques
Target: Beginner to Intermediate
Execution time: 2-5 seconds
Dependencies: None
"""

import numpy as np
from pymatgen.core import Element
import matplotlib.pyplot as plt

# Period 2 elements
elements = ["Li", "Be", "B", "C", "N", "O", "F"]

# Extract data
atomic_radius = []
ionization_energy = []
electronegativity = []

for el_symbol in elements:
    el = Element(el_symbol)
    atomic_radius.append(el.atomic_radius)
    ionization_energy.append(el.ionization_energy)
    electronegativity.append(el.X)

# Convert to NumPy arrays
ar = np.array(atomic_radius)
ie = np.array(ionization_energy)
en = np.array(electronegativity)

# Calculate correlation coefficients
corr_ar_ie = np.corrcoef(ar, ie)[0, 1]
corr_en_ie = np.corrcoef(en, ie)[0, 1]

print(f"Correlation coefficients:")
print(f"  Atomic radius vs Ionization energy: {corr_ar_ie:.3f}")
print(f"  Electronegativity vs Ionization energy: {corr_en_ie:.3f}")

# Scatter plots
fig, axes = plt.subplots(1, 2, figsize=(14, 5))

axes[0].scatter(ar, ie, s=100, color='#f093fb', edgecolors='black')
for i, el in enumerate(elements):
    axes[0].annotate(el, (ar[i], ie[i]), fontsize=12, ha='right')
axes[0].set_xlabel('Atomic Radius (√Ö)', fontsize=12)
axes[0].set_ylabel('Ionization Energy (eV)', fontsize=12)
axes[0].set_title(f'Correlation: {corr_ar_ie:.3f}', fontsize=14, fontweight='bold')
axes[0].grid(alpha=0.3)

axes[1].scatter(en, ie, s=100, color='#f5576c', edgecolors='black')
for i, el in enumerate(elements):
    axes[1].annotate(el, (en[i], ie[i]), fontsize=12, ha='right')
axes[1].set_xlabel('Electronegativity (Pauling)', fontsize=12)
axes[1].set_ylabel('Ionization Energy (eV)', fontsize=12)
axes[1].set_title(f'Correlation: {corr_en_ie:.3f}', fontsize=14, fontweight='bold')
axes[1].grid(alpha=0.3)

plt.tight_layout()
plt.savefig('correlation_analysis.png', dpi=150, bbox_inches='tight')
plt.show()

# Example output:
# Correlation coefficients:
#   Atomic radius vs Ionization energy: -0.985 (strong negative correlation)
#   Electronegativity vs Ionization energy: 0.992 (strong positive correlation)</code></pre>
</details>
<details>
<summary>Exercise 1-7: Simple Model Application</summary>
<p><strong>Problem</strong>: Train a linear regression model with the following fictional data to predict band gaps:</p>
<pre>
Compounds: ["MgO", "CaO", "SrO", "BaO", "ZnO", "CdO"]
Band gaps (eV): [7.8, 6.9, 5.9, 4.2, 3.4, 2.3]
            </pre>
<p>Evaluate MAE and R¬≤ with train/test split (80/20).</p>
<p><strong>Sample Solution</strong>:</p>
<pre><code class="language-python"># Requirements:
# - Python 3.9+
# - pandas&gt;=2.0.0, &lt;2.2.0

"""
Example: Sample Solution:

Purpose: Demonstrate machine learning model training and evaluation
Target: Beginner to Intermediate
Execution time: 30-60 seconds
Dependencies: None
"""

import pandas as pd
from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_absolute_error, r2_score
from matminer.featurizers.composition import ElementProperty

# Data preparation
compounds = ["MgO", "CaO", "SrO", "BaO", "ZnO", "CdO"]
bandgaps = [7.8, 6.9, 5.9, 4.2, 3.4, 2.3]

df = pd.DataFrame({"composition": compounds, "bandgap": bandgaps})

# Feature generation
featurizer = ElementProperty.from_preset("magpie")
df = featurizer.featurize_dataframe(df, col_id="composition")

# Separate features and target
feature_cols = [col for col in df.columns if col not in ["composition", "bandgap"]]
X = df[feature_cols].values
y = df["bandgap"].values

# Train/test split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Linear regression
model = LinearRegression()
model.fit(X_train, y_train)
y_pred = model.predict(X_test)

# Evaluation
mae = mean_absolute_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)

print(f"Model Performance:")
print(f"  MAE: {mae:.3f} eV")
print(f"  R¬≤: {r2:.3f}")
print(f"\nTest data predictions:")
for i, (true_val, pred_val) in enumerate(zip(y_test, y_pred)):
    print(f"  Actual: {true_val:.1f} eV, Predicted: {pred_val:.1f} eV")</code></pre>
</details>
<h3>Hard (Advanced Level)</h3>
<details>
<summary>Exercise 1-8: Feature Design for Multicomponent Materials</summary>
<p><strong>Problem</strong>: For the high-entropy alloy (HEA) "CoCrFeNiMn" (equimolar ratio), calculate the following:</p>
<ol>
<li>Mean, standard deviation, and range of atomic radius</li>
<li>Mean, standard deviation, and range of electronegativity</li>
<li>Mean, standard deviation, and range of valence electron count</li>
</ol>
<p>Visualize these statistics and discuss implications for HEA design.</p>
<p><strong>Sample Solution</strong>:</p>
<pre><code class="language-python"># Requirements:
# - Python 3.9+
# - matplotlib&gt;=3.7.0
# - numpy&gt;=1.24.0, &lt;2.0.0
# - pandas&gt;=2.0.0, &lt;2.2.0

"""
Example: Sample Solution:

Purpose: Demonstrate data visualization techniques
Target: Intermediate
Execution time: 1-5 minutes
Dependencies: None
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from pymatgen.core import Composition, Element

# High-entropy alloy (equimolar ratio)
comp = Composition("CoCrFeNiMn")
fractions = comp.get_atomic_fraction()

# Extract elemental properties
properties = {
    'atomic_radius': [],
    'X': [],  # Electronegativity
    'nvalence': []  # Valence electrons
}

for el in comp.elements:
    properties['atomic_radius'].append(Element(el).atomic_radius)
    properties['X'].append(Element(el).X)
    properties['nvalence'].append(Element(el).nvalence)

# Calculate statistics
stats_results = {}
for prop_name, values in properties.items():
    values = np.array(values)
    stats_results[prop_name] = {
        'mean': values.mean(),
        'std': values.std(),
        'range': values.max() - values.min()
    }

# Display results
print("Elemental Property Statistics for CoCrFeNiMn:\n")
for prop_name, stats in stats_results.items():
    print(f"{prop_name}:")
    for stat_name, value in stats.items():
        print(f"  {stat_name}: {value:.4f}")
    print()

# Visualization
fig, axes = plt.subplots(1, 3, figsize=(18, 5))
prop_labels = ['Atomic Radius (√Ö)', 'Electronegativity', 'Valence Electrons']

for ax, (prop_name, prop_label) in zip(axes, zip(properties.keys(), prop_labels)):
    values = properties[prop_name]
    stats = stats_results[prop_name]

    ax.bar(['Co', 'Cr', 'Fe', 'Ni', 'Mn'], values,
           color=['#f093fb', '#f5576c', '#feca57', '#48dbfb', '#00d2d3'],
           edgecolor='black')
    ax.axhline(stats['mean'], color='red', linestyle='--', linewidth=2, label='Mean')
    ax.set_ylabel(prop_label, fontsize=12)
    ax.set_title(f'{prop_label}\nMean={stats["mean"]:.3f}, Std={stats["std"]:.3f}',
                 fontsize=14, fontweight='bold')
    ax.legend()
    ax.grid(axis='y', alpha=0.3)

plt.tight_layout()
plt.savefig('hea_feature_analysis.png', dpi=150, bbox_inches='tight')
plt.show()

# Implications for HEA design
print("Implications for HEA design:")
print("- Small standard deviation in atomic radius ‚Üí Low lattice strain ‚Üí High phase stability")
print("- Small standard deviation in electronegativity ‚Üí Uniform chemical affinity ‚Üí Easy solid solution formation")
print("- Appropriate mean valence electron count ‚Üí Affects metallic bond strength")</code></pre>
</details>
<details>
<summary>Exercise 1-9: Cross-Validation</summary>
<p><strong>Problem</strong>: Using the data from Exercise 1-7, evaluate model generalization performance with 5-fold cross-validation. Display MAE and R¬≤ for each fold, and report mean ¬± standard deviation.</p>
<p><strong>Sample Solution</strong>:</p>
<pre><code class="language-python"># Requirements:
# - Python 3.9+
# - numpy&gt;=1.24.0, &lt;2.0.0
# - pandas&gt;=2.0.0, &lt;2.2.0

"""
Example: Sample Solution:

Purpose: Demonstrate data manipulation and preprocessing
Target: Beginner to Intermediate
Execution time: 10-30 seconds
Dependencies: None
"""

import pandas as pd
import numpy as np
from sklearn.linear_model import LinearRegression
from sklearn.model_selection import cross_val_score, KFold
from matminer.featurizers.composition import ElementProperty

# Data preparation
compounds = ["MgO", "CaO", "SrO", "BaO", "ZnO", "CdO"]
bandgaps = [7.8, 6.9, 5.9, 4.2, 3.4, 2.3]
df = pd.DataFrame({"composition": compounds, "bandgap": bandgaps})

# Feature generation
featurizer = ElementProperty.from_preset("magpie")
df = featurizer.featurize_dataframe(df, col_id="composition")

# Features and target
feature_cols = [col for col in df.columns if col not in ["composition", "bandgap"]]
X = df[feature_cols].values
y = df["bandgap"].values

# 5-fold cross-validation
kfold = KFold(n_splits=5, shuffle=True, random_state=42)
model = LinearRegression()

# MAE evaluation
mae_scores = -cross_val_score(model, X, y, cv=kfold,
                               scoring='neg_mean_absolute_error')

# R¬≤ evaluation
r2_scores = cross_val_score(model, X, y, cv=kfold, scoring='r2')

# Display results
print("5-fold Cross-Validation Results:\n")
print("MAE for each fold (eV):")
for i, mae in enumerate(mae_scores):
    print(f"  Fold {i+1}: {mae:.3f}")
print(f"Mean MAE: {mae_scores.mean():.3f} ¬± {mae_scores.std():.3f}\n")

print("R¬≤ for each fold:")
for i, r2 in enumerate(r2_scores):
    print(f"  Fold {i+1}: {r2:.3f}")
print(f"Mean R¬≤: {r2_scores.mean():.3f} ¬± {r2_scores.std():.3f}")</code></pre>
</details>
<details>
<summary>Exercise 1-10: Model Evaluation (Comprehensive Problem)</summary>
<p><strong>Problem</strong>: Build a formation energy prediction model using composition-based features with the following fictional OQMD data:</p>
<pre>
Compounds: ["Li2O", "Na2O", "K2O", "MgO", "CaO", "SrO", "Al2O3", "Ga2O3", "In2O3", "TiO2"]
Formation energies (eV/atom): [-2.9, -2.6, -2.3, -3.0, -3.2, -3.1, -3.5, -2.8, -2.5, -4.1]
            </pre>
<ol>
<li>Generate features (Magpie preset)</li>
<li>Train/test split (70/30)</li>
<li>Train with Random Forest model (n_estimators=100)</li>
<li>Evaluate on test set: MAE, RMSE, R¬≤</li>
<li>Display top 5 feature importances</li>
</ol>
<p><strong>Sample Solution</strong>:</p>
<pre><code class="language-python"># Requirements:
# - Python 3.9+
# - matplotlib&gt;=3.7.0
# - numpy&gt;=1.24.0, &lt;2.0.0
# - pandas&gt;=2.0.0, &lt;2.2.0

"""
Example: Sample Solution:

Purpose: Demonstrate data visualization techniques
Target: Advanced
Execution time: 30-60 seconds
Dependencies: None
"""

import pandas as pd
import numpy as np
from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score
from matminer.featurizers.composition import ElementProperty
import matplotlib.pyplot as plt

# Data preparation
compounds = ["Li2O", "Na2O", "K2O", "MgO", "CaO", "SrO",
             "Al2O3", "Ga2O3", "In2O3", "TiO2"]
formation_energies = [-2.9, -2.6, -2.3, -3.0, -3.2, -3.1,
                      -3.5, -2.8, -2.5, -4.1]

df = pd.DataFrame({"composition": compounds, "formation_energy": formation_energies})

# Feature generation
featurizer = ElementProperty.from_preset("magpie")
df = featurizer.featurize_dataframe(df, col_id="composition")

# Features and target
feature_cols = [col for col in df.columns if col not in ["composition", "formation_energy"]]
X = df[feature_cols].values
y = df["formation_energy"].values

# Train/test split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

# Random Forest model
model = RandomForestRegressor(n_estimators=100, random_state=42)
model.fit(X_train, y_train)
y_pred = model.predict(X_test)

# Evaluation metrics
mae = mean_absolute_error(y_test, y_pred)
rmse = np.sqrt(mean_squared_error(y_test, y_pred))
r2 = r2_score(y_test, y_pred)

print("Model Evaluation Results:")
print(f"  MAE: {mae:.3f} eV/atom")
print(f"  RMSE: {rmse:.3f} eV/atom")
print(f"  R¬≤: {r2:.3f}\n")

# Top 5 feature importances
feature_importance = pd.DataFrame({
    'feature': feature_cols,
    'importance': model.feature_importances_
}).sort_values('importance', ascending=False)

print("Top 5 Feature Importances:")
print(feature_importance.head())

# Prediction vs actual plot
plt.figure(figsize=(8, 6))
plt.scatter(y_test, y_pred, s=100, color='#f5576c', alpha=0.7, edgecolors='black')
plt.plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()],
         'k--', lw=2, label='Perfect Prediction')
plt.xlabel('Actual Value (eV/atom)', fontsize=12)
plt.ylabel('Predicted Value (eV/atom)', fontsize=12)
plt.title(f'Formation Energy Prediction (Random Forest)\nMAE={mae:.3f}, R¬≤={r2:.3f}',
          fontsize=14, fontweight='bold')
plt.legend()
plt.grid(alpha=0.3)
plt.tight_layout()
plt.savefig('rf_prediction.png', dpi=150, bbox_inches='tight')
plt.show()</code></pre>
</details>
<h2 id="summary">Summary</h2>
<p>In this chapter, we learned the fundamentals of <strong>composition-based features</strong>:</p>
<ul>
<li>‚úÖ Principles of converting chemical composition to numerical vectors</li>
<li>‚úÖ Types of elemental properties (atomic radius, ionization energy, electronegativity, etc.)</li>
<li>‚úÖ Statistical aggregation methods (mean, variance, max/min, range)</li>
<li>‚úÖ Implementation with pymatgen/matminer</li>
<li>‚úÖ Success stories (OQMD formation energy prediction, band gap prediction)</li>
<li>‚úÖ Prediction capabilities without structural information and advantages of high-speed screening</li>
</ul>
<div class="highlight-box">
<h4>üéì Learning Objectives Achievement Check</h4>
<p>Can you answer the following questions?</p>
<ul>
<li>Can you explain what composition-based features are in 3 sentences?</li>
<li>Can you manually calculate atomic radius statistics for Fe‚ÇÇO‚ÇÉ?</li>
<li>Can you determine whether composition-based or GNN is appropriate?</li>
<li>Can you generate a 145-dimensional vector from a chemical formula using matminer?</li>
</ul>
<p><strong>If all are Yes</strong>, proceed to Chapter 2 (Magpie Details)!</p>
</div>
<h2 id="references">References</h2>
<ol>
<li>Ward, L., Agrawal, A., Choudhary, A., &amp; Wolverton, C. (2016). "A general-purpose machine learning framework for predicting properties of inorganic materials." <em>npj Computational Materials</em>, 2, 16028. <a href="https://doi.org/10.1038/npjcompumats.2016.28">https://doi.org/10.1038/npjcompumats.2016.28</a> (Original Magpie descriptor paper, pp. 1-7)</li>
<li>Jha, D., Ward, L., Paul, A., Liao, W., Choudhary, A., Wolverton, C., &amp; Agrawal, A. (2018). "ElemNet: Deep Learning the Chemistry of Materials From Only Elemental Composition." <em>Scientific Reports</em>, 8, 17593. <a href="https://doi.org/10.1038/s41598-018-35934-y">https://doi.org/10.1038/s41598-018-35934-y</a> (High-accuracy prediction from composition only, pp. 1-13)</li>
<li>Ong, S.P., Richards, W.D., Jain, A., Hautier, G., Kocher, M., Cholia, S., Gunter, D., Chevrier, V.L., Persson, K.A., &amp; Ceder, G. (2013). "Python Materials Genomics (pymatgen): A robust, open-source python library for materials analysis." <em>Computational Materials Science</em>, 68, 314-319. <a href="https://doi.org/10.1016/j.commatsci.2012.10.028">https://doi.org/10.1016/j.commatsci.2012.10.028</a> (Pymatgen library foundation, pp. 314-319)</li>
<li>Ward, L., Dunn, A., Faghaninia, A., Zimmermann, N.E.R., Bajaj, S., Wang, Q., Montoya, J., Chen, J., Bystrom, K., Dylla, M., Chard, K., Asta, M., Persson, K.A., Snyder, G.J., Foster, I., &amp; Jain, A. (2018). "Matminer: An open source toolkit for materials data mining." <em>Computational Materials Science</em>, 152, 60-69. <a href="https://doi.org/10.1016/j.commatsci.2018.05.018">https://doi.org/10.1016/j.commatsci.2018.05.018</a> (Original matminer paper, feature generation toolkit, pp. 60-69)</li>
<li>Meredig, B., Agrawal, A., Kirklin, S., Saal, J.E., Doak, J.W., Thompson, A., Zhang, K., Choudhary, A., &amp; Wolverton, C. (2014). "Combinatorial screening for new materials in unconstrained composition space with machine learning." <em>Physical Review B</em>, 89(9), 094104. <a href="https://doi.org/10.1103/PhysRevB.89.094104">https://doi.org/10.1103/PhysRevB.89.094104</a> (Empirical study on composition space exploration, pp. 1-7)</li>
<li>Himanen, L., J√§ger, M.O.J., Morooka, E.V., Federici Canova, F., Ranawat, Y.S., Gao, D.Z., Rinke, P., &amp; Foster, A.S. (2019). "DScribe: Library of descriptors for machine learning in materials science." <em>Computer Physics Communications</em>, 247, 106949. <a href="https://doi.org/10.1016/j.cpc.2019.106949">https://doi.org/10.1016/j.cpc.2019.106949</a> (Comprehensive review of descriptor libraries, pp. 1-15)</li>
<li>Materials Project Documentation: matminer module. <a href="https://docs.materialsproject.org/">https://docs.materialsproject.org/</a> (Official matminer documentation and usage examples)</li>
</ol>
<div class="nav-buttons">
<a class="nav-button" href="./index.html">‚Üê Series Contents</a>
<a class="nav-button" href="chapter-2.html">Chapter 2: Magpie and Statistical Descriptors ‚Üí</a>
</div>
<section class="disclaimer">
<h3>Disclaimer</h3>
<ul>
<li>This content is provided solely for educational, research, and informational purposes and does not constitute professional advice (legal, accounting, technical warranty, etc.).</li>
<li>This content and accompanying code examples are provided "AS IS" without any warranty, express or implied, including but not limited to merchantability, fitness for a particular purpose, non-infringement, accuracy, completeness, operation, or safety.</li>
<li>The author and Tohoku University assume no responsibility for the content, availability, or safety of external links, third-party data, tools, libraries, etc.</li>
<li>To the maximum extent permitted by applicable law, the author and Tohoku University shall not be liable for any direct, indirect, incidental, special, consequential, or punitive damages arising from the use, execution, or interpretation of this content.</li>
<li>The content may be changed, updated, or discontinued without notice.</li>
<li>The copyright and license of this content are subject to the stated conditions (e.g., CC BY 4.0). Such licenses typically include no-warranty clauses.</li>
</ul>
</section>

</main>
<footer>
<div class="container">
<p>¬© 2025 AI Terakoya - Dr. Yusuke Hashimoto, Tohoku University</p>
<p>This content is provided for educational purposes. For commercial use, please contact the author.</p>
<p>Licensed under CC BY 4.0</p>
</div>
</footer>
<!-- Prism.js for syntax highlighting -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
</body>
</html>