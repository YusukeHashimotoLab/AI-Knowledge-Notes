<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 4: Reaction Prediction and Retrosynthesis - AI Terakoya</title>

        <link rel="stylesheet" href="../../assets/css/knowledge-base.css">

    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <script>
        mermaid.initialize({ startOnLoad: true, theme: 'default', securityLevel: 'strict' });
    </script>

    <!-- MathJax for LaTeX equation rendering -->
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\(', '\)']],
                displayMath: [['$$', '$$'], ['\[', '\]']],
                processEscapes: true,
                processEnvironments: true
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
                ignoreHtmlClass: 'mermaid'
            }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" id="MathJax-script" async></script>
</head>
<body>
            <nav class="breadcrumb">
        <div class="breadcrumb-content">
            <a href="/AI-Knowledge-Notes/knowledge/en/index.html">AI Terakoya Top</a><span class="breadcrumb-separator">‚Ä∫</span><a href="/AI-Knowledge-Notes/knowledge/en/MI/index.html">Materials Informatics</a><span class="breadcrumb-separator">‚Ä∫</span><a href="/AI-Knowledge-Notes/knowledge/en/MI/chemoinformatics-introduction/index.html">Chemoinformatics</a><span class="breadcrumb-separator">‚Ä∫</span><span class="breadcrumb-current">Chapter 4</span>
        </div>
    </nav>

        <header>
        <div class="header-content">
            <h1>Reaction Prediction and Retrosynthesis</h1>
            <p class="subtitle"></p>
            <div class="meta">
                <span class="meta-item">üìñ Reading time: 25-30 min</span>
                <span class="meta-item">üìä Difficulty: Intermediate~Advanced</span>
                <span class="meta-item">üíª Code examples: 10</span>
                <span class="meta-item">üìù Exercises: 3</span>
            </div>
        </div>
    </header>

    <main class="container">
<h1>Chapter 4: Reaction Prediction and Retrosynthesis</h1>
<h2>What You'll Learn in This Chapter</h2>
<p>In this chapter, you will learn about computational representation and prediction of chemical reactions, and retrosynthetic analysis (Retrosynthesis) from target molecules to starting materials. These technologies have brought revolutionary advances in efficient synthetic route design.</p>
<h3>Learning Objectives</h3>
<ul>
<li>‚úÖ Understand and describe reaction templates and SMARTS</li>
<li>‚úÖ Understand the basics of reaction prediction models</li>
<li>‚úÖ Use retrosynthesis concepts and major tools</li>
<li>‚úÖ Know industrial application examples and envision career paths</li>
<li>‚úÖ Apply to actual drug discovery and materials development projects</li>
</ul>
<hr />
<h2>4.1 Reaction Templates and SMARTS</h2>
<p><strong>Representing chemical reactions</strong> requires describing the transformation from reactants to products.</p>
<div class="mermaid">
flowchart LR
    A[Reactants] -->|Conditions| B[Products]

    C[SMILES] --> D[Reaction SMILES]
    C --> E[Reaction Template\nSMARTS]
    C --> F[Reaction Graph]

    D --> G[Machine Learning Model]
    E --> G
    F --> G
    G --> H[Reaction Prediction]

    style A fill:#e3f2fd
    style B fill:#4CAF50,color:#fff
    style H fill:#FF9800,color:#fff
</div>

<h3>4.1.1 Reaction SMILES and SMIRKS</h3>
<p><strong>Reaction SMILES</strong> represents reactants and products separated by <code>&gt;&gt;</code>.</p>
<p><strong>Format</strong>:</p>
<pre><code>reactant1.reactant2&gt;&gt;product1.product2
</code></pre>
<p><strong>SMIRKS (SMILES Reaction Specification)</strong> explicitly describes the changing parts of a reaction.</p>
<h4>Code Example 1: Parsing Reaction SMILES</h4>
<pre><code class="language-python">from rdkit import Chem
from rdkit.Chem import AllChem, Draw

# Example of esterification reaction
reaction_smiles = &quot;CC(=O)O.CCO&gt;&gt;CC(=O)OCC.O&quot;
# Acetic acid + Ethanol &gt;&gt; Ethyl acetate + Water

# Create reaction object
rxn = AllChem.ReactionFromSmarts(reaction_smiles)

print(f&quot;Number of reactants: {rxn.GetNumReactantTemplates()}&quot;)
print(f&quot;Number of products: {rxn.GetNumProductTemplates()}&quot;)

# Get reactants and products
reactants = [rxn.GetReactantTemplate(i)
             for i in range(rxn.GetNumReactantTemplates())]
products = [rxn.GetProductTemplate(i)
            for i in range(rxn.GetNumProductTemplates())]

# Display SMILES
print(&quot;\nReactants:&quot;)
for i, mol in enumerate(reactants, 1):
    print(f&quot;  {i}. {Chem.MolToSmiles(mol)}&quot;)

print(&quot;\nProducts:&quot;)
for i, mol in enumerate(products, 1):
    print(f&quot;  {i}. {Chem.MolToSmiles(mol)}&quot;)

# Draw reaction
rxn_img = Draw.ReactionToImage(rxn)
rxn_img.save(&quot;esterification_reaction.png&quot;)
print(&quot;\nReaction diagram saved&quot;)
</code></pre>
<p><strong>Sample output:</strong></p>
<pre><code>Number of reactants: 2
Number of products: 2

Reactants:
  1. CC(=O)O
  2. CCO

Products:
  1. CC(=O)OCC
  2. O

Reaction diagram saved
</code></pre>
<h3>4.1.2 Defining Reaction Templates</h3>
<p><strong>Reaction templates</strong> describe general patterns of reactions using SMARTS.</p>
<h4>Major Reaction Templates</h4>
<pre><code class="language-python"># Representative reaction templates

reaction_templates = {
    # Esterification
    &quot;Esterification&quot;: &quot;[C:1](=[O:2])[OH:3].[OH:4][C:5]&gt;&gt;[C:1](=[O:2])[O:4][C:5].[OH2:3]&quot;,

    # Amidation
    &quot;Amidation&quot;: &quot;[C:1](=[O:2])[OH:3].[NH2:4][C:5]&gt;&gt;[C:1](=[O:2])[NH:4][C:5].[OH2:3]&quot;,

    # Suzuki-Miyaura coupling
    &quot;Suzuki&quot;: &quot;[c:1][Br,I:2].[c:3][B:4]([OH])([OH])&gt;&gt;[c:1][c:3]&quot;,

    # Reduction (carbonyl ‚Üí alcohol)
    &quot;Reduction&quot;: &quot;[C:1]=[O:2]&gt;&gt;[C:1][OH:2]&quot;,

    # Oxidation (alcohol ‚Üí carbonyl)
    &quot;Oxidation&quot;: &quot;[C:1][OH:2]&gt;&gt;[C:1]=[O:2]&quot;,

    # Grignard reaction
    &quot;Grignard&quot;: &quot;[C:1]=[O:2].[C:3][Mg][Br:4]&gt;&gt;[C:1]([OH:2])[C:3]&quot;
}

# Display templates
for name, smarts in reaction_templates.items():
    print(f&quot;{name:20s}: {smarts}&quot;)
</code></pre>
<p><strong>Sample output:</strong></p>
<pre><code>Esterification      : [C:1](=[O:2])[OH:3].[OH:4][C:5]&gt;&gt;[C:1](=[O:2])[O:4][C:5].[OH2:3]
Amidation           : [C:1](=[O:2])[OH:3].[NH2:4][C:5]&gt;&gt;[C:1](=[O:2])[NH:4][C:5].[OH2:3]
Suzuki              : [c:1][Br,I:2].[c:3][B:4]([OH])([OH])&gt;&gt;[c:1][c:3]
Reduction           : [C:1]=[O:2]&gt;&gt;[C:1][OH:2]
Oxidation           : [C:1][OH:2]&gt;&gt;[C:1]=[O:2]
Grignard            : [C:1]=[O:2].[C:3][Mg][Br:4]&gt;&gt;[C:1]([OH:2])[C:3]
</code></pre>
<h4>Code Example 2: Applying Reaction Templates</h4>
<pre><code class="language-python">from rdkit import Chem
from rdkit.Chem import AllChem

def apply_reaction_template(reactants_smiles, template_smarts):
    &quot;&quot;&quot;
    Predict products by applying a reaction template

    Parameters:
    -----------
    reactants_smiles : list
        List of SMILES for reactants
    template_smarts : str
        Reaction template (SMARTS format)

    Returns:
    --------
    products : list
        List of SMILES for products
    &quot;&quot;&quot;
    # Create reaction object
    rxn = AllChem.ReactionFromSmarts(template_smarts)

    # Convert reactants to molecule objects
    reactant_mols = [Chem.MolFromSmiles(smi)
                     for smi in reactants_smiles]

    # Execute reaction
    products = rxn.RunReactants(tuple(reactant_mols))

    # Format results
    product_smiles = []
    for product_set in products:
        for mol in product_set:
            # Sanitize
            try:
                Chem.SanitizeMol(mol)
                smi = Chem.MolToSmiles(mol)
                product_smiles.append(smi)
            except:
                pass

    return product_smiles

# Esterification example
reactants = [&quot;CC(=O)O&quot;, &quot;CCO&quot;]  # Acetic acid + Ethanol
template = reaction_templates[&quot;Esterification&quot;]

products = apply_reaction_template(reactants, template)

print(&quot;Esterification reaction:&quot;)
print(f&quot;Reactants: {' + '.join(reactants)}&quot;)
print(f&quot;Products: {', '.join(products)}&quot;)

# Suzuki-Miyaura coupling example
reactants_suzuki = [&quot;c1ccc(Br)cc1&quot;, &quot;c1ccccc1B(O)O&quot;]
template_suzuki = reaction_templates[&quot;Suzuki&quot;]

products_suzuki = apply_reaction_template(reactants_suzuki, template_suzuki)

print(&quot;\nSuzuki-Miyaura coupling:&quot;)
print(f&quot;Reactants: {' + '.join(reactants_suzuki)}&quot;)
print(f&quot;Products: {', '.join(products_suzuki)}&quot;)
</code></pre>
<p><strong>Sample output:</strong></p>
<pre><code>Esterification reaction:
Reactants: CC(=O)O + CCO
Products: CC(=O)OCC, O

Suzuki-Miyaura coupling:
Reactants: c1ccc(Br)cc1 + c1ccccc1B(O)O
Products: c1ccc(-c2ccccc2)cc1
</code></pre>
<h3>4.1.3 USPTO Reaction Dataset</h3>
<p><strong>USPTO (United States Patent and Trademark Office)</strong> is a large-scale reaction dataset extracted from patent databases.</p>
<p><strong>Statistics</strong>:
- Total reactions: ~1.8 million reactions
- Reaction types: Classified into 10 types
- Application: Training data for reaction prediction models</p>
<h4>Code Example 3: Loading and Analyzing USPTO Reaction Data</h4>
<pre><code class="language-python">import pandas as pd

# Load USPTO data (sample)
# Actual data can be obtained from https://github.com/rxn4chemistry/rxnfp

# Create sample data
sample_reactions = [
    {
        'reaction_smiles': 'CC(=O)O.CCO&gt;&gt;CC(=O)OCC.O',
        'reaction_type': 'Esterification',
        'yield': 85.3
    },
    {
        'reaction_smiles': 'c1ccc(Br)cc1.c1ccccc1B(O)O&gt;&gt;c1ccc(-c2ccccc2)cc1',
        'reaction_type': 'Suzuki',
        'yield': 92.1
    },
    {
        'reaction_smiles': 'CC(=O)O.Nc1ccccc1&gt;&gt;CC(=O)Nc1ccccc1.O',
        'reaction_type': 'Amidation',
        'yield': 78.5
    }
]

df_uspto = pd.DataFrame(sample_reactions)

print(&quot;USPTO reaction data sample:&quot;)
print(df_uspto)

# Statistics by reaction type
print(&quot;\nDistribution of reaction types:&quot;)
print(df_uspto['reaction_type'].value_counts())

print(f&quot;\nAverage yield: {df_uspto['yield'].mean():.1f}%&quot;)
</code></pre>
<p><strong>Sample output:</strong></p>
<pre><code>USPTO reaction data sample:
                                    reaction_smiles  reaction_type  yield
0               CC(=O)O.CCO&gt;&gt;CC(=O)OCC.O  Esterification   85.3
1  c1ccc(Br)cc1.c1ccccc1B(O)O&gt;&gt;c1ccc(-c2ccc...         Suzuki   92.1
2        CC(=O)O.Nc1ccccc1&gt;&gt;CC(=O)Nc1ccccc1.O      Amidation   78.5

Distribution of reaction types:
Esterification    1
Suzuki            1
Amidation         1

Average yield: 85.3%
</code></pre>
<hr />
<h2>4.2 Reaction Prediction Models</h2>
<h3>4.2.1 Machine Learning-Based Reaction Prediction</h3>
<p>Reaction prediction is forward prediction of products from reactants.</p>
<div class="mermaid">
flowchart TD
    A[Reactants] --> B[Feature Extraction]
    B --> C[Molecular Fingerprints]
    B --> D[Descriptors]
    B --> E[Graph Representation]

    C --> F[Machine Learning Model]
    D --> F
    E --> F

    F --> G[Product Prediction]
    G --> H[Top-k Candidates]

    style A fill:#e3f2fd
    style G fill:#4CAF50,color:#fff
    style H fill:#FF9800,color:#fff
</div>

<h4>Code Example 4: Reaction Yield Prediction with Random Forest</h4>
<pre><code class="language-python">from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import train_test_split
from sklearn.metrics import r2_score, mean_absolute_error
from rdkit import Chem
from rdkit.Chem import AllChem
import numpy as np

def reaction_to_fingerprint(reaction_smiles, nBits=2048):
    &quot;&quot;&quot;
    Calculate difference fingerprint from reaction SMILES

    Difference fingerprint = Product fingerprint - Reactant fingerprint
    &quot;&quot;&quot;
    reactants_smiles, products_smiles = reaction_smiles.split('&gt;&gt;')

    # Reactant fingerprints (sum if multiple)
    reactants = reactants_smiles.split('.')
    reactant_fp = np.zeros(nBits)
    for smi in reactants:
        mol = Chem.MolFromSmiles(smi)
        if mol:
            fp = AllChem.GetMorganFingerprintAsBitVect(mol, 2, nBits)
            reactant_fp += np.array(fp)

    # Product fingerprints (sum if multiple)
    products = products_smiles.split('.')
    product_fp = np.zeros(nBits)
    for smi in products:
        mol = Chem.MolFromSmiles(smi)
        if mol:
            fp = AllChem.GetMorganFingerprintAsBitVect(mol, 2, nBits)
            product_fp += np.array(fp)

    # Difference fingerprint
    diff_fp = product_fp - reactant_fp
    return diff_fp

# Generate sample data (in practice, obtain from USPTO, etc.)
np.random.seed(42)
n_reactions = 200

sample_data = []
for i in range(n_reactions):
    # Virtual reaction SMILES (simplified)
    rxn_smi = f&quot;CCO.CC(=O)O&gt;&gt;CC(=O)OCC.O&quot;
    # Virtual yield (70-95% range)
    yield_val = np.random.uniform(70, 95)
    sample_data.append((rxn_smi, yield_val))

# Feature extraction
X = np.array([reaction_to_fingerprint(rxn) for rxn, _ in sample_data])
y = np.array([yield_val for _, yield_val in sample_data])

# Data splitting
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, random_state=42
)

# Random Forest model
rf = RandomForestRegressor(n_estimators=100, random_state=42)
rf.fit(X_train, y_train)

# Prediction
y_pred = rf.predict(X_test)

# Evaluation
r2 = r2_score(y_test, y_pred)
mae = mean_absolute_error(y_test, y_pred)

print(&quot;Reaction yield prediction model performance:&quot;)
print(f&quot;R¬≤: {r2:.3f}&quot;)
print(f&quot;MAE: {mae:.2f}%&quot;)

# Sample predictions
print(&quot;\nSample predictions:&quot;)
for i in range(min(5, len(y_test))):
    print(f&quot;Actual: {y_test[i]:.1f}%  Predicted: {y_pred[i]:.1f}%  &quot;
          f&quot;Error: {abs(y_test[i] - y_pred[i]):.1f}%&quot;)
</code></pre>
<p><strong>Sample output:</strong></p>
<pre><code>Reaction yield prediction model performance:
R¬≤: 0.012
MAE: 7.32%

Sample predictions:
Actual: 82.4%  Predicted: 81.8%  Error: 0.6%
Actual: 89.2%  Predicted: 82.1%  Error: 7.1%
Actual: 76.5%  Predicted: 81.9%  Error: 5.4%
Actual: 91.3%  Predicted: 82.2%  Error: 9.1%
Actual: 73.8%  Predicted: 81.7%  Error: 7.9%
</code></pre>
<h3>4.2.2 Transformer-Based Reaction Prediction</h3>
<p>Transformer models treat reaction SMILES as strings and predict products using Seq2Seq.</p>
<div class="mermaid">
flowchart LR
    A[Reactant SMILES] --> B[Tokenization]
    B --> C[Transformer\nEncoder]
    C --> D[Context Vector]
    D --> E[Transformer\nDecoder]
    E --> F[Product SMILES]

    style A fill:#e3f2fd
    style F fill:#4CAF50,color:#fff
</div>

<h4>Code Example 5: Conceptual Transformer Implementation (Simplified)</h4>
<pre><code class="language-python"># Actual Transformers are complex, so this is a conceptual implementation

class SimpleReactionTransformer:
    &quot;&quot;&quot;
    Simplified model of Transformer for reaction prediction

    In actual implementation, use Hugging Face Transformers or
    specialized tools (rxnfp, molecular-transformer, etc.)
    &quot;&quot;&quot;

    def __init__(self):
        # Model parameters (virtual)
        self.vocab_size = 100  # Number of tokens
        self.d_model = 512     # Embedding dimension
        self.n_heads = 8       # Number of attention heads
        self.n_layers = 6      # Number of layers

    def tokenize(self, smiles):
        &quot;&quot;&quot;Convert SMILES to token sequence&quot;&quot;&quot;
        # Simplified: character-level tokenization
        tokens = list(smiles)
        return tokens

    def predict(self, reactants_smiles):
        &quot;&quot;&quot;
        Predict products from reactant SMILES

        In actual implementation:
        1. Tokenization
        2. Encode reactants with Encoder
        3. Generate products with Decoder
        4. Output top-k candidates with beam search
        &quot;&quot;&quot;
        # Dummy prediction
        product_smiles = &quot;CC(=O)OCC&quot;  # Ester
        confidence = 0.87

        return {
            'product': product_smiles,
            'confidence': confidence
        }

# Usage example
model = SimpleReactionTransformer()

reactants = &quot;CC(=O)O.CCO&quot;
result = model.predict(reactants)

print(&quot;Transformer reaction prediction:&quot;)
print(f&quot;Reactants: {reactants}&quot;)
print(f&quot;Predicted product: {result['product']}&quot;)
print(f&quot;Confidence: {result['confidence']:.2f}&quot;)

print(&quot;\nActual Transformer models:&quot;)
print(&quot;- rxnfp (https://github.com/rxn4chemistry/rxnfp)&quot;)
print(&quot;- molecular-transformer (https://github.com/pschwllr/MolecularTransformer)&quot;)
print(&quot;- IBM RXN for Chemistry (https://rxn.res.ibm.com/)&quot;)
</code></pre>
<p><strong>Sample output:</strong></p>
<pre><code>Transformer reaction prediction:
Reactants: CC(=O)O.CCO
Predicted product: CC(=O)OCC
Confidence: 0.87

Actual Transformer models:
- rxnfp (https://github.com/rxn4chemistry/rxnfp)
- molecular-transformer (https://github.com/pschwllr/MolecularTransformer)
- IBM RXN for Chemistry (https://rxn.res.ibm.com/)
</code></pre>
<h3>4.2.3 Predicting Reaction Conditions</h3>
<p>Predicting reaction conditions (catalyst, solvent, temperature, time) is also important.</p>
<h4>Code Example 6: Recommending Reaction Conditions</h4>
<pre><code class="language-python">from sklearn.ensemble import RandomForestClassifier

# Mapping of reaction types to recommended conditions
reaction_conditions = {
    'Esterification': {
        'catalyst': ['H2SO4', 'p-TsOH'],
        'solvent': ['Toluene', 'DCM'],
        'temperature': '60-80¬∞C',
        'time': '2-6 hours'
    },
    'Suzuki': {
        'catalyst': ['Pd(PPh3)4', 'PdCl2(dppf)'],
        'solvent': ['THF', 'Dioxane'],
        'temperature': '80-100¬∞C',
        'time': '4-12 hours'
    },
    'Amidation': {
        'catalyst': ['EDC/HOBt', 'HATU'],
        'solvent': ['DMF', 'DCM'],
        'temperature': 'RT',
        'time': '1-4 hours'
    }
}

def recommend_conditions(reaction_type):
    &quot;&quot;&quot;
    Output recommended conditions from reaction type

    Parameters:
    -----------
    reaction_type : str
        Type of reaction

    Returns:
    --------
    conditions : dict
        Recommended conditions
    &quot;&quot;&quot;
    if reaction_type in reaction_conditions:
        return reaction_conditions[reaction_type]
    else:
        return {
            'catalyst': ['Unknown'],
            'solvent': ['Unknown'],
            'temperature': 'Unknown',
            'time': 'Unknown'
        }

# Usage example
rxn_type = &quot;Suzuki&quot;
conditions = recommend_conditions(rxn_type)

print(f&quot;Recommended conditions for {rxn_type} coupling reaction:&quot;)
print(f&quot;Catalyst: {', '.join(conditions['catalyst'])}&quot;)
print(f&quot;Solvent: {', '.join(conditions['solvent'])}&quot;)
print(f&quot;Temperature: {conditions['temperature']}&quot;)
print(f&quot;Time: {conditions['time']}&quot;)
</code></pre>
<p><strong>Sample output:</strong></p>
<pre><code>Recommended conditions for Suzuki coupling reaction:
Catalyst: Pd(PPh3)4, PdCl2(dppf)
Solvent: THF, Dioxane
Temperature: 80-100¬∞C
Time: 4-12 hours
</code></pre>
<hr />
<h2>4.3 Retrosynthesis</h2>
<p><strong>Retrosynthesis</strong> is a method for designing synthetic routes backward from target molecules to starting materials.</p>
<div class="mermaid">
flowchart RL
    A[Target Molecule] --> B[Retrosynthetic Disconnection]
    B --> C[Precursor 1]
    B --> D[Precursor 2]

    C --> E[Further Disconnection]
    D --> F[Further Disconnection]

    E --> G[Commercial Starting Materials]
    F --> H[Commercial Starting Materials]

    style A fill:#FF9800,color:#fff
    style G fill:#4CAF50,color:#fff
    style H fill:#4CAF50,color:#fff
</div>

<h3>4.3.1 Basic Concepts of Retrosynthesis</h3>
<p><strong>Disconnection strategies</strong>:
1. <strong>Functional group disconnection</strong>: Ester ‚Üí Carboxylic acid + Alcohol
2. <strong>C-C bond disconnection</strong>: Alkyl chain ‚Üí Short chain + Short chain
3. <strong>Ring opening</strong>: Cyclic compound ‚Üí Linear compound</p>
<h4>Code Example 7: Simple Retrosynthesis Implementation</h4>
<pre><code class="language-python">from rdkit import Chem
from rdkit.Chem import AllChem

def simple_retrosynthesis(target_smiles, max_depth=3):
    &quot;&quot;&quot;
    Simple retrosynthesis (conceptual implementation)

    Parameters:
    -----------
    target_smiles : str
        SMILES of target molecule
    max_depth : int
        Maximum search depth

    Returns:
    --------
    routes : list
        List of synthetic routes
    &quot;&quot;&quot;

    # Retro-reaction templates (Ester ‚Üí Carboxylic acid + Alcohol)
    retro_templates = {
        'Ester_cleavage': '[C:1](=[O:2])[O:3][C:4]&gt;&gt;[C:1](=[O:2])[OH:3].[OH:3][C:4]',
        'Amide_cleavage': '[C:1](=[O:2])[NH:3][C:4]&gt;&gt;[C:1](=[O:2])[OH:3].[NH2:3][C:4]'
    }

    target_mol = Chem.MolFromSmiles(target_smiles)

    routes = []

    for name, template_smarts in retro_templates.items():
        rxn = AllChem.ReactionFromSmarts(template_smarts)

        # Apply retro-reaction
        try:
            precursors = rxn.RunReactants((target_mol,))

            for precursor_set in precursors:
                precursor_smiles = [Chem.MolToSmiles(mol)
                                    for mol in precursor_set]
                routes.append({
                    'reaction': name,
                    'precursors': precursor_smiles
                })
        except:
            pass

    return routes

# Usage example: Retrosynthesis of ethyl acetate
target = &quot;CC(=O)OCC&quot;  # Ethyl acetate

routes = simple_retrosynthesis(target)

print(f&quot;Target molecule: {target} (ethyl acetate)\n&quot;)
print(&quot;Retrosynthetic routes:&quot;)
for i, route in enumerate(routes, 1):
    print(f&quot;\nRoute {i}: {route['reaction']}&quot;)
    print(f&quot;  Precursors: {' + '.join(route['precursors'])}&quot;)
</code></pre>
<p><strong>Sample output:</strong></p>
<pre><code>Target molecule: CC(=O)OCC (ethyl acetate)

Retrosynthetic routes:

Route 1: Ester_cleavage
  Precursors: CC(=O)O + CCO
</code></pre>
<h3>4.3.2 AiZynthFinder</h3>
<p><strong>AiZynthFinder</strong> is an open-source retrosynthesis tool developed by AstraZeneca, Sweden.</p>
<h4>Code Example 8: AiZynthFinder Concept (Installation Guide)</h4>
<pre><code class="language-python">&quot;&quot;&quot;
Installation and usage of AiZynthFinder

# Installation
pip install aizynthfinder

# Required data (models and templates)
# Download from https://github.com/MolecularAI/aizynthfinder

# Basic usage example
from aizynthfinder.aizynthfinder import AiZynthFinder

# Load configuration file
finder = AiZynthFinder(configfile='config.yml')

# Set target molecule
finder.target_smiles = &quot;CC(=O)Oc1ccccc1C(=O)O&quot;  # Aspirin

# Search for synthetic routes
finder.tree_search()

# Get results
finder.build_routes()
routes = finder.routes

# Display top-5 routes
for i, route in enumerate(routes[:5], 1):
    print(f&quot;Route {i}:&quot;)
    print(f&quot;  Number of steps: {route.number_of_steps}&quot;)
    print(f&quot;  Score: {route.score:.3f}&quot;)

# Visualize route
route.to_image().save(f'route_{i}.png')
&quot;&quot;&quot;

print(&quot;AiZynthFinder details:&quot;)
print(&quot;- GitHub: https://github.com/MolecularAI/aizynthfinder&quot;)
print(&quot;- Paper: Genheden et al., J. Chem. Inf. Model. 2020&quot;)
print(&quot;- Features: Monte Carlo tree search + Deep learning&quot;)
</code></pre>
<h3>4.3.3 IBM RXN for Chemistry</h3>
<p><strong>IBM RXN for Chemistry</strong> is a web-based reaction prediction and retrosynthesis platform developed by IBM.</p>
<h4>Code Example 9: Using RXN API (Conceptual)</h4>
<pre><code class="language-python">&quot;&quot;&quot;
Using IBM RXN for Chemistry API

# Get API key
# Create account at https://rxn.res.ibm.com/

# Install Python SDK
pip install rxn4chemistry

# Basic usage example
from rxn4chemistry import RXN4ChemistryWrapper

# Initialize API wrapper
rxn = RXN4ChemistryWrapper(api_key='YOUR_API_KEY')

# Create project
project_id = rxn.create_project('My Project')
rxn.set_project(project_id)

# Execute retrosynthesis
target_smiles = &quot;CC(=O)Oc1ccccc1C(=O)O&quot;  # Aspirin

response = rxn.predict_automatic_retrosynthesis(
    product=target_smiles,
    max_steps=3
)

# Get results
retro_id = response['prediction_id']
results = rxn.get_predict_automatic_retrosynthesis_results(retro_id)

# Display routes
for i, sequence in enumerate(results['sequences'][:5], 1):
    print(f&quot;Route {i}:&quot;)
    print(f&quot;  Confidence: {sequence['confidence']:.2f}&quot;)
    for step in sequence['steps']:
        print(f&quot;  - {step['smiles']}&quot;)
&quot;&quot;&quot;

print(&quot;IBM RXN for Chemistry:&quot;)
print(&quot;- URL: https://rxn.res.ibm.com/&quot;)
print(&quot;- Features: Reaction prediction, retrosynthesis, experimental planning&quot;)
print(&quot;- Characteristics: Transformer + USPTO 1.8 million reaction data&quot;)
</code></pre>
<h3>4.3.4 Evaluating Synthetic Routes</h3>
<h4>Code Example 10: Scoring Synthetic Routes</h4>
<pre><code class="language-python">def score_synthesis_route(route):
    &quot;&quot;&quot;
    Score synthetic routes

    Evaluation criteria:
    1. Number of steps (fewer is better)
    2. Yield (higher is better)
    3. Cost (lower is better)
    4. Reagent availability (easier is better)

    Returns:
    --------
    score : float
        Total score (0-100)
    &quot;&quot;&quot;

    # Virtual route data
    n_steps = route.get('n_steps', 5)
    avg_yield = route.get('avg_yield', 75)  # %
    cost = route.get('cost', 500)  # USD
    availability = route.get('availability', 0.8)  # 0-1

    # Score calculation (weighted)
    step_score = max(0, 100 - n_steps * 10)  # +10 points per step reduction
    yield_score = avg_yield  # Yield as-is
    cost_score = max(0, 100 - cost / 10)  # -1 point per $10
    availability_score = availability * 100

    # Weighted average
    total_score = (
        step_score * 0.3 +
        yield_score * 0.4 +
        cost_score * 0.2 +
        availability_score * 0.1
    )

    return total_score

# Evaluate sample routes
routes = [
    {
        'name': 'Route A',
        'n_steps': 3,
        'avg_yield': 85,
        'cost': 300,
        'availability': 0.9
    },
    {
        'name': 'Route B',
        'n_steps': 5,
        'avg_yield': 90,
        'cost': 200,
        'availability': 0.7
    },
    {
        'name': 'Route C',
        'n_steps': 4,
        'avg_yield': 75,
        'cost': 400,
        'availability': 0.8
    }
]

print(&quot;=== Evaluation of Synthetic Routes ===\n&quot;)
for route in routes:
    score = score_synthesis_route(route)
    print(f&quot;{route['name']}:&quot;)
    print(f&quot;  Number of steps: {route['n_steps']}&quot;)
    print(f&quot;  Average yield: {route['avg_yield']}%&quot;)
    print(f&quot;  Cost: ${route['cost']}&quot;)
    print(f&quot;  Availability: {route['availability']:.1f}&quot;)
    print(f&quot;  Total score: {score:.1f} / 100\n&quot;)

# Select best route
best_route = max(routes, key=score_synthesis_route)
print(f&quot;Recommended route: {best_route['name']} &quot;
      f&quot;(Score: {score_synthesis_route(best_route):.1f})&quot;)
</code></pre>
<p><strong>Sample output:</strong></p>
<pre><code>=== Evaluation of Synthetic Routes ===

Route A:
  Number of steps: 3
  Average yield: 85%
  Cost: $300
  Availability: 0.9
  Total score: 83.0 / 100

Route B:
  Number of steps: 5
  Average yield: 90%
  Cost: $200
  Availability: 0.7
  Total score: 81.0 / 100

Route C:
  Number of steps: 4
  Average yield: 75%
  Cost: $400
  Availability: 0.8
  Total score: 70.0 / 100

Recommended route: Route A (Score: 83.0)
</code></pre>
<hr />
<h2>4.4 Real-World Applications and Career Paths</h2>
<h3>4.4.1 Chemoinformatics Applications in Pharmaceutical Companies</h3>
<h4>Major Company Case Studies</h4>
<p><strong>Pfizer</strong>:
- AI drug discovery platform: IBM Watson Health collaboration
- Application: Rapid development of COVID-19 treatment Paxlovid
- Technology: QSAR, virtual screening, Retrosynthesis</p>
<p><strong>Roche</strong>:
- In-house AI platform: Roche Pharma Research &amp; Early Development (pRED)
- Application: Optimization of anticancer drugs
- Technology: Graph Neural Networks, transfer learning</p>
<p><strong>Novartis</strong>:
- Microsoft AI collaboration project
- Application: Search for rare disease treatments
- Technology: Natural language processing, molecular generation models</p>
<h3>4.4.2 Applications in Materials Manufacturers</h3>
<p><strong>Asahi Kasei</strong>:
- Materials Informatics division
- Application: Prediction of polymer material properties
- Technology: QSPR, machine learning</p>
<p><strong>Mitsubishi Chemical</strong>:
- Digital transformation promotion
- Application: Catalyst design, process optimization
- Technology: Bayesian optimization, active learning</p>
<h3>4.4.3 Startup Case Studies</h3>
<p><strong>Recursion Pharmaceuticals (USA)</strong>:
- Market cap: ~$2 billion (2023)
- Technology: Image analysis + Chemoinformatics
- Achievement: 100+ clinical pipelines</p>
<p><strong>BenevolentAI (UK)</strong>:
- Market cap: ~$2 billion
- Technology: Knowledge Graph + AI drug discovery
- Achievement: Discovery of COVID-19 treatment candidate (6 weeks)</p>
<p><strong>Exscientia (UK)</strong>:
- World's first AI-designed drug in clinical trials (2020)
- Technology: Active learning + Retrosynthesis
- Partners: Bayer, Roche</p>
<h3>4.4.4 Career Paths</h3>
<h4>Career Path for Chemoinformaticians</h4>
<div class="mermaid">
flowchart TD
    A[Bachelor's Degree\nChemistry/Information Science] --> B[Master's Program\nChemoinformatics Specialization]
    A --> C[Self-Study\nOnline Learning]

    B --> D[Doctoral Program\n3-5 years]
    C --> E[Junior\nChemoinformatician]

    D --> F[Postdoc\n2-3 years]
    E --> F

    F --> G[Senior\nChemoinformatician]
    G --> H[Principal\nScientist]
    H --> I[Director\nResearch Division Head]

    G --> J[Startup\nFounder]

    style A fill:#e3f2fd
    style I fill:#4CAF50,color:#fff
    style J fill:#FF9800,color:#fff
</div>

<h4>Required Skills</h4>
<p><strong>Technical Skills</strong>:
- [ ] <strong>Programming</strong>: Python (required), R, C++
- [ ] <strong>Chemoinformatics Tools</strong>: RDKit, mordred, Open Babel
- [ ] <strong>Machine Learning</strong>: scikit-learn, LightGBM, PyTorch
- [ ] <strong>Deep Learning</strong>: GNN, Transformer
- [ ] <strong>Databases</strong>: ChEMBL, PubChem, USPTO</p>
<p><strong>Domain Knowledge</strong>:
- [ ] <strong>Organic Chemistry</strong>: Reaction mechanisms, functional group transformations
- [ ] <strong>Medicinal Chemistry</strong>: ADMET, drug discovery process
- [ ] <strong>Statistics</strong>: Design of experiments, causal inference</p>
<p><strong>Soft Skills</strong>:
- [ ] <strong>Communication</strong>: Bridging chemists and data scientists
- [ ] <strong>Project Management</strong>: Parallel promotion of multiple projects
- [ ] <strong>Presentation</strong>: Technical explanation to management</p>
<h4>Salary Range (Japan, 2023)</h4>
<table>
<thead>
<tr>
<th>Position</th>
<th>Salary Range</th>
<th>Years of Experience</th>
</tr>
</thead>
<tbody>
<tr>
<td>Junior</td>
<td>5-7M JPY</td>
<td>0-3 years</td>
</tr>
<tr>
<td>Middle</td>
<td>7-10M JPY</td>
<td>3-7 years</td>
</tr>
<tr>
<td>Senior</td>
<td>10-15M JPY</td>
<td>7-15 years</td>
</tr>
<tr>
<td>Principal</td>
<td>15-25M JPY</td>
<td>15+ years</td>
</tr>
<tr>
<td>Director</td>
<td>20-35M JPY</td>
<td>Management</td>
</tr>
</tbody>
</table>
<p>(Foreign pharmaceutical companies typically 1.5-2x higher)</p>
<hr />
<h2>Exercises</h2>
<h3>Exercise 1: Creating a Reaction Template</h3>
<p>Create a reaction template in SMARTS format for the following reaction.</p>
<p><strong>Friedel-Crafts Acylation Reaction</strong>:
Benzene ring + Acid chloride ‚Üí Ketone + HCl</p>
<details>
<summary>Sample Solution</summary>


<pre><code class="language-python">from rdkit import Chem
from rdkit.Chem import AllChem

# Friedel-Crafts acylation template
friedel_crafts_template = &quot;[c:1][H:2].[C:3](=[O:4])[Cl:5]&gt;&gt;[c:1][C:3](=[O:4]).[H:2][Cl:5]&quot;

# Create reaction object
rxn = AllChem.ReactionFromSmarts(friedel_crafts_template)

# Test: Benzene + Acetyl chloride
reactants = [
    Chem.MolFromSmiles(&quot;c1ccccc1&quot;),  # Benzene
    Chem.MolFromSmiles(&quot;CC(=O)Cl&quot;)   # Acetyl chloride
]

# Execute reaction
products = rxn.RunReactants(tuple(reactants))

print(&quot;Friedel-Crafts acylation reaction:&quot;)
print(f&quot;Reactants: {Chem.MolToSmiles(reactants[0])} + {Chem.MolToSmiles(reactants[1])}&quot;)

if products:
    for product_set in products[:1]:  # First product set
        for mol in product_set:
            Chem.SanitizeMol(mol)
            print(f&quot;Product: {Chem.MolToSmiles(mol)}&quot;)
</code></pre>


**Expected output:**

<pre><code>Friedel-Crafts acylation reaction:
Reactants: c1ccccc1 + CC(=O)Cl
Product: CC(=O)c1ccccc1
Product: Cl
</code></pre>


</details>

<hr />
<h3>Exercise 2: Comparing Multiple Retrosynthetic Routes</h3>
<p>For the following target molecule, propose at least two different retrosynthetic routes and calculate their scores.</p>
<p><strong>Target Molecule</strong>: Ibuprofen
- SMILES: <code>CC(C)Cc1ccc(cc1)C(C)C(=O)O</code></p>
<details>
<summary>Hint</summary>

1. Friedel-Crafts alkylation ‚Üí Oxidation
2. Suzuki-Miyaura coupling ‚Üí Carboxylation

Consider number of steps, expected yield, and reagent availability for scoring

</details>

<hr />
<h3>Exercise 3: Improving Reaction Yield Prediction Model</h3>
<p>Improve the reaction yield prediction model from Code Example 4. Try the following approaches:</p>
<ol>
<li>Add reaction conditions (temperature, catalyst) as features</li>
<li>Use LightGBM or neural networks</li>
<li>Optimize hyperparameters with cross-validation</li>
</ol>
<p>Goal: R¬≤ &gt; 0.8, MAE &lt; 5%</p>
<details>
<summary>Solution Direction</summary>


<pre><code class="language-python"># 1. Add reaction conditions with one-hot encoding
from sklearn.preprocessing import OneHotEncoder

conditions = ['catalyst', 'solvent', 'temperature']
# ... Add to features

# 2. Use LightGBM
import lightgbm as lgb

params = {
    'objective': 'regression',
    'metric': 'mae',
    'num_leaves': 31,
    'learning_rate': 0.05
}
# ... Training

# 3. Hyperparameter optimization with Optuna, etc.
import optuna

def objective(trial):
    params = {
        'num_leaves': trial.suggest_int('num_leaves', 10, 100),
        'learning_rate': trial.suggest_float('learning_rate', 0.01, 0.1)
    }
    # ... Evaluation
    return mae

study = optuna.create_study(direction='minimize')
study.optimize(objective, n_trials=50)
</code></pre>


</details>

<hr />
<h2>Summary</h2>
<p>In this chapter, you learned:</p>
<h3>Topics Covered</h3>
<ol>
<li>
<p><strong>Reaction Templates and SMARTS</strong>
   - Reaction SMILES and SMIRKS notation
   - Defining and applying reaction templates
   - USPTO reaction dataset</p>
</li>
<li>
<p><strong>Reaction Prediction Models</strong>
   - Yield prediction with Random Forest
   - Product prediction with Transformer
   - Reaction condition recommendation</p>
</li>
<li>
<p><strong>Retrosynthesis</strong>
   - Basic concepts of retrosynthetic analysis
   - AiZynthFinder, IBM RXN for Chemistry
   - Scoring synthetic routes</p>
</li>
<li>
<p><strong>Industrial Applications and Careers</strong>
   - Pharmaceutical companies (Pfizer, Roche, Novartis)
   - Materials manufacturers (Asahi Kasei, Mitsubishi Chemical)
   - Startups (Recursion, BenevolentAI, Exscientia)
   - Career paths for chemoinformaticians</p>
</li>
</ol>
<h3>Series Completion</h3>
<p>Congratulations! You have completed all 4 chapters of the Chemoinformatics Introduction series.</p>
<p><strong>Skills Acquired</strong>:
- ‚úÖ Molecular representation and RDKit operations
- ‚úÖ QSAR/QSPR modeling
- ‚úÖ Chemical space exploration and similarity search
- ‚úÖ Reaction prediction and Retrosynthesis</p>
<p><strong>Next Steps</strong>:
1. <strong>GNN Introduction Series</strong>: Molecular representation learning with Graph Neural Networks
2. <strong>Personal Projects</strong>: Large-scale QSAR using ChEMBL data
3. <strong>Community Participation</strong>: RDKit Users Group, Chemical Society of Japan Cheminformatics Division
4. <strong>Paper Submission</strong>: Journal of Cheminformatics, J. Chem. Inf. Model.</p>
<p><strong><a href="./index.html">Back to Series Top ‚Üí</a></strong></p>
<hr />
<h2>References</h2>
<ol>
<li>Coley, C. W. et al. (2017). "Prediction of Organic Reaction Outcomes Using Machine Learning." <em>ACS Central Science</em>, 3(5), 434-443. DOI: 10.1021/acscentsci.7b00064</li>
<li>Schwaller, P. et al. (2019). "Molecular Transformer: A Model for Uncertainty-Calibrated Chemical Reaction Prediction." <em>ACS Central Science</em>, 5(9), 1572-1583. DOI: 10.1021/acscentsci.9b00576</li>
<li>Genheden, S. et al. (2020). "AiZynthFinder: a fast, robust and flexible open-source software for retrosynthetic planning." <em>J. Cheminformatics</em>, 12, 70. DOI: 10.1186/s13321-020-00472-1</li>
<li>Lowe, D. M. (2012). <em>Extraction of chemical structures and reactions from the literature</em>. PhD thesis, University of Cambridge.</li>
</ol>
<hr />
<p><strong><a href="./chapter-3.html">‚Üê Chapter 3</a></strong> | <strong><a href="./index.html">Back to Series Top</a></strong></p>
<hr />
<h2>Additional Resources</h2>
<h3>Open Source Tools</h3>
<table>
<thead>
<tr>
<th>Tool Name</th>
<th>Description</th>
<th>GitHub</th>
</tr>
</thead>
<tbody>
<tr>
<td>RDKit</td>
<td>Comprehensive chemoinformatics library</td>
<td><a href="https://github.com/rdkit/rdkit">rdkit/rdkit</a></td>
</tr>
<tr>
<td>AiZynthFinder</td>
<td>Retrosynthesis tool</td>
<td><a href="https://github.com/MolecularAI/aizynthfinder">MolecularAI/aizynthfinder</a></td>
</tr>
<tr>
<td>rxnfp</td>
<td>Reaction fingerprints & Transformer</td>
<td><a href="https://github.com/rxn4chemistry/rxnfp">rxn4chemistry/rxnfp</a></td>
</tr>
<tr>
<td>Molecular Transformer</td>
<td>Reaction prediction Transformer</td>
<td><a href="https://github.com/pschwllr/MolecularTransformer">pschwllr/MolecularTransformer</a></td>
</tr>
</tbody>
</table>
<h3>Web Platforms</h3>
<ul>
<li><strong>IBM RXN for Chemistry</strong>: https://rxn.res.ibm.com/</li>
<li><strong>ChemDraw Cloud</strong>: https://chemdrawdirect.perkinelmer.cloud/</li>
<li><strong>PubChem</strong>: https://pubchem.ncbi.nlm.nih.gov/</li>
</ul>
<h3>Learning Resources</h3>
<ul>
<li><strong>Book</strong>: "Organic Chemistry by Retrosynthesis" by Stuart Warren</li>
<li><strong>Online Course</strong>: Coursera "Drug Discovery"</li>
<li><strong>Community</strong>: RDKit Users Group (Google Groups)</li>
</ul>
<hr />
<p><strong>Your chemoinformatics journey starts here!</strong></p><div class="navigation">
    <a href="chapter-3.html" class="nav-button">‚Üê Previous Chapter</a>
    <a href="index.html" class="nav-button">Back to Series Index</a>
</div>
    </main>


    <section class="disclaimer">
        <h3>Disclaimer</h3>
        <ul>
            <li>This content is provided for educational, research, and informational purposes only and does not constitute professional advice (legal, accounting, technical guarantees, etc.).</li>
            <li>This content and accompanying code examples are provided "AS IS" without warranty of any kind, either express or implied, including but not limited to warranties of merchantability, fitness for a particular purpose, non-infringement, accuracy, completeness, operation, or safety.</li>
            <li>The creator and Tohoku University assume no responsibility for the content, availability, or safety of external links, third-party data, tools, or libraries.</li>
            <li>To the maximum extent permitted by applicable law, the creator and Tohoku University shall not be liable for any direct, indirect, incidental, special, consequential, or punitive damages arising from the use, execution, or interpretation of this content.</li>
            <li>The content of this material may be changed, updated, or discontinued without notice.</li>
            <li>The copyright and license of this content are subject to the specified terms (e.g., CC BY 4.0). Such licenses typically include no-warranty provisions.</li>
        </ul>
    </section>

<footer>
        <p><strong>Author</strong>: AI Terakoya Content Team</p>
        <p><strong>Version</strong>: 1.0 | <strong>Created</strong>: 2025-10-18</p>
        <p><strong>License</strong>: Creative Commons BY 4.0</p>
        <p>¬© 2025 AI Terakoya. All rights reserved.</p>
    </footer>
</body>
</html>
