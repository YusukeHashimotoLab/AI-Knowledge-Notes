<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Chapter 4: Data Management and Post-Processing (FireWorks, AiiDA) - AI Terakoya</title>
<link href="../../assets/css/knowledge-base.css" rel="stylesheet"/>
<script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
<script>
        mermaid.initialize({ startOnLoad: true, theme: 'default', securityLevel: 'strict' });
    </script>
<!-- MathJax for LaTeX equation rendering -->
<script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\(', '\)']],
                displayMath: [['$$', '$$'], ['\[', '\]']],
                processEscapes: true,
                processEnvironments: true
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
                ignoreHtmlClass: 'mermaid'
            }
        };
    </script>
<script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
<nav class="breadcrumb">
<div class="breadcrumb-content">
<a href="/AI-Knowledge-Notes/knowledge/en/index.html">AI Terakoya Home</a><span class="breadcrumb-separator">‚Ä∫</span><a href="/AI-Knowledge-Notes/knowledge/en/MI/index.html">Materials Informatics</a><span class="breadcrumb-separator">‚Ä∫</span><a href="/AI-Knowledge-Notes/knowledge/en/MI/high-throughput-computing-introduction/index.html">High Throughput Computing</a><span class="breadcrumb-separator">‚Ä∫</span><span class="breadcrumb-current">Chapter 4</span>
</div>
</nav><div class="locale-switcher">
<span class="current-locale">üåê EN</span>
<span class="locale-separator">|</span>

<span class="locale-meta">Last sync: 2025-11-16</span>
</div>

<header>
<div class="header-content">
<h1>Chapter 4: Data Management and Post-Processing (FireWorks, AiiDA)</h1>
<p class="subtitle"></p>
<div class="meta">
<span class="meta-item">üìñ Reading Time: 20-25 minutes</span>
<span class="meta-item">üìä Difficulty: Advanced</span>
<span class="meta-item">üíª Code Examples: 6</span>
<span class="meta-item">üìù Exercises: 0</span>
</div>
</div>
</header>
<main class="container">
<h1>Chapter 4: Data Management and Post-Processing (FireWorks, AiiDA)</h1>
<p class="chapter-description" style="margin: 1.5rem 0; padding: 1rem; background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); border-left: 4px solid #7b2cbf; border-radius: 8px; font-size: 1.05rem; line-height: 1.8; color: #2d3748;">This chapter demonstrates specific procedures for scaling with SLURM and cloud platforms. You will also learn the essentials of cost estimation and optimization.</p>
<p class="chapter-supplement" style="margin: 0.75rem 0 1.5rem 0; padding: 0.75rem 1rem; background: linear-gradient(135deg, #fff8e1 0%, #fff3cd 100%); border-left: 3px solid #f59e0b; border-radius: 6px; font-size: 0.95rem; line-height: 1.7; color: #4a5568;"><strong>üí° Note:</strong> Rough estimation using unit cost √ó time √ó number of instances ‚Üí set upper limits. Be cautious as excessive parallelization increases failure rates.</p>
<h2>Learning Objectives</h2>
<p>By reading this chapter, you will master the following:</p>
<ul>
<li>‚úÖ Build complex workflows with FireWorks</li>
<li>‚úÖ Master standard workflows in Atomate</li>
<li>‚úÖ Record data provenance with AiiDA</li>
<li>‚úÖ Store calculation results in structured databases</li>
<li>‚úÖ Publish results to NOMAD</li>
</ul>
<hr/>
<h2>4.1 Workflow Management with FireWorks</h2>
<h3>FireWorks Architecture</h3>
<div class="mermaid">
flowchart TD
    A["Firework"] --&gt;|Chain| B["Workflow"]
    B --&gt; C["LaunchPad<br/>MongoDB"]
    C --&gt;|Task Assignment| D["Rocket Launcher"]
    D --&gt;|Execute| E["Compute Node"]
    E --&gt;|Results| C

    style C fill:#4ecdc4
    style A fill:#ffe66d
    style B fill:#ff6b6b
</div>
<p><strong>Key Components</strong>:
- <strong>Firework</strong>: Single task (one DFT calculation)
- <strong>Workflow</strong>: Chain of multiple Fireworks
- <strong>LaunchPad</strong>: Database (MongoDB)
- <strong>Rocket</strong>: Task execution engine</p>
<h3>Installation and Configuration</h3>
<pre><code class="language-bash"># Install FireWorks
pip install fireworks

# Install MongoDB (macOS)
brew install mongodb-community

# Start MongoDB
brew services start mongodb-community

# Initialize FireWorks
lpad init
# ‚Üí Generates my_launchpad.yaml
</code></pre>
<p><strong>my_launchpad.yaml</strong>:</p>
<pre><code class="language-yaml">host: localhost
port: 27017
name: fireworks
username: null
password: null
</code></pre>
<h3>Creating Basic Fireworks</h3>
<pre><code class="language-python">from fireworks import Firework, LaunchPad, ScriptTask
from fireworks.core.rocket_launcher import rapidfire

# Connect to LaunchPad (database)
launchpad = LaunchPad(host='localhost', port=27017, name='fireworks')

# Define task (run VASP)
vasp_task = ScriptTask.from_str(
    'mpirun -np 48 vasp_std',
    use_shell=True
)

# Create Firework
fw = Firework(
    vasp_task,
    name='VASP relaxation',
    spec={'_category': 'VASP'}
)

# Add to LaunchPad
launchpad.add_wf(fw)

# Execute
rapidfire(launchpad)
</code></pre>
<h3>Standard Workflows in Atomate</h3>
<p><strong>Atomate</strong> is a library of standardized workflows used by Materials Project.</p>
<pre><code class="language-python">from atomate.vasp.workflows.base.core import get_wf
from pymatgen.core import Structure

# Load structure
structure = Structure.from_file("LiCoO2.cif")

# Get standard workflow
# optimize_structure_and_properties:
#   1. Structure optimization
#   2. Static calculation
#   3. Band structure
#   4. DOS calculation
wf = get_wf(
    structure,
    "optimize_structure_and_properties.yaml"
)

# Add to LaunchPad
launchpad.add_wf(wf)

# Execute
rapidfire(launchpad, nlaunches='infinite')
</code></pre>
<h3>Creating Custom Workflows</h3>
<pre><code class="language-python">from fireworks import Firework, Workflow
from fireworks.core.firework import FiretaskBase
from atomate.vasp.firetasks.write_inputs import WriteVaspFromIOSet
from atomate.vasp.firetasks.run_calc import RunVaspCustodian
from atomate.vasp.firetasks.parse_outputs import VaspToDb
from pymatgen.io.vasp.sets import MPRelaxSet, MPStaticSet

class CustomWorkflow:
    """Custom workflow generation"""

    @staticmethod
    def bandgap_workflow(structure):
        """
        Band gap calculation workflow
        1. Structure optimization ‚Üí 2. Static calculation ‚Üí 3. Band gap extraction
        """
        # Firework 1: Structure optimization
        fw1 = Firework(
            [
                WriteVaspFromIOSet(structure=structure, vasp_input_set=MPRelaxSet),
                RunVaspCustodian(vasp_cmd="vasp_std"),
                VaspToDb(db_file="db.json", task_label="relax")
            ],
            name="Structural relaxation",
            spec={"_category": "relax"}
        )

        # Firework 2: Static calculation
        fw2 = Firework(
            [
                WriteVaspFromIOSet(structure=structure, vasp_input_set=MPStaticSet),
                RunVaspCustodian(vasp_cmd="vasp_std"),
                VaspToDb(db_file="db.json", task_label="static")
            ],
            name="Static calculation",
            spec={"_category": "static"}
        )

        # Firework 3: Band gap extraction
        fw3 = Firework(
            [ExtractBandgapTask()],
            name="Extract bandgap"
        )

        # Build workflow (fw1 ‚Üí fw2 ‚Üí fw3)
        wf = Workflow(
            [fw1, fw2, fw3],
            links_dict={fw1: [fw2], fw2: [fw3]},
            name=f"Bandgap workflow: {structure.composition.reduced_formula}"
        )

        return wf


class ExtractBandgapTask(FiretaskBase):
    """Band gap extraction task"""

    def run_task(self, fw_spec):
        from pymatgen.io.vasp.outputs import Vasprun

        vasprun = Vasprun("vasprun.xml")
        bandgap = vasprun.get_band_structure().get_band_gap()

        print(f"Band gap: {bandgap['energy']:.3f} eV")

        # Save result to database
        return {"bandgap": bandgap['energy']}

# Usage example
structure = Structure.from_file("LiCoO2.cif")
wf = CustomWorkflow.bandgap_workflow(structure)

launchpad.add_wf(wf)
rapidfire(launchpad)
</code></pre>
<h3>Error Handling and Restart</h3>
<pre><code class="language-python">from custodian.custodian import Custodian
from custodian.vasp.handlers import VaspErrorHandler, UnconvergedErrorHandler
from custodian.vasp.jobs import VaspJob

# Configure error handlers
handlers = [
    VaspErrorHandler(),           # General VASP errors
    UnconvergedErrorHandler(),    # Convergence errors
]

# Define VASP job
jobs = [
    VaspJob(
        vasp_cmd=["mpirun", "-np", "48", "vasp_std"],
        output_file="vasp.out",
        auto_npar=False
    )
]

# Run Custodian (automatic error handling)
c = Custodian(
    handlers=handlers,
    jobs=jobs,
    max_errors=5
)

c.run()
</code></pre>
<hr/>
<h2>4.2 Provenance Management with AiiDA</h2>
<h3>The Importance of Data Provenance</h3>
<p><strong>Provenance</strong> is the complete record of how calculation results were obtained.</p>
<p><strong>Information to track</strong>:
- Input data (structures, parameters)
- Software used (VASP 6.3.0, etc.)
- Computing environment (nodes, cores, date/time)
- Intermediate results
- Final results</p>
<h3>Installing AiiDA</h3>
<pre><code class="language-bash"># Install AiiDA
pip install aiida-core aiida-vasp

# Initialize database
verdi quicksetup

# Check status
verdi status
</code></pre>
<h3>Running Calculations with AiiDA</h3>
<pre><code class="language-python">from aiida import orm, engine
from aiida.plugins import CalculationFactory, DataFactory

# Get VASP calculation class
VaspCalculation = CalculationFactory('vasp.vasp')

# Data types
StructureData = DataFactory('structure')
KpointsData = DataFactory('array.kpoints')

# Create structure data
structure = StructureData()
# (Set structure)

# Set k-points
kpoints = KpointsData()
kpoints.set_kpoints_mesh([8, 8, 8])

# Calculation parameters
parameters = orm.Dict(dict={
    'ENCUT': 520,
    'EDIFF': 1e-5,
    'ISMEAR': 0,
    'SIGMA': 0.05,
})

# Build calculation
builder = VaspCalculation.get_builder()
builder.structure = structure
builder.kpoints = kpoints
builder.parameters = parameters
builder.code = orm.Code.get_from_string('vasp@localhost')

# Submit
calc_node = engine.submit(builder)
print(f"Calculation node: {calc_node.pk}")
</code></pre>
<h3>Data Queries</h3>
<pre><code class="language-python">from aiida.orm import QueryBuilder

# Search all VASP calculations
qb = QueryBuilder()
qb.append(VaspCalculation, filters={'attributes.exit_status': 0})

for calc in qb.all():
    print(f"PK: {calc[0].pk}, Formula: {calc[0].inputs.structure.get_formula()}")

# Search for materials with band gap 1.5-2.5 eV
qb = QueryBuilder()
qb.append(VaspCalculation, tag='calc')
qb.append(orm.Dict, with_incoming='calc', filters={
    'attributes.band_gap': {'and': [{'&gt;=': 1.5}, {'&lt;=': 2.5}]}
})

results = qb.all()
print(f"Matching materials: {len(results)}")
</code></pre>
<hr/>
<h2>4.3 Structuring Calculation Data</h2>
<h3>JSON Schema Design</h3>
<pre><code class="language-python">import json
from datetime import datetime

class MaterialsDataSchema:
    """Schema for materials calculation data"""

    @staticmethod
    def create_entry(material_id, formula, structure, calculation_results):
        """
        Create database entry

        Returns:
        --------
        entry : dict
            Structured data
        """
        entry = {
            # Identification
            "material_id": material_id,
            "formula": formula,
            "created_at": datetime.now().isoformat(),

            # Structure information
            "structure": {
                "lattice": structure.lattice.matrix.tolist(),
                "species": [str(site.specie) for site in structure],
                "coords": [site.frac_coords.tolist() for site in structure],
                "space_group": structure.get_space_group_info()[1]
            },

            # Calculation results
            "properties": {
                "energy": calculation_results.get("energy"),
                "band_gap": calculation_results.get("band_gap"),
                "formation_energy": calculation_results.get("formation_energy"),
            },

            # Calculation metadata
            "calculation_metadata": {
                "software": "VASP 6.3.0",
                "functional": "PBE",
                "encut": 520,
                "kpoints": calculation_results.get("kpoints"),
                "converged": calculation_results.get("converged"),
                "calculation_time": calculation_results.get("calculation_time"),
            },

            # Provenance
            "provenance": {
                "input_structure_source": "Materials Project",
                "workflow": "Atomate optimize_structure",
                "hostname": calculation_results.get("hostname"),
                "date": calculation_results.get("date"),
            }
        }

        return entry

# Usage example
entry = MaterialsDataSchema.create_entry(
    material_id="custom-0001",
    formula="LiCoO2",
    structure=structure,
    calculation_results={
        "energy": -45.67,
        "band_gap": 2.3,
        "converged": True,
        "kpoints": [12, 12, 8],
        "calculation_time": "2.5 hours",
        "hostname": "hpc.university.edu",
        "date": "2025-10-17",
    }
)

# Save as JSON
with open("data/custom-0001.json", 'w') as f:
    json.dump(entry, f, indent=2)
</code></pre>
<h3>Data Management with MongoDB</h3>
<pre><code class="language-python">from pymongo import MongoClient
import json

class MaterialsDatabase:
    """Materials database using MongoDB"""

    def __init__(self, host='localhost', port=27017, db_name='materials'):
        self.client = MongoClient(host, port)
        self.db = self.client[db_name]
        self.collection = self.db['calculations']

        # Create indices (speed up searches)
        self.collection.create_index("material_id", unique=True)
        self.collection.create_index("formula")
        self.collection.create_index("properties.band_gap")

    def insert(self, entry):
        """Insert data"""
        result = self.collection.insert_one(entry)
        return result.inserted_id

    def find_by_formula(self, formula):
        """Search by chemical formula"""
        return list(self.collection.find({"formula": formula}))

    def find_by_bandgap_range(self, min_gap, max_gap):
        """Search by band gap range"""
        query = {
            "properties.band_gap": {
                "$gte": min_gap,
                "$lte": max_gap
            }
        }
        return list(self.collection.find(query))

    def get_statistics(self):
        """Get statistics"""
        pipeline = [
            {
                "$group": {
                    "_id": None,
                    "total": {"$sum": 1},
                    "avg_bandgap": {"$avg": "$properties.band_gap"},
                    "avg_energy": {"$avg": "$properties.energy"}
                }
            }
        ]

        result = list(self.collection.aggregate(pipeline))
        return result[0] if result else {}

# Usage example
db = MaterialsDatabase()

# Insert data
db.insert(entry)

# Search
licoo2_results = db.find_by_formula("LiCoO2")
print(f"LiCoO2 calculations: {len(licoo2_results)}")

# Band gap search
semiconductors = db.find_by_bandgap_range(0.5, 3.0)
print(f"Semiconductors (0.5-3.0 eV): {len(semiconductors)}")

# Statistics
stats = db.get_statistics()
print(f"Average band gap: {stats['avg_bandgap']:.2f} eV")
</code></pre>
<hr/>
<h2>4.4 Automating Post-Processing</h2>
<h3>Automatic DOS/Band Structure Plotting</h3>
<pre><code class="language-python">from pymatgen.io.vasp.outputs import Vasprun
from pymatgen.electronic_structure.plotter import BSPlotter, DosPlotter
import matplotlib.pyplot as plt

def auto_plot_band_dos(directory):
    """
    Automatically plot band structure and DOS

    Parameters:
    -----------
    directory : str
        Directory containing vasprun.xml
    """
    vasprun = Vasprun(f"{directory}/vasprun.xml")

    # Band structure
    bs = vasprun.get_band_structure()
    bs_plotter = BSPlotter(bs)

    fig = bs_plotter.get_plot(ylim=[-5, 5])
    fig.savefig(f"{directory}/band_structure.png", dpi=300)
    print(f"Band structure saved: {directory}/band_structure.png")

    # DOS
    dos = vasprun.complete_dos
    dos_plotter = DosPlotter()
    dos_plotter.add_dos("Total", dos)

    fig = dos_plotter.get_plot(xlim=[-5, 5])
    fig.savefig(f"{directory}/dos.png", dpi=300)
    print(f"DOS saved: {directory}/dos.png")

    # Band gap
    bandgap = bs.get_band_gap()
    print(f"Band gap: {bandgap['energy']:.3f} eV ({bandgap['transition']})")

# Usage example
auto_plot_band_dos("calculations/LiCoO2")
</code></pre>
<h3>Automatic Report Generation</h3>
<pre><code class="language-python">from jinja2 import Template
from datetime import datetime

def generate_report(material_data, output_file="report.html"):
    """
    Automatically generate calculation result report

    Parameters:
    -----------
    material_data : dict
        Material data
    output_file : str
        Output HTML file
    """
    template_str = """
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Calculation Report: {{ material_data.formula }}&lt;/title&gt;
    &lt;style&gt;
        body { font-family: Arial, sans-serif; margin: 40px; }
        table { border-collapse: collapse; width: 100%; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #4CAF50; color: white; }
        img { max-width: 600px; }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;{{ material_data.formula }}&lt;/h1&gt;
    &lt;p&gt;Generated: {{ generation_time }}&lt;/p&gt;

    &lt;h2&gt;Structure Information&lt;/h2&gt;
    &lt;table&gt;
        &lt;tr&gt;&lt;th&gt;Property&lt;/th&gt;&lt;th&gt;Value&lt;/th&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;Space Group&lt;/td&gt;&lt;td&gt;{{ material_data.structure.space_group }}&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;Lattice Parameter a&lt;/td&gt;&lt;td&gt;{{ "%.3f"|format(material_data.structure.lattice[0][0]) }} √Ö&lt;/td&gt;&lt;/tr&gt;
    &lt;/table&gt;

    &lt;h2&gt;Calculation Results&lt;/h2&gt;
    &lt;table&gt;
        &lt;tr&gt;&lt;th&gt;Property&lt;/th&gt;&lt;th&gt;Value&lt;/th&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;Energy&lt;/td&gt;&lt;td&gt;{{ "%.3f"|format(material_data.properties.energy) }} eV/atom&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;Band Gap&lt;/td&gt;&lt;td&gt;{{ "%.3f"|format(material_data.properties.band_gap) }} eV&lt;/td&gt;&lt;/tr&gt;
    &lt;/table&gt;

    &lt;h2&gt;Band Structure&lt;/h2&gt;
    &lt;img src="band_structure.png" alt="Band Structure"&gt;

    &lt;h2&gt;Density of States&lt;/h2&gt;
    &lt;img src="dos.png" alt="DOS"&gt;
&lt;/body&gt;
&lt;/html&gt;
    """

    template = Template(template_str)

    html = template.render(
        material_data=material_data,
        generation_time=datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    )

    with open(output_file, 'w') as f:
        f.write(html)

    print(f"Report generated: {output_file}")

# Usage example
generate_report(entry, output_file="LiCoO2_report.html")
</code></pre>
<hr/>
<h2>4.5 Data Sharing and Archiving</h2>
<h3>Uploading to NOMAD Repository</h3>
<pre><code class="language-python">import requests
import json

def upload_to_nomad(data_files, metadata):
    """
    Upload data to NOMAD Repository

    Parameters:
    -----------
    data_files : list
        List of files to upload
    metadata : dict
        Metadata
    """
    nomad_url = "https://nomad-lab.eu/prod/rae/api/v1/uploads"

    # Prepare metadata
    upload_metadata = {
        "upload_name": metadata.get("name", "Untitled"),
        "references": metadata.get("references", []),
        "coauthors": metadata.get("coauthors", []),
    }

    # Upload files
    files = []
    for file_path in data_files:
        files.append(('file', open(file_path, 'rb')))

    response = requests.post(
        nomad_url,
        files=files,
        data={'metadata': json.dumps(upload_metadata)},
        headers={'Authorization': f'Bearer {NOMAD_API_TOKEN}'}
    )

    if response.status_code == 200:
        upload_id = response.json()['upload_id']
        print(f"Upload successful: {upload_id}")
        print(f"URL: https://nomad-lab.eu/prod/rae/gui/uploads/{upload_id}")
        return upload_id
    else:
        print(f"Upload failed: {response.status_code}")
        return None

# Usage example
files = [
    "calculations/LiCoO2/vasprun.xml",
    "calculations/LiCoO2/OUTCAR",
    "calculations/LiCoO2/CONTCAR",
]

metadata = {
    "name": "LiCoO2 battery material calculations",
    "references": ["https://doi.org/10.xxxx/xxxxx"],
    "coauthors": ["Dr. Yusuke Hashimoto"]
}

upload_to_nomad(files, metadata)
</code></pre>
<hr/>
<h2>4.6 Exercises</h2>
<h3>Exercise 1 (Difficulty: medium)</h3>
<p><strong>Problem</strong>: Create a 2-step workflow with FireWorks: structural optimization ‚Üí static calculation.</p>
<details>
<summary>Solution Example</summary>
<pre><code class="language-python">from fireworks import Firework, Workflow
from atomate.vasp.firetasks.write_inputs import WriteVaspFromIOSet
from atomate.vasp.firetasks.run_calc import RunVaspCustodian
from pymatgen.io.vasp.sets import MPRelaxSet, MPStaticSet
from pymatgen.core import Structure

structure = Structure.from_file("POSCAR")

# Firework 1: Structural optimization
fw1 = Firework(
    [
        WriteVaspFromIOSet(structure=structure, vasp_input_set=MPRelaxSet),
        RunVaspCustodian(vasp_cmd="vasp_std")
    ],
    name="Relax"
)

# Firework 2: Static calculation
fw2 = Firework(
    [
        WriteVaspFromIOSet(structure=structure, vasp_input_set=MPStaticSet),
        RunVaspCustodian(vasp_cmd="vasp_std")
    ],
    name="Static"
)

# Workflow
wf = Workflow([fw1, fw2], links_dict={fw1: [fw2]})

launchpad.add_wf(wf)
</code></pre>
</details>
<h3>Exercise 2 (Difficulty: hard)</h3>
<p><strong>Problem</strong>: From 1000 materials stored in MongoDB, extract the following:
1. Semiconductors with band gap 1.0-2.0 eV
2. Negative (stable) formation energy
3. Save results to CSV</p>
<details>
<summary>Solution Example</summary>
<pre><code class="language-python">import pandas as pd

db = MaterialsDatabase()

# Query
query = {
    "properties.band_gap": {"$gte": 1.0, "$lte": 2.0},
    "properties.formation_energy": {"$lt": 0}
}

results = list(db.collection.find(query))

# Create DataFrame
data = []
for r in results:
    data.append({
        "formula": r["formula"],
        "band_gap": r["properties"]["band_gap"],
        "formation_energy": r["properties"]["formation_energy"],
        "space_group": r["structure"]["space_group"]
    })

df = pd.DataFrame(data)

# Save to CSV
df.to_csv("stable_semiconductors.csv", index=False)
print(f"Matching materials: {len(df)}")
print(df.head())
</code></pre>
</details>
<hr/>
<h2>4.7 Summary</h2>
<p><strong>Key Points</strong>:</p>
<ol>
<li><strong>FireWorks</strong>: Standard workflow management for Materials Project</li>
<li><strong>Atomate</strong>: Standardized calculation workflows</li>
<li><strong>AiiDA</strong>: Data provenance tracking</li>
<li><strong>MongoDB</strong>: Large-scale data management</li>
<li><strong>NOMAD</strong>: Data publication and FAIR principles</li>
</ol>
<p><strong>Next Step</strong>: Chapter 5 covers cloud HPC utilization.</p>
<p><strong><a href="chapter-5.html">Chapter 5: Cloud HPC Utilization and Optimization ‚Üí</a></strong></p>
<hr/>
<p><strong>License</strong>: CC BY 4.0
<strong>Date Created</strong>: 2025-10-17
<strong>Author</strong>: Dr. Yusuke Hashimoto, Tohoku University</p><div class="navigation">
<a class="nav-button" href="chapter-3.html">‚Üê Previous Chapter</a>
<a class="nav-button" href="index.html">Back to Series Index</a>
<a class="nav-button" href="chapter-5.html">Next Chapter ‚Üí</a>
</div>
</main>
<section class="disclaimer">
<h3>Disclaimer</h3>
<ul>
<li>This content is provided solely for educational, research, and informational purposes and does not constitute professional advice (legal, accounting, technical guarantees, etc.).</li>
<li>This content and accompanying code examples are provided "AS IS" without any warranties, express or implied, including but not limited to merchantability, fitness for a particular purpose, non-infringement, accuracy, completeness, operation, or safety.</li>
<li>The author and Tohoku University assume no responsibility for the content, availability, or safety of external links, third-party data, tools, libraries, etc.</li>
<li>In the event that direct, indirect, incidental, special, consequential, or punitive damages arise from the use, execution, or interpretation of this content, to the maximum extent permitted by applicable law, the author and Tohoku University shall not be held liable.</li>
<li>The content of this material may be changed, updated, or discontinued without notice.</li>
<li>The copyright and license of this content are subject to the specified conditions (e.g., CC BY 4.0). Such licenses typically include warranty disclaimers.</li>
</ul>
</section>
<footer>
<p><strong>Author</strong>: AI Terakoya Content Team</p>
<p><strong>Version</strong>: 1.0 | <strong>Date Created</strong>: 2025-10-17</p>
<p><strong>License</strong>: Creative Commons BY 4.0</p>
<p>¬© 2025 AI Terakoya. All rights reserved.</p>
</footer>
</body>
</html>
