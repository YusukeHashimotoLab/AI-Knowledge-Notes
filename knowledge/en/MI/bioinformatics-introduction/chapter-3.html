<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 3: Molecular Docking and Interaction Analysis - AI Terakoya</title>

        <link rel="stylesheet" href="../../assets/css/knowledge-base.css">

    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <script>
        mermaid.initialize({ startOnLoad: true, theme: 'default', securityLevel: 'strict' });
    </script>

    <!-- MathJax for LaTeX equation rendering -->
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\(', '\)']],
                displayMath: [['$$', '$$'], ['\[', '\]']],
                processEscapes: true,
                processEnvironments: true
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
                ignoreHtmlClass: 'mermaid'
            }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" id="MathJax-script" async></script>
</head>
<body>
            <nav class="breadcrumb">
        <div class="breadcrumb-content">
            <a href="/AI-Knowledge-Notes/knowledge/en/index.html">AI Terakoya Home</a><span class="breadcrumb-separator">‚Ä∫</span><a href="/AI-Knowledge-Notes/knowledge/en/MI/index.html">Materials Informatics</a><span class="breadcrumb-separator">‚Ä∫</span><a href="/AI-Knowledge-Notes/knowledge/en/MI/bioinformatics-introduction/index.html">Bioinformatics</a><span class="breadcrumb-separator">‚Ä∫</span><span class="breadcrumb-current">Chapter 3</span>
        </div>
    </nav>

        <header>
        <div class="header-content">
            <h1>Chapter 3: Molecular Docking and Interaction Analysis</h1>
            <p class="subtitle">Predicting Protein-Ligand Binding</p>
            <div class="meta">
                <span class="meta-item">üìñ Reading Time: 25-30 min</span>
                <span class="meta-item">üìä Difficulty: Intermediate</span>
                <span class="meta-item">üíª Code Examples: 9</span>
                <span class="meta-item">üìù Exercises: 3</span>
            </div>
        </div>
    </header>

    <main class="container">
<h1>Chapter 3: Molecular Docking and Interaction Analysis</h1>
<p><strong>Predicting Protein-Ligand Binding</strong></p>
<h2>Learning Objectives</h2>
<ul>
<li>‚úÖ Understand the principles of molecular docking and scoring functions</li>
<li>‚úÖ Execute molecular docking with AutoDock Vina</li>
<li>‚úÖ Evaluate binding affinity and compare with experimental data</li>
<li>‚úÖ Visualize binding sites and interactions with PyMOL</li>
<li>‚úÖ Build binding prediction models using machine learning</li>
</ul>
<p><strong>Reading Time</strong>: 25-30 min | <strong>Code Examples</strong>: 9 | <strong>Exercises</strong>: 3</p>
<hr />
<h2>3.1 Fundamentals of Molecular Docking</h2>
<h3>What is Molecular Docking?</h3>
<p><strong>Molecular docking</strong> is a computational method to predict the binding mode of a ligand (small molecule) to a protein (receptor).</p>
<div class="mermaid">
flowchart LR
    A[Protein Structure] --> C[Docking\nSimulation]
    B[Ligand Structure] --> C
    C --> D[Binding Pose]
    C --> E[Binding Affinity]
    D --> F[Drug Design]
    E --> F

    style A fill:#e3f2fd
    style B fill:#fff3e0
    style C fill:#4CAF50,color:#fff
    style D fill:#f3e5f5
    style E fill:#ffebee
    style F fill:#fff9c4
</div>

<p><strong>Applications</strong>:
- Drug discovery (hit compound identification)
- Biosensor design (ligand selection)
- Drug delivery systems design (binding to target proteins)</p>
<hr />
<h3>Two Steps of Docking</h3>
<p><strong>1. Sampling</strong>
- Explore possible binding poses of the ligand
- Methods: Genetic algorithms, Monte Carlo, systematic search</p>
<p><strong>2. Scoring</strong>
- Evaluate the binding affinity of each pose
- Scoring functions: Force field-based, empirical, knowledge-based</p>
<hr />
<h3>Overview of AutoDock Vina</h3>
<p><strong>AutoDock Vina</strong> is the most widely used molecular docking software.</p>
<p><strong>Features</strong>:
- Fast (100x faster than classic AutoDock)
- High accuracy (RMSD &lt; 2 √Ö vs experimental values)
- Open source</p>
<p><strong>Installation</strong>:</p>
<pre><code class="language-bash"># Install with Conda
conda install -c conda-forge vina

# Or download from official website
# http://vina.scripps.edu/
</code></pre>
<hr />
<h3>Example 1: Preparing Protein and Ligand</h3>
<pre><code class="language-python">from rdkit import Chem
from rdkit.Chem import AllChem, Descriptors
from Bio.PDB import PDBParser
import os

# Protein preparation (PDB file)
def prepare_protein(pdb_file, output_pdbqt):
    &quot;&quot;&quot;
    Prepare protein for docking

    Parameters:
    -----------
    pdb_file : str
        Input PDB file
    output_pdbqt : str
        Output PDBQT file (AutoDock format)
    &quot;&quot;&quot;
    # Use Open Babel to convert PDB ‚Üí PDBQT
    # PDBQT: Extended PDB format with charges and atom types
    cmd = f&quot;obabel {pdb_file} -O {output_pdbqt} -xr&quot;
    os.system(cmd)

    print(f&quot;Protein preparation complete: {output_pdbqt}&quot;)

# Ligand preparation (SMILES)
def prepare_ligand_from_smiles(smiles, output_pdbqt):
    &quot;&quot;&quot;
    Prepare ligand from SMILES

    Parameters:
    -----------
    smiles : str
        SMILES notation of ligand
    output_pdbqt : str
        Output PDBQT file
    &quot;&quot;&quot;
    # Generate molecule object
    mol = Chem.MolFromSmiles(smiles)

    # Add hydrogens
    mol = Chem.AddHs(mol)

    # Generate 3D coordinates
    AllChem.EmbedMolecule(mol, randomSeed=42)
    AllChem.MMFFOptimizeMolecule(mol)

    # Save in PDB format
    temp_pdb = &quot;ligand_temp.pdb&quot;
    Chem.MolToPDBFile(mol, temp_pdb)

    # Convert PDB ‚Üí PDBQT
    cmd = f&quot;obabel {temp_pdb} -O {output_pdbqt} -xh&quot;
    os.system(cmd)

    # Remove temporary file
    os.remove(temp_pdb)

    print(f&quot;Ligand preparation complete: {output_pdbqt}&quot;)

    # Display molecule information
    mw = Descriptors.MolWt(mol)
    logp = Descriptors.MolLogP(mol)
    print(f&quot;  Molecular weight: {mw:.1f}&quot;)
    print(f&quot;  LogP: {logp:.2f}&quot;)

# Usage example
# Aspirin (analgesic)
aspirin_smiles = &quot;CC(=O)Oc1ccccc1C(=O)O&quot;
prepare_ligand_from_smiles(aspirin_smiles, &quot;aspirin.pdbqt&quot;)
</code></pre>
<hr />
<h3>Example 2: Running AutoDock Vina</h3>
<pre><code class="language-python">import subprocess
import os

def run_autodock_vina(
    receptor_pdbqt,
    ligand_pdbqt,
    center_x, center_y, center_z,
    size_x=20, size_y=20, size_z=20,
    output_pdbqt=&quot;output.pdbqt&quot;,
    exhaustiveness=8
):
    &quot;&quot;&quot;
    Run AutoDock Vina

    Parameters:
    -----------
    receptor_pdbqt : str
        Protein PDBQT file
    ligand_pdbqt : str
        Ligand PDBQT file
    center_x, center_y, center_z : float
        Center coordinates of search box (√Ö)
    size_x, size_y, size_z : float
        Size of search box (√Ö)
    output_pdbqt : str
        Output file
    exhaustiveness : int
        Exhaustiveness of search (default 8, use 16-32 for higher accuracy)
    &quot;&quot;&quot;

    # Vina command
    cmd = [
        &quot;vina&quot;,
        &quot;--receptor&quot;, receptor_pdbqt,
        &quot;--ligand&quot;, ligand_pdbqt,
        &quot;--center_x&quot;, str(center_x),
        &quot;--center_y&quot;, str(center_y),
        &quot;--center_z&quot;, str(center_z),
        &quot;--size_x&quot;, str(size_x),
        &quot;--size_y&quot;, str(size_y),
        &quot;--size_z&quot;, str(size_z),
        &quot;--out&quot;, output_pdbqt,
        &quot;--exhaustiveness&quot;, str(exhaustiveness)
    ]

    print(&quot;=== Running AutoDock Vina ===&quot;)
    print(&quot; &quot;.join(cmd))

    # Execute
    result = subprocess.run(
        cmd,
        capture_output=True,
        text=True
    )

    # Display results
    print(result.stdout)

    # Extract binding affinities
    affinities = []
    for line in result.stdout.split('\n'):
        if line.strip().startswith('1') or \
           line.strip().startswith('2') or \
           line.strip().startswith('3'):
            parts = line.split()
            if len(parts) &gt;= 2:
                try:
                    affinity = float(parts[1])
                    affinities.append(affinity)
                except ValueError:
                    pass

    if affinities:
        print(f&quot;\n=== Binding Affinity ===&quot;)
        print(f&quot;Best score: {affinities[0]:.1f} kcal/mol&quot;)
        print(f&quot;Top 3: {affinities[:3]}&quot;)

    return affinities

# Usage example (fictional coordinates)
# In actual use, specify coordinates of binding site
&quot;&quot;&quot;
affinities = run_autodock_vina(
    receptor_pdbqt=&quot;protein.pdbqt&quot;,
    ligand_pdbqt=&quot;ligand.pdbqt&quot;,
    center_x=10.5,
    center_y=20.3,
    center_z=15.8,
    size_x=20,
    size_y=20,
    size_z=20,
    output_pdbqt=&quot;docking_result.pdbqt&quot;
)
&quot;&quot;&quot;
</code></pre>
<p><strong>Output example</strong>:</p>
<pre><code>=== Running AutoDock Vina ===
vina --receptor protein.pdbqt --ligand ligand.pdbqt ...

Performing docking...
mode |   affinity | dist from best mode
     | (kcal/mol) | rmsd l.b.| rmsd u.b.
-----+------------+----------+----------
   1      -8.5       0.000       0.000
   2      -8.2       1.823       3.145
   3      -7.9       2.456       4.021

=== Binding Affinity ===
Best score: -8.5 kcal/mol
Top 3: [-8.5, -8.2, -7.9]
</code></pre>
<hr />
<h2>3.2 Visualization and Analysis of Interactions</h2>
<h3>Visualization with PyMOL</h3>
<p><strong>Example 3: Generating PyMOL Script</strong></p>
<pre><code class="language-python">def generate_pymol_script(
    protein_pdb,
    ligand_pdbqt,
    output_script=&quot;visualize.pml&quot;
):
    &quot;&quot;&quot;
    Generate PyMOL visualization script

    Parameters:
    -----------
    protein_pdb : str
        Protein PDB file
    ligand_pdbqt : str
        Docking result (PDBQT)
    output_script : str
        Output PyMOL script
    &quot;&quot;&quot;
    script = f&quot;&quot;&quot;
# PyMOL visualization script

# Load files
load {protein_pdb}, protein
load {ligand_pdbqt}, ligand

# Protein display settings
hide everything, protein
show cartoon, protein
color cyan, protein

# Display binding site (within 5√Ö of ligand)
select binding_site, protein within 5 of ligand
show sticks, binding_site
color green, binding_site

# Ligand display
hide everything, ligand
show sticks, ligand
color yellow, ligand
util.cbay ligand

# Display hydrogen bonds
distance hbonds, ligand, binding_site, mode=2
color red, hbonds

# View settings
zoom ligand, 5
set stick_radius, 0.3
set sphere_scale, 0.25

# White background
bg_color white

# Rendering settings
set ray_shadows, 0
set antialias, 2

# Save image
ray 1200, 1200
png binding_site.png, dpi=300

print(&quot;Visualization complete: binding_site.png&quot;)
&quot;&quot;&quot;

    with open(output_script, 'w') as f:
        f.write(script)

    print(f&quot;PyMOL script generated: {output_script}&quot;)
    print(&quot;Run with: pymol visualize.pml&quot;)

# Usage example
generate_pymol_script(
    &quot;protein.pdb&quot;,
    &quot;docking_result.pdbqt&quot;,
    &quot;visualize.pml&quot;
)
</code></pre>
<hr />
<h3>Quantitative Analysis of Interactions</h3>
<p><strong>Example 4: Detecting Hydrogen Bonds</strong></p>
<pre><code class="language-python">from Bio.PDB import PDBParser, NeighborSearch
import numpy as np

def detect_hydrogen_bonds(
    protein_structure,
    ligand_structure,
    distance_cutoff=3.5,  # √Ö
    angle_cutoff=120  # degrees
):
    &quot;&quot;&quot;
    Detect hydrogen bonds

    Parameters:
    -----------
    protein_structure : Bio.PDB.Structure
        Protein structure
    ligand_structure : Bio.PDB.Structure
        Ligand structure
    distance_cutoff : float
        Distance threshold (√Ö)
    angle_cutoff : float
        Angle threshold (degrees)

    Returns:
    --------
    list: List of hydrogen bonds
    &quot;&quot;&quot;
    # All protein atoms
    protein_atoms = [
        atom for atom in protein_structure.get_atoms()
    ]

    # All ligand atoms
    ligand_atoms = [
        atom for atom in ligand_structure.get_atoms()
    ]

    # Neighbor search
    ns = NeighborSearch(protein_atoms)

    hbonds = []

    # For each ligand atom
    for ligand_atom in ligand_atoms:
        # Donor/acceptor determination (simplified)
        if ligand_atom.element not in ['N', 'O']:
            continue

        # Nearby protein atoms
        nearby_atoms = ns.search(
            ligand_atom.get_coord(),
            distance_cutoff
        )

        for protein_atom in nearby_atoms:
            if protein_atom.element not in ['N', 'O']:
                continue

            # Calculate distance
            distance = ligand_atom - protein_atom

            if distance &lt;= distance_cutoff:
                hbonds.append({
                    'ligand_atom': ligand_atom.get_full_id(),
                    'protein_atom': protein_atom.get_full_id(),
                    'distance': distance
                })

    return hbonds

# Usage example (fictional structure)
&quot;&quot;&quot;
parser = PDBParser(QUIET=True)
protein = parser.get_structure('protein', 'protein.pdb')
ligand = parser.get_structure('ligand', 'ligand.pdb')

hbonds = detect_hydrogen_bonds(protein, ligand)

print(f&quot;=== Hydrogen Bonds ===&quot;)
print(f&quot;Number detected: {len(hbonds)}&quot;)

for i, hb in enumerate(hbonds[:5], 1):
    print(f&quot;\nHydrogen bond {i}:&quot;)
    print(f&quot;  Distance: {hb['distance']:.2f} √Ö&quot;)
    print(f&quot;  Ligand atom: {hb['ligand_atom']}&quot;)
    print(f&quot;  Protein atom: {hb['protein_atom']}&quot;)
&quot;&quot;&quot;
</code></pre>
<hr />
<h3>Analysis of Hydrophobic Interactions</h3>
<p><strong>Example 5: Detecting Hydrophobic Contacts</strong></p>
<pre><code class="language-python">def detect_hydrophobic_contacts(
    protein_structure,
    ligand_structure,
    distance_cutoff=4.5  # √Ö
):
    &quot;&quot;&quot;
    Detect hydrophobic interactions

    Parameters:
    -----------
    protein_structure : Bio.PDB.Structure
    ligand_structure : Bio.PDB.Structure
    distance_cutoff : float
        Threshold for hydrophobic interaction (√Ö)

    Returns:
    --------
    list: List of hydrophobic contacts
    &quot;&quot;&quot;
    # Hydrophobic amino acids
    hydrophobic_residues = [
        'ALA', 'VAL', 'ILE', 'LEU', 'MET',
        'PHE', 'TRP', 'PRO'
    ]

    # Carbon atoms in hydrophobic residues
    protein_hydrophobic_atoms = []
    for residue in protein_structure.get_residues():
        if residue.get_resname() in hydrophobic_residues:
            for atom in residue:
                if atom.element == 'C':
                    protein_hydrophobic_atoms.append(atom)

    # Carbon atoms in ligand
    ligand_carbon_atoms = [
        atom for atom in ligand_structure.get_atoms()
        if atom.element == 'C'
    ]

    # Neighbor search
    ns = NeighborSearch(protein_hydrophobic_atoms)

    contacts = []

    for ligand_atom in ligand_carbon_atoms:
        nearby_atoms = ns.search(
            ligand_atom.get_coord(),
            distance_cutoff
        )

        for protein_atom in nearby_atoms:
            distance = ligand_atom - protein_atom

            if distance &lt;= distance_cutoff:
                contacts.append({
                    'ligand_atom': ligand_atom.get_full_id(),
                    'protein_atom': protein_atom.get_full_id(),
                    'residue': protein_atom.get_parent().get_resname(),
                    'distance': distance
                })

    return contacts

# Usage example
&quot;&quot;&quot;
contacts = detect_hydrophobic_contacts(protein, ligand)

print(f&quot;\n=== Hydrophobic Contacts ===&quot;)
print(f&quot;Number detected: {len(contacts)}&quot;)

# Count by residue
from collections import Counter
residue_counts = Counter(
    [c['residue'] for c in contacts]
)

print(&quot;\nContacts by residue:&quot;)
for residue, count in residue_counts.most_common(5):
    print(f&quot;  {residue}: {count}&quot;)
&quot;&quot;&quot;
</code></pre>
<hr />
<h2>3.3 Machine Learning for Binding Prediction</h2>
<h3>Graph Neural Networks (GNN)</h3>
<p><strong>Example 6: Graph Representation of Protein-Ligand Complex</strong></p>
<pre><code class="language-python">import networkx as nx
import numpy as np
from rdkit import Chem

def protein_ligand_to_graph(protein_atoms, ligand_mol):
    &quot;&quot;&quot;
    Convert protein-ligand complex to graph

    Parameters:
    -----------
    protein_atoms : list
        List of protein atoms
    ligand_mol : RDKit Mol
        Ligand molecule

    Returns:
    --------
    networkx.Graph: Complex graph
    &quot;&quot;&quot;
    G = nx.Graph()

    # Ligand graph (molecular graph)
    for atom in ligand_mol.GetAtoms():
        G.add_node(
            f&quot;L{atom.GetIdx()}&quot;,
            atom_type=atom.GetSymbol(),
            atomic_num=atom.GetAtomicNum(),
            hybridization=str(atom.GetHybridization()),
            node_type='ligand'
        )

    # Ligand bonds
    for bond in ligand_mol.GetBonds():
        G.add_edge(
            f&quot;L{bond.GetBeginAtomIdx()}&quot;,
            f&quot;L{bond.GetEndAtomIdx()}&quot;,
            bond_type=str(bond.GetBondType())
        )

    # Protein atoms (simplified: representative atoms only)
    for i, atom in enumerate(protein_atoms[:50]):  # First 50 atoms
        G.add_node(
            f&quot;P{i}&quot;,
            atom_type=atom.element,
            node_type='protein'
        )

    # Protein-ligand interaction edges
    # (Distance-based, 4√Ö threshold)
    ligand_coords = ligand_mol.GetConformer().GetPositions()

    for i, protein_atom in enumerate(protein_atoms[:50]):
        protein_coord = protein_atom.get_coord()

        for j, ligand_coord in enumerate(ligand_coords):
            distance = np.linalg.norm(
                protein_coord - ligand_coord
            )

            if distance &lt; 4.0:  # Within 4√Ö
                G.add_edge(
                    f&quot;P{i}&quot;,
                    f&quot;L{j}&quot;,
                    interaction='contact',
                    distance=distance
                )

    return G

# Usage example
&quot;&quot;&quot;
ligand_smiles = &quot;CC(=O)Oc1ccccc1C(=O)O&quot;  # Aspirin
ligand_mol = Chem.MolFromSmiles(ligand_smiles)
ligand_mol = Chem.AddHs(ligand_mol)
AllChem.EmbedMolecule(ligand_mol)

# protein_atoms obtained from Bio.PDB.Structure
# complex_graph = protein_ligand_to_graph(
#     protein_atoms, ligand_mol
# )

# Graph statistics
# print(f&quot;Number of nodes: {complex_graph.number_of_nodes()}&quot;)
# print(f&quot;Number of edges: {complex_graph.number_of_edges()}&quot;)
&quot;&quot;&quot;
</code></pre>
<hr />
<h3>DeepDocking-Style Prediction Model</h3>
<p><strong>Example 7: Binding Affinity Prediction Model</strong></p>
<pre><code class="language-python">import numpy as np
import pandas as pd
from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_absolute_error, r2_score

def extract_complex_features(
    protein_structure,
    ligand_mol
):
    &quot;&quot;&quot;
    Extract features from protein-ligand complex

    Returns:
    --------
    dict: Feature dictionary
    &quot;&quot;&quot;
    from rdkit.Chem import Descriptors

    # Ligand features
    ligand_features = {
        'ligand_mw': Descriptors.MolWt(ligand_mol),
        'ligand_logp': Descriptors.MolLogP(ligand_mol),
        'ligand_hbd': Descriptors.NumHDonors(ligand_mol),
        'ligand_hba': Descriptors.NumHAcceptors(ligand_mol),
        'ligand_rotatable_bonds': Descriptors.NumRotatableBonds(
            ligand_mol
        ),
        'ligand_aromatic_rings': Descriptors.NumAromaticRings(
            ligand_mol
        )
    }

    # Protein features (simplified)
    # In reality, use binding site residue composition, etc.
    protein_features = {
        'binding_site_residues': 10,  # Placeholder value
        'binding_site_hydrophobic': 0.4,
        'binding_site_charged': 0.3
    }

    return {**ligand_features, **protein_features}

# Generate sample data (in practice, use database)
np.random.seed(42)

n_samples = 200
X_features = []
y_affinities = []

for _ in range(n_samples):
    # Random features (for demo)
    features = {
        'ligand_mw': np.random.uniform(150, 500),
        'ligand_logp': np.random.uniform(-2, 5),
        'ligand_hbd': np.random.randint(0, 6),
        'ligand_hba': np.random.randint(0, 10),
        'ligand_rotatable_bonds': np.random.randint(0, 10),
        'ligand_aromatic_rings': np.random.randint(0, 4),
        'binding_site_residues': np.random.randint(5, 20),
        'binding_site_hydrophobic': np.random.uniform(0.2, 0.6),
        'binding_site_charged': np.random.uniform(0.1, 0.5)
    }

    # Binding affinity (kcal/mol)
    # Generated based on realistic relationships
    affinity = (
        -0.1 * features['ligand_mw'] / 100
        - 1.5 * features['ligand_hbd']
        - 1.0 * features['ligand_hba']
        + 2.0 * features['ligand_logp']
        + np.random.randn() * 1.0
    )

    X_features.append(list(features.values()))
    y_affinities.append(affinity)

X = np.array(X_features)
y = np.array(y_affinities)

# Train/test split
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, random_state=42
)

# Model training
model = RandomForestRegressor(
    n_estimators=100,
    max_depth=10,
    random_state=42
)

model.fit(X_train, y_train)

# Prediction
y_pred = model.predict(X_test)

# Evaluation
mae = mean_absolute_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)

print(f&quot;=== Binding Affinity Prediction Model ===&quot;)
print(f&quot;MAE: {mae:.2f} kcal/mol&quot;)
print(f&quot;R¬≤: {r2:.3f}&quot;)

# Feature importance
feature_names = [
    'MW', 'LogP', 'HBD', 'HBA', 'RotBonds',
    'AromRings', 'BSResidues', 'BSHydrophobic',
    'BSCharged'
]

importance_df = pd.DataFrame({
    'feature': feature_names,
    'importance': model.feature_importances_
}).sort_values('importance', ascending=False)

print(&quot;\nFeature importance:&quot;)
print(importance_df)
</code></pre>
<hr />
<h2>3.4 Case Study: Antibody-Antigen Interactions</h2>
<h3>Antibody Structure Modeling</h3>
<p><strong>Example 8: Modeling Antibody Variable Regions</strong></p>
<pre><code class="language-python">def model_antibody_structure(
    heavy_chain_seq,
    light_chain_seq,
    output_pdb=&quot;antibody_model.pdb&quot;
):
    &quot;&quot;&quot;
    Model antibody structure

    Parameters:
    -----------
    heavy_chain_seq : str
        Heavy chain sequence
    light_chain_seq : str
        Light chain sequence
    output_pdb : str
        Output PDB file

    Note:
    -----
    In practice, use specialized tools (Modeller, AlphaFold2)
    &quot;&quot;&quot;
    print(&quot;=== Antibody Structure Modeling ===&quot;)
    print(f&quot;Heavy chain length: {len(heavy_chain_seq)} aa&quot;)
    print(f&quot;Light chain length: {len(light_chain_seq)} aa&quot;)

    # CDR (Complementarity-Determining Region) estimation
    # Simplified: Assume heavy chain CDR3 is positions 95-102
    cdr_h3_start = 95
    cdr_h3_end = 102

    if len(heavy_chain_seq) &gt;= cdr_h3_end:
        cdr_h3_seq = heavy_chain_seq[cdr_h3_start:cdr_h3_end]
        print(f&quot;\nCDR-H3 sequence: {cdr_h3_seq}&quot;)
        print(f&quot;Length: {len(cdr_h3_seq)} aa&quot;)

    # Actual modeling should be performed with AlphaFold2 or Modeller
    # Here, only display information for demo

    print(f&quot;\nModel will be saved to: {output_pdb}&quot;)
    print(&quot;Use AlphaFold2 for actual modeling&quot;)

# Usage example
heavy_chain = &quot;QVQLQQSGPGLVKPSQTLSLTCAISGDSVSSNSAAWN&quot; * 3
light_chain = &quot;DIQMTQSPSSLSASVGDRVTITCRASQDVNTAVAWY&quot; * 3

model_antibody_structure(heavy_chain, light_chain)
</code></pre>
<hr />
<h3>Epitope Prediction</h3>
<p><strong>Example 9: Linear Epitope Prediction</strong></p>
<pre><code class="language-python">def predict_linear_epitopes(
    antigen_sequence,
    window_size=9
):
    &quot;&quot;&quot;
    Predict linear epitopes (simplified version)

    Parameters:
    -----------
    antigen_sequence : str
        Amino acid sequence of antigen
    window_size : int
        Window size for epitopes

    Returns:
    --------
    list: List of epitope candidates
    &quot;&quot;&quot;
    # Simplified prediction (in practice, use Bepipred, IEDB tools, etc.)

    # Scoring considering hydrophobicity, charge, surface exposure
    hydrophobic_aa = &quot;AVILMFWP&quot;
    charged_aa = &quot;KRHDE&quot;
    polar_aa = &quot;STNQYC&quot;

    epitope_candidates = []

    for i in range(len(antigen_sequence) - window_size + 1):
        peptide = antigen_sequence[i:i+window_size]

        # Calculate score
        hydrophobic_count = sum(
            1 for aa in peptide if aa in hydrophobic_aa
        )
        charged_count = sum(
            1 for aa in peptide if aa in charged_aa
        )
        polar_count = sum(
            1 for aa in peptide if aa in polar_aa
        )

        # Simple score: prefer balanced peptides
        score = (
            0.3 * charged_count +
            0.5 * polar_count +
            0.2 * hydrophobic_count
        )

        epitope_candidates.append({
            'position': i,
            'peptide': peptide,
            'score': score
        })

    # Sort by score
    epitope_candidates.sort(
        key=lambda x: x['score'],
        reverse=True
    )

    return epitope_candidates

# Usage example
antigen_seq = &quot;&quot;&quot;
MFVFLVLLPLVSSQCVNLTTRTQLPPAYTNSFTRGVYYPDKVFRSSVLHS
TQDLFLPFFSNVTWFHAIHVSGTNGTKRFDNPVLPFNDGVYFASTEKSNI
IRGWIFGTTLDSKTQSLLIVNNATNVVIKVCEFQFCNDPFLGVYYHKNNK
SWMESEFRVYSSANNCTFEYVSQPFLMDLEGKQGNFKNLREFVFKNIDGY
FKIYSKHTPINLVRDLPQGFSALEPLVDLPIGINITRFQTLLALHRSYLT
PGDSSSGWTAGAAAYYVGYLQPRTFLLKYNENGTITDAVDCALDPLSETK
CTLKSFTVEKGIYQTSNFRVQPTESIVRFPNITNLCPFGEVFNATRFASV
YAWNRKRISNCVADYSVLYNSASFSTFKCYGVSPTKLNDLCFTNVYADSF
VIRGDEVRQIAPGQTGKIADYNYKLPDDFTGCVIAWNSNNLDSKVGGNYN
YLYRLFRKSNLKPFERDISTEIYQAGSTPCNGVEGFNCYFPLQSYGFQPT
NGVGYQPYRVVVLSFELLHAPATVCGPKKSTNLVKNKCVNF
&quot;&quot;&quot;
antigen_seq = antigen_seq.replace(&quot;\n&quot;, &quot;&quot;).replace(&quot; &quot;, &quot;&quot;)

epitopes = predict_linear_epitopes(antigen_seq, window_size=9)

print(f&quot;=== Epitope Prediction ===&quot;)
print(f&quot;Sequence length: {len(antigen_seq)} aa&quot;)
print(f&quot;\nTop 5 candidates:&quot;)

for i, ep in enumerate(epitopes[:5], 1):
    print(f&quot;\n{i}. Position {ep['position']}&quot;)
    print(f&quot;   Sequence: {ep['peptide']}&quot;)
    print(f&quot;   Score: {ep['score']:.2f}&quot;)
</code></pre>
<hr />
<h2>3.5 Chapter Summary</h2>
<h3>What We Learned</h3>
<ol>
<li>
<p><strong>Molecular Docking</strong>
   - Docking with AutoDock Vina
   - Binding affinity scores</p>
</li>
<li>
<p><strong>Interaction Analysis</strong>
   - Hydrogen bond detection
   - Hydrophobic contacts
   - PyMOL visualization</p>
</li>
<li>
<p><strong>Machine Learning</strong>
   - Graph representation
   - Binding affinity prediction</p>
</li>
<li>
<p><strong>Antibody-Antigen</strong>
   - Antibody structure modeling
   - Epitope prediction</p>
</li>
</ol>
<h3>Next Chapter</h3>
<p>In Chapter 4, we will learn about <strong>Biosensor and Drug Delivery System (DDS) Materials Design</strong>.</p>
<p><strong><a href="./chapter-4.html">Chapter 4: Biosensor and DDS Materials Design ‚Üí</a></strong></p>
<hr />
<h2>References</h2>
<ol>
<li>
<p>Trott, O. &amp; Olson, A. J. (2010). "AutoDock Vina: improving the
   speed and accuracy of docking with a new scoring function."
   <em>Journal of Computational Chemistry</em>, 31(2), 455-461.</p>
</li>
<li>
<p>Burley, S. K. et al. (2021). "RCSB Protein Data Bank."
   <em>Nucleic Acids Research</em>, 49(D1), D437-D451.</p>
</li>
</ol>
<hr />
<h2>Navigation</h2>
<p><strong><a href="./chapter-2.html">‚Üê Chapter 2</a></strong> | <strong><a href="./chapter-4.html">Chapter 4 ‚Üí</a></strong> | <strong><a href="./index.html">Table of Contents</a></strong></p><div class="navigation">
    <a href="chapter-2.html" class="nav-button">‚Üê Previous Chapter</a>
    <a href="index.html" class="nav-button">Return to Series Index</a>
    <a href="chapter-4.html" class="nav-button">Next Chapter ‚Üí</a>
</div>
    </main>


    <section class="disclaimer">
        <h3>Disclaimer</h3>
        <ul>
            <li>This content is provided solely for educational, research, and informational purposes and does not constitute professional advice (legal, accounting, technical warranty, etc.).</li>
            <li>This content and accompanying code examples are provided "AS IS" without any warranty, express or implied, including but not limited to merchantability, fitness for a particular purpose, non-infringement, accuracy, completeness, operability, or safety.</li>
            <li>The creator and Tohoku University assume no responsibility for the content, availability, or safety of external links, third-party data, tools, libraries, etc.</li>
            <li>To the maximum extent permitted by applicable law, the creator and Tohoku University shall not be liable for any direct, indirect, incidental, special, consequential, or punitive damages arising from the use, execution, or interpretation of this content.</li>
            <li>The content of this material may be changed, updated, or discontinued without notice.</li>
            <li>Copyright and licensing of this content are subject to specified terms (e.g., CC BY 4.0). Such licenses typically include no-warranty clauses.</li>
        </ul>
    </section>

<footer>
        <p><strong>Author</strong>: AI Terakoya Content Team</p>
        <p><strong>Version</strong>: 1.0 | <strong>Created</strong>: 2025-10-17</p>
        <p><strong>License</strong>: Creative Commons BY 4.0</p>
        <p>¬© 2025 AI Terakoya. All rights reserved.</p>
    </footer>
</body>
</html>
