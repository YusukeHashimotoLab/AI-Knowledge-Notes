<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 5: AlphaFold - The Revolution in Protein Structure Prediction - AI Terakoya</title>

    <style>
        :root {
            --color-primary: #2c3e50;
            --color-primary-dark: #1a252f;
            --color-accent: #7b2cbf;
            --color-accent-light: #9d4edd;
            --color-text: #2d3748;
            --color-text-light: #4a5568;
            --color-bg: #ffffff;
            --color-bg-alt: #f7fafc;
            --color-border: #e2e8f0;
            --color-code-bg: #f8f9fa;
            --color-link: #3182ce;
            --color-link-hover: #2c5aa0;

            --spacing-xs: 0.5rem;
            --spacing-sm: 1rem;
            --spacing-md: 1.5rem;
            --spacing-lg: 2rem;
            --spacing-xl: 3rem;

            --font-body: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            --font-mono: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;

            --border-radius: 8px;
            --box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-body);
            line-height: 1.7;
            color: var(--color-text);
            background-color: var(--color-bg);
            font-size: 16px;
        }

        header {
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            color: white;
            padding: var(--spacing-xl) var(--spacing-md);
            margin-bottom: var(--spacing-xl);
            box-shadow: var(--box-shadow);
        }

        .header-content {
            max-width: 900px;
            margin: 0 auto;
        }

        h1 {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: var(--spacing-sm);
            line-height: 1.2;
        }

        .subtitle {
            font-size: 1.1rem;
            opacity: 0.95;
            font-weight: 400;
            margin-bottom: var(--spacing-md);
        }

        .meta {
            display: flex;
            flex-wrap: wrap;
            gap: var(--spacing-md);
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .meta-item {
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 0 var(--spacing-md) var(--spacing-xl);
        }

        h2 {
            font-size: 1.75rem;
            color: var(--color-primary);
            margin-top: var(--spacing-xl);
            margin-bottom: var(--spacing-md);
            padding-bottom: var(--spacing-xs);
            border-bottom: 3px solid var(--color-accent);
        }

        h3 {
            font-size: 1.4rem;
            color: var(--color-primary);
            margin-top: var(--spacing-lg);
            margin-bottom: var(--spacing-sm);
        }

        h4 {
            font-size: 1.1rem;
            color: var(--color-primary-dark);
            margin-top: var(--spacing-md);
            margin-bottom: var(--spacing-sm);
        }

        p {
            margin-bottom: var(--spacing-md);
            color: var(--color-text);
        }

        a {
            color: var(--color-link);
            text-decoration: none;
            transition: color 0.2s;
        }

        a:hover {
            color: var(--color-link-hover);
            text-decoration: underline;
        }

        ul, ol {
            margin-left: var(--spacing-lg);
            margin-bottom: var(--spacing-md);
        }

        li {
            margin-bottom: var(--spacing-xs);
            color: var(--color-text);
        }

        pre {
            background-color: var(--color-code-bg);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            overflow-x: auto;
            margin-bottom: var(--spacing-md);
            font-family: var(--font-mono);
            font-size: 0.9rem;
            line-height: 1.5;
        }

        code {
            font-family: var(--font-mono);
            font-size: 0.9em;
            background-color: var(--color-code-bg);
            padding: 0.2em 0.4em;
            border-radius: 3px;
        }

        pre code {
            background-color: transparent;
            padding: 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: var(--spacing-md);
            font-size: 0.95rem;
        }

        th, td {
            border: 1px solid var(--color-border);
            padding: var(--spacing-sm);
            text-align: left;
        }

        th {
            background-color: var(--color-bg-alt);
            font-weight: 600;
            color: var(--color-primary);
        }

        blockquote {
            border-left: 4px solid var(--color-accent);
            padding-left: var(--spacing-md);
            margin: var(--spacing-md) 0;
            color: var(--color-text-light);
            font-style: italic;
            background-color: var(--color-bg-alt);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        .mermaid {
            text-align: center;
            margin: var(--spacing-lg) 0;
            background-color: var(--color-bg-alt);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        details {
            background-color: var(--color-bg-alt);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            padding: var(--spacing-md);
            margin-bottom: var(--spacing-md);
        }

        summary {
            cursor: pointer;
            font-weight: 600;
            color: var(--color-primary);
            user-select: none;
            padding: var(--spacing-xs);
            margin: calc(-1 * var(--spacing-md));
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
        }

        summary:hover {
            background-color: rgba(123, 44, 191, 0.1);
        }

        details[open] summary {
            margin-bottom: var(--spacing-md);
            border-bottom: 1px solid var(--color-border);
        }

        .learning-objectives {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            padding: var(--spacing-lg);
            border-radius: var(--border-radius);
            border-left: 4px solid var(--color-accent);
            margin-bottom: var(--spacing-xl);
        }

        .learning-objectives h2 {
            margin-top: 0;
            border-bottom: none;
        }

        .navigation {
            display: flex;
            justify-content: space-between;
            gap: var(--spacing-md);
            margin: var(--spacing-xl) 0;
            padding-top: var(--spacing-lg);
            border-top: 2px solid var(--color-border);
        }

        .nav-button {
            flex: 1;
            padding: var(--spacing-md);
            background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-light) 100%);
            color: white;
            border-radius: var(--border-radius);
            text-align: center;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: var(--box-shadow);
        }

        .nav-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            text-decoration: none;
        }

        footer {
            margin-top: var(--spacing-xl);
            padding: var(--spacing-lg) var(--spacing-md);
            background-color: var(--color-bg-alt);
            border-top: 1px solid var(--color-border);
            text-align: center;
            font-size: 0.9rem;
            color: var(--color-text-light);
        }
        .disclaimer {
            max-width: 900px;
            margin: 2rem auto;
            padding: 1.5rem;
            background: #f8f9fa;
            border-left: 4px solid #6c757d;
            border-radius: 4px;
        }

        .disclaimer h3 {
            color: #495057;
            margin-bottom: 1rem;
            font-size: 1.1rem;
        }

        .disclaimer ul {
            list-style: none;
            padding-left: 0;
        }

        .disclaimer li {
            padding: 0.5rem 0;
            padding-left: 1.5rem;
            position: relative;
            font-size: 0.9rem;
            color: #6c757d;
            line-height: 1.6;
        }

        .disclaimer li::before {
            content: "‚ö†Ô∏è";
            position: absolute;
            left: 0;
        }


        @media (max-width: 768px) {
            h1 {
                font-size: 1.5rem;
            }

            h2 {
                font-size: 1.4rem;
            }

            h3 {
                font-size: 1.2rem;
            }

            .meta {
                font-size: 0.85rem;
            }

            .navigation {
                flex-direction: column;
            }

            table {
                font-size: 0.85rem;
            }

            th, td {
                padding: var(--spacing-xs);
            }
        }



        /* Breadcrumb styles */
        .breadcrumb {
            background: #f7fafc;
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #e2e8f0;
            font-size: 0.9rem;
        }

        .breadcrumb-content {
            max-width: 900px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .breadcrumb a {
            color: #667eea;
            text-decoration: none;
            transition: color 0.2s;
        }

        .breadcrumb a:hover {
            color: #764ba2;
            text-decoration: underline;
        }

        .breadcrumb-separator {
            color: #a0aec0;
            margin: 0 0.25rem;
        }

        .breadcrumb-current {
            color: #4a5568;
            font-weight: 500;
        }
    </style>

    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <script>
        mermaid.initialize({ startOnLoad: true, theme: 'default', securityLevel: 'strict' });
    </script>

    <!-- MathJax for LaTeX equation rendering -->
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\(', '\)']],
                displayMath: [['$$', '$$'], ['\[', '\]']],
                processEscapes: true,
                processEnvironments: true
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
                ignoreHtmlClass: 'mermaid'
            }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" id="MathJax-script" async></script>
</head>
<body>
            <nav class="breadcrumb">
        <div class="breadcrumb-content">
            <a href="/AI-Knowledge-Notes/knowledge/en/index.html">AI Terakoya Top</a><span class="breadcrumb-separator">‚Ä∫</span><a href="/AI-Knowledge-Notes/knowledge/en/MI/index.html">Materials Informatics</a><span class="breadcrumb-separator">‚Ä∫</span><a href="/AI-Knowledge-Notes/knowledge/en/MI/bioinformatics-introduction/index.html">Bioinformatics</a><span class="breadcrumb-separator">‚Ä∫</span><span class="breadcrumb-current">Chapter 5</span>
        </div>
    </nav>

        <header>
        <div class="header-content">
            <h1>Chapter 5: AlphaFold - The Revolution in Protein Structure Prediction</h1>
            <p class="subtitle">The Moment AI Solved Biology's 50-Year Grand Challenge</p>
            <div class="meta">
                <span class="meta-item">üìñ Reading Time: 30-35 min</span>
                <span class="meta-item">üìä Difficulty: Intermediate</span>
                <span class="meta-item">üíª Code Examples: 8</span>
                <span class="meta-item">üìù Exercises: 10</span>
            </div>
        </div>
    </header>

    <main class="container">
<h1>Chapter 5: AlphaFold - The Revolution in Protein Structure Prediction</h1>
<p><strong>The Moment AI Solved Biology's 50-Year Grand Challenge - The Complete Story of the Technology That Decoded the "Second Genetic Code" of Proteins</strong></p>
<hr />
<h2>5.1 Historical Significance of AlphaFold</h2>
<h3>5.1.1 The 50-Year Challenge: "Protein Folding Problem"</h3>
<p>In 1972, Nobel laureate Christian Anfinsen proposed the hypothesis that "a protein's amino acid sequence determines its three-dimensional structure." However, actually predicting the 3D structure from the amino acid sequence remained one of biology's greatest challenges for half a century.</p>
<p><strong>By the Numbers:</strong>
- Protein types: ~20,000 in the human genome alone
- Cost of experimental structure determination: $120,000/structure (X-ray crystallography)
- Time required: Average 3-5 years/structure
- Structures determined: ~170,000 as of 2020 (&lt;1% of all proteins)</p>
<p><strong>Example (Real Case):</strong>
When the COVID-19 pandemic began in 2020, determining the structure of the virus spike protein was expected to take several months with conventional methods. However, using AlphaFold, highly accurate structure prediction became possible within just days after the sequence was published, greatly accelerating vaccine development.</p>
<div class="mermaid">
timeline
    title History of Protein Structure Prediction
    1972 : Anfinsen's Hypothesis
         : Protein sequence determines structure
    1994 : CASP Begins
         : Structure prediction competition
    2018 : AlphaFold 1
         : DeepMind wins CASP13
    2020 : AlphaFold 2
         : Achieves GDT 92.4 at CASP14
    2022 : AlphaFold Database
         : Releases 200 million structures
    2024 : AlphaFold 3
         : Expands to protein complexes, RNA, DNA
</div>

<h3>5.1.2 Historic Success at CASP14</h3>
<p>CASP (Critical Assessment of protein Structure Prediction) is an international protein structure prediction competition held biennially. AlphaFold 2 achieved historic success at CASP14 in 2020.</p>
<p><strong>Performance:</strong>
- <strong>GDT (Global Distance Test) Score</strong>: 92.4/100
  - Previous best: ~60-70 points
  - Experimental methods (X-ray crystallography): ~90 points
- <strong>Evaluation Set</strong>: 98 unpublished protein structures
- <strong>Gap with 2nd Place</strong>: ~25 points (overwhelming lead)</p>
<blockquote>
<p>"This is a big deal in structural biology. A problem that has been open for 50 years has essentially been solved."</p>
<p>‚Äî Dr. John Moult (CASP Founder, University of Maryland)</p>
</blockquote>
<div class="mermaid">
flowchart LR
    A[Amino Acid Sequence\nMKFLAIVSL...] --> B[AlphaFold 2]
    B --> C[3D Structure Prediction\nGDT 92.4]
    C --> D{Accuracy Assessment}
    D -->|Very High\npLDDT>90| E[Confidence: Experimental Level]
    D -->|High\npLDDT 70-90| F[Confidence: Suitable for Modeling]
    D -->|Low\npLDDT<70| G[Confidence: Low]

    style A fill:#e3f2fd
    style C fill:#e8f5e9
    style E fill:#c8e6c9
    style F fill:#fff9c4
    style G fill:#ffccbc
</div>

<h3>5.1.3 Impact on Industry and Research</h3>
<p><strong>üí° Pro Tip:</strong>
The AlphaFold Database is freely available. Over 200 million protein structures can be downloaded instantly from https://alphafold.ebi.ac.uk/</p>
<p><strong>Industrial Impact by the Numbers:</strong>
- <strong>Drug Discovery Timeline Reduction</strong>: Target protein structure determination from 5 years ‚Üí minutes
- <strong>Cost Reduction</strong>: $120,000/structure ‚Üí nearly free (computational cost only)
- <strong>Nature Citations</strong>: The 2021 paper cited 15,000+ times (as of 2024)
- <strong>Adopting Companies</strong>: All major pharmaceutical companies including Pfizer, Novartis, GSK, Roche</p>
<pre><code class="language-python"># ===================================
# Example 1: Retrieving Structure from AlphaFold Database
# ===================================

import requests
from io import StringIO
from Bio.PDB import PDBParser

def download_alphafold_structure(uniprot_id):
    &quot;&quot;&quot;Download structure from AlphaFold Database

    Args:
        uniprot_id (str): UniProt ID (e.g., P00533)

    Returns:
        Bio.PDB.Structure: Protein structure object
        None: If download fails

    Example:
        &gt;&gt;&gt; structure = download_alphafold_structure(&quot;P00533&quot;)  # EGFR receptor
        &gt;&gt;&gt; print(f&quot;Chains: {len(list(structure.get_chains()))}&quot;)
    &quot;&quot;&quot;
    # AlphaFold Database URL
    url = f&quot;https://alphafold.ebi.ac.uk/files/AF-{uniprot_id}-F1-model_v4.pdb&quot;

    try:
        response = requests.get(url, timeout=10)
        response.raise_for_status()

        # Parse PDB file
        parser = PDBParser(QUIET=True)
        structure = parser.get_structure(uniprot_id, StringIO(response.text))

        print(f&quot;‚úì Structure retrieved successfully: {uniprot_id}&quot;)
        print(f&quot;  Number of residues: {len(list(structure.get_residues()))}&quot;)

        return structure

    except requests.exceptions.RequestException as e:
        print(f&quot;‚úó Download failed: {e}&quot;)
        return None

# Usage example: Retrieve EGFR (Epidermal Growth Factor Receptor) structure
egfr_structure = download_alphafold_structure(&quot;P00533&quot;)

# Expected output:
# ‚úì Structure retrieved successfully: P00533
#   Number of residues: 1210
</code></pre>
<hr />
<h2>5.2 AlphaFold Architecture</h2>
<h3>5.2.1 Algorithm Overview</h3>
<p>AlphaFold 2 consists of three main components:</p>
<div class="mermaid">
flowchart TD
    A[Input: Amino Acid Sequence] --> B[MSA Generation\nMultiple Sequence Alignment]
    B --> C[Evoformer\n48-Layer Attention]
    C --> D[Structure Module\nCoordinate Prediction]
    D --> E[Output: 3D Coordinates + pLDDT]

    B --> F[Template Search\nSimilar Structures from PDB]
    F --> C

    C --> G[Inter-Residue Distances\nDistogram]
    G --> D

    style A fill:#e3f2fd
    style C fill:#fff3e0
    style D fill:#f3e5f5
    style E fill:#e8f5e9
</div>

<p><strong>Component Roles:</strong></p>
<ol>
<li>
<p><strong>MSA (Multiple Sequence Alignment)</strong>:
   - Search for evolutionarily related sequences (BFD, MGnify, UniRef, etc.)
   - Extract sequence conservation and coevolution patterns
   - Function: Infer structural information from evolutionary constraints</p>
</li>
<li>
<p><strong>Evoformer</strong>:
   - 48-layer Transformer-like architecture
   - Row attention (sequence dimension) + Column attention (residue dimension)
   - Pair representation updates (inter-residue relationships)</p>
</li>
<li>
<p><strong>Structure Module</strong>:
   - Transformation to 3D coordinates
   - Equivariant Transformer (rotation and translation invariant)
   - Iterative structure refinement (8 recycling iterations)</p>
</li>
</ol>
<h3>5.2.2 Innovation in Attention Mechanism</h3>
<p><strong>‚ö†Ô∏è Note:</strong>
AlphaFold's attention mechanism differs from standard Transformers (BERT, GPT, etc.). By using <strong>pair representation</strong>, it explicitly models inter-residue interactions.</p>
<pre><code class="language-python"># ===================================
# Example 2: Analyzing pLDDT (Prediction Confidence Score)
# ===================================

import numpy as np
from Bio.PDB import PDBParser
import matplotlib.pyplot as plt

def extract_plddt_scores(pdb_file):
    &quot;&quot;&quot;Extract pLDDT scores from AlphaFold structure

    pLDDT (predicted Local Distance Difference Test) is a
    metric indicating prediction confidence for each residue on a 0-100 scale.

    Interpretation:
    - pLDDT &gt; 90: Very high (equivalent to experimental structure)
    - pLDDT 70-90: Confident (suitable for modeling)
    - pLDDT 50-70: Low (possible flexible region)
    - pLDDT &lt; 50: Very low (unreliable)

    Args:
        pdb_file (str): AlphaFold PDB file path

    Returns:
        tuple: (residue number list, pLDDT score list)
    &quot;&quot;&quot;
    parser = PDBParser(QUIET=True)
    structure = parser.get_structure('protein', pdb_file)

    residue_numbers = []
    plddt_scores = []

    for model in structure:
        for chain in model:
            for residue in chain:
                # pLDDT is stored in B-factor column
                for atom in residue:
                    if atom.name == 'CA':  # CŒ± atom only
                        residue_numbers.append(residue.id[1])
                        plddt_scores.append(atom.bfactor)
                        break

    return residue_numbers, plddt_scores

def analyze_plddt(pdb_file):
    &quot;&quot;&quot;Statistical analysis and visualization of pLDDT&quot;&quot;&quot;
    res_nums, plddt = extract_plddt_scores(pdb_file)

    # Statistics
    mean_plddt = np.mean(plddt)
    very_high = sum(1 for x in plddt if x &gt; 90)
    confident = sum(1 for x in plddt if 70 &lt;= x &lt;= 90)
    low = sum(1 for x in plddt if x &lt; 70)

    print(f&quot;pLDDT Statistics:&quot;)
    print(f&quot;  Mean score: {mean_plddt:.2f}&quot;)
    print(f&quot;  Very high (&gt;90): {very_high} residues ({very_high/len(plddt)*100:.1f}%)&quot;)
    print(f&quot;  Confident (70-90): {confident} residues ({confident/len(plddt)*100:.1f}%)&quot;)
    print(f&quot;  Low (&lt;70): {low} residues ({low/len(plddt)*100:.1f}%)&quot;)

    # Visualization
    plt.figure(figsize=(12, 4))
    plt.plot(res_nums, plddt, linewidth=2)
    plt.axhline(y=90, color='g', linestyle='--', label='Very high threshold')
    plt.axhline(y=70, color='orange', linestyle='--', label='Confident threshold')
    plt.axhline(y=50, color='r', linestyle='--', label='Low threshold')
    plt.xlabel('Residue Number')
    plt.ylabel('pLDDT Score')
    plt.title('AlphaFold Prediction Confidence (pLDDT)')
    plt.legend()
    plt.grid(alpha=0.3)
    plt.ylim(0, 100)
    plt.tight_layout()
    plt.savefig('plddt_analysis.png', dpi=150)
    print(&quot;‚úì Graph saved: plddt_analysis.png&quot;)

    return mean_plddt, plddt

# Usage example
# analyze_plddt('AF-P00533-F1-model_v4.pdb')

# Expected output:
# pLDDT Statistics:
#   Mean score: 82.45
#   Very high (&gt;90): 654 residues (54.0%)
#   Confident (70-90): 432 residues (35.7%)
#   Low (&lt;70): 124 residues (10.3%)
# ‚úì Graph saved: plddt_analysis.png
</code></pre>
<h3>5.2.3 Importance of MSA</h3>
<p><strong>Why is MSA Important?</strong></p>
<p>In protein evolution, functionally important residues are conserved. Additionally, residue pairs that are structurally in contact show <strong>coevolution</strong>: when one residue mutates, the contacting partner also mutates compensatorily.</p>
<p><strong>Example (Real Case):</strong>
When two residues A and B in an enzyme's active site interact:
- Species 1: A=Asp (negative), B=Arg (positive) ‚Üí electrostatic interaction
- Species 2: A=Glu (negative), B=Lys (positive) ‚Üí same electrostatic interaction
- Species 3: A=Ala (hydrophobic), B=Val (hydrophobic) ‚Üí hydrophobic interaction</p>
<p>From such <strong>coevolution patterns</strong>, AlphaFold infers inter-residue contacts.</p>
<pre><code class="language-python"># ===================================
# Example 3: MSA Generation and Analysis
# ===================================

from Bio.Blast import NCBIWWW, NCBIXML

def generate_msa_blast(sequence, max_hits=100):
    &quot;&quot;&quot;Generate MSA using NCBI BLAST

    Note: AlphaFold actually uses larger databases
    (BFD, MGnify, UniRef90), but here we use BLAST
    for a simple demonstration.

    Args:
        sequence (str): Amino acid sequence
        max_hits (int): Maximum number of hits

    Returns:
        list: List of homologous sequences
    &quot;&quot;&quot;
    print(&quot;BLAST search started (may take several minutes)...&quot;)

    # Search with NCBI BLAST
    result_handle = NCBIWWW.qblast(
        program=&quot;blastp&quot;,
        database=&quot;nr&quot;,
        sequence=sequence,
        hitlist_size=max_hits
    )

    # Parse results
    blast_records = NCBIXML.parse(result_handle)
    record = next(blast_records)

    homologs = []
    for alignment in record.alignments[:max_hits]:
        for hsp in alignment.hsps:
            if hsp.expect &lt; 1e-5:  # E-value threshold
                homologs.append({
                    'title': alignment.title,
                    'e_value': hsp.expect,
                    'identity': hsp.identities / hsp.align_length,
                    'sequence': hsp.sbjct
                })

    print(f&quot;‚úì Detected {len(homologs)} homologous sequences&quot;)
    return homologs

def calculate_sequence_conservation(msa_sequences):
    &quot;&quot;&quot;Calculate sequence conservation

    Args:
        msa_sequences (list): List of aligned sequences

    Returns:
        np.array: Conservation score for each position (0-1)
    &quot;&quot;&quot;
    if not msa_sequences:
        return None

    length = len(msa_sequences[0])
    conservation = np.zeros(length)

    for pos in range(length):
        # Calculate amino acid frequency at each position
        amino_acids = [seq[pos] for seq in msa_sequences if pos &lt; len(seq)]

        # Exclude gaps
        amino_acids = [aa for aa in amino_acids if aa != '-']

        if amino_acids:
            # Ratio of most frequent amino acid = conservation
            from collections import Counter
            most_common = Counter(amino_acids).most_common(1)[0][1]
            conservation[pos] = most_common / len(amino_acids)

    return conservation

# Usage example (commented out as actual execution takes time)
# sequence = &quot;MKFLAIVSLF&quot;  # Short sequence example
# homologs = generate_msa_blast(sequence)
# conservation = calculate_sequence_conservation([h['sequence'] for h in homologs])
# print(f&quot;Mean conservation: {np.mean(conservation):.2f}&quot;)

# Expected output:
# BLAST search started (may take several minutes)...
# ‚úì Detected 87 homologous sequences
# Mean conservation: 0.73
</code></pre>
<hr />
<h2>5.3 Practical Applications of AlphaFold</h2>
<h3>5.3.1 Easy Structure Prediction with ColabFold</h3>
<p><strong>ColabFold</strong> is a tool for running AlphaFold on Google Colaboratory. It allows free GPU usage and enables structure prediction without programming.</p>
<p><strong>Usage Steps:</strong>
1. Access https://colab.research.google.com/github/sokrypton/ColabFold
2. Enter amino acid sequence
3. Execute "Runtime" ‚Üí "Run all"
4. Obtain results in approximately 10-30 minutes</p>
<p><strong>üí° Pro Tip:</strong>
ColabFold has daily usage limits. For large-scale predictions, local installation is recommended.</p>
<pre><code class="language-python"># ===================================
# Example 4: Protein Structure Visualization
# ===================================

import py3Dmol
from IPython.display import display

def visualize_protein_structure(pdb_file, color_by='plddt'):
    &quot;&quot;&quot;Interactively visualize AlphaFold structure

    Args:
        pdb_file (str): PDB file path
        color_by (str): Coloring method
            - 'plddt': Color by pLDDT score (default)
            - 'chain': By chain
            - 'ss': By secondary structure

    Returns:
        py3Dmol.view: 3D visualization object
    &quot;&quot;&quot;
    # Load PDB file
    with open(pdb_file, 'r') as f:
        pdb_data = f.read()

    # Create 3Dmol viewer
    view = py3Dmol.view(width=800, height=600)
    view.addModel(pdb_data, 'pdb')

    if color_by == 'plddt':
        # Color by pLDDT score (blue=high confidence, red=low)
        view.setStyle({
            'cartoon': {
                'colorscheme': {
                    'prop': 'b',  # B-factor (pLDDT)
                    'gradient': 'roygb',
                    'min': 50,
                    'max': 100
                }
            }
        })
    elif color_by == 'ss':
        # Color by secondary structure
        view.setStyle({'cartoon': {'color': 'spectrum'}})
    else:
        # By chain
        view.setStyle({'cartoon': {'colorscheme': 'chain'}})

    view.zoomTo()

    return view

# Usage example in Jupyter Notebook
# view = visualize_protein_structure('AF-P00533-F1-model_v4.pdb')
# display(view)

# Expected behavior:
# Interactive 3D structure displayed,
# rotatable and zoomable with mouse.
# Color-coded by pLDDT score (blue=high confidence, red=low).
</code></pre>
<h3>5.3.2 Applications in Drug Discovery</h3>
<p>AlphaFold is being utilized at multiple stages of drug discovery:</p>
<div class="mermaid">
flowchart LR
    A[Target Protein\nIdentification] --> B[AlphaFold\nStructure Prediction]
    B --> C[Pocket Detection\nFpocket, DoGSite]
    C --> D[Docking\nAutoDock Vina]
    D --> E[Lead Compound\nOptimization]
    E --> F[ADMET Prediction\nChemprop]
    F --> G[Candidate Compound\nSelection]

    style A fill:#e3f2fd
    style B fill:#fff3e0
    style D fill:#f3e5f5
    style G fill:#e8f5e9
</div>

<p><strong>Success Stories:</strong></p>
<ol>
<li>
<p><strong>Exscientia x Sanofi (2023)</strong>:
   - Target: CDK7 kinase (cancer treatment)
   - Docking based on AlphaFold structure
   - Clinical trial candidate identified in 18 months (conventional 4-5 years)</p>
</li>
<li>
<p><strong>Insilico Medicine (2022)</strong>:
   - Target: Novel target for idiopathic pulmonary fibrosis
   - AlphaFold + generative models
   - Phase I clinical trial started in 30 months</p>
</li>
</ol>
<pre><code class="language-python"># ===================================
# Example 5: Binding Pocket Detection
# ===================================

from Bio.PDB import PDBParser, NeighborSearch
import numpy as np

def detect_binding_pockets(pdb_file, pocket_threshold=10.0):
    &quot;&quot;&quot;Detect binding pockets from protein structure

    Simple implementation: Detect concave surface regions
    (For practical use, specialized tools like Fpocket, DoGSite are recommended)

    Args:
        pdb_file (str): PDB file path
        pocket_threshold (float): Distance threshold for pocket detection [√Ö]

    Returns:
        list: List of residue numbers for pocket candidates
    &quot;&quot;&quot;
    parser = PDBParser(QUIET=True)
    structure = parser.get_structure('protein', pdb_file)

    # Get all atoms
    atoms = []
    for model in structure:
        for chain in model:
            for residue in chain:
                for atom in residue:
                    atoms.append(atom)

    # Create neighbor search object
    ns = NeighborSearch(atoms)

    # Detect surface residues (high solvent accessibility)
    surface_residues = []

    for model in structure:
        for chain in model:
            for residue in chain:
                # Get CŒ± atom
                ca_atom = None
                for atom in residue:
                    if atom.name == 'CA':
                        ca_atom = atom
                        break

                if ca_atom is None:
                    continue

                # Count atoms within 10√Ö radius
                neighbors = ns.search(ca_atom.coord, pocket_threshold)

                # Few neighboring atoms = exposed to surface
                if len(neighbors) &lt; 30:  # Empirical threshold
                    surface_residues.append({
                        'residue_number': residue.id[1],
                        'residue_name': residue.resname,
                        'chain': chain.id,
                        'neighbors': len(neighbors),
                        'coord': ca_atom.coord
                    })

    # Group pockets by clustering
    pocket_candidates = cluster_surface_residues(surface_residues)

    print(f&quot;‚úì Detected {len(pocket_candidates)} pocket candidates&quot;)
    for i, pocket in enumerate(pocket_candidates, 1):
        print(f&quot;  Pocket {i}: {len(pocket)} residues&quot;)

    return pocket_candidates

def cluster_surface_residues(surface_residues, distance_cutoff=8.0):
    &quot;&quot;&quot;Cluster surface residues to identify pockets&quot;&quot;&quot;
    if not surface_residues:
        return []

    # Calculate distance matrix
    coords = np.array([r['coord'] for r in surface_residues])
    n = len(coords)

    # Simple clustering (for practical use, use DBSCAN etc.)
    visited = set()
    pockets = []

    for i in range(n):
        if i in visited:
            continue

        pocket = [surface_residues[i]]
        visited.add(i)
        queue = [i]

        while queue:
            current = queue.pop(0)
            current_coord = coords[current]

            for j in range(n):
                if j in visited:
                    continue

                distance = np.linalg.norm(current_coord - coords[j])
                if distance &lt; distance_cutoff:
                    pocket.append(surface_residues[j])
                    visited.add(j)
                    queue.append(j)

        if len(pocket) &gt;= 5:  # Minimum pocket size
            pockets.append(pocket)

    # Sort by size
    pockets.sort(key=len, reverse=True)

    return pockets

# Usage example
# pockets = detect_binding_pockets('AF-P00533-F1-model_v4.pdb')

# Expected output:
# ‚úì Detected 3 pocket candidates
#   Pocket 1: 23 residues
#   Pocket 2: 15 residues
#   Pocket 3: 8 residues
</code></pre>
<h3>5.3.3 Applications in Materials Science</h3>
<p>Proteins are natural functional materials. AlphaFold is accelerating biomaterial design.</p>
<p><strong>Application Examples:</strong></p>
<ol>
<li>
<p><strong>Enzyme Engineering</strong>:
   - Structure prediction of industrial enzymes
   - Active site modification design
   - Stability improvement (thermal stability, pH stability)</p>
</li>
<li>
<p><strong>Biosensors</strong>:
   - Fluorescent protein structure optimization
   - Binding domain design</p>
</li>
<li>
<p><strong>Nanomaterials</strong>:
   - Protein nanoparticle design
   - Self-assembling materials</p>
</li>
</ol>
<pre><code class="language-python"># ===================================
# Example 6: Structural Similarity Comparison
# ===================================

from Bio.PDB import PDBParser, Superimposer
import numpy as np

def calculate_rmsd(pdb1, pdb2):
    &quot;&quot;&quot;Calculate RMSD between two protein structures

    RMSD (Root Mean Square Deviation) is a metric indicating
    structural similarity. Smaller values = more similar.

    Interpretation:
    - RMSD &lt; 2√Ö: Very similar (nearly identical)
    - RMSD 2-5√Ö: Similar (same fold)
    - RMSD &gt; 10√Ö: Different structures

    Args:
        pdb1, pdb2 (str): PDB file paths

    Returns:
        float: RMSD value [√Ö]
    &quot;&quot;&quot;
    parser = PDBParser(QUIET=True)
    structure1 = parser.get_structure('s1', pdb1)
    structure2 = parser.get_structure('s2', pdb2)

    # Extract CŒ± atoms only
    atoms1 = []
    atoms2 = []

    for model in structure1:
        for chain in model:
            for residue in chain:
                if 'CA' in residue:
                    atoms1.append(residue['CA'])

    for model in structure2:
        for chain in model:
            for residue in chain:
                if 'CA' in residue:
                    atoms2.append(residue['CA'])

    # Match atom count (align to shorter one)
    min_length = min(len(atoms1), len(atoms2))
    atoms1 = atoms1[:min_length]
    atoms2 = atoms2[:min_length]

    # Superimpose structures
    super_imposer = Superimposer()
    super_imposer.set_atoms(atoms1, atoms2)

    rmsd = super_imposer.rms

    print(f&quot;Structure Comparison:&quot;)
    print(f&quot;  PDB1: {pdb1}&quot;)
    print(f&quot;  PDB2: {pdb2}&quot;)
    print(f&quot;  RMSD: {rmsd:.2f} √Ö&quot;)

    if rmsd &lt; 2.0:
        print(&quot;  ‚Üí Very similar (nearly identical)&quot;)
    elif rmsd &lt; 5.0:
        print(&quot;  ‚Üí Similar (same fold)&quot;)
    else:
        print(&quot;  ‚Üí Different structures&quot;)

    return rmsd

def compare_alphafold_vs_experimental(alphafold_pdb, experimental_pdb):
    &quot;&quot;&quot;Validate AlphaFold prediction vs experimental structure&quot;&quot;&quot;
    rmsd = calculate_rmsd(alphafold_pdb, experimental_pdb)

    # Simple GDT score calculation
    # (Actual GDT involves more complex calculations)
    if rmsd &lt; 1.0:
        gdt_estimate = 95
    elif rmsd &lt; 2.0:
        gdt_estimate = 85
    elif rmsd &lt; 4.0:
        gdt_estimate = 70
    else:
        gdt_estimate = 50

    print(f&quot;  Estimated GDT score: {gdt_estimate}&quot;)

    return rmsd, gdt_estimate

# Usage example
# rmsd, gdt = compare_alphafold_vs_experimental(
#     'AF-P00533-F1-model_v4.pdb',
#     'experimental_structure.pdb'
# )

# Expected output:
# Structure Comparison:
#   PDB1: AF-P00533-F1-model_v4.pdb
#   PDB2: experimental_structure.pdb
#   RMSD: 1.8 √Ö
#   ‚Üí Very similar (nearly identical)
#   Estimated GDT score: 85
</code></pre>
<hr />
<h2>5.4 Limitations and Future Prospects of AlphaFold</h2>
<h3>5.4.1 Current Limitations</h3>
<p>While AlphaFold is revolutionary, it has the following constraints:</p>
<p><strong>üí° Pro Tip:</strong>
Understanding AlphaFold's limitations and combining it appropriately with experimental methods is crucial.</p>
<table>
<thead>
<tr>
<th>Limitation</th>
<th>Details</th>
<th>Alternative Methods</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Flexible Regions</strong></td>
<td>Low accuracy for intrinsically disordered regions (IDPs)</td>
<td>NMR, SAXS</td>
</tr>
<tr>
<td><strong>Complexes</strong></td>
<td>Inaccurate for protein-ligand complexes</td>
<td>X-ray crystallography, Cryo-EM</td>
</tr>
<tr>
<td><strong>Dynamic Behavior</strong></td>
<td>Predicts only one static structure</td>
<td>Molecular Dynamics (MD) simulation</td>
</tr>
<tr>
<td><strong>Post-translational Modifications</strong></td>
<td>Does not account for phosphorylation, glycosylation, etc.</td>
<td>Experimental validation essential</td>
</tr>
<tr>
<td><strong>Novel Folds</strong></td>
<td>Accuracy degrades with insufficient MSA</td>
<td>De novo structure prediction, experiments</td>
</tr>
</tbody>
</table>
<p><strong>Example (Real Case):</strong>
Many transcription factors fold upon DNA binding (coupled folding and binding). Since they exist in an intrinsically disordered state alone, accurate structure prediction with AlphaFold is difficult.</p>
<h3>5.4.2 Evolution of AlphaFold 3</h3>
<p>AlphaFold 3, announced in 2024, added the following capabilities:</p>
<p><strong>New Features:</strong>
- <strong>Complex Prediction</strong>: Protein-DNA, protein-RNA, protein-ligand
- <strong>Covalent Modifications</strong>: Support for some phosphorylation and glycosylation
- <strong>Metal Ions</strong>: Consideration of metal coordination in active sites</p>
<p><strong>Evolution by the Numbers:</strong>
- Protein-ligand complex accuracy: 67% ‚Üí 76% (CASP15)
- Protein-nucleic acid complexes: Newly supported (previously impossible)
- Computational speed: ~2x faster than AlphaFold 2</p>
<pre><code class="language-python"># ===================================
# Example 7: Utilizing the AlphaFold Database API
# ===================================

import requests
import json

def search_alphafold_database(query, organism=None):
    &quot;&quot;&quot;Search AlphaFold Database by UniProt ID

    Args:
        query (str): Protein name or UniProt ID
        organism (str): Species (optional, e.g., 'human')

    Returns:
        list: List of search results
    &quot;&quot;&quot;
    # Search with UniProt API
    uniprot_url = &quot;https://rest.uniprot.org/uniprotkb/search&quot;
    params = {
        'query': query,
        'format': 'json',
        'size': 10
    }

    if organism:
        params['query'] += f&quot; AND organism_name:{organism}&quot;

    response = requests.get(uniprot_url, params=params)

    if response.status_code != 200:
        print(f&quot;‚úó Search failed: {response.status_code}&quot;)
        return []

    results = response.json()

    alphafold_entries = []

    for entry in results.get('results', []):
        uniprot_id = entry['primaryAccession']
        protein_name = entry['proteinDescription']['recommendedName']['fullName']['value']
        organism_name = entry['organism']['scientificName']
        sequence_length = entry['sequence']['length']

        # Construct AlphaFold URLs
        alphafold_url = f&quot;https://alphafold.ebi.ac.uk/entry/{uniprot_id}&quot;
        pdb_url = f&quot;https://alphafold.ebi.ac.uk/files/AF-{uniprot_id}-F1-model_v4.pdb&quot;

        alphafold_entries.append({
            'uniprot_id': uniprot_id,
            'protein_name': protein_name,
            'organism': organism_name,
            'length': sequence_length,
            'alphafold_url': alphafold_url,
            'pdb_url': pdb_url
        })

    # Display results
    print(f&quot;‚úì Found {len(alphafold_entries)} entries\n&quot;)
    for i, entry in enumerate(alphafold_entries, 1):
        print(f&quot;{i}. {entry['protein_name']}&quot;)
        print(f&quot;   UniProt: {entry['uniprot_id']}&quot;)
        print(f&quot;   Species: {entry['organism']}&quot;)
        print(f&quot;   Length: {entry['length']} aa&quot;)
        print(f&quot;   AlphaFold: {entry['alphafold_url']}\n&quot;)

    return alphafold_entries

# Usage example
results = search_alphafold_database(&quot;p53&quot;, organism=&quot;human&quot;)

# Expected output:
# ‚úì Found 3 entries
#
# 1. Cellular tumor antigen p53
#    UniProt: P04637
#    Species: Homo sapiens
#    Length: 393 aa
#    AlphaFold: https://alphafold.ebi.ac.uk/entry/P04637
#
# 2. Tumor protein p53-inducible protein 11
#    UniProt: Q9BVI4
#    Species: Homo sapiens
#    Length: 236 aa
#    AlphaFold: https://alphafold.ebi.ac.uk/entry/Q9BVI4
</code></pre>
<pre><code class="language-python"># ===================================
# Example 8: Integrated Workflow for AlphaFold Prediction
# ===================================

import requests
import numpy as np
from Bio.PDB import PDBParser
from io import StringIO

class AlphaFoldAnalyzer:
    &quot;&quot;&quot;Comprehensive analysis class for AlphaFold structures&quot;&quot;&quot;

    def __init__(self, uniprot_id):
        &quot;&quot;&quot;
        Args:
            uniprot_id (str): UniProt ID
        &quot;&quot;&quot;
        self.uniprot_id = uniprot_id
        self.structure = None
        self.plddt_scores = None

    def download_structure(self):
        &quot;&quot;&quot;Download structure&quot;&quot;&quot;
        url = f&quot;https://alphafold.ebi.ac.uk/files/AF-{self.uniprot_id}-F1-model_v4.pdb&quot;

        try:
            response = requests.get(url, timeout=10)
            response.raise_for_status()

            parser = PDBParser(QUIET=True)
            self.structure = parser.get_structure(
                self.uniprot_id,
                StringIO(response.text)
            )

            print(f&quot;‚úì Structure download successful: {self.uniprot_id}&quot;)
            return True

        except Exception as e:
            print(f&quot;‚úó Download failed: {e}&quot;)
            return False

    def extract_plddt(self):
        &quot;&quot;&quot;Extract pLDDT scores&quot;&quot;&quot;
        if self.structure is None:
            print(&quot;‚úó Structure not downloaded&quot;)
            return None

        plddt = []
        for model in self.structure:
            for chain in model:
                for residue in chain:
                    for atom in residue:
                        if atom.name == 'CA':
                            plddt.append(atom.bfactor)
                            break

        self.plddt_scores = np.array(plddt)
        return self.plddt_scores

    def assess_quality(self):
        &quot;&quot;&quot;Assess prediction quality&quot;&quot;&quot;
        if self.plddt_scores is None:
            self.extract_plddt()

        mean_plddt = np.mean(self.plddt_scores)
        very_high = np.sum(self.plddt_scores &gt; 90) / len(self.plddt_scores) * 100
        confident = np.sum((self.plddt_scores &gt;= 70) &amp; (self.plddt_scores &lt;= 90)) / len(self.plddt_scores) * 100
        low = np.sum(self.plddt_scores &lt; 70) / len(self.plddt_scores) * 100

        quality_report = {
            'mean_plddt': mean_plddt,
            'very_high_pct': very_high,
            'confident_pct': confident,
            'low_pct': low,
            'overall_quality': self._get_quality_label(mean_plddt)
        }

        print(&quot;\nQuality Assessment Report:&quot;)
        print(f&quot;  Mean pLDDT: {mean_plddt:.2f}&quot;)
        print(f&quot;  Very high (&gt;90): {very_high:.1f}%&quot;)
        print(f&quot;  Confident (70-90): {confident:.1f}%&quot;)
        print(f&quot;  Low (&lt;70): {low:.1f}%&quot;)
        print(f&quot;  Overall assessment: {quality_report['overall_quality']}&quot;)

        return quality_report

    def _get_quality_label(self, mean_plddt):
        &quot;&quot;&quot;Overall quality label&quot;&quot;&quot;
        if mean_plddt &gt; 90:
            return &quot;Excellent (experimental level)&quot;
        elif mean_plddt &gt; 80:
            return &quot;Very good (suitable for modeling)&quot;
        elif mean_plddt &gt; 70:
            return &quot;Good (use with caution)&quot;
        else:
            return &quot;Poor (unreliable)&quot;

    def find_flexible_regions(self, threshold=70):
        &quot;&quot;&quot;Detect highly flexible regions (low pLDDT)&quot;&quot;&quot;
        if self.plddt_scores is None:
            self.extract_plddt()

        flexible_regions = []
        in_region = False
        start = None

        for i, score in enumerate(self.plddt_scores):
            if score &lt; threshold and not in_region:
                start = i + 1  # 1-indexed
                in_region = True
            elif score &gt;= threshold and in_region:
                flexible_regions.append((start, i))
                in_region = False

        if in_region:
            flexible_regions.append((start, len(self.plddt_scores)))

        print(f&quot;\nFlexible regions (pLDDT &lt; {threshold}):&quot;)
        if flexible_regions:
            for start, end in flexible_regions:
                length = end - start + 1
                print(f&quot;  Residues {start}-{end} ({length} residues)&quot;)
        else:
            print(&quot;  None (high rigidity overall)&quot;)

        return flexible_regions

    def get_summary(self):
        &quot;&quot;&quot;Comprehensive summary&quot;&quot;&quot;
        if self.structure is None:
            self.download_structure()

        # Basic info
        num_residues = len(list(self.structure.get_residues()))

        # Quality assessment
        quality = self.assess_quality()

        # Flexible regions
        flexible = self.find_flexible_regions()

        summary = {
            'uniprot_id': self.uniprot_id,
            'num_residues': num_residues,
            'quality': quality,
            'flexible_regions': flexible
        }

        return summary

# Usage example
analyzer = AlphaFoldAnalyzer(&quot;P00533&quot;)  # EGFR
summary = analyzer.get_summary()

# Expected output:
# ‚úì Structure download successful: P00533
#
# Quality Assessment Report:
#   Mean pLDDT: 84.32
#   Very high (&gt;90): 58.2%
#   Confident (70-90): 34.1%
#   Low (&lt;70): 7.7%
#   Overall assessment: Very good (suitable for modeling)
#
# Flexible regions (pLDDT &lt; 70):
#   Residues 1-24 (24 residues)
#   Residues 312-335 (24 residues)
</code></pre>
<h3>5.4.3 Future Prospects</h3>
<p><strong>Research Directions:</strong></p>
<ol>
<li>
<p><strong>Dynamic Structure Prediction</strong>:
   - From one static structure ‚Üí multiple conformations
   - Allosteric change prediction
   - Integration with molecular dynamics</p>
</li>
<li>
<p><strong>Applications in Design</strong>:
   - Inverse problem: Design amino acid sequence from desired structure
   - Combination with RFdiffusion, ProteinMPNN, etc.
   - De novo protein design</p>
</li>
<li>
<p><strong>Multimodal Integration</strong>:
   - Integration with Cryo-EM density maps
   - Utilization of NMR data
   - Fusion with mass spectrometry data</p>
</li>
</ol>
<p><strong>Predicted Industrial Impact (2030):</strong>
- Drug development timeline: Average 10 years ‚Üí 3-5 years
- Application range of structure-based drug discovery: 30% ‚Üí 80%
- New protein materials: 10 types/year ‚Üí 100+ types</p>
<hr />
<h2>Learning Objectives Review</h2>
<p>Upon completing this chapter, you will be able to explain the following:</p>
<h3>Basic Understanding</h3>
<ul>
<li>‚úÖ Explain the significance of GDT 92.4 achieved by AlphaFold at CASP14</li>
<li>‚úÖ Understand why the protein folding problem was a "50-year challenge"</li>
<li>‚úÖ Interpret pLDDT scores (&gt;90=experimental level, 70-90=suitable for modeling, &lt;70=low confidence)</li>
<li>‚úÖ Explain why MSA (Multiple Sequence Alignment) is crucial for structure prediction</li>
<li>‚úÖ Quantify AlphaFold's industrial impact (drug discovery timeline reduction, cost savings)</li>
</ul>
<h3>Practical Skills</h3>
<ul>
<li>‚úÖ Download any protein structure from the AlphaFold Database</li>
<li>‚úÖ Extract pLDDT scores and evaluate prediction quality</li>
<li>‚úÖ Visualize protein structures in 3D and color-code by confidence</li>
<li>‚úÖ Compare AlphaFold predictions with experimental structures using RMSD calculations</li>
<li>‚úÖ Detect binding pockets and identify drug targets</li>
<li>‚úÖ Perform structure predictions for new sequences using ColabFold</li>
</ul>
<h3>Application Capabilities</h3>
<ul>
<li>‚úÖ Utilize AlphaFold at each stage of drug discovery projects (target identification, docking, optimization)</li>
<li>‚úÖ Understand AlphaFold's limitations (flexible regions, complexes, dynamic behavior) and combine with experimental methods</li>
<li>‚úÖ Apply AlphaFold to biomaterial design (enzyme engineering, biosensors)</li>
<li>‚úÖ Develop concrete plans for utilizing AlphaFold in your research field</li>
</ul>
<hr />
<h2>Exercises</h2>
<h3>Easy (Fundamentals)</h3>
<p><strong>Q1</strong>: What GDT (Global Distance Test) score did AlphaFold 2 achieve at CASP14?</p>
<p>a) 60.5
b) 75.3
c) 92.4
d) 98.7</p>
<details>
<summary>View Answer</summary>

**Correct Answer**: c) 92.4

**Explanation**:
AlphaFold 2 achieved **GDT 92.4/100** at CASP14 in 2020, marking historic success.

Reference:
- Previous best score: ~60-70 points
- Experimental methods (X-ray crystallography): ~90 points
- AlphaFold 2: 92.4 points (reached experimental level)

This result led to the assessment that the protein structure prediction problem was "essentially solved" (statement from Nature editors).

</details>

<hr />
<p><strong>Q2</strong>: A residue with a pLDDT (predicted Local Distance Difference Test) score of 85 falls into which category?</p>
<p>a) Very high (equivalent to experimental structure)
b) Confident (suitable for modeling)
c) Low (possible flexible region)
d) Very low (unreliable)</p>
<details>
<summary>View Answer</summary>

**Correct Answer**: b) Confident (suitable for modeling)

**Explanation**:
pLDDT score interpretation criteria:

| Score Range | Category | Meaning |
|----------|---------|-----|
| **pLDDT > 90** | Very high | Accuracy equivalent to experimental structures |
| **pLDDT 70-90** | Confident | Suitable for modeling ‚Üê 85 falls here |
| **pLDDT 50-70** | Low | Possible flexible region |
| **pLDDT < 50** | Very low | Unreliable |

pLDDT=85 is in the "Confident" category and can be used sufficiently for structure modeling (docking, mutation analysis, etc.). However, experimental validation may be recommended in some cases.

</details>

<hr />
<p><strong>Q3</strong>: What is required as input for AlphaFold?</p>
<p>a) 3D structure of the protein
b) Amino acid sequence only
c) X-ray diffraction data
d) Electron microscopy images</p>
<details>
<summary>View Answer</summary>

**Correct Answer**: b) Amino acid sequence only

**Explanation**:
AlphaFold's greatest advantage is that it can predict 3D structure (tertiary structure) from **amino acid sequence (primary structure) alone**.

Input example:

<pre><code>MKFLAIVSLLFLLTSQCVLLNRTCKDINTFIHGN...
</code></pre>


AlphaFold processing flow:
1. Input: Amino acid sequence
2. MSA generation: Search for homologous sequences from databases
3. Evoformer: Extract structural information via attention mechanism
4. Structure Module: Predict 3D coordinates
5. Output: PDB file (3D structure + pLDDT scores)

While conventional methods (X-ray crystallography, Cryo-EM) require actual protein samples, AlphaFold can predict structures through computation alone.

</details>

<hr />
<h3>Medium (Application)</h3>
<p><strong>Q4</strong>: Conventional methods took an average of 3-5 years and $120,000 to determine one protein structure. Estimate the time and cost for the same structure prediction using AlphaFold.</p>
<details>
<summary>View Answer</summary>

**Estimated Results**:
- **Time**: Minutes to 1 hour (>99.9% reduction)
- **Cost**: Nearly free (GPU computation cost only, approximately $1-10)

**Calculation Basis**:

**Time Reduction:**
- Conventional: 3-5 years (average 4 years = 35,040 hours)
- AlphaFold: 10-60 minutes (average 30 minutes = 0.5 hours)
- Reduction rate: (35,040 - 0.5) / 35,040 √ó 100 = **99.999%**

**Cost Reduction:**
- Conventional: $120,000 (researcher personnel costs, equipment, crystallization reagents, etc.)
- AlphaFold: $1-10 (Google Colab GPU usage fee, or own GPU electricity cost)
- Reduction rate: (120,000 - 5) / 120,000 √ó 100 = **99.996%**

**Important Points:**
This dramatic efficiency improvement fundamentally changed the research cycle in drug discovery and materials science:

- **Before (Conventional)**: Experimentally determine 1-2 structures per project
- **After (AlphaFold)**: Can predict structures for entire genome (20,000 proteins) at once

</details>

<hr />
<p><strong>Q5</strong>: Comparing an AlphaFold predicted structure with an experimental structure (X-ray crystallography) yielded RMSD = 3.2 √Ö. Evaluate the quality of this prediction.</p>
<details>
<summary>View Answer</summary>

**Assessment**: **Good - Same fold, suitable for modeling**

**RMSD (Root Mean Square Deviation) Interpretation:**

| RMSD Range | Assessment | Meaning |
|--------|------|-----|
| < 2√Ö | Excellent | Nearly identical structure |
| 2-5√Ö | Good | Same fold ‚Üê 3.2√Ö falls here |
| 5-10√Ö | Moderate | Partially similar |
| > 10√Ö | Poor | Different structures |

**Practical Applications of RMSD = 3.2√Ö:**

‚úÖ **Suitable Applications:**
- Docking simulations (if active site is high precision)
- Mutation effect prediction
- Protein-protein interaction analysis
- Functional domain identification

‚ö†Ô∏è **Applications Requiring Caution:**
- High-precision drug design (RMSD < 2√Ö desirable)
- Detailed enzymatic catalytic mechanism analysis
- Crystallization condition prediction

**Real Example:**
The average RMSD for AlphaFold 2 at CASP14 was approximately 1.5-2.0√Ö. RMSD = 3.2√Ö is slightly less accurate but sufficient for many applications.

</details>

<hr />
<p><strong>Q6</strong>: What are "Intrinsically Disordered Proteins (IDPs)" that AlphaFold struggles with? Also, why is prediction difficult for AlphaFold?</p>
<details>
<summary>View Answer</summary>

**What are Intrinsically Disordered Regions (IDPs):**
Protein regions that do not have a fixed 3D structure and move flexibly.

**Characteristics:**
- ~30-40% of all proteins contain IDPs
- Functions: Transcriptional regulation, signal transduction, molecular recognition
- Examples: N-terminal region of p53, tau protein

**Why AlphaFold Struggles:**

1. **MSA Limitations**:
   - IDPs have low evolutionary conservation
   - Large sequence variation ‚Üí unclear coevolution patterns

2. **Structural Diversity**:
   - One sequence adopts multiple conformations
   - AlphaFold can only output one static structure

3. **Training Data Bias**:
   - PDB (Protein Data Bank) contains mostly structured proteins
   - Few experimental IDP structures available

**Identification by pLDDT Score:**
IDP regions often have pLDDT < 70, signaling "difficult to predict."

**Alternative Methods:**
- NMR spectroscopy: Observes dynamic structures in solution
- SAXS (Small-Angle X-ray Scattering): Measures average shape
- Molecular dynamics simulation: Simulates dynamic behavior

</details>

<hr />
<h3>Hard (Advanced)</h3>
<p><strong>Q7</strong>: You are planning a drug discovery project using AlphaFold. Among the following three target proteins, which is most suitable? Explain with reasoning.</p>
<ul>
<li><strong>Target A</strong>: GPCR protein (7-transmembrane), membrane protein, 380 residues</li>
<li><strong>Target B</strong>: Kinase (soluble), globular structure, 295 residues, multiple homologs available</li>
<li><strong>Target C</strong>: Transcription factor (DNA-binding domain + intrinsically disordered region), 520 residues</li>
</ul>
<details>
<summary>View Answer</summary>

**Optimal Target**: **Target B (Kinase)**

**Detailed Evaluation:**

**Target A (GPCR Protein)**: ‚ö†Ô∏è **Moderate Suitability**
- **Advantages**:
  - AlphaFold 2 can predict membrane proteins to some extent
  - Important as drug targets (~30% of approved drugs target GPCRs)
- **Challenges**:
  - Slightly lower accuracy in transmembrane regions (pLDDT 70-80)
  - Large structural changes upon ligand binding (allosteric effects)
  - Cannot capture differences between active/inactive states in one structure
- **Recommendation**: Combine AlphaFold prediction + experimental structures (X-ray, Cryo-EM)

**Target B (Kinase)**: ‚úÖ **Most Optimal**
- **Advantages**:
  - Soluble protein ‚Üí high-accuracy prediction (expect pLDDT > 90)
  - Globular structure ‚Üí AlphaFold's strength
  - Multiple homologs available ‚Üí rich MSA, improved accuracy
  - Kinase family has high structural conservation
  - Clear ATP-binding pocket ‚Üí ideal for docking studies
- **Track Record**:
  - Insilico Medicine success story (DDR1 kinase, 2019)
  - Identified clinical candidate compound in 18 months based on AlphaFold prediction
- **Workflow**:
  1. AlphaFold prediction (expect pLDDT > 90)
  2. Pocket detection (Fpocket)
  3. Docking (AutoDock Vina)
  4. Lead compound optimization

**Target C (Transcription Factor)**: ‚ùå **Unsuitable**
- **Challenges**:
  - Intrinsically disordered region ‚Üí difficult for AlphaFold (pLDDT < 50)
  - Folds upon DNA binding (coupled folding and binding)
  - Structure not defined alone
- **Alternative Methods**:
  - Need experimental structure of transcription factor-DNA complex
  - Utilize AlphaFold 3 (complex prediction capability)
  - Experimental methods like NMR, Cryo-EM

**Conclusion:**
Target B is most suitable. With three conditions met‚Äîsoluble, globular, rich MSA‚Äîit maximizes AlphaFold's strengths. In actual drug discovery projects, this type of target has the most AlphaFold success stories.

</details>

<hr />
<p><strong>Q8</strong>: How did AlphaFold contribute during the COVID-19 pandemic (2020)? Explain the specific timeline and impact.</p>
<details>
<summary>View Answer</summary>

**AlphaFold's COVID-19 Contributions:**

**Timeline:**

| Date | Event | AlphaFold Contribution |
|-----|---------|-------------|
| January 2020 | SARS-CoV-2 sequence published | - |
| February 2020 | DeepMind publishes structure predictions | **Predicted 6 structures including spike protein** |
| March 2020 | Experimental structure determination begins | AlphaFold predictions support experimental design |
| May 2020 | Experimental structures published (PDB) | **High agreement with AlphaFold predictions (RMSD < 2√Ö)** |
| December 2020 | Vaccine approval | Structural information accelerated antibody design |

**Specific Contributions:**

1. **Providing Initial Structural Information (February 2020)**:
   - Predicted spike protein structure within days of sequence release
   - Conventional methods expected to take several months ‚Üí **3-6 month time savings**

2. **Validation of Prediction Accuracy (May 2020)**:
   - When experimental structure (Cryo-EM) was published, verified agreement with AlphaFold prediction
   - RMSD < 2√Ö ‚Üí nearly experimental-level accuracy
   - This established trust in AlphaFold

3. **Applications in Therapeutic Development**:
   - **Mpro (Main protease)**: Antiviral drug target
     - AlphaFold structure ‚Üí Docking ‚Üí Contributed to Paxlovid (Pfizer) development
   - **Spike protein**: Neutralizing antibody design
     - ACE2 binding domain structure ‚Üí Antibody therapeutic development

**Impact by the Numbers:**

- **Research Papers**: ~15% of 2020 SARS-CoV-2 structure papers cited AlphaFold predictions
- **Time Savings**: Target structure determination 6 months ‚Üí days (99% reduction)
- **Accessibility**: Free public release enabled immediate use by researchers worldwide

**Important Lesson:**

> "AlphaFold demonstrated that in emergencies like pandemics, it can provide initial structural information without waiting for experimental methods. This has the potential to fundamentally change responses to future public health crises."
>
> ‚Äî Dr. Janet Thornton (Director, European Bioinformatics Institute)

**Limitations Also Revealed:**
- Spike-antibody complex predictions were inaccurate (AlphaFold 2 limitation)
- High responsiveness to variant strains (Omicron, etc.) but limitations in immune escape prediction
- Experimental validation remains essential

</details>

<hr />
<p><strong>Q9</strong>: You need to improve the thermal stability of a cellulase in an enzyme engineering project. How would you utilize AlphaFold? Design a workflow in 5 steps.</p>
<details>
<summary>View Answer</summary>

**AlphaFold Workflow for Enzyme Thermal Stability Improvement:**

**Step 1: Wild-Type Enzyme Structure Prediction and Quality Assessment**

<pre><code class="language-python"># Retrieve structure from AlphaFold Database
structure = download_alphafold_structure(&quot;P12345&quot;)  # UniProt ID

# pLDDT analysis
plddt_scores = extract_plddt_scores(structure)
mean_plddt = np.mean(plddt_scores)

# Quality determination
if mean_plddt &gt; 80:
    print(&quot;‚úì High-quality prediction ‚Üí Suitable for design&quot;)
else:
    print(&quot;‚ö†Ô∏è Low quality ‚Üí Combination with experimental structure recommended&quot;)
</code></pre>


**Expected Result**: Mean pLDDT 85 (Very good)

---

**Step 2: Identification of Flexible Regions**

<pre><code class="language-python"># Factors reducing thermal stability = flexible regions
flexible_regions = find_flexible_regions(plddt_scores, threshold=70)

# Also check regions with high B-factor (temperature factor)
high_bfactor_residues = identify_high_bfactor(structure, cutoff=50)

# Results
# ‚Üí Residues 45-52, 123-135 are flexible (pLDDT &lt; 70)
</code></pre>


**Interpretation**: These regions are prone to structural collapse at high temperatures

---

**Step 3: Mutation Candidate Design**

**Strategies:**
1. **Introduce disulfide bonds**: Fix flexible regions
2. **Introduce Pro**: Rigidify loops
3. **Form salt bridges**: Stabilize via electrostatic interactions
4. **Strengthen hydrophobic core**: Improve internal packing


<pre><code class="language-python"># Example: Introduce disulfide bond in residues 45-52
# Identify appropriate Cys introduction positions by distance calculation
candidate_mutations = [
    &quot;A45C&quot;,  # Mutate residue 45 from Ala to Cys
    &quot;L52C&quot;,  # Mutate residue 52 from Leu to Cys
    # Distance: 5.8√Ö ‚Üí disulfide bond formation possible
]
</code></pre>


---

**Step 4: Mutant Structure Prediction**

**‚ö†Ô∏è Note**: Since AlphaFold is trained on wild-type sequences, mutant prediction accuracy is not guaranteed. For small mutations (1-3 residues), it's relatively reliable, but be cautious with large-scale mutations.


<pre><code class="language-python"># Create mutant sequence
mutant_sequence = apply_mutations(wt_sequence, candidate_mutations)

# Structure prediction with AlphaFold (ColabFold or local execution)
mutant_structure = alphafold_predict(mutant_sequence)

# Structure comparison
rmsd = calculate_rmsd(wt_structure, mutant_structure)
print(f&quot;Structural change: RMSD = {rmsd:.2f} √Ö&quot;)

# Expected: RMSD &lt; 2√Ö (small change)
</code></pre>


---

**Step 5: Validation with Molecular Dynamics (MD) Simulation**

AlphaFold provides only static structures. Dynamic simulation is needed to evaluate thermal stability.


<pre><code class="language-python"># MD simulation with GROMACS etc.
# Gradually increase temperature (300K ‚Üí 350K ‚Üí 400K)

temperatures = [300, 350, 400]  # K
rmsd_stability = {}

for temp in temperatures:
    # 10ns simulation at each temperature
    trajectory = run_md_simulation(mutant_structure, temp, time=10)

    # RMSD time evolution
    rmsd_vs_time = calculate_rmsd_trajectory(trajectory)

    # Average RMSD (last 5ns)
    avg_rmsd = np.mean(rmsd_vs_time[5000:])
    rmsd_stability[temp] = avg_rmsd

# Comparison results
# Wild-type: 300K (2.1√Ö), 350K (4.5√Ö), 400K (8.2√Ö) ‚Üí structural collapse
# Mutant: 300K (2.0√Ö), 350K (2.8√Ö), 400K (4.1√Ö) ‚Üí Improved!
</code></pre>


**Final Determination:**
- Mutant A45C/L52C confirms thermal stability improvement in MD
- Experimental validation (DSC: Differential Scanning Calorimetry) to measure melting temperature Tm
- Wild-type Tm = 65¬∞C ‚Üí Mutant Tm = 78¬∞C (+13¬∞C improvement)

---

**Summary:**

| Step | Method | Objective | Time |
|--------|------|-----|------|
| 1 | AlphaFold prediction | Obtain structural information | 30 min |
| 2 | pLDDT/B-factor analysis | Identify flexible regions | 1 hour |
| 3 | Computational mutation design | Candidate mutation list | 2 hours |
| 4 | AlphaFold mutant prediction | Structural confirmation | 1 hour |
| 5 | MD simulation | Dynamic validation | 24 hours |

**Total: ~2-3 days** (Conventional experimental approach: 3-6 months)

**Important Point:**
AlphaFold alone is insufficient. The combination of MD simulation and experimental validation is key.

</details>

<hr />
<p><strong>Q10</strong>: What new capabilities were added to AlphaFold 3 (announced in 2024) compared to AlphaFold 2? Also, provide two examples of new applications enabled by this evolution.</p>
<details>
<summary>View Answer</summary>

**AlphaFold 3 New Features:**

### 1. **Expanded Complex Prediction**

**AlphaFold 2 Limitations:**
- Could only predict single proteins
- Inaccurate for protein-ligand complexes

**AlphaFold 3 Evolution:**
- Protein-DNA complexes
- Protein-RNA complexes
- Protein-small molecule ligand complexes
- Protein-protein complexes (with higher accuracy)

**Improvement by the Numbers:**
- Protein-ligand complex accuracy: 67% ‚Üí **76%** (CASP15)
- Protein-DNA complexes: Newly supported (previously impossible)

---

### 2. **Support for Covalent Modifications**

**Newly Supported Modifications:**
- Phosphorylation (Ser, Thr, Tyr)
- Some glycosylation (N-glycosylation, O-glycosylation)
- Methylation, acetylation (histone modifications)
- Ubiquitination

**Importance:**
Post-translational modifications are essential for protein function regulation in living organisms. For example, kinase activation requires phosphorylation.

---

### 3. **Consideration of Metal Ions**

**Supported Metals:**
- Zn¬≤‚Å∫ (zinc fingers)
- Fe¬≤‚Å∫/Fe¬≥‚Å∫ (heme)
- Mg¬≤‚Å∫ (enzyme active sites)
- Ca¬≤‚Å∫ (EF hands)

**Example (Real Case):**
Zinc finger proteins (transcription factors) cannot form structures without Zn¬≤‚Å∫. AlphaFold 2 ignored this, but AlphaFold 3 explicitly models metal coordination.

---

### 4. **Improved Computational Speed**

- Approximately **2x faster** than AlphaFold 2
- Reduced memory usage
- Support for longer sequences (>3000 residues)

---

**New Application Examples:**

### Application Example 1: **Transcription Factor-DNA Complex Structure Prediction ‚Üí Improved Genome Editing Precision**

**Background:**
Genome editing tools like CRISPR-Cas9 recognize and bind specific DNA sequences. However, off-target effects (binding to unintended locations) were problematic.

**AlphaFold 3 Application:**

<pre><code class="language-python"># Predict Cas9 protein + guide RNA + target DNA complex
complex_structure = alphafold3_predict(
    protein_seq=&quot;MDKKYSIGLDIG...&quot;,  # Cas9 sequence
    rna_seq=&quot;GUUUUAGAGCUA...&quot;,      # Guide RNA
    dna_seq=&quot;ATCGATCGATCG...&quot;       # Target DNA
)

# Evaluate binding specificity
binding_affinity = calculate_binding_energy(complex_structure)

# Compare multiple candidate sequences
# ‚Üí Confirm weak binding to off-target sequences
</code></pre>


**Achievements:**
- Improved off-target effect prediction accuracy
- More specific guide RNA design
- Enhanced gene therapy safety

**Real Example:**
Intellia Therapeutics (genome editing company) used AlphaFold 3 to improve CRISPR therapy specificity, reporting favorable clinical trial results (2024).

---

### Application Example 2: **Protein-Ligand Complex Prediction in Drug Discovery ‚Üí Improved Docking Accuracy**

**Background:**
Conventional docking software (AutoDock Vina, etc.) fixes protein structure and moves only the ligand. However, **induced fit** actually occurs, with the protein also undergoing structural changes.

**AlphaFold 3 Application:**

<pre><code class="language-python"># Directly predict protein + ligand complex
complex = alphafold3_predict_complex(
    protein_seq=&quot;MKKFFDSRREQ...&quot;,   # Kinase sequence
    ligand_smiles=&quot;Cc1ccc(NC(=O)...&quot;  # Inhibitor candidate
)

# Structure considering induced fit
# ‚Üí Pocket shape is optimized
</code></pre>


**Comparison with Conventional Methods:**

| Method | Accuracy | Induced Fit | Computation Time |
|-----|------|------------|---------|
| AutoDock Vina | 60-70% | ‚ùå No | Minutes |
| Molecular Dynamics | 80-85% | ‚úÖ Yes | Days |
| AlphaFold 3 | **75-80%** | ‚úÖ Yes | Hours |

**Achievements:**
- Improved docking score reliability
- Accurate lead compound prioritization
- Efficient experimental screening (reduced candidates by 1/10)

**Real Example:**
Exscientia used AlphaFold 3 to design PKCŒ∏ inhibitors, shortening the conventional 18-month process to **12 months** (announced in 2024).

---

**Summary:**

AlphaFold 3's evolution enables:
1. **Complex Prediction**: Can predict interactions with DNA/RNA/ligands
2. **Modification Support**: Predictions closer to actual in vivo states
3. **Expanded Applications**: Genome editing, structure-based drug discovery, epigenetics research, etc.

Future Prospects:
- AlphaFold 4 (hypothetical): Dynamic structure and allosteric change prediction
- Real-time drug discovery: Shorten AI design ‚Üí synthesis ‚Üí evaluation cycle to weeks

</details>

<hr />
<h2>Next Steps</h2>
<p>Leveraging the foundational knowledge of AlphaFold learned in this chapter, let's tackle actual bioinformatics projects.</p>
<p><strong>Recommended Learning Path:</strong></p>
<ol>
<li>
<p><strong>Hands-on Projects</strong>:
   - Structure prediction of your research target proteins
   - Statistical analysis of the entire AlphaFold Database
   - Pocket detection for drug target proteins</p>
</li>
<li>
<p><strong>Related Technologies</strong>:
   - Molecular Dynamics (MD) simulation (GROMACS, AMBER)
   - Docking simulation (AutoDock Vina, Glide)
   - Protein design (RFdiffusion, ProteinMPNN)</p>
</li>
<li>
<p><strong>Next Chapters</strong>:
   - Chapter 6: Practical Structure-Based Drug Discovery (planned)
   - Chapter 7: Protein Design and De Novo Design (planned)</p>
</li>
</ol>
<hr />
<h2>References</h2>
<h3>Academic Papers</h3>
<ol>
<li>
<p>Jumper, J., Evans, R., Pritzel, A., et al. (2021). "Highly accurate protein structure prediction with AlphaFold." <em>Nature</em>, 596(7873), 583-589. https://doi.org/10.1038/s41586-021-03819-2</p>
</li>
<li>
<p>Varadi, M., Anyango, S., Deshpande, M., et al. (2022). "AlphaFold Protein Structure Database: massively expanding the structural coverage of protein-sequence space with high-accuracy models." <em>Nucleic Acids Research</em>, 50(D1), D439-D444. https://doi.org/10.1093/nar/gkab1061</p>
</li>
<li>
<p>Abramson, J., Adler, J., Dunger, J., et al. (2024). "Accurate structure prediction of biomolecular interactions with AlphaFold 3." <em>Nature</em>, 630, 493-500. https://doi.org/10.1038/s41586-024-07487-w</p>
</li>
<li>
<p>Kryshtafovych, A., Schwede, T., Topf, M., et al. (2021). "Critical assessment of methods of protein structure prediction (CASP)‚ÄîRound XIV." <em>Proteins</em>, 89(12), 1607-1617. https://doi.org/10.1002/prot.26237</p>
</li>
<li>
<p>Tunyasuvunakool, K., Adler, J., Wu, Z., et al. (2021). "Highly accurate protein structure prediction for the human proteome." <em>Nature</em>, 596(7873), 590-596. https://doi.org/10.1038/s41586-021-03828-1</p>
</li>
</ol>
<h3>Books</h3>
<ol start="6">
<li>
<p>Berman, H. M., Westbrook, J., Feng, Z., et al. (2000). "The Protein Data Bank." <em>Nucleic Acids Research</em>, 28(1), 235-242.</p>
</li>
<li>
<p>Liljas, A., Liljas, L., Ash, M. R., et al. (2016). <em>Textbook of Structural Biology</em> (2nd ed.). World Scientific Publishing.</p>
</li>
</ol>
<h3>Websites & Databases</h3>
<ol start="8">
<li>
<p>AlphaFold Protein Structure Database. https://alphafold.ebi.ac.uk/ (Accessed: 2025-10-19)</p>
</li>
<li>
<p>ColabFold. https://colab.research.google.com/github/sokrypton/ColabFold (Accessed: 2025-10-19)</p>
</li>
<li>
<p>RCSB Protein Data Bank. https://www.rcsb.org/ (Accessed: 2025-10-19)</p>
</li>
<li>
<p>DeepMind Blog. "AlphaFold: a solution to a 50-year-old grand challenge in biology." https://deepmind.google/discover/blog/alphafold-a-solution-to-a-50-year-old-grand-challenge-in-biology/ (Accessed: 2025-10-19)</p>
</li>
</ol>
<h3>Tools and Software</h3>
<ol start="12">
<li>
<p><strong>BioPython</strong>: Cock, P. J., et al. (2009). "Biopython: freely available Python tools for computational molecular biology and bioinformatics." <em>Bioinformatics</em>, 25(11), 1422-1423.</p>
</li>
<li>
<p><strong>py3Dmol</strong>: Rego, N., &amp; Koes, D. (2015). "3Dmol.js: molecular visualization with WebGL." <em>Bioinformatics</em>, 31(8), 1322-1324.</p>
</li>
<li>
<p><strong>AutoDock Vina</strong>: Trott, O., &amp; Olson, A. J. (2010). "AutoDock Vina: improving the speed and accuracy of docking with a new scoring function." <em>Journal of Computational Chemistry</em>, 31(2), 455-461.</p>
</li>
</ol>
<hr />
<h2>We Welcome Your Feedback</h2>
<p>To improve this chapter, we welcome your feedback:</p>
<ul>
<li><strong>Typos, errors, technical mistakes</strong>: Report via GitHub repository Issues</li>
<li><strong>Improvement suggestions</strong>: New topics, additional code examples you'd like to see</li>
<li><strong>Questions</strong>: Sections that were difficult to understand, areas needing additional explanation</li>
<li><strong>Success stories</strong>: Share your AlphaFold project experiences</li>
</ul>
<p><strong>Contact</strong>: yusuke.hashimoto.b8@tohoku.ac.jp</p>
<hr />
<p><a href="./index.html">Return to Series Index</a> | <a href="./chapter-1.html">‚Üê Return to Chapter 1</a> | <a href="#">Proceed to Next Chapter (Planned) ‚Üí</a></p>
<hr />
<p><strong>Last Updated</strong>: October 19, 2025
<strong>Version</strong>: 1.0
<strong>License</strong>: Creative Commons BY 4.0
<strong>Author</strong>: Dr. Yusuke Hashimoto (Tohoku University)</p><div class="navigation">
    <a href="chapter-4.html" class="nav-button">‚Üê Previous Chapter</a>
    <a href="index.html" class="nav-button">Return to Series Index</a>
</div>
    </main>


    <section class="disclaimer">
        <h3>Disclaimer</h3>
        <ul>
            <li>This content is provided for educational, research, and informational purposes only, and does not constitute professional advice (legal, accounting, technical warranties, etc.).</li>
            <li>This content and accompanying code examples are provided "AS IS" without warranties of any kind, either express or implied, including but not limited to merchantability, fitness for a particular purpose, non-infringement, accuracy, completeness, operation, or safety.</li>
            <li>The authors and Tohoku University assume no responsibility for the content, availability, or safety of external links, third-party data, tools, or libraries.</li>
            <li>To the maximum extent permitted by applicable law, the authors and Tohoku University shall not be liable for any direct, indirect, incidental, special, consequential, or punitive damages arising from the use, execution, or interpretation of this content.</li>
            <li>The content of this material is subject to change, update, or discontinuation without notice.</li>
            <li>The copyright and license of this content are subject to the specified conditions (e.g., CC BY 4.0). Such licenses typically include warranty disclaimers.</li>
        </ul>
    </section>

<footer>
        <p><strong>Authors</strong>: AI Terakoya Content Team</p>
        <p><strong>Version</strong>: 1.0 | <strong>Created</strong>: 2025-10-19</p>
        <p><strong>License</strong>: Creative Commons BY 4.0</p>
        <p>¬© 2025 AI Terakoya. All rights reserved.</p>
    </footer>
</body>
</html>
