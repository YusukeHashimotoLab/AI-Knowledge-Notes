<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Chapter 2: Fundamentals of MI - Concepts, Methods, and Ecosystem - AI Terakoya</title>
<link href="../../assets/css/knowledge-base.css" rel="stylesheet"/>
<script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
<script>
        mermaid.initialize({ startOnLoad: true, theme: 'default', securityLevel: 'strict' });
    </script>
<!-- MathJax for LaTeX equation rendering -->
<script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\(', '\)']],
                displayMath: [['$$', '$$'], ['\[', '\]']],
                processEscapes: true,
                processEnvironments: true
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
                ignoreHtmlClass: 'mermaid'
            }
        };
    </script>
<script id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
<nav class="breadcrumb">
<div class="breadcrumb-content">
<a href="../index.html">AI Terakoya Home</a><span class="breadcrumb-separator">‚Ä∫</span><a href="../../MI/index.html">Materials Informatics</a><span class="breadcrumb-separator">‚Ä∫</span><a href="../../MI/mi-introduction/index.html">MI</a><span class="breadcrumb-separator">‚Ä∫</span><span class="breadcrumb-current">Chapter 2</span>
</div>
</nav><div class="locale-switcher">
<span class="current-locale">üåê EN</span>
<span class="locale-separator">|</span>
<a href="../../../jp/MI/mi-introduction/chapter2-fundamentals.html" class="locale-link">üáØüáµ JP</a>
<span class="locale-separator">|</span>
<span class="locale-meta">Last sync: 2025-11-16</span>
</div>
<header>
<div class="header-content">
<h1>Chapter 2: Fundamentals of MI - Concepts, Methods, and Ecosystem</h1>
<p class="subtitle">Theory and Practice of Data-Driven Materials Development</p>
<div class="meta">
<span class="meta-item">üìñ Reading time: 20-25 minutes</span>
<span class="meta-item">üìä Difficulty: Beginner to Intermediate</span>
<span class="meta-item">üíª Code examples: 0</span>
<span class="meta-item">üìù Exercises: 0</span>
</div>
</div>
</header>
<main class="container">
<h1>Chapter 2: Fundamentals of MI - Concepts, Methods, and Ecosystem</h1>
<p class="chapter-description" style="margin: 1.5rem 0; padding: 1rem; background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); border-left: 4px solid #7b2cbf; border-radius: 8px; font-size: 1.05rem; line-height: 1.8; color: #2d3748;">Grasp the complete picture of material descriptors and major databases, and learn to retrieve actual data using pymatgen/MP API. Understand the end-to-end workflow from feature generation with matminer.</p>
<p class="chapter-supplement" style="margin: 0.75rem 0 1.5rem 0; padding: 0.75rem 1rem; background: linear-gradient(135deg, #fff8e1 0%, #fff3cd 100%); border-left: 3px solid #f59e0b; border-radius: 6px; font-size: 0.95rem; line-height: 1.7; color: #4a5568;"><strong>üí° Tip:</strong> Think of Materials Project as an "atlas of materials" and pymatgen as the "tools to read the map." Start small with data acquisition ‚Üí featurization workflow to build familiarity.</p>
<h2>Learning Objectives</h2>
<p>By reading this chapter, you will be able to:
- Explain the definition of MI and its differences from related fields (computational materials science, cheminformatics, etc.)
- Understand the characteristics and use cases of major materials databases (Materials Project, AFLOW, OQMD, JARVIS)
- Explain the 5-step MI workflow in detail (from problem formulation to validation)
- Understand the types and importance of material descriptors (composition-based, structure-based, property-based)
- Correctly use 20 key technical terms in the MI domain</p>
<hr/>
<h2>2.1 What is MI: Definition and Related Fields</h2>
<h3>2.1.1 Etymology and History of Materials Informatics</h3>
<p>The term <strong>Materials Informatics (MI)</strong> began to be used in the early 2000s. It gained worldwide attention particularly after the launch of the <strong>U.S. Materials Genome Initiative (MGI) in 2011</strong> [1].</p>
<p><strong>MGI Goals:</strong>
- Reduce the development time for new materials to half of conventional approaches
- Significantly reduce development costs
- Accelerate through integration of computation, experiments, and data</p>
<p>This initiative was expected to fundamentally transform materials science, just as the Human Genome Project revolutionized biology.</p>
<h3>2.1.2 Definition</h3>
<p><strong>Materials Informatics (MI)</strong> is an interdisciplinary field that integrates materials science and data science. It is a methodology that leverages large amounts of materials data and information science technologies such as machine learning to accelerate the discovery of new materials and prediction of material properties.</p>
<p><strong>Concise definition:</strong></p>
<blockquote>
<p>"The science of accelerating materials development using the power of data and AI"</p>
</blockquote>
<p><strong>Core elements:</strong>
1. <strong>Data</strong>: Experimental data, computational data, knowledge from literature
2. <strong>Computation</strong>: First-principles calculations, molecular dynamics simulations
3. <strong>Machine Learning</strong>: Predictive models, optimization algorithms
4. <strong>Experimental Validation</strong>: Verification of predictions and data augmentation</p>
<h3>2.1.3 Comparison with Related Fields</h3>
<p>MI is related to multiple fields, but each has a different focus.</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Target</th>
<th>Main Methods</th>
<th>Purpose</th>
<th>Relationship with MI</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Computational Materials Science</strong></td>
<td>Physical and chemical phenomena in materials</td>
<td>DFT, Molecular Dynamics</td>
<td>Theoretical prediction of material properties</td>
<td>MI utilizes this data</td>
</tr>
<tr>
<td><strong>Cheminformatics</strong></td>
<td>Compounds, small molecules</td>
<td>QSAR, molecular descriptors</td>
<td>Drug design, molecular property prediction</td>
<td>Shares descriptor concepts</td>
</tr>
<tr>
<td><strong>Bioinformatics</strong></td>
<td>Biomolecules, DNA/proteins</td>
<td>Sequence analysis, structure prediction</td>
<td>Decoding genetic information</td>
<td>Shares data-driven approaches</td>
</tr>
<tr>
<td><strong>Materials Informatics (MI)</strong></td>
<td>Solid materials in general</td>
<td>Machine Learning, Bayesian Optimization</td>
<td>Discovery and design of new materials</td>
<td>-</td>
</tr>
</tbody>
</table>
<p><strong>Uniqueness of MI:</strong>
- <strong>Inverse design approach</strong>: Design materials from target properties (conventional: calculate properties from materials)
- <strong>Diverse material types</strong>: Wide range of targets including metals, ceramics, semiconductors, polymers
- <strong>Strong experimental linkage</strong>: Emphasis on experimental validation, not just computation</p>
<h3>2.1.4 Forward Design vs Inverse Design</h3>
<p><strong>Conventional materials development (Forward Design):</strong></p>
<pre><code>Material composition ‚Üí Calculate/measure structure &amp; properties ‚Üí Evaluate results
</code></pre>
<ul>
<li>Researchers propose candidate materials</li>
<li>Repeated trial and error</li>
<li>Time-consuming</li>
</ul>
<p><strong>MI Approach (Inverse Design):</strong></p>
<pre><code>Target properties ‚Üí Machine learning predicts candidate materials ‚Üí Experiment on top candidates
</code></pre>
<ul>
<li>AI proposes optimal materials</li>
<li>Efficient screening of large number of candidates</li>
<li>Significant time reduction</li>
</ul>
<p><strong>Concrete example of inverse design:</strong>
"Want a semiconductor material with bandgap of 2.0 eV"
‚Üí MI system automatically generates candidate material list
‚Üí Researchers experimentally validate only top 10 candidates</p>
<hr/>
<h2>2.2 MI Glossary: 20 Essential Terms</h2>
<p>This section summarizes technical terms frequently encountered in MI. For beginners, properly understanding these terms is the first step.</p>
<h3>Data and Model Related (1-7)</h3>
<table>
<thead>
<tr>
<th>Term (English)</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1. Descriptor</strong></td>
<td>Numerical representation of material features. Example: electronegativity, atomic radius, lattice constant. Used as input to machine learning models.</td>
</tr>
<tr>
<td><strong>2. Feature Engineering</strong></td>
<td>The process of designing and selecting descriptors suitable for machine learning from raw data. Critical step that affects model performance.</td>
</tr>
<tr>
<td><strong>3. Screening</strong></td>
<td>Efficiently selecting materials with desired properties from a large pool of candidates. Computational screening can evaluate thousands to tens of thousands of materials in a short time.</td>
</tr>
<tr>
<td><strong>4. Overfitting</strong></td>
<td>Phenomenon where a model "memorizes" training data and prediction performance on unknown data degrades. Requires special attention in materials science with limited data.</td>
</tr>
<tr>
<td><strong>5. Cross-validation</strong></td>
<td>Method to evaluate model generalization performance. Data is divided into K folds, using one for testing and the rest for training, repeated K times.</td>
</tr>
<tr>
<td><strong>6. Ensemble Methods</strong></td>
<td>Technique to achieve more accurate predictions by combining predictions from multiple models. Examples: Random Forest, Gradient Boosting.</td>
</tr>
<tr>
<td><strong>7. Validation</strong></td>
<td>Process of confirming whether predicted results match actual material properties through experiments or high-precision calculations. Critical step to ensure MI reliability.</td>
</tr>
</tbody>
</table>
<h3>Computational Methods Related (8-13)</h3>
<table>
<thead>
<tr>
<th>Term (English)</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>8. Density Functional Theory (DFT)</strong></td>
<td>Method to calculate electronic states of materials based on quantum mechanics. Can theoretically predict material properties (bandgap, formation energy, etc.).</td>
</tr>
<tr>
<td><strong>9. Active Learning</strong></td>
<td>Learning method where the model proposes "which data to acquire next." Can improve the model while minimizing experimental costs.</td>
</tr>
<tr>
<td><strong>10. Bayesian Optimization</strong></td>
<td>Method to search for optimal materials while minimizing the number of experiments. Uses Gaussian processes to determine next experimental candidates.</td>
</tr>
<tr>
<td><strong>11. Transfer Learning</strong></td>
<td>Technique to apply a model trained on one material system to a related different material system. Enables accurate predictions even for new material systems with limited data.</td>
</tr>
<tr>
<td><strong>12. Graph Neural Networks (GNN)</strong></td>
<td>Neural networks that treat crystal structures as graphs (atoms=nodes, bonds=edges) and directly learn structural information. Recently gaining attention.</td>
</tr>
<tr>
<td><strong>13. High-throughput Computation</strong></td>
<td>Method to automatically execute first-principles calculations for large numbers of materials. Materials Project has evaluated over 140,000 materials using high-throughput computation.</td>
</tr>
</tbody>
</table>
<h3>Materials Science Related (14-20)</h3>
<table>
<thead>
<tr>
<th>Term (English)</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>14. Crystal Structure</strong></td>
<td>Structure where atoms are arranged in a regular pattern. Types include FCC (face-centered cubic), BCC (body-centered cubic), HCP (hexagonal close-packed).</td>
</tr>
<tr>
<td><strong>15. Space Group</strong></td>
<td>230 mathematical groups that classify crystal structure symmetry. Closely related to material properties.</td>
</tr>
<tr>
<td><strong>16. Bandgap</strong></td>
<td>Energy difference between the electron-occupied valence band and empty conduction band in semiconductors or insulators. Important for solar cells and semiconductor device design.</td>
</tr>
<tr>
<td><strong>17. Formation Energy</strong></td>
<td>Energy change when a material is formed from its constituent elements. Negative values indicate stable materials.</td>
</tr>
<tr>
<td><strong>18. Phase Diagram</strong></td>
<td>Diagram showing which phase (solid, liquid, gas) a material exists in as a function of temperature, pressure, and composition. Essential for alloy design.</td>
</tr>
<tr>
<td><strong>19. Multi-objective Optimization</strong></td>
<td>Method to simultaneously optimize multiple properties (e.g., lightweight and strength). Balances properties that usually have trade-off relationships.</td>
</tr>
<tr>
<td><strong>20. Pareto Front</strong></td>
<td>In multi-objective optimization, the set of solutions that are not optimal in all objectives but cannot improve any objective. Represents candidate group of optimal materials.</td>
</tr>
</tbody>
</table>
<p><strong>Key points for term learning:</strong>
- First prioritize understanding 1-7 (data &amp; model related)
- Learn 8-13 (computational methods) in detail at intermediate level
- Review 14-20 (materials science) alongside materials science fundamentals</p>
<hr/>
<h2>2.3 Overview of Materials Databases</h2>
<p>This section provides detailed comparison of four major materials databases that form the foundation of MI.</p>
<h3>2.3.1 Detailed Comparison of Major Databases</h3>
<table>
<thead>
<tr>
<th>Database Name</th>
<th>Number of Materials</th>
<th>Data Source</th>
<th>Main Property Data</th>
<th>License</th>
<th>Access Method</th>
<th>Advantages</th>
<th>Use Cases</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Materials Project</strong></td>
<td>140,000+</td>
<td>DFT calculations (VASP)</td>
<td>Bandgap, formation energy, elastic constants, phase stability</td>
<td><strong>CC BY 4.0</strong><br/>(Academic/non-profit only)</td>
<td>Web UI, API (Python: <code>pymatgen</code>), registration required (free)</td>
<td>Largest scale, active community, rich tools</td>
<td>Battery materials, semiconductors, structural materials</td>
</tr>
<tr>
<td><strong>AFLOW</strong></td>
<td>3,500,000+</td>
<td>DFT calculations (VASP)</td>
<td>Crystal structure, electronic structure, thermodynamic stability</td>
<td><strong>CC BY 4.0</strong></td>
<td>Web UI, API (RESTful), no registration required</td>
<td>Most crystal structure data, standardized naming convention</td>
<td>Crystal structure exploration, new structure prediction</td>
</tr>
<tr>
<td><strong>OQMD</strong></td>
<td>1,000,000+</td>
<td>DFT calculations (VASP)</td>
<td>Formation energy, stability, phase diagrams</td>
<td><strong>ODbL 1.0</strong><br/>(Citation required)</td>
<td>Web UI, API (Python: <code>qmpy</code>), no registration required</td>
<td>Strong in phase diagram calculations, rich alloy data</td>
<td>Alloy design, phase stability evaluation</td>
</tr>
<tr>
<td><strong>JARVIS</strong></td>
<td>70,000+</td>
<td>DFT calculations (VASP)<br/>Machine Learning predictions</td>
<td>Optical properties, mechanical properties, topological properties</td>
<td><strong>NIST Public Data</strong><br/>(Public domain)</td>
<td>Web UI, API (Python: <code>jarvis-tools</code>), no registration required</td>
<td>Diverse properties, provides machine learning models</td>
<td>Optical materials, topological materials</td>
</tr>
</tbody>
</table>
<h3>2.3.2 Database Selection Guide</h3>
<p><strong>1. Materials Project</strong>
- <strong>When to use</strong>: Battery materials, semiconductors, general inorganic materials exploration
- <strong>Strengths</strong>:
  - Intuitive Web UI, beginner-friendly
  - Rich Python library (<code>pymatgen</code>)
  - Active community with abundant information
- <strong>Weaknesses</strong>: Low coverage for some structure types</p>
<p><strong>2. AFLOW</strong>
- <strong>When to use</strong>: New crystal structure exploration, structural similarity search
- <strong>Strengths</strong>:
  - Most crystal structures (3.5 million types)
  - Standardized crystal structure description (AFLOW prototype)
  - Fast structural similarity search
- <strong>Weaknesses</strong>: Fewer types of property data compared to Materials Project</p>
<p><strong>3. OQMD</strong>
- <strong>When to use</strong>: Alloy phase diagram calculations, detailed phase stability evaluation
- <strong>Strengths</strong>:
  - Specialized in phase diagram calculations
  - Rich data for multi-component alloys
  - Temperature-dependent evaluation possible
- <strong>Weaknesses</strong>: Web UI usability somewhat inferior</p>
<p><strong>4. JARVIS</strong>
- <strong>When to use</strong>: Optical materials, topological materials, using machine learning models
- <strong>Strengths</strong>:
  - Integrated machine learning models
  - Rich optical properties (dielectric constant, refractive index)
  - Topological property calculations
- <strong>Weaknesses</strong>: Fewer materials than others</p>
<h3>2.3.3 Practical Examples of Database Utilization</h3>
<p><strong>Scenario 1: Want to find new cathode materials for lithium-ion batteries</strong></p>
<ol>
<li>
<p><strong>Search in Materials Project</strong>:
   - Conditions: Contains Li, voltage 3.5-4.5V, stable
   - Candidates: 100 types found</p>
</li>
<li>
<p><strong>Select top 10</strong>:
   - Evaluate by balance of capacity, voltage, and stability</p>
</li>
<li>
<p><strong>Confirm phase stability in OQMD</strong>:
   - Check possibility of decomposition with temperature changes</p>
</li>
<li>
<p><strong>Experimental validation</strong>:
   - Actually synthesize top 3 materials</p>
</li>
</ol>
<p><strong>Scenario 2: Want to find transparent conducting materials (for solar cells)</strong></p>
<ol>
<li>
<p><strong>Search in JARVIS</strong>:
   - Conditions: Bandgap &gt; 3.0 eV (transparent), high electrical conductivity
   - Candidates: 50 types</p>
</li>
<li>
<p><strong>Additional information from Materials Project</strong>:
   - Check formation energy and thermal stability</p>
</li>
<li>
<p><strong>Search for similar structures in AFLOW</strong>:
   - Find structures similar to promising materials found</p>
</li>
<li>
<p><strong>Experimental validation</strong></p>
</li>
</ol>
<h3>2.3.4 Example Database Access</h3>
<p><strong>Materials Project API (Python) Usage Example:</strong></p>
<pre><code class="language-python">from pymatgen.ext.matproj import MPRester

# Get API key: https://materialsproject.org
with MPRester("YOUR_API_KEY") as mpr:
    # Get information on LiCoO2
    data = mpr.get_data("mp-1234")  # material_id

    print(f"Chemical formula: {data[0]['pretty_formula']}")
    print(f"Bandgap: {data[0]['band_gap']} eV")
    print(f"Formation energy: {data[0]['formation_energy_per_atom']} eV/atom")
</code></pre>
<p><strong>Important points:</strong>
- Each database has a complementary relationship
- Using multiple databases, not just one, is recommended
- To ensure data reliability, it is important to compare results across different databases</p>
<h3>2.3.5 Data Licenses and Citation Methods</h3>
<p>Proper license understanding and citation are essential when using materials databases. Inappropriate use can cause legal and ethical issues.</p>
<h4>License Details</h4>
<p><strong>Materials Project - CC BY 4.0 (Creative Commons Attribution 4.0)</strong></p>
<ul>
<li><strong>Permitted uses:</strong></li>
<li>‚úÖ Use in academic research</li>
<li>‚úÖ Use in papers and presentations</li>
<li>‚úÖ Educational purposes</li>
<li>
<p>‚úÖ Use in non-profit projects</p>
</li>
<li>
<p><strong>Restrictions:</strong></p>
</li>
<li>‚ö†Ô∏è <strong>Commercial use requires separate permission</strong></li>
<li>‚ö†Ô∏è Contact in advance when using for corporate product development</li>
<li>
<p>‚ö†Ô∏è Must credit source when redistributing data</p>
</li>
<li>
<p><strong>Citation method:</strong>
<code>Jain, A., Ong, S. P., Hautier, G., Chen, W., Richards, W. D., et al. (2013).
  "Commentary: The Materials Project: A materials genome approach to accelerating
  materials innovation." APL Materials, 1(1), 011002.
  DOI: 10.1063/1.4812323</code></p>
</li>
<li>
<p><strong>API key acquisition:</strong> https://materialsproject.org ‚Üí Account registration (free) ‚Üí API Keys</p>
</li>
</ul>
<p><strong>AFLOW - CC BY 4.0</strong></p>
<ul>
<li><strong>Permitted uses:</strong></li>
<li>‚úÖ Free use for both academic and commercial purposes</li>
<li>
<p>‚úÖ Data modification and redistribution also possible (with source attribution)</p>
</li>
<li>
<p><strong>Citation method:</strong>
<code>Curtarolo, S., Setyawan, W., Hart, G. L., Jahnatek, M., et al. (2012).
  "AFLOW: An automatic framework for high-throughput materials discovery."
  Computational Materials Science, 58, 218-226.
  DOI: 10.1016/j.commatsci.2012.02.005</code></p>
</li>
<li>
<p><strong>Access:</strong> No registration required, API also freely available</p>
</li>
</ul>
<p><strong>OQMD - Open Database License (ODbL) 1.0</strong></p>
<ul>
<li><strong>Permitted uses:</strong></li>
<li>‚úÖ Use for both academic and commercial purposes</li>
<li>
<p>‚úÖ Data modification and redistribution also possible</p>
</li>
<li>
<p><strong>Required conditions:</strong></p>
</li>
<li>‚úÖ <strong>Must include citation</strong></li>
<li>
<p>‚úÖ Derived data must be published under same license (ODbL)</p>
</li>
<li>
<p><strong>Citation method:</strong>
<code>Saal, J. E., Kirklin, S., Aykol, M., Meredig, B., &amp; Wolverton, C. (2013).
  "Materials Design and Discovery with High-Throughput Density Functional Theory:
  The Open Quantum Materials Database (OQMD)." JOM, 65(11), 1501-1509.
  DOI: 10.1007/s11837-013-0755-4</code></p>
</li>
<li>
<p><strong>Access:</strong> No registration required</p>
</li>
</ul>
<p><strong>JARVIS - NIST Public Data (Public domain equivalent)</strong></p>
<ul>
<li><strong>Permitted uses:</strong></li>
<li>‚úÖ Completely free to use (U.S. government data)</li>
<li>‚úÖ Unlimited for both academic and commercial purposes</li>
<li>
<p>‚úÖ Citation recommended but not required</p>
</li>
<li>
<p><strong>Recommended citation method:</strong>
<code>Choudhary, K., Garrity, K. F., Reid, A. C. E., et al. (2020).
  "The joint automated repository for various integrated simulations (JARVIS)
  for data-driven materials design." npj Computational Materials, 6(1), 173.
  DOI: 10.1038/s41524-020-00440-1</code></p>
</li>
<li>
<p><strong>Access:</strong> No registration required</p>
</li>
</ul>
<h4>Commercial Use Considerations</h4>
<p><strong>‚ö†Ô∏è Important: Commercial Use of Materials Project</strong></p>
<p>Materials Project uses CC BY 4.0 license for <strong>academic and non-profit purposes only</strong>. The following cases are considered commercial use:</p>
<ul>
<li>‚ùå Corporate product development (material selection, property prediction, etc.)</li>
<li>‚ùå Data use in commercial services</li>
<li>‚ùå Use in paid consulting work</li>
</ul>
<p><strong>For commercial use:</strong>
1. Contact Materials Project operations team (contact@materialsproject.org)
2. Explain usage purpose and scope
3. Obtain commercial license (conditions negotiable)</p>
<p><strong>AFLOW, OQMD, JARVIS allow commercial use:</strong>
- However, proper citation is mandatory
- Pay attention to license when publishing derived data</p>
<h4>Redistribution Permissions</h4>
<table>
<thead>
<tr>
<th>Database</th>
<th>Original Data Redistribution</th>
<th>Processed Data Redistribution</th>
<th>Conditions</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Materials Project</strong></td>
<td>‚ö†Ô∏è Requires confirmation</td>
<td>‚ö†Ô∏è Requires confirmation</td>
<td>Source attribution, academic purposes only</td>
</tr>
<tr>
<td><strong>AFLOW</strong></td>
<td>‚úÖ Possible</td>
<td>‚úÖ Possible</td>
<td>Source attribution required</td>
</tr>
<tr>
<td><strong>OQMD</strong></td>
<td>‚úÖ Possible</td>
<td>‚úÖ Possible</td>
<td>Maintain ODbL license, source attribution</td>
</tr>
<tr>
<td><strong>JARVIS</strong></td>
<td>‚úÖ Possible</td>
<td>‚úÖ Possible</td>
<td>No restrictions (citation recommended)</td>
</tr>
</tbody>
</table>
<h4>Citation Examples in Python Code</h4>
<p>It is recommended to include citations not only in papers and reports but also within code:</p>
<pre><code class="language-python">"""
Materials Project API Example

Data source: Materials Project (https://materialsproject.org)
License: CC BY 4.0 (academic use only)
Citation: Jain et al. (2013), APL Materials, 1(1), 011002.
          DOI: 10.1063/1.4812323

Commercial use requires separate permission from Materials Project.
"""

from pymatgen.ext.matproj import MPRester

# Recommended to load API key from environment variable
import os
API_KEY = os.getenv("MP_API_KEY")  # Do not hardcode for security

with MPRester(API_KEY) as mpr:
    # Data retrieval code
    pass
</code></pre>
<h4>Rate Limits and Etiquette</h4>
<p>Each database has rate limits to avoid server overload:</p>
<table>
<thead>
<tr>
<th>Database</th>
<th>Rate Limit</th>
<th>Recommendations</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Materials Project</strong></td>
<td>~5 requests/sec</td>
<td>Insert sleep() during bulk retrieval</td>
</tr>
<tr>
<td><strong>AFLOW</strong></td>
<td>No explicit limit</td>
<td>Use within reasonable range</td>
</tr>
<tr>
<td><strong>OQMD</strong></td>
<td>No explicit limit</td>
<td>Avoid parallel requests</td>
</tr>
<tr>
<td><strong>JARVIS</strong></td>
<td>No explicit limit</td>
<td>Batch download recommended</td>
</tr>
</tbody>
</table>
<p><strong>Recommended code example (handling rate limits):</strong></p>
<pre><code class="language-python">import time
from pymatgen.ext.matproj import MPRester

with MPRester(API_KEY) as mpr:
    material_ids = ["mp-1234", "mp-5678", ...]  # Large number of IDs

    results = []
    for i, mat_id in enumerate(material_ids):
        data = mpr.get_data(mat_id)
        results.append(data)

        # Wait 1 second every 100 requests (rate limit consideration)
        if (i + 1) % 100 == 0:
            time.sleep(1)
            print(f"Retrieved: {i+1}/{len(material_ids)}")
</code></pre>
<h4>Checklist: Verification Before Using Database</h4>
<ul>
<li>[ ] Is the usage purpose academic or commercial?</li>
<li>[ ] For commercial use, does the license permit it?</li>
<li>[ ] Have you confirmed the citation method?</li>
<li>[ ] Have you obtained API key if required?</li>
<li>[ ] Have you understood rate limits and written appropriate code?</li>
<li>[ ] If planning to redistribute data, are you meeting license conditions?</li>
</ul>
<hr/>
<h2>2.4 MI Ecosystem: Data Flow</h2>
<p>MI is not a single technology but an ecosystem where multiple elements collaborate. The following diagram shows the data flow in MI.</p>
<div class="mermaid">
flowchart TB
    subgraph "Data Generation"
        A[Experimental Data] --&gt; D[Materials Database]
        B[First-Principles Calculations\nDFT] --&gt; D
        C[Papers &amp; Patents] --&gt; D
    end

    subgraph "Data Processing"
        D --&gt; E[Data Cleaning\nStandardization]
        E --&gt; F[Descriptor Generation\nFeature Engineering]
    end

    subgraph "Machine Learning"
        F --&gt; G[Model Training\nRegression &amp; Classification]
        G --&gt; H[Prediction &amp; Screening\nThousands-Tens of thousands of candidates]
    end

    subgraph "Experimental Validation"
        H --&gt; I[Candidate Material Selection\nTop 10-100]
        I --&gt; J[Experimental Synthesis &amp; Measurement]
        J --&gt; K{Prediction\nAccurate?}
    end

    subgraph "Continuous Improvement"
        K --&gt;|Yes| L[Add as New Data]
        K --&gt;|No| M[Model Improvement &amp; Retraining]
        L --&gt; D
        M --&gt; G
    end

    style D fill:#e3f2fd
    style F fill:#fff3e0
    style G fill:#f3e5f5
    style J fill:#e8f5e9
    style L fill:#fce4ec
</div>
<p><strong>How to read the diagram:</strong>
1. <strong>Data Generation</strong>: Collect data from experiments, computations, and literature
2. <strong>Data Processing</strong>: Convert raw data into machine learning-suitable format
3. <strong>Machine Learning</strong>: Train models and predict large numbers of candidates
4. <strong>Experimental Validation</strong>: Experimentally verify promising candidates
5. <strong>Continuous Improvement</strong>: Add results to data and improve models</p>
<p><strong>Importance of the feedback loop:</strong>
- Accurate predictions ‚Üí Add data to further improve model
- Inaccurate predictions ‚Üí Review model and change descriptors or learning methods
- By repeating this cycle, model accuracy improves</p>
<hr/>
<h2>2.5 MI Basic Workflow: Detailed Version</h2>
<p>Chapter 1 introduced a 4-step workflow, but here we expand it to a more practical <strong>5-step</strong> workflow.</p>
<h3>2.5.1 Overall Picture</h3>
<div class="mermaid">
flowchart LR
    A[Step 0:\nProblem Formulation] --&gt; B[Step 1:\nData Collection]
    B --&gt; C[Step 2:\nModel Construction]
    C --&gt; D[Step 3:\nPrediction &amp; Screening]
    D --&gt; E[Step 4:\nExperimental Validation]
    E --&gt; F[Step 5:\nData Addition &amp; Improvement]
    F - Continuous Improvement .-&gt; B

    style A fill:#ffebee
    style B fill:#e3f2fd
    style C fill:#fff3e0
    style D fill:#f3e5f5
    style E fill:#e8f5e9
    style F fill:#fce4ec
</div>
<h3>2.5.2 Step 0: Problem Formulation (Most Important, Often Overlooked)</h3>
<p><strong>What to do:</strong>
- Clearly define the problem to solve
- Specify target properties and constraints
- Set success criteria</p>
<p><strong>Concrete example: Battery material development</strong></p>
<p><strong>Poor problem formulation:</strong></p>
<blockquote>
<p>"Want to find good battery materials"</p>
</blockquote>
<p><strong>Good problem formulation:</strong></p>
<blockquote>
<p>"Discover lithium-ion battery cathode materials with the following properties:
- Theoretical capacity: ‚â•200 mAh/g
- Operating voltage: 3.5-4.5 V vs. Li/Li+
- Cycle life: capacity retention ‚â•80% after 500 cycles
- Cost: ‚â§$50/kg (raw material basis)
- Safety: thermal runaway temperature ‚â•200¬∞C
- Environmental constraints: minimize Co usage (ideally Co-free)"</p>
</blockquote>
<p><strong>Problem formulation checklist:</strong>
- [ ] Are target properties quantitatively defined?
- [ ] Are constraints (cost, environmental, safety) clear?
- [ ] Are success criteria measurable?
- [ ] Is the scope experimentally verifiable?</p>
<p><strong>Time estimate:</strong> 1-2 weeks (including literature review and expert discussions)</p>
<p><strong>Common failures:</strong>
- Vague goals, changed multiple times later
- Ignoring constraints, searching for unrealizable materials
- No success criteria, endless search</p>
<h3>2.5.3 Step 1: Data Collection</h3>
<p><strong>What to do:</strong>
- Collect material information from existing experimental data and literature
- Download relevant data from materials databases
- Add data through first-principles calculations if necessary</p>
<p><strong>Data source priority:</strong>
1. <strong>Existing databases</strong> (Most efficient)
   - Materials Project, AFLOW, OQMD
   - High reliability, ready to use</p>
<ol start="2">
<li>
<p><strong>Papers &amp; patents</strong> (Manual work required)
   - Google Scholar, Web of Science
   - May contain experimental data</p>
</li>
<li>
<p><strong>Self-calculation/measurement</strong> (Time-consuming)
   - Generate data for new materials by DFT calculations
   - Laboratory measurements</p>
</li>
</ol>
<p><strong>Concrete example: Lithium-ion battery cathode materials</strong></p>
<pre><code class="language-python"># Requirements:
# - Python 3.9+
# - pandas&gt;=2.0.0, &lt;2.2.0

"""
Data collection for lithium-ion battery cathode materials

Dependencies (libraries and versions):
- Python: 3.9+
- pymatgen: 2023.10.11 or later
- pandas: 2.0+
- numpy: 1.24+

Environment (execution environment):
- API key: Materials Project (https://materialsproject.org)
- Rate limit: ~5 requests/sec
"""

from pymatgen.ext.matproj import MPRester
import pandas as pd
import os

# Load API key from environment variable (improved security)
API_KEY = os.getenv("MP_API_KEY", "YOUR_API_KEY")

# Search Li-containing oxides from Materials Project
with MPRester(API_KEY) as mpr:
    # Search criteria
    criteria = {
        "elements": {"$all": ["Li", "O"]},  # Must contain Li and O
        "nelements": {"$gte": 2, "$lte": 4},  # 2-4 elements
        "e_above_hull": {"$lte": 0.05}  # Stable or metastable (within 50 meV/atom)
    }

    # Properties to retrieve
    properties = [
        "material_id",
        "pretty_formula",
        "formation_energy_per_atom",  # eV/atom
        "energy_above_hull",  # eV/atom (thermodynamic stability)
        "band_gap",  # eV (electronic structure)
        "density"  # g/cm¬≥
    ]

    # Data retrieval
    results = mpr.query(criteria, properties)

    # Convert to DataFrame
    df = pd.DataFrame(results)

    print(f"Number of materials retrieved: {len(df)}")
    print(f"Data shape: {df.shape}")
    print(df.head())

# Data validation (check NaN, outliers)
print(f"\nNumber of missing values:\n{df.isnull().sum()}")
print(f"\nBandgap range: {df['band_gap'].min():.2f} - {df['band_gap'].max():.2f} eV")
</code></pre>
<p><strong>Expected results:</strong>
- Hundreds to thousands of candidate material data
- Basic properties for each material (composition, formation energy, bandgap, etc.)</p>
<p><strong>Time estimate:</strong>
- Database utilization: Several hours to days
- Literature survey: 1-2 weeks
- DFT calculations: Several weeks to months (depends on number of materials)</p>
<p><strong>Common issues:</strong>
- Data missing (specific properties available only for certain materials)
- Data discrepancies (values differ across databases)
- Data bias (biased toward specific material systems)</p>
<p><strong>Solutions:</strong>
- Compare multiple databases to verify reliability
- Consider missing value imputation methods (mean, machine learning estimation, etc.)
- Recognize data bias and clarify model applicability scope</p>
<h3>2.5.4 Step 2: Model Construction</h3>
<p><strong>What to do:</strong>
- Train machine learning models using collected data
- Select appropriate descriptors (features)
- Evaluate and optimize model performance</p>
<p><strong>Sub-steps:</strong></p>
<p><strong>2.1 Descriptor Design</strong></p>
<p>Need to convert materials into numerical vectors.</p>
<p><strong>Types of descriptors:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Concrete Examples</th>
<th>Advantages</th>
<th>Disadvantages</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Composition-based</strong></td>
<td>Electronegativity, atomic radius, atomic weight</td>
<td>Simple calculation, easy to interpret</td>
<td>Ignores structural information</td>
</tr>
<tr>
<td><strong>Structure-based</strong></td>
<td>Lattice constants, space group, coordination number</td>
<td>Captures structure-property relationships</td>
<td>Requires crystal structure data</td>
</tr>
<tr>
<td><strong>Property-based</strong></td>
<td>Melting point, density, bandgap</td>
<td>Uses correlations between properties</td>
<td>Difficult to apply to unknown materials</td>
</tr>
</tbody>
</table>
<p><strong>Descriptor example: Numerical representation of LiCoO2</strong></p>
<pre><code class="language-python"># Simple example: composition-based descriptor
material = "LiCoO2"

# Fraction of each element
Li_fraction = 0.25  # 1/(1+1+2)
Co_fraction = 0.25
O_fraction = 0.50

# Element properties (from periodic table)
electronegativity_Li = 0.98
electronegativity_Co = 1.88
electronegativity_O = 3.44

# Weighted average
avg_electronegativity = (
    Li_fraction * electronegativity_Li +
    Co_fraction * electronegativity_Co +
    O_fraction * electronegativity_O
)  # = 2.38

# Vector representation
descriptor_vector = [
    Li_fraction, Co_fraction, O_fraction,  # Composition
    avg_electronegativity,  # Electronegativity
    # ... add other properties
]
</code></pre>
<p><strong>In actual projects, use the <code>matminer</code> library:</strong></p>
<pre><code class="language-python">from matminer.featurizers.composition import ElementProperty

# Automatically generate many descriptors
featurizer = ElementProperty.from_preset("magpie")
features = featurizer.featurize_dataframe(df, col_id="composition")
</code></pre>
<p><strong>2.2 Model Selection</strong></p>
<p><strong>Beginner-level models:</strong>
- <strong>Linear Regression</strong>: Simple, easy to interpret
- <strong>Decision Trees</strong>: Visualizable, captures nonlinear relationships</p>
<p><strong>Intermediate-level models:</strong>
- <strong>Random Forest</strong>: High accuracy, resistant to overfitting
- <strong>Gradient Boosting (XGBoost, LightGBM)</strong>: Highest accuracy</p>
<p><strong>Advanced-level models:</strong>
- <strong>Neural Networks</strong>: Learn complex nonlinear relationships
- <strong>Graph Neural Networks (GNN)</strong>: Directly learn crystal structures</p>
<p><strong>2.3 Training and Evaluation</strong></p>
<pre><code class="language-python"># Requirements:
# - Python 3.9+
# - numpy&gt;=1.24.0, &lt;2.0.0

"""
Machine learning model training and evaluation

Dependencies (libraries and versions):
- Python: 3.9+
- scikit-learn: 1.3+
- numpy: 1.24+
- pandas: 2.0+

Reproducibility:
- Random seed fixed: 42 (unified across all random operations)
- Train/test split: 80/20
- Cross-validation: 5-fold
"""

import numpy as np
from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_absolute_error, r2_score, mean_squared_error

# Fix random seed (ensure reproducibility)
RANDOM_SEED = 42
np.random.seed(RANDOM_SEED)

# Data split
X = features  # Descriptors (e.g., 73-dimensional vector)
y = df['target_property']  # e.g., voltage (V), bandgap (eV), etc.

print(f"Data shape: X={X.shape}, y={y.shape}")
print(f"Target variable range: {y.min():.2f} - {y.max():.2f}")

X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, random_state=RANDOM_SEED, shuffle=True
)

print(f"Training data: {X_train.shape[0]} samples, Test data: {X_test.shape[0]} samples")

# Model training
model = RandomForestRegressor(
    n_estimators=100,  # Number of decision trees
    max_depth=20,  # Maximum depth (prevent overfitting)
    min_samples_split=5,  # Minimum samples required for split
    random_state=RANDOM_SEED,  # Ensure reproducibility
    n_jobs=-1  # Use all CPU cores (speed up)
)

model.fit(X_train, y_train)

# Prediction
y_pred = model.predict(X_test)

# Calculate evaluation metrics
mae = mean_absolute_error(y_test, y_pred)  # Mean Absolute Error
rmse = np.sqrt(mean_squared_error(y_test, y_pred))  # Root Mean Squared Error
r2 = r2_score(y_test, y_pred)  # Coefficient of Determination

print("\n===== Test Set Performance =====")
print(f"MAE (Mean Absolute Error): {mae:.3f}")
print(f"RMSE (Root Mean Squared Error): {rmse:.3f}")
print(f"R¬≤ (Coefficient of Determination): {r2:.3f}")

# Cross-validation (more reliable evaluation)
cv_scores = cross_val_score(
    model, X, y, cv=5, scoring='neg_mean_absolute_error', n_jobs=-1
)
print(f"\n===== Cross-Validation Performance (5-fold) =====")
print(f"CV MAE: {-cv_scores.mean():.3f} ¬± {cv_scores.std():.3f}")

# Data leakage verification (compare training error vs test error)
y_train_pred = model.predict(X_train)
train_mae = mean_absolute_error(y_train, y_train_pred)
print(f"\nTraining MAE: {train_mae:.3f}, Test MAE: {mae:.3f}")
if train_mae &lt; mae * 0.5:
    print("‚ö†Ô∏è Warning: Possible overfitting (training error significantly lower)")
</code></pre>
<p><strong>Performance guidelines:</strong>
- <strong>R¬≤ &gt; 0.8</strong>: Good
- <strong>R¬≤ &gt; 0.9</strong>: Excellent
- <strong>R¬≤ &lt; 0.5</strong>: Model needs review</p>
<p><strong>Time estimate:</strong>
- Descriptor design: Several days to 1 week
- Model training and optimization: 1-2 weeks</p>
<p><strong>Common issues:</strong>
- Overfitting (high accuracy on training data but low on test data)
- Descriptor selection mistakes (overlooking important features)</p>
<p><strong>Solutions:</strong>
- Verify generalization performance with cross-validation
- Analyze feature importance and remove unnecessary descriptors
- Introduce regularization (L1/L2)</p>
<h3>2.5.5 Step 3: Prediction &amp; Screening</h3>
<p><strong>What to do:</strong>
- Use trained model to predict properties of unknown materials
- Evaluate large numbers of candidate materials (thousands to tens of thousands) in a short time
- Select promising top candidates</p>
<p><strong>Screening workflow:</strong></p>
<pre><code>Candidate materials: 10,000 types (generated by calculations)
  ‚Üì (Predict with machine learning: minutes)
Rank by predicted values
  ‚Üì
Select top 1,000 (close to target properties)
  ‚Üì (Detailed calculation/evaluation: hours to days)
Narrow down to top 100
  ‚Üì
Materials to experiment: Top 10 (most promising candidates)
</code></pre>
<p><strong>Concrete code example:</strong></p>
<pre><code class="language-python"># Requirements:
# - Python 3.9+
# - numpy&gt;=1.24.0, &lt;2.0.0

"""
Example: Concrete code example:

Purpose: Demonstrate core concepts and implementation patterns
Target: Beginner to Intermediate
Execution time: 10-30 seconds
Dependencies: None
"""

import numpy as np

# Generate candidate material list (e.g., create candidates by varying composition)
# Actually use more systematic methods
candidate_compositions = [...]  # 10,000 candidates

# Calculate descriptors for each candidate
candidate_features = compute_descriptors(candidate_compositions)

# Predict with model
predicted_properties = model.predict(candidate_features)

# Rank (e.g., by high voltage)
ranked_indices = np.argsort(predicted_properties)[::-1]

# Select top 100
top_100 = [candidate_compositions[i] for i in ranked_indices[:100]]

print("Top 10 candidates:")
for i, comp in enumerate(top_100[:10]):
    pred_val = predicted_properties[ranked_indices[i]]
    print(f"{i+1}. {comp}: Predicted value = {pred_val:.2f}")
</code></pre>
<p><strong>Efficiency example:</strong>
- <strong>Conventional</strong>: Experimentally evaluate 10,000 types ‚Üí ~30 years (1 per day)
- <strong>MI</strong>: Experimentally evaluate 10 types ‚Üí ~2 weeks
- <strong>Time reduction rate</strong>: 99.9%</p>
<p><strong>Time estimate:</strong>
- Prediction calculation: Minutes to hours (depends on number of candidate materials)
- Result analysis: Several days</p>
<p><strong>Important notes:</strong>
- Predictions are predictions. Always experimentally verify
- For materials outside model applicability scope (significantly different from training data), prediction accuracy is low
- Uncertainty evaluation (Bayesian methods) provides more reliability</p>
<h3>2.5.6 Step 4: Experimental Validation</h3>
<p><strong>What to do:</strong>
- Actually synthesize materials narrowed down by predictions
- Measure properties and verify prediction accuracy
- Analyze discrepancies between predictions and measurements</p>
<p><strong>Experiment priority:</strong>
1. <strong>Materials with highest predicted values</strong> (best case)
2. <strong>Materials with moderate prediction but low uncertainty</strong> (safe choice)
3. <strong>Materials with high prediction but also high uncertainty</strong> (high risk, high return)</p>
<p><strong>Validation checklist:</strong>
- [ ] Are synthesis conditions established?
- [ ] Are measurement instruments available?
- [ ] Does measurement accuracy meet target property requirements?
- [ ] Reproducibility confirmation (multiple measurements)</p>
<p><strong>Time estimate:</strong>
- Synthesis: Several days to weeks (depends on material)
- Measurement: Several days to 1 week
- Total: 2-3 months for top 10</p>
<p><strong>Success and failure assessment:</strong></p>
<table>
<thead>
<tr>
<th>Result</th>
<th>Assessment</th>
<th>Next Action</th>
</tr>
</thead>
<tbody>
<tr>
<td>Prediction matches measurement</td>
<td>Success</td>
<td>Add to data, continue exploration</td>
</tr>
<tr>
<td>Better than prediction</td>
<td>Great success</td>
<td>Analyze model and investigate why it underestimated</td>
</tr>
<tr>
<td>Worse than prediction</td>
<td>Partial failure</td>
<td>Review descriptors and model</td>
</tr>
<tr>
<td>Completely different</td>
<td>Failure</td>
<td>Possible out of model scope. Reconsider data and model</td>
</tr>
</tbody>
</table>
<p><strong>Important points:</strong>
- Failures are also valuable data. Always add to database
- By analyzing causes of prediction-measurement discrepancies, models improve</p>
<h3>2.5.7 Step 5: Data Addition &amp; Model Improvement</h3>
<p><strong>What to do:</strong>
- Add experimental results (both successes and failures) to database
- Retrain model with new data
- Verify prediction accuracy improvement</p>
<p><strong>Continuous improvement cycle:</strong></p>
<pre><code>Initial model (R¬≤ = 0.75)
  ‚Üì
Add 10 experimental results
  ‚Üì
Model retraining (R¬≤ = 0.82)
  ‚Üì
10 more experiments
  ‚Üì
Model retraining (R¬≤ = 0.88)
  ‚Üì
Finally discover optimal material
</code></pre>
<p><strong>Utilizing active learning:</strong></p>
<p>In normal MI, materials with high predicted values are experimented on, but in <strong>active learning</strong>, the model proposes "materials with high uncertainty."</p>
<pre><code class="language-python"># Estimate uncertainty with Random Forest
predictions = []
for tree in model.estimators_:
    pred = tree.predict(candidate_features)
    predictions.append(pred)

predictions = np.array(predictions)
uncertainty = predictions.std(axis=0)  # Large standard deviation = high uncertainty

# Prioritize materials with high uncertainty for experiments
high_uncertainty_indices = np.argsort(uncertainty)[::-1]
next_experiment = candidate_compositions[high_uncertainty_indices[0]]
</code></pre>
<p><strong>Time estimate:</strong> 1-2 weeks per cycle</p>
<p><strong>Termination conditions:</strong>
- Materials meeting target properties found
- Prediction accuracy sufficiently high (R¬≤ &gt; 0.9)
- Budget/time constraints</p>
<hr/>
<h2>2.6 Material Descriptor Details</h2>
<h3>2.6.1 Types of Descriptors and Concrete Examples</h3>
<p><strong>1. Composition-based Descriptors</strong></p>
<p><strong>Features:</strong>
- Calculable from chemical formula alone
- Usable even when crystal structure is unknown
- Low computational cost</p>
<p><strong>Concrete examples:</strong></p>
<table>
<thead>
<tr>
<th>Descriptor</th>
<th>Description</th>
<th>Example (LiCoO2)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Average electronegativity</td>
<td>Weighted average of each element's electronegativity</td>
<td>2.38</td>
</tr>
<tr>
<td>Average atomic radius</td>
<td>Weighted average of each element's atomic radius</td>
<td>1.15 √Ö</td>
</tr>
<tr>
<td>Number of element types</td>
<td>Number of constituent elements</td>
<td>3 (Li, Co, O)</td>
</tr>
<tr>
<td>Average atomic weight</td>
<td>Weighted average of each element's atomic weight</td>
<td>30.8 g/mol</td>
</tr>
<tr>
<td>Electronegativity difference</td>
<td>Difference between maximum and minimum electronegativity</td>
<td>2.46 (O - Li)</td>
</tr>
</tbody>
</table>
<p><strong>2. Structure-based Descriptors</strong></p>
<p><strong>Features:</strong>
- Utilizes crystal structure information
- Captures structure-property relationships
- Requires crystal structure data</p>
<p><strong>Concrete examples:</strong></p>
<table>
<thead>
<tr>
<th>Descriptor</th>
<th>Description</th>
<th>Example (LiCoO2)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Lattice constants</td>
<td>Unit cell lengths a, b, c</td>
<td>a=2.82 √Ö, c=14.05 √Ö (hexagonal)</td>
</tr>
<tr>
<td>Space group</td>
<td>Crystal symmetry</td>
<td>R-3m (166)</td>
</tr>
<tr>
<td>Coordination number</td>
<td>Number of nearest neighbor atoms around an atom</td>
<td>Co: 6-coordinate (surrounded by oxygen)</td>
</tr>
<tr>
<td>Bond distance</td>
<td>Distance between adjacent atoms</td>
<td>Co-O: 1.93 √Ö</td>
</tr>
<tr>
<td>Density</td>
<td>Mass per unit volume</td>
<td>5.06 g/cm¬≥</td>
</tr>
</tbody>
</table>
<p><strong>3. Property-based Descriptors</strong></p>
<p><strong>Features:</strong>
- Predict unknown properties from known properties
- Utilizes correlations between properties
- Difficult to apply to unknown materials</p>
<p><strong>Concrete examples:</strong></p>
<table>
<thead>
<tr>
<th>Descriptor</th>
<th>Description</th>
<th>Example (LiCoO2)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Melting point</td>
<td>Solid-to-liquid phase transition temperature</td>
<td>~1200 K</td>
</tr>
<tr>
<td>Bandgap</td>
<td>Electronic structure energy gap</td>
<td>~2.7 eV (insulator)</td>
</tr>
<tr>
<td>Formation energy</td>
<td>Energy when formed from elements</td>
<td>-2.5 eV/atom (stable)</td>
</tr>
<tr>
<td>Elastic modulus</td>
<td>Material hardness/resistance to deformation</td>
<td>150 GPa</td>
</tr>
<tr>
<td>Thermal conductivity</td>
<td>Ease of heat transfer</td>
<td>5 W/(m¬∑K)</td>
</tr>
</tbody>
</table>
<h3>2.6.2 Automatic Descriptor Generation (Utilizing Matminer)</h3>
<pre><code class="language-python">from matminer.featurizers.composition import ElementProperty, Stoichiometry
from matminer.featurizers.structure import DensityFeatures
from pymatgen.core import Composition

# Automatic generation of composition-based descriptors
comp = Composition("LiCoO2")

# Example 1: Element property-based descriptors (73 types)
element_featurizer = ElementProperty.from_preset("magpie")
element_features = element_featurizer.featurize(comp)

print(f"Number of generated descriptors: {len(element_features)}")
print(f"Example descriptors: {element_features[:5]}")

# Example 2: Stoichiometry-based descriptors
stoich_featurizer = Stoichiometry()
stoich_features = stoich_featurizer.featurize(comp)

print(f"Stoichiometry descriptors: {stoich_features}")
</code></pre>
<p><strong>Descriptors generated by Matminer (partial list):</strong>
- Average electronegativity, atomic radius, atomic weight
- Element position on periodic table (group, period)
- Electronic configuration (number of s-orbital electrons, p-orbital electrons, etc.)
- Average and variance of oxidation states
- Number of valence electrons for elements</p>
<h3>2.6.3 Descriptor Selection and Feature Engineering</h3>
<p><strong>Not all descriptors are useful:</strong>
- Irrelevant descriptors ‚Üí Become noise and degrade model performance
- Redundant descriptors ‚Üí Waste of computational cost</p>
<p><strong>Descriptor selection methods:</strong></p>
<p><strong>1. Feature Importance</strong></p>
<pre><code class="language-python"># Requirements:
# - Python 3.9+
# - matplotlib&gt;=3.7.0
# - pandas&gt;=2.0.0, &lt;2.2.0

"""
Example: 1. Feature Importance

Purpose: Demonstrate data visualization techniques
Target: Beginner to Intermediate
Execution time: 2-5 seconds
Dependencies: None
"""

import matplotlib.pyplot as plt
import pandas as pd

# Random Forest feature importance
importances = model.feature_importances_
feature_names = X.columns

# Sort by importance
indices = np.argsort(importances)[::-1]

# Visualize top 20
plt.figure(figsize=(10, 6))
plt.bar(range(20), importances[indices[:20]])
plt.xticks(range(20), [feature_names[i] for i in indices[:20]], rotation=90)
plt.xlabel("Feature")
plt.ylabel("Importance")
plt.title("Feature Importance Top 20")
plt.tight_layout()
plt.show()
</code></pre>
<p><strong>2. Correlation Analysis</strong></p>
<pre><code class="language-python"># Correlation matrix between features
correlation_matrix = X.corr()

# Remove feature pairs with high correlation (&gt;0.9)
high_corr_pairs = []
for i in range(len(correlation_matrix.columns)):
    for j in range(i+1, len(correlation_matrix.columns)):
        if abs(correlation_matrix.iloc[i, j]) &gt; 0.9:
            high_corr_pairs.append((correlation_matrix.columns[i],
                                   correlation_matrix.columns[j]))

print(f"High correlation pairs: {len(high_corr_pairs)} pairs")
</code></pre>
<p><strong>3. Recursive Feature Elimination (RFE)</strong></p>
<pre><code class="language-python">from sklearn.feature_selection import RFE

# Select best 50 features
selector = RFE(model, n_features_to_select=50, step=1)
selector.fit(X_train, y_train)

selected_features = X.columns[selector.support_]
print(f"Selected features: {list(selected_features)}")
</code></pre>
<hr/>
<h2>2.8 Practical Pitfalls: Common Failures in MI Projects</h2>
<p>To succeed in MI projects, avoiding practical pitfalls is as important as technical skills. This section introduces six pitfalls beginners commonly fall into and countermeasures.</p>
<h3>2.8.1 Data Leakage</h3>
<p><strong>Problem:</strong></p>
<p>Data leakage is a phenomenon where test data information leaks into the training process, leading to overestimation of model performance.</p>
<p><strong>Common cases:</strong></p>
<p><strong>Case 1: Preprocessing errors</strong></p>
<pre><code class="language-python"># ‚ùå Wrong: Standardize all data then split
from sklearn.preprocessing import StandardScaler
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)  # Test data info leaks!

X_train, X_test, y_train, y_test = train_test_split(X_scaled, y, test_size=0.2)

# ‚úÖ Correct: Split first, then standardize only on training data
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)

scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)  # Learn only on training data
X_test_scaled = scaler.transform(X_test)  # Only transform test data
</code></pre>
<p><strong>Case 2: Handling time series data</strong></p>
<pre><code class="language-python"># ‚ùå Wrong: Random split (train on future data)
X_train, X_test = train_test_split(X, test_size=0.2, random_state=42)

# ‚úÖ Correct: Split by time order
split_point = int(len(X) * 0.8)
X_train = X[:split_point]  # Train on old data
X_test = X[split_point:]  # Test on new data
</code></pre>
<p><strong>Countermeasures:</strong>
- Preprocessing must learn only on training data, apply only to test data
- For time series data, split by time order
- Verify data leakage with cross-validation (GroupKFold, TimeSeriesSplit)</p>
<h3>2.8.2 Duplicate Structures</h3>
<p><strong>Problem:</strong></p>
<p>Materials databases sometimes have the same material registered multiple times with different IDs. This causes the same material to appear in both training and test data, overestimating performance.</p>
<p><strong>Detection method:</strong></p>
<pre><code class="language-python">from pymatgen.analysis.structure_matcher import StructureMatcher

# Determine structural similarity
matcher = StructureMatcher()

# Detect duplicates
duplicates = []
for i in range(len(structures)):
    for j in range(i+1, len(structures)):
        if matcher.fit(structures[i], structures[j]):
            duplicates.append((i, j))
            print(f"Duplicate found: {material_ids[i]} and {material_ids[j]}")

print(f"Number of duplicates: {len(duplicates)}")
</code></pre>
<p><strong>Countermeasures:</strong>
- Remove duplicates when constructing dataset
- Identify similar structures with structure matching
- Cross-check across different databases</p>
<h3>2.8.3 Polymorphs with Same Chemical Formula</h3>
<p><strong>Problem:</strong></p>
<p>Even with the same chemical formula, different crystal structures result in vastly different properties (e.g., diamond and graphite are both C). Using only composition-based descriptors cannot capture this difference.</p>
<p><strong>Concrete example: TiO2 polymorphs</strong></p>
<table>
<thead>
<tr>
<th>Polymorph</th>
<th>Space Group</th>
<th>Bandgap</th>
<th>Use</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Anatase</strong></td>
<td>I4‚ÇÅ/amd</td>
<td>3.2 eV</td>
<td>Photocatalyst</td>
</tr>
<tr>
<td><strong>Rutile</strong></td>
<td>P4‚ÇÇ/mnm</td>
<td>3.0 eV</td>
<td>Pigment</td>
</tr>
<tr>
<td><strong>Brookite</strong></td>
<td>Pbca</td>
<td>3.4 eV</td>
<td>Research</td>
</tr>
</tbody>
</table>
<p><strong>Countermeasure:</strong></p>
<pre><code class="language-python">from matminer.featurizers.structure import SiteStatsFingerprint

# Add structure-based descriptors
structure_featurizer = SiteStatsFingerprint.from_preset("LocalPropertyDifference")
structure_features = structure_featurizer.featurize_dataframe(df, col_id="structure")

# Use both composition and structure
X = pd.concat([composition_features, structure_features], axis=1)
</code></pre>
<p><strong>Countermeasures:</strong>
- Combine composition-based and structure-based descriptors
- Check <code>energy_above_hull</code> in database (select only stable phases)
- Ensure proper phase identification in experiments (XRD, etc.)</p>
<h3>2.8.4 Unit Cell Normalization</h3>
<p><strong>Problem:</strong></p>
<p>Crystal structures have two representations: conventional cell and primitive cell, which have different numbers of atoms even for the same material.</p>
<p><strong>Example: FCC metal case</strong>
- Conventional cell: 4 atoms
- Primitive cell: 1 atom</p>
<p><strong>Countermeasure:</strong></p>
<pre><code class="language-python">from pymatgen.symmetry.analyzer import SpacegroupAnalyzer

# Unify to primitive cell
analyzer = SpacegroupAnalyzer(structure)
primitive_structure = analyzer.get_primitive_standard_structure()

# Or normalize by number of atoms
formation_energy_per_atom = formation_energy / structure.num_sites
</code></pre>
<p><strong>Countermeasures:</strong>
- Unify all structures to primitive cell
- Always normalize energy per atom (eV/atom)
- Use descriptors that do not depend on number of atoms</p>
<h3>2.8.5 Handling Missing Values</h3>
<p><strong>Problem:</strong></p>
<p>In materials databases, not all materials have all property data. Inappropriate missing value handling significantly degrades prediction accuracy.</p>
<p><strong>Check missing values:</strong></p>
<pre><code class="language-python"># Requirements:
# - Python 3.9+
# - matplotlib&gt;=3.7.0
# - pandas&gt;=2.0.0, &lt;2.2.0
# - seaborn&gt;=0.12.0

"""
Example: Check missing values:

Purpose: Demonstrate data visualization techniques
Target: Intermediate
Execution time: 2-5 seconds
Dependencies: None
"""

import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

# Visualize missing values
missing = df.isnull().sum() / len(df) * 100
missing = missing[missing &gt; 0].sort_values(ascending=False)

plt.figure(figsize=(10, 6))
missing.plot(kind='bar')
plt.ylabel('Missing rate (%)')
plt.title('Missing rate by property')
plt.show()

print(f"Properties with missing values: {len(missing)}/{len(df.columns)}")
</code></pre>
<p><strong>Choose countermeasure:</strong></p>
<table>
<thead>
<tr>
<th>Missing Rate</th>
<th>Recommended Countermeasure</th>
<th>Reason</th>
</tr>
</thead>
<tbody>
<tr>
<td>&lt; 5%</td>
<td>Mean/median imputation</td>
<td>Small impact</td>
</tr>
<tr>
<td>5-20%</td>
<td>KNN imputation, iterative imputation</td>
<td>Use correlations with other properties</td>
</tr>
<tr>
<td>20-50%</td>
<td>Remove that property</td>
<td>Low imputation reliability</td>
</tr>
<tr>
<td>&gt; 50%</td>
<td>Remove data</td>
<td>Unusable</td>
</tr>
</tbody>
</table>
<p><strong>Imputation example:</strong></p>
<pre><code class="language-python">from sklearn.impute import KNNImputer

# KNN imputation (use values from similar materials)
imputer = KNNImputer(n_neighbors=5)
X_imputed = imputer.fit_transform(X_train)

# Or use only properties without missing values
df_clean = df.dropna(subset=['band_gap', 'formation_energy'])
</code></pre>
<p><strong>Countermeasures:</strong>
- Always check missing rate
- Analyze missing pattern (random or systematic)
- Validate validity of imputation method</p>
<h3>2.8.6 Outlier Impact</h3>
<p><strong>Problem:</strong></p>
<p>Calculation errors, measurement mistakes, or extreme materials exist as outliers and distort model learning.</p>
<p><strong>Detection method:</strong></p>
<pre><code class="language-python"># Requirements:
# - Python 3.9+
# - matplotlib&gt;=3.7.0
# - numpy&gt;=1.24.0, &lt;2.0.0

"""
Example: Detection method:

Purpose: Demonstrate data visualization techniques
Target: Intermediate
Execution time: 2-5 seconds
Dependencies: None
"""

import numpy as np
import matplotlib.pyplot as plt

# Visualize outliers with box plot
plt.figure(figsize=(12, 4))

plt.subplot(1, 3, 1)
plt.boxplot(df['formation_energy_per_atom'])
plt.title('Formation Energy (eV/atom)')

plt.subplot(1, 3, 2)
plt.boxplot(df['band_gap'])
plt.title('Band Gap (eV)')

plt.subplot(1, 3, 3)
plt.boxplot(df['density'])
plt.title('Density (g/cm¬≥)')

plt.tight_layout()
plt.show()

# Detect outliers by IQR method
Q1 = df['formation_energy_per_atom'].quantile(0.25)
Q3 = df['formation_energy_per_atom'].quantile(0.75)
IQR = Q3 - Q1

outliers = df[(df['formation_energy_per_atom'] &lt; Q1 - 1.5*IQR) |
              (df['formation_energy_per_atom'] &gt; Q3 + 1.5*IQR)]

print(f"Number of outliers: {len(outliers)}/{len(df)} ({len(outliers)/len(df)*100:.1f}%)")
print(outliers[['material_id', 'pretty_formula', 'formation_energy_per_atom']])
</code></pre>
<p><strong>Countermeasures:</strong></p>
<ol>
<li>
<p><strong>Identify cause:</strong>
   - Calculation error ‚Üí Remove
   - Measurement mistake ‚Üí Remove
   - Real extreme material ‚Üí Retain (but evaluate impact)</p>
</li>
<li>
<p><strong>Robust models:</strong>
   ```python
   from sklearn.ensemble import RandomForestRegressor
   from sklearn.linear_model import HuberRegressor  # Robust to outliers</p>
</li>
</ol>
<p># Random Forest is relatively robust to outliers
   model_rf = RandomForestRegressor()</p>
<p># Huber regression (robust to outliers)
   model_huber = HuberRegressor(epsilon=1.5)
   ```</p>
<ol start="3">
<li><strong>Transformation:</strong>
<code>python
   # Log transformation (normalize skewed distribution)
   df['log_formation_energy'] = np.log1p(np.abs(df['formation_energy_per_atom']))</code></li>
</ol>
<p><strong>Countermeasures:</strong>
- Always check outliers
- Check physical validity
- Compare performance before and after outlier removal</p>
<h3>2.8.7 Practical Checklist</h3>
<p>Items to check before starting MI projects:</p>
<p><strong>Data quality:</strong>
- [ ] Confirmed proportion and distribution of missing values?
- [ ] Removed duplicate structures?
- [ ] Detected and addressed outliers?
- [ ] Eliminated possibility of data leakage?</p>
<p><strong>Model construction:</strong>
- [ ] Did preprocessing learn only on training data?
- [ ] Performed appropriate data split? (time series, group, random)
- [ ] Evaluated generalization performance with cross-validation?
- [ ] Checked signs of overfitting?</p>
<p><strong>Result interpretation:</strong>
- [ ] Confirmed physical validity of prediction results?
- [ ] Understood model applicability scope?
- [ ] Evaluated uncertainty?</p>
<p><strong>Reproducibility:</strong>
- [ ] Fixed random seed?
- [ ] Recorded dependency library versions?
- [ ] Documented data preprocessing steps?</p>
<hr/>
<h2>2.9 End-of-Chapter Checklist: Quality Assurance</h2>
<p>Verify that you understand and can practice the content of this chapter.</p>
<h3>Conceptual Understanding</h3>
<ul>
<li>[ ] Can explain MI definition to others</li>
<li>[ ] Can explain differences from computational materials science and cheminformatics</li>
<li>[ ] Can show difference between forward and inverse design with concrete examples</li>
<li>[ ] Can correctly use at least 15 out of 20 MI terminology</li>
</ul>
<h3>Database Utilization (Application)</h3>
<ul>
<li>[ ] Understand Materials Project license and commercial use restrictions</li>
<li>[ ] Can differentiate uses of 4 databases (MP, AFLOW, OQMD, JARVIS)</li>
<li>[ ] Obtained API key and can retrieve data with Python</li>
<li>[ ] Know data citation methods and can include in code</li>
</ul>
<h3>Workflow Practice (Application)</h3>
<ul>
<li>[ ] Can set quantitative goals in problem formulation</li>
<li>[ ] Can check missing values and duplicates during data collection</li>
<li>[ ] Can select appropriate descriptors (composition/structure/property)</li>
<li>[ ] Can perform correct data split avoiding data leakage</li>
<li>[ ] Can evaluate generalization performance with cross-validation</li>
</ul>
<h3>Code Quality (Quality Assurance)</h3>
<ul>
<li>[ ] All code includes dependency library versions</li>
<li>[ ] Fixed random seed to ensure reproducibility</li>
<li>[ ] Performed data validation (shape, dtype, NaN, range)</li>
<li>[ ] Can write API access code handling rate limits</li>
</ul>
<h3>Practical Skills (Real-world Application)</h3>
<ul>
<li>[ ] Can recognize and avoid 5 data leakage patterns</li>
<li>[ ] Can detect and remove duplicate structures</li>
<li>[ ] Can select appropriate missing value handling methods</li>
<li>[ ] Can detect outliers and assess validity</li>
</ul>
<h3>Next Steps</h3>
<p><strong>If achievement rate &lt;80%:</strong>
- Re-read this chapter, focusing on poorly understood parts
- Solve exercises again
- Reinforce foundational knowledge with prerequisites.md</p>
<p><strong>If achievement rate 80-95%:</strong>
- Ready to proceed to Chapter 3 (Practical section)
- Deepen understanding while coding in Chapter 3</p>
<p><strong>If achievement rate ‚â•95%:</strong>
- Proceed to Chapter 3 and consolidate knowledge through actual code implementation
- If possible, start a simple MI project</p>
<hr/>
<h2>2.7 Summary</h2>
<h3>What You Learned in This Chapter</h3>
<ol>
<li>
<p><strong>MI Definition and Position</strong>
   - Integration of materials science and data science
   - Efficiency through inverse design approach
   - Differences from computational materials science and cheminformatics</p>
</li>
<li>
<p><strong>20 MI Terms</strong>
   - Data &amp; model related (descriptor, feature engineering, overfitting, etc.)
   - Computational methods related (DFT, Bayesian Optimization, GNN, etc.)
   - Materials science related (crystal structure, bandgap, phase diagram, etc.)</p>
</li>
<li>
<p><strong>Materials Databases</strong>
   - Materials Project: Largest scale, beginner-friendly
   - AFLOW: Most crystal structure data
   - OQMD: Strong in phase diagram calculations
   - JARVIS: Machine learning model integration
   - Using multiple databases concurrently is recommended</p>
</li>
<li>
<p><strong>MI Ecosystem</strong>
   - Cycle of data generation ‚Üí processing ‚Üí machine learning ‚Üí experimental validation ‚Üí improvement
   - Feedback loop is important</p>
</li>
<li>
<p><strong>5-Step MI Workflow</strong>
   - Step 0: Problem formulation (most important)
   - Step 1: Data collection (databases, papers, calculations)
   - Step 2: Model construction (descriptor design, training, evaluation)
   - Step 3: Prediction &amp; screening (efficiently evaluate large candidates)
   - Step 4: Experimental validation (synthesis &amp; measurement of top candidates)
   - Step 5: Data addition &amp; improvement (continuous improvement cycle)</p>
</li>
<li>
<p><strong>Material Descriptor Details</strong>
   - Three types: composition-based, structure-based, property-based
   - Automatic generation with Matminer
   - Importance of feature selection</p>
</li>
</ol>
<h3>To the Next Chapter</h3>
<p>In Chapter 3, we put this knowledge into practice. Using actual Python code, you will experience the entire workflow from data retrieval from materials databases, descriptor generation, machine learning model construction, to predictions.</p>
<hr/>
<h2>Exercises</h2>
<h3>Problem 1 (Difficulty: easy)</h3>
<p>Select 5 terms from the MI glossary and explain them in your own words.</p>
<details>
<summary>Sample Answer</summary>

**1. Descriptor**
Numerical representation of material features that can be input to machine learning models. Examples include element electronegativity and atomic radius.

**2. Screening**
Efficiently narrowing down materials with desired properties from a large pool of candidates. MI allows computational evaluation of thousands to tens of thousands of materials in a short time.

**3. Overfitting**
Phenomenon where a machine learning model memorizes training data and prediction performance on new data degrades. Can be detected by cross-validation.

**4. Bandgap**
In semiconductors, the energy difference between the electron-occupied valence band and empty conduction band. Important metric for solar cell design.

**5. Bayesian Optimization**
Method to search for optimal materials while minimizing the number of experiments. AI proposes which materials to experiment on next.

</details>
<h3>Problem 2 (Difficulty: medium)</h3>
<p>Regarding the use cases of Materials Project and AFLOW, answer which one to use for the following scenarios with reasons.</p>
<p><strong>Scenario A</strong>: Want to explore new lithium-ion battery cathode materials. Need bandgap and formation energy data.</p>
<p><strong>Scenario B</strong>: Want to find new materials with crystal structures similar to existing materials. Need structural similarity search.</p>
<details>
<summary>Sample Answer</summary>

**Scenario A: Use Materials Project**

**Reasons:**
- Materials Project has over 140,000 materials data with both bandgap and formation energy available
- Rich tools specialized for battery material research (voltage, capacity calculations, etc.)
- Well-developed Python library (pymatgen), easy data retrieval
- Intuitive Web UI, easy for beginners to use

**Scenario B: Use AFLOW**

**Reasons:**
- AFLOW has the most crystal structure data (3.5 million types)
- Fast and accurate structural similarity search functionality
- Standardized structure description through AFLOW prototypes makes similar structure exploration easy
- Rich tools specialized for structure exploration

**Summary:**
Materials Project is suitable when emphasizing property data, AFLOW when emphasizing structure exploration. In actual projects, both are often used together.

</details>
<h3>Problem 3 (Difficulty: medium)</h3>
<p>Explain why Step 0 (problem formulation) of the MI workflow is most important, with concrete examples.</p>
<details>
<summary>Hint</summary>

Vague problem formulation affects all subsequent steps. Consider the importance of clarifying target properties, constraints, and success criteria.

</details>
<details>
<summary>Sample Answer</summary>

**Importance of problem formulation:**

Insufficient problem formulation causes the following issues.

**Bad example:**
&gt; "Want to find high-performance catalyst materials"

**Problems:**
- "High-performance" not defined (reaction rate? Selectivity? Durability?)
- No constraints (cost, toxicity, availability)
- Unclear success criteria (when to stop exploration?)

**Consequences:**
1. Waste time in data collection (collect irrelevant data)
2. Model optimizes wrong objectives
3. Realize at experiment stage "actually different properties were important," need to start over

**Good example:**
&gt; "Discover catalyst materials for hydrogen production with the following properties:
&gt; - Reaction rate: ‚â•100 mol H2/(m¬≤¬∑h)
&gt; - Selectivity: ‚â•95% (suppress by-products other than hydrogen)
&gt; - Durability: activity ‚â•80% after 1000 hours continuous operation
&gt; - Cost: ‚â§$100/kg
&gt; - Constraint: Minimize precious metal use (Pt, Pd, etc.)"

**Effects:**
1. Clear data collection (prioritize reaction rate, selectivity, durability data)
2. Model optimizes correct objectives
3. Clear success criteria, easy to evaluate project progress
4. Easy to decide experiment priorities

**Value of time investment:**
Spending 1-2 weeks on problem formulation significantly reduces risk of wasting months to years of subsequent work.

</details>
<h3>Problem 4 (Difficulty: hard)</h3>
<p>There are three types of material descriptors: composition-based, structure-based, and property-based. List advantages and disadvantages of each, and explain in what situations they should be used.</p>
<details>
<summary>Hint</summary>

Consider the trade-offs between computational cost, required data, and prediction accuracy for each descriptor.

</details>
<details>
<summary>Sample Answer</summary>

**Composition-based Descriptors**

**Advantages:**
- Calculable from chemical formula alone (no crystal structure needed)
- Low computational cost (seconds)
- Applicable to unknown materials

**Disadvantages:**
- Ignores structural information (same composition but different structure ‚Üí different properties)
- Prediction accuracy may be lower than structure-based

**Use when:**
- Many materials with unknown crystal structures
- Need high-speed screening (tens of thousands)
- Project initial stages (rough screening)

**Structure-based Descriptors**

**Advantages:**
- Captures structure-property relationships (more accurate predictions)
- Can distinguish different structures with same composition

**Disadvantages:**
- Requires crystal structure data (determined experimentally or by DFT calculations)
- High computational cost
- For unknown materials, need to predict structure

**Use when:**
- Crystal structure data available
- Need high-accuracy predictions (narrowing down final candidates)
- Want to understand structure-property correlations

**Property-based Descriptors**

**Advantages:**
- Uses correlations between properties (e.g., high melting point materials tend to be hard)
- High accuracy for known materials

**Disadvantages:**
- Difficult to apply to unknown materials (need other properties to predict target property)
- Unclear causal relationships (why those properties are related)

**Use when:**
- Inferring one property from another for known materials
- Material systems with abundant experimental data
- Exploring correlations between properties

**Practical differentiation strategy:**

1. **Initial screening (tens of thousands)**: Composition-based descriptors
   - Quickly narrow down to ~1,000 candidates

2. **Intermediate screening (1,000)**: Structure-based descriptors
   - More accurately narrow down to ~100

3. **Final selection (100)**: Property-based descriptors (if possible)
   - Use known properties to determine final 10

4. **Experimental validation (10)**

This staged approach balances computational cost and prediction accuracy.

</details>
<hr/>
<h2>References</h2>
<ol>
<li>
<p><strong>Materials Genome Initiative (MGI)</strong> - White House Office of Science and Technology Policy (2011)
   URL: https://www.mgi.gov
   <em>Materials development acceleration project launched by the U.S. in 2011. Became the catalyst for global MI proliferation.</em></p>
</li>
<li>
<p>Ramprasad, R., Batra, R., Pilania, G., Mannodi-Kanakkithodi, A., &amp; Kim, C. (2017). "Machine learning in materials informatics: recent applications and prospects." <em>npj Computational Materials</em>, 3(1), 54.
   DOI: <a href="https://doi.org/10.1038/s41524-017-0056-5">10.1038/s41524-017-0056-5</a></p>
</li>
<li>
<p>Jain, A., Ong, S. P., Hautier, G., Chen, W., Richards, W. D., et al. (2013). "Commentary: The Materials Project: A materials genome approach to accelerating materials innovation." <em>APL Materials</em>, 1(1), 011002.
   DOI: <a href="https://doi.org/10.1063/1.4812323">10.1063/1.4812323</a>
   Materials Project: https://materialsproject.org</p>
</li>
<li>
<p>Curtarolo, S., Setyawan, W., Hart, G. L., Jahnatek, M., Chepulskii, R. V., et al. (2012). "AFLOW: An automatic framework for high-throughput materials discovery." <em>Computational Materials Science</em>, 58, 218-226.
   DOI: <a href="https://doi.org/10.1016/j.commatsci.2012.02.005">10.1016/j.commatsci.2012.02.005</a>
   AFLOW: http://www.aflowlib.org</p>
</li>
<li>
<p>Saal, J. E., Kirklin, S., Aykol, M., Meredig, B., &amp; Wolverton, C. (2013). "Materials Design and Discovery with High-Throughput Density Functional Theory: The Open Quantum Materials Database (OQMD)." <em>JOM</em>, 65(11), 1501-1509.
   DOI: <a href="https://doi.org/10.1007/s11837-013-0755-4">10.1007/s11837-013-0755-4</a>
   OQMD: http://oqmd.org</p>
</li>
<li>
<p>Choudhary, K., Garrity, K. F., Reid, A. C. E., DeCost, B., Biacchi, A. J., et al. (2020). "The joint automated repository for various integrated simulations (JARVIS) for data-driven materials design." <em>npj Computational Materials</em>, 6(1), 173.
   DOI: <a href="https://doi.org/10.1038/s41524-020-00440-1">10.1038/s41524-020-00440-1</a>
   JARVIS: https://jarvis.nist.gov</p>
</li>
</ol>
<hr/>
<p><strong>Author Information</strong></p>
<p>This article was created as part of the MI Knowledge Hub project under Dr. Yusuke Hashimoto at Tohoku University.</p>
<p><strong>Update History</strong>
- 2025-10-16: v3.0 Initial version
  - Expanded Section 2 from v2.1 (~2,000 words) to 4,000-5,000 words
  - Added 20-term glossary
  - Added detailed materials database comparison table
  - Added MI ecosystem diagram (Mermaid)
  - Added detailed explanation of 5-step workflow
  - Added in-depth section on material descriptors
  - Added 4 exercise problems (difficulty: 1 easy, 2 medium, 1 hard)</p>
<div class="navigation">
<a class="nav-button" href="chapter1-introduction.html">‚Üê Previous Chapter</a>
<a class="nav-button" href="index.html">Back to Series Index</a>
<a class="nav-button" href="chapter3-hands-on.html">Next Chapter ‚Üí</a>
</div>
</main>
<section class="disclaimer">
<h3>Disclaimer</h3>
<ul>
<li>This content is provided solely for educational, research, and informational purposes and does not constitute professional advice (legal, accounting, technical guarantees, etc.).</li>
<li>This content and accompanying code examples are provided "AS IS" without any warranties, express or implied, including merchantability, fitness for a particular purpose, non-infringement, accuracy, completeness, operation, or safety.</li>
<li>The author and Tohoku University assume no responsibility for the content, availability, or safety of external links, third-party data, tools, libraries, etc.</li>
<li>To the maximum extent permitted by applicable law, the author and Tohoku University are not liable for any direct, indirect, incidental, special, consequential, or punitive damages arising from the use, execution, or interpretation of this content.</li>
<li>The content may be changed, updated, or discontinued without notice.</li>
<li>Copyright and license of this content follow the stated conditions (e.g., CC BY 4.0). Such licenses typically include no-warranty clauses.</li>
</ul>
</section>
<footer>
<p><strong>Authors</strong>: AI Terakoya Content Team</p>
<p><strong>Version</strong>: 3.0 | <strong>Created</strong>: 2025-10-16</p>
<p><strong>License</strong>: Creative Commons BY 4.0</p>
<p>¬© 2025 AI Terakoya. All rights reserved.</p>
</footer>
</body>
</html>