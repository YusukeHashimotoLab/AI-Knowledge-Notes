<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Chapter - AI Terakoya</title>
<link href="../../assets/css/knowledge-base.css" rel="stylesheet"/>
<script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
<script>
        mermaid.initialize({ startOnLoad: true, theme: 'default', securityLevel: 'strict' });
    </script>
<!-- MathJax for LaTeX equation rendering -->
<script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\(', '\)']],
                displayMath: [['$$', '$$'], ['\[', '\]']],
                processEscapes: true,
                processEnvironments: true
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
                ignoreHtmlClass: 'mermaid'
            }
        };
    </script>
<script async="" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
<nav class="breadcrumb">
<div class="breadcrumb-content">
<a href="/AI-Knowledge-Notes/knowledge/en/index.html">AI Terakoya Home</a><span class="breadcrumb-separator">‚Ä∫</span><a href="/AI-Knowledge-Notes/knowledge/en/MI/index.html">Materials Informatics</a><span class="breadcrumb-separator">‚Ä∫</span><a href="/AI-Knowledge-Notes/knowledge/en/MI/data-driven-materials-introduction/index.html">Data Driven Materials</a><span class="breadcrumb-separator">‚Ä∫</span><span class="breadcrumb-current">Chapter 4</span>
</div>
</nav><div class="locale-switcher">
<span class="current-locale">üåê EN</span>
<span class="locale-separator">|</span>
<a href="../../../jp/MI/data-driven-materials-introduction/chapter-4.html" class="locale-link">üáØüáµ JP</a>
<span class="locale-separator">|</span>
<span class="locale-meta">Last sync: 2025-11-16</span>
</div>
<header>
<div class="header-content">
<h1>Chapter</h1>
<p class="subtitle"></p>
<div class="meta">
<span class="meta-item">üìñ Reading time: 20-25 minutes</span>
<span class="meta-item">üìä Difficulty: Beginner</span>
<span class="meta-item">üíª Code examples: 0</span>
<span class="meta-item">üìù Exercises: 0</span>
</div>
</div>
</header>
<main class="container">
<h1>Chapter 4: Explainable AI (XAI)</h1><p class="chapter-description">This chapter covers Explainable AI (XAI). You will learn Understanding the importance of interpretability, Local linear approximation, and Learning from real-world applications (Toyota.</p>


<hr/>
<h2>Learning Objectives</h2>
<p>By reading this chapter, you will master:</p>
<ul>
<li>‚úÖ Understanding the importance of interpretability and the black-box problem</li>
<li>‚úÖ Quantitative interpretation of predictions using SHAP (Shapley values)</li>
<li>‚úÖ Local linear approximation and explanation generation using LIME</li>
<li>‚úÖ Neural network interpretation through Attention visualization</li>
<li>‚úÖ Learning from real-world applications (Toyota, IBM, Citrine)</li>
<li>‚úÖ Career paths and salary information for materials data scientists</li>
</ul>
<hr/>
<h2>4.1 The Importance of Interpretability</h2>
<p>Understanding machine learning model predictions and extracting physical meaning is essential in materials science.</p>
<h3>The Black-Box Problem</h3>
<pre><code class="language-python"># Requirements:
# - Python 3.9+
# - matplotlib&gt;=3.7.0
# - numpy&gt;=1.24.0, &lt;2.0.0
# - pandas&gt;=2.0.0, &lt;2.2.0
# - seaborn&gt;=0.12.0

"""
Example: The Black-Box Problem

Purpose: Demonstrate data visualization techniques
Target: Advanced
Execution time: 2-5 seconds
Dependencies: None
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.ensemble import RandomForestRegressor
from sklearn.linear_model import Ridge

# Sample data
np.random.seed(42)
X = np.random.randn(200, 10)
y = 2*X[:, 0] + 3*X[:, 1] - 1.5*X[:, 2] + np.random.normal(0, 0.5, 200)

# Interpretable model vs black-box model
ridge = Ridge(alpha=1.0)
rf = RandomForestRegressor(n_estimators=100, random_state=42)

ridge.fit(X, y)
rf.fit(X, y)

# Ridge coefficients (interpretable)
ridge_coefs = ridge.coef_

# Visualization: Model interpretability differences
fig, axes = plt.subplots(1, 2, figsize=(14, 6))

# Ridge: Clear from linear coefficients
axes[0].bar(range(len(ridge_coefs)), ridge_coefs,
            color='steelblue', alpha=0.7)
axes[0].set_xlabel('Feature Index', fontsize=11)
axes[0].set_ylabel('Coefficient', fontsize=11)
axes[0].set_title('Ridge Regression (Interpretable)', fontsize=12, fontweight='bold')
axes[0].axhline(y=0, color='red', linestyle='--', linewidth=1)
axes[0].grid(alpha=0.3)

# Random Forest: Complex non-linear relationships (black-box)
axes[1].text(0.5, 0.5, '‚ùì\nBlack Box\n\n100 decision trees\nComplex non-linear relationships\nDifficult to interpret',
             ha='center', va='center', fontsize=16,
             bbox=dict(boxstyle='round', facecolor='gray', alpha=0.3),
             transform=axes[1].transAxes)
axes[1].set_title('Random Forest (Black-Box)',
                  fontsize=12, fontweight='bold')
axes[1].axis('off')

plt.tight_layout()
plt.show()

print("Interpretability challenges:")
print("- Linear models: Influence is clear from coefficients, but accuracy is low")
print("- Non-linear models: High accuracy, but why predictions are made is unclear")
print("‚Üí XAI (Explainable AI) aims for both")
</code></pre>
<h3>The Need for Physical Interpretation in Materials Science</h3>
<pre><code class="language-python"># Use cases for interpretability in materials science
use_cases = pd.DataFrame({
    'Use Case': [
        'New material discovery',
        'Synthesis condition optimization',
        'Process anomaly detection',
        'Property prediction',
        'Material design guidelines'
    ],
    'Importance of Interpretability': [10, 9, 8, 7, 10],
    'Reason': [
        'Understanding physical mechanisms leads to new discoveries',
        'Identify which parameters are critical',
        'Root cause of anomalies must be identified',
        'Verify prediction basis',
        'Extract design principles'
    ]
})

# Visualization
fig, ax = plt.subplots(figsize=(12, 6))

colors = plt.cm.YlOrRd(np.linspace(0.3, 0.9, len(use_cases)))

bars = ax.barh(use_cases['Use Case'],
               use_cases['Importance of Interpretability'],
               color=colors, alpha=0.7)

ax.set_xlabel('Importance of Interpretability (1-10)', fontsize=12)
ax.set_xlim(0, 10)
ax.set_title('Importance of Interpretability in Materials Science',
             fontsize=13, fontweight='bold')
ax.grid(axis='x', alpha=0.3)

# Add reason annotations
for idx, row in use_cases.iterrows():
    ax.text(row['Importance of Interpretability'] + 0.3, idx,
            row['Reason'], va='center', fontsize=9, style='italic')

plt.tight_layout()
plt.show()

print("Why XAI is needed in materials science:")
print("1. Verification of physical law consistency")
print("2. Reflection in experimental planning")
print("3. Integration of expert knowledge")
print("4. Accountability in papers and patents")
</code></pre>
<h3>Trustworthiness and Debugging</h3>
<pre><code class="language-python"># Example of discovering model prediction errors through interpretation
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_absolute_error

# Data generation (intentionally including noise)
X_data = np.random.randn(300, 5)
# Correct relationship: y = 2*X0 + 3*X1
y_true = 2*X_data[:, 0] + 3*X_data[:, 1] + np.random.normal(0, 0.3, 300)

# Add noise to some samples (simulate measurement error)
noise_idx = np.random.choice(300, 30, replace=False)
y_data = y_true.copy()
y_data[noise_idx] += np.random.normal(0, 5, 30)

# Training
X_train, X_test, y_train, y_test = train_test_split(
    X_data, y_data, test_size=0.2, random_state=42
)

model = RandomForestRegressor(n_estimators=100, random_state=42)
model.fit(X_train, y_train)

# Prediction
y_pred = model.predict(X_test)
mae = mean_absolute_error(y_test, y_pred)

# Identify samples with large errors
errors = np.abs(y_test - y_pred)
high_error_idx = np.where(errors &gt; np.percentile(errors, 90))[0]

print(f"Model MAE: {mae:.4f}")
print(f"Number of high-error samples: {len(high_error_idx)}")
print("\n‚Üí Use XAI to analyze causes of high-error samples")
print("  - Discover data quality issues")
print("  - Identify model weaknesses")
print("  - Verify physical validity")
</code></pre>
<hr/>
<h2>4.2 SHAP (SHapley Additive exPlanations)</h2>
<p>An interpretation method based on Shapley values from cooperative game theory.</p>
<h3>Shapley Values Theory</h3>
<pre><code class="language-python"># Requirements:
# - Python 3.9+
# - shap&gt;=0.42.0

"""
Example: Shapley Values Theory

Purpose: Demonstrate machine learning model training and evaluation
Target: Beginner
Execution time: 1-5 minutes
Dependencies: None
"""

import shap

# Visualize SHAP basic concept
shap.initjs()

# Model training
model_shap = RandomForestRegressor(n_estimators=100, random_state=42)
model_shap.fit(X_train, y_train)

# SHAP Explainer
explainer = shap.TreeExplainer(model_shap)
shap_values = explainer.shap_values(X_test)

print("Meaning of SHAP values:")
print("- How much each feature contributed to the prediction")
print("- Shapley value: Fair distribution from cooperative game theory")
print("- Expressed as deviation from base value")
print(f"\nSHAP values shape: {shap_values.shape}")
print(f"  Number of samples: {shap_values.shape[0]}")
print(f"  Number of features: {shap_values.shape[1]}")

# Explain single sample
sample_idx = 0
base_value = explainer.expected_value
prediction = model_shap.predict(X_test[sample_idx:sample_idx+1])[0]

print(f"\nPrediction for sample {sample_idx}:")
print(f"Base value: {base_value:.4f}")
print(f"Sum of SHAP values: {shap_values[sample_idx].sum():.4f}")
print(f"Prediction: {prediction:.4f}")
print(f"Verification: {base_value + shap_values[sample_idx].sum():.4f} ‚âà {prediction:.4f}")
</code></pre>
<h3>SHAP Value Computation (Tree SHAP, Kernel SHAP)</h3>
<pre><code class="language-python"># Tree SHAP (fast, tree-based models only)
explainer_tree = shap.TreeExplainer(model_shap)
shap_values_tree = explainer_tree.shap_values(X_test)

# Kernel SHAP (model-agnostic, slow)
# Demo with small sample
X_test_small = X_test[:10]
explainer_kernel = shap.KernelExplainer(
    model_shap.predict,
    shap.sample(X_train, 50)
)
shap_values_kernel = explainer_kernel.shap_values(X_test_small)

print("Comparison of SHAP computation methods:")
print("\nTree SHAP:")
print(f"  Target models: Tree-based (RF, XGBoost, LightGBM)")
print(f"  Computation speed: Fast")
print(f"  Accuracy: Exact solution")

print("\nKernel SHAP:")
print(f"  Target models: Any (including neural networks)")
print(f"  Computation speed: Slow")
print(f"  Accuracy: Approximate solution (sampling-based)")

# Simple computation time comparison
import time

start = time.time()
_ = explainer_tree.shap_values(X_test)
tree_time = time.time() - start

print(f"\nTree SHAP computation time: {tree_time:.3f} seconds ({len(X_test)} samples)")
</code></pre>
<h3>Global vs Local Interpretation</h3>
<pre><code class="language-python"># Global interpretation: Average importance across all samples
mean_abs_shap = np.abs(shap_values).mean(axis=0)

fig, axes = plt.subplots(1, 2, figsize=(14, 6))

# Global interpretation
axes[0].bar(range(len(mean_abs_shap)), mean_abs_shap,
            color='steelblue', alpha=0.7)
axes[0].set_xlabel('Feature Index', fontsize=11)
axes[0].set_ylabel('Mean |SHAP value|', fontsize=11)
axes[0].set_title('Global Interpretation (Overall Importance)',
                  fontsize=12, fontweight='bold')
axes[0].grid(alpha=0.3)

# Local interpretation: Specific sample
sample_idx = 0
axes[1].bar(range(len(shap_values[sample_idx])),
            shap_values[sample_idx],
            color='coral', alpha=0.7)
axes[1].axhline(y=0, color='black', linestyle='-', linewidth=1)
axes[1].set_xlabel('Feature Index', fontsize=11)
axes[1].set_ylabel('SHAP value', fontsize=11)
axes[1].set_title(f'Local Interpretation (Sample {sample_idx} explanation)',
                  fontsize=12, fontweight='bold')
axes[1].grid(alpha=0.3)

plt.tight_layout()
plt.show()

print("Global vs Local interpretation:")
print("\nGlobal:")
print("  - Average feature importance across all samples")
print("  - Understand overall model behavior")
print("  - General guidelines for new material design")

print("\nLocal:")
print("  - Basis for individual predictions")
print("  - Identify causes of anomalous samples")
print("  - Optimization direction for specific materials")
</code></pre>
<h3>Summary Plot, Dependence Plot</h3>
<pre><code class="language-python"># Summary plot (overview)
plt.figure(figsize=(10, 8))
shap.summary_plot(shap_values, X_test, plot_type="dot", show=False)
plt.title('SHAP Summary Plot', fontsize=13, fontweight='bold', pad=20)
plt.tight_layout()
plt.show()

print("How to read Summary Plot:")
print("- Vertical axis: Features (ordered by importance)")
print("- Horizontal axis: SHAP value (influence on prediction)")
print("- Color: Feature value (red=high, blue=low)")
print("- Distribution: Diversity of influence for each feature")

# Dependence plot (detailed for individual features)
feature_idx = 0

plt.figure(figsize=(10, 6))
shap.dependence_plot(
    feature_idx,
    shap_values,
    X_test,
    show=False
)
plt.title(f'SHAP Dependence Plot (Feature {feature_idx})',
          fontsize=13, fontweight='bold')
plt.tight_layout()
plt.show()

print("\nHow to read Dependence Plot:")
print("- Horizontal axis: Feature value")
print("- Vertical axis: SHAP value (influence on prediction)")
print("- Color: Another feature that interacts")
print("- Trend: Visualization of non-linear relationships")
</code></pre>
<hr/>
<h2>4.3 LIME (Local Interpretable Model-agnostic Explanations)</h2>
<p>An explanation generation method based on local linear approximation.</p>
<h3>Local Linear Approximation</h3>
<pre><code class="language-python"># Requirements:
# - Python 3.9+
# - lime&gt;=0.2.0

"""
Example: Local Linear Approximation

Purpose: Demonstrate data visualization techniques
Target: Beginner
Execution time: 1-5 minutes
Dependencies: None
"""

from lime import lime_tabular

# LIME Explainer
lime_explainer = lime_tabular.LimeTabularExplainer(
    X_train,
    mode='regression',
    feature_names=[f'Feature_{i}' for i in range(X_train.shape[1])],
    verbose=False
)

# Explain single sample
sample_idx = 0
explanation = lime_explainer.explain_instance(
    X_test[sample_idx],
    model_shap.predict,
    num_features=5
)

# Visualization
fig = explanation.as_pyplot_figure()
plt.title(f'LIME Explanation (Sample {sample_idx})',
          fontsize=13, fontweight='bold')
plt.tight_layout()
plt.show()

print("How LIME works:")
print("1. Random sampling around target sample")
print("2. Predictions by black-box model")
print("3. Distance-based weighting")
print("4. Train local linear model")
print("5. Explain using linear coefficients")

# Display explanation numerically
print("\nExplanations (by importance):")
for feature, weight in explanation.as_list():
    print(f"  {feature}: {weight:.4f}")
</code></pre>
<h3>Tabular LIME</h3>
<pre><code class="language-python"># Run LIME on multiple samples
n_samples_lime = 5
lime_results = []

for i in range(n_samples_lime):
    exp = lime_explainer.explain_instance(
        X_test[i],
        model_shap.predict,
        num_features=X_train.shape[1]
    )

    # Convert explanation to dictionary
    exp_dict = dict(exp.as_list())
    lime_results.append(exp_dict)

# Convert to DataFrame
lime_df = pd.DataFrame(lime_results)

print(f"\nLIME explanations for {n_samples_lime} samples:")
print(lime_df.head())

# Evaluate consistency (are same features always important?)
feature_importance_consistency = lime_df.abs().mean()
print("\nAverage feature importance (LIME):")
print(feature_importance_consistency.sort_values(ascending=False))
</code></pre>
<h3>Generating Prediction Explanations</h3>
<pre><code class="language-python"># SHAP vs LIME comparison
def compare_shap_lime(sample_idx):
    """
    Compare SHAP vs LIME explanations for the same sample
    """
    # SHAP
    shap_exp = shap_values[sample_idx]

    # LIME
    lime_exp = lime_explainer.explain_instance(
        X_test[sample_idx],
        model_shap.predict,
        num_features=X_train.shape[1]
    )
    lime_dict = dict(lime_exp.as_list())

    # Align LIME explanations to same order as SHAP
    lime_exp_ordered = []
    for i in range(len(shap_exp)):
        feature_name = f'Feature_{i}'
        # Search for corresponding feature in LIME explanation
        for key, value in lime_dict.items():
            if feature_name in key:
                lime_exp_ordered.append(value)
                break
        else:
            lime_exp_ordered.append(0)

    return shap_exp, np.array(lime_exp_ordered)

# Compare
sample_idx = 0
shap_exp, lime_exp = compare_shap_lime(sample_idx)

# Visualization
fig, ax = plt.subplots(figsize=(12, 6))

x_pos = np.arange(len(shap_exp))
width = 0.35

ax.bar(x_pos - width/2, shap_exp, width,
       label='SHAP', color='steelblue', alpha=0.7)
ax.bar(x_pos + width/2, lime_exp, width,
       label='LIME', color='coral', alpha=0.7)

ax.set_xlabel('Feature Index', fontsize=12)
ax.set_ylabel('Importance', fontsize=12)
ax.set_title(f'SHAP vs LIME (Sample {sample_idx})',
             fontsize=13, fontweight='bold')
ax.set_xticks(x_pos)
ax.legend()
ax.grid(alpha=0.3)
ax.axhline(y=0, color='black', linestyle='-', linewidth=1)

plt.tight_layout()
plt.show()

# Correlation analysis
correlation = np.corrcoef(shap_exp, lime_exp)[0, 1]
print(f"\nSHAP-LIME correlation: {correlation:.4f}")
print("High correlation ‚Üí Consistent explanations from both methods")
</code></pre>
<hr/>
<h2>4.4 Attention Visualization (for NN/GNN)</h2>
<p>Visualizing the Attention mechanism in neural networks.</p>
<h3>Visualizing Attention Weights</h3>
<pre><code class="language-python"># Simple demo of Attention mechanism
from sklearn.neural_network import MLPRegressor

# Train neural network
nn_model = MLPRegressor(
    hidden_layer_sizes=(50, 50),
    max_iter=1000,
    random_state=42
)
nn_model.fit(X_train, y_train)

# Get activation of intermediate layer (simple version)
def get_activation(model, X, layer_idx=0):
    """
    Get activation of specified layer
    """
    # Weights and biases
    W = model.coefs_[layer_idx]
    b = model.intercepts_[layer_idx]

    # Activation (ReLU)
    activation = np.maximum(0, X @ W + b)

    return activation

# Activation of first layer
activation_layer1 = get_activation(nn_model, X_test, layer_idx=0)

# Attention-like weights (treat activation magnitude as weights)
attention_weights = np.abs(activation_layer1).mean(axis=1)

# Visualization
plt.figure(figsize=(12, 6))
plt.scatter(range(len(attention_weights)), attention_weights,
            c=y_test, cmap='viridis', s=100, alpha=0.6)
plt.colorbar(label='Target Value')
plt.xlabel('Sample Index', fontsize=12)
plt.ylabel('Attention Weight (Activation Strength)', fontsize=12)
plt.title('Attention-like Weights (First Layer Activation)',
          fontsize=13, fontweight='bold')
plt.grid(alpha=0.3)
plt.tight_layout()
plt.show()

print("Significance of Attention visualization:")
print("- Which inputs is the model attending to?")
print("- Identification of important samples and features")
print("- Understanding internal behavior of neural networks")
</code></pre>
<h3>Grad-CAM for Materials</h3>
<pre><code class="language-python"># Gradient-based importance (simplified version)
def gradient_based_importance(model, X_sample):
    """
    Gradient-based feature importance
    """
    # Approximate with numerical differentiation
    epsilon = 1e-5
    base_pred = model.predict(X_sample.reshape(1, -1))[0]

    importances = []
    for i in range(len(X_sample)):
        X_perturbed = X_sample.copy()
        X_perturbed[i] += epsilon

        perturbed_pred = model.predict(X_perturbed.reshape(1, -1))[0]

        # Gradient approximation
        gradient = (perturbed_pred - base_pred) / epsilon
        importances.append(gradient)

    return np.array(importances)

# Execute on sample
sample_idx = 0
grad_importances = gradient_based_importance(nn_model, X_test[sample_idx])

# Compare SHAP, LIME, and Gradient
fig, axes = plt.subplots(1, 3, figsize=(18, 5))

# SHAP
axes[0].bar(range(len(shap_exp)), shap_exp,
            color='steelblue', alpha=0.7)
axes[0].axhline(y=0, color='black', linestyle='-', linewidth=1)
axes[0].set_xlabel('Feature', fontsize=11)
axes[0].set_ylabel('Importance', fontsize=11)
axes[0].set_title('SHAP', fontsize=12, fontweight='bold')
axes[0].grid(alpha=0.3)

# LIME
axes[1].bar(range(len(lime_exp)), lime_exp,
            color='coral', alpha=0.7)
axes[1].axhline(y=0, color='black', linestyle='-', linewidth=1)
axes[1].set_xlabel('Feature', fontsize=11)
axes[1].set_ylabel('Importance', fontsize=11)
axes[1].set_title('LIME', fontsize=12, fontweight='bold')
axes[1].grid(alpha=0.3)

# Gradient
axes[2].bar(range(len(grad_importances)), grad_importances,
            color='green', alpha=0.7)
axes[2].axhline(y=0, color='black', linestyle='-', linewidth=1)
axes[2].set_xlabel('Feature', fontsize=11)
axes[2].set_ylabel('Gradient', fontsize=11)
axes[2].set_title('Gradient-based', fontsize=12, fontweight='bold')
axes[2].grid(alpha=0.3)

plt.tight_layout()
plt.show()

print("Characteristics of three methods:")
print("SHAP: Game-theoretic fairness, works with all models")
print("LIME: Local linear approximation, intuitive")
print("Gradient: Gradient information, specialized for neural networks")
</code></pre>
<h3>Which Atoms/Bonds are Important?</h3>
<pre><code class="language-python"># Application example in materials science: Element importance
composition_features = ['Li', 'Co', 'Ni', 'Mn', 'O']

# Simulation data
X_composition = pd.DataFrame({
    'Li': np.random.uniform(0.9, 1.1, 100),
    'Co': np.random.uniform(0, 0.6, 100),
    'Ni': np.random.uniform(0, 0.8, 100),
    'Mn': np.random.uniform(0, 0.4, 100),
    'O': np.random.uniform(1.9, 2.1, 100)
})

# Capacity (Ni is important)
y_capacity = (
    150 * X_composition['Ni'] +
    120 * X_composition['Co'] +
    80 * X_composition['Mn'] +
    np.random.normal(0, 5, 100)
)

# Model training
model_comp = RandomForestRegressor(n_estimators=100, random_state=42)
model_comp.fit(X_composition, y_capacity)

# SHAP analysis
explainer_comp = shap.TreeExplainer(model_comp)
shap_values_comp = explainer_comp.shap_values(X_composition)

# Element-wise importance
mean_abs_shap_comp = np.abs(shap_values_comp).mean(axis=0)

# Visualization
plt.figure(figsize=(10, 6))
plt.bar(composition_features, mean_abs_shap_comp,
        color=['#FFD700', '#4169E1', '#32CD32', '#FF69B4', '#FF6347'],
        alpha=0.7, edgecolor='black', linewidth=1.5)
plt.xlabel('Element', fontsize=12)
plt.ylabel('Mean |SHAP value|', fontsize=12)
plt.title('Element Contribution to Battery Capacity (SHAP Analysis)',
          fontsize=13, fontweight='bold')
plt.grid(axis='y', alpha=0.3)
plt.tight_layout()
plt.show()

print("Element-wise importance:")
for elem, importance in zip(composition_features, mean_abs_shap_comp):
    print(f"  {elem}: {importance:.2f}")

print("\nImplications for material design:")
print("‚Üí Increasing Ni content is expected to improve capacity")
</code></pre>
<hr/>
<h2>4.5 Real-World Applications and Career Paths</h2>
<p>We introduce industry applications of XAI and career information for materials data scientists.</p>
<h3>Toyota: XAI Application in Materials Development</h3>
<pre><code class="language-python"># Toyota case study (simulation)
print("=== Toyota Automotive Materials Development Case ===")
print("\nChallenge:")
print("  - Clarify battery material degradation mechanisms")
print("  - Select optimal materials from thousands of candidates")

print("\nXAI Application:")
print("  - Identify degradation contributing factors with SHAP analysis")
print("  - Visualize interactions between temperature, voltage, and cycle count")
print("  - Verify consistency with physical models")

print("\nResults:")
print("  - Development time reduced by 40%")
print("  - Battery lifetime improved by 20%")
print("  - Researchers gained physical insights")

# Simulation: Battery degradation prediction
battery_aging = pd.DataFrame({
    'Temperature': np.random.uniform(20, 60, 200),
    'Voltage': np.random.uniform(3.0, 4.5, 200),
    'Cycle Count': np.random.uniform(0, 1000, 200),
    'Charge Rate': np.random.uniform(0.5, 2.0, 200)
})

# Degradation rate (temperature and cycles are main factors)
degradation = (
    0.5 * battery_aging['Temperature'] +
    0.3 * battery_aging['Cycle Count'] / 100 +
    0.2 * battery_aging['Voltage'] * battery_aging['Charge Rate'] +
    np.random.normal(0, 2, 200)
)

# Model
model_aging = RandomForestRegressor(n_estimators=100, random_state=42)
model_aging.fit(battery_aging, degradation)

# SHAP analysis
explainer_aging = shap.TreeExplainer(model_aging)
shap_values_aging = explainer_aging.shap_values(battery_aging)

# Visualization
plt.figure(figsize=(10, 8))
shap.summary_plot(shap_values_aging, battery_aging, show=False)
plt.title('SHAP Analysis of Battery Degradation Factors (Toyota-style Case)',
          fontsize=13, fontweight='bold', pad=20)
plt.tight_layout()
plt.show()
</code></pre>
<h3>IBM Research: Interpretability in AI Materials Design</h3>
<pre><code class="language-python"># Requirements:
# - Python 3.9+
# - networkx&gt;=3.1.0

"""
Example: IBM Research: Interpretability in AI Materials Design

Purpose: Demonstrate data visualization techniques
Target: Advanced
Execution time: 2-5 seconds
Dependencies: None
"""

print("\n=== IBM Research Materials Design Case ===")
print("\nProject: RoboRXN (Automated Chemistry Experiments)")
print("\nCharacteristics:")
print("  - XAI integrated into reaction condition optimization")
print("  - SHAP + Attention for reaction mechanism prediction")
print("  - Generate chemist-understandable recommendations")

print("\nTechnology Stack:")
print("  - Graph Neural Network (GNN)")
print("  - Attention mechanism")
print("  - SHAP for molecular graphs")

print("\nResults:")
print("  - Reaction yield prediction accuracy 95%")
print("  - Gained chemist trust")
print("  - Discovered novel reaction pathways")

# Molecular graph importance visualization (conceptual)
fig, ax = plt.subplots(figsize=(10, 8))

# Dummy molecular graph
import networkx as nx

G = nx.Graph()
G.add_edges_from([
    (0, 1), (1, 2), (2, 3), (3, 4), (4, 0),
    (1, 5), (3, 6)
])

pos = nx.spring_layout(G, seed=42)

# Node importance (Attention weights-like)
node_importance = np.random.rand(len(G.nodes))
node_importance = node_importance / node_importance.sum()

nx.draw(
    G, pos,
    node_color=node_importance,
    node_size=1000 * node_importance / node_importance.max(),
    cmap='YlOrRd',
    with_labels=True,
    font_size=12,
    font_weight='bold',
    edge_color='gray',
    width=2,
    ax=ax
)

sm = plt.cm.ScalarMappable(
    cmap='YlOrRd',
    norm=plt.Normalize(vmin=0, vmax=node_importance.max())
)
sm.set_array([])
cbar = plt.colorbar(sm, ax=ax, label='Attention Weight')

ax.set_title('Molecular Graph Attention Visualization (IBM-style)',
             fontsize=13, fontweight='bold')
plt.tight_layout()
plt.show()
</code></pre>
<h3>Startup: Citrine Informatics (Explainable AI)</h3>
<pre><code class="language-python">print("\n=== Citrine Informatics Case ===")
print("\nBusiness Model:")
print("  - Provides materials development platform")
print("  - Core technology: Explainable AI")
print("  - SaaS deployment to major manufacturers")

print("\nTechnical Features:")
print("  - Bayesian optimization + XAI")
print("  - Uncertainty quantification")
print("  - Integration of physical constraints")

print("\nCustomer Cases:")
print("  - Panasonic: 50% faster battery material development")
print("  - 3M: 30% improvement in adhesive performance")
print("  - Michelin: Tire rubber optimization")

print("\nDifferentiation Factors:")
print("  - Gain expert trust through explainability")
print("  - Integration with physical models")
print("  - High accuracy with small datasets")

# Citrine approach (simulation)
# Predictions with uncertainty + SHAP

from sklearn.ensemble import GradientBoostingRegressor

# Model (quantile regression-style)
model_citrine_lower = GradientBoostingRegressor(
    loss='quantile', alpha=0.1, n_estimators=100, random_state=42
)
model_citrine_median = GradientBoostingRegressor(
    n_estimators=100, random_state=42
)
model_citrine_upper = GradientBoostingRegressor(
    loss='quantile', alpha=0.9, n_estimators=100, random_state=42
)

X_citrine = X_composition
y_citrine = y_capacity

model_citrine_lower.fit(X_citrine, y_citrine)
model_citrine_median.fit(X_citrine, y_citrine)
model_citrine_upper.fit(X_citrine, y_citrine)

# Prediction
X_new = X_citrine.iloc[:20]
y_pred_lower = model_citrine_lower.predict(X_new)
y_pred_median = model_citrine_median.predict(X_new)
y_pred_upper = model_citrine_upper.predict(X_new)

# Visualization
fig, ax = plt.subplots(figsize=(12, 6))

x_axis = range(len(X_new))

ax.fill_between(x_axis, y_pred_lower, y_pred_upper,
                alpha=0.3, color='steelblue',
                label='80% Prediction Interval')
ax.plot(x_axis, y_pred_median, 'o-',
        color='steelblue', linewidth=2, label='Prediction Median')

ax.set_xlabel('Material Sample', fontsize=12)
ax.set_ylabel('Capacity (mAh/g)', fontsize=12)
ax.set_title('Citrine-style Prediction with Uncertainty',
             fontsize=13, fontweight='bold')
ax.legend()
ax.grid(alpha=0.3)

plt.tight_layout()
plt.show()

print("\nBenefits of uncertainty:")
print("  - Risk assessment")
print("  - Prioritization of additional experiments")
print("  - Increased confidence in decision-making")
</code></pre>
<h3>Career Path: Materials Data Scientists, XAI Researchers</h3>
<pre><code class="language-python"># Career path information
career_paths = pd.DataFrame({
    'Career Path': [
        'Materials Data Scientist',
        'XAI Researcher (Academia)',
        'ML Engineer (Materials-specialized)',
        'R&amp;D Manager (AI adoption)',
        'Technical Consultant'
    ],
    'Required Skills': [
        'Materials Science + ML + Python',
        'Statistics + ML Theory + Paper Writing',
        'ML Implementation + MLOps',
        'Materials Science + Project Management',
        'Materials Science + ML + Business'
    ],
    'Example Employers': [
        'Toyota, Panasonic, Mitsubishi Chemical',
        'Universities, AIST, RIKEN',
        'Citrine, Materials Zone',
        'Large Manufacturing R&amp;D Divisions',
        'Accenture, Deloitte'
    ]
})

print("\n=== Career Paths ===")
print(career_paths.to_string(index=False))
</code></pre>
<h3>Salary: ¬•7-15 million (Japan), $90-180K (US)</h3>
<pre><code class="language-python"># Salary data
salary_data = pd.DataFrame({
    'Position': [
        'Junior (0-3 years)',
        'Mid-level (3-7 years)',
        'Senior (7-15 years)',
        'Lead Scientist',
        'Manager'
    ],
    'Japan_Low': [500, 700, 1000, 1200, 1500],
    'Japan_High': [700, 1000, 1500, 2000, 2500],
    'US_Low': [70, 90, 130, 150, 180],
    'US_High': [90, 130, 180, 220, 300]
})

# Visualization
fig, axes = plt.subplots(1, 2, figsize=(16, 6))

# Japan
axes[0].barh(salary_data['Position'],
             salary_data['Japan_High'] - salary_data['Japan_Low'],
             left=salary_data['Japan_Low'],
             color='steelblue', alpha=0.7)

for idx, row in salary_data.iterrows():
    axes[0].text(row['Japan_Low'] - 50, idx,
                 f"{row['Japan_Low']}", va='center', ha='right', fontsize=9)
    axes[0].text(row['Japan_High'] + 50, idx,
                 f"{row['Japan_High']}", va='center', ha='left', fontsize=9)

axes[0].set_xlabel('Annual Salary (ten thousand yen)', fontsize=12)
axes[0].set_title('Japan Salary Range', fontsize=13, fontweight='bold')
axes[0].grid(axis='x', alpha=0.3)

# US
axes[1].barh(salary_data['Position'],
             salary_data['US_High'] - salary_data['US_Low'],
             left=salary_data['US_Low'],
             color='coral', alpha=0.7)

for idx, row in salary_data.iterrows():
    axes[1].text(row['US_Low'] - 5, idx,
                 f"${row['US_Low']}K", va='center', ha='right', fontsize=9)
    axes[1].text(row['US_High'] + 5, idx,
                 f"${row['US_High']}K", va='center', ha='left', fontsize=9)

axes[1].set_xlabel('Annual Salary (thousand dollars)', fontsize=12)
axes[1].set_title('US Salary Range', fontsize=13, fontweight='bold')
axes[1].grid(axis='x', alpha=0.3)

plt.tight_layout()
plt.show()

print("\nFactors affecting salary:")
print("  - Degree (Master's vs PhD)")
print("  - Industry (Manufacturing vs IT)")
print("  - Location (Tokyo vs Regional, Silicon Valley vs Other)")
print("  - Skillset (Materials Science + ML + Domain Knowledge)")
print("  - Track Record (Papers, Patents, Project Success)")

print("\nSkill Development Strategy:")
print("  1. Strengthen materials science fundamentals (degree recommended)")
print("  2. Practical ML/DL skills (Kaggle, GitHub)")
print("  3. Master XAI methods (SHAP, LIME)")
print("  4. Publish papers and contribute to OSS")
print("  5. Network (conferences, meetups)")
</code></pre>
<hr/>
<h2>Exercises</h2>
<h3>Problem 1 (Difficulty: Easy)</h3>
<p>Using SHAP and LIME, generate explanations for the same sample and calculate the correlation of feature importance. Discuss what high and low correlations mean.</p>
<details>
<summary>Solution Example</summary>
<pre><code class="language-python"># Requirements:
# - Python 3.9+
# - lime&gt;=0.2.0
# - numpy&gt;=1.24.0, &lt;2.0.0
# - shap&gt;=0.42.0

"""
Example: Using SHAP and LIME, generate explanations for the same samp

Purpose: Demonstrate machine learning model training and evaluation
Target: Advanced
Execution time: 30-60 seconds
Dependencies: None
"""

import shap
from lime import lime_tabular
from sklearn.ensemble import RandomForestRegressor
import numpy as np

# Model training
model = RandomForestRegressor(n_estimators=100, random_state=42)
model.fit(X_train, y_train)

# SHAP
explainer_shap = shap.TreeExplainer(model)
shap_values = explainer_shap.shap_values(X_test)

# LIME
explainer_lime = lime_tabular.LimeTabularExplainer(
    X_train, mode='regression'
)

sample_idx = 0

# LIME explanation
lime_exp = explainer_lime.explain_instance(
    X_test[sample_idx], model.predict, num_features=X_train.shape[1]
)
lime_dict = dict(lime_exp.as_list())

# Calculate correlation
shap_importances = shap_values[sample_idx]
lime_importances = [lime_dict.get(f'Feature_{i}', 0)
                    for i in range(len(shap_importances))]

correlation = np.corrcoef(shap_importances, lime_importances)[0, 1]
print(f"SHAP-LIME correlation: {correlation:.4f}")

if correlation &gt; 0.7:
    print("High correlation: Consistent explanations from both methods ‚Üí High reliability")
else:
    print("Low correlation: Explanation discrepancy ‚Üí Careful interpretation needed")
</code></pre>
</details>
<h3>Problem 2 (Difficulty: Medium)</h3>
<p>Using SHAP Dependence Plot, visualize interactions between two features. Analyze whether non-linear relationships or interactions are observed.</p>
<details>
<summary>Solution Example</summary>
<pre><code class="language-python"># Requirements:
# - Python 3.9+
# - matplotlib&gt;=3.7.0
# - shap&gt;=0.42.0

"""
Example: Using SHAP Dependence Plot, visualize interactions between t

Purpose: Demonstrate data visualization techniques
Target: Beginner to Intermediate
Execution time: 2-5 seconds
Dependencies: None
"""

import shap
import matplotlib.pyplot as plt

# SHAP calculation
explainer = shap.TreeExplainer(model)
shap_values = explainer.shap_values(X_test)

# Dependence Plot (feature 0 and feature 1 interaction)
fig, axes = plt.subplots(1, 2, figsize=(16, 6))

shap.dependence_plot(0, shap_values, X_test, interaction_index=1,
                     ax=axes[0], show=False)
axes[0].set_title('Feature 0 (interaction with Feature 1)')

shap.dependence_plot(1, shap_values, X_test, interaction_index=0,
                     ax=axes[1], show=False)
axes[1].set_title('Feature 1 (interaction with Feature 0)')

plt.tight_layout()
plt.show()

print("Analysis Points:")
print("- Color variation: Strength of interaction")
print("- Non-linear patterns: Complex relationships")
print("- Trend: Direction of influence (positive/negative)")
</code></pre>
</details>
<h3>Problem 3 (Difficulty: Hard)</h3>
<p>Mimic the Toyota battery degradation prediction case and perform SHAP analysis on three factors (temperature, voltage, cycle count), quantitatively evaluating which factor contributes most to degradation. Also discuss physical validity.</p>
<details>
<summary>Solution Example</summary>
<pre><code class="language-python"># Requirements:
# - Python 3.9+
# - numpy&gt;=1.24.0, &lt;2.0.0
# - pandas&gt;=2.0.0, &lt;2.2.0
# - shap&gt;=0.42.0

"""
Example: Mimic the Toyota battery degradation prediction case and per

Purpose: Demonstrate data visualization techniques
Target: Advanced
Execution time: 30-60 seconds
Dependencies: None
"""

import pandas as pd
import numpy as np
from sklearn.ensemble import GradientBoostingRegressor
import shap

# Data generation
battery_data = pd.DataFrame({
    'Temperature': np.random.uniform(20, 60, 300),
    'Voltage': np.random.uniform(3.0, 4.5, 300),
    'Cycle Count': np.random.uniform(0, 1000, 300)
})

# Degradation rate (physically reasonable model)
# Degradation increases with high temperature, high voltage, and many cycles
degradation = (
    0.8 * (battery_data['Temperature'] - 20) +  # High temp accelerates degradation
    2.0 * (battery_data['Voltage'] - 3.0)**2 +  # High voltage accelerates degradation
    0.05 * battery_data['Cycle Count'] +  # Cycle degradation
    0.01 * battery_data['Temperature'] * battery_data['Cycle Count'] / 100 +  # Interaction
    np.random.normal(0, 3, 300)
)

# Model training
model = GradientBoostingRegressor(n_estimators=100, random_state=42)
model.fit(battery_data, degradation)

# SHAP analysis
explainer = shap.TreeExplainer(model)
shap_values = explainer.shap_values(battery_data)

# Importance aggregation
mean_abs_shap = np.abs(shap_values).mean(axis=0)
feature_names = battery_data.columns

print("Degradation factor importance (SHAP):")
for name, importance in zip(feature_names, mean_abs_shap):
    print(f"  {name}: {importance:.2f}")

# Summary Plot
shap.summary_plot(shap_values, battery_data, show=False)
plt.title('SHAP Analysis of Battery Degradation Factors', fontsize=13, fontweight='bold')
plt.tight_layout()
plt.show()

print("\nPhysical Validity:")
print("- Temperature: Arrhenius equation predicts increased reaction rate at high temp ‚Üí Valid")
print("- Voltage: High voltage promotes side reactions ‚Üí Valid")
print("- Cycle Count: Repeated charge-discharge causes degradation ‚Üí Valid")
</code></pre>
</details>
<hr/>
<h2>4.6 XAI Environment and Practical Pitfalls</h2>
<h3>SHAP Library Version Management</h3>
<pre><code class="language-python"># Requirements:
# - Python 3.9+
# - lime&gt;=0.2.0
# - numpy&gt;=1.24.0, &lt;2.0.0
# - pandas&gt;=2.0.0, &lt;2.2.0
# - scikit-learn&gt;=1.3.0, &lt;1.5.0
# - shap&gt;=0.42.0

"""
Example: SHAP Library Version Management

Purpose: Demonstrate data visualization techniques
Target: Intermediate
Execution time: 2-5 seconds
Dependencies: None
"""

# Libraries needed for XAI
import sys
import shap
import lime
import sklearn
import pandas as pd
import numpy as np

xai_env_info = {
    'Python': sys.version,
    'NumPy': np.__version__,
    'Pandas': pd.__version__,
    'scikit-learn': sklearn.__version__,
    'SHAP': shap.__version__,
    'LIME': lime.__version__,
    'Date': '2025-10-19'
}

print("=== XAI Environment ===")
for key, value in xai_env_info.items():
    print(f"{key}: {value}")

# Recommended versions
print("\n„ÄêRecommended Environment„Äë")
recommended_xai = """
numpy==1.24.3
pandas==2.0.3
scikit-learn==1.3.0
shap==0.43.0
lime==0.2.0.1
matplotlib==3.7.2
"""
print(recommended_xai)

print("\n„ÄêInstallation Command„Äë")
print("```bash")
print("pip install shap==0.43.0 lime==0.2.0.1")
print("```")

print("\n„ÄêImportant Notes„Äë")
print("‚ö†Ô∏è SHAP frequently has API changes ‚Üí Version pinning recommended")
print("‚ö†Ô∏è TreeExplainer verified to work with scikit-learn 1.3 or later")
print("‚ö†Ô∏è Kernel SHAP difficult to compute with large datasets (&gt;10000 samples)")
</code></pre>
<h3>Practical Pitfalls in XAI</h3>
<pre><code class="language-python">print("=== Practical Pitfalls in XAI\n")

print("„ÄêPitfall 1: Misinterpretation of SHAP Values„Äë")
print("‚ùå Misconception: Large SHAP value = Large feature value")
print("‚Üí SHAP value represents 'contribution to prediction', not feature magnitude")

print("\n‚úÖ Correct Understanding:")
print("```python")
print("# SHAP value = How much this feature contributed to prediction")
print("# Even small feature values can have large SHAP values")
print("feature_value = 0.1  # Small value")
print("shap_value = 2.5     # Large influence")
print("# ‚Üí This feature is important despite small magnitude")
print("```")

print("\n„ÄêPitfall 2: Ignoring LIME's Locality„Äë")
print("‚ö†Ô∏è Generalizing LIME explanation from one sample to all")
print("‚Üí LIME's local linear approximation varies across samples")

print("\n‚úÖ Solution: Check consistency across multiple samples")
print("```python")
print("# Run LIME on 10 samples, check if important features agree")
print("for i in range(10):")
print("    explanation = lime_explainer.explain_instance(X[i], model.predict)")
print("    # Check if top 3 features match")
print("```")

print("\n„ÄêPitfall 3: Confusing Correlation and Causation„Äë")
print("‚ö†Ô∏è \"High SHAP value ‚Üí Changing this feature will change prediction\"")
print("‚Üí This is correlation, not causation")

print("\n‚úÖ Causation requires separate methods")
print("```python")
print("# XAI is correlation analysis")
print("# For causation, use:")
print("# - A/B testing")
print("# - Causal graphs (DAG)")
print("# - Propensity score matching")
print("```")

print("\n„ÄêPitfall 4: Overconfidence in Attention Visualization„Äë")
print("‚ö†Ô∏è High Attention = Model correctly focuses on this part")
print("‚Üí Not necessarily the correct reason")

print("\n‚úÖ Cross-validate with multiple methods")
print("```python")
print("# Check agreement between SHAP + LIME + Attention")
print("# Verify physical plausibility with domain experts")
print("```")

print("\n„ÄêPitfall 5: Ignoring Computational Cost at Scale„Äë")
print("‚ö†Ô∏è Running Kernel SHAP on 10000 samples")
print("‚Üí Computation time: Hours to days")

print("\n‚úÖ Choose method and sample size appropriately")
print("```python")
print("if len(X) &lt; 1000:")
print("    explainer = shap.KernelExplainer()  # Any model")
print("else:")
print("    # Use subsampling or TreeExplainer")
print("    X_sample = shap.sample(X, 1000)")
print("    explainer = shap.TreeExplainer()  # Fast")
print("```")
</code></pre>
<hr/>
<h2>Summary</h2>
<p>In this chapter, we learned the theory and practice of <strong>Explainable AI (XAI)</strong>.</p>
<p><strong>Key Points</strong>:</p>
<ol>
<li><strong>Black-Box Problem</strong>: High-accuracy models are hard to interpret ‚Üí XAI provides solutions</li>
<li><strong>SHAP</strong>: Fair feature contribution evaluation using Shapley values</li>
<li><strong>LIME</strong>: Generate explanations through local linear approximation</li>
<li><strong>Attention Visualization</strong>: Understand internal behavior of neural networks</li>
<li><strong>Real-World Applications</strong>: Success cases from Toyota, IBM, Citrine</li>
<li><strong>Career Path</strong>: Growing demand for materials data scientists, salaries ¬•7-25 million</li>
<li><strong>Environment Management</strong>: Version pinning for SHAP, LIME and computational cost management</li>
<li><strong>Practical Pitfalls</strong>: SHAP value misinterpretation, LIME locality, correlation vs causation, Attention overconfidence, computational cost</li>
</ol>
<p><strong>Series Summary</strong>:</p>
<ul>
<li><strong>Chapter 1</strong>: Data collection strategy and cleaning ‚Üí Prepare high-quality data</li>
<li><strong>Chapter 2</strong>: Feature engineering ‚Üí Reduce 200 dimensions to 20</li>
<li><strong>Chapter 3</strong>: Model selection and optimization ‚Üí Automatic optimization with Optuna</li>
<li><strong>Chapter 4</strong>: Explainable AI ‚Üí Physical interpretation of predictions</li>
</ul>
<p><strong>Next Steps</strong>:</p>
<ol>
<li>Apply full workflow to real datasets</li>
<li>Submit papers and contribute to OSS</li>
<li>Attend conferences and build networks</li>
<li>Develop career as materials data scientist</li>
</ol>
<hr/>
<h2>Chapter 4 Checklist</h2>
<h3>SHAP (SHapley Additive exPlanations)</h3>
<ul>
<li>[ ] <strong>Understanding SHAP Values</strong></li>
<li>[ ] Understand theoretical background of Shapley values (cooperative game theory)</li>
<li>[ ] Verify base value + sum of SHAP values = prediction</li>
<li>
<p>[ ] SHAP values are independent of feature magnitude (represent contribution)</p>
</li>
<li>
<p>[ ] <strong>Choosing SHAP Computation Methods</strong></p>
</li>
<li>[ ] Tree-based models ‚Üí TreeExplainer (fast, exact solution)</li>
<li>[ ] Any model ‚Üí KernelExplainer (slow, approximate solution)</li>
<li>
<p>[ ] Deep learning ‚Üí DeepExplainer or GradientExplainer</p>
</li>
<li>
<p>[ ] <strong>Global Interpretation</strong></p>
</li>
<li>[ ] Evaluate overall feature importance using mean(|SHAP values|)</li>
<li>[ ] Visualize distribution and influence direction with Summary Plot</li>
<li>
<p>[ ] Rank top important features with Bar Plot</p>
</li>
<li>
<p>[ ] <strong>Local Interpretation</strong></p>
</li>
<li>[ ] Explain prediction basis using SHAP values for individual samples</li>
<li>[ ] Visualize contribution from base value using Force Plot</li>
<li>
<p>[ ] Display cumulative contribution using Waterfall Plot</p>
</li>
<li>
<p>[ ] <strong>Dependence Plot</strong></p>
</li>
<li>[ ] Visualize relationship between feature value and SHAP value</li>
<li>[ ] Discover non-linear relationships</li>
<li>[ ] Identify interaction terms (interaction_index)</li>
</ul>
<h3>LIME (Local Interpretable Model-agnostic Explanations)</h3>
<ul>
<li>[ ] <strong>LIME Basic Understanding</strong></li>
<li>[ ] Understand how local linear approximation works</li>
<li>[ ] Random sampling around sample</li>
<li>
<p>[ ] Distance-based weighting</p>
</li>
<li>
<p>[ ] <strong>Tabular LIME</strong></p>
</li>
<li>[ ] Explain tabular data using LimeTabularExplainer</li>
<li>[ ] Specify number of important features with num_features argument</li>
<li>
<p>[ ] Explain individual predictions with explain_instance()</p>
</li>
<li>
<p>[ ] <strong>Recognize LIME Limitations</strong></p>
</li>
<li>[ ] Explanations are local, not global</li>
<li>[ ] Different explanations for different samples (no consistency)</li>
<li>
<p>[ ] Computational cost lower than SHAP</p>
</li>
<li>
<p>[ ] <strong>SHAP vs LIME Comparison</strong></p>
</li>
<li>[ ] Check agreement of important features between both methods</li>
<li>[ ] Correlation &gt; 0.7 indicates high reliability</li>
<li>[ ] Interpret carefully when results disagree</li>
</ul>
<h3>Attention Visualization (for NN/GNN)</h3>
<ul>
<li>[ ] <strong>Get Attention Weights</strong></li>
<li>[ ] Extract intermediate layer activations from neural networks</li>
<li>[ ] Visualize Attention mechanism weights</li>
<li>
<p>[ ] Analyze which inputs the model attends to</p>
</li>
<li>
<p>[ ] <strong>Grad-CAM-style Methods</strong></p>
</li>
<li>[ ] Compute gradient-based importance</li>
<li>[ ] Approximate feature importance using numerical differentiation</li>
<li>
<p>[ ] Specialized for neural networks</p>
</li>
<li>
<p>[ ] <strong>Application to Molecular Graphs</strong></p>
</li>
<li>[ ] Identify important atoms/bonds in GNN</li>
<li>[ ] Estimate reaction mechanisms with Attention</li>
<li>[ ] Verify chemical plausibility with experts</li>
</ul>
<h3>Learning Real-World Application Cases</h3>
<ul>
<li>[ ] <strong>Toyota: Materials Development</strong></li>
<li>[ ] Identify degradation factors with SHAP analysis</li>
<li>[ ] Visualize interactions between temperature, voltage, cycle count</li>
<li>
<p>[ ] 40% reduction in development time, 20% improvement in battery life</p>
</li>
<li>
<p>[ ] <strong>IBM Research: Automated Chemistry Experiments</strong></p>
</li>
<li>[ ] Predict reaction mechanisms with GNN + Attention</li>
<li>[ ] 95% reaction yield prediction accuracy</li>
<li>
<p>[ ] Discover novel reaction pathways</p>
</li>
<li>
<p>[ ] <strong>Citrine Informatics: SaaS Business</strong></p>
</li>
<li>[ ] Core technology: Explainable AI</li>
<li>[ ] Uncertainty quantification + SHAP</li>
<li>[ ] Deployed at Panasonic, 3M, Michelin</li>
</ul>
<h3>Building Career Path</h3>
<ul>
<li>[ ] <strong>Required Skillset</strong></li>
<li>[ ] Materials science expertise (degree recommended)</li>
<li>[ ] Machine learning and deep learning implementation skills</li>
<li>[ ] Master XAI methods (SHAP, LIME)</li>
<li>
<p>[ ] Python, scikit-learn, PyTorch/TensorFlow</p>
</li>
<li>
<p>[ ] <strong>Career Options</strong></p>
</li>
<li>[ ] Materials Data Scientist (Manufacturing R&amp;D)</li>
<li>[ ] XAI Researcher (Academia)</li>
<li>[ ] ML Engineer (Materials-specialized startup)</li>
<li>[ ] R&amp;D Manager (AI adoption)</li>
<li>
<p>[ ] Technical Consultant</p>
</li>
<li>
<p>[ ] <strong>Salary Goals</strong></p>
</li>
<li>[ ] Japan: Junior ¬•5-7M, Mid ¬•10-15M, Senior ¬•15-25M</li>
<li>[ ] US: $70-90K (Junior), $130-180K (Mid), $180-300K (Senior)</li>
<li>
<p>[ ] Improve salary through: Degree, papers, project success</p>
</li>
<li>
<p>[ ] <strong>Skill Development Strategy</strong></p>
</li>
<li>[ ] Strengthen materials science fundamentals (degree or self-study)</li>
<li>[ ] Practical ML/DL (Kaggle, GitHub)</li>
<li>[ ] Master XAI methods (this series)</li>
<li>[ ] Publish papers and contribute to OSS</li>
<li>[ ] Network at conferences and meetups</li>
</ul>
<h3>Avoiding Practical Pitfalls (XAI)</h3>
<ul>
<li>[ ] <strong>Correct SHAP Value Interpretation</strong></li>
<li>[ ] SHAP value ‚â† Feature magnitude</li>
<li>[ ] SHAP value = Contribution to prediction</li>
<li>
<p>[ ] Interpret as deviation from base value</p>
</li>
<li>
<p>[ ] <strong>Recognize LIME Locality</strong></p>
</li>
<li>[ ] Don't generalize explanation from one sample to all</li>
<li>[ ] Check consistency across multiple samples</li>
<li>
<p>[ ] Cross-validate with SHAP</p>
</li>
<li>
<p>[ ] <strong>Distinguish Correlation and Causation</strong></p>
</li>
<li>[ ] XAI is correlation analysis (not causal inference)</li>
<li>[ ] "High SHAP value ‚Üí Changing feature changes prediction" is a misconception</li>
<li>
<p>[ ] Use A/B tests and causal graphs for causation</p>
</li>
<li>
<p>[ ] <strong>Limitations of Attention Visualization</strong></p>
</li>
<li>[ ] High Attention ‚â† Necessarily correct reasoning</li>
<li>[ ] Cross-validate with multiple methods (SHAP + LIME + Attention)</li>
<li>
<p>[ ] Verify physical plausibility with experts</p>
</li>
<li>
<p>[ ] <strong>Manage Computational Cost</strong></p>
</li>
<li>[ ] Kernel SHAP: Recommended for &lt; 1000 samples</li>
<li>[ ] Tree SHAP: Fast even with tens of thousands of samples</li>
<li>[ ] For large data: Use subsampling or tree-based methods</li>
</ul>
<h3>XAI Quality Evaluation</h3>
<ul>
<li>[ ] <strong>Explanation Consistency</strong></li>
<li>[ ] SHAP vs LIME correlation &gt; 0.7</li>
<li>[ ] Important features agree across multiple samples</li>
<li>
<p>[ ] Physical interpretation matches ML interpretation</p>
</li>
<li>
<p>[ ] <strong>Physical Validity</strong></p>
</li>
<li>[ ] Verified by domain experts</li>
<li>[ ] Consistent with known physical laws</li>
<li>
<p>[ ] Aligned with experimental results</p>
</li>
<li>
<p>[ ] <strong>Practical Utility</strong></p>
</li>
<li>[ ] Can extract material design guidelines</li>
<li>[ ] Can inform experimental planning</li>
<li>[ ] Meets accountability requirements for papers and patents</li>
</ul>
<h3>Ensuring Reproducibility</h3>
<ul>
<li>[ ] <strong>Version Management</strong></li>
<li>[ ] Pin versions of SHAP and LIME</li>
<li>[ ] Watch for API changes (especially SHAP)</li>
<li>
<p>[ ] Document in requirements.txt</p>
</li>
<li>
<p>[ ] <strong>Unified Computational Environment</strong></p>
</li>
<li>[ ] Set random seeds (SHAP, LIME)</li>
<li>[ ] Fix parallel computation settings (n_jobs)</li>
<li>
<p>[ ] Docker environment recommended</p>
</li>
<li>
<p>[ ] <strong>Save Explanations</strong></p>
</li>
<li>[ ] Save SHAP values as NumPy arrays</li>
<li>[ ] Save visualizations as PNG/PDF</li>
<li>[ ] Convert explanation text to Markdown/LaTeX</li>
</ul>
<hr/>
<h2>References</h2>
<ol>
<li>
<p><strong>Lundberg, S. M. &amp; Lee, S. I.</strong> (2017). A unified approach to interpreting model predictions. <em>Advances in Neural Information Processing Systems</em>, 30, 4765-4774.</p>
</li>
<li>
<p><strong>Ribeiro, M. T., Singh, S., &amp; Guestrin, C.</strong> (2016). "Why should I trust you?": Explaining the predictions of any classifier. <em>Proceedings of the 22nd ACM SIGKDD</em>, 1135-1144. <a href="https://doi.org/10.1145/2939672.2939778">DOI: 10.1145/2939672.2939778</a></p>
</li>
<li>
<p><strong>Molnar, C.</strong> (2022). <em>Interpretable Machine Learning: A Guide for Making Black Box Models Explainable</em> (2nd ed.). <a href="https://christophm.github.io/interpretable-ml-book/">https://christophm.github.io/interpretable-ml-book/</a></p>
</li>
<li>
<p><strong>Vaswani, A., Shazeer, N., Parmar, N., et al.</strong> (2017). Attention is all you need. <em>Advances in Neural Information Processing Systems</em>, 30, 5998-6008.</p>
</li>
<li>
<p><strong>Citrine Informatics.</strong> (2023). Materials Informatics Platform. <a href="https://citrine.io/">https://citrine.io/</a></p>
</li>
</ol>
<hr/>
<p><a href="chapter-3.html">‚Üê Back to Chapter 3</a> | <a href="index.html">Back to Series Index</a></p>
<hr/>
<h2>Congratulations on Completing the Series!</h2>
<p>You have now acquired practical skills in data-driven materials science. We wish you continued success.</p>
<p><strong>Feedback and Questions</strong>:
- Email: yusuke.hashimoto.b8@tohoku.ac.jp
- GitHub: <a href="https://github.com/YusukeHashimotoPhD/AI_Homepage">AI_Homepage Repository</a></p>
<p><strong>Related Series</strong>:
- <a href="../bayesian-optimization-introduction/">Introduction to Bayesian Optimization</a>
- <a href="../active-learning-introduction/">Introduction to Active Learning</a>
- <a href="../gnn-introduction/">Introduction to Graph Neural Networks</a></p>
<div class="navigation">
<a class="nav-button" href="chapter-3.html">‚Üê Previous Chapter</a>
<a class="nav-button" href="index.html">Back to Series Index</a>
</div>
</main>
<section class="disclaimer">
<h3>Disclaimer</h3>
<ul>
<li>This content is provided for educational, research, and informational purposes only, and does not provide professional advice (legal, accounting, technical assurance, etc.).</li>
<li>This content and accompanying code examples are provided "AS IS" without any express or implied warranties, including but not limited to merchantability, fitness for a particular purpose, non-infringement, accuracy, completeness, operation, or safety.</li>
<li>The creators and Tohoku University assume no responsibility for the content, availability, or safety of external links, data, tools, or libraries provided by third parties.</li>
<li>The creators and Tohoku University shall not be liable for any direct, indirect, incidental, special, consequential, or punitive damages arising from the use, execution, or interpretation of this content, to the maximum extent permitted by applicable law.</li>
<li>The content of this material may be changed, updated, or discontinued without notice.</li>
<li>The copyright and license of this content follow the stated conditions (e.g., CC BY 4.0). The applicable license typically includes warranty disclaimers.</li>
</ul>
</section>
<footer>
<p><strong>Author</strong>: AI Terakoya Content Team</p>
<p><strong>Version</strong>: 1.0 | <strong>Created</strong>: 2025-10-17</p>
<p><strong>License</strong>: Creative Commons BY 4.0</p>
<p>¬© 2025 AI Terakoya. All rights reserved.</p>
</footer>
</body>
</html>
